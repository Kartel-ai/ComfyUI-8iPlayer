window.process = { env: { NODE_ENV: "production" } }; // or "development"

var Yw = Object.defineProperty, Hw = Object.defineProperties;
var Pw = Object.getOwnPropertyDescriptors;
var zd = Object.getOwnPropertySymbols;
var BI = Object.prototype.hasOwnProperty, xI = Object.prototype.propertyIsEnumerable;
var NI = Math.pow, DI = (t, e, r) => e in t ? Yw(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, Da = (t, e) => {
  for (var r in e || (e = {}))
    BI.call(e, r) && DI(t, r, e[r]);
  if (zd)
    for (var r of zd(e))
      xI.call(e, r) && DI(t, r, e[r]);
  return t;
}, Yr = (t, e) => Hw(t, Pw(e));
var GI = (t, e) => {
  var r = {};
  for (var u in t)
    BI.call(t, u) && e.indexOf(u) < 0 && (r[u] = t[u]);
  if (t != null && zd)
    for (var u of zd(t))
      e.indexOf(u) < 0 && xI.call(t, u) && (r[u] = t[u]);
  return r;
};
var Ca = (t, e, r) => new Promise((u, I) => {
  var E = (w) => {
    try {
      g(r.next(w));
    } catch (B) {
      I(B);
    }
  }, k = (w) => {
    try {
      g(r.throw(w));
    } catch (B) {
      I(B);
    }
  }, g = (w) => w.done ? u(w.value) : Promise.resolve(w.value).then(E, k);
  g((r = r.apply(t, e)).next());
});
import * as Wa from "three";
window.requestIdleCallback = window.requestIdleCallback || function(t) {
  var e = Date.now();
  return setTimeout(function() {
    t({
      didTimeout: !1,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - e));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(t) {
  clearTimeout(t);
};
var xy = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function Nf(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var km = { exports: {} };
/*! For license information please see dash.all.min.js.LICENSE.txt */
(function(t, e) {
  (function(r, u) {
    t.exports = u();
  })(self, function() {
    return function() {
      var r = { 5358: function(k, g, w) {
        var B = { "./af": 9066, "./af.js": 9066, "./ar": 1110, "./ar-dz": 4261, "./ar-dz.js": 4261, "./ar-kw": 7717, "./ar-kw.js": 7717, "./ar-ly": 7060, "./ar-ly.js": 7060, "./ar-ma": 2757, "./ar-ma.js": 2757, "./ar-ps": 8490, "./ar-ps.js": 8490, "./ar-sa": 735, "./ar-sa.js": 735, "./ar-tn": 5385, "./ar-tn.js": 5385, "./ar.js": 1110, "./az": 6190, "./az.js": 6190, "./be": 1448, "./be.js": 1448, "./bg": 7890, "./bg.js": 7890, "./bm": 6832, "./bm.js": 6832, "./bn": 7193, "./bn-bd": 196, "./bn-bd.js": 196, "./bn.js": 7193, "./bo": 6682, "./bo.js": 6682, "./br": 1133, "./br.js": 1133, "./bs": 1214, "./bs.js": 1214, "./ca": 7357, "./ca.js": 7357, "./cs": 1659, "./cs.js": 1659, "./cv": 3944, "./cv.js": 3944, "./cy": 9381, "./cy.js": 9381, "./da": 8782, "./da.js": 8782, "./de": 4722, "./de-at": 2170, "./de-at.js": 2170, "./de-ch": 1020, "./de-ch.js": 1020, "./de.js": 4722, "./dv": 9295, "./dv.js": 9295, "./el": 3372, "./el.js": 3372, "./en-au": 3797, "./en-au.js": 3797, "./en-ca": 8479, "./en-ca.js": 8479, "./en-gb": 4086, "./en-gb.js": 4086, "./en-ie": 3309, "./en-ie.js": 3309, "./en-il": 150, "./en-il.js": 150, "./en-in": 2332, "./en-in.js": 2332, "./en-nz": 2239, "./en-nz.js": 2239, "./en-sg": 5501, "./en-sg.js": 5501, "./eo": 325, "./eo.js": 325, "./es": 4049, "./es-do": 8143, "./es-do.js": 8143, "./es-mx": 1075, "./es-mx.js": 1075, "./es-us": 246, "./es-us.js": 246, "./es.js": 4049, "./et": 180, "./et.js": 180, "./eu": 9707, "./eu.js": 9707, "./fa": 4576, "./fa.js": 4576, "./fi": 3016, "./fi.js": 3016, "./fil": 2158, "./fil.js": 2158, "./fo": 5790, "./fo.js": 5790, "./fr": 5097, "./fr-ca": 8030, "./fr-ca.js": 8030, "./fr-ch": 3669, "./fr-ch.js": 3669, "./fr.js": 5097, "./fy": 8664, "./fy.js": 8664, "./ga": 409, "./ga.js": 409, "./gd": 4198, "./gd.js": 4198, "./gl": 2638, "./gl.js": 2638, "./gom-deva": 9871, "./gom-deva.js": 9871, "./gom-latn": 2624, "./gom-latn.js": 2624, "./gu": 2053, "./gu.js": 2053, "./he": 278, "./he.js": 278, "./hi": 8818, "./hi.js": 8818, "./hr": 9543, "./hr.js": 9543, "./hu": 4630, "./hu.js": 4630, "./hy-am": 2417, "./hy-am.js": 2417, "./id": 424, "./id.js": 424, "./is": 7213, "./is.js": 7213, "./it": 8, "./it-ch": 4354, "./it-ch.js": 4354, "./it.js": 8, "./ja": 6076, "./ja.js": 6076, "./jv": 7289, "./jv.js": 7289, "./ka": 6149, "./ka.js": 6149, "./kk": 2075, "./kk.js": 2075, "./km": 4001, "./km.js": 4001, "./kn": 4360, "./kn.js": 4360, "./ko": 5071, "./ko.js": 5071, "./ku": 1209, "./ku-kmr": 6882, "./ku-kmr.js": 6882, "./ku.js": 1209, "./ky": 4125, "./ky.js": 4125, "./lb": 8531, "./lb.js": 8531, "./lo": 5784, "./lo.js": 5784, "./lt": 4985, "./lt.js": 4985, "./lv": 1991, "./lv.js": 1991, "./me": 3507, "./me.js": 3507, "./mi": 6959, "./mi.js": 6959, "./mk": 7441, "./mk.js": 7441, "./ml": 9844, "./ml.js": 9844, "./mn": 4302, "./mn.js": 4302, "./mr": 1930, "./mr.js": 1930, "./ms": 4457, "./ms-my": 5748, "./ms-my.js": 5748, "./ms.js": 4457, "./mt": 3980, "./mt.js": 3980, "./my": 2639, "./my.js": 2639, "./nb": 5953, "./nb.js": 5953, "./ne": 5876, "./ne.js": 5876, "./nl": 7475, "./nl-be": 493, "./nl-be.js": 493, "./nl.js": 7475, "./nn": 9221, "./nn.js": 9221, "./oc-lnc": 6261, "./oc-lnc.js": 6261, "./pa-in": 4288, "./pa-in.js": 4288, "./pl": 5813, "./pl.js": 5813, "./pt": 2845, "./pt-br": 7078, "./pt-br.js": 7078, "./pt.js": 2845, "./ro": 6122, "./ro.js": 6122, "./ru": 936, "./ru.js": 936, "./sd": 2642, "./sd.js": 2642, "./se": 529, "./se.js": 529, "./si": 149, "./si.js": 149, "./sk": 2051, "./sk.js": 2051, "./sl": 5306, "./sl.js": 5306, "./sq": 4301, "./sq.js": 4301, "./sr": 2452, "./sr-cyrl": 555, "./sr-cyrl.js": 555, "./sr.js": 2452, "./ss": 395, "./ss.js": 395, "./sv": 4600, "./sv.js": 4600, "./sw": 6687, "./sw.js": 6687, "./ta": 5102, "./ta.js": 5102, "./te": 1298, "./te.js": 1298, "./tet": 9028, "./tet.js": 9028, "./tg": 8680, "./tg.js": 8680, "./th": 7093, "./th.js": 7093, "./tk": 2668, "./tk.js": 2668, "./tl-ph": 3890, "./tl-ph.js": 3890, "./tlh": 6717, "./tlh.js": 6717, "./tr": 6475, "./tr.js": 6475, "./tzl": 911, "./tzl.js": 911, "./tzm": 6552, "./tzm-latn": 8648, "./tzm-latn.js": 8648, "./tzm.js": 6552, "./ug-cn": 419, "./ug-cn.js": 419, "./uk": 6073, "./uk.js": 6073, "./ur": 210, "./ur.js": 210, "./uz": 9226, "./uz-latn": 4010, "./uz-latn.js": 4010, "./uz.js": 9226, "./vi": 3272, "./vi.js": 3272, "./x-pseudo": 8780, "./x-pseudo.js": 8780, "./yo": 6201, "./yo.js": 6201, "./zh-cn": 6893, "./zh-cn.js": 6893, "./zh-hk": 6977, "./zh-hk.js": 6977, "./zh-mo": 4068, "./zh-mo.js": 4068, "./zh-tw": 217, "./zh-tw.js": 217 };
        function c(m) {
          var b = d(m);
          return w(b);
        }
        function d(m) {
          if (!w.o(B, m)) {
            var b = new Error("Cannot find module '" + m + "'");
            throw b.code = "MODULE_NOT_FOUND", b;
          }
          return B[m];
        }
        c.keys = function() {
          return Object.keys(B);
        }, c.resolve = d, k.exports = c, c.id = 5358;
      }, 7267: function(k, g) {
        g.byteLength = function(T) {
          var n = b(T), o = n[0], l = n[1];
          return 3 * (o + l) / 4 - l;
        }, g.toByteArray = function(T) {
          var n, o, l = b(T), h = l[0], p = l[1], z = new c(function(Q, vt, Lt) {
            return 3 * (vt + Lt) / 4 - Lt;
          }(0, h, p)), Z = 0, V = p > 0 ? h - 4 : h;
          for (o = 0; o < V; o += 4) n = B[T.charCodeAt(o)] << 18 | B[T.charCodeAt(o + 1)] << 12 | B[T.charCodeAt(o + 2)] << 6 | B[T.charCodeAt(o + 3)], z[Z++] = n >> 16 & 255, z[Z++] = n >> 8 & 255, z[Z++] = 255 & n;
          return p === 2 && (n = B[T.charCodeAt(o)] << 2 | B[T.charCodeAt(o + 1)] >> 4, z[Z++] = 255 & n), p === 1 && (n = B[T.charCodeAt(o)] << 10 | B[T.charCodeAt(o + 1)] << 4 | B[T.charCodeAt(o + 2)] >> 2, z[Z++] = n >> 8 & 255, z[Z++] = 255 & n), z;
        }, g.fromByteArray = function(T) {
          for (var n, o = T.length, l = o % 3, h = [], p = 16383, z = 0, Z = o - l; z < Z; z += p) h.push(y(T, z, z + p > Z ? Z : z + p));
          return l === 1 ? (n = T[o - 1], h.push(w[n >> 2] + w[n << 4 & 63] + "==")) : l === 2 && (n = (T[o - 2] << 8) + T[o - 1], h.push(w[n >> 10] + w[n >> 4 & 63] + w[n << 2 & 63] + "=")), h.join("");
        };
        for (var w = [], B = [], c = typeof Uint8Array != "undefined" ? Uint8Array : Array, d = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", m = 0; m < 64; ++m) w[m] = d[m], B[d.charCodeAt(m)] = m;
        function b(T) {
          var n = T.length;
          if (n % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var o = T.indexOf("=");
          return o === -1 && (o = n), [o, o === n ? 0 : 4 - o % 4];
        }
        function y(T, n, o) {
          for (var l, h, p = [], z = n; z < o; z += 3) l = (T[z] << 16 & 16711680) + (T[z + 1] << 8 & 65280) + (255 & T[z + 2]), p.push(w[(h = l) >> 18 & 63] + w[h >> 12 & 63] + w[h >> 6 & 63] + w[63 & h]);
          return p.join("");
        }
        B[45] = 62, B[95] = 63;
      }, 44: function(k, g, w) {
        var B = w(7267), c = w(7986), d = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        g.Buffer = y, g.SlowBuffer = function(q) {
          return +q != q && (q = 0), y.alloc(+q);
        }, g.INSPECT_MAX_BYTES = 50;
        var m = 2147483647;
        function b(q) {
          if (q > m) throw new RangeError('The value "' + q + '" is invalid for option "size"');
          var tt = new Uint8Array(q);
          return Object.setPrototypeOf(tt, y.prototype), tt;
        }
        function y(q, tt, x) {
          if (typeof q == "number") {
            if (typeof tt == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return o(q);
          }
          return T(q, tt, x);
        }
        function T(q, tt, x) {
          if (typeof q == "string") return function(lt, Gt) {
            if (typeof Gt == "string" && Gt !== "" || (Gt = "utf8"), !y.isEncoding(Gt)) throw new TypeError("Unknown encoding: " + Gt);
            var ee = 0 | z(lt, Gt), Vt = b(ee), Jt = Vt.write(lt, Gt);
            return Jt !== ee && (Vt = Vt.slice(0, Jt)), Vt;
          }(q, tt);
          if (ArrayBuffer.isView(q)) return function(lt) {
            if (Nt(lt, Uint8Array)) {
              var Gt = new Uint8Array(lt);
              return h(Gt.buffer, Gt.byteOffset, Gt.byteLength);
            }
            return l(lt);
          }(q);
          if (q == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof q);
          if (Nt(q, ArrayBuffer) || q && Nt(q.buffer, ArrayBuffer) || typeof SharedArrayBuffer != "undefined" && (Nt(q, SharedArrayBuffer) || q && Nt(q.buffer, SharedArrayBuffer))) return h(q, tt, x);
          if (typeof q == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
          var U = q.valueOf && q.valueOf();
          if (U != null && U !== q) return y.from(U, tt, x);
          var pt = function(lt) {
            if (y.isBuffer(lt)) {
              var Gt = 0 | p(lt.length), ee = b(Gt);
              return ee.length === 0 || lt.copy(ee, 0, 0, Gt), ee;
            }
            return lt.length !== void 0 ? typeof lt.length != "number" || Ft(lt.length) ? b(0) : l(lt) : lt.type === "Buffer" && Array.isArray(lt.data) ? l(lt.data) : void 0;
          }(q);
          if (pt) return pt;
          if (typeof Symbol != "undefined" && Symbol.toPrimitive != null && typeof q[Symbol.toPrimitive] == "function") return y.from(q[Symbol.toPrimitive]("string"), tt, x);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof q);
        }
        function n(q) {
          if (typeof q != "number") throw new TypeError('"size" argument must be of type number');
          if (q < 0) throw new RangeError('The value "' + q + '" is invalid for option "size"');
        }
        function o(q) {
          return n(q), b(q < 0 ? 0 : 0 | p(q));
        }
        function l(q) {
          for (var tt = q.length < 0 ? 0 : 0 | p(q.length), x = b(tt), U = 0; U < tt; U += 1) x[U] = 255 & q[U];
          return x;
        }
        function h(q, tt, x) {
          if (tt < 0 || q.byteLength < tt) throw new RangeError('"offset" is outside of buffer bounds');
          if (q.byteLength < tt + (x || 0)) throw new RangeError('"length" is outside of buffer bounds');
          var U;
          return U = tt === void 0 && x === void 0 ? new Uint8Array(q) : x === void 0 ? new Uint8Array(q, tt) : new Uint8Array(q, tt, x), Object.setPrototypeOf(U, y.prototype), U;
        }
        function p(q) {
          if (q >= m) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + m.toString(16) + " bytes");
          return 0 | q;
        }
        function z(q, tt) {
          if (y.isBuffer(q)) return q.length;
          if (ArrayBuffer.isView(q) || Nt(q, ArrayBuffer)) return q.byteLength;
          if (typeof q != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof q);
          var x = q.length, U = arguments.length > 2 && arguments[2] === !0;
          if (!U && x === 0) return 0;
          for (var pt = !1; ; ) switch (tt) {
            case "ascii":
            case "latin1":
            case "binary":
              return x;
            case "utf8":
            case "utf-8":
              return Rn(q).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * x;
            case "hex":
              return x >>> 1;
            case "base64":
              return En(q).length;
            default:
              if (pt) return U ? -1 : Rn(q).length;
              tt = ("" + tt).toLowerCase(), pt = !0;
          }
        }
        function Z(q, tt, x) {
          var U = !1;
          if ((tt === void 0 || tt < 0) && (tt = 0), tt > this.length || ((x === void 0 || x > this.length) && (x = this.length), x <= 0) || (x >>>= 0) <= (tt >>>= 0)) return "";
          for (q || (q = "utf8"); ; ) switch (q) {
            case "hex":
              return Ce(this, tt, x);
            case "utf8":
            case "utf-8":
              return at(this, tt, x);
            case "ascii":
              return jt(this, tt, x);
            case "latin1":
            case "binary":
              return At(this, tt, x);
            case "base64":
              return Mt(this, tt, x);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ne(this, tt, x);
            default:
              if (U) throw new TypeError("Unknown encoding: " + q);
              q = (q + "").toLowerCase(), U = !0;
          }
        }
        function V(q, tt, x) {
          var U = q[tt];
          q[tt] = q[x], q[x] = U;
        }
        function Q(q, tt, x, U, pt) {
          if (q.length === 0) return -1;
          if (typeof x == "string" ? (U = x, x = 0) : x > 2147483647 ? x = 2147483647 : x < -2147483648 && (x = -2147483648), Ft(x = +x) && (x = pt ? 0 : q.length - 1), x < 0 && (x = q.length + x), x >= q.length) {
            if (pt) return -1;
            x = q.length - 1;
          } else if (x < 0) {
            if (!pt) return -1;
            x = 0;
          }
          if (typeof tt == "string" && (tt = y.from(tt, U)), y.isBuffer(tt)) return tt.length === 0 ? -1 : vt(q, tt, x, U, pt);
          if (typeof tt == "number") return tt &= 255, typeof Uint8Array.prototype.indexOf == "function" ? pt ? Uint8Array.prototype.indexOf.call(q, tt, x) : Uint8Array.prototype.lastIndexOf.call(q, tt, x) : vt(q, [tt], x, U, pt);
          throw new TypeError("val must be string, number or Buffer");
        }
        function vt(q, tt, x, U, pt) {
          var lt, Gt = 1, ee = q.length, Vt = tt.length;
          if (U !== void 0 && ((U = String(U).toLowerCase()) === "ucs2" || U === "ucs-2" || U === "utf16le" || U === "utf-16le")) {
            if (q.length < 2 || tt.length < 2) return -1;
            Gt = 2, ee /= 2, Vt /= 2, x /= 2;
          }
          function Jt(Qt, me) {
            return Gt === 1 ? Qt[me] : Qt.readUInt16BE(me * Gt);
          }
          if (pt) {
            var Ot = -1;
            for (lt = x; lt < ee; lt++) if (Jt(q, lt) === Jt(tt, Ot === -1 ? 0 : lt - Ot)) {
              if (Ot === -1 && (Ot = lt), lt - Ot + 1 === Vt) return Ot * Gt;
            } else Ot !== -1 && (lt -= lt - Ot), Ot = -1;
          } else for (x + Vt > ee && (x = ee - Vt), lt = x; lt >= 0; lt--) {
            for (var Kt = !0, ae = 0; ae < Vt; ae++) if (Jt(q, lt + ae) !== Jt(tt, ae)) {
              Kt = !1;
              break;
            }
            if (Kt) return lt;
          }
          return -1;
        }
        function Lt(q, tt, x, U) {
          x = Number(x) || 0;
          var pt = q.length - x;
          U ? (U = Number(U)) > pt && (U = pt) : U = pt;
          var lt = tt.length;
          U > lt / 2 && (U = lt / 2);
          for (var Gt = 0; Gt < U; ++Gt) {
            var ee = parseInt(tt.substr(2 * Gt, 2), 16);
            if (Ft(ee)) return Gt;
            q[x + Gt] = ee;
          }
          return Gt;
        }
        function zt(q, tt, x, U) {
          return Tn(Rn(tt, q.length - x), q, x, U);
        }
        function X(q, tt, x, U) {
          return Tn(function(pt) {
            for (var lt = [], Gt = 0; Gt < pt.length; ++Gt) lt.push(255 & pt.charCodeAt(Gt));
            return lt;
          }(tt), q, x, U);
        }
        function D(q, tt, x, U) {
          return Tn(En(tt), q, x, U);
        }
        function yt(q, tt, x, U) {
          return Tn(function(pt, lt) {
            for (var Gt, ee, Vt, Jt = [], Ot = 0; Ot < pt.length && !((lt -= 2) < 0); ++Ot) ee = (Gt = pt.charCodeAt(Ot)) >> 8, Vt = Gt % 256, Jt.push(Vt), Jt.push(ee);
            return Jt;
          }(tt, q.length - x), q, x, U);
        }
        function Mt(q, tt, x) {
          return tt === 0 && x === q.length ? B.fromByteArray(q) : B.fromByteArray(q.slice(tt, x));
        }
        function at(q, tt, x) {
          x = Math.min(q.length, x);
          for (var U = [], pt = tt; pt < x; ) {
            var lt, Gt, ee, Vt, Jt = q[pt], Ot = null, Kt = Jt > 239 ? 4 : Jt > 223 ? 3 : Jt > 191 ? 2 : 1;
            if (pt + Kt <= x) switch (Kt) {
              case 1:
                Jt < 128 && (Ot = Jt);
                break;
              case 2:
                (192 & (lt = q[pt + 1])) == 128 && (Vt = (31 & Jt) << 6 | 63 & lt) > 127 && (Ot = Vt);
                break;
              case 3:
                lt = q[pt + 1], Gt = q[pt + 2], (192 & lt) == 128 && (192 & Gt) == 128 && (Vt = (15 & Jt) << 12 | (63 & lt) << 6 | 63 & Gt) > 2047 && (Vt < 55296 || Vt > 57343) && (Ot = Vt);
                break;
              case 4:
                lt = q[pt + 1], Gt = q[pt + 2], ee = q[pt + 3], (192 & lt) == 128 && (192 & Gt) == 128 && (192 & ee) == 128 && (Vt = (15 & Jt) << 18 | (63 & lt) << 12 | (63 & Gt) << 6 | 63 & ee) > 65535 && Vt < 1114112 && (Ot = Vt);
            }
            Ot === null ? (Ot = 65533, Kt = 1) : Ot > 65535 && (Ot -= 65536, U.push(Ot >>> 10 & 1023 | 55296), Ot = 56320 | 1023 & Ot), U.push(Ot), pt += Kt;
          }
          return function(ae) {
            var Qt = ae.length;
            if (Qt <= Bt) return String.fromCharCode.apply(String, ae);
            for (var me = "", an = 0; an < Qt; ) me += String.fromCharCode.apply(String, ae.slice(an, an += Bt));
            return me;
          }(U);
        }
        g.kMaxLength = m, y.TYPED_ARRAY_SUPPORT = function() {
          try {
            var q = new Uint8Array(1), tt = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(tt, Uint8Array.prototype), Object.setPrototypeOf(q, tt), q.foo() === 42;
          } catch (x) {
            return !1;
          }
        }(), y.TYPED_ARRAY_SUPPORT || typeof console == "undefined" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(y.prototype, "parent", { enumerable: !0, get: function() {
          if (y.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(y.prototype, "offset", { enumerable: !0, get: function() {
          if (y.isBuffer(this)) return this.byteOffset;
        } }), y.poolSize = 8192, y.from = function(q, tt, x) {
          return T(q, tt, x);
        }, Object.setPrototypeOf(y.prototype, Uint8Array.prototype), Object.setPrototypeOf(y, Uint8Array), y.alloc = function(q, tt, x) {
          return function(U, pt, lt) {
            return n(U), U <= 0 ? b(U) : pt !== void 0 ? typeof lt == "string" ? b(U).fill(pt, lt) : b(U).fill(pt) : b(U);
          }(q, tt, x);
        }, y.allocUnsafe = function(q) {
          return o(q);
        }, y.allocUnsafeSlow = function(q) {
          return o(q);
        }, y.isBuffer = function(q) {
          return q != null && q._isBuffer === !0 && q !== y.prototype;
        }, y.compare = function(q, tt) {
          if (Nt(q, Uint8Array) && (q = y.from(q, q.offset, q.byteLength)), Nt(tt, Uint8Array) && (tt = y.from(tt, tt.offset, tt.byteLength)), !y.isBuffer(q) || !y.isBuffer(tt)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (q === tt) return 0;
          for (var x = q.length, U = tt.length, pt = 0, lt = Math.min(x, U); pt < lt; ++pt) if (q[pt] !== tt[pt]) {
            x = q[pt], U = tt[pt];
            break;
          }
          return x < U ? -1 : U < x ? 1 : 0;
        }, y.isEncoding = function(q) {
          switch (String(q).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, y.concat = function(q, tt) {
          if (!Array.isArray(q)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (q.length === 0) return y.alloc(0);
          var x;
          if (tt === void 0) for (tt = 0, x = 0; x < q.length; ++x) tt += q[x].length;
          var U = y.allocUnsafe(tt), pt = 0;
          for (x = 0; x < q.length; ++x) {
            var lt = q[x];
            if (Nt(lt, Uint8Array)) pt + lt.length > U.length ? y.from(lt).copy(U, pt) : Uint8Array.prototype.set.call(U, lt, pt);
            else {
              if (!y.isBuffer(lt)) throw new TypeError('"list" argument must be an Array of Buffers');
              lt.copy(U, pt);
            }
            pt += lt.length;
          }
          return U;
        }, y.byteLength = z, y.prototype._isBuffer = !0, y.prototype.swap16 = function() {
          var q = this.length;
          if (q % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var tt = 0; tt < q; tt += 2) V(this, tt, tt + 1);
          return this;
        }, y.prototype.swap32 = function() {
          var q = this.length;
          if (q % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var tt = 0; tt < q; tt += 4) V(this, tt, tt + 3), V(this, tt + 1, tt + 2);
          return this;
        }, y.prototype.swap64 = function() {
          var q = this.length;
          if (q % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var tt = 0; tt < q; tt += 8) V(this, tt, tt + 7), V(this, tt + 1, tt + 6), V(this, tt + 2, tt + 5), V(this, tt + 3, tt + 4);
          return this;
        }, y.prototype.toString = function() {
          var q = this.length;
          return q === 0 ? "" : arguments.length === 0 ? at(this, 0, q) : Z.apply(this, arguments);
        }, y.prototype.toLocaleString = y.prototype.toString, y.prototype.equals = function(q) {
          if (!y.isBuffer(q)) throw new TypeError("Argument must be a Buffer");
          return this === q || y.compare(this, q) === 0;
        }, y.prototype.inspect = function() {
          var q = "", tt = g.INSPECT_MAX_BYTES;
          return q = this.toString("hex", 0, tt).replace(/(.{2})/g, "$1 ").trim(), this.length > tt && (q += " ... "), "<Buffer " + q + ">";
        }, d && (y.prototype[d] = y.prototype.inspect), y.prototype.compare = function(q, tt, x, U, pt) {
          if (Nt(q, Uint8Array) && (q = y.from(q, q.offset, q.byteLength)), !y.isBuffer(q)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof q);
          if (tt === void 0 && (tt = 0), x === void 0 && (x = q ? q.length : 0), U === void 0 && (U = 0), pt === void 0 && (pt = this.length), tt < 0 || x > q.length || U < 0 || pt > this.length) throw new RangeError("out of range index");
          if (U >= pt && tt >= x) return 0;
          if (U >= pt) return -1;
          if (tt >= x) return 1;
          if (this === q) return 0;
          for (var lt = (pt >>>= 0) - (U >>>= 0), Gt = (x >>>= 0) - (tt >>>= 0), ee = Math.min(lt, Gt), Vt = this.slice(U, pt), Jt = q.slice(tt, x), Ot = 0; Ot < ee; ++Ot) if (Vt[Ot] !== Jt[Ot]) {
            lt = Vt[Ot], Gt = Jt[Ot];
            break;
          }
          return lt < Gt ? -1 : Gt < lt ? 1 : 0;
        }, y.prototype.includes = function(q, tt, x) {
          return this.indexOf(q, tt, x) !== -1;
        }, y.prototype.indexOf = function(q, tt, x) {
          return Q(this, q, tt, x, !0);
        }, y.prototype.lastIndexOf = function(q, tt, x) {
          return Q(this, q, tt, x, !1);
        }, y.prototype.write = function(q, tt, x, U) {
          if (tt === void 0) U = "utf8", x = this.length, tt = 0;
          else if (x === void 0 && typeof tt == "string") U = tt, x = this.length, tt = 0;
          else {
            if (!isFinite(tt)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            tt >>>= 0, isFinite(x) ? (x >>>= 0, U === void 0 && (U = "utf8")) : (U = x, x = void 0);
          }
          var pt = this.length - tt;
          if ((x === void 0 || x > pt) && (x = pt), q.length > 0 && (x < 0 || tt < 0) || tt > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          U || (U = "utf8");
          for (var lt = !1; ; ) switch (U) {
            case "hex":
              return Lt(this, q, tt, x);
            case "utf8":
            case "utf-8":
              return zt(this, q, tt, x);
            case "ascii":
            case "latin1":
            case "binary":
              return X(this, q, tt, x);
            case "base64":
              return D(this, q, tt, x);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return yt(this, q, tt, x);
            default:
              if (lt) throw new TypeError("Unknown encoding: " + U);
              U = ("" + U).toLowerCase(), lt = !0;
          }
        }, y.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var Bt = 4096;
        function jt(q, tt, x) {
          var U = "";
          x = Math.min(q.length, x);
          for (var pt = tt; pt < x; ++pt) U += String.fromCharCode(127 & q[pt]);
          return U;
        }
        function At(q, tt, x) {
          var U = "";
          x = Math.min(q.length, x);
          for (var pt = tt; pt < x; ++pt) U += String.fromCharCode(q[pt]);
          return U;
        }
        function Ce(q, tt, x) {
          var U = q.length;
          (!tt || tt < 0) && (tt = 0), (!x || x < 0 || x > U) && (x = U);
          for (var pt = "", lt = tt; lt < x; ++lt) pt += ve[q[lt]];
          return pt;
        }
        function ne(q, tt, x) {
          for (var U = q.slice(tt, x), pt = "", lt = 0; lt < U.length - 1; lt += 2) pt += String.fromCharCode(U[lt] + 256 * U[lt + 1]);
          return pt;
        }
        function Ht(q, tt, x) {
          if (q % 1 != 0 || q < 0) throw new RangeError("offset is not uint");
          if (q + tt > x) throw new RangeError("Trying to access beyond buffer length");
        }
        function Le(q, tt, x, U, pt, lt) {
          if (!y.isBuffer(q)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (tt > pt || tt < lt) throw new RangeError('"value" argument is out of bounds');
          if (x + U > q.length) throw new RangeError("Index out of range");
        }
        function sn(q, tt, x, U, pt, lt) {
          if (x + U > q.length) throw new RangeError("Index out of range");
          if (x < 0) throw new RangeError("Index out of range");
        }
        function we(q, tt, x, U, pt) {
          return tt = +tt, x >>>= 0, pt || sn(q, 0, x, 4), c.write(q, tt, x, U, 23, 4), x + 4;
        }
        function ln(q, tt, x, U, pt) {
          return tt = +tt, x >>>= 0, pt || sn(q, 0, x, 8), c.write(q, tt, x, U, 52, 8), x + 8;
        }
        y.prototype.slice = function(q, tt) {
          var x = this.length;
          (q = ~~q) < 0 ? (q += x) < 0 && (q = 0) : q > x && (q = x), (tt = tt === void 0 ? x : ~~tt) < 0 ? (tt += x) < 0 && (tt = 0) : tt > x && (tt = x), tt < q && (tt = q);
          var U = this.subarray(q, tt);
          return Object.setPrototypeOf(U, y.prototype), U;
        }, y.prototype.readUintLE = y.prototype.readUIntLE = function(q, tt, x) {
          q >>>= 0, tt >>>= 0, x || Ht(q, tt, this.length);
          for (var U = this[q], pt = 1, lt = 0; ++lt < tt && (pt *= 256); ) U += this[q + lt] * pt;
          return U;
        }, y.prototype.readUintBE = y.prototype.readUIntBE = function(q, tt, x) {
          q >>>= 0, tt >>>= 0, x || Ht(q, tt, this.length);
          for (var U = this[q + --tt], pt = 1; tt > 0 && (pt *= 256); ) U += this[q + --tt] * pt;
          return U;
        }, y.prototype.readUint8 = y.prototype.readUInt8 = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 1, this.length), this[q];
        }, y.prototype.readUint16LE = y.prototype.readUInt16LE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 2, this.length), this[q] | this[q + 1] << 8;
        }, y.prototype.readUint16BE = y.prototype.readUInt16BE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 2, this.length), this[q] << 8 | this[q + 1];
        }, y.prototype.readUint32LE = y.prototype.readUInt32LE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), (this[q] | this[q + 1] << 8 | this[q + 2] << 16) + 16777216 * this[q + 3];
        }, y.prototype.readUint32BE = y.prototype.readUInt32BE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), 16777216 * this[q] + (this[q + 1] << 16 | this[q + 2] << 8 | this[q + 3]);
        }, y.prototype.readIntLE = function(q, tt, x) {
          q >>>= 0, tt >>>= 0, x || Ht(q, tt, this.length);
          for (var U = this[q], pt = 1, lt = 0; ++lt < tt && (pt *= 256); ) U += this[q + lt] * pt;
          return U >= (pt *= 128) && (U -= Math.pow(2, 8 * tt)), U;
        }, y.prototype.readIntBE = function(q, tt, x) {
          q >>>= 0, tt >>>= 0, x || Ht(q, tt, this.length);
          for (var U = tt, pt = 1, lt = this[q + --U]; U > 0 && (pt *= 256); ) lt += this[q + --U] * pt;
          return lt >= (pt *= 128) && (lt -= Math.pow(2, 8 * tt)), lt;
        }, y.prototype.readInt8 = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 1, this.length), 128 & this[q] ? -1 * (255 - this[q] + 1) : this[q];
        }, y.prototype.readInt16LE = function(q, tt) {
          q >>>= 0, tt || Ht(q, 2, this.length);
          var x = this[q] | this[q + 1] << 8;
          return 32768 & x ? 4294901760 | x : x;
        }, y.prototype.readInt16BE = function(q, tt) {
          q >>>= 0, tt || Ht(q, 2, this.length);
          var x = this[q + 1] | this[q] << 8;
          return 32768 & x ? 4294901760 | x : x;
        }, y.prototype.readInt32LE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), this[q] | this[q + 1] << 8 | this[q + 2] << 16 | this[q + 3] << 24;
        }, y.prototype.readInt32BE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), this[q] << 24 | this[q + 1] << 16 | this[q + 2] << 8 | this[q + 3];
        }, y.prototype.readFloatLE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), c.read(this, q, !0, 23, 4);
        }, y.prototype.readFloatBE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 4, this.length), c.read(this, q, !1, 23, 4);
        }, y.prototype.readDoubleLE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 8, this.length), c.read(this, q, !0, 52, 8);
        }, y.prototype.readDoubleBE = function(q, tt) {
          return q >>>= 0, tt || Ht(q, 8, this.length), c.read(this, q, !1, 52, 8);
        }, y.prototype.writeUintLE = y.prototype.writeUIntLE = function(q, tt, x, U) {
          q = +q, tt >>>= 0, x >>>= 0, U || Le(this, q, tt, x, Math.pow(2, 8 * x) - 1, 0);
          var pt = 1, lt = 0;
          for (this[tt] = 255 & q; ++lt < x && (pt *= 256); ) this[tt + lt] = q / pt & 255;
          return tt + x;
        }, y.prototype.writeUintBE = y.prototype.writeUIntBE = function(q, tt, x, U) {
          q = +q, tt >>>= 0, x >>>= 0, U || Le(this, q, tt, x, Math.pow(2, 8 * x) - 1, 0);
          var pt = x - 1, lt = 1;
          for (this[tt + pt] = 255 & q; --pt >= 0 && (lt *= 256); ) this[tt + pt] = q / lt & 255;
          return tt + x;
        }, y.prototype.writeUint8 = y.prototype.writeUInt8 = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 1, 255, 0), this[tt] = 255 & q, tt + 1;
        }, y.prototype.writeUint16LE = y.prototype.writeUInt16LE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 2, 65535, 0), this[tt] = 255 & q, this[tt + 1] = q >>> 8, tt + 2;
        }, y.prototype.writeUint16BE = y.prototype.writeUInt16BE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 2, 65535, 0), this[tt] = q >>> 8, this[tt + 1] = 255 & q, tt + 2;
        }, y.prototype.writeUint32LE = y.prototype.writeUInt32LE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 4, 4294967295, 0), this[tt + 3] = q >>> 24, this[tt + 2] = q >>> 16, this[tt + 1] = q >>> 8, this[tt] = 255 & q, tt + 4;
        }, y.prototype.writeUint32BE = y.prototype.writeUInt32BE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 4, 4294967295, 0), this[tt] = q >>> 24, this[tt + 1] = q >>> 16, this[tt + 2] = q >>> 8, this[tt + 3] = 255 & q, tt + 4;
        }, y.prototype.writeIntLE = function(q, tt, x, U) {
          if (q = +q, tt >>>= 0, !U) {
            var pt = Math.pow(2, 8 * x - 1);
            Le(this, q, tt, x, pt - 1, -pt);
          }
          var lt = 0, Gt = 1, ee = 0;
          for (this[tt] = 255 & q; ++lt < x && (Gt *= 256); ) q < 0 && ee === 0 && this[tt + lt - 1] !== 0 && (ee = 1), this[tt + lt] = (q / Gt | 0) - ee & 255;
          return tt + x;
        }, y.prototype.writeIntBE = function(q, tt, x, U) {
          if (q = +q, tt >>>= 0, !U) {
            var pt = Math.pow(2, 8 * x - 1);
            Le(this, q, tt, x, pt - 1, -pt);
          }
          var lt = x - 1, Gt = 1, ee = 0;
          for (this[tt + lt] = 255 & q; --lt >= 0 && (Gt *= 256); ) q < 0 && ee === 0 && this[tt + lt + 1] !== 0 && (ee = 1), this[tt + lt] = (q / Gt | 0) - ee & 255;
          return tt + x;
        }, y.prototype.writeInt8 = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 1, 127, -128), q < 0 && (q = 255 + q + 1), this[tt] = 255 & q, tt + 1;
        }, y.prototype.writeInt16LE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 2, 32767, -32768), this[tt] = 255 & q, this[tt + 1] = q >>> 8, tt + 2;
        }, y.prototype.writeInt16BE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 2, 32767, -32768), this[tt] = q >>> 8, this[tt + 1] = 255 & q, tt + 2;
        }, y.prototype.writeInt32LE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 4, 2147483647, -2147483648), this[tt] = 255 & q, this[tt + 1] = q >>> 8, this[tt + 2] = q >>> 16, this[tt + 3] = q >>> 24, tt + 4;
        }, y.prototype.writeInt32BE = function(q, tt, x) {
          return q = +q, tt >>>= 0, x || Le(this, q, tt, 4, 2147483647, -2147483648), q < 0 && (q = 4294967295 + q + 1), this[tt] = q >>> 24, this[tt + 1] = q >>> 16, this[tt + 2] = q >>> 8, this[tt + 3] = 255 & q, tt + 4;
        }, y.prototype.writeFloatLE = function(q, tt, x) {
          return we(this, q, tt, !0, x);
        }, y.prototype.writeFloatBE = function(q, tt, x) {
          return we(this, q, tt, !1, x);
        }, y.prototype.writeDoubleLE = function(q, tt, x) {
          return ln(this, q, tt, !0, x);
        }, y.prototype.writeDoubleBE = function(q, tt, x) {
          return ln(this, q, tt, !1, x);
        }, y.prototype.copy = function(q, tt, x, U) {
          if (!y.isBuffer(q)) throw new TypeError("argument should be a Buffer");
          if (x || (x = 0), U || U === 0 || (U = this.length), tt >= q.length && (tt = q.length), tt || (tt = 0), U > 0 && U < x && (U = x), U === x || q.length === 0 || this.length === 0) return 0;
          if (tt < 0) throw new RangeError("targetStart out of bounds");
          if (x < 0 || x >= this.length) throw new RangeError("Index out of range");
          if (U < 0) throw new RangeError("sourceEnd out of bounds");
          U > this.length && (U = this.length), q.length - tt < U - x && (U = q.length - tt + x);
          var pt = U - x;
          return this === q && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(tt, x, U) : Uint8Array.prototype.set.call(q, this.subarray(x, U), tt), pt;
        }, y.prototype.fill = function(q, tt, x, U) {
          if (typeof q == "string") {
            if (typeof tt == "string" ? (U = tt, tt = 0, x = this.length) : typeof x == "string" && (U = x, x = this.length), U !== void 0 && typeof U != "string") throw new TypeError("encoding must be a string");
            if (typeof U == "string" && !y.isEncoding(U)) throw new TypeError("Unknown encoding: " + U);
            if (q.length === 1) {
              var pt = q.charCodeAt(0);
              (U === "utf8" && pt < 128 || U === "latin1") && (q = pt);
            }
          } else typeof q == "number" ? q &= 255 : typeof q == "boolean" && (q = Number(q));
          if (tt < 0 || this.length < tt || this.length < x) throw new RangeError("Out of range index");
          if (x <= tt) return this;
          var lt;
          if (tt >>>= 0, x = x === void 0 ? this.length : x >>> 0, q || (q = 0), typeof q == "number") for (lt = tt; lt < x; ++lt) this[lt] = q;
          else {
            var Gt = y.isBuffer(q) ? q : y.from(q, U), ee = Gt.length;
            if (ee === 0) throw new TypeError('The value "' + q + '" is invalid for argument "value"');
            for (lt = 0; lt < x - tt; ++lt) this[lt + tt] = Gt[lt % ee];
          }
          return this;
        };
        var _e = /[^+/0-9A-Za-z-_]/g;
        function Rn(q, tt) {
          var x;
          tt = tt || 1 / 0;
          for (var U = q.length, pt = null, lt = [], Gt = 0; Gt < U; ++Gt) {
            if ((x = q.charCodeAt(Gt)) > 55295 && x < 57344) {
              if (!pt) {
                if (x > 56319) {
                  (tt -= 3) > -1 && lt.push(239, 191, 189);
                  continue;
                }
                if (Gt + 1 === U) {
                  (tt -= 3) > -1 && lt.push(239, 191, 189);
                  continue;
                }
                pt = x;
                continue;
              }
              if (x < 56320) {
                (tt -= 3) > -1 && lt.push(239, 191, 189), pt = x;
                continue;
              }
              x = 65536 + (pt - 55296 << 10 | x - 56320);
            } else pt && (tt -= 3) > -1 && lt.push(239, 191, 189);
            if (pt = null, x < 128) {
              if ((tt -= 1) < 0) break;
              lt.push(x);
            } else if (x < 2048) {
              if ((tt -= 2) < 0) break;
              lt.push(x >> 6 | 192, 63 & x | 128);
            } else if (x < 65536) {
              if ((tt -= 3) < 0) break;
              lt.push(x >> 12 | 224, x >> 6 & 63 | 128, 63 & x | 128);
            } else {
              if (!(x < 1114112)) throw new Error("Invalid code point");
              if ((tt -= 4) < 0) break;
              lt.push(x >> 18 | 240, x >> 12 & 63 | 128, x >> 6 & 63 | 128, 63 & x | 128);
            }
          }
          return lt;
        }
        function En(q) {
          return B.toByteArray(function(tt) {
            if ((tt = (tt = tt.split("=")[0]).trim().replace(_e, "")).length < 2) return "";
            for (; tt.length % 4 != 0; ) tt += "=";
            return tt;
          }(q));
        }
        function Tn(q, tt, x, U) {
          for (var pt = 0; pt < U && !(pt + x >= tt.length || pt >= q.length); ++pt) tt[pt + x] = q[pt];
          return pt;
        }
        function Nt(q, tt) {
          return q instanceof tt || q != null && q.constructor != null && q.constructor.name != null && q.constructor.name === tt.name;
        }
        function Ft(q) {
          return q != q;
        }
        var ve = function() {
          for (var q = "0123456789abcdef", tt = new Array(256), x = 0; x < 16; ++x) for (var U = 16 * x, pt = 0; pt < 16; ++pt) tt[U + pt] = q[x] + q[pt];
          return tt;
        }();
      }, 6877: function(k, g) {
        var w = { parseBuffer: function(d) {
          return new B(d).parse();
        }, addBoxProcessor: function(d, m) {
          typeof d == "string" && typeof m == "function" && (c.prototype._boxProcessors[d] = m);
        }, createFile: function() {
          return new B();
        }, createBox: function(d, m, b) {
          var y = c.create(d);
          return m && m.append(y, b), y;
        }, createFullBox: function(d, m, b) {
          var y = w.createBox(d, m, b);
          return y.version = 0, y.flags = 0, y;
        }, Utils: {} };
        w.Utils.dataViewToString = function(d, m) {
          var b = m || "utf-8";
          if (typeof TextDecoder != "undefined") return new TextDecoder(b).decode(d);
          var y = [], T = 0;
          if (b === "utf-8") for (; T < d.byteLength; ) {
            var n = d.getUint8(T++);
            n < 128 || (n < 224 ? (n = (31 & n) << 6, n |= 63 & d.getUint8(T++)) : n < 240 ? (n = (15 & n) << 12, n |= (63 & d.getUint8(T++)) << 6, n |= 63 & d.getUint8(T++)) : (n = (7 & n) << 18, n |= (63 & d.getUint8(T++)) << 12, n |= (63 & d.getUint8(T++)) << 6, n |= 63 & d.getUint8(T++))), y.push(String.fromCharCode(n));
          }
          else for (; T < d.byteLength; ) y.push(String.fromCharCode(d.getUint8(T++)));
          return y.join("");
        }, w.Utils.utf8ToByteArray = function(d) {
          var m, b;
          if (typeof TextEncoder != "undefined") m = new TextEncoder().encode(d);
          else for (m = [], b = 0; b < d.length; ++b) {
            var y = d.charCodeAt(b);
            y < 128 ? m.push(y) : y < 2048 ? (m.push(192 | y >> 6), m.push(128 | 63 & y)) : y < 65536 ? (m.push(224 | y >> 12), m.push(128 | 63 & y >> 6), m.push(128 | 63 & y)) : (m.push(240 | y >> 18), m.push(128 | 63 & y >> 12), m.push(128 | 63 & y >> 6), m.push(128 | 63 & y));
          }
          return m;
        }, w.Utils.appendBox = function(d, m, b) {
          if (m._offset = d._cursor.offset, m._root = d._root ? d._root : d, m._raw = d._raw, m._parent = d, b !== -1) if (b != null) {
            var y, T = -1;
            if (typeof b == "number") T = b;
            else {
              if (typeof b == "string") y = b;
              else {
                if (typeof b != "object" || !b.type) return void d.boxes.push(m);
                y = b.type;
              }
              for (var n = 0; n < d.boxes.length; n++) if (y === d.boxes[n].type) {
                T = n + 1;
                break;
              }
            }
            d.boxes.splice(T, 0, m);
          } else d.boxes.push(m);
        }, g.parseBuffer = w.parseBuffer, g.addBoxProcessor = w.addBoxProcessor, g.createFile = w.createFile, g.createBox = w.createBox, g.createFullBox = w.createFullBox, g.Utils = w.Utils, w.Cursor = function(d) {
          this.offset = d === void 0 ? 0 : d;
        };
        var B = function(d) {
          this._cursor = new w.Cursor(), this.boxes = [], d && (this._raw = new DataView(d));
        };
        B.prototype.fetch = function(d) {
          var m = this.fetchAll(d, !0);
          return m.length ? m[0] : null;
        }, B.prototype.fetchAll = function(d, m) {
          var b = [];
          return B._sweep.call(this, d, b, m), b;
        }, B.prototype.parse = function() {
          for (this._cursor.offset = 0, this.boxes = []; this._cursor.offset < this._raw.byteLength; ) {
            var d = c.parse(this);
            if (d.type === void 0) break;
            this.boxes.push(d);
          }
          return this;
        }, B._sweep = function(d, m, b) {
          for (var y in this.type && this.type == d && m.push(this), this.boxes) {
            if (m.length && b) return;
            B._sweep.call(this.boxes[y], d, m, b);
          }
        }, B.prototype.write = function() {
          var d, m = 0;
          for (d = 0; d < this.boxes.length; d++) m += this.boxes[d].getLength(!1);
          var b = new Uint8Array(m);
          for (this._rawo = new DataView(b.buffer), this.bytes = b, this._cursor.offset = 0, d = 0; d < this.boxes.length; d++) this.boxes[d].write();
          return b.buffer;
        }, B.prototype.append = function(d, m) {
          w.Utils.appendBox(this, d, m);
        };
        var c = function() {
          this._cursor = new w.Cursor();
        };
        c.parse = function(d) {
          var m = new c();
          return m._offset = d._cursor.offset, m._root = d._root ? d._root : d, m._raw = d._raw, m._parent = d, m._parseBox(), d._cursor.offset = m._raw.byteOffset + m._raw.byteLength, m;
        }, c.create = function(d) {
          var m = new c();
          return m.type = d, m.boxes = [], m;
        }, c.prototype._boxContainers = ["dinf", "edts", "mdia", "meco", "mfra", "minf", "moof", "moov", "mvex", "stbl", "strk", "traf", "trak", "tref", "udta", "vttc", "sinf", "schi", "encv", "enca", "meta", "grpl", "prsl"], c.prototype._boxProcessors = {}, c.prototype._procField = function(d, m, b) {
          this._parsing ? this[d] = this._readField(m, b) : this._writeField(m, b, this[d]);
        }, c.prototype._procFieldArray = function(d, m, b, y) {
          var T;
          if (this._parsing) for (this[d] = [], T = 0; T < m; T++) this[d][T] = this._readField(b, y);
          else for (T = 0; T < this[d].length; T++) this._writeField(b, y, this[d][T]);
        }, c.prototype._procFullBox = function() {
          this._procField("version", "uint", 8), this._procField("flags", "uint", 24);
        }, c.prototype._procEntries = function(d, m, b) {
          var y;
          if (this._parsing) for (this[d] = [], y = 0; y < m; y++) this[d].push({}), b.call(this, this[d][y]);
          else for (y = 0; y < m; y++) b.call(this, this[d][y]);
        }, c.prototype._procSubEntries = function(d, m, b, y) {
          var T;
          if (this._parsing) for (d[m] = [], T = 0; T < b; T++) d[m].push({}), y.call(this, d[m][T]);
          else for (T = 0; T < b; T++) y.call(this, d[m][T]);
        }, c.prototype._procEntryField = function(d, m, b, y) {
          this._parsing ? d[m] = this._readField(b, y) : this._writeField(b, y, d[m]);
        }, c.prototype._procSubBoxes = function(d, m) {
          var b;
          if (this._parsing) for (this[d] = [], b = 0; b < m; b++) this[d].push(c.parse(this));
          else for (b = 0; b < m; b++) this._rawo ? this[d][b].write() : this.size += this[d][b].getLength();
        }, c.prototype._readField = function(d, m) {
          switch (d) {
            case "uint":
              return this._readUint(m);
            case "int":
              return this._readInt(m);
            case "template":
              return this._readTemplate(m);
            case "string":
              return m === -1 ? this._readTerminatedString() : this._readString(m);
            case "data":
              return this._readData(m);
            case "utf8":
              return this._readUTF8String();
            case "utf8string":
              return this._readUTF8TerminatedString();
            default:
              return -1;
          }
        }, c.prototype._readInt = function(d) {
          var m = null, b = this._cursor.offset - this._raw.byteOffset;
          switch (d) {
            case 8:
              m = this._raw.getInt8(b);
              break;
            case 16:
              m = this._raw.getInt16(b);
              break;
            case 32:
              m = this._raw.getInt32(b);
              break;
            case 64:
              var y = this._raw.getInt32(b), T = this._raw.getInt32(b + 4);
              m = y * Math.pow(2, 32) + T;
          }
          return this._cursor.offset += d >> 3, m;
        }, c.prototype._readUint = function(d) {
          var m, b, y = null, T = this._cursor.offset - this._raw.byteOffset;
          switch (d) {
            case 8:
              y = this._raw.getUint8(T);
              break;
            case 16:
              y = this._raw.getUint16(T);
              break;
            case 24:
              y = ((m = this._raw.getUint16(T)) << 8) + (b = this._raw.getUint8(T + 2));
              break;
            case 32:
              y = this._raw.getUint32(T);
              break;
            case 64:
              m = this._raw.getUint32(T), b = this._raw.getUint32(T + 4), y = m * Math.pow(2, 32) + b;
          }
          return this._cursor.offset += d >> 3, y;
        }, c.prototype._readString = function(d) {
          for (var m = "", b = 0; b < d; b++) {
            var y = this._readUint(8);
            m += String.fromCharCode(y);
          }
          return m;
        }, c.prototype._readTemplate = function(d) {
          return this._readUint(d / 2) + this._readUint(d / 2) / Math.pow(2, d / 2);
        }, c.prototype._readTerminatedString = function() {
          for (var d = ""; this._cursor.offset - this._offset < this._raw.byteLength; ) {
            var m = this._readUint(8);
            if (m === 0) break;
            d += String.fromCharCode(m);
          }
          return d;
        }, c.prototype._readData = function(d) {
          var m = d > 0 ? d : this._raw.byteLength - (this._cursor.offset - this._offset);
          if (m > 0) {
            var b = new Uint8Array(this._raw.buffer, this._cursor.offset, m);
            return this._cursor.offset += m, b;
          }
          return null;
        }, c.prototype._readUTF8String = function() {
          var d = this._raw.byteLength - (this._cursor.offset - this._offset), m = null;
          return d > 0 && (m = new DataView(this._raw.buffer, this._cursor.offset, d), this._cursor.offset += d), m && w.Utils.dataViewToString(m);
        }, c.prototype._readUTF8TerminatedString = function() {
          var d = this._raw.byteLength - (this._cursor.offset - this._offset), m = null;
          if (d > 0) {
            var b;
            for (m = new DataView(this._raw.buffer, this._cursor.offset, d), b = 0; b < d && m.getUint8(b) !== 0; b++) ;
            m = new DataView(this._raw.buffer, this._cursor.offset, b), this._cursor.offset += Math.min(b + 1, d);
          }
          return m && w.Utils.dataViewToString(m);
        }, c.prototype._parseBox = function() {
          if (this._parsing = !0, this._cursor.offset = this._offset, this._offset + 8 > this._raw.buffer.byteLength) this._root._incomplete = !0;
          else {
            switch (this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this.size) {
              case 0:
                this._raw = new DataView(this._raw.buffer, this._offset);
                break;
              case 1:
                this._offset + this.size > this._raw.buffer.byteLength ? (this._incomplete = !0, this._root._incomplete = !0) : this._raw = new DataView(this._raw.buffer, this._offset, this.largesize);
                break;
              default:
                this._offset + this.size > this._raw.buffer.byteLength ? (this._incomplete = !0, this._root._incomplete = !0) : this._raw = new DataView(this._raw.buffer, this._offset, this.size);
            }
            this._incomplete || (this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1 ? this._parseContainerBox() : this._data = this._readData());
          }
        }, c.prototype._parseFullBox = function() {
          this.version = this._readUint(8), this.flags = this._readUint(24);
        }, c.prototype._parseContainerBox = function() {
          for (this.boxes = []; this._cursor.offset - this._raw.byteOffset < this._raw.byteLength; ) this.boxes.push(c.parse(this));
        }, c.prototype.append = function(d, m) {
          w.Utils.appendBox(this, d, m);
        }, c.prototype.getLength = function() {
          if (this._parsing = !1, this._rawo = null, this.size = 0, this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1) for (var d = 0; d < this.boxes.length; d++) this.size += this.boxes[d].getLength();
          return this._data && this._writeData(this._data), this.size;
        }, c.prototype.write = function() {
          switch (this._parsing = !1, this._cursor.offset = this._parent._cursor.offset, this.size) {
            case 0:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.parent._rawo.byteLength - this._cursor.offset);
              break;
            case 1:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.largesize);
              break;
            default:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.size);
          }
          if (this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1) for (var d = 0; d < this.boxes.length; d++) this.boxes[d].write();
          return this._data && this._writeData(this._data), this._parent._cursor.offset += this.size, this.size;
        }, c.prototype._writeInt = function(d, m) {
          if (this._rawo) {
            var b = this._cursor.offset - this._rawo.byteOffset;
            switch (d) {
              case 8:
                this._rawo.setInt8(b, m);
                break;
              case 16:
                this._rawo.setInt16(b, m);
                break;
              case 32:
                this._rawo.setInt32(b, m);
                break;
              case 64:
                var y = Math.floor(m / Math.pow(2, 32)), T = m - y * Math.pow(2, 32);
                this._rawo.setUint32(b, y), this._rawo.setUint32(b + 4, T);
            }
            this._cursor.offset += d >> 3;
          } else this.size += d >> 3;
        }, c.prototype._writeUint = function(d, m) {
          if (this._rawo) {
            var b, y, T = this._cursor.offset - this._rawo.byteOffset;
            switch (d) {
              case 8:
                this._rawo.setUint8(T, m);
                break;
              case 16:
                this._rawo.setUint16(T, m);
                break;
              case 24:
                b = (16776960 & m) >> 8, y = 255 & m, this._rawo.setUint16(T, b), this._rawo.setUint8(T + 2, y);
                break;
              case 32:
                this._rawo.setUint32(T, m);
                break;
              case 64:
                y = m - (b = Math.floor(m / Math.pow(2, 32))) * Math.pow(2, 32), this._rawo.setUint32(T, b), this._rawo.setUint32(T + 4, y);
            }
            this._cursor.offset += d >> 3;
          } else this.size += d >> 3;
        }, c.prototype._writeString = function(d, m) {
          for (var b = 0; b < d; b++) this._writeUint(8, m.charCodeAt(b));
        }, c.prototype._writeTerminatedString = function(d) {
          if (d.length !== 0) {
            for (var m = 0; m < d.length; m++) this._writeUint(8, d.charCodeAt(m));
            this._writeUint(8, 0);
          }
        }, c.prototype._writeTemplate = function(d, m) {
          var b = Math.floor(m), y = (m - b) * Math.pow(2, d / 2);
          this._writeUint(d / 2, b), this._writeUint(d / 2, y);
        }, c.prototype._writeData = function(d) {
          if (d) if (this._rawo) {
            if (d instanceof Array) {
              for (var m = this._cursor.offset - this._rawo.byteOffset, b = 0; b < d.length; b++) this._rawo.setInt8(m + b, d[b]);
              this._cursor.offset += d.length;
            }
            d instanceof Uint8Array && (this._root.bytes.set(d, this._cursor.offset), this._cursor.offset += d.length);
          } else this.size += d.length;
        }, c.prototype._writeUTF8String = function(d) {
          var m = w.Utils.utf8ToByteArray(d);
          if (this._rawo) for (var b = new DataView(this._rawo.buffer, this._cursor.offset, m.length), y = 0; y < m.length; y++) b.setUint8(y, m[y]);
          else this.size += m.length;
        }, c.prototype._writeField = function(d, m, b) {
          switch (d) {
            case "uint":
              this._writeUint(m, b);
              break;
            case "int":
              this._writeInt(m, b);
              break;
            case "template":
              this._writeTemplate(m, b);
              break;
            case "string":
              m == -1 ? this._writeTerminatedString(b) : this._writeString(m, b);
              break;
            case "data":
              this._writeData(b);
              break;
            case "utf8":
              this._writeUTF8String(b);
          }
        }, c.prototype._boxProcessors.ardi = function() {
          this._procFullBox(), this._procField("audio_rendering_indication", "uint", 8);
        }, c.prototype._boxProcessors.avc1 = c.prototype._boxProcessors.avc2 = c.prototype._boxProcessors.avc3 = c.prototype._boxProcessors.avc4 = c.prototype._boxProcessors.hvc1 = c.prototype._boxProcessors.hev1 = c.prototype._boxProcessors.encv = function() {
          this._procFieldArray("reserved1", 6, "uint", 8), this._procField("data_reference_index", "uint", 16), this._procField("pre_defined1", "uint", 16), this._procField("reserved2", "uint", 16), this._procFieldArray("pre_defined2", 3, "uint", 32), this._procField("width", "uint", 16), this._procField("height", "uint", 16), this._procField("horizresolution", "template", 32), this._procField("vertresolution", "template", 32), this._procField("reserved3", "uint", 32), this._procField("frame_count", "uint", 16), this._procFieldArray("compressorname", 32, "uint", 8), this._procField("depth", "uint", 16), this._procField("pre_defined3", "int", 16), this._procField("config", "data", -1);
        }, c.prototype._boxProcessors.ctts = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(d) {
            this._procEntryField(d, "sample_count", "uint", 32), this._procEntryField(d, "sample_offset", this.version === 1 ? "int" : "uint", 32);
          });
        }, c.prototype._boxProcessors.dref = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procSubBoxes("entries", this.entry_count);
        }, c.prototype._boxProcessors.elng = function() {
          this._procFullBox(), this._procField("extended_language", "utf8string");
        }, c.prototype._boxProcessors.elst = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(d) {
            this._procEntryField(d, "segment_duration", "uint", this.version === 1 ? 64 : 32), this._procEntryField(d, "media_time", "int", this.version === 1 ? 64 : 32), this._procEntryField(d, "media_rate_integer", "int", 16), this._procEntryField(d, "media_rate_fraction", "int", 16);
          });
        }, c.prototype._boxProcessors.emsg = function() {
          this._procFullBox(), this.version == 1 ? (this._procField("timescale", "uint", 32), this._procField("presentation_time", "uint", 64), this._procField("event_duration", "uint", 32), this._procField("id", "uint", 32), this._procField("scheme_id_uri", "string", -1), this._procField("value", "string", -1)) : (this._procField("scheme_id_uri", "string", -1), this._procField("value", "string", -1), this._procField("timescale", "uint", 32), this._procField("presentation_time_delta", "uint", 32), this._procField("event_duration", "uint", 32), this._procField("id", "uint", 32)), this._procField("message_data", "data", -1);
        }, c.prototype._boxProcessors.free = c.prototype._boxProcessors.skip = function() {
          this._procField("data", "data", -1);
        }, c.prototype._boxProcessors.frma = function() {
          this._procField("data_format", "uint", 32);
        }, c.prototype._boxProcessors.ftyp = c.prototype._boxProcessors.styp = function() {
          this._procField("major_brand", "string", 4), this._procField("minor_version", "uint", 32);
          var d = -1;
          this._parsing && (d = (this._raw.byteLength - (this._cursor.offset - this._raw.byteOffset)) / 4), this._procFieldArray("compatible_brands", d, "string", 4);
        }, c.prototype._boxProcessors.hdlr = function() {
          this._procFullBox(), this._procField("pre_defined", "uint", 32), this._procField("handler_type", "string", 4), this._procFieldArray("reserved", 3, "uint", 32), this._procField("name", "string", -1);
        }, c.prototype._boxProcessors.imda = function() {
          this._procField("imda_identifier", "uint", 32), this._procField("data", "data", -1);
        }, c.prototype._boxProcessors.kind = function() {
          this._procFullBox(), this._procField("schemeURI", "utf8string"), this._procField("value", "utf8string");
        }, c.prototype._boxProcessors.labl = function() {
          this._procFullBox(), this.is_group_label = !!(1 & this.flags), this._procField("label_id", "uint", 16), this._procField("language", "utf8string"), this._procField("label", "utf8string");
        }, c.prototype._boxProcessors.mdat = function() {
          this._procField("data", "data", -1);
        }, c.prototype._boxProcessors.mdhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("timescale", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._parsing || typeof this.language != "string" || (this.language = this.language.charCodeAt(0) - 96 << 10 | this.language.charCodeAt(1) - 96 << 5 | this.language.charCodeAt(2) - 96), this._procField("language", "uint", 16), this._parsing && (this.language = String.fromCharCode(96 + (this.language >> 10 & 31), 96 + (this.language >> 5 & 31), 96 + (31 & this.language))), this._procField("pre_defined", "uint", 16);
        }, c.prototype._boxProcessors.mehd = function() {
          this._procFullBox(), this._procField("fragment_duration", "uint", this.version == 1 ? 64 : 32);
        }, c.prototype._boxProcessors.meta = function() {
          this._procFullBox();
        }, c.prototype._boxProcessors.mfhd = function() {
          this._procFullBox(), this._procField("sequence_number", "uint", 32);
        }, c.prototype._boxProcessors.mfro = function() {
          this._procFullBox(), this._procField("mfra_size", "uint", 32);
        }, c.prototype._boxProcessors.mp4a = c.prototype._boxProcessors.enca = function() {
          this._procFieldArray("reserved1", 6, "uint", 8), this._procField("data_reference_index", "uint", 16), this._procFieldArray("reserved2", 2, "uint", 32), this._procField("channelcount", "uint", 16), this._procField("samplesize", "uint", 16), this._procField("pre_defined", "uint", 16), this._procField("reserved3", "uint", 16), this._procField("samplerate", "template", 32), this._procField("esds", "data", -1);
        }, c.prototype._boxProcessors.mvhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("timescale", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._procField("rate", "template", 32), this._procField("volume", "template", 16), this._procField("reserved1", "uint", 16), this._procFieldArray("reserved2", 2, "uint", 32), this._procFieldArray("matrix", 9, "template", 32), this._procFieldArray("pre_defined", 6, "uint", 32), this._procField("next_track_ID", "uint", 32);
        }, c.prototype._boxProcessors.payl = function() {
          this._procField("cue_text", "utf8");
        }, c.prototype._boxProcessors.prft = function() {
          this._procFullBox(), this._procField("reference_track_ID", "uint", 32), this._procField("ntp_timestamp_sec", "uint", 32), this._procField("ntp_timestamp_frac", "uint", 32), this._procField("media_time", "uint", this.version == 1 ? 64 : 32);
        }, c.prototype._boxProcessors.prsl = function() {
          this._procFullBox(), this._procField("group_id", "uint", 32), this._procField("num_entities_in_group", "uint", 32), this._procEntries("entities", this.num_entities_in_group, function(d) {
            this._procEntryField(d, "entity_id", "uint", 32);
          }), 4096 & this.flags && this._procField("preselection_tag", "utf8string"), 8192 & this.flags && this._procField("selection_priority", "uint", 8), 16384 & this.flags && this._procField("interleaving_tag", "utf8string");
        }, c.prototype._boxProcessors.pssh = function() {
          this._procFullBox(), this._procFieldArray("SystemID", 16, "uint", 8), this._procField("DataSize", "uint", 32), this._procFieldArray("Data", this.DataSize, "uint", 8);
        }, c.prototype._boxProcessors.schm = function() {
          this._procFullBox(), this._procField("scheme_type", "uint", 32), this._procField("scheme_version", "uint", 32), 1 & this.flags && this._procField("scheme_uri", "string", -1);
        }, c.prototype._boxProcessors.sdtp = function() {
          this._procFullBox();
          var d = -1;
          this._parsing && (d = this._raw.byteLength - (this._cursor.offset - this._raw.byteOffset)), this._procFieldArray("sample_dependency_table", d, "uint", 8);
        }, c.prototype._boxProcessors.sidx = function() {
          this._procFullBox(), this._procField("reference_ID", "uint", 32), this._procField("timescale", "uint", 32), this._procField("earliest_presentation_time", "uint", this.version == 1 ? 64 : 32), this._procField("first_offset", "uint", this.version == 1 ? 64 : 32), this._procField("reserved", "uint", 16), this._procField("reference_count", "uint", 16), this._procEntries("references", this.reference_count, function(d) {
            this._parsing || (d.reference = (1 & d.reference_type) << 31, d.reference |= 2147483647 & d.referenced_size, d.sap = (1 & d.starts_with_SAP) << 31, d.sap |= (3 & d.SAP_type) << 28, d.sap |= 268435455 & d.SAP_delta_time), this._procEntryField(d, "reference", "uint", 32), this._procEntryField(d, "subsegment_duration", "uint", 32), this._procEntryField(d, "sap", "uint", 32), this._parsing && (d.reference_type = d.reference >> 31 & 1, d.referenced_size = 2147483647 & d.reference, d.starts_with_SAP = d.sap >> 31 & 1, d.SAP_type = d.sap >> 28 & 7, d.SAP_delta_time = 268435455 & d.sap);
          });
        }, c.prototype._boxProcessors.smhd = function() {
          this._procFullBox(), this._procField("balance", "uint", 16), this._procField("reserved", "uint", 16);
        }, c.prototype._boxProcessors.ssix = function() {
          this._procFullBox(), this._procField("subsegment_count", "uint", 32), this._procEntries("subsegments", this.subsegment_count, function(d) {
            this._procEntryField(d, "ranges_count", "uint", 32), this._procSubEntries(d, "ranges", d.ranges_count, function(m) {
              this._procEntryField(m, "level", "uint", 8), this._procEntryField(m, "range_size", "uint", 24);
            });
          });
        }, c.prototype._boxProcessors.stsd = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procSubBoxes("entries", this.entry_count);
        }, c.prototype._boxProcessors.sttg = function() {
          this._procField("settings", "utf8");
        }, c.prototype._boxProcessors.stts = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(d) {
            this._procEntryField(d, "sample_count", "uint", 32), this._procEntryField(d, "sample_delta", "uint", 32);
          });
        }, c.prototype._boxProcessors.subs = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(d) {
            this._procEntryField(d, "sample_delta", "uint", 32), this._procEntryField(d, "subsample_count", "uint", 16), this._procSubEntries(d, "subsamples", d.subsample_count, function(m) {
              this._procEntryField(m, "subsample_size", "uint", this.version === 1 ? 32 : 16), this._procEntryField(m, "subsample_priority", "uint", 8), this._procEntryField(m, "discardable", "uint", 8), this._procEntryField(m, "codec_specific_parameters", "uint", 32);
            });
          });
        }, c.prototype._boxProcessors.tenc = function() {
          this._procFullBox(), this._procField("default_IsEncrypted", "uint", 24), this._procField("default_IV_size", "uint", 8), this._procFieldArray("default_KID", 16, "uint", 8);
        }, c.prototype._boxProcessors.tfdt = function() {
          this._procFullBox(), this._procField("baseMediaDecodeTime", "uint", this.version == 1 ? 64 : 32);
        }, c.prototype._boxProcessors.tfhd = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), 1 & this.flags && this._procField("base_data_offset", "uint", 64), 2 & this.flags && this._procField("sample_description_offset", "uint", 32), 8 & this.flags && this._procField("default_sample_duration", "uint", 32), 16 & this.flags && this._procField("default_sample_size", "uint", 32), 32 & this.flags && this._procField("default_sample_flags", "uint", 32);
        }, c.prototype._boxProcessors.tfra = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), this._parsing || (this.reserved = 0, this.reserved |= (48 & this.length_size_of_traf_num) << 4, this.reserved |= (12 & this.length_size_of_trun_num) << 2, this.reserved |= 3 & this.length_size_of_sample_num), this._procField("reserved", "uint", 32), this._parsing && (this.length_size_of_traf_num = (48 & this.reserved) >> 4, this.length_size_of_trun_num = (12 & this.reserved) >> 2, this.length_size_of_sample_num = 3 & this.reserved), this._procField("number_of_entry", "uint", 32), this._procEntries("entries", this.number_of_entry, function(d) {
            this._procEntryField(d, "time", "uint", this.version === 1 ? 64 : 32), this._procEntryField(d, "moof_offset", "uint", this.version === 1 ? 64 : 32), this._procEntryField(d, "traf_number", "uint", 8 * (this.length_size_of_traf_num + 1)), this._procEntryField(d, "trun_number", "uint", 8 * (this.length_size_of_trun_num + 1)), this._procEntryField(d, "sample_number", "uint", 8 * (this.length_size_of_sample_num + 1));
          });
        }, c.prototype._boxProcessors.tkhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("track_ID", "uint", 32), this._procField("reserved1", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._procFieldArray("reserved2", 2, "uint", 32), this._procField("layer", "uint", 16), this._procField("alternate_group", "uint", 16), this._procField("volume", "template", 16), this._procField("reserved3", "uint", 16), this._procFieldArray("matrix", 9, "template", 32), this._procField("width", "template", 32), this._procField("height", "template", 32);
        }, c.prototype._boxProcessors.trex = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), this._procField("default_sample_description_index", "uint", 32), this._procField("default_sample_duration", "uint", 32), this._procField("default_sample_size", "uint", 32), this._procField("default_sample_flags", "uint", 32);
        }, c.prototype._boxProcessors.trun = function() {
          this._procFullBox(), this._procField("sample_count", "uint", 32), 1 & this.flags && this._procField("data_offset", "int", 32), 4 & this.flags && this._procField("first_sample_flags", "uint", 32), this._procEntries("samples", this.sample_count, function(d) {
            256 & this.flags && this._procEntryField(d, "sample_duration", "uint", 32), 512 & this.flags && this._procEntryField(d, "sample_size", "uint", 32), 1024 & this.flags && this._procEntryField(d, "sample_flags", "uint", 32), 2048 & this.flags && this._procEntryField(d, "sample_composition_time_offset", this.version === 1 ? "int" : "uint", 32);
          });
        }, c.prototype._boxProcessors["url "] = c.prototype._boxProcessors["urn "] = function() {
          this._procFullBox(), this.type === "urn " && this._procField("name", "string", -1), this._procField("location", "string", -1);
        }, c.prototype._boxProcessors.vlab = function() {
          this._procField("source_label", "utf8");
        }, c.prototype._boxProcessors.vmhd = function() {
          this._procFullBox(), this._procField("graphicsmode", "uint", 16), this._procFieldArray("opcolor", 3, "uint", 16);
        }, c.prototype._boxProcessors.vttC = function() {
          this._procField("config", "utf8");
        }, c.prototype._boxProcessors.vtte = function() {
        };
      }, 9826: function(k) {
        var g, w = typeof Reflect == "object" ? Reflect : null, B = w && typeof w.apply == "function" ? w.apply : function(Z, V, Q) {
          return Function.prototype.apply.call(Z, V, Q);
        };
        g = w && typeof w.ownKeys == "function" ? w.ownKeys : Object.getOwnPropertySymbols ? function(Z) {
          return Object.getOwnPropertyNames(Z).concat(Object.getOwnPropertySymbols(Z));
        } : function(Z) {
          return Object.getOwnPropertyNames(Z);
        };
        var c = Number.isNaN || function(Z) {
          return Z != Z;
        };
        function d() {
          d.init.call(this);
        }
        k.exports = d, k.exports.once = function(Z, V) {
          return new Promise(function(Q, vt) {
            function Lt(X) {
              Z.removeListener(V, zt), vt(X);
            }
            function zt() {
              typeof Z.removeListener == "function" && Z.removeListener("error", Lt), Q([].slice.call(arguments));
            }
            z(Z, V, zt, { once: !0 }), V !== "error" && function(X, D) {
              typeof X.on == "function" && z(X, "error", D, { once: !0 });
            }(Z, Lt);
          });
        }, d.EventEmitter = d, d.prototype._events = void 0, d.prototype._eventsCount = 0, d.prototype._maxListeners = void 0;
        var m = 10;
        function b(Z) {
          if (typeof Z != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Z);
        }
        function y(Z) {
          return Z._maxListeners === void 0 ? d.defaultMaxListeners : Z._maxListeners;
        }
        function T(Z, V, Q, vt) {
          var Lt, zt, X, D;
          if (b(Q), (zt = Z._events) === void 0 ? (zt = Z._events = /* @__PURE__ */ Object.create(null), Z._eventsCount = 0) : (zt.newListener !== void 0 && (Z.emit("newListener", V, Q.listener ? Q.listener : Q), zt = Z._events), X = zt[V]), X === void 0) X = zt[V] = Q, ++Z._eventsCount;
          else if (typeof X == "function" ? X = zt[V] = vt ? [Q, X] : [X, Q] : vt ? X.unshift(Q) : X.push(Q), (Lt = y(Z)) > 0 && X.length > Lt && !X.warned) {
            X.warned = !0;
            var yt = new Error("Possible EventEmitter memory leak detected. " + X.length + " " + String(V) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            yt.name = "MaxListenersExceededWarning", yt.emitter = Z, yt.type = V, yt.count = X.length, D = yt, console && console.warn && console.warn(D);
          }
          return Z;
        }
        function n() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function o(Z, V, Q) {
          var vt = { fired: !1, wrapFn: void 0, target: Z, type: V, listener: Q }, Lt = n.bind(vt);
          return Lt.listener = Q, vt.wrapFn = Lt, Lt;
        }
        function l(Z, V, Q) {
          var vt = Z._events;
          if (vt === void 0) return [];
          var Lt = vt[V];
          return Lt === void 0 ? [] : typeof Lt == "function" ? Q ? [Lt.listener || Lt] : [Lt] : Q ? function(zt) {
            for (var X = new Array(zt.length), D = 0; D < X.length; ++D) X[D] = zt[D].listener || zt[D];
            return X;
          }(Lt) : p(Lt, Lt.length);
        }
        function h(Z) {
          var V = this._events;
          if (V !== void 0) {
            var Q = V[Z];
            if (typeof Q == "function") return 1;
            if (Q !== void 0) return Q.length;
          }
          return 0;
        }
        function p(Z, V) {
          for (var Q = new Array(V), vt = 0; vt < V; ++vt) Q[vt] = Z[vt];
          return Q;
        }
        function z(Z, V, Q, vt) {
          if (typeof Z.on == "function") vt.once ? Z.once(V, Q) : Z.on(V, Q);
          else {
            if (typeof Z.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Z);
            Z.addEventListener(V, function Lt(zt) {
              vt.once && Z.removeEventListener(V, Lt), Q(zt);
            });
          }
        }
        Object.defineProperty(d, "defaultMaxListeners", { enumerable: !0, get: function() {
          return m;
        }, set: function(Z) {
          if (typeof Z != "number" || Z < 0 || c(Z)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Z + ".");
          m = Z;
        } }), d.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, d.prototype.setMaxListeners = function(Z) {
          if (typeof Z != "number" || Z < 0 || c(Z)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Z + ".");
          return this._maxListeners = Z, this;
        }, d.prototype.getMaxListeners = function() {
          return y(this);
        }, d.prototype.emit = function(Z) {
          for (var V = [], Q = 1; Q < arguments.length; Q++) V.push(arguments[Q]);
          var vt = Z === "error", Lt = this._events;
          if (Lt !== void 0) vt = vt && Lt.error === void 0;
          else if (!vt) return !1;
          if (vt) {
            var zt;
            if (V.length > 0 && (zt = V[0]), zt instanceof Error) throw zt;
            var X = new Error("Unhandled error." + (zt ? " (" + zt.message + ")" : ""));
            throw X.context = zt, X;
          }
          var D = Lt[Z];
          if (D === void 0) return !1;
          if (typeof D == "function") B(D, this, V);
          else {
            var yt = D.length, Mt = p(D, yt);
            for (Q = 0; Q < yt; ++Q) B(Mt[Q], this, V);
          }
          return !0;
        }, d.prototype.addListener = function(Z, V) {
          return T(this, Z, V, !1);
        }, d.prototype.on = d.prototype.addListener, d.prototype.prependListener = function(Z, V) {
          return T(this, Z, V, !0);
        }, d.prototype.once = function(Z, V) {
          return b(V), this.on(Z, o(this, Z, V)), this;
        }, d.prototype.prependOnceListener = function(Z, V) {
          return b(V), this.prependListener(Z, o(this, Z, V)), this;
        }, d.prototype.removeListener = function(Z, V) {
          var Q, vt, Lt, zt, X;
          if (b(V), (vt = this._events) === void 0) return this;
          if ((Q = vt[Z]) === void 0) return this;
          if (Q === V || Q.listener === V) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete vt[Z], vt.removeListener && this.emit("removeListener", Z, Q.listener || V));
          else if (typeof Q != "function") {
            for (Lt = -1, zt = Q.length - 1; zt >= 0; zt--) if (Q[zt] === V || Q[zt].listener === V) {
              X = Q[zt].listener, Lt = zt;
              break;
            }
            if (Lt < 0) return this;
            Lt === 0 ? Q.shift() : function(D, yt) {
              for (; yt + 1 < D.length; yt++) D[yt] = D[yt + 1];
              D.pop();
            }(Q, Lt), Q.length === 1 && (vt[Z] = Q[0]), vt.removeListener !== void 0 && this.emit("removeListener", Z, X || V);
          }
          return this;
        }, d.prototype.off = d.prototype.removeListener, d.prototype.removeAllListeners = function(Z) {
          var V, Q, vt;
          if ((Q = this._events) === void 0) return this;
          if (Q.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Q[Z] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Q[Z]), this;
          if (arguments.length === 0) {
            var Lt, zt = Object.keys(Q);
            for (vt = 0; vt < zt.length; ++vt) (Lt = zt[vt]) !== "removeListener" && this.removeAllListeners(Lt);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (V = Q[Z]) == "function") this.removeListener(Z, V);
          else if (V !== void 0) for (vt = V.length - 1; vt >= 0; vt--) this.removeListener(Z, V[vt]);
          return this;
        }, d.prototype.listeners = function(Z) {
          return l(this, Z, !0);
        }, d.prototype.rawListeners = function(Z) {
          return l(this, Z, !1);
        }, d.listenerCount = function(Z, V) {
          return typeof Z.listenerCount == "function" ? Z.listenerCount(V) : h.call(Z, V);
        }, d.prototype.listenerCount = h, d.prototype.eventNames = function() {
          return this._eventsCount > 0 ? g(this._events) : [];
        };
      }, 7316: function(k) {
        k.exports = function g(w, B) {
          if (w === B) return !0;
          if (w && B && typeof w == "object" && typeof B == "object") {
            if (w.constructor !== B.constructor) return !1;
            var c, d, m;
            if (Array.isArray(w)) {
              if ((c = w.length) != B.length) return !1;
              for (d = c; d-- != 0; ) if (!g(w[d], B[d])) return !1;
              return !0;
            }
            if (w.constructor === RegExp) return w.source === B.source && w.flags === B.flags;
            if (w.valueOf !== Object.prototype.valueOf) return w.valueOf() === B.valueOf();
            if (w.toString !== Object.prototype.toString) return w.toString() === B.toString();
            if ((c = (m = Object.keys(w)).length) !== Object.keys(B).length) return !1;
            for (d = c; d-- != 0; ) if (!Object.prototype.hasOwnProperty.call(B, m[d])) return !1;
            for (d = c; d-- != 0; ) {
              var b = m[d];
              if (!g(w[b], B[b])) return !1;
            }
            return !0;
          }
          return w != w && B != B;
        };
      }, 7986: function(k, g) {
        g.read = function(w, B, c, d, m) {
          var b, y, T = 8 * m - d - 1, n = (1 << T) - 1, o = n >> 1, l = -7, h = c ? m - 1 : 0, p = c ? -1 : 1, z = w[B + h];
          for (h += p, b = z & (1 << -l) - 1, z >>= -l, l += T; l > 0; b = 256 * b + w[B + h], h += p, l -= 8) ;
          for (y = b & (1 << -l) - 1, b >>= -l, l += d; l > 0; y = 256 * y + w[B + h], h += p, l -= 8) ;
          if (b === 0) b = 1 - o;
          else {
            if (b === n) return y ? NaN : 1 / 0 * (z ? -1 : 1);
            y += Math.pow(2, d), b -= o;
          }
          return (z ? -1 : 1) * y * Math.pow(2, b - d);
        }, g.write = function(w, B, c, d, m, b) {
          var y, T, n, o = 8 * b - m - 1, l = (1 << o) - 1, h = l >> 1, p = m === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, z = d ? 0 : b - 1, Z = d ? 1 : -1, V = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
          for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (T = isNaN(B) ? 1 : 0, y = l) : (y = Math.floor(Math.log(B) / Math.LN2), B * (n = Math.pow(2, -y)) < 1 && (y--, n *= 2), (B += y + h >= 1 ? p / n : p * Math.pow(2, 1 - h)) * n >= 2 && (y++, n /= 2), y + h >= l ? (T = 0, y = l) : y + h >= 1 ? (T = (B * n - 1) * Math.pow(2, m), y += h) : (T = B * Math.pow(2, h - 1) * Math.pow(2, m), y = 0)); m >= 8; w[c + z] = 255 & T, z += Z, T /= 256, m -= 8) ;
          for (y = y << m | T, o += m; o > 0; w[c + z] = 255 & y, z += Z, y /= 256, o -= 8) ;
          w[c + z - Z] |= 128 * V;
        };
      }, 5474: function(k, g, w) {
        (function(B) {
          B.parser = function(x, U) {
            return new m(x, U);
          }, B.SAXParser = m, B.SAXStream = y, B.createStream = function(x, U) {
            return new y(x, U);
          }, B.MAX_BUFFER_LENGTH = 65536;
          var c, d = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
          function m(x, U) {
            if (!(this instanceof m)) return new m(x, U);
            var pt = this;
            (function(lt) {
              for (var Gt = 0, ee = d.length; Gt < ee; Gt++) lt[d[Gt]] = "";
            })(pt), pt.q = pt.c = "", pt.bufferCheckPosition = B.MAX_BUFFER_LENGTH, pt.opt = U || {}, pt.opt.lowercase = pt.opt.lowercase || pt.opt.lowercasetags, pt.looseCase = pt.opt.lowercase ? "toLowerCase" : "toUpperCase", pt.tags = [], pt.closed = pt.closedRoot = pt.sawRoot = !1, pt.tag = pt.error = null, pt.strict = !!x, pt.noscript = !(!x && !pt.opt.noscript), pt.state = At.BEGIN, pt.strictEntities = pt.opt.strictEntities, pt.ENTITIES = pt.strictEntities ? Object.create(B.XML_ENTITIES) : Object.create(B.ENTITIES), pt.attribList = [], pt.opt.xmlns && (pt.ns = Object.create(Q)), pt.trackPosition = pt.opt.position !== !1, pt.trackPosition && (pt.position = pt.line = pt.column = 0), ne(pt, "onready");
          }
          B.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function(x) {
            function U() {
            }
            return U.prototype = x, new U();
          }), Object.keys || (Object.keys = function(x) {
            var U = [];
            for (var pt in x) x.hasOwnProperty(pt) && U.push(pt);
            return U;
          }), m.prototype = { end: function() {
            ln(this);
          }, write: function(x) {
            var U = this;
            if (this.error) throw this.error;
            if (U.closed) return we(U, "Cannot write after close. Assign an onready handler.");
            if (x === null) return ln(U);
            typeof x == "object" && (x = x.toString());
            for (var pt = 0, lt = ""; lt = tt(x, pt++), U.c = lt, lt; ) switch (U.trackPosition && (U.position++, lt === `
` ? (U.line++, U.column = 0) : U.column++), U.state) {
              case At.BEGIN:
                if (U.state = At.BEGIN_WHITESPACE, lt === "\uFEFF") continue;
                q(U, lt);
                continue;
              case At.BEGIN_WHITESPACE:
                q(U, lt);
                continue;
              case At.TEXT:
                if (U.sawRoot && !U.closedRoot) {
                  for (var Gt = pt - 1; lt && lt !== "<" && lt !== "&"; ) (lt = tt(x, pt++)) && U.trackPosition && (U.position++, lt === `
` ? (U.line++, U.column = 0) : U.column++);
                  U.textNode += x.substring(Gt, pt - 1);
                }
                lt !== "<" || U.sawRoot && U.closedRoot && !U.strict ? (!Mt(T, lt) || U.sawRoot && !U.closedRoot || _e(U, "Text data outside of root node."), lt === "&" ? U.state = At.TEXT_ENTITY : U.textNode += lt) : (U.state = At.OPEN_WAKA, U.startTagPosition = U.position);
                continue;
              case At.SCRIPT:
                lt === "<" ? U.state = At.SCRIPT_ENDING : U.script += lt;
                continue;
              case At.SCRIPT_ENDING:
                lt === "/" ? U.state = At.CLOSE_TAG : (U.script += "<" + lt, U.state = At.SCRIPT);
                continue;
              case At.OPEN_WAKA:
                if (lt === "!") U.state = At.SGML_DECL, U.sgmlDecl = "";
                else if (!yt(T, lt)) if (yt(vt, lt)) U.state = At.OPEN_TAG, U.tagName = lt;
                else if (lt === "/") U.state = At.CLOSE_TAG, U.tagName = "";
                else if (lt === "?") U.state = At.PROC_INST, U.procInstName = U.procInstBody = "";
                else {
                  if (_e(U, "Unencoded <"), U.startTagPosition + 1 < U.position) {
                    var ee = U.position - U.startTagPosition;
                    lt = new Array(ee).join(" ") + lt;
                  }
                  U.textNode += "<" + lt, U.state = At.TEXT;
                }
                continue;
              case At.SGML_DECL:
                (U.sgmlDecl + lt).toUpperCase() === p ? (Ht(U, "onopencdata"), U.state = At.CDATA, U.sgmlDecl = "", U.cdata = "") : U.sgmlDecl + lt === "--" ? (U.state = At.COMMENT, U.comment = "", U.sgmlDecl = "") : (U.sgmlDecl + lt).toUpperCase() === z ? (U.state = At.DOCTYPE, (U.doctype || U.sawRoot) && _e(U, "Inappropriately located doctype declaration"), U.doctype = "", U.sgmlDecl = "") : lt === ">" ? (Ht(U, "onsgmldeclaration", U.sgmlDecl), U.sgmlDecl = "", U.state = At.TEXT) : (yt(l, lt) && (U.state = At.SGML_DECL_QUOTED), U.sgmlDecl += lt);
                continue;
              case At.SGML_DECL_QUOTED:
                lt === U.q && (U.state = At.SGML_DECL, U.q = ""), U.sgmlDecl += lt;
                continue;
              case At.DOCTYPE:
                lt === ">" ? (U.state = At.TEXT, Ht(U, "ondoctype", U.doctype), U.doctype = !0) : (U.doctype += lt, lt === "[" ? U.state = At.DOCTYPE_DTD : yt(l, lt) && (U.state = At.DOCTYPE_QUOTED, U.q = lt));
                continue;
              case At.DOCTYPE_QUOTED:
                U.doctype += lt, lt === U.q && (U.q = "", U.state = At.DOCTYPE);
                continue;
              case At.DOCTYPE_DTD:
                U.doctype += lt, lt === "]" ? U.state = At.DOCTYPE : yt(l, lt) && (U.state = At.DOCTYPE_DTD_QUOTED, U.q = lt);
                continue;
              case At.DOCTYPE_DTD_QUOTED:
                U.doctype += lt, lt === U.q && (U.state = At.DOCTYPE_DTD, U.q = "");
                continue;
              case At.COMMENT:
                lt === "-" ? U.state = At.COMMENT_ENDING : U.comment += lt;
                continue;
              case At.COMMENT_ENDING:
                lt === "-" ? (U.state = At.COMMENT_ENDED, U.comment = sn(U.opt, U.comment), U.comment && Ht(U, "oncomment", U.comment), U.comment = "") : (U.comment += "-" + lt, U.state = At.COMMENT);
                continue;
              case At.COMMENT_ENDED:
                lt !== ">" ? (_e(U, "Malformed comment"), U.comment += "--" + lt, U.state = At.COMMENT) : U.state = At.TEXT;
                continue;
              case At.CDATA:
                lt === "]" ? U.state = At.CDATA_ENDING : U.cdata += lt;
                continue;
              case At.CDATA_ENDING:
                lt === "]" ? U.state = At.CDATA_ENDING_2 : (U.cdata += "]" + lt, U.state = At.CDATA);
                continue;
              case At.CDATA_ENDING_2:
                lt === ">" ? (U.cdata && Ht(U, "oncdata", U.cdata), Ht(U, "onclosecdata"), U.cdata = "", U.state = At.TEXT) : lt === "]" ? U.cdata += "]" : (U.cdata += "]]" + lt, U.state = At.CDATA);
                continue;
              case At.PROC_INST:
                lt === "?" ? U.state = At.PROC_INST_ENDING : yt(T, lt) ? U.state = At.PROC_INST_BODY : U.procInstName += lt;
                continue;
              case At.PROC_INST_BODY:
                if (!U.procInstBody && yt(T, lt)) continue;
                lt === "?" ? U.state = At.PROC_INST_ENDING : U.procInstBody += lt;
                continue;
              case At.PROC_INST_ENDING:
                lt === ">" ? (Ht(U, "onprocessinginstruction", { name: U.procInstName, body: U.procInstBody }), U.procInstName = U.procInstBody = "", U.state = At.TEXT) : (U.procInstBody += "?" + lt, U.state = At.PROC_INST_BODY);
                continue;
              case At.OPEN_TAG:
                yt(Lt, lt) ? U.tagName += lt : (Rn(U), lt === ">" ? Nt(U) : lt === "/" ? U.state = At.OPEN_TAG_SLASH : (Mt(T, lt) && _e(U, "Invalid character in tag name"), U.state = At.ATTRIB));
                continue;
              case At.OPEN_TAG_SLASH:
                lt === ">" ? (Nt(U, !0), Ft(U)) : (_e(U, "Forward-slash in opening tag not followed by >"), U.state = At.ATTRIB);
                continue;
              case At.ATTRIB:
                if (yt(T, lt)) continue;
                lt === ">" ? Nt(U) : lt === "/" ? U.state = At.OPEN_TAG_SLASH : yt(vt, lt) ? (U.attribName = lt, U.attribValue = "", U.state = At.ATTRIB_NAME) : _e(U, "Invalid attribute name");
                continue;
              case At.ATTRIB_NAME:
                lt === "=" ? U.state = At.ATTRIB_VALUE : lt === ">" ? (_e(U, "Attribute without value"), U.attribValue = U.attribName, Tn(U), Nt(U)) : yt(T, lt) ? U.state = At.ATTRIB_NAME_SAW_WHITE : yt(Lt, lt) ? U.attribName += lt : _e(U, "Invalid attribute name");
                continue;
              case At.ATTRIB_NAME_SAW_WHITE:
                if (lt === "=") U.state = At.ATTRIB_VALUE;
                else {
                  if (yt(T, lt)) continue;
                  _e(U, "Attribute without value"), U.tag.attributes[U.attribName] = "", U.attribValue = "", Ht(U, "onattribute", { name: U.attribName, value: "" }), U.attribName = "", lt === ">" ? Nt(U) : yt(vt, lt) ? (U.attribName = lt, U.state = At.ATTRIB_NAME) : (_e(U, "Invalid attribute name"), U.state = At.ATTRIB);
                }
                continue;
              case At.ATTRIB_VALUE:
                if (yt(T, lt)) continue;
                yt(l, lt) ? (U.q = lt, U.state = At.ATTRIB_VALUE_QUOTED) : (_e(U, "Unquoted attribute value"), U.state = At.ATTRIB_VALUE_UNQUOTED, U.attribValue = lt);
                continue;
              case At.ATTRIB_VALUE_QUOTED:
                if (lt !== U.q) {
                  lt === "&" ? U.state = At.ATTRIB_VALUE_ENTITY_Q : U.attribValue += lt;
                  continue;
                }
                Tn(U), U.q = "", U.state = At.ATTRIB_VALUE_CLOSED;
                continue;
              case At.ATTRIB_VALUE_CLOSED:
                yt(T, lt) ? U.state = At.ATTRIB : lt === ">" ? Nt(U) : lt === "/" ? U.state = At.OPEN_TAG_SLASH : yt(vt, lt) ? (_e(U, "No whitespace between attributes"), U.attribName = lt, U.attribValue = "", U.state = At.ATTRIB_NAME) : _e(U, "Invalid attribute name");
                continue;
              case At.ATTRIB_VALUE_UNQUOTED:
                if (Mt(h, lt)) {
                  lt === "&" ? U.state = At.ATTRIB_VALUE_ENTITY_U : U.attribValue += lt;
                  continue;
                }
                Tn(U), lt === ">" ? Nt(U) : U.state = At.ATTRIB;
                continue;
              case At.CLOSE_TAG:
                if (U.tagName) lt === ">" ? Ft(U) : yt(Lt, lt) ? U.tagName += lt : U.script ? (U.script += "</" + U.tagName, U.tagName = "", U.state = At.SCRIPT) : (Mt(T, lt) && _e(U, "Invalid tagname in closing tag"), U.state = At.CLOSE_TAG_SAW_WHITE);
                else {
                  if (yt(T, lt)) continue;
                  Mt(vt, lt) ? U.script ? (U.script += "</" + lt, U.state = At.SCRIPT) : _e(U, "Invalid tagname in closing tag.") : U.tagName = lt;
                }
                continue;
              case At.CLOSE_TAG_SAW_WHITE:
                if (yt(T, lt)) continue;
                lt === ">" ? Ft(U) : _e(U, "Invalid characters in closing tag");
                continue;
              case At.TEXT_ENTITY:
              case At.ATTRIB_VALUE_ENTITY_Q:
              case At.ATTRIB_VALUE_ENTITY_U:
                var Vt, Jt;
                switch (U.state) {
                  case At.TEXT_ENTITY:
                    Vt = At.TEXT, Jt = "textNode";
                    break;
                  case At.ATTRIB_VALUE_ENTITY_Q:
                    Vt = At.ATTRIB_VALUE_QUOTED, Jt = "attribValue";
                    break;
                  case At.ATTRIB_VALUE_ENTITY_U:
                    Vt = At.ATTRIB_VALUE_UNQUOTED, Jt = "attribValue";
                }
                lt === ";" ? (U[Jt] += ve(U), U.entity = "", U.state = Vt) : yt(U.entity.length ? X : zt, lt) ? U.entity += lt : (_e(U, "Invalid character in entity name"), U[Jt] += "&" + U.entity + lt, U.entity = "", U.state = Vt);
                continue;
              default:
                throw new Error(U, "Unknown state: " + U.state);
            }
            return U.position >= U.bufferCheckPosition && function(Ot) {
              for (var Kt = Math.max(B.MAX_BUFFER_LENGTH, 10), ae = 0, Qt = 0, me = d.length; Qt < me; Qt++) {
                var an = Ot[d[Qt]].length;
                if (an > Kt) switch (d[Qt]) {
                  case "textNode":
                    Le(Ot);
                    break;
                  case "cdata":
                    Ht(Ot, "oncdata", Ot.cdata), Ot.cdata = "";
                    break;
                  case "script":
                    Ht(Ot, "onscript", Ot.script), Ot.script = "";
                    break;
                  default:
                    we(Ot, "Max buffer length exceeded: " + d[Qt]);
                }
                ae = Math.max(ae, an);
              }
              var Ge = B.MAX_BUFFER_LENGTH - ae;
              Ot.bufferCheckPosition = Ge + Ot.position;
            }(U), U;
          }, resume: function() {
            return this.error = null, this;
          }, close: function() {
            return this.write(null);
          }, flush: function() {
            var x;
            Le(x = this), x.cdata !== "" && (Ht(x, "oncdata", x.cdata), x.cdata = ""), x.script !== "" && (Ht(x, "onscript", x.script), x.script = "");
          } };
          try {
            c = w(3515).Stream;
          } catch (x) {
            c = function() {
            };
          }
          var b = B.EVENTS.filter(function(x) {
            return x !== "error" && x !== "end";
          });
          function y(x, U) {
            if (!(this instanceof y)) return new y(x, U);
            c.apply(this), this._parser = new m(x, U), this.writable = !0, this.readable = !0;
            var pt = this;
            this._parser.onend = function() {
              pt.emit("end");
            }, this._parser.onerror = function(lt) {
              pt.emit("error", lt), pt._parser.error = null;
            }, this._decoder = null, b.forEach(function(lt) {
              Object.defineProperty(pt, "on" + lt, { get: function() {
                return pt._parser["on" + lt];
              }, set: function(Gt) {
                if (!Gt) return pt.removeAllListeners(lt), pt._parser["on" + lt] = Gt, Gt;
                pt.on(lt, Gt);
              }, enumerable: !0, configurable: !1 });
            });
          }
          y.prototype = Object.create(c.prototype, { constructor: { value: y } }), y.prototype.write = function(x) {
            if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(x)) {
              if (!this._decoder) {
                var U = w(748).I;
                this._decoder = new U("utf8");
              }
              x = this._decoder.write(x);
            }
            return this._parser.write(x.toString()), this.emit("data", x), !0;
          }, y.prototype.end = function(x) {
            return x && x.length && this.write(x), this._parser.end(), !0;
          }, y.prototype.on = function(x, U) {
            var pt = this;
            return pt._parser["on" + x] || b.indexOf(x) === -1 || (pt._parser["on" + x] = function() {
              var lt = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              lt.splice(0, 0, x), pt.emit.apply(pt, lt);
            }), c.prototype.on.call(pt, x, U);
          };
          var T = `\r
   `, n = "0124356789", o = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", l = `'"`, h = T + ">", p = "[CDATA[", z = "DOCTYPE", Z = "http://www.w3.org/XML/1998/namespace", V = "http://www.w3.org/2000/xmlns/", Q = { xml: Z, xmlns: V };
          T = D(T), n = D(n), o = D(o);
          var vt = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Lt = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, zt = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, X = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
          function D(x) {
            return x.split("").reduce(function(U, pt) {
              return U[pt] = !0, U;
            }, {});
          }
          function yt(x, U) {
            return function(pt) {
              return Object.prototype.toString.call(pt) === "[object RegExp]";
            }(x) ? !!U.match(x) : x[U];
          }
          function Mt(x, U) {
            return !yt(x, U);
          }
          l = D(l), h = D(h);
          var at, Bt, jt, At = 0;
          for (var Ce in B.STATE = { BEGIN: At++, BEGIN_WHITESPACE: At++, TEXT: At++, TEXT_ENTITY: At++, OPEN_WAKA: At++, SGML_DECL: At++, SGML_DECL_QUOTED: At++, DOCTYPE: At++, DOCTYPE_QUOTED: At++, DOCTYPE_DTD: At++, DOCTYPE_DTD_QUOTED: At++, COMMENT_STARTING: At++, COMMENT: At++, COMMENT_ENDING: At++, COMMENT_ENDED: At++, CDATA: At++, CDATA_ENDING: At++, CDATA_ENDING_2: At++, PROC_INST: At++, PROC_INST_BODY: At++, PROC_INST_ENDING: At++, OPEN_TAG: At++, OPEN_TAG_SLASH: At++, ATTRIB: At++, ATTRIB_NAME: At++, ATTRIB_NAME_SAW_WHITE: At++, ATTRIB_VALUE: At++, ATTRIB_VALUE_QUOTED: At++, ATTRIB_VALUE_CLOSED: At++, ATTRIB_VALUE_UNQUOTED: At++, ATTRIB_VALUE_ENTITY_Q: At++, ATTRIB_VALUE_ENTITY_U: At++, CLOSE_TAG: At++, CLOSE_TAG_SAW_WHITE: At++, SCRIPT: At++, SCRIPT_ENDING: At++ }, B.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, B.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(B.ENTITIES).forEach(function(x) {
            var U = B.ENTITIES[x], pt = typeof U == "number" ? String.fromCharCode(U) : U;
            B.ENTITIES[x] = pt;
          }), B.STATE) B.STATE[B.STATE[Ce]] = Ce;
          function ne(x, U, pt) {
            x[U] && x[U](pt);
          }
          function Ht(x, U, pt) {
            x.textNode && Le(x), ne(x, U, pt);
          }
          function Le(x) {
            x.textNode = sn(x.opt, x.textNode), x.textNode && ne(x, "ontext", x.textNode), x.textNode = "";
          }
          function sn(x, U) {
            return x.trim && (U = U.trim()), x.normalize && (U = U.replace(/\s+/g, " ")), U;
          }
          function we(x, U) {
            return Le(x), x.trackPosition && (U += `
Line: ` + x.line + `
Column: ` + x.column + `
Char: ` + x.c), U = new Error(U), x.error = U, ne(x, "onerror", U), x;
          }
          function ln(x) {
            return x.sawRoot && !x.closedRoot && _e(x, "Unclosed root tag"), x.state !== At.BEGIN && x.state !== At.BEGIN_WHITESPACE && x.state !== At.TEXT && we(x, "Unexpected end"), Le(x), x.c = "", x.closed = !0, ne(x, "onend"), m.call(x, x.strict, x.opt), x;
          }
          function _e(x, U) {
            if (typeof x != "object" || !(x instanceof m)) throw new Error("bad call to strictFail");
            x.strict && we(x, U);
          }
          function Rn(x) {
            x.strict || (x.tagName = x.tagName[x.looseCase]());
            var U = x.tags[x.tags.length - 1] || x, pt = x.tag = { name: x.tagName, attributes: {} };
            x.opt.xmlns && (pt.ns = U.ns), x.attribList.length = 0, Ht(x, "onopentagstart", pt);
          }
          function En(x, U) {
            var pt = x.indexOf(":") < 0 ? ["", x] : x.split(":"), lt = pt[0], Gt = pt[1];
            return U && x === "xmlns" && (lt = "xmlns", Gt = ""), { prefix: lt, local: Gt };
          }
          function Tn(x) {
            if (x.strict || (x.attribName = x.attribName[x.looseCase]()), x.attribList.indexOf(x.attribName) !== -1 || x.tag.attributes.hasOwnProperty(x.attribName)) x.attribName = x.attribValue = "";
            else {
              if (x.opt.xmlns) {
                var U = En(x.attribName, !0), pt = U.prefix, lt = U.local;
                if (pt === "xmlns") if (lt === "xml" && x.attribValue !== Z) _e(x, "xml: prefix must be bound to " + Z + `
Actual: ` + x.attribValue);
                else if (lt === "xmlns" && x.attribValue !== V) _e(x, "xmlns: prefix must be bound to " + V + `
Actual: ` + x.attribValue);
                else {
                  var Gt = x.tag, ee = x.tags[x.tags.length - 1] || x;
                  Gt.ns === ee.ns && (Gt.ns = Object.create(ee.ns)), Gt.ns[lt] = x.attribValue;
                }
                x.attribList.push([x.attribName, x.attribValue]);
              } else x.tag.attributes[x.attribName] = x.attribValue, Ht(x, "onattribute", { name: x.attribName, value: x.attribValue });
              x.attribName = x.attribValue = "";
            }
          }
          function Nt(x, U) {
            if (x.opt.xmlns) {
              var pt = x.tag, lt = En(x.tagName);
              pt.prefix = lt.prefix, pt.local = lt.local, pt.uri = pt.ns[lt.prefix] || "", pt.prefix && !pt.uri && (_e(x, "Unbound namespace prefix: " + JSON.stringify(x.tagName)), pt.uri = lt.prefix);
              var Gt = x.tags[x.tags.length - 1] || x;
              pt.ns && Gt.ns !== pt.ns && Object.keys(pt.ns).forEach(function(Te) {
                Ht(x, "onopennamespace", { prefix: Te, uri: pt.ns[Te] });
              });
              for (var ee = 0, Vt = x.attribList.length; ee < Vt; ee++) {
                var Jt = x.attribList[ee], Ot = Jt[0], Kt = Jt[1], ae = En(Ot, !0), Qt = ae.prefix, me = ae.local, an = Qt === "" ? "" : pt.ns[Qt] || "", Ge = { name: Ot, value: Kt, prefix: Qt, local: me, uri: an };
                Qt && Qt !== "xmlns" && !an && (_e(x, "Unbound namespace prefix: " + JSON.stringify(Qt)), Ge.uri = Qt), x.tag.attributes[Ot] = Ge, Ht(x, "onattribute", Ge);
              }
              x.attribList.length = 0;
            }
            x.tag.isSelfClosing = !!U, x.sawRoot = !0, x.tags.push(x.tag), Ht(x, "onopentag", x.tag), U || (x.noscript || x.tagName.toLowerCase() !== "script" ? x.state = At.TEXT : x.state = At.SCRIPT, x.tag = null, x.tagName = ""), x.attribName = x.attribValue = "", x.attribList.length = 0;
          }
          function Ft(x) {
            if (!x.tagName) return _e(x, "Weird empty close tag."), x.textNode += "</>", void (x.state = At.TEXT);
            if (x.script) {
              if (x.tagName !== "script") return x.script += "</" + x.tagName + ">", x.tagName = "", void (x.state = At.SCRIPT);
              Ht(x, "onscript", x.script), x.script = "";
            }
            var U = x.tags.length, pt = x.tagName;
            x.strict || (pt = pt[x.looseCase]());
            for (var lt = pt; U-- && x.tags[U].name !== lt; ) _e(x, "Unexpected close tag");
            if (U < 0) return _e(x, "Unmatched closing tag: " + x.tagName), x.textNode += "</" + x.tagName + ">", void (x.state = At.TEXT);
            x.tagName = pt;
            for (var Gt = x.tags.length; Gt-- > U; ) {
              var ee = x.tag = x.tags.pop();
              x.tagName = x.tag.name, Ht(x, "onclosetag", x.tagName);
              var Vt = {};
              for (var Jt in ee.ns) Vt[Jt] = ee.ns[Jt];
              var Ot = x.tags[x.tags.length - 1] || x;
              x.opt.xmlns && ee.ns !== Ot.ns && Object.keys(ee.ns).forEach(function(Kt) {
                var ae = ee.ns[Kt];
                Ht(x, "onclosenamespace", { prefix: Kt, uri: ae });
              });
            }
            U === 0 && (x.closedRoot = !0), x.tagName = x.attribValue = x.attribName = "", x.attribList.length = 0, x.state = At.TEXT;
          }
          function ve(x) {
            var U, pt = x.entity, lt = pt.toLowerCase(), Gt = "";
            return x.ENTITIES[pt] ? x.ENTITIES[pt] : x.ENTITIES[lt] ? x.ENTITIES[lt] : ((pt = lt).charAt(0) === "#" && (pt.charAt(1) === "x" ? (pt = pt.slice(2), Gt = (U = parseInt(pt, 16)).toString(16)) : (pt = pt.slice(1), Gt = (U = parseInt(pt, 10)).toString(10))), pt = pt.replace(/^0+/, ""), Gt.toLowerCase() !== pt ? (_e(x, "Invalid character entity"), "&" + x.entity + ";") : String.fromCodePoint(U));
          }
          function q(x, U) {
            U === "<" ? (x.state = At.OPEN_WAKA, x.startTagPosition = x.position) : Mt(T, U) && (_e(x, "Non-whitespace before first tag."), x.textNode = U, x.state = At.TEXT);
          }
          function tt(x, U) {
            var pt = "";
            return U < x.length && (pt = x.charAt(U)), pt;
          }
          At = B.STATE, String.fromCodePoint || (at = String.fromCharCode, Bt = Math.floor, jt = function() {
            var x, U, pt = [], lt = -1, Gt = arguments.length;
            if (!Gt) return "";
            for (var ee = ""; ++lt < Gt; ) {
              var Vt = Number(arguments[lt]);
              if (!isFinite(Vt) || Vt < 0 || Vt > 1114111 || Bt(Vt) !== Vt) throw RangeError("Invalid code point: " + Vt);
              Vt <= 65535 ? pt.push(Vt) : (x = 55296 + ((Vt -= 65536) >> 10), U = Vt % 1024 + 56320, pt.push(x, U)), (lt + 1 === Gt || pt.length > 16384) && (ee += at.apply(null, pt), pt.length = 0);
            }
            return ee;
          }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: jt, configurable: !0, writable: !0 }) : String.fromCodePoint = jt);
        })(g);
      }, 6739: function(k, g, w) {
        (function(B, c, d, m, b) {
          function y(tt) {
            if ("contents" in tt) for (var x = ("styleAttrs" in tt) ? tt.styleAttrs[m.byName.ruby.qname] : null, U = tt.kind === "span" && (x === "container" || x === "textContainer" || x === "baseContainer"), pt = tt.contents.length - 1; pt >= 0; pt--) !U || "styleAttrs" in tt.contents[pt] && m.byName.ruby.qname in tt.contents[pt].styleAttrs ? y(tt.contents[pt]) : delete tt.contents[pt];
          }
          function T(tt, x, U, pt) {
            var lt = pt && pt.timeContainer === "seq", Gt = 0;
            pt && (Gt = lt && U ? U.end : pt.begin), x.begin = x.explicit_begin ? x.explicit_begin + Gt : Gt;
            var ee = x.begin, Vt = null;
            if ("sets" in x) for (var Jt = 0; Jt < x.sets.length; Jt++) T(tt, x.sets[Jt], Vt, x), ee = x.timeContainer === "seq" ? x.sets[Jt].end : Math.max(ee, x.sets[Jt].end), Vt = x.sets[Jt];
            if ("contents" in x) {
              if ("contents" in x) for (var Ot = 0; Ot < x.contents.length; Ot++) T(tt, x.contents[Ot], Vt, x), ee = x.timeContainer === "seq" ? x.contents[Ot].end : Math.max(ee, x.contents[Ot].end), Vt = x.contents[Ot];
            } else ee = lt ? x.begin : Number.POSITIVE_INFINITY;
            x.explicit_end !== null && x.explicit_dur !== null ? x.end = Math.min(x.begin + x.explicit_dur, Gt + x.explicit_end) : x.explicit_end === null && x.explicit_dur !== null ? x.end = x.begin + x.explicit_dur : x.explicit_end !== null && x.explicit_dur === null ? x.end = Gt + x.explicit_end : x.end = ee, delete x.explicit_begin, delete x.explicit_dur, delete x.explicit_end, tt._registerEvent(x);
          }
          function n(tt) {
            this.node = tt;
          }
          function o() {
            this.events = [], this.head = new l(), this.body = null;
          }
          function l() {
            this.styling = new h(), this.layout = new Z();
          }
          function h() {
            this.styles = {}, this.initials = {};
          }
          function p() {
            this.id = null, this.styleAttrs = null, this.styleRefs = null;
          }
          function z() {
            this.styleAttrs = null;
          }
          function Z() {
            this.regions = {};
          }
          function V(tt, x) {
            Q.call(this, "image"), this.src = tt, this.type = x;
          }
          function Q(tt) {
            this.kind = tt;
          }
          function vt(tt) {
            this.id = tt;
          }
          function Lt(tt) {
            this.regionID = tt;
          }
          function zt(tt) {
            this.styleAttrs = tt;
          }
          function X(tt) {
            this.sets = tt;
          }
          function D(tt) {
            this.contents = tt;
          }
          function yt(tt, x, U) {
            this.explicit_begin = tt, this.explicit_end = x, this.explicit_dur = U;
          }
          function Mt() {
            Q.call(this, "body");
          }
          function at() {
            Q.call(this, "div");
          }
          function Bt() {
            Q.call(this, "p");
          }
          function jt() {
            Q.call(this, "span");
          }
          function At() {
            Q.call(this, "span");
          }
          function Ce() {
            Q.call(this, "br");
          }
          function ne() {
          }
          function Ht() {
          }
          function Le(tt) {
            return tt && "xml:id" in tt.attributes && tt.attributes["xml:id"].value || null;
          }
          function sn(tt) {
            return tt && "style" in tt.attributes ? tt.attributes.style.value.split(" ") : [];
          }
          function we(tt, x) {
            var U = {};
            if (tt !== null) for (var pt in tt.attributes) {
              var lt = tt.attributes[pt].uri + " " + tt.attributes[pt].local, Gt = m.byQName[lt];
              if (Gt !== void 0) {
                var ee = Gt.parse(tt.attributes[pt].value);
                ee !== null ? (U[lt] = ee, Gt === m.byName.zIndex && Nt(x, "zIndex attribute present but not used by IMSC1 since regions do not overlap")) : Ft(x, "Cannot parse styling attribute " + lt + " --> " + tt.attributes[pt].value);
              }
            }
            return U;
          }
          function ln(tt, x, U) {
            for (var pt in tt.attributes) if (tt.attributes[pt].uri === x && tt.attributes[pt].local === U) return tt.attributes[pt].value;
            return null;
          }
          function _e(tt, x, U) {
            var pt, lt = null;
            return (pt = /^(\d+(?:\.\d+)?)f$/.exec(U)) !== null ? x !== null && (lt = parseFloat(pt[1]) / x) : (pt = /^(\d+(?:\.\d+)?)t$/.exec(U)) !== null ? tt !== null && (lt = parseFloat(pt[1]) / tt) : (pt = /^(\d+(?:\.\d+)?)ms$/.exec(U)) !== null ? lt = parseFloat(pt[1]) / 1e3 : (pt = /^(\d+(?:\.\d+)?)s$/.exec(U)) !== null ? lt = parseFloat(pt[1]) : (pt = /^(\d+(?:\.\d+)?)h$/.exec(U)) !== null ? lt = 3600 * parseFloat(pt[1]) : (pt = /^(\d+(?:\.\d+)?)m$/.exec(U)) !== null ? lt = 60 * parseFloat(pt[1]) : (pt = /^(\d{2,}):(\d\d):(\d\d(?:\.\d+)?)$/.exec(U)) !== null ? lt = 3600 * parseInt(pt[1]) + 60 * parseInt(pt[2]) + parseFloat(pt[3]) : (pt = /^(\d{2,}):(\d\d):(\d\d)\:(\d{2,})$/.exec(U)) !== null && x !== null && (lt = 3600 * parseInt(pt[1]) + 60 * parseInt(pt[2]) + parseInt(pt[3]) + (pt[4] === null ? 0 : parseInt(pt[4]) / x)), lt;
          }
          function Rn(tt, x, U) {
            for (; x.styleRefs.length > 0; ) {
              var pt = x.styleRefs.pop();
              pt in tt.styles ? (Rn(tt, tt.styles[pt], U), Tn(tt.styles[pt].styleAttrs, x.styleAttrs)) : Ft(U, "Non-existant style id referenced");
            }
          }
          function En(tt, x, U, pt) {
            for (var lt = x.length - 1; lt >= 0; lt--) {
              var Gt = x[lt];
              Gt in tt.styles ? Tn(tt.styles[Gt].styleAttrs, U) : Ft(pt, "Non-existant style id referenced");
            }
          }
          function Tn(tt, x) {
            for (var U in tt) tt.hasOwnProperty(U) && (U in x || (x[U] = tt[U]));
          }
          function Nt(tt, x) {
            if (tt && tt.warn && tt.warn(x)) throw x;
          }
          function Ft(tt, x) {
            if (tt && tt.error && tt.error(x)) throw x;
          }
          function ve(tt, x) {
            throw tt && tt.fatal && tt.fatal(x), x;
          }
          function q(tt, x) {
            for (var U, pt = 0, lt = tt.length - 1; pt <= lt; ) {
              var Gt = tt[U = Math.floor((pt + lt) / 2)];
              if (Gt < x) pt = U + 1;
              else {
                if (!(Gt > x)) return { found: !0, index: U };
                lt = U - 1;
              }
            }
            return { found: !1, index: pt };
          }
          B.fromXML = function(tt, x, U) {
            var pt = c.parser(!0, { xmlns: !0 }), lt = [], Gt = [], ee = [], Vt = 0, Jt = null;
            pt.onclosetag = function(me) {
              if (lt[0] instanceof ne) Jt.head !== null && Jt.head.styling !== null && En(Jt.head.styling, lt[0].styleRefs, lt[0].styleAttrs, x), delete lt[0].styleRefs;
              else if (lt[0] instanceof h) for (var an in lt[0].styles) lt[0].styles.hasOwnProperty(an) && Rn(lt[0], lt[0].styles[an], x);
              else if (lt[0] instanceof Bt || lt[0] instanceof jt) {
                if (lt[0].contents.length > 1) {
                  var Ge, Te = [lt[0].contents[0]];
                  for (Ge = 1; Ge < lt[0].contents.length; Ge++) lt[0].contents[Ge] instanceof At && Te[Te.length - 1] instanceof At ? Te[Te.length - 1].text += lt[0].contents[Ge].text : Te.push(lt[0].contents[Ge]);
                  lt[0].contents = Te;
                }
                lt[0] instanceof jt && lt[0].contents.length === 1 && lt[0].contents[0] instanceof At && (lt[0].text = lt[0].contents[0].text, delete lt[0].contents);
              } else lt[0] instanceof n && (lt[0].node.uri === d.ns_tt && lt[0].node.local === "metadata" ? Vt-- : Vt > 0 && U && "onCloseTag" in U && U.onCloseTag());
              ee.shift(), Gt.shift(), lt.shift();
            }, pt.ontext = function(me) {
              if (lt[0] !== void 0) if (lt[0] instanceof jt || lt[0] instanceof Bt) {
                if (lt[0] instanceof jt) {
                  var an = lt[0].styleAttrs[m.byName.ruby.qname];
                  if (an === "container" || an === "textContainer" || an === "baseContainer") return;
                }
                var Ge = new At();
                Ge.initFromText(Jt, lt[0], me, Gt[0], ee[0], x), lt[0].contents.push(Ge);
              } else lt[0] instanceof n && Vt > 0 && U && "onText" in U && U.onText(me);
            }, pt.onopentag = function(me) {
              var an = me.attributes["xml:space"];
              an ? ee.unshift(an.value) : ee.length === 0 ? ee.unshift("default") : ee.unshift(ee[0]);
              var Ge = me.attributes["xml:lang"];
              if (Ge ? Gt.unshift(Ge.value) : Gt.length === 0 ? Gt.unshift("") : Gt.unshift(Gt[0]), me.uri === d.ns_tt) if (me.local === "tt") Jt !== null && ve(x, "Two <tt> elements at (" + this.line + "," + this.column + ")"), (Jt = new o()).initFromNode(me, Gt[0], x), lt.unshift(Jt);
              else if (me.local === "head") lt[0] instanceof o || ve(x, "Parent of <head> element is not <tt> at (" + this.line + "," + this.column + ")"), lt.unshift(Jt.head);
              else if (me.local === "styling") lt[0] instanceof l || ve(x, "Parent of <styling> element is not <head> at (" + this.line + "," + this.column + ")"), lt.unshift(Jt.head.styling);
              else if (me.local === "style") {
                var Te;
                lt[0] instanceof h ? ((Te = new p()).initFromNode(me, x), Te.id ? Jt.head.styling.styles[Te.id] = Te : Ft(x, "<style> element missing @id attribute"), lt.unshift(Te)) : lt[0] instanceof ne ? ((Te = new p()).initFromNode(me, x), Tn(Te.styleAttrs, lt[0].styleAttrs), lt.unshift(Te)) : ve(x, "Parent of <style> element is not <styling> or <region> at (" + this.line + "," + this.column + ")");
              } else if (me.local === "initial") {
                var ge;
                if (lt[0] instanceof h) {
                  for (var ze in (ge = new z()).initFromNode(me, x), ge.styleAttrs) ge.styleAttrs.hasOwnProperty(ze) && (Jt.head.styling.initials[ze] = ge.styleAttrs[ze]);
                  lt.unshift(ge);
                } else ve(x, "Parent of <initial> element is not <styling> at (" + this.line + "," + this.column + ")");
              } else if (me.local === "layout") lt[0] instanceof l || ve(x, "Parent of <layout> element is not <head> at " + this.line + "," + this.column + ")"), lt.unshift(Jt.head.layout);
              else if (me.local === "region") {
                lt[0] instanceof Z || ve(x, "Parent of <region> element is not <layout> at " + this.line + "," + this.column + ")");
                var Zn = new ne();
                Zn.initFromNode(Jt, me, Gt[0], x), !Zn.id || Zn.id in Jt.head.layout.regions ? Ft(x, "Ignoring <region> with duplicate or missing @id at " + this.line + "," + this.column + ")") : Jt.head.layout.regions[Zn.id] = Zn, lt.unshift(Zn);
              } else if (me.local === "body") {
                lt[0] instanceof o || ve(x, "Parent of <body> element is not <tt> at " + this.line + "," + this.column + ")"), Jt.body !== null && ve(x, "Second <body> element at " + this.line + "," + this.column + ")");
                var qn = new Mt();
                qn.initFromNode(Jt, me, Gt[0], x), Jt.body = qn, lt.unshift(qn);
              } else if (me.local === "div") {
                lt[0] instanceof at || lt[0] instanceof Mt || ve(x, "Parent of <div> element is not <body> or <div> at " + this.line + "," + this.column + ")");
                var Aa = new at();
                Aa.initFromNode(Jt, lt[0], me, Gt[0], x);
                var Hn = Aa.styleAttrs[m.byName.backgroundImage.qname];
                Hn && (Aa.contents.push(new V(Hn)), delete Aa.styleAttrs[m.byName.backgroundImage.qname]), lt[0].contents.push(Aa), lt.unshift(Aa);
              } else if (me.local === "image") {
                lt[0] instanceof at || ve(x, "Parent of <image> element is not <div> at " + this.line + "," + this.column + ")");
                var xa = new V();
                xa.initFromNode(Jt, lt[0], me, Gt[0], x), lt[0].contents.push(xa), lt.unshift(xa);
              } else if (me.local === "p") {
                lt[0] instanceof at || ve(x, "Parent of <p> element is not <div> at " + this.line + "," + this.column + ")");
                var Ee = new Bt();
                Ee.initFromNode(Jt, lt[0], me, Gt[0], x), lt[0].contents.push(Ee), lt.unshift(Ee);
              } else if (me.local === "span") {
                lt[0] instanceof jt || lt[0] instanceof Bt || ve(x, "Parent of <span> element is not <span> or <p> at " + this.line + "," + this.column + ")");
                var xe = new jt();
                xe.initFromNode(Jt, lt[0], me, Gt[0], ee[0], x), lt[0].contents.push(xe), lt.unshift(xe);
              } else if (me.local === "br") {
                lt[0] instanceof jt || lt[0] instanceof Bt || ve(x, "Parent of <br> element is not <span> or <p> at " + this.line + "," + this.column + ")");
                var Re = new Ce();
                Re.initFromNode(Jt, lt[0], me, Gt[0], x), lt[0].contents.push(Re), lt.unshift(Re);
              } else if (me.local === "set") {
                lt[0] instanceof jt || lt[0] instanceof Bt || lt[0] instanceof at || lt[0] instanceof Mt || lt[0] instanceof ne || lt[0] instanceof Ce || ve(x, "Parent of <set> element is not a content element or a region at " + this.line + "," + this.column + ")");
                var Ie = new Ht();
                Ie.initFromNode(Jt, lt[0], me, x), lt[0].sets.push(Ie), lt.unshift(Ie);
              } else lt.unshift(new n(me));
              else lt.unshift(new n(me));
              if (lt[0] instanceof n) {
                if (me.uri === d.ns_tt && me.local === "metadata") Vt++;
                else if (Vt > 0 && U && "onOpenTag" in U) {
                  var Ne = [];
                  for (var Ue in me.attributes) Ne[me.attributes[Ue].uri + " " + me.attributes[Ue].local] = { uri: me.attributes[Ue].uri, local: me.attributes[Ue].local, value: me.attributes[Ue].value };
                  U.onOpenTag(me.uri, me.local, Ne);
                }
              }
            }, pt.write(tt).close(), delete Jt.head.styling.styles;
            var Ot = !1;
            for (var Kt in Jt.head.layout.regions) if (Jt.head.layout.regions.hasOwnProperty(Kt)) {
              Ot = !0;
              break;
            }
            if (!Ot) {
              var ae = ne.prototype.createDefaultRegion(Jt.lang);
              Jt.head.layout.regions[ae.id] = ae;
            }
            for (var Qt in Jt.head.layout.regions) Jt.head.layout.regions.hasOwnProperty(Qt) && T(Jt, Jt.head.layout.regions[Qt], null, null);
            return Jt.body && T(Jt, Jt.body, null, null), Jt.body && y(Jt.body), Jt;
          }, o.prototype.initFromNode = function(tt, x, U) {
            var pt = function(Vt, Jt) {
              var Ot = ln(Vt, d.ns_ttp, "cellResolution"), Kt = 15, ae = 32;
              if (Ot !== null) {
                var Qt = /(\d+) (\d+)/.exec(Ot);
                Qt !== null ? (ae = parseInt(Qt[1]), Kt = parseInt(Qt[2])) : Nt(Jt, "Malformed cellResolution value (using initial value instead)");
              }
              return { w: ae, h: Kt };
            }(tt, U);
            this.cellLength = { h: new b.ComputedLength(0, 1 / pt.h), w: new b.ComputedLength(1 / pt.w, 0) };
            var lt = function(Vt, Jt) {
              var Ot, Kt = ln(Vt, d.ns_ttp, "frameRate"), ae = 30;
              Kt !== null && ((Ot = /(\d+)/.exec(Kt)) !== null ? ae = parseInt(Ot[1]) : Nt(Jt, "Malformed frame rate attribute (using initial value instead)"));
              var Qt = ln(Vt, d.ns_ttp, "frameRateMultiplier"), me = 1;
              Qt !== null && ((Ot = /(\d+) (\d+)/.exec(Qt)) !== null ? me = parseInt(Ot[1]) / parseInt(Ot[2]) : Nt(Jt, "Malformed frame rate multiplier attribute (using initial value instead)"));
              var an = me * ae, Ge = 1, Te = ln(Vt, d.ns_ttp, "tickRate");
              return Te === null ? Kt !== null && (Ge = an) : (Ot = /(\d+)/.exec(Te)) !== null ? Ge = parseInt(Ot[1]) : Nt(Jt, "Malformed tick rate attribute (using initial value instead)"), { effectiveFrameRate: an, tickRate: Ge };
            }(tt, U);
            this.effectiveFrameRate = lt.effectiveFrameRate, this.tickRate = lt.tickRate, this.aspectRatio = function(Vt, Jt) {
              var Ot = ln(Vt, d.ns_ittp, "aspectRatio");
              Ot === null && (Ot = ln(Vt, d.ns_ttp, "displayAspectRatio"));
              var Kt = null;
              if (Ot !== null) {
                var ae = /(\d+)\s+(\d+)/.exec(Ot);
                if (ae !== null) {
                  var Qt = parseInt(ae[1]), me = parseInt(ae[2]);
                  Qt !== 0 && me !== 0 ? Kt = Qt / me : Ft(Jt, "Illegal aspectRatio values (ignoring)");
                } else Ft(Jt, "Malformed aspectRatio attribute (ignoring)");
              }
              return Kt;
            }(tt, U);
            var Gt = ln(tt, d.ns_ttp, "timeBase");
            Gt !== null && Gt !== "media" && ve(U, "Unsupported time base");
            var ee = function(Vt, Jt) {
              var Ot = ln(Vt, d.ns_tts, "extent");
              if (Ot === null) return null;
              var Kt = Ot.split(" ");
              if (Kt.length !== 2) return Nt(Jt, "Malformed extent (ignoring)"), null;
              var ae = b.parseLength(Kt[0]), Qt = b.parseLength(Kt[1]);
              return Qt && ae ? { h: Qt, w: ae } : (Nt(Jt, "Malformed extent values (ignoring)"), null);
            }(tt, U);
            ee === null ? this.pxLength = { h: null, w: null } : (ee.h.unit === "px" && ee.w.unit === "px" || ve(U, "Extent on TT must be in px or absent"), this.pxLength = { h: new b.ComputedLength(0, 1 / ee.h.value), w: new b.ComputedLength(1 / ee.w.value, 0) }), this.dimensions = { h: new b.ComputedLength(0, 1), w: new b.ComputedLength(1, 0) }, this.lang = x;
          }, o.prototype._registerEvent = function(tt) {
            if (!(tt.end <= tt.begin)) {
              var x = q(this.events, tt.begin);
              if (x.found || this.events.splice(x.index, 0, tt.begin), tt.end !== Number.POSITIVE_INFINITY) {
                var U = q(this.events, tt.end);
                U.found || this.events.splice(U.index, 0, tt.end);
              }
            }
          }, o.prototype.getMediaTimeRange = function() {
            return [this.events[0], this.events[this.events.length - 1]];
          }, o.prototype.getMediaTimeEvents = function() {
            return this.events;
          }, p.prototype.initFromNode = function(tt, x) {
            this.id = Le(tt), this.styleAttrs = we(tt, x), this.styleRefs = sn(tt);
          }, z.prototype.initFromNode = function(tt, x) {
            for (var U in this.styleAttrs = {}, tt.attributes) if (tt.attributes[U].uri === d.ns_itts || tt.attributes[U].uri === d.ns_ebutts || tt.attributes[U].uri === d.ns_tts) {
              var pt = tt.attributes[U].uri + " " + tt.attributes[U].local;
              this.styleAttrs[pt] = tt.attributes[U].value;
            }
          }, V.prototype.initFromNode = function(tt, x, U, pt, lt) {
            this.src = "src" in U.attributes ? U.attributes.src.value : null, this.src || Ft(lt, "Invalid image@src attribute"), this.type = "type" in U.attributes ? U.attributes.type.value : null, this.type || Ft(lt, "Invalid image@type attribute"), zt.prototype.initFromNode.call(this, tt, x, U, lt), yt.prototype.initFromNode.call(this, tt, x, U, lt), X.prototype.initFromNode.call(this, tt, x, U, lt), Lt.prototype.initFromNode.call(this, tt, x, U, lt), this.lang = pt;
          }, vt.prototype.initFromNode = function(tt, x, U, pt) {
            this.id = Le(U);
          }, Lt.prototype.initFromNode = function(tt, x, U, pt) {
            this.regionID = function(lt) {
              return lt && "region" in lt.attributes ? lt.attributes.region.value : "";
            }(U);
          }, zt.prototype.initFromNode = function(tt, x, U, pt) {
            this.styleAttrs = we(U, pt), tt.head !== null && tt.head.styling !== null && En(tt.head.styling, sn(U), this.styleAttrs, pt);
          }, X.prototype.initFromNode = function(tt, x, U, pt) {
            this.sets = [];
          }, D.prototype.initFromNode = function(tt, x, U, pt) {
            this.contents = [];
          }, yt.prototype.initFromNode = function(tt, x, U, pt) {
            var lt = function(Gt, ee, Vt, Jt) {
              var Ot = null;
              Vt && "begin" in Vt.attributes && (Ot = _e(Gt.tickRate, Gt.effectiveFrameRate, Vt.attributes.begin.value)) === null && Nt(Jt, "Malformed begin value " + Vt.attributes.begin.value + " (using 0)");
              var Kt = null;
              Vt && "dur" in Vt.attributes && (Kt = _e(Gt.tickRate, Gt.effectiveFrameRate, Vt.attributes.dur.value)) === null && Nt(Jt, "Malformed dur value " + Vt.attributes.dur.value + " (ignoring)");
              var ae = null;
              return Vt && "end" in Vt.attributes && (ae = _e(Gt.tickRate, Gt.effectiveFrameRate, Vt.attributes.end.value)) === null && Nt(Jt, "Malformed end value (ignoring)"), { explicit_begin: Ot, explicit_end: ae, explicit_dur: Kt };
            }(tt, 0, U, pt);
            this.explicit_begin = lt.explicit_begin, this.explicit_end = lt.explicit_end, this.explicit_dur = lt.explicit_dur, this.timeContainer = function(Gt, ee) {
              var Vt = Gt && "timeContainer" in Gt.attributes ? Gt.attributes.timeContainer.value : null;
              return Vt && Vt !== "par" ? Vt === "seq" ? "seq" : (Ft(ee, "Illegal value of timeContainer (assuming 'par')"), "par") : "par";
            }(U, pt);
          }, Mt.prototype.initFromNode = function(tt, x, U, pt) {
            zt.prototype.initFromNode.call(this, tt, null, x, pt), yt.prototype.initFromNode.call(this, tt, null, x, pt), X.prototype.initFromNode.call(this, tt, null, x, pt), Lt.prototype.initFromNode.call(this, tt, null, x, pt), D.prototype.initFromNode.call(this, tt, null, x, pt), this.lang = U;
          }, at.prototype.initFromNode = function(tt, x, U, pt, lt) {
            zt.prototype.initFromNode.call(this, tt, x, U, lt), yt.prototype.initFromNode.call(this, tt, x, U, lt), X.prototype.initFromNode.call(this, tt, x, U, lt), Lt.prototype.initFromNode.call(this, tt, x, U, lt), D.prototype.initFromNode.call(this, tt, x, U, lt), this.lang = pt;
          }, Bt.prototype.initFromNode = function(tt, x, U, pt, lt) {
            zt.prototype.initFromNode.call(this, tt, x, U, lt), yt.prototype.initFromNode.call(this, tt, x, U, lt), X.prototype.initFromNode.call(this, tt, x, U, lt), Lt.prototype.initFromNode.call(this, tt, x, U, lt), D.prototype.initFromNode.call(this, tt, x, U, lt), this.lang = pt;
          }, jt.prototype.initFromNode = function(tt, x, U, pt, lt, Gt) {
            zt.prototype.initFromNode.call(this, tt, x, U, Gt), yt.prototype.initFromNode.call(this, tt, x, U, Gt), X.prototype.initFromNode.call(this, tt, x, U, Gt), Lt.prototype.initFromNode.call(this, tt, x, U, Gt), D.prototype.initFromNode.call(this, tt, x, U, Gt), this.space = lt, this.lang = pt;
          }, At.prototype.initFromText = function(tt, x, U, pt, lt, Gt) {
            yt.prototype.initFromNode.call(this, tt, x, null, Gt), this.text = U, this.space = lt, this.lang = pt;
          }, Ce.prototype.initFromNode = function(tt, x, U, pt, lt) {
            Lt.prototype.initFromNode.call(this, tt, x, U, lt), yt.prototype.initFromNode.call(this, tt, x, U, lt), this.lang = pt;
          }, ne.prototype.createDefaultRegion = function(tt) {
            var x = new ne();
            return vt.call(x, ""), zt.call(x, {}), X.call(x, []), yt.call(x, 0, Number.POSITIVE_INFINITY, null), this.lang = tt, x;
          }, ne.prototype.initFromNode = function(tt, x, U, pt) {
            vt.prototype.initFromNode.call(this, tt, null, x, pt), yt.prototype.initFromNode.call(this, tt, null, x, pt), X.prototype.initFromNode.call(this, tt, null, x, pt), this.styleAttrs = we(x, pt), this.styleRefs = sn(x), this.lang = U;
          }, Ht.prototype.initFromNode = function(tt, x, U, pt) {
            yt.prototype.initFromNode.call(this, tt, x, U, pt);
            var lt = we(U, pt);
            for (var Gt in this.qname = null, this.value = null, lt) if (lt.hasOwnProperty(Gt)) {
              if (this.qname) {
                Ft(pt, "More than one style specified on set");
                break;
              }
              this.qname = Gt, this.value = lt[Gt];
            }
          };
        })(g, typeof sax == "undefined" ? w(5474) : sax, typeof imscNames == "undefined" ? w(977) : imscNames, typeof imscStyles == "undefined" ? w(1219) : imscStyles, typeof imscUtils == "undefined" ? w(6404) : imscUtils);
      }, 1612: function(k, g, w) {
        var B = /firefox/i.test(navigator.userAgent);
        (function(c, d, m) {
          function b(D, yt, Mt, at) {
            var Bt;
            if (Mt.kind === "region") (Bt = document.createElement("div")).style.position = "absolute";
            else if (Mt.kind === "body") Bt = document.createElement("div");
            else if (Mt.kind === "div") Bt = document.createElement("div");
            else if (Mt.kind === "image") {
              if (Bt = document.createElement("img"), D.imgResolver !== null && Mt.src !== null) {
                var jt = D.imgResolver(Mt.src, Bt);
                jt && (Bt.src = jt), Bt.height = D.regionH, Bt.width = D.regionW;
              }
            } else if (Mt.kind === "p") Bt = document.createElement("p");
            else if (Mt.kind === "span") if (Mt.styleAttrs[m.byName.ruby.qname] === "container") Bt = document.createElement("ruby"), D.ruby = !0;
            else if (Mt.styleAttrs[m.byName.ruby.qname] === "base") Bt = document.createElement("span");
            else if (Mt.styleAttrs[m.byName.ruby.qname] === "text") Bt = document.createElement("rt");
            else if (Mt.styleAttrs[m.byName.ruby.qname] === "baseContainer") Bt = document.createElement("rbc");
            else if (Mt.styleAttrs[m.byName.ruby.qname] === "textContainer") Bt = document.createElement("rtc");
            else {
              if (Mt.styleAttrs[m.byName.ruby.qname] === "delimiter") return;
              Bt = document.createElement("span");
            }
            else Mt.kind === "br" && (Bt = document.createElement("br"));
            if (Bt) {
              if (Mt.lang && (Mt.kind !== "region" && Mt.lang === at.lang || (Bt.lang = Mt.lang)), yt.appendChild(Bt), Bt.style.margin = "0", Mt.kind === "region") {
                var At = Mt.styleAttrs[m.byName.writingMode.qname];
                At === "lrtb" || At === "lr" ? (D.ipd = "lr", D.bpd = "tb") : At === "rltb" || At === "rl" ? (D.ipd = "rl", D.bpd = "tb") : At === "tblr" ? (D.ipd = "tb", D.bpd = "lr") : At !== "tbrl" && At !== "tb" || (D.ipd = "tb", D.bpd = "rl");
              } else if (Mt.kind === "p" && D.bpd === "tb") {
                var Ce = Mt.styleAttrs[m.byName.direction.qname];
                D.ipd = Ce === "ltr" ? "lr" : "rl";
              }
              for (var ne = 0; ne < z.length; ne++) {
                var Ht = z[ne], Le = Mt.styleAttrs[Ht.qname];
                Le !== void 0 && Ht.map !== null && Ht.map(D, Bt, Mt, Le);
              }
              var sn = Bt, we = Mt.styleAttrs[m.byName.linePadding.qname];
              if (we && !we.isZero()) {
                var ln = we.toUsedLength(D.w, D.h);
                if (ln > 0) {
                  var _e = Math.ceil(ln) + "px";
                  D.bpd === "tb" ? (sn.style.paddingLeft = _e, sn.style.paddingRight = _e) : (sn.style.paddingTop = _e, sn.style.paddingBottom = _e), D.lp = we;
                }
              }
              var Rn = Mt.styleAttrs[m.byName.multiRowAlign.qname];
              if (Rn && Rn !== "auto") {
                var En = document.createElement("span");
                En.style.display = "inline-block", En.style.textAlign = Rn, Bt.appendChild(En), sn = En, D.mra = Rn;
              }
              var Tn = Mt.styleAttrs[m.byName.rubyReserve.qname];
              if (Tn && Tn[0] !== "none" && (D.rubyReserve = Tn), Mt.styleAttrs[m.byName.fillLineGap.qname] && (D.flg = !0), Mt.kind === "span" && Mt.text) {
                var Nt = Mt.styleAttrs[m.byName.textEmphasis.qname];
                if (Nt && Nt.style !== "none" && (D.textEmphasis = !0), m.byName.textCombine.qname in Mt.styleAttrs && Mt.styleAttrs[m.byName.textCombine.qname] === "all") Bt.textContent = Mt.text, Bt._isd_element = Mt, Nt && h(D, Bt, 0, Nt);
                else for (var Ft = "", ve = 0; ve < Mt.text.length; ve++) {
                  Ft += Mt.text.charAt(ve);
                  var q = Mt.text.charCodeAt(ve);
                  if (q < 55296 || q > 56319 || ve === Mt.text.length - 1) {
                    var tt = document.createElement("span");
                    tt.textContent = Ft, Nt && h(D, tt, 0, Nt), Bt.appendChild(tt), Ft = "", tt._isd_element = Mt;
                  }
                }
              }
              if ("contents" in Mt) for (var x = 0; x < Mt.contents.length; x++) b(D, sn, Mt.contents[x], Mt);
              var U = [];
              if (Mt.kind === "p" && (l(D, sn, U, null), D.rubyReserve && (function(Vt, Jt) {
                for (var Ot = 0; Ot < Vt.length; Ot++) {
                  var Kt, ae, Qt = document.createElement("ruby"), me = document.createElement("span");
                  me.textContent = "", Qt.appendChild(me);
                  var an, Ge = Jt.rubyReserve[1].toUsedLength(Jt.w, Jt.h) + "px";
                  Jt.rubyReserve[0] === "both" || Jt.rubyReserve[0] === "outside" && Vt.length == 1 ? ((Kt = document.createElement("rtc")).style[vt] = Q ? "after" : "under", Kt.textContent = "", Kt.style.fontSize = Ge, (ae = document.createElement("rtc")).style[vt] = Q ? "before" : "over", ae.textContent = "", ae.style.fontSize = Ge, Qt.appendChild(Kt), Qt.appendChild(ae)) : ((Kt = document.createElement("rtc")).textContent = "", Kt.style.fontSize = Ge, an = Jt.rubyReserve[0] === "after" || Jt.rubyReserve[0] === "outside" && Ot > 0 ? Q ? "after" : Jt.bpd === "tb" || Jt.bpd === "rl" ? "under" : "over" : Q ? "before" : Jt.bpd === "tb" || Jt.bpd === "rl" ? "over" : "under", Kt.style[vt] = an, Qt.appendChild(Kt));
                  for (var Te = null, ge = 0; ge < Vt[Ot].rbc.length; ge++) if (Vt[Ot].rbc[ge].localName === "ruby") {
                    Te = Vt[Ot].rbc[ge];
                    for (var ze = 0; ze < Te.style.length; ze++) Qt.style.setProperty(Te.style.item(ze), Te.style.getPropertyValue(Te.style.item(ze)));
                    break;
                  }
                  (Te = Te || Vt[Ot].elements[0].node).parentElement.insertBefore(Qt, Te);
                }
              }(U, D), D.rubyReserve = null), (D.ruby || D.rubyReserve) && (function(Vt, Jt) {
                for (var Ot = 0; Ot < Vt.length; Ot++) for (var Kt = 0; Kt < Vt[Ot].rbc.length; Kt++) {
                  var ae;
                  Vt[Ot].rbc[Kt].style[vt] || (ae = Q ? Ot === 0 ? "before" : "after" : Jt.bpd === "tb" || Jt.bpd === "rl" ? Ot === 0 ? "over" : "under" : Ot === 0 ? "under" : "over", Vt[Ot].rbc[Kt].style[vt] = ae);
                }
              }(U, D), D.ruby = null), D.textEmphasis && (function(Vt, Jt) {
                for (var Ot = 0; Ot < Vt.length; Ot++) for (var Kt = 0; Kt < Vt[Ot].te.length; Kt++) {
                  var ae;
                  Vt[Ot].te[Kt].style[zt] && Vt[Ot].te[Kt].style[zt] !== "none" || (ae = Jt.bpd === "tb" ? Ot === 0 ? "left over" : "left under" : Jt.bpd === "rl" ? Ot === 0 ? "right under" : "left under" : Ot === 0 ? "left under" : "right under", Vt[Ot].te[Kt].style[zt] = ae);
                }
              }(U, D), D.textEmphasis = null), D.mra && (function(Vt) {
                for (var Jt = 0; Jt < Vt.length - 1; Jt++) {
                  var Ot = Vt[Jt].elements.length;
                  if (Ot !== 0 && Vt[Jt].br === !1) {
                    var Kt = document.createElement("br"), ae = Vt[Jt].elements[Ot - 1].node;
                    ae.parentElement.insertBefore(Kt, ae.nextSibling);
                  }
                }
              }(U), D.mra = null), D.lp && (function(Vt, Jt, Ot) {
                if (Vt !== null) for (var Kt = 0; Kt < Vt.length; Kt++) {
                  var ae = Vt[Kt].elements.length, Qt = Math.ceil(Jt) + "px", me = "-" + Math.ceil(Jt) + "px";
                  if (ae !== 0) {
                    var an = Vt[Kt].elements[Vt[Kt].start_elem], Ge = Vt[Kt].elements[Vt[Kt].end_elem];
                    if (an === Ge) {
                      var Te = an.node.getBoundingClientRect();
                      if (Te.width == 0 || Te.height == 0) continue;
                    }
                    Ot.ipd === "lr" ? (an.node.style.marginLeft = me, an.node.style.paddingLeft = Qt) : Ot.ipd === "rl" ? (an.node.style.paddingRight = Qt, an.node.style.marginRight = me) : Ot.ipd === "tb" && (an.node.style.paddingTop = Qt, an.node.style.marginTop = me), Ot.ipd === "lr" ? (B || (Ge.node.style.marginRight = me), Ge.node.style.paddingRight = Qt) : Ot.ipd === "rl" ? (Ge.node.style.paddingLeft = Qt, B || (Ge.node.style.marginLeft = me)) : Ot.ipd === "tb" && (Ge.node.style.paddingBottom = Qt, Ge.node.style.marginBottom = me);
                  }
                }
              }(U, D.lp.toUsedLength(D.w, D.h), D), D.lp = null), function(Vt, Jt) {
                for (var Ot = 0; Ot < Vt.length; Ot++) for (var Kt = Vt[Ot], ae = 1; ae < Kt.elements.length; ) {
                  var Qt = Kt.elements[ae - 1], me = Kt.elements[ae];
                  T(Qt.node, me.node, Jt) ? Kt.elements.splice(ae, 1) : ae++;
                }
                for (var an, Ge, Te = [], ge = 0; ge < Vt.length; ge++) for (var ze = 0; ze < Vt[ge].elements.length; ze++) (Ge = y(an = Vt[ge].elements[ze].node, Te, !1)) && (an.style.backgroundColor = Ge);
                for (var Zn = 0; Zn < Te.length; Zn++) Te[Zn].style.backgroundColor = "";
              }(U, D), D.flg)) {
                var pt = o(sn.getBoundingClientRect(), D);
                (function(Vt, Jt, Ot, Kt) {
                  for (var ae = Math.sign(Ot - Jt), Qt = 0; Qt <= Vt.length; Qt++) {
                    var me, an, Ge, Te;
                    if (me = Qt === 0 ? Math.round(Jt) : Qt === Vt.length ? Math.round(Ot) : Math.round((Vt[Qt - 1].after + Vt[Qt].before) / 2), Qt > 0 && Vt[Qt - 1]) for (Ge = 0; Ge < Vt[Qt - 1].elements.length; Ge++) an = ae * (me - (Te = Vt[Qt - 1].elements[Ge]).after) + "px", Kt.bpd === "lr" ? Te.node.style.paddingRight = an : Kt.bpd === "rl" ? Te.node.style.paddingLeft = an : Kt.bpd === "tb" && (Te.node.style.paddingBottom = an);
                    if (Qt < Vt.length) for (Ge = 0; Ge < Vt[Qt].elements.length; Ge++) an = ae * ((Te = Vt[Qt].elements[Ge]).before - me) + "px", Kt.bpd === "lr" ? Te.node.style.paddingLeft = an : Kt.bpd === "rl" ? Te.node.style.paddingRight = an : Kt.bpd === "tb" && (Te.node.style.paddingTop = an);
                  }
                })(U, pt.before, pt.after, D), D.flg = null;
              }
              if (Mt.kind === "region" && D.bpd === "tb" && D.enableRollUp && Mt.contents.length > 0 && Mt.styleAttrs[m.byName.displayAlign.qname] === "after") {
                l(D, sn, U, null);
                var lt = new n(Mt.id === "" ? "_" : Mt.id, U);
                if (D.currentISDState[lt.id] = lt, D.previousISDState && lt.id in D.previousISDState && D.previousISDState[lt.id].plist.length > 0 && lt.plist.length > 1 && lt.plist[lt.plist.length - 2].text === D.previousISDState[lt.id].plist[D.previousISDState[lt.id].plist.length - 1].text) {
                  var Gt = Bt.firstElementChild, ee = lt.plist[lt.plist.length - 1].after - lt.plist[lt.plist.length - 1].before;
                  Gt.style.bottom = "-" + ee + "px", Gt.style.transition = "transform 0.4s", Gt.style.position = "relative", Gt.style.transform = "translateY(-" + ee + "px)";
                }
              }
            } else X(D.errorHandler, "Error processing ISD element kind: " + Mt.kind);
          }
          function y(D, yt, Mt) {
            return D.style.backgroundColor ? (Mt && !yt.includes(D) && yt.push(D), D.style.backgroundColor) : D.parentElement.nodeName === "SPAN" || D.parentElement.nodeName === "RUBY" || D.parentElement.nodeName === "RBC" || D.parentElement.nodeName === "RTC" || D.parentElement.nodeName === "RT" ? y(D.parentElement, yt, !0) : void 0;
          }
          function T(D, yt, Mt) {
            if (D.tagName === "SPAN" && yt.tagName === "SPAN" && D._isd_element === yt._isd_element) {
              if (!D._isd_element) return X(Mt.errorHandler, "Internal error: HTML span is not linked to a source element; cannot merge spans."), !1;
              D.textContent += yt.textContent;
              for (var at = 0; at < yt.style.length; at++) {
                var Bt = yt.style[at];
                (Bt.indexOf("border") >= 0 || Bt.indexOf("padding") >= 0 || Bt.indexOf("margin") >= 0) && (D.style[Bt] = yt.style[Bt]);
              }
              return yt.parentElement.removeChild(yt), !0;
            }
            return !1;
          }
          function n(D, yt) {
            this.id = D, this.plist = yt;
          }
          function o(D, yt) {
            var Mt = { before: null, after: null, start: null, end: null };
            return yt.bpd === "tb" ? (Mt.before = D.top, Mt.after = D.bottom, yt.ipd === "lr" ? (Mt.start = D.left, Mt.end = D.right) : (Mt.start = D.right, Mt.end = D.left)) : yt.bpd === "lr" ? (Mt.before = D.left, Mt.after = D.right, Mt.start = D.top, Mt.end = D.bottom) : yt.bpd === "rl" && (Mt.before = D.right, Mt.after = D.left, Mt.start = D.top, Mt.end = D.bottom), Mt;
          }
          function l(D, yt, Mt, at) {
            if (yt.localName !== "rt" && yt.localName !== "rtc") {
              var Bt, jt, At, Ce, ne = yt.style.backgroundColor || at;
              if (yt.childElementCount === 0) if (yt.localName === "span" || yt.localName === "rb") {
                var Ht = o(yt.getBoundingClientRect(), D);
                if (Mt.length !== 0 && (Bt = Ht.before, jt = Ht.after, At = Mt[Mt.length - 1].before, jt < (Ce = Mt[Mt.length - 1].after) && Bt > At || Ce <= jt && At >= Bt)) {
                  var Le = Math.sign(Ht.after - Ht.before), sn = Math.sign(Ht.end - Ht.start);
                  Le * (Ht.before - Mt[Mt.length - 1].before) < 0 && (Mt[Mt.length - 1].before = Ht.before), Le * (Ht.after - Mt[Mt.length - 1].after) > 0 && (Mt[Mt.length - 1].after = Ht.after), sn * (Ht.start - Mt[Mt.length - 1].start) < 0 && (Mt[Mt.length - 1].start = Ht.start, Mt[Mt.length - 1].start_elem = Mt[Mt.length - 1].elements.length), sn * (Ht.end - Mt[Mt.length - 1].end) > 0 && (Mt[Mt.length - 1].end = Ht.end, Mt[Mt.length - 1].end_elem = Mt[Mt.length - 1].elements.length);
                } else Mt.push({ before: Ht.before, after: Ht.after, start: Ht.start, end: Ht.end, start_elem: 0, end_elem: 0, elements: [], rbc: [], te: [], text: "", br: !1 });
                Mt[Mt.length - 1].text += yt.textContent, Mt[Mt.length - 1].elements.push({ node: yt, bgcolor: ne, before: Ht.before, after: Ht.after });
              } else yt.localName === "br" && Mt.length !== 0 && (Mt[Mt.length - 1].br = !0);
              else for (var we = yt.firstChild; we; ) we.nodeType === Node.ELEMENT_NODE && (l(D, we, Mt, ne), we.localName === "ruby" || we.localName === "rtc" ? Mt.length > 0 && Mt[Mt.length - 1].rbc.push(we) : we.localName === "span" && we.style[Lt] && we.style[Lt] !== "none" && Mt.length > 0 && Mt[Mt.length - 1].te.push(we)), we = we.nextSibling;
            }
          }
          function h(D, yt, Mt, at) {
            var Bt;
            at.style !== "none" && (at.style === "auto" ? yt.style[Lt] = "filled" : yt.style[Lt] = at.style + " " + at.symbol, (at.position === "before" || at.position === "after") && (Bt = D.bpd === "tb" ? at.position === "before" ? "left over" : "left under" : D.bpd === "rl" ? at.position === "before" ? "right under" : "left under" : at.position === "before" ? "left under" : "right under", yt.style[zt] = Bt));
          }
          function p(D, yt) {
            this.qname = D, this.map = yt;
          }
          c.render = function(D, yt, Mt, at, Bt, jt, At, Ce, ne) {
            var Ht = at || yt.clientHeight, Le = Bt || yt.clientWidth;
            if (D.aspectRatio !== null) {
              var sn = Ht * D.aspectRatio;
              sn > Le ? Ht = Math.round(Le / D.aspectRatio) : Le = sn;
            }
            var we = document.createElement("div");
            we.style.position = "relative", we.style.width = Le + "px", we.style.height = Ht + "px", we.style.margin = "auto", we.style.top = 0, we.style.bottom = 0, we.style.left = 0, we.style.right = 0, we.style.zIndex = 0;
            var ln = { h: Ht, w: Le, regionH: null, regionW: null, imgResolver: Mt, displayForcedOnlyMode: jt || !1, isd: D, errorHandler: At, previousISDState: Ce, enableRollUp: ne || !1, currentISDState: {}, flg: null, lp: null, mra: null, ipd: null, bpd: null, ruby: null, textEmphasis: null, rubyReserve: null };
            if (yt.appendChild(we), "contents" in D) for (var _e = 0; _e < D.contents.length; _e++) b(ln, we, D.contents[_e], D);
            return ln.currentISDState;
          };
          for (var z = [new p("http://www.w3.org/ns/ttml#styling backgroundColor", function(D, yt, Mt, at) {
            at[3] !== 0 && (yt.style.backgroundColor = "rgba(" + at[0].toString() + "," + at[1].toString() + "," + at[2].toString() + "," + (at[3] / 255).toString() + ")");
          }), new p("http://www.w3.org/ns/ttml#styling color", function(D, yt, Mt, at) {
            yt.style.color = "rgba(" + at[0].toString() + "," + at[1].toString() + "," + at[2].toString() + "," + (at[3] / 255).toString() + ")";
          }), new p("http://www.w3.org/ns/ttml#styling direction", function(D, yt, Mt, at) {
            yt.style.direction = at;
          }), new p("http://www.w3.org/ns/ttml#styling display", function(D, yt, Mt, at) {
          }), new p("http://www.w3.org/ns/ttml#styling displayAlign", function(D, yt, Mt, at) {
            yt.style.display = "flex", yt.style.flexDirection = "column", at === "before" ? yt.style.justifyContent = "flex-start" : at === "center" ? yt.style.justifyContent = "center" : at === "after" && (yt.style.justifyContent = "flex-end");
          }), new p("http://www.w3.org/ns/ttml#styling extent", function(D, yt, Mt, at) {
            D.regionH = at.h.toUsedLength(D.w, D.h), D.regionW = at.w.toUsedLength(D.w, D.h);
            var Bt = 0, jt = 0, At = Mt.styleAttrs["http://www.w3.org/ns/ttml#styling padding"];
            At && (Bt = At[0].toUsedLength(D.w, D.h) + At[2].toUsedLength(D.w, D.h), jt = At[1].toUsedLength(D.w, D.h) + At[3].toUsedLength(D.w, D.h)), yt.style.height = D.regionH - Bt + "px", yt.style.width = D.regionW - jt + "px";
          }), new p("http://www.w3.org/ns/ttml#styling fontFamily", function(D, yt, Mt, at) {
            for (var Bt = [], jt = 0; jt < at.length; jt++) at[jt] = at[jt].trim(), at[jt] === "monospaceSerif" ? (Bt.push("Courier New"), Bt.push('"Liberation Mono"'), Bt.push("Courier"), Bt.push("monospace")) : at[jt] === "proportionalSansSerif" ? (Bt.push("Arial"), Bt.push("Helvetica"), Bt.push('"Liberation Sans"'), Bt.push("sans-serif")) : at[jt] === "monospace" ? Bt.push("monospace") : at[jt] === "sansSerif" ? Bt.push("sans-serif") : at[jt] === "serif" ? Bt.push("serif") : at[jt] === "monospaceSansSerif" ? (Bt.push("Consolas"), Bt.push("monospace")) : at[jt] === "proportionalSerif" ? Bt.push("serif") : Bt.push(at[jt]);
            if (Bt.length > 0) {
              for (var At = [Bt[0]], Ce = 1; Ce < Bt.length; Ce++) At.indexOf(Bt[Ce]) == -1 && At.push(Bt[Ce]);
              Bt = At;
            }
            yt.style.fontFamily = Bt.join(",");
          }), new p("http://www.w3.org/ns/ttml#styling shear", function(D, yt, Mt, at) {
            if (at !== 0) {
              var Bt = -0.9 * at;
              D.bpd === "tb" ? yt.style.transform = "skewX(" + Bt + "deg)" : yt.style.transform = "skewY(" + Bt + "deg)";
            }
          }), new p("http://www.w3.org/ns/ttml#styling fontSize", function(D, yt, Mt, at) {
            yt.style.fontSize = at.toUsedLength(D.w, D.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling fontStyle", function(D, yt, Mt, at) {
            yt.style.fontStyle = at;
          }), new p("http://www.w3.org/ns/ttml#styling fontWeight", function(D, yt, Mt, at) {
            yt.style.fontWeight = at;
          }), new p("http://www.w3.org/ns/ttml#styling lineHeight", function(D, yt, Mt, at) {
            yt.style.lineHeight = at === "normal" ? "normal" : at.toUsedLength(D.w, D.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling opacity", function(D, yt, Mt, at) {
            yt.style.opacity = at;
          }), new p("http://www.w3.org/ns/ttml#styling origin", function(D, yt, Mt, at) {
            yt.style.top = at.h.toUsedLength(D.w, D.h) + "px", yt.style.left = at.w.toUsedLength(D.w, D.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling overflow", function(D, yt, Mt, at) {
            yt.style.overflow = at;
          }), new p("http://www.w3.org/ns/ttml#styling padding", function(D, yt, Mt, at) {
            var Bt = [];
            Bt[0] = at[0].toUsedLength(D.w, D.h) + "px", Bt[1] = at[3].toUsedLength(D.w, D.h) + "px", Bt[2] = at[2].toUsedLength(D.w, D.h) + "px", Bt[3] = at[1].toUsedLength(D.w, D.h) + "px", yt.style.padding = Bt.join(" ");
          }), new p("http://www.w3.org/ns/ttml#styling position", function(D, yt, Mt, at) {
            yt.style.top = at.h.toUsedLength(D.w, D.h) + "px", yt.style.left = at.w.toUsedLength(D.w, D.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling rubyAlign", function(D, yt, Mt, at) {
            yt.style.rubyAlign = at === "spaceAround" ? "space-around" : "center";
          }), new p("http://www.w3.org/ns/ttml#styling rubyPosition", function(D, yt, Mt, at) {
            var Bt;
            at !== "before" && at !== "after" || (Bt = Q ? at : D.bpd === "tb" || D.bpd === "rl" ? at === "before" ? "over" : "under" : at === "before" ? "under" : "over", yt.parentElement.style[vt] = Bt);
          }), new p("http://www.w3.org/ns/ttml#styling showBackground", null), new p("http://www.w3.org/ns/ttml#styling textAlign", function(D, yt, Mt, at) {
            var Bt;
            Bt = at === "start" ? D.ipd === "rl" ? "right" : "left" : at === "end" ? D.ipd === "rl" ? "left" : "right" : at, yt.style.textAlign = Bt;
          }), new p("http://www.w3.org/ns/ttml#styling textDecoration", function(D, yt, Mt, at) {
            yt.style.textDecoration = at.join(" ").replace("lineThrough", "line-through");
          }), new p("http://www.w3.org/ns/ttml#styling textOutline", function(D, yt, Mt, at) {
          }), new p("http://www.w3.org/ns/ttml#styling textShadow", function(D, yt, Mt, at) {
            var Bt = Mt.styleAttrs[m.byName.textOutline.qname];
            if (at === "none" && Bt === "none") yt.style.textShadow = "";
            else {
              var jt = [];
              if (Bt !== "none") {
                var At = "rgba(" + Bt.color[0].toString() + "," + Bt.color[1].toString() + "," + Bt.color[2].toString() + "," + (Bt.color[3] / 255).toString() + ")";
                jt.push("1px 1px 1px " + At), jt.push("-1px 1px 1px " + At), jt.push("1px -1px 1px " + At), jt.push("-1px -1px 1px " + At);
              }
              if (at !== "none") for (var Ce = 0; Ce < at.length; Ce++) jt.push(at[Ce].x_off.toUsedLength(D.w, D.h) + "px " + at[Ce].y_off.toUsedLength(D.w, D.h) + "px " + at[Ce].b_radius.toUsedLength(D.w, D.h) + "px rgba(" + at[Ce].color[0].toString() + "," + at[Ce].color[1].toString() + "," + at[Ce].color[2].toString() + "," + (at[Ce].color[3] / 255).toString() + ")");
              yt.style.textShadow = jt.join(",");
            }
          }), new p("http://www.w3.org/ns/ttml#styling textCombine", function(D, yt, Mt, at) {
            yt.style.textCombineUpright = at;
          }), new p("http://www.w3.org/ns/ttml#styling textEmphasis", function(D, yt, Mt, at) {
          }), new p("http://www.w3.org/ns/ttml#styling unicodeBidi", function(D, yt, Mt, at) {
            var Bt;
            Bt = at === "bidiOverride" ? "bidi-override" : at, yt.style.unicodeBidi = Bt;
          }), new p("http://www.w3.org/ns/ttml#styling visibility", function(D, yt, Mt, at) {
            yt.style.visibility = at;
          }), new p("http://www.w3.org/ns/ttml#styling wrapOption", function(D, yt, Mt, at) {
            at === "wrap" ? Mt.space === "preserve" ? yt.style.whiteSpace = "pre-wrap" : yt.style.whiteSpace = "normal" : Mt.space === "preserve" ? yt.style.whiteSpace = "pre" : yt.style.whiteSpace = "noWrap";
          }), new p("http://www.w3.org/ns/ttml#styling writingMode", function(D, yt, Mt, at) {
            at === "lrtb" || at === "lr" || at === "rltb" || at === "rl" ? yt.style.writingMode = "horizontal-tb" : at === "tblr" ? yt.style.writingMode = "vertical-lr" : at !== "tbrl" && at !== "tb" || (yt.style.writingMode = "vertical-rl");
          }), new p("http://www.w3.org/ns/ttml#styling zIndex", function(D, yt, Mt, at) {
            yt.style.zIndex = at;
          }), new p("http://www.w3.org/ns/ttml/profile/imsc1#styling forcedDisplay", function(D, yt, Mt, at) {
            D.displayForcedOnlyMode && at === !1 && (yt.style.visibility = "hidden");
          })], Z = {}, V = 0; V < z.length; V++) Z[z[V].qname] = z[V];
          var Q = "webkitRubyPosition" in window.getComputedStyle(document.documentElement), vt = Q ? "webkitRubyPosition" : "rubyPosition", Lt = "webkitTextEmphasisStyle" in window.getComputedStyle(document.documentElement) ? "webkitTextEmphasisStyle" : "textEmphasisStyle", zt = "webkitTextEmphasisPosition" in window.getComputedStyle(document.documentElement) ? "webkitTextEmphasisPosition" : "textEmphasisPosition";
          function X(D, yt) {
            if (D && D.error && D.error(yt)) throw yt;
          }
        })(g, typeof imscNames == "undefined" ? w(977) : imscNames, typeof imscStyles == "undefined" ? w(1219) : imscStyles, typeof imscUtils == "undefined" ? w(6404) : imscUtils);
      }, 8905: function(k, g, w) {
        (function(B, c, d, m) {
          B.generateISD = function(p, z, Z) {
            var V, Q = new o(p), vt = {}, Lt = {}, zt = p.head.styling.initials[d.byName.showBackground.qname], X = p.head.styling.initials[d.byName.backgroundColor.qname];
            for (var D in p.head.layout.regions) if (p.head.layout.regions.hasOwnProperty(D)) {
              var yt = p.head.layout.regions[D], Mt = yt.styleAttrs[d.byName.showBackground.qname] || zt, at = yt.styleAttrs[d.byName.backgroundColor.qname] || X;
              Lt[yt.id] = (Mt === "always" || Mt === void 0) && at !== void 0 && !(z < yt.begin || z >= yt.end);
            }
            for (var Bt in p.body && p.body.regionID && (Lt[p.body.regionID] = !0), V = p.body !== null ? function At(Ce, ne) {
              if (ne.contents) {
                var Ht = {};
                for (var Le in ne) ne.hasOwnProperty(Le) && (Ht[Le] = ne[Le]);
                return Ht.contents = [], ne.contents.filter(function(sn) {
                  return !(Ce < sn.begin || Ce >= sn.end);
                }).forEach(function(sn) {
                  var we = At(Ce, sn);
                  we.regionID && (Lt[we.regionID] = !0), we !== null && Ht.contents.push(we);
                }), Ht;
              }
              return ne;
            }(z, p.body) : null, Lt[""] !== void 0 && (Lt[""] = !0), Lt) if (Lt[Bt]) {
              var jt = y(p, z, p.head.layout.regions[Bt], V, null, "", p.head.layout.regions[Bt], Z, vt);
              jt !== null && Q.contents.push(jt.element);
            }
            return Q;
          };
          var b = [d.byName.color.qname, d.byName.textCombine.qname, d.byName.textDecoration.qname, d.byName.textEmphasis.qname, d.byName.textOutline.qname, d.byName.textShadow.qname];
          function y(p, z, Z, V, Q, vt, Lt, zt, X) {
            if (z < Lt.begin || z >= Lt.end) return null;
            var D = "regionID" in Lt && Lt.regionID !== "" ? Lt.regionID : vt;
            if (Q !== null && D !== Z.id && (!("contents" in Lt) || "contents" in Lt && Lt.contents.length === 0 || D !== "")) return null;
            var yt = new l(Lt);
            if ("sets" in Lt) for (var Mt = 0; Mt < Lt.sets.length; Mt++) z < Lt.sets[Mt].begin || z >= Lt.sets[Mt].end || (yt.styleAttrs[Lt.sets[Mt].qname] = Lt.sets[Mt].value);
            var at = {};
            for (var Bt in yt.styleAttrs) if (yt.styleAttrs.hasOwnProperty(Bt) && (at[Bt] = !0, yt.kind === "region" && Bt === d.byName.writingMode.qname && !(d.byName.direction.qname in yt.styleAttrs))) {
              var jt = yt.styleAttrs[Bt];
              jt === "lrtb" || jt === "lr" ? yt.styleAttrs[d.byName.direction.qname] = "ltr" : jt !== "rltb" && jt !== "rl" || (yt.styleAttrs[d.byName.direction.qname] = "rtl");
            }
            if (Q !== null) for (var At = 0; At < d.all.length; At++) {
              var Ce = d.all[At];
              if (Ce.qname === d.byName.textDecoration.qname) {
                var ne = Q.styleAttrs[Ce.qname], Ht = yt.styleAttrs[Ce.qname], Le = [];
                Ht === void 0 ? Le = ne : Ht.indexOf("none") === -1 ? ((Ht.indexOf("noUnderline") === -1 && ne.indexOf("underline") !== -1 || Ht.indexOf("underline") !== -1) && Le.push("underline"), (Ht.indexOf("noLineThrough") === -1 && ne.indexOf("lineThrough") !== -1 || Ht.indexOf("lineThrough") !== -1) && Le.push("lineThrough"), (Ht.indexOf("noOverline") === -1 && ne.indexOf("overline") !== -1 || Ht.indexOf("overline") !== -1) && Le.push("overline")) : Le.push("none"), yt.styleAttrs[Ce.qname] = Le;
              } else if (Ce.qname !== d.byName.fontSize.qname || Ce.qname in yt.styleAttrs || yt.kind !== "span" || yt.styleAttrs[d.byName.ruby.qname] !== "textContainer") if (Ce.qname !== d.byName.fontSize.qname || Ce.qname in yt.styleAttrs || yt.kind !== "span" || yt.styleAttrs[d.byName.ruby.qname] !== "text") Ce.inherit && Ce.qname in Q.styleAttrs && !(Ce.qname in yt.styleAttrs) && (yt.styleAttrs[Ce.qname] = Q.styleAttrs[Ce.qname]);
              else {
                var sn = Q.styleAttrs[d.byName.fontSize.qname];
                Q.styleAttrs[d.byName.ruby.qname] === "textContainer" ? yt.styleAttrs[Ce.qname] = sn : yt.styleAttrs[Ce.qname] = new m.ComputedLength(0.5 * sn.rw, 0.5 * sn.rh);
              }
              else {
                var we = Q.styleAttrs[d.byName.fontSize.qname];
                yt.styleAttrs[Ce.qname] = new m.ComputedLength(0.5 * we.rw, 0.5 * we.rh);
              }
            }
            for (var ln = 0; ln < d.all.length; ln++) {
              var _e = d.all[ln];
              if (!(_e.qname in yt.styleAttrs) && !(_e.qname === d.byName.position.qname && d.byName.origin.qname in yt.styleAttrs || _e.qname === d.byName.origin.qname && d.byName.position.qname in yt.styleAttrs)) {
                var Rn = p.head.styling.initials[_e.qname] || _e.initial;
                if (Rn !== null && (yt.kind === "region" || _e.inherit === !1 && Rn !== null)) {
                  var En = _e.parse(Rn);
                  En !== null ? (yt.styleAttrs[_e.qname] = En, at[_e.qname] = !0) : h(zt, "Invalid initial value for '" + _e.qname + "' on element '" + yt.kind);
                }
              }
            }
            for (var Tn = 0; Tn < d.all.length; Tn++) {
              var Nt = d.all[Tn];
              if (Nt.qname in at && Nt.compute !== null) {
                var Ft = Nt.compute(p, Q, yt, yt.styleAttrs[Nt.qname], X);
                Ft !== null ? yt.styleAttrs[Nt.qname] = Ft : (yt.styleAttrs[Nt.qname] = Nt.compute(p, Q, yt, Nt.parse(Nt.initial), X), h(zt, "Style '" + Nt.qname + "' on element '" + yt.kind + "' cannot be computed"));
              }
            }
            if (yt.styleAttrs[d.byName.display.qname] === "none") return null;
            var ve = null;
            Q === null ? ve = V === null ? [] : [V] : "contents" in Lt && (ve = Lt.contents);
            for (var q = 0; ve !== null && q < ve.length; q++) {
              var tt = y(p, z, Z, V, yt, D, ve[q], zt, X);
              tt !== null && yt.contents.push(tt.element);
            }
            for (var x in yt.styleAttrs) if (yt.styleAttrs.hasOwnProperty(x)) {
              var U = !1;
              if (yt.kind === "span") {
                var pt = yt.styleAttrs[d.byName.ruby.qname];
                (U = (pt === "container" || pt === "textContainer" || pt === "baseContainer") && b.indexOf(x) !== -1) || (U = pt !== "container" && x === d.byName.rubyAlign.qname), U || (U = !(pt === "textContainer" || pt === "text") && x === d.byName.rubyPosition.qname);
              }
              if (!U) {
                var lt = d.byQName[x];
                "applies" in lt && (U = lt.applies.indexOf(yt.kind) === -1);
              }
              U && delete yt.styleAttrs[x];
            }
            var Gt = yt.styleAttrs[d.byName.ruby.qname];
            if (yt.kind === "p" || yt.kind === "span" && (Gt === "textContainer" || Gt === "text")) {
              var ee = [];
              T(yt, ee), function(Vt) {
                for (var Jt, Ot = 0; Ot < Vt.length; ) if ((Jt = Vt[Ot]).kind !== "br" && Jt.space !== "preserve") {
                  var Kt = Jt.text.replace(/[\t\r\n ]+/g, " ");
                  /^[ ]/.test(Kt) && (Ot === 0 || (ae = Vt[Ot - 1]).kind === "br" || /[\r\n\t ]$/.test(ae.text)) && (Kt = Kt.substring(1)), Jt.text = Kt, Kt.length === 0 ? Vt.splice(Ot, 1) : Ot++;
                } else Ot++;
                var ae, Qt;
                for (Ot = 0; Ot < Vt.length; Ot++) (Jt = Vt[Ot]).kind !== "br" && Jt.space !== "preserve" ? /[ ]$/.test(Jt.text) && (Ot === Vt.length - 1 || (Qt = Vt[Ot + 1]).kind === "br" || Qt.space === "preserve" && /^[\r\n]/.test(Qt.text)) && (Jt.text = Jt.text.slice(0, -1)) : Ot++;
              }(ee), n(yt);
            }
            return yt.kind === "div" && d.byName.backgroundImage.qname in yt.styleAttrs || yt.kind === "br" || yt.kind === "image" || "contents" in yt && yt.contents.length > 0 || yt.kind === "span" && yt.text !== null || yt.kind === "region" && yt.styleAttrs[d.byName.showBackground.qname] === "always" ? { region_id: D, element: yt } : null;
          }
          function T(p, z) {
            if ("contents" in p) for (var Z = 0; Z < p.contents.length; Z++) {
              var V = p.contents[Z], Q = V.styleAttrs[d.byName.ruby.qname];
              (V.kind !== "span" || Q !== "textContainer" && Q !== "text") && ("contents" in V ? T(V, z) : (V.kind === "span" && V.text.length !== 0 || V.kind === "br") && z.push(V));
            }
          }
          function n(p) {
            if (p.kind === "br") return !1;
            if ("text" in p) return p.text.length === 0;
            if ("contents" in p) {
              for (var z = p.contents.length; z--; ) n(p.contents[z]) && p.contents.splice(z, 1);
              return p.contents.length === 0;
            }
          }
          function o(p) {
            this.contents = [], this.aspectRatio = p.aspectRatio, this.lang = p.lang;
          }
          function l(p) {
            for (var z in this.kind = p.kind || "region", this.lang = p.lang, p.id && (this.id = p.id), this.styleAttrs = {}, p.styleAttrs) p.styleAttrs.hasOwnProperty(z) && (this.styleAttrs[z] = p.styleAttrs[z]);
            "src" in p && (this.src = p.src), "type" in p && (this.type = p.type), "text" in p ? this.text = p.text : (this.kind === "region" || "contents" in p) && (this.contents = []), "space" in p && (this.space = p.space);
          }
          function h(p, z) {
            if (p && p.error && p.error(z)) throw z;
          }
        })(g, typeof imscNames == "undefined" ? w(977) : imscNames, typeof imscStyles == "undefined" ? w(1219) : imscStyles, typeof imscUtils == "undefined" ? w(6404) : imscUtils);
      }, 7640: function(k, g, w) {
        g.generateISD = w(8905).generateISD, g.fromXML = w(6739).fromXML, g.renderHTML = w(1612).render;
      }, 977: function(k, g) {
        (function(w) {
          w.ns_tt = "http://www.w3.org/ns/ttml", w.ns_tts = "http://www.w3.org/ns/ttml#styling", w.ns_ttp = "http://www.w3.org/ns/ttml#parameter", w.ns_xml = "http://www.w3.org/XML/1998/namespace", w.ns_itts = "http://www.w3.org/ns/ttml/profile/imsc1#styling", w.ns_ittp = "http://www.w3.org/ns/ttml/profile/imsc1#parameter", w.ns_smpte = "http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt", w.ns_ebutts = "urn:ebu:tt:style";
        })(g);
      }, 1219: function(k, g, w) {
        (function(B, c, d) {
          function m(T, n, o, l, h, p, z, Z) {
            this.name = n, this.ns = T, this.qname = T + " " + n, this.inherit = h, this.animatable = p, this.initial = o, this.applies = l, this.parse = z, this.compute = Z;
          }
          for (var b in B.all = [new m(c.ns_tts, "backgroundColor", "transparent", ["body", "div", "p", "region", "span"], !1, !0, d.parseColor, null), new m(c.ns_tts, "color", "white", ["span"], !0, !0, d.parseColor, null), new m(c.ns_tts, "direction", "ltr", ["p", "span"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "display", "auto", ["body", "div", "p", "region", "span"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "displayAlign", "before", ["region"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "extent", "auto", ["tt", "region"], !1, !0, function(T) {
            if (T === "auto") return T;
            var n = T.split(" ");
            if (n.length !== 2) return null;
            var o = d.parseLength(n[0]), l = d.parseLength(n[1]);
            return l && o ? { h: l, w: o } : null;
          }, function(T, n, o, l, h) {
            var p, z;
            if (l === "auto") p = new d.ComputedLength(0, 1);
            else if ((p = d.toComputedLength(l.h.value, l.h.unit, null, T.dimensions.h, null, T.pxLength.h)) === null) return null;
            if (l === "auto") z = new d.ComputedLength(1, 0);
            else if ((z = d.toComputedLength(l.w.value, l.w.unit, null, T.dimensions.w, null, T.pxLength.w)) === null) return null;
            return { h: p, w: z };
          }), new m(c.ns_tts, "fontFamily", "default", ["span", "p"], !0, !0, function(T) {
            for (var n = T.split(","), o = [], l = 0; l < n.length; l++) n[l] = n[l].trim(), n[l].charAt(0) !== "'" && n[l].charAt(0) !== '"' && n[l] === "default" ? o.push("monospaceSerif") : o.push(n[l]);
            return o;
          }, null), new m(c.ns_tts, "shear", "0%", ["p"], !0, !0, d.parseLength, function(T, n, o, l) {
            return l.unit !== "%" ? null : Math.abs(l.value) > 100 ? 100 * Math.sign(l.value) : l.value;
          }), new m(c.ns_tts, "fontSize", "1c", ["span", "p"], !0, !0, d.parseLength, function(T, n, o, l, h) {
            return d.toComputedLength(l.value, l.unit, n !== null ? n.styleAttrs[B.byName.fontSize.qname] : T.cellLength.h, n !== null ? n.styleAttrs[B.byName.fontSize.qname] : T.cellLength.h, T.cellLength.h, T.pxLength.h);
          }), new m(c.ns_tts, "fontStyle", "normal", ["span", "p"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "fontWeight", "normal", ["span", "p"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "lineHeight", "normal", ["p"], !0, !0, function(T) {
            return T === "normal" ? T : d.parseLength(T);
          }, function(T, n, o, l, h) {
            var p;
            if (l === "normal") p = l;
            else if ((p = d.toComputedLength(l.value, l.unit, o.styleAttrs[B.byName.fontSize.qname], o.styleAttrs[B.byName.fontSize.qname], T.cellLength.h, T.pxLength.h)) === null) return null;
            return p;
          }), new m(c.ns_tts, "opacity", 1, ["region"], !1, !0, parseFloat, null), new m(c.ns_tts, "origin", "auto", ["region"], !1, !0, function(T) {
            if (T === "auto") return T;
            var n = T.split(" ");
            if (n.length !== 2) return null;
            var o = d.parseLength(n[0]), l = d.parseLength(n[1]);
            return l && o ? { h: l, w: o } : null;
          }, function(T, n, o, l, h) {
            var p, z;
            if (l === "auto") p = new d.ComputedLength(0, 0);
            else if ((p = d.toComputedLength(l.h.value, l.h.unit, null, T.dimensions.h, null, T.pxLength.h)) === null) return null;
            if (l === "auto") z = new d.ComputedLength(0, 0);
            else if ((z = d.toComputedLength(l.w.value, l.w.unit, null, T.dimensions.w, null, T.pxLength.w)) === null) return null;
            return { h: p, w: z };
          }), new m(c.ns_tts, "overflow", "hidden", ["region"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "padding", "0px", ["region"], !1, !0, function(T) {
            var n = T.split(" ");
            if (n.length > 4) return null;
            for (var o = [], l = 0; l < n.length; l++) {
              var h = d.parseLength(n[l]);
              if (!h) return null;
              o.push(h);
            }
            return o;
          }, function(T, n, o, l, h) {
            var p;
            if (l.length === 1) p = [l[0], l[0], l[0], l[0]];
            else if (l.length === 2) p = [l[0], l[1], l[0], l[1]];
            else if (l.length === 3) p = [l[0], l[1], l[2], l[1]];
            else {
              if (l.length !== 4) return null;
              p = [l[0], l[1], l[2], l[3]];
            }
            var z = o.styleAttrs[B.byName.writingMode.qname];
            if (z === "lrtb" || z === "lr") p = [p[0], p[3], p[2], p[1]];
            else if (z === "rltb" || z === "rl") p = [p[0], p[1], p[2], p[3]];
            else if (z === "tblr") p = [p[3], p[0], p[1], p[2]];
            else {
              if (z !== "tbrl" && z !== "tb") return null;
              p = [p[3], p[2], p[1], p[0]];
            }
            for (var Z = [], V = 0; V < p.length; V++) if (p[V].value === 0) Z[V] = new d.ComputedLength(0, 0);
            else if (Z[V] = d.toComputedLength(p[V].value, p[V].unit, o.styleAttrs[B.byName.fontSize.qname], V === 0 || V === 2 ? o.styleAttrs[B.byName.extent.qname].h : o.styleAttrs[B.byName.extent.qname].w, V === 0 || V === 2 ? T.cellLength.h : T.cellLength.w, V === 0 || V === 2 ? T.pxLength.h : T.pxLength.w), Z[V] === null) return null;
            return Z;
          }), new m(c.ns_tts, "position", "top left", ["region"], !1, !0, function(T) {
            return d.parsePosition(T);
          }, function(T, n, o, l) {
            var h, p;
            return (h = d.toComputedLength(l.v.offset.value, l.v.offset.unit, null, new d.ComputedLength(-o.styleAttrs[B.byName.extent.qname].h.rw, T.dimensions.h.rh - o.styleAttrs[B.byName.extent.qname].h.rh), null, T.pxLength.h)) === null ? null : (l.v.edge === "bottom" && (h = new d.ComputedLength(-h.rw - o.styleAttrs[B.byName.extent.qname].h.rw, T.dimensions.h.rh - h.rh - o.styleAttrs[B.byName.extent.qname].h.rh)), p = d.toComputedLength(l.h.offset.value, l.h.offset.unit, null, new d.ComputedLength(T.dimensions.w.rw - o.styleAttrs[B.byName.extent.qname].w.rw, -o.styleAttrs[B.byName.extent.qname].w.rh), null, T.pxLength.w), h === null ? null : (l.h.edge === "right" && (p = new d.ComputedLength(T.dimensions.w.rw - p.rw - o.styleAttrs[B.byName.extent.qname].w.rw, -p.rh - o.styleAttrs[B.byName.extent.qname].w.rh)), { h, w: p }));
          }), new m(c.ns_tts, "ruby", "none", ["span"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "rubyAlign", "center", ["span"], !0, !0, function(T) {
            return T !== "center" && T !== "spaceAround" ? null : T;
          }, null), new m(c.ns_tts, "rubyPosition", "outside", ["span"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "rubyReserve", "none", ["p"], !0, !0, function(T) {
            var n = T.split(" "), o = [null, null];
            if (n.length === 0 || n.length > 2 || n[0] !== "none" && n[0] !== "both" && n[0] !== "after" && n[0] !== "before" && n[0] !== "outside") return null;
            if (o[0] = n[0], n.length === 2 && n[0] !== "none") {
              var l = d.parseLength(n[1]);
              if (!l) return null;
              o[1] = l;
            }
            return o;
          }, function(T, n, o, l, h) {
            if (l[0] === "none") return l;
            var p;
            return (p = l[1] === null ? new d.ComputedLength(0.5 * o.styleAttrs[B.byName.fontSize.qname].rw, 0.5 * o.styleAttrs[B.byName.fontSize.qname].rh) : d.toComputedLength(l[1].value, l[1].unit, o.styleAttrs[B.byName.fontSize.qname], o.styleAttrs[B.byName.fontSize.qname], T.cellLength.h, T.pxLength.h)) === null ? null : [l[0], p];
          }), new m(c.ns_tts, "showBackground", "always", ["region"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "textAlign", "start", ["p"], !0, !0, function(T) {
            return T;
          }, function(T, n, o, l, h) {
            return l === "left" ? "start" : l === "right" ? "end" : l;
          }), new m(c.ns_tts, "textCombine", "none", ["span"], !0, !0, function(T) {
            return T === "none" || T === "all" ? T : null;
          }, null), new m(c.ns_tts, "textDecoration", "none", ["span"], !0, !0, function(T) {
            return T.split(" ");
          }, null), new m(c.ns_tts, "textEmphasis", "none", ["span"], !0, !0, function(T) {
            for (var n = T.split(" "), o = { style: null, symbol: null, color: null, position: null }, l = 0; l < n.length; l++) if (n[l] === "none" || n[l] === "auto") o.style = n[l];
            else if (n[l] === "filled" || n[l] === "open") o.style = n[l];
            else if (n[l] === "circle" || n[l] === "dot" || n[l] === "sesame") o.symbol = n[l];
            else if (n[l] === "current") o.color = n[l];
            else if (n[l] === "outside" || n[l] === "before" || n[l] === "after") o.position = n[l];
            else if (o.color = d.parseColor(n[l]), o.color === null) return null;
            return o.style == null && o.symbol == null ? o.style = "auto" : (o.symbol = o.symbol || "circle", o.style = o.style || "filled"), o.position = o.position || "outside", o.color = o.color || "current", o;
          }, null), new m(c.ns_tts, "textOutline", "none", ["span"], !0, !0, function(T) {
            if (T === "none") return T;
            var n = {}, o = T.split(" ");
            if (o.length === 0 || o.length > 2) return null;
            var l = d.parseColor(o[0]);
            if (n.color = l, l !== null && o.shift(), o.length !== 1) return null;
            var h = d.parseLength(o[0]);
            return h ? (n.thickness = h, n) : null;
          }, function(T, n, o, l, h) {
            if (l === "none") return l;
            var p = {};
            return l.color === null ? p.color = o.styleAttrs[B.byName.color.qname] : p.color = l.color, p.thickness = d.toComputedLength(l.thickness.value, l.thickness.unit, o.styleAttrs[B.byName.fontSize.qname], o.styleAttrs[B.byName.fontSize.qname], T.cellLength.h, T.pxLength.h), p.thickness === null ? null : p;
          }), new m(c.ns_tts, "textShadow", "none", ["span"], !0, !0, d.parseTextShadow, function(T, n, o, l) {
            if (l === "none") return l;
            for (var h = [], p = 0; p < l.length; p++) {
              var z = {};
              if (z.x_off = d.toComputedLength(l[p][0].value, l[p][0].unit, null, o.styleAttrs[B.byName.fontSize.qname], null, T.pxLength.w), z.x_off === null || (z.y_off = d.toComputedLength(l[p][1].value, l[p][1].unit, null, o.styleAttrs[B.byName.fontSize.qname], null, T.pxLength.h), z.y_off === null)) return null;
              if (l[p][2] === null) z.b_radius = 0;
              else if (z.b_radius = d.toComputedLength(l[p][2].value, l[p][2].unit, null, o.styleAttrs[B.byName.fontSize.qname], null, T.pxLength.h), z.b_radius === null) return null;
              l[p][3] === null ? z.color = o.styleAttrs[B.byName.color.qname] : z.color = l[p][3], h.push(z);
            }
            return h;
          }), new m(c.ns_tts, "unicodeBidi", "normal", ["span", "p"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "visibility", "visible", ["body", "div", "p", "region", "span"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "wrapOption", "wrap", ["span"], !0, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "writingMode", "lrtb", ["region"], !1, !0, function(T) {
            return T;
          }, null), new m(c.ns_tts, "zIndex", "auto", ["region"], !1, !0, function(T) {
            var n;
            return T === "auto" ? n = T : (n = parseInt(T), isNaN(n) && (n = null)), n;
          }, null), new m(c.ns_ebutts, "linePadding", "0c", ["p"], !0, !1, d.parseLength, function(T, n, o, l, h) {
            return d.toComputedLength(l.value, l.unit, null, null, T.cellLength.w, null);
          }), new m(c.ns_ebutts, "multiRowAlign", "auto", ["p"], !0, !1, function(T) {
            return T;
          }, null), new m(c.ns_smpte, "backgroundImage", null, ["div"], !1, !1, function(T) {
            return T;
          }, null), new m(c.ns_itts, "forcedDisplay", "false", ["body", "div", "p", "region", "span"], !0, !0, function(T) {
            return T === "true";
          }, null), new m(c.ns_itts, "fillLineGap", "false", ["p"], !0, !0, function(T) {
            return T === "true";
          }, null)], B.byQName = {}, B.all) B.byQName[B.all[b].qname] = B.all[b];
          for (var y in B.byName = {}, B.all) B.byName[B.all[y].name] = B.all[y];
        })(g, typeof imscNames == "undefined" ? w(977) : imscNames, typeof imscUtils == "undefined" ? w(6404) : imscUtils);
      }, 6404: function(k, g) {
        (function(w) {
          var B = /#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?/, c = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/, d = /rgba\(\s*(\d+),\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/, m = { transparent: [0, 0, 0, 0], black: [0, 0, 0, 255], silver: [192, 192, 192, 255], gray: [128, 128, 128, 255], white: [255, 255, 255, 255], maroon: [128, 0, 0, 255], red: [255, 0, 0, 255], purple: [128, 0, 128, 255], fuchsia: [255, 0, 255, 255], magenta: [255, 0, 255, 255], green: [0, 128, 0, 255], lime: [0, 255, 0, 255], olive: [128, 128, 0, 255], yellow: [255, 255, 0, 255], navy: [0, 0, 128, 255], blue: [0, 0, 255, 255], teal: [0, 128, 128, 255], aqua: [0, 255, 255, 255], cyan: [0, 255, 255, 255] };
          w.parseColor = function(y) {
            var T, n = null, o = m[y.toLowerCase()];
            return o !== void 0 ? n = o : (T = B.exec(y)) !== null ? n = [parseInt(T[1], 16), parseInt(T[2], 16), parseInt(T[3], 16), T[4] !== void 0 ? parseInt(T[4], 16) : 255] : (T = c.exec(y)) !== null ? n = [parseInt(T[1]), parseInt(T[2]), parseInt(T[3]), 255] : (T = d.exec(y)) !== null && (n = [parseInt(T[1]), parseInt(T[2]), parseInt(T[3]), parseInt(T[4])]), n;
          };
          var b = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
          w.parseLength = function(y) {
            var T, n = null;
            return (T = b.exec(y)) !== null && (n = { value: parseFloat(T[1]), unit: T[2] }), n;
          }, w.parseTextShadow = function(y) {
            for (var T = y.match(/([^\(,\)]|\([^\)]+\))+/g), n = [], o = 0; o < T.length; o++) {
              var l = T[o].split(" ");
              if (l.length === 1 && l[0] === "none") return "none";
              if (l.length > 1 && l.length < 5) {
                var h = [null, null, null, null], p = w.parseLength(l.shift());
                if (p === null || (h[0] = p, (p = w.parseLength(l.shift())) === null)) return null;
                if (h[1] = p, l.length === 0) {
                  n.push(h);
                  continue;
                }
                if ((p = w.parseLength(l[0])) !== null && (h[2] = p, l.shift()), l.length === 0) {
                  n.push(h);
                  continue;
                }
                var z = w.parseColor(l[0]);
                if (z === null) return null;
                h[3] = z, n.push(h);
              }
            }
            return n;
          }, w.parsePosition = function(y) {
            var T = y.split(" "), n = function(V) {
              return V === "center" || V === "left" || V === "top" || V === "bottom" || V === "right";
            };
            if (T.length > 4) return null;
            for (var o = 0; o < T.length; o++) if (!n(T[o])) {
              var l = w.parseLength(T[o]);
              if (l === null) return null;
              T[o] = l;
            }
            for (var h = { h: { edge: "left", offset: { value: 50, unit: "%" } }, v: { edge: "top", offset: { value: 50, unit: "%" } } }, p = 0; p < T.length; ) {
              var z = T[p++];
              if (n(z)) {
                var Z = { value: 0, unit: "%" };
                T.length !== 2 && p < T.length && !n(T[p]) && (Z = T[p++]), z === "right" ? (h.h.edge = z, h.h.offset = Z) : z === "bottom" ? (h.v.edge = z, h.v.offset = Z) : z === "left" ? h.h.offset = Z : z === "top" && (h.v.offset = Z);
              } else {
                if (T.length !== 1 && T.length !== 2) return null;
                p === 1 ? h.h.offset = z : h.v.offset = z;
              }
            }
            return h;
          }, w.ComputedLength = function(y, T) {
            this.rw = y, this.rh = T;
          }, w.ComputedLength.prototype.toUsedLength = function(y, T) {
            return y * this.rw + T * this.rh;
          }, w.ComputedLength.prototype.isZero = function() {
            return this.rw === 0 && this.rh === 0;
          }, w.toComputedLength = function(y, T, n, o, l, h) {
            return T === "%" && o ? new w.ComputedLength(o.rw * y / 100, o.rh * y / 100) : T === "em" && n ? new w.ComputedLength(n.rw * y, n.rh * y) : T === "c" && l ? new w.ComputedLength(y * l.rw, y * l.rh) : T === "px" && h ? new w.ComputedLength(y * h.rw, y * h.rh) : T === "rh" ? new w.ComputedLength(0, y / 100) : T === "rw" ? new w.ComputedLength(y / 100, 0) : null;
          };
        })(g);
      }, 7523: function(k) {
        typeof Object.create == "function" ? k.exports = function(g, w) {
          w && (g.super_ = w, g.prototype = Object.create(w.prototype, { constructor: { value: g, enumerable: !1, writable: !0, configurable: !0 } }));
        } : k.exports = function(g, w) {
          if (w) {
            g.super_ = w;
            var B = function() {
            };
            B.prototype = w.prototype, g.prototype = new B(), g.prototype.constructor = g;
          }
        };
      }, 9066: function(k, g, w) {
        (function(B) {
          B.defineLocale("af", { months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"), weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"), weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"), weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"), meridiemParse: /vm|nm/i, isPM: function(c) {
            return /^nm$/i.test(c);
          }, meridiem: function(c, d, m) {
            return c < 12 ? m ? "vm" : "VM" : m ? "nm" : "NM";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Vandag om] LT", nextDay: "[Mre om] LT", nextWeek: "dddd [om] LT", lastDay: "[Gister om] LT", lastWeek: "[Laas] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oor %s", past: "%s gelede", s: "'n paar sekondes", ss: "%d sekondes", m: "'n minuut", mm: "%d minute", h: "'n uur", hh: "%d ure", d: "'n dag", dd: "%d dae", M: "'n maand", MM: "%d maande", y: "'n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(c) {
            return c + (c === 1 || c === 8 || c >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4261: function(k, g, w) {
        (function(B) {
          var c = function(y) {
            return y === 0 ? 0 : y === 1 ? 1 : y === 2 ? 2 : y % 100 >= 3 && y % 100 <= 10 ? 3 : y % 100 >= 11 ? 4 : 5;
          }, d = { s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "] }, m = function(y) {
            return function(T, n, o, l) {
              var h = c(T), p = d[y][c(T)];
              return h === 2 && (p = p[n ? 0 : 1]), p.replace(/%d/i, T);
            };
          }, b = ["", "", "", "", "", "", "", "", "", "", "", ""];
          B.defineLocale("ar-dz", { months: b, monthsShort: b, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(y) {
            return y === "";
          }, meridiem: function(y, T, n) {
            return y < 12 ? "" : "";
          }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: m("s"), ss: m("s"), m: m("m"), mm: m("m"), h: m("h"), hh: m("h"), d: m("d"), dd: m("d"), M: m("M"), MM: m("M"), y: m("y"), yy: m("y") }, postformat: function(y) {
            return y.replace(/,/g, "");
          }, week: { dow: 0, doy: 4 } });
        })(w(7840));
      }, 7717: function(k, g, w) {
        (function(B) {
          B.defineLocale("ar-kw", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, week: { dow: 0, doy: 12 } });
        })(w(7840));
      }, 7060: function(k, g, w) {
        (function(B) {
          var c = { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0" }, d = function(T) {
            return T === 0 ? 0 : T === 1 ? 1 : T === 2 ? 2 : T % 100 >= 3 && T % 100 <= 10 ? 3 : T % 100 >= 11 ? 4 : 5;
          }, m = { s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "] }, b = function(T) {
            return function(n, o, l, h) {
              var p = d(n), z = m[T][d(n)];
              return p === 2 && (z = z[o ? 0 : 1]), z.replace(/%d/i, n);
            };
          }, y = ["", "", "", "", "", "", "", "", "", "", "", ""];
          B.defineLocale("ar-ly", { months: y, monthsShort: y, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(T) {
            return T === "";
          }, meridiem: function(T, n, o) {
            return T < 12 ? "" : "";
          }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: b("s"), ss: b("s"), m: b("m"), mm: b("m"), h: b("h"), hh: b("h"), d: b("d"), dd: b("d"), M: b("M"), MM: b("M"), y: b("y"), yy: b("y") }, preparse: function(T) {
            return T.replace(//g, ",");
          }, postformat: function(T) {
            return T.replace(/\d/g, function(n) {
              return c[n];
            }).replace(/,/g, "");
          }, week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 2757: function(k, g, w) {
        (function(B) {
          B.defineLocale("ar-ma", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8490: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("ar-ps", { months: " _________ _ _ ".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            }).split("").reverse().join("").replace(/[](?![\u062a\u0643])/g, function(b) {
              return d[b];
            }).split("").reverse().join("").replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            }).replace(/,/g, "");
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 735: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("ar-sa", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            }).replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            }).replace(/,/g, "");
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 5385: function(k, g, w) {
        (function(B) {
          B.defineLocale("ar-tn", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1110: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" }, m = function(n) {
            return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
          }, b = { s: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], m: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], h: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], d: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], M: ["  ", " ", ["", ""], "%d ", "%d ", "%d "], y: ["  ", " ", ["", ""], "%d ", "%d ", "%d "] }, y = function(n) {
            return function(o, l, h, p) {
              var z = m(o), Z = b[n][m(o)];
              return z === 2 && (Z = Z[l ? 0 : 1]), Z.replace(/%d/i, o);
            };
          }, T = ["", "", "", "", "", "", "", "", "", "", "", ""];
          B.defineLocale("ar", { months: T, monthsShort: T, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(n) {
            return n === "";
          }, meridiem: function(n, o, l) {
            return n < 12 ? "" : "";
          }, calendar: { sameDay: "[  ] LT", nextDay: "[  ] LT", nextWeek: "dddd [ ] LT", lastDay: "[  ] LT", lastWeek: "dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: y("s"), ss: y("s"), m: y("m"), mm: y("m"), h: y("h"), hh: y("h"), d: y("d"), dd: y("d"), M: y("M"), MM: y("M"), y: y("y"), yy: y("y") }, preparse: function(n) {
            return n.replace(/[]/g, function(o) {
              return d[o];
            }).replace(//g, ",");
          }, postformat: function(n) {
            return n.replace(/\d/g, function(o) {
              return c[o];
            }).replace(/,/g, "");
          }, week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 6190: function(k, g, w) {
        (function(B) {
          var c = { 1: "-inci", 5: "-inci", 8: "-inci", 70: "-inci", 80: "-inci", 2: "-nci", 7: "-nci", 20: "-nci", 50: "-nci", 3: "-nc", 4: "-nc", 100: "-nc", 6: "-nc", 9: "-uncu", 10: "-uncu", 30: "-uncu", 60: "-nc", 90: "-nc" };
          B.defineLocale("az", { months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"), monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"), weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split("_"), weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"), weekdaysMin: "Bz_BE_A__CA_C_".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugn saat] LT", nextDay: "[sabah saat] LT", nextWeek: "[gln hft] dddd [saat] LT", lastDay: "[dnn] LT", lastWeek: "[ken hft] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s vvl", s: "bir ne saniy", ss: "%d saniy", m: "bir dqiq", mm: "%d dqiq", h: "bir saat", hh: "%d saat", d: "bir gn", dd: "%d gn", M: "bir ay", MM: "%d ay", y: "bir il", yy: "%d il" }, meridiemParse: /gec|shr|gndz|axam/, isPM: function(d) {
            return /^(gndz|axam)$/.test(d);
          }, meridiem: function(d, m, b) {
            return d < 4 ? "gec" : d < 12 ? "shr" : d < 17 ? "gndz" : "axam";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/, ordinal: function(d) {
            if (d === 0) return d + "-nc";
            var m = d % 10;
            return d + (c[m] || c[d % 100 - m] || c[d >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 1448: function(k, g, w) {
        (function(B) {
          function c(d, m, b) {
            return b === "m" ? m ? "" : "" : b === "h" ? m ? "" : "" : d + " " + (y = +d, T = { ss: m ? "__" : "__", mm: m ? "__" : "__", hh: m ? "__" : "__", dd: "__", MM: "__", yy: "__" }[b].split("_"), y % 10 == 1 && y % 100 != 11 ? T[0] : y % 10 >= 2 && y % 10 <= 4 && (y % 100 < 10 || y % 100 >= 20) ? T[1] : T[2]);
            var y, T;
          }
          B.defineLocale("be", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: "___________".split("_"), weekdays: { format: "______".split("_"), standalone: "______".split("_"), isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/ }, weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., HH:mm", LLLL: "dddd, D MMMM YYYY ., HH:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", lastDay: "[ ] LT", nextWeek: function() {
            return "[] dddd [] LT";
          }, lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return "[ ] dddd [] LT";
              case 1:
              case 2:
              case 4:
                return "[ ] dddd [] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: " %s", past: "%s ", s: " ", m: c, mm: c, h: c, hh: c, d: "", dd: c, M: "", MM: c, y: "", yy: c }, meridiemParse: /|||/, isPM: function(d) {
            return /^(|)$/.test(d);
          }, meridiem: function(d, m, b) {
            return d < 4 ? "" : d < 12 ? "" : d < 17 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(||)/, ordinal: function(d, m) {
            switch (m) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return d % 10 != 2 && d % 10 != 3 || d % 100 == 12 || d % 100 == 13 ? d + "-" : d + "-";
              case "D":
                return d + "-";
              default:
                return d;
            }
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 7890: function(k, g, w) {
        (function(B) {
          B.defineLocale("bg", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[] dddd [] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[] dddd [] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: " ", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", w: "", ww: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/, ordinal: function(c) {
            var d = c % 10, m = c % 100;
            return c === 0 ? c + "-" : m === 0 ? c + "-" : m > 10 && m < 20 ? c + "-" : d === 1 ? c + "-" : d === 2 ? c + "-" : d === 7 || d === 8 ? c + "-" : c + "-";
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 6832: function(k, g, w) {
        (function(B) {
          B.defineLocale("bm", { months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo".split("_"), monthsShort: "Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des".split("_"), weekdays: "Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"), weekdaysShort: "Kar_Nt_Tar_Ara_Ala_Jum_Sib".split("_"), weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "MMMM [tile] D [san] YYYY", LLL: "MMMM [tile] D [san] YYYY [lr] HH:mm", LLLL: "dddd MMMM [tile] D [san] YYYY [lr] HH:mm" }, calendar: { sameDay: "[Bi lr] LT", nextDay: "[Sini lr] LT", nextWeek: "dddd [don lr] LT", lastDay: "[Kunu lr] LT", lastWeek: "dddd [tmnen lr] LT", sameElse: "L" }, relativeTime: { future: "%s kn", past: "a b %s b", s: "sanga dama dama", ss: "sekondi %d", m: "miniti kelen", mm: "miniti %d", h: "lr kelen", hh: "lr %d", d: "tile kelen", dd: "tile %d", M: "kalo kelen", MM: "kalo %d", y: "san kelen", yy: "san %d" }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 196: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("bn-bd", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /||||||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 4 ? m : m + 12 : b === "" || b === "" ? m : b === "" ? m >= 3 ? m : m + 12 : b === "" || b === "" ? m + 12 : void 0;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 6 ? "" : m < 12 ? "" : m < 15 ? "" : m < 18 ? "" : m < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 7193: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("bn", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /||||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" && m >= 4 || b === "" && m < 5 || b === "" ? m + 12 : m;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 10 ? "" : m < 17 ? "" : m < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 6682: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("bo", { months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), monthsShortRegex: /^(\d{1,2})/, monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[], LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /||||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" && m >= 4 || b === "" && m < 5 || b === "" ? m + 12 : m;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 10 ? "" : m < 17 ? "" : m < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 1133: function(k, g, w) {
        (function(B) {
          function c(T, n, o) {
            return T + " " + function(l, h) {
              return h === 2 ? function(p) {
                var z = { m: "v", b: "v", d: "z" };
                return z[p.charAt(0)] === void 0 ? p : z[p.charAt(0)] + p.substring(1);
              }(l) : l;
            }({ mm: "munutenn", MM: "miz", dd: "devezh" }[o], T);
          }
          function d(T) {
            return T > 9 ? d(T % 10) : T;
          }
          var m = [/^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i], b = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, y = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
          B.defineLocale("br", { months: "Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"), monthsShort: "Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"), weekdays: "Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn".split("_"), weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"), weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"), weekdaysParse: y, fullWeekdaysParse: [/^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i], shortWeekdaysParse: [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i], minWeekdaysParse: y, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex: /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY HH:mm", LLLL: "dddd, D [a viz] MMMM YYYY HH:mm" }, calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warchoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Dech da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" }, relativeTime: { future: "a-benn %s", past: "%s zo", s: "un nebeud segondenno", ss: "%d eilenn", m: "ur vunutenn", mm: c, h: "un eur", hh: "%d eur", d: "un devezh", dd: c, M: "ur miz", MM: c, y: "ur bloaz", yy: function(T) {
            switch (d(T)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return T + " bloaz";
              default:
                return T + " vloaz";
            }
          } }, dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/, ordinal: function(T) {
            return T + (T === 1 ? "a" : "vet");
          }, week: { dow: 1, doy: 4 }, meridiemParse: /a.m.|g.m./, isPM: function(T) {
            return T === "g.m.";
          }, meridiem: function(T, n, o) {
            return T < 12 ? "a.m." : "g.m.";
          } });
        })(w(7840));
      }, 1214: function(k, g, w) {
        (function(B) {
          function c(d, m, b) {
            var y = d + " ";
            switch (b) {
              case "ss":
                return y + (d === 1 ? "sekunda" : d === 2 || d === 3 || d === 4 ? "sekunde" : "sekundi");
              case "mm":
                return y + (d === 1 ? "minuta" : d === 2 || d === 3 || d === 4 ? "minute" : "minuta");
              case "h":
                return "jedan sat";
              case "hh":
                return y + (d === 1 ? "sat" : d === 2 || d === 3 || d === 4 ? "sata" : "sati");
              case "dd":
                return y + (d === 1 ? "dan" : "dana");
              case "MM":
                return y + (d === 1 ? "mjesec" : d === 2 || d === 3 || d === 4 ? "mjeseca" : "mjeseci");
              case "yy":
                return y + (d === 1 ? "godina" : d === 2 || d === 3 || d === 4 ? "godine" : "godina");
            }
          }
          B.defineLocale("bs", { months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
                return "[prolu] dddd [u] LT";
              case 6:
                return "[prole] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[proli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: c, m: function(d, m, b, y) {
            if (b === "m") return m ? "jedna minuta" : y ? "jednu minutu" : "jedne minute";
          }, mm: c, h: c, hh: c, d: "dan", dd: c, M: "mjesec", MM: c, y: "godinu", yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 7357: function(k, g, w) {
        (function(B) {
          B.defineLocale("ca", { months: { standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"), format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"), monthsParseExact: !0, weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a les] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a les] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: function() {
            return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, nextDay: function() {
            return "[dem a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, nextWeek: function() {
            return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, lastDay: function() {
            return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "d'aqu %s", past: "fa %s", s: "uns segons", ss: "%d segons", m: "un minut", mm: "%d minuts", h: "una hora", hh: "%d hores", d: "un dia", dd: "%d dies", M: "un mes", MM: "%d mesos", y: "un any", yy: "%d anys" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/, ordinal: function(c, d) {
            var m = c === 1 ? "r" : c === 2 ? "n" : c === 3 ? "r" : c === 4 ? "t" : "";
            return d !== "w" && d !== "W" || (m = "a"), c + m;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1659: function(k, g, w) {
        (function(B) {
          var c = { standalone: "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split("_"), format: "ledna_nora_bezna_dubna_kvtna_ervna_ervence_srpna_z_jna_listopadu_prosince".split("_"), isFormat: /DD?[o.]?(\[[^\[\]]*\]|\s)+MMMM/ }, d = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_"), m = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i], b = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
          function y(n) {
            return n > 1 && n < 5 && ~~(n / 10) != 1;
          }
          function T(n, o, l, h) {
            var p = n + " ";
            switch (l) {
              case "s":
                return o || h ? "pr sekund" : "pr sekundami";
              case "ss":
                return o || h ? p + (y(n) ? "sekundy" : "sekund") : p + "sekundami";
              case "m":
                return o ? "minuta" : h ? "minutu" : "minutou";
              case "mm":
                return o || h ? p + (y(n) ? "minuty" : "minut") : p + "minutami";
              case "h":
                return o ? "hodina" : h ? "hodinu" : "hodinou";
              case "hh":
                return o || h ? p + (y(n) ? "hodiny" : "hodin") : p + "hodinami";
              case "d":
                return o || h ? "den" : "dnem";
              case "dd":
                return o || h ? p + (y(n) ? "dny" : "dn") : p + "dny";
              case "M":
                return o || h ? "msc" : "mscem";
              case "MM":
                return o || h ? p + (y(n) ? "msce" : "msc") : p + "msci";
              case "y":
                return o || h ? "rok" : "rokem";
              case "yy":
                return o || h ? p + (y(n) ? "roky" : "let") : p + "lety";
            }
          }
          B.defineLocale("cs", { months: c, monthsShort: d, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i, monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"), weekdaysShort: "ne_po_t_st_t_p_so".split("_"), weekdaysMin: "ne_po_t_st_t_p_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm", l: "D. M. YYYY" }, calendar: { sameDay: "[dnes v] LT", nextDay: "[ztra v] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedli v] LT";
              case 1:
              case 2:
                return "[v] dddd [v] LT";
              case 3:
                return "[ve stedu v] LT";
              case 4:
                return "[ve tvrtek v] LT";
              case 5:
                return "[v ptek v] LT";
              case 6:
                return "[v sobotu v] LT";
            }
          }, lastDay: "[vera v] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulou nedli v] LT";
              case 1:
              case 2:
                return "[minul] dddd [v] LT";
              case 3:
                return "[minulou stedu v] LT";
              case 4:
              case 5:
                return "[minul] dddd [v] LT";
              case 6:
                return "[minulou sobotu v] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "ped %s", s: T, ss: T, m: T, mm: T, h: T, hh: T, d: T, dd: T, M: T, MM: T, y: T, yy: T }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 3944: function(k, g, w) {
        (function(B) {
          B.defineLocale("cv", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "YYYY [] MMMM [] D[-]", LLL: "YYYY [] MMMM [] D[-], HH:mm", LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm" }, calendar: { sameDay: "[] LT []", nextDay: "[] LT []", lastDay: "[] LT []", nextWeek: "[] dddd LT []", lastWeek: "[] dddd LT []", sameElse: "L" }, relativeTime: { future: function(c) {
            return c + (/$/i.exec(c) ? "" : /$/i.exec(c) ? "" : "");
          }, past: "%s ", s: "- ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}-/, ordinal: "%d-", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 9381: function(k, g, w) {
        (function(B) {
          B.defineLocale("cy", { months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"), monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"), weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"), weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"), weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" }, relativeTime: { future: "mewn %s", past: "%s yn l", s: "ychydig eiliadau", ss: "%d eiliad", m: "munud", mm: "%d munud", h: "awr", hh: "%d awr", d: "diwrnod", dd: "%d diwrnod", M: "mis", MM: "%d mis", y: "blwyddyn", yy: "%d flynedd" }, dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/, ordinal: function(c) {
            var d = "";
            return c > 20 ? d = c === 40 || c === 50 || c === 60 || c === 80 || c === 100 ? "fed" : "ain" : c > 0 && (d = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"][c]), c + d;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8782: function(k, g, w) {
        (function(B) {
          B.defineLocale("da", { months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"), weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"), weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "p dddd [kl.] LT", lastDay: "[i gr kl.] LT", lastWeek: "[i] dddd[s kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "f sekunder", ss: "%d sekunder", m: "et minut", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dage", M: "en mned", MM: "%d mneder", y: "et r", yy: "%d r" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2170: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [d + " Tage", d + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [d + " Monate", d + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [d + " Jahre", d + " Jahren"] };
            return m ? T[b][0] : T[b][1];
          }
          B.defineLocale("de-at", { months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: c, mm: "%d Minuten", h: c, hh: "%d Stunden", d: c, dd: c, w: c, ww: "%d Wochen", M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1020: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [d + " Tage", d + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [d + " Monate", d + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [d + " Jahre", d + " Jahren"] };
            return m ? T[b][0] : T[b][1];
          }
          B.defineLocale("de-ch", { months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: c, mm: "%d Minuten", h: c, hh: "%d Stunden", d: c, dd: c, w: c, ww: "%d Wochen", M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4722: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [d + " Tage", d + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [d + " Monate", d + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [d + " Jahre", d + " Jahren"] };
            return m ? T[b][0] : T[b][1];
          }
          B.defineLocale("de", { months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: c, mm: "%d Minuten", h: c, hh: "%d Stunden", d: c, dd: c, w: c, ww: "%d Wochen", M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 9295: function(k, g, w) {
        (function(B) {
          var c = ["", "", "", "", "", "", "", "", "", "", "", ""], d = ["", "", "", "", "", "", ""];
          B.defineLocale("dv", { months: c, monthsShort: c, weekdays: d, weekdaysShort: d, weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd LT", lastDay: "[] LT", lastWeek: "[] dddd LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: "", ss: "d% ", m: "", mm: " %d", h: "", hh: " %d", d: "", dd: " %d", M: "", MM: " %d", y: "", yy: " %d" }, preparse: function(m) {
            return m.replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/,/g, "");
          }, week: { dow: 7, doy: 12 } });
        })(w(7840));
      }, 3372: function(k, g, w) {
        (function(B) {
          B.defineLocale("el", { monthsNominativeEl: "___________".split("_"), monthsGenitiveEl: "___________".split("_"), months: function(c, d) {
            return c ? typeof d == "string" && /D/.test(d.substring(0, d.indexOf("MMMM"))) ? this._monthsGenitiveEl[c.month()] : this._monthsNominativeEl[c.month()] : this._monthsNominativeEl;
          }, monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), meridiem: function(c, d, m) {
            return c > 11 ? m ? "" : "" : m ? "" : "";
          }, isPM: function(c) {
            return (c + "").toLowerCase()[0] === "";
          }, meridiemParse: /[]\.??\.?/i, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendarEl: { sameDay: "[ {}] LT", nextDay: "[ {}] LT", nextWeek: "dddd [{}] LT", lastDay: "[ {}] LT", lastWeek: function() {
            return this.day() === 6 ? "[ ] dddd [{}] LT" : "[ ] dddd [{}] LT";
          }, sameElse: "L" }, calendar: function(c, d) {
            var m, b = this._calendarEl[c], y = d && d.hours();
            return m = b, (typeof Function != "undefined" && m instanceof Function || Object.prototype.toString.call(m) === "[object Function]") && (b = b.apply(d)), b.replace("{}", y % 12 == 1 ? "" : "");
          }, relativeTime: { future: " %s", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 3797: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-au", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 0, doy: 4 } });
        })(w(7840));
      }, 8479: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-ca", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "YYYY-MM-DD", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          } });
        })(w(7840));
      }, 4086: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-gb", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 3309: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-ie", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 150: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-il", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          } });
        })(w(7840));
      }, 2332: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-in", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 2239: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-nz", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5501: function(k, g, w) {
        (function(B) {
          B.defineLocale("en-sg", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 325: function(k, g, w) {
        (function(B) {
          B.defineLocale("eo", { months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split("_"), monthsShort: "jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec".split("_"), weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"), weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"), weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "[la] D[-an de] MMMM, YYYY", LLL: "[la] D[-an de] MMMM, YYYY HH:mm", LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm", llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm" }, meridiemParse: /[ap]\.t\.m/i, isPM: function(c) {
            return c.charAt(0).toLowerCase() === "p";
          }, meridiem: function(c, d, m) {
            return c > 11 ? m ? "p.t.m." : "P.T.M." : m ? "a.t.m." : "A.T.M.";
          }, calendar: { sameDay: "[Hodia je] LT", nextDay: "[Morga je] LT", nextWeek: "dddd[n je] LT", lastDay: "[Hiera je] LT", lastWeek: "[pasintan] dddd[n je] LT", sameElse: "L" }, relativeTime: { future: "post %s", past: "anta %s", s: "kelkaj sekundoj", ss: "%d sekundoj", m: "unu minuto", mm: "%d minutoj", h: "unu horo", hh: "%d horoj", d: "unu tago", dd: "%d tagoj", M: "unu monato", MM: "%d monatoj", y: "unu jaro", yy: "%d jaroj" }, dayOfMonthOrdinalParse: /\d{1,2}a/, ordinal: "%da", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 8143: function(k, g, w) {
        (function(B) {
          var c = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), d = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), m = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], b = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          B.defineLocale("es-do", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"), weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un da", dd: "%d das", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un ao", yy: "%d aos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1075: function(k, g, w) {
        (function(B) {
          var c = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), d = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), m = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], b = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          B.defineLocale("es-mx", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"), weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un da", dd: "%d das", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un ao", yy: "%d aos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 0, doy: 4 }, invalidDate: "Fecha invlida" });
        })(w(7840));
      }, 246: function(k, g, w) {
        (function(B) {
          var c = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), d = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), m = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], b = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          B.defineLocale("es-us", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"), weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "MM/DD/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un da", dd: "%d das", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un ao", yy: "%d aos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 4049: function(k, g, w) {
        (function(B) {
          var c = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), d = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), m = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], b = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          B.defineLocale("es", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"), weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un da", dd: "%d das", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un ao", yy: "%d aos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 }, invalidDate: "Fecha invlida" });
        })(w(7840));
      }, 180: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { s: ["mne sekundi", "mni sekund", "paar sekundit"], ss: [d + "sekundi", d + "sekundit"], m: ["he minuti", "ks minut"], mm: [d + " minuti", d + " minutit"], h: ["he tunni", "tund aega", "ks tund"], hh: [d + " tunni", d + " tundi"], d: ["he peva", "ks pev"], M: ["kuu aja", "kuu aega", "ks kuu"], MM: [d + " kuu", d + " kuud"], y: ["he aasta", "aasta", "ks aasta"], yy: [d + " aasta", d + " aastat"] };
            return m ? T[b][2] ? T[b][2] : T[b][1] : y ? T[b][0] : T[b][1];
          }
          B.defineLocale("et", { months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"), monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"), weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split("_"), weekdaysShort: "P_E_T_K_N_R_L".split("_"), weekdaysMin: "P_E_T_K_N_R_L".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[Tna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Jrgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" }, relativeTime: { future: "%s prast", past: "%s tagasi", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: "%d peva", M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 9707: function(k, g, w) {
        (function(B) {
          B.defineLocale("eu", { months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"), monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"), monthsParseExact: !0, weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"), weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"), weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY[ko] MMMM[ren] D[a]", LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm", LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm", l: "YYYY-M-D", ll: "YYYY[ko] MMM D[a]", lll: "YYYY[ko] MMM D[a] HH:mm", llll: "ddd, YYYY[ko] MMM D[a] HH:mm" }, calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" }, relativeTime: { future: "%s barru", past: "duela %s", s: "segundo batzuk", ss: "%d segundo", m: "minutu bat", mm: "%d minutu", h: "ordu bat", hh: "%d ordu", d: "egun bat", dd: "%d egun", M: "hilabete bat", MM: "%d hilabete", y: "urte bat", yy: "%d urte" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 4576: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("fa", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /  |  /, isPM: function(m) {
            return /  /.test(m);
          }, meridiem: function(m, b, y) {
            return m < 12 ? "  " : "  ";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "dddd [] [] LT", sameElse: "L" }, relativeTime: { future: " %s", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[-]/g, function(b) {
              return d[b];
            }).replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            }).replace(/,/g, "");
          }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 3016: function(k, g, w) {
        (function(B) {
          var c = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(" "), d = ["nolla", "yhden", "kahden", "kolmen", "neljn", "viiden", "kuuden", c[7], c[8], c[9]];
          function m(b, y, T, n) {
            var o = "";
            switch (T) {
              case "s":
                return n ? "muutaman sekunnin" : "muutama sekunti";
              case "ss":
                o = n ? "sekunnin" : "sekuntia";
                break;
              case "m":
                return n ? "minuutin" : "minuutti";
              case "mm":
                o = n ? "minuutin" : "minuuttia";
                break;
              case "h":
                return n ? "tunnin" : "tunti";
              case "hh":
                o = n ? "tunnin" : "tuntia";
                break;
              case "d":
                return n ? "pivn" : "piv";
              case "dd":
                o = n ? "pivn" : "piv";
                break;
              case "M":
                return n ? "kuukauden" : "kuukausi";
              case "MM":
                o = n ? "kuukauden" : "kuukautta";
                break;
              case "y":
                return n ? "vuoden" : "vuosi";
              case "yy":
                o = n ? "vuoden" : "vuotta";
            }
            return function(l, h) {
              return l < 10 ? h ? d[l] : c[l] : l;
            }(b, n) + " " + o;
          }
          B.defineLocale("fi", { months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"), monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split("_"), weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"), weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"), weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "Do MMMM[ta] YYYY", LLL: "Do MMMM[ta] YYYY, [klo] HH.mm", LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm", l: "D.M.YYYY", ll: "Do MMM YYYY", lll: "Do MMM YYYY, [klo] HH.mm", llll: "ddd, Do MMM YYYY, [klo] HH.mm" }, calendar: { sameDay: "[tnn] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" }, relativeTime: { future: "%s pst", past: "%s sitten", s: m, ss: m, m, mm: m, h: m, hh: m, d: m, dd: m, M: m, MM: m, y: m, yy: m }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2158: function(k, g, w) {
        (function(B) {
          B.defineLocale("fil", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(c) {
            return c;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5790: function(k, g, w) {
        (function(B) {
          B.defineLocale("fo", { months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split("_"), weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"), weekdaysMin: "su_m_t_mi_h_fr_le".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D. MMMM, YYYY HH:mm" }, calendar: { sameDay: "[ dag kl.] LT", nextDay: "[ morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[ gjr kl.] LT", lastWeek: "[sstu] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "um %s", past: "%s sani", s: "f sekund", ss: "%d sekundir", m: "ein minuttur", mm: "%d minuttir", h: "ein tmi", hh: "%d tmar", d: "ein dagur", dd: "%d dagar", M: "ein mnaur", MM: "%d mnair", y: "eitt r", yy: "%d r" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8030: function(k, g, w) {
        (function(B) {
          B.defineLocale("fr-ca", { months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"), monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourdhui ] LT", nextDay: "[Demain ] LT", nextWeek: "dddd [] LT", lastDay: "[Hier ] LT", lastWeek: "dddd [dernier ] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(c, d) {
            switch (d) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return c + (c === 1 ? "er" : "e");
              case "w":
              case "W":
                return c + (c === 1 ? "re" : "e");
            }
          } });
        })(w(7840));
      }, 3669: function(k, g, w) {
        (function(B) {
          B.defineLocale("fr-ch", { months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"), monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourdhui ] LT", nextDay: "[Demain ] LT", nextWeek: "dddd [] LT", lastDay: "[Hier ] LT", lastWeek: "dddd [dernier ] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(c, d) {
            switch (d) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return c + (c === 1 ? "er" : "e");
              case "w":
              case "W":
                return c + (c === 1 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5097: function(k, g, w) {
        (function(B) {
          var c = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, d = [/^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i];
          B.defineLocale("fr", { months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split("_"), monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split("_"), monthsRegex: c, monthsShortRegex: c, monthsStrictRegex: /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsShortStrictRegex: /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i, monthsParse: d, longMonthsParse: d, shortMonthsParse: d, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourdhui ] LT", nextDay: "[Demain ] LT", nextWeek: "dddd [] LT", lastDay: "[Hier ] LT", lastWeek: "dddd [dernier ] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", w: "une semaine", ww: "%d semaines", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|)/, ordinal: function(m, b) {
            switch (b) {
              case "D":
                return m + (m === 1 ? "er" : "");
              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
                return m + (m === 1 ? "er" : "e");
              case "w":
              case "W":
                return m + (m === 1 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8664: function(k, g, w) {
        (function(B) {
          var c = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), d = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
          B.defineLocale("fy", { months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"), monthsShort: function(m, b) {
            return m ? /-MMM-/.test(b) ? d[m.month()] : c[m.month()] : c;
          }, monthsParseExact: !0, weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"), weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"), weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[hjoed om] LT", nextDay: "[moarn om] LT", nextWeek: "dddd [om] LT", lastDay: "[juster om] LT", lastWeek: "[frne] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oer %s", past: "%s lyn", s: "in pear sekonden", ss: "%d sekonden", m: "ien mint", mm: "%d minuten", h: "ien oere", hh: "%d oeren", d: "ien dei", dd: "%d dagen", M: "ien moanne", MM: "%d moannen", y: "ien jier", yy: "%d jierren" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(m) {
            return m + (m === 1 || m === 8 || m >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 409: function(k, g, w) {
        (function(B) {
          B.defineLocale("ga", { months: ["Eanir", "Feabhra", "Mrta", "Aibren", "Bealtaine", "Meitheamh", "Iil", "Lnasa", "Men Fmhair", "Deireadh Fmhair", "Samhain", "Nollaig"], monthsShort: ["Ean", "Feabh", "Mrt", "Aib", "Beal", "Meith", "Iil", "Ln", "M.F.", "D.F.", "Samh", "Noll"], monthsParseExact: !0, weekdays: ["D Domhnaigh", "D Luain", "D Mirt", "D Cadaoin", "Dardaoin", "D hAoine", "D Sathairn"], weekdaysShort: ["Domh", "Luan", "Mirt", "Cad", "Dar", "Aoine", "Sath"], weekdaysMin: ["Do", "Lu", "M", "C", "D", "A", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Inniu ag] LT", nextDay: "[Amrach ag] LT", nextWeek: "dddd [ag] LT", lastDay: "[Inn ag] LT", lastWeek: "dddd [seo caite] [ag] LT", sameElse: "L" }, relativeTime: { future: "i %s", past: "%s  shin", s: "cpla soicind", ss: "%d soicind", m: "nimad", mm: "%d nimad", h: "uair an chloig", hh: "%d uair an chloig", d: "l", dd: "%d l", M: "m", MM: "%d monna", y: "bliain", yy: "%d bliain" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(c) {
            return c + (c === 1 ? "d" : c % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4198: function(k, g, w) {
        (function(B) {
          B.defineLocale("gd", { months: ["Am Faoilleach", "An Gearran", "Am Mrt", "An Giblean", "An Citean", "An t-gmhios", "An t-Iuchar", "An Lnastal", "An t-Sultain", "An Dmhair", "An t-Samhain", "An Dbhlachd"], monthsShort: ["Faoi", "Gear", "Mrt", "Gibl", "Cit", "gmh", "Iuch", "Ln", "Sult", "Dmh", "Samh", "Dbh"], monthsParseExact: !0, weekdays: ["Didmhnaich", "Diluain", "Dimirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"], weekdaysShort: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], weekdaysMin: ["D", "Lu", "M", "Ci", "Ar", "Ha", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[An-diugh aig] LT", nextDay: "[A-mireach aig] LT", nextWeek: "dddd [aig] LT", lastDay: "[An-d aig] LT", lastWeek: "dddd [seo chaidh] [aig] LT", sameElse: "L" }, relativeTime: { future: "ann an %s", past: "bho chionn %s", s: "beagan diogan", ss: "%d diogan", m: "mionaid", mm: "%d mionaidean", h: "uair", hh: "%d uairean", d: "latha", dd: "%d latha", M: "mos", MM: "%d mosan", y: "bliadhna", yy: "%d bliadhna" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(c) {
            return c + (c === 1 ? "d" : c % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2638: function(k, g, w) {
        (function(B) {
          B.defineLocale("gl", { months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split("_"), monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"), weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"), weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoxe " + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[ma " + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [" + (this.hours() !== 1 ? "s" : "a") + "] LT";
          }, lastDay: function() {
            return "[onte " + (this.hours() !== 1 ? "" : "a") + "] LT";
          }, lastWeek: function() {
            return "[o] dddd [pasado " + (this.hours() !== 1 ? "s" : "a") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: function(c) {
            return c.indexOf("un") === 0 ? "n" + c : "en " + c;
          }, past: "hai %s", s: "uns segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "unha hora", hh: "%d horas", d: "un da", dd: "%d das", M: "un mes", MM: "%d meses", y: "un ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 9871: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { s: [" ", " "], ss: [d + " ", d + " "], m: [" ", " "], mm: [d + " ", d + " "], h: [" ", " "], hh: [d + " ", d + " "], d: [" ", " "], dd: [d + " ", d + " "], M: [" ", " "], MM: [d + " ", d + " "], y: [" ", " "], yy: [d + " ", d + " "] };
            return y ? T[b][0] : T[b][1];
          }
          B.defineLocale("gom-deva", { months: { standalone: "___________".split("_"), format: "___________".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "._.__.___._._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "._._._._._._.".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm []", LTS: "A h:mm:ss []", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm []", LLLL: "dddd, MMMM Do, YYYY, A h:mm []", llll: "ddd, D MMM YYYY, A h:mm []" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[] dddd[,] LT", lastDay: "[] LT", lastWeek: "[] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s ", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}()/, ordinal: function(d, m) {
            return m === "D" ? d + "" : d;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /|||/, meridiemHour: function(d, m) {
            return d === 12 && (d = 0), m === "" ? d < 4 ? d : d + 12 : m === "" ? d : m === "" ? d > 12 ? d : d + 12 : m === "" ? d + 12 : void 0;
          }, meridiem: function(d, m, b) {
            return d < 4 ? "" : d < 12 ? "" : d < 16 ? "" : d < 20 ? "" : "";
          } });
        })(w(7840));
      }, 2624: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { s: ["thoddea sekondamni", "thodde sekond"], ss: [d + " sekondamni", d + " sekond"], m: ["eka mintan", "ek minut"], mm: [d + " mintamni", d + " mintam"], h: ["eka voran", "ek vor"], hh: [d + " voramni", d + " voram"], d: ["eka disan", "ek dis"], dd: [d + " disamni", d + " dis"], M: ["eka mhoinean", "ek mhoino"], MM: [d + " mhoineamni", d + " mhoine"], y: ["eka vorsan", "ek voros"], yy: [d + " vorsamni", d + " vorsam"] };
            return y ? T[b][0] : T[b][1];
          }
          B.defineLocale("gom-latn", { months: { standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"), format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"), weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"), weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm [vazta]", LTS: "A h:mm:ss [vazta]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [vazta]", LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]", llll: "ddd, D MMM YYYY, A h:mm [vazta]" }, calendar: { sameDay: "[Aiz] LT", nextDay: "[Faleam] LT", nextWeek: "[Fuddlo] dddd[,] LT", lastDay: "[Kal] LT", lastWeek: "[Fattlo] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s adim", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}(er)/, ordinal: function(d, m) {
            return m === "D" ? d + "er" : d;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /rati|sokallim|donparam|sanje/, meridiemHour: function(d, m) {
            return d === 12 && (d = 0), m === "rati" ? d < 4 ? d : d + 12 : m === "sokallim" ? d : m === "donparam" ? d > 12 ? d : d + 12 : m === "sanje" ? d + 12 : void 0;
          }, meridiem: function(d, m, b) {
            return d < 4 ? "rati" : d < 12 ? "sokallim" : d < 16 ? "donparam" : d < 20 ? "sanje" : "rati";
          } });
        })(w(7840));
      }, 2053: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("gu", { months: "___________".split("_"), monthsShort: "._.__.___._._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /|||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 4 ? m : m + 12 : b === "" ? m : b === "" ? m >= 10 ? m : m + 12 : b === "" ? m + 12 : void 0;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 10 ? "" : m < 17 ? "" : m < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 278: function(k, g, w) {
        (function(B) {
          B.defineLocale("he", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D []MMMM YYYY", LLL: "D []MMMM YYYY HH:mm", LLLL: "dddd, D []MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[ ]LT", nextDay: "[ ]LT", nextWeek: "dddd [] LT", lastDay: "[ ]LT", lastWeek: "[] dddd [ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: " ", ss: "%d ", m: "", mm: "%d ", h: "", hh: function(c) {
            return c === 2 ? "" : c + " ";
          }, d: "", dd: function(c) {
            return c === 2 ? "" : c + " ";
          }, M: "", MM: function(c) {
            return c === 2 ? "" : c + " ";
          }, y: "", yy: function(c) {
            return c === 2 ? "" : c % 10 == 0 && c !== 10 ? c + " " : c + " ";
          } }, meridiemParse: /"|"| | | ||/i, isPM: function(c) {
            return /^("| |)$/.test(c);
          }, meridiem: function(c, d, m) {
            return c < 5 ? " " : c < 10 ? "" : c < 12 ? m ? '"' : " " : c < 18 ? m ? '"' : " " : "";
          } });
        })(w(7840));
      }, 8818: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" }, m = [/^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i];
          B.defineLocale("hi", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: "._.__.___._._._._._.".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, monthsParse: m, longMonthsParse: m, shortMonthsParse: [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i], monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i, monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i, monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i, monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: "  ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(b) {
            return b.replace(/[]/g, function(y) {
              return d[y];
            });
          }, postformat: function(b) {
            return b.replace(/\d/g, function(y) {
              return c[y];
            });
          }, meridiemParse: /|||/, meridiemHour: function(b, y) {
            return b === 12 && (b = 0), y === "" ? b < 4 ? b : b + 12 : y === "" ? b : y === "" ? b >= 10 ? b : b + 12 : y === "" ? b + 12 : void 0;
          }, meridiem: function(b, y, T) {
            return b < 4 ? "" : b < 10 ? "" : b < 17 ? "" : b < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 9543: function(k, g, w) {
        (function(B) {
          function c(d, m, b) {
            var y = d + " ";
            switch (b) {
              case "ss":
                return y + (d === 1 ? "sekunda" : d === 2 || d === 3 || d === 4 ? "sekunde" : "sekundi");
              case "m":
                return m ? "jedna minuta" : "jedne minute";
              case "mm":
                return y + (d === 1 ? "minuta" : d === 2 || d === 3 || d === 4 ? "minute" : "minuta");
              case "h":
                return m ? "jedan sat" : "jednog sata";
              case "hh":
                return y + (d === 1 ? "sat" : d === 2 || d === 3 || d === 4 ? "sata" : "sati");
              case "dd":
                return y + (d === 1 ? "dan" : "dana");
              case "MM":
                return y + (d === 1 ? "mjesec" : d === 2 || d === 3 || d === 4 ? "mjeseca" : "mjeseci");
              case "yy":
                return y + (d === 1 ? "godina" : d === 2 || d === 3 || d === 4 ? "godine" : "godina");
            }
          }
          B.defineLocale("hr", { months: { format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"), standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_") }, monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM YYYY", LLL: "Do MMMM YYYY H:mm", LLLL: "dddd, Do MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prolu] [nedjelju] [u] LT";
              case 3:
                return "[prolu] [srijedu] [u] LT";
              case 6:
                return "[prole] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[proli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: c, m: c, mm: c, h: c, hh: c, d: "dan", dd: c, M: "mjesec", MM: c, y: "godinu", yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 4630: function(k, g, w) {
        (function(B) {
          var c = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");
          function d(b, y, T, n) {
            var o = b;
            switch (T) {
              case "s":
                return n || y ? "nhny msodperc" : "nhny msodperce";
              case "ss":
                return o + (n || y) ? " msodperc" : " msodperce";
              case "m":
                return "egy" + (n || y ? " perc" : " perce");
              case "mm":
                return o + (n || y ? " perc" : " perce");
              case "h":
                return "egy" + (n || y ? " ra" : " rja");
              case "hh":
                return o + (n || y ? " ra" : " rja");
              case "d":
                return "egy" + (n || y ? " nap" : " napja");
              case "dd":
                return o + (n || y ? " nap" : " napja");
              case "M":
                return "egy" + (n || y ? " hnap" : " hnapja");
              case "MM":
                return o + (n || y ? " hnap" : " hnapja");
              case "y":
                return "egy" + (n || y ? " v" : " ve");
              case "yy":
                return o + (n || y ? " v" : " ve");
            }
            return "";
          }
          function m(b) {
            return (b ? "" : "[mlt] ") + "[" + c[this.day()] + "] LT[-kor]";
          }
          B.defineLocale("hu", { months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split("_"), monthsShort: "jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"), weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"), weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D. H:mm", LLLL: "YYYY. MMMM D., dddd H:mm" }, meridiemParse: /de|du/i, isPM: function(b) {
            return b.charAt(1).toLowerCase() === "u";
          }, meridiem: function(b, y, T) {
            return b < 12 ? T === !0 ? "de" : "DE" : T === !0 ? "du" : "DU";
          }, calendar: { sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function() {
            return m.call(this, !0);
          }, lastDay: "[tegnap] LT[-kor]", lastWeek: function() {
            return m.call(this, !1);
          }, sameElse: "L" }, relativeTime: { future: "%s mlva", past: "%s", s: d, ss: d, m: d, mm: d, h: d, hh: d, d, dd: d, M: d, MM: d, y: d, yy: d }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2417: function(k, g, w) {
        (function(B) {
          B.defineLocale("hy-am", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., HH:mm", LLLL: "dddd, D MMMM YYYY ., HH:mm" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", lastDay: "[] LT", nextWeek: function() {
            return "dddd [ ] LT";
          }, lastWeek: function() {
            return "[] dddd [ ] LT";
          }, sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: "  ", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, meridiemParse: /|||/, isPM: function(c) {
            return /^(|)$/.test(c);
          }, meridiem: function(c) {
            return c < 4 ? "" : c < 12 ? "" : c < 17 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/, ordinal: function(c, d) {
            switch (d) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                return c === 1 ? c + "-" : c + "-";
              default:
                return c;
            }
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 424: function(k, g, w) {
        (function(B) {
          B.defineLocale("id", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"), weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|siang|sore|malam/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "pagi" ? c : d === "siang" ? c >= 11 ? c : c + 12 : d === "sore" || d === "malam" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            return c < 11 ? "pagi" : c < 15 ? "siang" : c < 19 ? "sore" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", ss: "%d detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 7213: function(k, g, w) {
        (function(B) {
          function c(m) {
            return m % 100 == 11 || m % 10 != 1;
          }
          function d(m, b, y, T) {
            var n = m + " ";
            switch (y) {
              case "s":
                return b || T ? "nokkrar sekndur" : "nokkrum sekndum";
              case "ss":
                return c(m) ? n + (b || T ? "sekndur" : "sekndum") : n + "seknda";
              case "m":
                return b ? "mnta" : "mntu";
              case "mm":
                return c(m) ? n + (b || T ? "mntur" : "mntum") : b ? n + "mnta" : n + "mntu";
              case "hh":
                return c(m) ? n + (b || T ? "klukkustundir" : "klukkustundum") : n + "klukkustund";
              case "d":
                return b ? "dagur" : T ? "dag" : "degi";
              case "dd":
                return c(m) ? b ? n + "dagar" : n + (T ? "daga" : "dgum") : b ? n + "dagur" : n + (T ? "dag" : "degi");
              case "M":
                return b ? "mnuur" : T ? "mnu" : "mnui";
              case "MM":
                return c(m) ? b ? n + "mnuir" : n + (T ? "mnui" : "mnuum") : b ? n + "mnuur" : n + (T ? "mnu" : "mnui");
              case "y":
                return b || T ? "r" : "ri";
              case "yy":
                return c(m) ? n + (b || T ? "r" : "rum") : n + (b || T ? "r" : "ri");
            }
          }
          B.defineLocale("is", { months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split("_"), monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"), weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split("_"), weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"), weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd, D. MMMM YYYY [kl.] H:mm" }, calendar: { sameDay: "[ dag kl.] LT", nextDay: "[ morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[ gr kl.] LT", lastWeek: "[sasta] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "eftir %s", past: "fyrir %s san", s: d, ss: d, m: d, mm: d, h: "klukkustund", hh: d, d, dd: d, M: d, MM: d, y: d, yy: d }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4354: function(k, g, w) {
        (function(B) {
          B.defineLocale("it-ch", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Oggi alle] LT", nextDay: "[Domani alle] LT", nextWeek: "dddd [alle] LT", lastDay: "[Ieri alle] LT", lastWeek: function() {
            return this.day() === 0 ? "[la scorsa] dddd [alle] LT" : "[lo scorso] dddd [alle] LT";
          }, sameElse: "L" }, relativeTime: { future: function(c) {
            return (/^[0-9].+$/.test(c) ? "tra" : "in") + " " + c;
          }, past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8: function(k, g, w) {
        (function(B) {
          B.defineLocale("it", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: function() {
            return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, nextDay: function() {
            return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, nextWeek: function() {
            return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, lastDay: function() {
            return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, lastWeek: function() {
            return this.day() === 0 ? "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT" : "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, sameElse: "L" }, relativeTime: { future: "tra %s", past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", w: "una settimana", ww: "%d settimane", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6076: function(k, g, w) {
        (function(B) {
          B.defineLocale("ja", { eras: [{ since: "2019-05-01", offset: 1, name: "", narrow: "", abbr: "R" }, { since: "1989-01-08", until: "2019-04-30", offset: 1, name: "", narrow: "", abbr: "H" }, { since: "1926-12-25", until: "1989-01-07", offset: 1, name: "", narrow: "", abbr: "S" }, { since: "1912-07-30", until: "1926-12-24", offset: 1, name: "", narrow: "", abbr: "T" }, { since: "1873-01-01", until: "1912-07-29", offset: 6, name: "", narrow: "", abbr: "M" }, { since: "0001-01-01", until: "1873-12-31", offset: 1, name: "", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "", narrow: "BC", abbr: "BC" }], eraYearOrdinalRegex: /(|\d+)/, eraYearOrdinalParse: function(c, d) {
            return d[1] === "" ? 1 : parseInt(d[1] || c, 10);
          }, months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMD dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMD(ddd) HH:mm" }, meridiemParse: /|/i, isPM: function(c) {
            return c === "";
          }, meridiem: function(c, d, m) {
            return c < 12 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: function(c) {
            return c.week() !== this.week() ? "[]dddd LT" : "dddd LT";
          }, lastDay: "[] LT", lastWeek: function(c) {
            return this.week() !== c.week() ? "[]dddd LT" : "dddd LT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(c, d) {
            switch (d) {
              case "y":
                return c === 1 ? "" : c + "";
              case "d":
              case "D":
              case "DDD":
                return c + "";
              default:
                return c;
            }
          }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d", m: "1", mm: "%d", h: "1", hh: "%d", d: "1", dd: "%d", M: "1", MM: "%d", y: "1", yy: "%d" } });
        })(w(7840));
      }, 7289: function(k, g, w) {
        (function(B) {
          B.defineLocale("jv", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"), weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"), weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /enjing|siyang|sonten|ndalu/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "enjing" ? c : d === "siyang" ? c >= 11 ? c : c + 12 : d === "sonten" || d === "ndalu" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            return c < 11 ? "enjing" : c < 15 ? "siyang" : c < 19 ? "sonten" : "ndalu";
          }, calendar: { sameDay: "[Dinten puniko pukul] LT", nextDay: "[Mbenjang pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kala wingi pukul] LT", lastWeek: "dddd [kepengker pukul] LT", sameElse: "L" }, relativeTime: { future: "wonten ing %s", past: "%s ingkang kepengker", s: "sawetawis detik", ss: "%d detik", m: "setunggal menit", mm: "%d menit", h: "setunggal jam", hh: "%d jam", d: "sedinten", dd: "%d dinten", M: "sewulan", MM: "%d wulan", y: "setaun", yy: "%d taun" }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 6149: function(k, g, w) {
        (function(B) {
          B.defineLocale("ka", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: { standalone: "______".split("_"), format: "______".split("_"), isFormat: /(|)/ }, weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[] LT[-]", nextDay: "[] LT[-]", lastDay: "[] LT[-]", nextWeek: "[] dddd LT[-]", lastWeek: "[] dddd LT-", sameElse: "L" }, relativeTime: { future: function(c) {
            return c.replace(/(|||||)(|)/, function(d, m, b) {
              return b === "" ? m + "" : m + b + "";
            });
          }, past: function(c) {
            return /(||||)/.test(c) ? c.replace(/(|)$/, " ") : //.test(c) ? c.replace(/$/, " ") : c;
          }, s: " ", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/, ordinal: function(c) {
            return c === 0 ? c : c === 1 ? c + "-" : c < 20 || c <= 100 && c % 20 == 0 || c % 100 == 0 ? "-" + c : c + "-";
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 2075: function(k, g, w) {
        (function(B) {
          var c = { 0: "-", 1: "-", 2: "-", 3: "-", 4: "-", 5: "-", 6: "-", 7: "-", 8: "-", 9: "-", 10: "-", 20: "-", 30: "-", 40: "-", 50: "-", 60: "-", 70: "-", 80: "-", 90: "-", 100: "-" };
          B.defineLocale("kk", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "[ ] dddd [] LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}-(|)/, ordinal: function(d) {
            return d + (c[d] || c[d % 10] || c[d >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 4001: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("km", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "dddd [] [] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4360: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("kn", { months: "___________".split("_"), monthsShort: "___________".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /|||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 4 ? m : m + 12 : b === "" ? m : b === "" ? m >= 10 ? m : m + 12 : b === "" ? m + 12 : void 0;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 10 ? "" : m < 17 ? "" : m < 20 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}()/, ordinal: function(m) {
            return m + "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 5071: function(k, g, w) {
        (function(B) {
          B.defineLocale("ko", { months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY MMMM D", LLL: "YYYY MMMM D A h:mm", LLLL: "YYYY MMMM D dddd A h:mm", l: "YYYY.MM.DD.", ll: "YYYY MMMM D", lll: "YYYY MMMM D A h:mm", llll: "YYYY MMMM D dddd A h:mm" }, calendar: { sameDay: " LT", nextDay: " LT", nextWeek: "dddd LT", lastDay: " LT", lastWeek: " dddd LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d", m: "1", mm: "%d", h: " ", hh: "%d", d: "", dd: "%d", M: " ", MM: "%d", y: " ", yy: "%d" }, dayOfMonthOrdinalParse: /\d{1,2}(||)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "";
              case "M":
                return c + "";
              case "w":
              case "W":
                return c + "";
              default:
                return c;
            }
          }, meridiemParse: /|/, isPM: function(c) {
            return c === "";
          }, meridiem: function(c, d, m) {
            return c < 12 ? "" : "";
          } });
        })(w(7840));
      }, 6882: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { s: ["end sanye", "end sanyeyan"], ss: [d + " sanye", d + " sanyeyan"], m: ["deqqeyek", "deqqeyek"], mm: [d + " deqqe", d + " deqqeyan"], h: ["saetek", "saetek"], hh: [d + " saet", d + " saetan"], d: ["rojek", "rojek"], dd: [d + " roj", d + " rojan"], w: ["hefteyek", "hefteyek"], ww: [d + " hefte", d + " hefteyan"], M: ["mehek", "mehek"], MM: [d + " meh", d + " mehan"], y: ["salek", "salek"], yy: [d + " sal", d + " salan"] };
            return m ? T[b][0] : T[b][1];
          }
          B.defineLocale("ku-kmr", { months: "Rbendan_Sibat_Adar_Nsan_Gulan_Hezran_Trmeh_Tebax_lon_Cotmeh_Mijdar_Berfanbar".split("_"), monthsShort: "Rb_Sib_Ada_Ns_Gul_Hez_Tr_Teb_lo_Cot_Mij_Ber".split("_"), monthsParseExact: !0, weekdays: "Yekem_Duem_Sem_arem_Pncem_n_em".split("_"), weekdaysShort: "Yek_Du_S_ar_Pn_n_em".split("_"), weekdaysMin: "Ye_Du_S_a_P_n_e".split("_"), meridiem: function(d, m, b) {
            return d < 12 ? b ? "bn" : "BN" : b ? "pn" : "PN";
          }, meridiemParse: /bn|BN|pn|PN/, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM[a] YYYY[an]", LLL: "Do MMMM[a] YYYY[an] HH:mm", LLLL: "dddd, Do MMMM[a] YYYY[an] HH:mm", ll: "Do MMM[.] YYYY[an]", lll: "Do MMM[.] YYYY[an] HH:mm", llll: "ddd[.], Do MMM[.] YYYY[an] HH:mm" }, calendar: { sameDay: "[ro di saet] LT [de]", nextDay: "[Sib di saet] LT [de]", nextWeek: "dddd [di saet] LT [de]", lastDay: "[Duh di saet] LT [de]", lastWeek: "dddd[a bor di saet] LT [de]", sameElse: "L" }, relativeTime: { future: "di %s de", past: "ber %s", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, w: c, ww: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}(?:y||\.)/, ordinal: function(d, m) {
            var b = m.toLowerCase();
            return b.includes("w") || b.includes("m") ? d + "." : d + function(y) {
              var T = (y = "" + y).substring(y.length - 1), n = y.length > 1 ? y.substring(y.length - 2) : "";
              return n == 12 || n == 13 || T != "2" && T != "3" && n != "50" && T != "70" && T != "80" ? "" : "y";
            }(d);
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1209: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" }, m = [" ", "", "", "", "", "", "", "", "", " ", " ", " "];
          B.defineLocale("ku", { months: m, monthsShort: m, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(b) {
            return //.test(b);
          }, meridiem: function(b, y, T) {
            return b < 12 ? "" : "";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "dddd [] LT", sameElse: "L" }, relativeTime: { future: " %s", past: "%s", s: " ", ss: " %d", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(b) {
            return b.replace(/[]/g, function(y) {
              return d[y];
            }).replace(//g, ",");
          }, postformat: function(b) {
            return b.replace(/\d/g, function(y) {
              return c[y];
            }).replace(/,/g, "");
          }, week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 4125: function(k, g, w) {
        (function(B) {
          var c = { 0: "-", 1: "-", 2: "-", 3: "-", 4: "-", 5: "-", 6: "-", 7: "-", 8: "-", 9: "-", 10: "-", 20: "-", 30: "-", 40: "-", 50: "-", 60: "-", 70: "-", 80: "-", 90: "-", 100: "-" };
          B.defineLocale("ky", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "[ ] dddd [] [] LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}-(|||)/, ordinal: function(d) {
            return d + (c[d] || c[d % 10] || c[d >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 8531: function(k, g, w) {
        (function(B) {
          function c(m, b, y, T) {
            var n = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], M: ["ee Mount", "engem Mount"], y: ["ee Joer", "engem Joer"] };
            return b ? n[y][0] : n[y][1];
          }
          function d(m) {
            if (m = parseInt(m, 10), isNaN(m)) return !1;
            if (m < 0) return !0;
            if (m < 10) return 4 <= m && m <= 7;
            if (m < 100) {
              var b = m % 10;
              return d(b === 0 ? m / 10 : b);
            }
            if (m < 1e4) {
              for (; m >= 10; ) m /= 10;
              return d(m);
            }
            return d(m /= 1e3);
          }
          B.defineLocale("lb", { months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split("_"), weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"), weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm [Auer]", LTS: "H:mm:ss [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm [Auer]", LLLL: "dddd, D. MMMM YYYY H:mm [Auer]" }, calendar: { sameDay: "[Haut um] LT", sameElse: "L", nextDay: "[Muer um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gschter um] LT", lastWeek: function() {
            switch (this.day()) {
              case 2:
              case 4:
                return "[Leschten] dddd [um] LT";
              default:
                return "[Leschte] dddd [um] LT";
            }
          } }, relativeTime: { future: function(m) {
            return d(m.substr(0, m.indexOf(" "))) ? "a " + m : "an " + m;
          }, past: function(m) {
            return d(m.substr(0, m.indexOf(" "))) ? "viru " + m : "virun " + m;
          }, s: "e puer Sekonnen", ss: "%d Sekonnen", m: c, mm: "%d Minutten", h: c, hh: "%d Stonnen", d: c, dd: "%d Deeg", M: c, MM: "%d Mint", y: c, yy: "%d Joer" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5784: function(k, g, w) {
        (function(B) {
          B.defineLocale("lo", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(c) {
            return c === "";
          }, meridiem: function(c, d, m) {
            return c < 12 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[]dddd[] LT", lastDay: "[] LT", lastWeek: "[]dddd[] LT", sameElse: "L" }, relativeTime: { future: " %s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " }, dayOfMonthOrdinalParse: /()\d{1,2}/, ordinal: function(c) {
            return "" + c;
          } });
        })(w(7840));
      }, 4985: function(k, g, w) {
        (function(B) {
          var c = { ss: "sekund_sekundi_sekundes", m: "minut_minuts_minut", mm: "minuts_minui_minutes", h: "valanda_valandos_valand", hh: "valandos_valand_valandas", d: "diena_dienos_dien", dd: "dienos_dien_dienas", M: "mnuo_mnesio_mnes", MM: "mnesiai_mnesi_mnesius", y: "metai_met_metus", yy: "metai_met_metus" };
          function d(T, n, o, l) {
            return n ? b(o)[0] : l ? b(o)[1] : b(o)[2];
          }
          function m(T) {
            return T % 10 == 0 || T > 10 && T < 20;
          }
          function b(T) {
            return c[T].split("_");
          }
          function y(T, n, o, l) {
            var h = T + " ";
            return T === 1 ? h + d(0, n, o[0], l) : n ? h + (m(T) ? b(o)[1] : b(o)[0]) : l ? h + b(o)[1] : h + (m(T) ? b(o)[1] : b(o)[2]);
          }
          B.defineLocale("lt", { months: { format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split("_"), standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split("_"), isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/ }, monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"), weekdays: { format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split("_"), standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split("_"), isFormat: /dddd HH:mm/ }, weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"), weekdaysMin: "S_P_A_T_K_Pn_".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY [m.] MMMM D [d.]", LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]", LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]", l: "YYYY-MM-DD", ll: "YYYY [m.] MMMM D [d.]", lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]", llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]" }, calendar: { sameDay: "[iandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Prajus] dddd LT", sameElse: "L" }, relativeTime: { future: "po %s", past: "prie %s", s: function(T, n, o, l) {
            return n ? "kelios sekunds" : l ? "keli sekundi" : "kelias sekundes";
          }, ss: y, m: d, mm: y, h: d, hh: y, d, dd: y, M: d, MM: y, y: d, yy: y }, dayOfMonthOrdinalParse: /\d{1,2}-oji/, ordinal: function(T) {
            return T + "-oji";
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 1991: function(k, g, w) {
        (function(B) {
          var c = { ss: "sekundes_sekundm_sekunde_sekundes".split("_"), m: "mintes_mintm_minte_mintes".split("_"), mm: "mintes_mintm_minte_mintes".split("_"), h: "stundas_stundm_stunda_stundas".split("_"), hh: "stundas_stundm_stunda_stundas".split("_"), d: "dienas_dienm_diena_dienas".split("_"), dd: "dienas_dienm_diena_dienas".split("_"), M: "mnea_mneiem_mnesis_mnei".split("_"), MM: "mnea_mneiem_mnesis_mnei".split("_"), y: "gada_gadiem_gads_gadi".split("_"), yy: "gada_gadiem_gads_gadi".split("_") };
          function d(y, T, n) {
            return n ? T % 10 == 1 && T % 100 != 11 ? y[2] : y[3] : T % 10 == 1 && T % 100 != 11 ? y[0] : y[1];
          }
          function m(y, T, n) {
            return y + " " + d(c[n], y, T);
          }
          function b(y, T, n) {
            return d(c[n], y, T);
          }
          B.defineLocale("lv", { months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split("_"), monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"), weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split("_"), weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY.", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, HH:mm", LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm" }, calendar: { sameDay: "[odien pulksten] LT", nextDay: "[Rt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagju] dddd [pulksten] LT", sameElse: "L" }, relativeTime: { future: "pc %s", past: "pirms %s", s: function(y, T) {
            return T ? "daas sekundes" : "dam sekundm";
          }, ss: m, m: b, mm: m, h: b, hh: m, d: b, dd: m, M: b, MM: m, y: b, yy: m }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 3507: function(k, g, w) {
        (function(B) {
          var c = { words: { ss: ["sekund", "sekunda", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], dd: ["dan", "dana", "dana"], MM: ["mjesec", "mjeseca", "mjeseci"], yy: ["godina", "godine", "godina"] }, correctGrammaticalCase: function(d, m) {
            return d === 1 ? m[0] : d >= 2 && d <= 4 ? m[1] : m[2];
          }, translate: function(d, m, b) {
            var y = c.words[b];
            return b.length === 1 ? m ? y[0] : y[1] : d + " " + c.correctGrammaticalCase(d, y);
          } };
          B.defineLocale("me", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sjutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jue u] LT", lastWeek: function() {
            return ["[prole] [nedjelje] [u] LT", "[prolog] [ponedjeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srijede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "nekoliko sekundi", ss: c.translate, m: c.translate, mm: c.translate, h: c.translate, hh: c.translate, d: "dan", dd: c.translate, M: "mjesec", MM: c.translate, y: "godinu", yy: c.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 6959: function(k, g, w) {
        (function(B) {
          B.defineLocale("mi", { months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split("_"), monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"), monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i, weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"), weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"), weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [i] HH:mm", LLLL: "dddd, D MMMM YYYY [i] HH:mm" }, calendar: { sameDay: "[i teie mahana, i] LT", nextDay: "[apopo i] LT", nextWeek: "dddd [i] LT", lastDay: "[inanahi i] LT", lastWeek: "dddd [whakamutunga i] LT", sameElse: "L" }, relativeTime: { future: "i roto i %s", past: "%s i mua", s: "te hkona ruarua", ss: "%d hkona", m: "he meneti", mm: "%d meneti", h: "te haora", hh: "%d haora", d: "he ra", dd: "%d ra", M: "he marama", MM: "%d marama", y: "he tau", yy: "%d tau" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 7441: function(k, g, w) {
        (function(B) {
          B.defineLocale("mk", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "e_o_____a".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "[] dddd [] LT", lastDay: "[ ] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[] dddd [] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[] dddd [] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/, ordinal: function(c) {
            var d = c % 10, m = c % 100;
            return c === 0 ? c + "-" : m === 0 ? c + "-" : m > 10 && m < 20 ? c + "-" : d === 1 ? c + "-" : d === 2 ? c + "-" : d === 7 || d === 8 ? c + "-" : c + "-";
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 9844: function(k, g, w) {
        (function(B) {
          B.defineLocale("ml", { months: "___________".split("_"), monthsShort: "._._._.___._._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm -", LTS: "A h:mm:ss -", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm -", LLLL: "dddd, D MMMM YYYY, A h:mm -" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, meridiemParse: /|| ||/i, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" && c >= 4 || d === " " || d === "" ? c + 12 : c;
          }, meridiem: function(c, d, m) {
            return c < 4 ? "" : c < 12 ? "" : c < 17 ? " " : c < 20 ? "" : "";
          } });
        })(w(7840));
      }, 4302: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            switch (b) {
              case "s":
                return m ? " " : " ";
              case "ss":
                return d + (m ? " " : " ");
              case "m":
              case "mm":
                return d + (m ? " " : " ");
              case "h":
              case "hh":
                return d + (m ? " " : " ");
              case "d":
              case "dd":
                return d + (m ? " " : " ");
              case "M":
              case "MM":
                return d + (m ? " " : " ");
              case "y":
              case "yy":
                return d + (m ? " " : " ");
              default:
                return d;
            }
          }
          B.defineLocale("mn", { months: " _ _ _ _ _ _ _ _ _ _  _  ".split("_"), monthsShort: "1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 ".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY  MMMM D", LLL: "YYYY  MMMM D HH:mm", LLLL: "dddd, YYYY  MMMM D HH:mm" }, meridiemParse: /|/i, isPM: function(d) {
            return d === "";
          }, meridiem: function(d, m, b) {
            return d < 12 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[] dddd LT", lastDay: "[] LT", lastWeek: "[] dddd LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2} /, ordinal: function(d, m) {
            switch (m) {
              case "d":
              case "D":
              case "DDD":
                return d + " ";
              default:
                return d;
            }
          } });
        })(w(7840));
      }, 1930: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          function m(b, y, T, n) {
            var o = "";
            if (y) switch (T) {
              case "s":
                o = " ";
                break;
              case "ss":
                o = "%d ";
                break;
              case "m":
                o = " ";
                break;
              case "mm":
                o = "%d ";
                break;
              case "h":
                o = " ";
                break;
              case "hh":
                o = "%d ";
                break;
              case "d":
                o = " ";
                break;
              case "dd":
                o = "%d ";
                break;
              case "M":
                o = " ";
                break;
              case "MM":
                o = "%d ";
                break;
              case "y":
                o = " ";
                break;
              case "yy":
                o = "%d ";
            }
            else switch (T) {
              case "s":
                o = " ";
                break;
              case "ss":
                o = "%d ";
                break;
              case "m":
                o = " ";
                break;
              case "mm":
                o = "%d ";
                break;
              case "h":
                o = " ";
                break;
              case "hh":
                o = "%d ";
                break;
              case "d":
                o = " ";
                break;
              case "dd":
                o = "%d ";
                break;
              case "M":
                o = " ";
                break;
              case "MM":
                o = "%d ";
                break;
              case "y":
                o = " ";
                break;
              case "yy":
                o = "%d ";
            }
            return o.replace(/%d/i, b);
          }
          B.defineLocale("mr", { months: "___________".split("_"), monthsShort: "._._._._._._._._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s", s: m, ss: m, m, mm: m, h: m, hh: m, d: m, dd: m, M: m, MM: m, y: m, yy: m }, preparse: function(b) {
            return b.replace(/[]/g, function(y) {
              return d[y];
            });
          }, postformat: function(b) {
            return b.replace(/\d/g, function(y) {
              return c[y];
            });
          }, meridiemParse: /||||/, meridiemHour: function(b, y) {
            return b === 12 && (b = 0), y === "" || y === "" ? b : y === "" || y === "" || y === "" ? b >= 12 ? b : b + 12 : void 0;
          }, meridiem: function(b, y, T) {
            return b >= 0 && b < 6 ? "" : b < 12 ? "" : b < 17 ? "" : b < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 5748: function(k, g, w) {
        (function(B) {
          B.defineLocale("ms-my", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "pagi" ? c : d === "tengahari" ? c >= 11 ? c : c + 12 : d === "petang" || d === "malam" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            return c < 11 ? "pagi" : c < 15 ? "tengahari" : c < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 4457: function(k, g, w) {
        (function(B) {
          B.defineLocale("ms", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "pagi" ? c : d === "tengahari" ? c >= 11 ? c : c + 12 : d === "petang" || d === "malam" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            return c < 11 ? "pagi" : c < 15 ? "tengahari" : c < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 3980: function(k, g, w) {
        (function(B) {
          B.defineLocale("mt", { months: "Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru".split("_"), monthsShort: "Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di".split("_"), weekdays: "Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt".split("_"), weekdaysShort: "ad_Tne_Tli_Erb_am_im_Sib".split("_"), weekdaysMin: "a_Tn_Tl_Er_a_i_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Illum fil-]LT", nextDay: "[Gada fil-]LT", nextWeek: "dddd [fil-]LT", lastDay: "[Il-biera fil-]LT", lastWeek: "dddd [li gadda] [fil-]LT", sameElse: "L" }, relativeTime: { future: "f %s", past: "%s ilu", s: "ftit sekondi", ss: "%d sekondi", m: "minuta", mm: "%d minuti", h: "siega", hh: "%d siegat", d: "urnata", dd: "%d ranet", M: "xahar", MM: "%d xhur", y: "sena", yy: "%d sni" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2639: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("my", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[.] LT []", nextDay: "[] LT []", nextWeek: "dddd LT []", lastDay: "[.] LT []", lastWeek: "[] dddd LT []", sameElse: "L" }, relativeTime: { future: " %s ", past: " %s ", s: ".", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d ", M: "", MM: "%d ", y: "", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5953: function(k, g, w) {
        (function(B) {
          B.defineLocale("nb", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: !0, weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"), weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"), weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] HH:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i gr kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "noen sekunder", ss: "%d sekunder", m: "ett minutt", mm: "%d minutter", h: "n time", hh: "%d timer", d: "n dag", dd: "%d dager", w: "n uke", ww: "%d uker", M: "n mned", MM: "%d mneder", y: "ett r", yy: "%d r" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5876: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("ne", { months: "___________".split("_"), monthsShort: "._.__.___._._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "._._._._._._.".split("_"), weekdaysMin: "._._._._._._.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /|||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 4 ? m : m + 12 : b === "" ? m : b === "" ? m >= 10 ? m : m + 12 : b === "" ? m + 12 : void 0;
          }, meridiem: function(m, b, y) {
            return m < 3 ? "" : m < 12 ? "" : m < 16 ? "" : m < 20 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[] dddd[,] LT", lastDay: "[] LT", lastWeek: "[] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 493: function(k, g, w) {
        (function(B) {
          var c = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), d = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), m = [/^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], b = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          B.defineLocale("nl-be", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "n minuut", mm: "%d minuten", h: "n uur", hh: "%d uur", d: "n dag", dd: "%d dagen", M: "n maand", MM: "%d maanden", y: "n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(y) {
            return y + (y === 1 || y === 8 || y >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 7475: function(k, g, w) {
        (function(B) {
          var c = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), d = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), m = [/^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], b = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          B.defineLocale("nl", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(y, T) {
            return y ? /-MMM-/.test(T) ? d[y.month()] : c[y.month()] : c;
          }, monthsRegex: b, monthsShortRegex: b, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "n minuut", mm: "%d minuten", h: "n uur", hh: "%d uur", d: "n dag", dd: "%d dagen", w: "n week", ww: "%d weken", M: "n maand", MM: "%d maanden", y: "n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(y) {
            return y + (y === 1 || y === 8 || y >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 9221: function(k, g, w) {
        (function(B) {
          B.defineLocale("nn", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: !0, weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"), weekdaysShort: "su._m._ty._on._to._fr._lau.".split("_"), weekdaysMin: "su_m_ty_on_to_fr_la".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I gr klokka] LT", lastWeek: "[Fregande] dddd [klokka] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s sidan", s: "nokre sekund", ss: "%d sekund", m: "eit minutt", mm: "%d minutt", h: "ein time", hh: "%d timar", d: "ein dag", dd: "%d dagar", w: "ei veke", ww: "%d veker", M: "ein mnad", MM: "%d mnader", y: "eit r", yy: "%d r" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6261: function(k, g, w) {
        (function(B) {
          B.defineLocale("oc-lnc", { months: { standalone: "genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre".split("_"), format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: "[ui a] LT", nextDay: "[deman a] LT", nextWeek: "dddd [a] LT", lastDay: "[ir a] LT", lastWeek: "dddd [passat a] LT", sameElse: "L" }, relativeTime: { future: "d'aqu %s", past: "fa %s", s: "unas segondas", ss: "%d segondas", m: "una minuta", mm: "%d minutas", h: "una ora", hh: "%d oras", d: "un jorn", dd: "%d jorns", M: "un mes", MM: "%d meses", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/, ordinal: function(c, d) {
            var m = c === 1 ? "r" : c === 2 ? "n" : c === 3 ? "r" : c === 4 ? "t" : "";
            return d !== "w" && d !== "W" || (m = "a"), c + m;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4288: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("pa-in", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm ", LTS: "A h:mm:ss ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ", LLLL: "dddd, D MMMM YYYY, A h:mm " }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[] dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /|||/, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 4 ? m : m + 12 : b === "" ? m : b === "" ? m >= 10 ? m : m + 12 : b === "" ? m + 12 : void 0;
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 10 ? "" : m < 17 ? "" : m < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 5813: function(k, g, w) {
        (function(B) {
          var c = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split("_"), d = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split("_"), m = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i];
          function b(T) {
            return T % 10 < 5 && T % 10 > 1 && ~~(T / 10) % 10 != 1;
          }
          function y(T, n, o) {
            var l = T + " ";
            switch (o) {
              case "ss":
                return l + (b(T) ? "sekundy" : "sekund");
              case "m":
                return n ? "minuta" : "minut";
              case "mm":
                return l + (b(T) ? "minuty" : "minut");
              case "h":
                return n ? "godzina" : "godzin";
              case "hh":
                return l + (b(T) ? "godziny" : "godzin");
              case "ww":
                return l + (b(T) ? "tygodnie" : "tygodni");
              case "MM":
                return l + (b(T) ? "miesice" : "miesicy");
              case "yy":
                return l + (b(T) ? "lata" : "lat");
            }
          }
          B.defineLocale("pl", { months: function(T, n) {
            return T ? /D MMMM/.test(n) ? d[T.month()] : c[T.month()] : c;
          }, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"), monthsParse: m, longMonthsParse: m, shortMonthsParse: m, weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Dzi o] LT", nextDay: "[Jutro o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W niedziel o] LT";
              case 2:
                return "[We wtorek o] LT";
              case 3:
                return "[W rod o] LT";
              case 6:
                return "[W sobot o] LT";
              default:
                return "[W] dddd [o] LT";
            }
          }, lastDay: "[Wczoraj o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W zesz niedziel o] LT";
              case 3:
                return "[W zesz rod o] LT";
              case 6:
                return "[W zesz sobot o] LT";
              default:
                return "[W zeszy] dddd [o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", ss: y, m: y, mm: y, h: y, hh: y, d: "1 dzie", dd: "%d dni", w: "tydzie", ww: y, M: "miesic", MM: y, y: "rok", yy: y }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 7078: function(k, g, w) {
        (function(B) {
          B.defineLocale("pt-br", { months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"), weekdaysMin: "do_2_3_4_5_6_s".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [s] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm" }, calendar: { sameDay: "[Hoje s] LT", nextDay: "[Amanh s] LT", nextWeek: "dddd [s] LT", lastDay: "[Ontem s] LT", lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "h %s", s: "poucos segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um ms", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", invalidDate: "Data invlida" });
        })(w(7840));
      }, 2845: function(k, g, w) {
        (function(B) {
          B.defineLocale("pt", { months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"), weekdaysMin: "Do_2_3_4_5_6_S".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm" }, calendar: { sameDay: "[Hoje s] LT", nextDay: "[Amanh s] LT", nextWeek: "dddd [s] LT", lastDay: "[Ontem s] LT", lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "h %s", s: "segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", w: "uma semana", ww: "%d semanas", M: "um ms", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6122: function(k, g, w) {
        (function(B) {
          function c(d, m, b) {
            var y = " ";
            return (d % 100 >= 20 || d >= 100 && d % 100 == 0) && (y = " de "), d + y + { ss: "secunde", mm: "minute", hh: "ore", dd: "zile", ww: "sptmni", MM: "luni", yy: "ani" }[b];
          }
          B.defineLocale("ro", { months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"), monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"), weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"), weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[azi la] LT", nextDay: "[mine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" }, relativeTime: { future: "peste %s", past: "%s n urm", s: "cteva secunde", ss: c, m: "un minut", mm: c, h: "o or", hh: c, d: "o zi", dd: c, w: "o sptmn", ww: c, M: "o lun", MM: c, y: "un an", yy: c }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 936: function(k, g, w) {
        (function(B) {
          function c(m, b, y) {
            return y === "m" ? b ? "" : "" : m + " " + (T = +m, n = { ss: b ? "__" : "__", mm: b ? "__" : "__", hh: "__", dd: "__", ww: "__", MM: "__", yy: "__" }[y].split("_"), T % 10 == 1 && T % 100 != 11 ? n[0] : T % 10 >= 2 && T % 10 <= 4 && (T % 100 < 10 || T % 100 >= 20) ? n[1] : n[2]);
            var T, n;
          }
          var d = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
          B.defineLocale("ru", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: { format: "._._._.____._._._._.".split("_"), standalone: "._.__.____._._._._.".split("_") }, weekdays: { standalone: "______".split("_"), format: "______".split("_"), isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/ }, weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), monthsParse: d, longMonthsParse: d, shortMonthsParse: d, monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i, monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i, monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i, monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., H:mm", LLLL: "dddd, D MMMM YYYY ., H:mm" }, calendar: { sameDay: "[, ] LT", nextDay: "[, ] LT", lastDay: "[, ] LT", nextWeek: function(m) {
            if (m.week() === this.week()) return this.day() === 2 ? "[] dddd, [] LT" : "[] dddd, [] LT";
            switch (this.day()) {
              case 0:
                return "[ ] dddd, [] LT";
              case 1:
              case 2:
              case 4:
                return "[ ] dddd, [] LT";
              case 3:
              case 5:
              case 6:
                return "[ ] dddd, [] LT";
            }
          }, lastWeek: function(m) {
            if (m.week() === this.week()) return this.day() === 2 ? "[] dddd, [] LT" : "[] dddd, [] LT";
            switch (this.day()) {
              case 0:
                return "[ ] dddd, [] LT";
              case 1:
              case 2:
              case 4:
                return "[ ] dddd, [] LT";
              case 3:
              case 5:
              case 6:
                return "[ ] dddd, [] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: " %s", past: "%s ", s: " ", ss: c, m: c, mm: c, h: "", hh: c, d: "", dd: c, w: "", ww: c, M: "", MM: c, y: "", yy: c }, meridiemParse: /|||/i, isPM: function(m) {
            return /^(|)$/.test(m);
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 12 ? "" : m < 17 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(||)/, ordinal: function(m, b) {
            switch (b) {
              case "M":
              case "d":
              case "DDD":
                return m + "-";
              case "D":
                return m + "-";
              case "w":
              case "W":
                return m + "-";
              default:
                return m;
            }
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 2642: function(k, g, w) {
        (function(B) {
          var c = ["", "", "", "", "", "", "", "", "", "", "", ""], d = ["", "", "", "", "", "", ""];
          B.defineLocale("sd", { months: c, monthsShort: c, weekdays: d, weekdaysShort: d, weekdaysMin: d, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd [  ] LT", lastDay: "[] LT", lastWeek: "[ ] dddd [] LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/,/g, "");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 529: function(k, g, w) {
        (function(B) {
          B.defineLocale("se", { months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split("_"), monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"), weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split("_"), weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"), weekdaysMin: "s_v_m_g_d_b_L".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "MMMM D. [b.] YYYY", LLL: "MMMM D. [b.] YYYY [ti.] HH:mm", LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm" }, calendar: { sameDay: "[otne ti] LT", nextDay: "[ihttin ti] LT", nextWeek: "dddd [ti] LT", lastDay: "[ikte ti] LT", lastWeek: "[ovddit] dddd [ti] LT", sameElse: "L" }, relativeTime: { future: "%s geaes", past: "mait %s", s: "moadde sekunddat", ss: "%d sekunddat", m: "okta minuhta", mm: "%d minuhtat", h: "okta diimmu", hh: "%d diimmut", d: "okta beaivi", dd: "%d beaivvit", M: "okta mnnu", MM: "%d mnut", y: "okta jahki", yy: "%d jagit" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 149: function(k, g, w) {
        (function(B) {
          B.defineLocale("si", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "a h:mm", LTS: "a h:mm:ss", L: "YYYY/MM/DD", LL: "YYYY MMMM D", LLL: "YYYY MMMM D, a h:mm", LLLL: "YYYY MMMM D [] dddd, a h:mm:ss" }, calendar: { sameDay: "[] LT[]", nextDay: "[] LT[]", nextWeek: "dddd LT[]", lastDay: "[] LT[]", lastWeek: "[] dddd LT[]", sameElse: "L" }, relativeTime: { future: "%s", past: "%s ", s: " ", ss: " %d", m: "", mm: " %d", h: "", hh: " %d", d: "", dd: " %d", M: "", MM: " %d", y: "", yy: " %d" }, dayOfMonthOrdinalParse: /\d{1,2} /, ordinal: function(c) {
            return c + " ";
          }, meridiemParse: / | |.|../, isPM: function(c) {
            return c === ".." || c === " ";
          }, meridiem: function(c, d, m) {
            return c > 11 ? m ? ".." : " " : m ? ".." : " ";
          } });
        })(w(7840));
      }, 2051: function(k, g, w) {
        (function(B) {
          var c = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split("_"), d = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");
          function m(y) {
            return y > 1 && y < 5;
          }
          function b(y, T, n, o) {
            var l = y + " ";
            switch (n) {
              case "s":
                return T || o ? "pr seknd" : "pr sekundami";
              case "ss":
                return T || o ? l + (m(y) ? "sekundy" : "seknd") : l + "sekundami";
              case "m":
                return T ? "minta" : o ? "mintu" : "mintou";
              case "mm":
                return T || o ? l + (m(y) ? "minty" : "mint") : l + "mintami";
              case "h":
                return T ? "hodina" : o ? "hodinu" : "hodinou";
              case "hh":
                return T || o ? l + (m(y) ? "hodiny" : "hodn") : l + "hodinami";
              case "d":
                return T || o ? "de" : "dom";
              case "dd":
                return T || o ? l + (m(y) ? "dni" : "dn") : l + "dami";
              case "M":
                return T || o ? "mesiac" : "mesiacom";
              case "MM":
                return T || o ? l + (m(y) ? "mesiace" : "mesiacov") : l + "mesiacmi";
              case "y":
                return T || o ? "rok" : "rokom";
              case "yy":
                return T || o ? l + (m(y) ? "roky" : "rokov") : l + "rokmi";
            }
          }
          B.defineLocale("sk", { months: c, monthsShort: d, weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"), weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"), weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm" }, calendar: { sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedeu o] LT";
              case 1:
              case 2:
                return "[v] dddd [o] LT";
              case 3:
                return "[v stredu o] LT";
              case 4:
                return "[vo tvrtok o] LT";
              case 5:
                return "[v piatok o] LT";
              case 6:
                return "[v sobotu o] LT";
            }
          }, lastDay: "[vera o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minul nedeu o] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[minul] dddd [o] LT";
              case 3:
                return "[minul stredu o] LT";
              case 6:
                return "[minul sobotu o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pred %s", s: b, ss: b, m: b, mm: b, h: b, hh: b, d: b, dd: b, M: b, MM: b, y: b, yy: b }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 5306: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = d + " ";
            switch (b) {
              case "s":
                return m || y ? "nekaj sekund" : "nekaj sekundami";
              case "ss":
                return T + (d === 1 ? m ? "sekundo" : "sekundi" : d === 2 ? m || y ? "sekundi" : "sekundah" : d < 5 ? m || y ? "sekunde" : "sekundah" : "sekund");
              case "m":
                return m ? "ena minuta" : "eno minuto";
              case "mm":
                return T + (d === 1 ? m ? "minuta" : "minuto" : d === 2 ? m || y ? "minuti" : "minutama" : d < 5 ? m || y ? "minute" : "minutami" : m || y ? "minut" : "minutami");
              case "h":
                return m ? "ena ura" : "eno uro";
              case "hh":
                return T + (d === 1 ? m ? "ura" : "uro" : d === 2 ? m || y ? "uri" : "urama" : d < 5 ? m || y ? "ure" : "urami" : m || y ? "ur" : "urami");
              case "d":
                return m || y ? "en dan" : "enim dnem";
              case "dd":
                return T + (d === 1 ? m || y ? "dan" : "dnem" : d === 2 ? m || y ? "dni" : "dnevoma" : m || y ? "dni" : "dnevi");
              case "M":
                return m || y ? "en mesec" : "enim mesecem";
              case "MM":
                return T + (d === 1 ? m || y ? "mesec" : "mesecem" : d === 2 ? m || y ? "meseca" : "mesecema" : d < 5 ? m || y ? "mesece" : "meseci" : m || y ? "mesecev" : "meseci");
              case "y":
                return m || y ? "eno leto" : "enim letom";
              case "yy":
                return T + (d === 1 ? m || y ? "leto" : "letom" : d === 2 ? m || y ? "leti" : "letoma" : d < 5 ? m || y ? "leta" : "leti" : m || y ? "let" : "leti");
            }
          }
          B.defineLocale("sl", { months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"), weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"), weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v] [nedeljo] [ob] LT";
              case 3:
                return "[v] [sredo] [ob] LT";
              case 6:
                return "[v] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[v] dddd [ob] LT";
            }
          }, lastDay: "[veraj ob] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prejnjo] [nedeljo] [ob] LT";
              case 3:
                return "[prejnjo] [sredo] [ob] LT";
              case 6:
                return "[prejnjo] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prejnji] dddd [ob] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "ez %s", past: "pred %s", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 4301: function(k, g, w) {
        (function(B) {
          B.defineLocale("sq", { months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split("_"), monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"), weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split("_"), weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"), weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"), weekdaysParseExact: !0, meridiemParse: /PD|MD/, isPM: function(c) {
            return c.charAt(0) === "M";
          }, meridiem: function(c, d, m) {
            return c < 12 ? "PD" : "MD";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Sot n] LT", nextDay: "[Nesr n] LT", nextWeek: "dddd [n] LT", lastDay: "[Dje n] LT", lastWeek: "dddd [e kaluar n] LT", sameElse: "L" }, relativeTime: { future: "n %s", past: "%s m par", s: "disa sekonda", ss: "%d sekonda", m: "nj minut", mm: "%d minuta", h: "nj or", hh: "%d or", d: "nj dit", dd: "%d dit", M: "nj muaj", MM: "%d muaj", y: "nj vit", yy: "%d vite" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 555: function(k, g, w) {
        (function(B) {
          var c = { words: { ss: ["", "", ""], m: [" ", " "], mm: ["", "", ""], h: [" ", " "], hh: ["", "", ""], d: [" ", " "], dd: ["", "", ""], M: [" ", " "], MM: ["", "", ""], y: [" ", " "], yy: ["", "", ""] }, correctGrammaticalCase: function(d, m) {
            return d % 10 >= 1 && d % 10 <= 4 && (d % 100 < 10 || d % 100 >= 20) ? d % 10 == 1 ? m[0] : m[1] : m[2];
          }, translate: function(d, m, b, y) {
            var T, n = c.words[b];
            return b.length === 1 ? b === "y" && m ? " " : y || m ? n[0] : n[1] : (T = c.correctGrammaticalCase(d, n), b === "yy" && m && T === "" ? d + " " : d + " " + T);
          } };
          B.defineLocale("sr-cyrl", { months: "___________".split("_"), monthsShort: "._._._.____._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "._._._._._._.".split("_"), weekdaysMin: "______".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[] [] [] LT";
              case 3:
                return "[] [] [] LT";
              case 6:
                return "[] [] [] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[] dddd [] LT";
            }
          }, lastDay: "[ ] LT", lastWeek: function() {
            return ["[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT", "[] [] [] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: " %s", past: " %s", s: " ", ss: c.translate, m: c.translate, mm: c.translate, h: c.translate, hh: c.translate, d: c.translate, dd: c.translate, M: c.translate, MM: c.translate, y: c.translate, yy: c.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 2452: function(k, g, w) {
        (function(B) {
          var c = { words: { ss: ["sekunda", "sekunde", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], d: ["jedan dan", "jednog dana"], dd: ["dan", "dana", "dana"], M: ["jedan mesec", "jednog meseca"], MM: ["mesec", "meseca", "meseci"], y: ["jednu godinu", "jedne godine"], yy: ["godinu", "godine", "godina"] }, correctGrammaticalCase: function(d, m) {
            return d % 10 >= 1 && d % 10 <= 4 && (d % 100 < 10 || d % 100 >= 20) ? d % 10 == 1 ? m[0] : m[1] : m[2];
          }, translate: function(d, m, b, y) {
            var T, n = c.words[b];
            return b.length === 1 ? b === "y" && m ? "jedna godina" : y || m ? n[0] : n[1] : (T = c.correctGrammaticalCase(d, n), b === "yy" && m && T === "godinu" ? d + " godina" : d + " " + T);
          } };
          B.defineLocale("sr", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedelju] [u] LT";
              case 3:
                return "[u] [sredu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jue u] LT", lastWeek: function() {
            return ["[prole] [nedelje] [u] LT", "[prolog] [ponedeljka] [u] LT", "[prolog] [utorka] [u] LT", "[prole] [srede] [u] LT", "[prolog] [etvrtka] [u] LT", "[prolog] [petka] [u] LT", "[prole] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pre %s", s: "nekoliko sekundi", ss: c.translate, m: c.translate, mm: c.translate, h: c.translate, hh: c.translate, d: c.translate, dd: c.translate, M: c.translate, MM: c.translate, y: c.translate, yy: c.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 395: function(k, g, w) {
        (function(B) {
          B.defineLocale("ss", { months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"), monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"), weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"), weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"), weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Namuhla nga] LT", nextDay: "[Kusasa nga] LT", nextWeek: "dddd [nga] LT", lastDay: "[Itolo nga] LT", lastWeek: "dddd [leliphelile] [nga] LT", sameElse: "L" }, relativeTime: { future: "nga %s", past: "wenteka nga %s", s: "emizuzwana lomcane", ss: "%d mzuzwana", m: "umzuzu", mm: "%d emizuzu", h: "lihora", hh: "%d emahora", d: "lilanga", dd: "%d emalanga", M: "inyanga", MM: "%d tinyanga", y: "umnyaka", yy: "%d iminyaka" }, meridiemParse: /ekuseni|emini|entsambama|ebusuku/, meridiem: function(c, d, m) {
            return c < 11 ? "ekuseni" : c < 15 ? "emini" : c < 19 ? "entsambama" : "ebusuku";
          }, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "ekuseni" ? c : d === "emini" ? c >= 11 ? c : c + 12 : d === "entsambama" || d === "ebusuku" ? c === 0 ? 0 : c + 12 : void 0;
          }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4600: function(k, g, w) {
        (function(B) {
          B.defineLocale("sv", { months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"), weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"), weekdaysMin: "s_m_ti_on_to_fr_l".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" }, calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igr] LT", nextWeek: "[P] dddd LT", lastWeek: "[I] dddd[s] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "fr %s sedan", s: "ngra sekunder", ss: "%d sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en mnad", MM: "%d mnader", y: "ett r", yy: "%d r" }, dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? ":e" : d === 1 || d === 2 ? ":a" : ":e");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6687: function(k, g, w) {
        (function(B) {
          B.defineLocale("sw", { months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"), weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"), weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"), weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "hh:mm A", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[leo saa] LT", nextDay: "[kesho saa] LT", nextWeek: "[wiki ijayo] dddd [saat] LT", lastDay: "[jana] LT", lastWeek: "[wiki iliyopita] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s baadaye", past: "tokea %s", s: "hivi punde", ss: "sekunde %d", m: "dakika moja", mm: "dakika %d", h: "saa limoja", hh: "masaa %d", d: "siku moja", dd: "siku %d", M: "mwezi mmoja", MM: "miezi %d", y: "mwaka mmoja", yy: "miaka %d" }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 5102: function(k, g, w) {
        (function(B) {
          var c = { 1: "", 2: "", 3: "", 4: "", 5: "", 6: "", 7: "", 8: "", 9: "", 0: "" }, d = { "": "1", "": "2", "": "3", "": "4", "": "5", "": "6", "": "7", "": "8", "": "9", "": "0" };
          B.defineLocale("ta", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, HH:mm", LLLL: "dddd, D MMMM YYYY, HH:mm" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[ ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: "  ", ss: "%d ", m: " ", mm: "%d ", h: "  ", hh: "%d  ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(m) {
            return m + "";
          }, preparse: function(m) {
            return m.replace(/[]/g, function(b) {
              return d[b];
            });
          }, postformat: function(m) {
            return m.replace(/\d/g, function(b) {
              return c[b];
            });
          }, meridiemParse: /|||||/, meridiem: function(m, b, y) {
            return m < 2 ? " " : m < 6 ? " " : m < 10 ? " " : m < 14 ? " " : m < 18 ? " " : m < 22 ? " " : " ";
          }, meridiemHour: function(m, b) {
            return m === 12 && (m = 0), b === "" ? m < 2 ? m : m + 12 : b === "" || b === "" || b === "" && m >= 10 ? m : m + 12;
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 1298: function(k, g, w) {
        (function(B) {
          B.defineLocale("te", { months: "___________".split("_"), monthsShort: "._.__.____._._._._.".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "dddd, LT", lastDay: "[] LT", lastWeek: "[] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", meridiemParse: /|||/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" ? c < 4 ? c : c + 12 : d === "" ? c : d === "" ? c >= 10 ? c : c + 12 : d === "" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            return c < 4 ? "" : c < 10 ? "" : c < 17 ? "" : c < 20 ? "" : "";
          }, week: { dow: 0, doy: 6 } });
        })(w(7840));
      }, 9028: function(k, g, w) {
        (function(B) {
          B.defineLocale("tet", { months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"), weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"), weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Ohin iha] LT", nextDay: "[Aban iha] LT", nextWeek: "dddd [iha] LT", lastDay: "[Horiseik iha] LT", lastWeek: "dddd [semana kotuk] [iha] LT", sameElse: "L" }, relativeTime: { future: "iha %s", past: "%s liuba", s: "segundu balun", ss: "segundu %d", m: "minutu ida", mm: "minutu %d", h: "oras ida", hh: "oras %d", d: "loron ida", dd: "loron %d", M: "fulan ida", MM: "fulan %d", y: "tinan ida", yy: "tinan %d" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8680: function(k, g, w) {
        (function(B) {
          var c = { 0: "-", 1: "-", 2: "-", 3: "-", 4: "-", 5: "-", 6: "-", 7: "-", 8: "-", 9: "-", 10: "-", 12: "-", 13: "-", 20: "-", 30: "-", 40: "-", 50: "-", 60: "-", 70: "-", 80: "-", 90: "-", 100: "-" };
          B.defineLocale("tg", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", lastDay: "[ ] LT", nextWeek: "dddd[] [  ] LT", lastWeek: "dddd[] [  ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: "%s ", s: " ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, meridiemParse: /|||/, meridiemHour: function(d, m) {
            return d === 12 && (d = 0), m === "" ? d < 4 ? d : d + 12 : m === "" ? d : m === "" ? d >= 11 ? d : d + 12 : m === "" ? d + 12 : void 0;
          }, meridiem: function(d, m, b) {
            return d < 4 ? "" : d < 11 ? "" : d < 16 ? "" : d < 19 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(|)/, ordinal: function(d) {
            return d + (c[d] || c[d % 10] || c[d >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 7093: function(k, g, w) {
        (function(B) {
          B.defineLocale("th", { months: "___________".split("_"), monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split("_"), monthsParseExact: !0, weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "._._._._._._.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY  H:mm", LLLL: "dddd D MMMM YYYY  H:mm" }, meridiemParse: /|/, isPM: function(c) {
            return c === "";
          }, meridiem: function(c, d, m) {
            return c < 12 ? "" : "";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd[ ] LT", lastDay: "[ ] LT", lastWeek: "[]dddd[ ] LT", sameElse: "L" }, relativeTime: { future: " %s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", w: "1 ", ww: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " } });
        })(w(7840));
      }, 2668: function(k, g, w) {
        (function(B) {
          var c = { 1: "'inji", 5: "'inji", 8: "'inji", 70: "'inji", 80: "'inji", 2: "'nji", 7: "'nji", 20: "'nji", 50: "'nji", 3: "'nji", 4: "'nji", 100: "'nji", 6: "'njy", 9: "'unjy", 10: "'unjy", 30: "'unjy", 60: "'ynjy", 90: "'ynjy" };
          B.defineLocale("tk", { months: "anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr".split("_"), monthsShort: "an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek".split("_"), weekdays: "ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe".split("_"), weekdaysShort: "ek_Du_Si_ar_Pen_Ann_en".split("_"), weekdaysMin: "k_D_S_r_Pn_An_n".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugn sagat] LT", nextDay: "[ertir sagat] LT", nextWeek: "[indiki] dddd [sagat] LT", lastDay: "[dn] LT", lastWeek: "[geen] dddd [sagat] LT", sameElse: "L" }, relativeTime: { future: "%s so", past: "%s ", s: "birne sekunt", m: "bir minut", mm: "%d minut", h: "bir sagat", hh: "%d sagat", d: "bir gn", dd: "%d gn", M: "bir a", MM: "%d a", y: "bir yl", yy: "%d yl" }, ordinal: function(d, m) {
            switch (m) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return d;
              default:
                if (d === 0) return d + "'unjy";
                var b = d % 10;
                return d + (c[b] || c[d % 100 - b] || c[d >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 3890: function(k, g, w) {
        (function(B) {
          B.defineLocale("tl-ph", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(c) {
            return c;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6717: function(k, g, w) {
        (function(B) {
          var c = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
          function d(m, b, y, T) {
            var n = function(o) {
              var l = Math.floor(o % 1e3 / 100), h = Math.floor(o % 100 / 10), p = o % 10, z = "";
              return l > 0 && (z += c[l] + "vatlh"), h > 0 && (z += (z !== "" ? " " : "") + c[h] + "maH"), p > 0 && (z += (z !== "" ? " " : "") + c[p]), z === "" ? "pagh" : z;
            }(m);
            switch (y) {
              case "ss":
                return n + " lup";
              case "mm":
                return n + " tup";
              case "hh":
                return n + " rep";
              case "dd":
                return n + " jaj";
              case "MM":
                return n + " jar";
              case "yy":
                return n + " DIS";
            }
          }
          B.defineLocale("tlh", { months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split("_"), monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split("_"), monthsParseExact: !0, weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[DaHjaj] LT", nextDay: "[waleS] LT", nextWeek: "LLL", lastDay: "[waHu] LT", lastWeek: "LLL", sameElse: "L" }, relativeTime: { future: function(m) {
            var b = m;
            return m.indexOf("jaj") !== -1 ? b.slice(0, -3) + "leS" : m.indexOf("jar") !== -1 ? b.slice(0, -3) + "waQ" : m.indexOf("DIS") !== -1 ? b.slice(0, -3) + "nem" : b + " pIq";
          }, past: function(m) {
            var b = m;
            return m.indexOf("jaj") !== -1 ? b.slice(0, -3) + "Hu" : m.indexOf("jar") !== -1 ? b.slice(0, -3) + "wen" : m.indexOf("DIS") !== -1 ? b.slice(0, -3) + "ben" : b + " ret";
          }, s: "puS lup", ss: d, m: "wa tup", mm: d, h: "wa rep", hh: d, d: "wa jaj", dd: d, M: "wa jar", MM: d, y: "wa DIS", yy: d }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6475: function(k, g, w) {
        (function(B) {
          var c = { 1: "'inci", 5: "'inci", 8: "'inci", 70: "'inci", 80: "'inci", 2: "'nci", 7: "'nci", 20: "'nci", 50: "'nci", 3: "'nc", 4: "'nc", 100: "'nc", 6: "'nc", 9: "'uncu", 10: "'uncu", 30: "'uncu", 60: "'nc", 90: "'nc" };
          B.defineLocale("tr", { months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split("_"), monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"), weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pzt_Sal_ar_Per_Cum_Cmt".split("_"), weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"), meridiem: function(d, m, b) {
            return d < 12 ? b ? "" : "" : b ? "s" : "S";
          }, meridiemParse: /||s|S/, isPM: function(d) {
            return d === "s" || d === "S";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugn saat] LT", nextDay: "[yarn saat] LT", nextWeek: "[gelecek] dddd [saat] LT", lastDay: "[dn] LT", lastWeek: "[geen] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s nce", s: "birka saniye", ss: "%d saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gn", dd: "%d gn", w: "bir hafta", ww: "%d hafta", M: "bir ay", MM: "%d ay", y: "bir yl", yy: "%d yl" }, ordinal: function(d, m) {
            switch (m) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return d;
              default:
                if (d === 0) return d + "'nc";
                var b = d % 10;
                return d + (c[b] || c[d % 100 - b] || c[d >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 911: function(k, g, w) {
        (function(B) {
          function c(d, m, b, y) {
            var T = { s: ["viensas secunds", "'iensas secunds"], ss: [d + " secunds", d + " secunds"], m: ["'n mut", "'iens mut"], mm: [d + " muts", d + " muts"], h: ["'n ora", "'iensa ora"], hh: [d + " oras", d + " oras"], d: ["'n ziua", "'iensa ziua"], dd: [d + " ziuas", d + " ziuas"], M: ["'n mes", "'iens mes"], MM: [d + " mesen", d + " mesen"], y: ["'n ar", "'iens ar"], yy: [d + " ars", d + " ars"] };
            return y || m ? T[b][0] : T[b][1];
          }
          B.defineLocale("tzl", { months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split("_"), monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"), weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"), weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"), weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM [dallas] YYYY", LLL: "D. MMMM [dallas] YYYY HH.mm", LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm" }, meridiemParse: /d\'o|d\'a/i, isPM: function(d) {
            return d.toLowerCase() === "d'o";
          }, meridiem: function(d, m, b) {
            return d > 11 ? b ? "d'o" : "D'O" : b ? "d'a" : "D'A";
          }, calendar: { sameDay: "[oxhi ] LT", nextDay: "[dem ] LT", nextWeek: "dddd [] LT", lastDay: "[ieiri ] LT", lastWeek: "[sr el] dddd [lasteu ] LT", sameElse: "L" }, relativeTime: { future: "osprei %s", past: "ja%s", s: c, ss: c, m: c, mm: c, h: c, hh: c, d: c, dd: c, M: c, MM: c, y: c, yy: c }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8648: function(k, g, w) {
        (function(B) {
          B.defineLocale("tzm-latn", { months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"), monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split("_"), weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"), weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"), weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" }, relativeTime: { future: "dadkh s yan %s", past: "yan %s", s: "imik", ss: "%d imik", m: "minu", mm: "%d minu", h: "saa", hh: "%d tassain", d: "ass", dd: "%d ossan", M: "ayowr", MM: "%d iyyirn", y: "asgas", yy: "%d isgasn" }, week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 6552: function(k, g, w) {
        (function(B) {
          B.defineLocale("tzm", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[ ] LT", lastWeek: "dddd [] LT", sameElse: "L" }, relativeTime: { future: "   %s", past: " %s", s: "", ss: "%d ", m: "", mm: "%d ", h: "", hh: "%d ", d: "", dd: "%d o", M: "o", MM: "%d ", y: "", yy: "%d " }, week: { dow: 6, doy: 12 } });
        })(w(7840));
      }, 419: function(k, g, w) {
        (function(B) {
          B.defineLocale("ug-cn", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY-M-D-", LLL: "YYYY-M-D- HH:mm", LLLL: "dddd YYYY-M-D- HH:mm" }, meridiemParse: / || || |/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === " " || d === "" || d === " " ? c : d === " " || d === "" ? c + 12 : c >= 11 ? c : c + 12;
          }, meridiem: function(c, d, m) {
            var b = 100 * c + d;
            return b < 600 ? " " : b < 900 ? "" : b < 1130 ? " " : b < 1230 ? "" : b < 1800 ? " " : "";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "[] dddd [] LT", lastDay: "[] LT", lastWeek: "[] dddd [] LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "-";
              case "w":
              case "W":
                return c + "-";
              default:
                return c;
            }
          }, preparse: function(c) {
            return c.replace(//g, ",");
          }, postformat: function(c) {
            return c.replace(/,/g, "");
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 6073: function(k, g, w) {
        (function(B) {
          function c(m, b, y) {
            return y === "m" ? b ? "" : "" : y === "h" ? b ? "" : "" : m + " " + (T = +m, n = { ss: b ? "__" : "__", mm: b ? "__" : "__", hh: b ? "__" : "__", dd: "__", MM: "__", yy: "__" }[y].split("_"), T % 10 == 1 && T % 100 != 11 ? n[0] : T % 10 >= 2 && T % 10 <= 4 && (T % 100 < 10 || T % 100 >= 20) ? n[1] : n[2]);
            var T, n;
          }
          function d(m) {
            return function() {
              return m + "" + (this.hours() === 11 ? "" : "") + "] LT";
            };
          }
          B.defineLocale("uk", { months: { format: "___________".split("_"), standalone: "___________".split("_") }, monthsShort: "___________".split("_"), weekdays: function(m, b) {
            var y = { nominative: "______".split("_"), accusative: "______".split("_"), genitive: "______".split("_") };
            return m === !0 ? y.nominative.slice(1, 7).concat(y.nominative.slice(0, 1)) : m ? y[/(\[[]\]) ?dddd/.test(b) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(b) ? "genitive" : "nominative"][m.day()] : y.nominative;
          }, weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY .", LLL: "D MMMM YYYY ., HH:mm", LLLL: "dddd, D MMMM YYYY ., HH:mm" }, calendar: { sameDay: d("[ "), nextDay: d("[ "), lastDay: d("[ "), nextWeek: d("[] dddd ["), lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return d("[] dddd [").call(this);
              case 1:
              case 2:
              case 4:
                return d("[] dddd [").call(this);
            }
          }, sameElse: "L" }, relativeTime: { future: " %s", past: "%s ", s: " ", ss: c, m: c, mm: c, h: "", hh: c, d: "", dd: c, M: "", MM: c, y: "", yy: c }, meridiemParse: /|||/, isPM: function(m) {
            return /^(|)$/.test(m);
          }, meridiem: function(m, b, y) {
            return m < 4 ? "" : m < 12 ? "" : m < 17 ? "" : "";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(|)/, ordinal: function(m, b) {
            switch (b) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return m + "-";
              case "D":
                return m + "-";
              default:
                return m;
            }
          }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 210: function(k, g, w) {
        (function(B) {
          var c = ["", "", "", "", "", "", "", "", "", "", "", ""], d = ["", "", "", "", "", "", ""];
          B.defineLocale("ur", { months: c, monthsShort: c, weekdays: d, weekdaysShort: d, weekdaysMin: d, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /|/, isPM: function(m) {
            return m === "";
          }, meridiem: function(m, b, y) {
            return m < 12 ? "" : "";
          }, calendar: { sameDay: "[ ] LT", nextDay: "[ ] LT", nextWeek: "dddd [] LT", lastDay: "[  ] LT", lastWeek: "[] dddd [] LT", sameElse: "L" }, relativeTime: { future: "%s ", past: "%s ", s: " ", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, preparse: function(m) {
            return m.replace(//g, ",");
          }, postformat: function(m) {
            return m.replace(/,/g, "");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 4010: function(k, g, w) {
        (function(B) {
          B.defineLocale("uz-latn", { months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"), monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"), weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"), weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"), weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Bugun soat] LT [da]", nextDay: "[Ertaga] LT [da]", nextWeek: "dddd [kuni soat] LT [da]", lastDay: "[Kecha soat] LT [da]", lastWeek: "[O'tgan] dddd [kuni soat] LT [da]", sameElse: "L" }, relativeTime: { future: "Yaqin %s ichida", past: "Bir necha %s oldin", s: "soniya", ss: "%d soniya", m: "bir daqiqa", mm: "%d daqiqa", h: "bir soat", hh: "%d soat", d: "bir kun", dd: "%d kun", M: "bir oy", MM: "%d oy", y: "bir yil", yy: "%d yil" }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 9226: function(k, g, w) {
        (function(B) {
          B.defineLocale("uz", { months: "___________".split("_"), monthsShort: "___________".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[ ] LT []", nextDay: "[] LT []", nextWeek: "dddd [ ] LT []", lastDay: "[ ] LT []", lastWeek: "[] dddd [ ] LT []", sameElse: "L" }, relativeTime: { future: " %s ", past: "  %s ", s: "", ss: "%d ", m: " ", mm: "%d ", h: " ", hh: "%d ", d: " ", dd: "%d ", M: " ", MM: "%d ", y: " ", yy: "%d " }, week: { dow: 1, doy: 7 } });
        })(w(7840));
      }, 3272: function(k, g, w) {
        (function(B) {
          B.defineLocale("vi", { months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split("_"), monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"), monthsParseExact: !0, weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split("_"), weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysParseExact: !0, meridiemParse: /sa|ch/i, isPM: function(c) {
            return /^ch$/i.test(c);
          }, meridiem: function(c, d, m) {
            return c < 12 ? m ? "sa" : "SA" : m ? "ch" : "CH";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [nm] YYYY", LLL: "D MMMM [nm] YYYY HH:mm", LLLL: "dddd, D MMMM [nm] YYYY HH:mm", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[Hm nay lc] LT", nextDay: "[Ngy mai lc] LT", nextWeek: "dddd [tun ti lc] LT", lastDay: "[Hm qua lc] LT", lastWeek: "dddd [tun trc lc] LT", sameElse: "L" }, relativeTime: { future: "%s ti", past: "%s trc", s: "vi giy", ss: "%d giy", m: "mt pht", mm: "%d pht", h: "mt gi", hh: "%d gi", d: "mt ngy", dd: "%d ngy", w: "mt tun", ww: "%d tun", M: "mt thng", MM: "%d thng", y: "mt nm", yy: "%d nm" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(c) {
            return c;
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 8780: function(k, g, w) {
        (function(B) {
          B.defineLocale("x-pseudo", { months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split("_"), monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split("_"), monthsParseExact: !0, weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split("_"), weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"), weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[T~d~ t] LT", nextDay: "[T~m~rr~w t] LT", nextWeek: "dddd [t] LT", lastDay: "[~st~rd~ t] LT", lastWeek: "[L~st] dddd [t] LT", sameElse: "L" }, relativeTime: { future: "~ %s", past: "%s ~g", s: " ~fw ~sc~ds", ss: "%d s~c~ds", m: " ~m~t", mm: "%d m~~ts", h: "~ h~r", hh: "%d h~rs", d: " ~d", dd: "%d d~s", M: " ~m~th", MM: "%d m~t~hs", y: " ~r", yy: "%d ~rs" }, dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(c) {
            var d = c % 10;
            return c + (~~(c % 100 / 10) == 1 ? "th" : d === 1 ? "st" : d === 2 ? "nd" : d === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6201: function(k, g, w) {
        (function(B) {
          B.defineLocale("yo", { months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split("_"), monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"), weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"), weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"), weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Oni ni] LT", nextDay: "[la ni] LT", nextWeek: "dddd [s ton'b] [ni] LT", lastDay: "[Ana ni] LT", lastWeek: "dddd [s tol] [ni] LT", sameElse: "L" }, relativeTime: { future: "ni %s", past: "%s kja", s: "isju aaya die", ss: "aaya %d", m: "isju kan", mm: "isju %d", h: "wakati kan", hh: "wakati %d", d: "j kan", dd: "j %d", M: "osu kan", MM: "osu %d", y: "dun kan", yy: "dun %d" }, dayOfMonthOrdinalParse: /j\s\d{1,2}/, ordinal: "j %d", week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6893: function(k, g, w) {
        (function(B) {
          B.defineLocale("zh-cn", { months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMDAhmm", LLLL: "YYYYMDddddAhmm", l: "YYYY/M/D", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, meridiemParse: /|||||/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" || d === "" || d === "" ? c : d === "" || d === "" ? c + 12 : c >= 11 ? c : c + 12;
          }, meridiem: function(c, d, m) {
            var b = 100 * c + d;
            return b < 600 ? "" : b < 900 ? "" : b < 1130 ? "" : b < 1230 ? "" : b < 1800 ? "" : "";
          }, calendar: { sameDay: "[]LT", nextDay: "[]LT", nextWeek: function(c) {
            return c.week() !== this.week() ? "[]dddLT" : "[]dddLT";
          }, lastDay: "[]LT", lastWeek: function(c) {
            return this.week() !== c.week() ? "[]dddLT" : "[]dddLT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(||)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "";
              case "M":
                return c + "";
              case "w":
              case "W":
                return c + "";
              default:
                return c;
            }
          }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", w: "1 ", ww: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " }, week: { dow: 1, doy: 4 } });
        })(w(7840));
      }, 6977: function(k, g, w) {
        (function(B) {
          B.defineLocale("zh-hk", { months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMDdddd HH:mm", l: "YYYY/M/D", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, meridiemParse: /|||||/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" || d === "" || d === "" ? c : d === "" ? c >= 11 ? c : c + 12 : d === "" || d === "" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            var b = 100 * c + d;
            return b < 600 ? "" : b < 900 ? "" : b < 1200 ? "" : b === 1200 ? "" : b < 1800 ? "" : "";
          }, calendar: { sameDay: "[]LT", nextDay: "[]LT", nextWeek: "[]ddddLT", lastDay: "[]LT", lastWeek: "[]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(||)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "";
              case "M":
                return c + "";
              case "w":
              case "W":
                return c + "";
              default:
                return c;
            }
          }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " } });
        })(w(7840));
      }, 4068: function(k, g, w) {
        (function(B) {
          B.defineLocale("zh-mo", { months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMDdddd HH:mm", l: "D/M/YYYY", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, meridiemParse: /|||||/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" || d === "" || d === "" ? c : d === "" ? c >= 11 ? c : c + 12 : d === "" || d === "" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            var b = 100 * c + d;
            return b < 600 ? "" : b < 900 ? "" : b < 1130 ? "" : b < 1230 ? "" : b < 1800 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[]dddd LT", lastDay: "[] LT", lastWeek: "[]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(||)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "";
              case "M":
                return c + "";
              case "w":
              case "W":
                return c + "";
              default:
                return c;
            }
          }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " } });
        })(w(7840));
      }, 217: function(k, g, w) {
        (function(B) {
          B.defineLocale("zh-tw", { months: "___________".split("_"), monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"), weekdays: "______".split("_"), weekdaysShort: "______".split("_"), weekdaysMin: "______".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYYMD", LLL: "YYYYMD HH:mm", LLLL: "YYYYMDdddd HH:mm", l: "YYYY/M/D", ll: "YYYYMD", lll: "YYYYMD HH:mm", llll: "YYYYMDdddd HH:mm" }, meridiemParse: /|||||/, meridiemHour: function(c, d) {
            return c === 12 && (c = 0), d === "" || d === "" || d === "" ? c : d === "" ? c >= 11 ? c : c + 12 : d === "" || d === "" ? c + 12 : void 0;
          }, meridiem: function(c, d, m) {
            var b = 100 * c + d;
            return b < 600 ? "" : b < 900 ? "" : b < 1130 ? "" : b < 1230 ? "" : b < 1800 ? "" : "";
          }, calendar: { sameDay: "[] LT", nextDay: "[] LT", nextWeek: "[]dddd LT", lastDay: "[] LT", lastWeek: "[]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(||)/, ordinal: function(c, d) {
            switch (d) {
              case "d":
              case "D":
              case "DDD":
                return c + "";
              case "M":
                return c + "";
              case "w":
              case "W":
                return c + "";
              default:
                return c;
            }
          }, relativeTime: { future: "%s", past: "%s", s: "", ss: "%d ", m: "1 ", mm: "%d ", h: "1 ", hh: "%d ", d: "1 ", dd: "%d ", M: "1 ", MM: "%d ", y: "1 ", yy: "%d " } });
        })(w(7840));
      }, 7840: function(k, g, w) {
        (k = w.nmd(k)).exports = function() {
          var B, c;
          function d() {
            return B.apply(null, arguments);
          }
          function m(S) {
            return S instanceof Array || Object.prototype.toString.call(S) === "[object Array]";
          }
          function b(S) {
            return S != null && Object.prototype.toString.call(S) === "[object Object]";
          }
          function y(S, O) {
            return Object.prototype.hasOwnProperty.call(S, O);
          }
          function T(S) {
            if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(S).length === 0;
            var O;
            for (O in S) if (y(S, O)) return !1;
            return !0;
          }
          function n(S) {
            return S === void 0;
          }
          function o(S) {
            return typeof S == "number" || Object.prototype.toString.call(S) === "[object Number]";
          }
          function l(S) {
            return S instanceof Date || Object.prototype.toString.call(S) === "[object Date]";
          }
          function h(S, O) {
            var gt, St = [], Yt = S.length;
            for (gt = 0; gt < Yt; ++gt) St.push(O(S[gt], gt));
            return St;
          }
          function p(S, O) {
            for (var gt in O) y(O, gt) && (S[gt] = O[gt]);
            return y(O, "toString") && (S.toString = O.toString), y(O, "valueOf") && (S.valueOf = O.valueOf), S;
          }
          function z(S, O, gt, St) {
            return Br(S, O, gt, St, !0).utc();
          }
          function Z(S) {
            return S._pf == null && (S._pf = { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidEra: null, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], era: null, meridiem: null, rfc2822: !1, weekdayMismatch: !1 }), S._pf;
          }
          function V(S) {
            var O = null, gt = !1, St = S._d && !isNaN(S._d.getTime());
            return St && (O = Z(S), gt = c.call(O.parsedDateParts, function(Yt) {
              return Yt != null;
            }), St = O.overflow < 0 && !O.empty && !O.invalidEra && !O.invalidMonth && !O.invalidWeekday && !O.weekdayMismatch && !O.nullInput && !O.invalidFormat && !O.userInvalidated && (!O.meridiem || O.meridiem && gt), S._strict && (St = St && O.charsLeftOver === 0 && O.unusedTokens.length === 0 && O.bigHour === void 0)), Object.isFrozen != null && Object.isFrozen(S) ? St : (S._isValid = St, S._isValid);
          }
          function Q(S) {
            var O = z(NaN);
            return S != null ? p(Z(O), S) : Z(O).userInvalidated = !0, O;
          }
          c = Array.prototype.some ? Array.prototype.some : function(S) {
            var O, gt = Object(this), St = gt.length >>> 0;
            for (O = 0; O < St; O++) if (O in gt && S.call(this, gt[O], O, gt)) return !0;
            return !1;
          };
          var vt = d.momentProperties = [], Lt = !1;
          function zt(S, O) {
            var gt, St, Yt, re = vt.length;
            if (n(O._isAMomentObject) || (S._isAMomentObject = O._isAMomentObject), n(O._i) || (S._i = O._i), n(O._f) || (S._f = O._f), n(O._l) || (S._l = O._l), n(O._strict) || (S._strict = O._strict), n(O._tzm) || (S._tzm = O._tzm), n(O._isUTC) || (S._isUTC = O._isUTC), n(O._offset) || (S._offset = O._offset), n(O._pf) || (S._pf = Z(O)), n(O._locale) || (S._locale = O._locale), re > 0) for (gt = 0; gt < re; gt++) n(Yt = O[St = vt[gt]]) || (S[St] = Yt);
            return S;
          }
          function X(S) {
            zt(this, S), this._d = new Date(S._d != null ? S._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Lt === !1 && (Lt = !0, d.updateOffset(this), Lt = !1);
          }
          function D(S) {
            return S instanceof X || S != null && S._isAMomentObject != null;
          }
          function yt(S) {
            d.suppressDeprecationWarnings === !1 && typeof console != "undefined" && console.warn && console.warn("Deprecation warning: " + S);
          }
          function Mt(S, O) {
            var gt = !0;
            return p(function() {
              if (d.deprecationHandler != null && d.deprecationHandler(null, S), gt) {
                var St, Yt, re, fe = [], je = arguments.length;
                for (Yt = 0; Yt < je; Yt++) {
                  if (St = "", typeof arguments[Yt] == "object") {
                    for (re in St += `
[` + Yt + "] ", arguments[0]) y(arguments[0], re) && (St += re + ": " + arguments[0][re] + ", ");
                    St = St.slice(0, -2);
                  } else St = arguments[Yt];
                  fe.push(St);
                }
                yt(S + `
Arguments: ` + Array.prototype.slice.call(fe).join("") + `
` + new Error().stack), gt = !1;
              }
              return O.apply(this, arguments);
            }, O);
          }
          var at, Bt = {};
          function jt(S, O) {
            d.deprecationHandler != null && d.deprecationHandler(S, O), Bt[S] || (yt(O), Bt[S] = !0);
          }
          function At(S) {
            return typeof Function != "undefined" && S instanceof Function || Object.prototype.toString.call(S) === "[object Function]";
          }
          function Ce(S, O) {
            var gt, St = p({}, S);
            for (gt in O) y(O, gt) && (b(S[gt]) && b(O[gt]) ? (St[gt] = {}, p(St[gt], S[gt]), p(St[gt], O[gt])) : O[gt] != null ? St[gt] = O[gt] : delete St[gt]);
            for (gt in S) y(S, gt) && !y(O, gt) && b(S[gt]) && (St[gt] = p({}, St[gt]));
            return St;
          }
          function ne(S) {
            S != null && this.set(S);
          }
          d.suppressDeprecationWarnings = !1, d.deprecationHandler = null, at = Object.keys ? Object.keys : function(S) {
            var O, gt = [];
            for (O in S) y(S, O) && gt.push(O);
            return gt;
          };
          function Ht(S, O, gt) {
            var St = "" + Math.abs(S), Yt = O - St.length;
            return (S >= 0 ? gt ? "+" : "" : "-") + Math.pow(10, Math.max(0, Yt)).toString().substr(1) + St;
          }
          var Le = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, sn = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, we = {}, ln = {};
          function _e(S, O, gt, St) {
            var Yt = St;
            typeof St == "string" && (Yt = function() {
              return this[St]();
            }), S && (ln[S] = Yt), O && (ln[O[0]] = function() {
              return Ht(Yt.apply(this, arguments), O[1], O[2]);
            }), gt && (ln[gt] = function() {
              return this.localeData().ordinal(Yt.apply(this, arguments), S);
            });
          }
          function Rn(S, O) {
            return S.isValid() ? (O = En(O, S.localeData()), we[O] = we[O] || function(gt) {
              var St, Yt, re, fe = gt.match(Le);
              for (St = 0, Yt = fe.length; St < Yt; St++) ln[fe[St]] ? fe[St] = ln[fe[St]] : fe[St] = (re = fe[St]).match(/\[[\s\S]/) ? re.replace(/^\[|\]$/g, "") : re.replace(/\\/g, "");
              return function(je) {
                var De, bn = "";
                for (De = 0; De < Yt; De++) bn += At(fe[De]) ? fe[De].call(je, gt) : fe[De];
                return bn;
              };
            }(O), we[O](S)) : S.localeData().invalidDate();
          }
          function En(S, O) {
            var gt = 5;
            function St(Yt) {
              return O.longDateFormat(Yt) || Yt;
            }
            for (sn.lastIndex = 0; gt >= 0 && sn.test(S); ) S = S.replace(sn, St), sn.lastIndex = 0, gt -= 1;
            return S;
          }
          var Tn = { D: "date", dates: "date", date: "date", d: "day", days: "day", day: "day", e: "weekday", weekdays: "weekday", weekday: "weekday", E: "isoWeekday", isoweekdays: "isoWeekday", isoweekday: "isoWeekday", DDD: "dayOfYear", dayofyears: "dayOfYear", dayofyear: "dayOfYear", h: "hour", hours: "hour", hour: "hour", ms: "millisecond", milliseconds: "millisecond", millisecond: "millisecond", m: "minute", minutes: "minute", minute: "minute", M: "month", months: "month", month: "month", Q: "quarter", quarters: "quarter", quarter: "quarter", s: "second", seconds: "second", second: "second", gg: "weekYear", weekyears: "weekYear", weekyear: "weekYear", GG: "isoWeekYear", isoweekyears: "isoWeekYear", isoweekyear: "isoWeekYear", w: "week", weeks: "week", week: "week", W: "isoWeek", isoweeks: "isoWeek", isoweek: "isoWeek", y: "year", years: "year", year: "year" };
          function Nt(S) {
            return typeof S == "string" ? Tn[S] || Tn[S.toLowerCase()] : void 0;
          }
          function Ft(S) {
            var O, gt, St = {};
            for (gt in S) y(S, gt) && (O = Nt(gt)) && (St[O] = S[gt]);
            return St;
          }
          var ve = { date: 9, day: 11, weekday: 11, isoWeekday: 11, dayOfYear: 4, hour: 13, millisecond: 16, minute: 14, month: 8, quarter: 7, second: 15, weekYear: 1, isoWeekYear: 1, week: 5, isoWeek: 5, year: 1 }, q, tt = /\d/, x = /\d\d/, U = /\d{3}/, pt = /\d{4}/, lt = /[+-]?\d{6}/, Gt = /\d\d?/, ee = /\d\d\d\d?/, Vt = /\d\d\d\d\d\d?/, Jt = /\d{1,3}/, Ot = /\d{1,4}/, Kt = /[+-]?\d{1,6}/, ae = /\d+/, Qt = /[+-]?\d+/, me = /Z|[+-]\d\d:?\d\d/gi, an = /Z|[+-]\d\d(?::?\d\d)?/gi, Ge = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, Te = /^[1-9]\d?/, ge = /^([1-9]\d|\d)/;
          function ze(S, O, gt) {
            q[S] = At(O) ? O : function(St, Yt) {
              return St && gt ? gt : O;
            };
          }
          function Zn(S, O) {
            return y(q, S) ? q[S](O._strict, O._locale) : new RegExp(function(gt) {
              return qn(gt.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(St, Yt, re, fe, je) {
                return Yt || re || fe || je;
              }));
            }(S));
          }
          function qn(S) {
            return S.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          function Aa(S) {
            return S < 0 ? Math.ceil(S) || 0 : Math.floor(S);
          }
          function Hn(S) {
            var O = +S, gt = 0;
            return O !== 0 && isFinite(O) && (gt = Aa(O)), gt;
          }
          q = {};
          var xa = {};
          function Ee(S, O) {
            var gt, St, Yt = O;
            for (typeof S == "string" && (S = [S]), o(O) && (Yt = function(re, fe) {
              fe[O] = Hn(re);
            }), St = S.length, gt = 0; gt < St; gt++) xa[S[gt]] = Yt;
          }
          function xe(S, O) {
            Ee(S, function(gt, St, Yt, re) {
              Yt._w = Yt._w || {}, O(gt, Yt._w, Yt, re);
            });
          }
          function Re(S, O, gt) {
            O != null && y(xa, S) && xa[S](O, gt._a, gt, S);
          }
          function Ie(S) {
            return S % 4 == 0 && S % 100 != 0 || S % 400 == 0;
          }
          var Ne = 0, Ue = 1, Xe = 2, He = 3, Ae = 4, be = 5, We = 6, zn = 7, Pe = 8;
          function pn(S) {
            return Ie(S) ? 366 : 365;
          }
          _e("Y", 0, 0, function() {
            var S = this.year();
            return S <= 9999 ? Ht(S, 4) : "+" + S;
          }), _e(0, ["YY", 2], 0, function() {
            return this.year() % 100;
          }), _e(0, ["YYYY", 4], 0, "year"), _e(0, ["YYYYY", 5], 0, "year"), _e(0, ["YYYYYY", 6, !0], 0, "year"), ze("Y", Qt), ze("YY", Gt, x), ze("YYYY", Ot, pt), ze("YYYYY", Kt, lt), ze("YYYYYY", Kt, lt), Ee(["YYYYY", "YYYYYY"], Ne), Ee("YYYY", function(S, O) {
            O[Ne] = S.length === 2 ? d.parseTwoDigitYear(S) : Hn(S);
          }), Ee("YY", function(S, O) {
            O[Ne] = d.parseTwoDigitYear(S);
          }), Ee("Y", function(S, O) {
            O[Ne] = parseInt(S, 10);
          }), d.parseTwoDigitYear = function(S) {
            return Hn(S) + (Hn(S) > 68 ? 1900 : 2e3);
          };
          var yn, wn = vn("FullYear", !0);
          function vn(S, O) {
            return function(gt) {
              return gt != null ? (In(this, S, gt), d.updateOffset(this, O), this) : Pn(this, S);
            };
          }
          function Pn(S, O) {
            if (!S.isValid()) return NaN;
            var gt = S._d, St = S._isUTC;
            switch (O) {
              case "Milliseconds":
                return St ? gt.getUTCMilliseconds() : gt.getMilliseconds();
              case "Seconds":
                return St ? gt.getUTCSeconds() : gt.getSeconds();
              case "Minutes":
                return St ? gt.getUTCMinutes() : gt.getMinutes();
              case "Hours":
                return St ? gt.getUTCHours() : gt.getHours();
              case "Date":
                return St ? gt.getUTCDate() : gt.getDate();
              case "Day":
                return St ? gt.getUTCDay() : gt.getDay();
              case "Month":
                return St ? gt.getUTCMonth() : gt.getMonth();
              case "FullYear":
                return St ? gt.getUTCFullYear() : gt.getFullYear();
              default:
                return NaN;
            }
          }
          function In(S, O, gt) {
            var St, Yt, re, fe, je;
            if (S.isValid() && !isNaN(gt)) {
              switch (St = S._d, Yt = S._isUTC, O) {
                case "Milliseconds":
                  return void (Yt ? St.setUTCMilliseconds(gt) : St.setMilliseconds(gt));
                case "Seconds":
                  return void (Yt ? St.setUTCSeconds(gt) : St.setSeconds(gt));
                case "Minutes":
                  return void (Yt ? St.setUTCMinutes(gt) : St.setMinutes(gt));
                case "Hours":
                  return void (Yt ? St.setUTCHours(gt) : St.setHours(gt));
                case "Date":
                  return void (Yt ? St.setUTCDate(gt) : St.setDate(gt));
                case "FullYear":
                  break;
                default:
                  return;
              }
              re = gt, fe = S.month(), je = (je = S.date()) !== 29 || fe !== 1 || Ie(re) ? je : 28, Yt ? St.setUTCFullYear(re, fe, je) : St.setFullYear(re, fe, je);
            }
          }
          function ye(S, O) {
            if (isNaN(S) || isNaN(O)) return NaN;
            var gt, St = (O % (gt = 12) + gt) % gt;
            return S += (O - St) / 12, St === 1 ? Ie(S) ? 29 : 28 : 31 - St % 7 % 2;
          }
          yn = Array.prototype.indexOf ? Array.prototype.indexOf : function(S) {
            var O;
            for (O = 0; O < this.length; ++O) if (this[O] === S) return O;
            return -1;
          }, _e("M", ["MM", 2], "Mo", function() {
            return this.month() + 1;
          }), _e("MMM", 0, 0, function(S) {
            return this.localeData().monthsShort(this, S);
          }), _e("MMMM", 0, 0, function(S) {
            return this.localeData().months(this, S);
          }), ze("M", Gt, Te), ze("MM", Gt, x), ze("MMM", function(S, O) {
            return O.monthsShortRegex(S);
          }), ze("MMMM", function(S, O) {
            return O.monthsRegex(S);
          }), Ee(["M", "MM"], function(S, O) {
            O[Ue] = Hn(S) - 1;
          }), Ee(["MMM", "MMMM"], function(S, O, gt, St) {
            var Yt = gt._locale.monthsParse(S, St, gt._strict);
            Yt != null ? O[Ue] = Yt : Z(gt).invalidMonth = S;
          });
          var le = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Qe = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), on = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Dn = Ge, Wn = Ge;
          function oa(S, O, gt) {
            var St, Yt, re, fe = S.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], St = 0; St < 12; ++St) re = z([2e3, St]), this._shortMonthsParse[St] = this.monthsShort(re, "").toLocaleLowerCase(), this._longMonthsParse[St] = this.months(re, "").toLocaleLowerCase();
            return gt ? O === "MMM" ? (Yt = yn.call(this._shortMonthsParse, fe)) !== -1 ? Yt : null : (Yt = yn.call(this._longMonthsParse, fe)) !== -1 ? Yt : null : O === "MMM" ? (Yt = yn.call(this._shortMonthsParse, fe)) !== -1 || (Yt = yn.call(this._longMonthsParse, fe)) !== -1 ? Yt : null : (Yt = yn.call(this._longMonthsParse, fe)) !== -1 || (Yt = yn.call(this._shortMonthsParse, fe)) !== -1 ? Yt : null;
          }
          function jn(S, O) {
            if (!S.isValid()) return S;
            if (typeof O == "string") {
              if (/^\d+$/.test(O)) O = Hn(O);
              else if (!o(O = S.localeData().monthsParse(O))) return S;
            }
            var gt = O, St = S.date();
            return St = St < 29 ? St : Math.min(St, ye(S.year(), gt)), S._isUTC ? S._d.setUTCMonth(gt, St) : S._d.setMonth(gt, St), S;
          }
          function ha(S) {
            return S != null ? (jn(this, S), d.updateOffset(this, !0), this) : Pn(this, "Month");
          }
          function va() {
            function S(De, bn) {
              return bn.length - De.length;
            }
            var O, gt, St, Yt, re = [], fe = [], je = [];
            for (O = 0; O < 12; O++) gt = z([2e3, O]), St = qn(this.monthsShort(gt, "")), Yt = qn(this.months(gt, "")), re.push(St), fe.push(Yt), je.push(Yt), je.push(St);
            re.sort(S), fe.sort(S), je.sort(S), this._monthsRegex = new RegExp("^(" + je.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + fe.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + re.join("|") + ")", "i");
          }
          function _a(S, O, gt, St, Yt, re, fe) {
            var je;
            return S < 100 && S >= 0 ? (je = new Date(S + 400, O, gt, St, Yt, re, fe), isFinite(je.getFullYear()) && je.setFullYear(S)) : je = new Date(S, O, gt, St, Yt, re, fe), je;
          }
          function ei(S) {
            var O, gt;
            return S < 100 && S >= 0 ? ((gt = Array.prototype.slice.call(arguments))[0] = S + 400, O = new Date(Date.UTC.apply(null, gt)), isFinite(O.getUTCFullYear()) && O.setUTCFullYear(S)) : O = new Date(Date.UTC.apply(null, arguments)), O;
          }
          function ni(S, O, gt) {
            var St = 7 + O - gt;
            return -(7 + ei(S, 0, St).getUTCDay() - O) % 7 + St - 1;
          }
          function nr(S, O, gt, St, Yt) {
            var re, fe, je = 1 + 7 * (O - 1) + (7 + gt - St) % 7 + ni(S, St, Yt);
            return je <= 0 ? fe = pn(re = S - 1) + je : je > pn(S) ? (re = S + 1, fe = je - pn(S)) : (re = S, fe = je), { year: re, dayOfYear: fe };
          }
          function Ma(S, O, gt) {
            var St, Yt, re = ni(S.year(), O, gt), fe = Math.floor((S.dayOfYear() - re - 1) / 7) + 1;
            return fe < 1 ? St = fe + ba(Yt = S.year() - 1, O, gt) : fe > ba(S.year(), O, gt) ? (St = fe - ba(S.year(), O, gt), Yt = S.year() + 1) : (Yt = S.year(), St = fe), { week: St, year: Yt };
          }
          function ba(S, O, gt) {
            var St = ni(S, O, gt), Yt = ni(S + 1, O, gt);
            return (pn(S) - St + Yt) / 7;
          }
          _e("w", ["ww", 2], "wo", "week"), _e("W", ["WW", 2], "Wo", "isoWeek"), ze("w", Gt, Te), ze("ww", Gt, x), ze("W", Gt, Te), ze("WW", Gt, x), xe(["w", "ww", "W", "WW"], function(S, O, gt, St) {
            O[St.substr(0, 1)] = Hn(S);
          });
          function Ka(S, O) {
            return S.slice(O, 7).concat(S.slice(0, O));
          }
          _e("d", 0, "do", "day"), _e("dd", 0, 0, function(S) {
            return this.localeData().weekdaysMin(this, S);
          }), _e("ddd", 0, 0, function(S) {
            return this.localeData().weekdaysShort(this, S);
          }), _e("dddd", 0, 0, function(S) {
            return this.localeData().weekdays(this, S);
          }), _e("e", 0, 0, "weekday"), _e("E", 0, 0, "isoWeekday"), ze("d", Gt), ze("e", Gt), ze("E", Gt), ze("dd", function(S, O) {
            return O.weekdaysMinRegex(S);
          }), ze("ddd", function(S, O) {
            return O.weekdaysShortRegex(S);
          }), ze("dddd", function(S, O) {
            return O.weekdaysRegex(S);
          }), xe(["dd", "ddd", "dddd"], function(S, O, gt, St) {
            var Yt = gt._locale.weekdaysParse(S, St, gt._strict);
            Yt != null ? O.d = Yt : Z(gt).invalidWeekday = S;
          }), xe(["d", "e", "E"], function(S, O, gt, St) {
            O[St] = Hn(S);
          });
          var Lo = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), $s = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Mo = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ro = Ge, cs = Ge, to = Ge;
          function Fe(S, O, gt) {
            var St, Yt, re, fe = S.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], St = 0; St < 7; ++St) re = z([2e3, 1]).day(St), this._minWeekdaysParse[St] = this.weekdaysMin(re, "").toLocaleLowerCase(), this._shortWeekdaysParse[St] = this.weekdaysShort(re, "").toLocaleLowerCase(), this._weekdaysParse[St] = this.weekdays(re, "").toLocaleLowerCase();
            return gt ? O === "dddd" ? (Yt = yn.call(this._weekdaysParse, fe)) !== -1 ? Yt : null : O === "ddd" ? (Yt = yn.call(this._shortWeekdaysParse, fe)) !== -1 ? Yt : null : (Yt = yn.call(this._minWeekdaysParse, fe)) !== -1 ? Yt : null : O === "dddd" ? (Yt = yn.call(this._weekdaysParse, fe)) !== -1 || (Yt = yn.call(this._shortWeekdaysParse, fe)) !== -1 || (Yt = yn.call(this._minWeekdaysParse, fe)) !== -1 ? Yt : null : O === "ddd" ? (Yt = yn.call(this._shortWeekdaysParse, fe)) !== -1 || (Yt = yn.call(this._weekdaysParse, fe)) !== -1 || (Yt = yn.call(this._minWeekdaysParse, fe)) !== -1 ? Yt : null : (Yt = yn.call(this._minWeekdaysParse, fe)) !== -1 || (Yt = yn.call(this._weekdaysParse, fe)) !== -1 || (Yt = yn.call(this._shortWeekdaysParse, fe)) !== -1 ? Yt : null;
          }
          function dn() {
            function S(Un, Kn) {
              return Kn.length - Un.length;
            }
            var O, gt, St, Yt, re, fe = [], je = [], De = [], bn = [];
            for (O = 0; O < 7; O++) gt = z([2e3, 1]).day(O), St = qn(this.weekdaysMin(gt, "")), Yt = qn(this.weekdaysShort(gt, "")), re = qn(this.weekdays(gt, "")), fe.push(St), je.push(Yt), De.push(re), bn.push(St), bn.push(Yt), bn.push(re);
            fe.sort(S), je.sort(S), De.sort(S), bn.sort(S), this._weekdaysRegex = new RegExp("^(" + bn.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + De.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + je.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + fe.join("|") + ")", "i");
          }
          function kn() {
            return this.hours() % 12 || 12;
          }
          function Jn(S, O) {
            _e(S, 0, 0, function() {
              return this.localeData().meridiem(this.hours(), this.minutes(), O);
            });
          }
          function On(S, O) {
            return O._meridiemParse;
          }
          _e("H", ["HH", 2], 0, "hour"), _e("h", ["hh", 2], 0, kn), _e("k", ["kk", 2], 0, function() {
            return this.hours() || 24;
          }), _e("hmm", 0, 0, function() {
            return "" + kn.apply(this) + Ht(this.minutes(), 2);
          }), _e("hmmss", 0, 0, function() {
            return "" + kn.apply(this) + Ht(this.minutes(), 2) + Ht(this.seconds(), 2);
          }), _e("Hmm", 0, 0, function() {
            return "" + this.hours() + Ht(this.minutes(), 2);
          }), _e("Hmmss", 0, 0, function() {
            return "" + this.hours() + Ht(this.minutes(), 2) + Ht(this.seconds(), 2);
          }), Jn("a", !0), Jn("A", !1), ze("a", On), ze("A", On), ze("H", Gt, ge), ze("h", Gt, Te), ze("k", Gt, Te), ze("HH", Gt, x), ze("hh", Gt, x), ze("kk", Gt, x), ze("hmm", ee), ze("hmmss", Vt), ze("Hmm", ee), ze("Hmmss", Vt), Ee(["H", "HH"], He), Ee(["k", "kk"], function(S, O, gt) {
            var St = Hn(S);
            O[He] = St === 24 ? 0 : St;
          }), Ee(["a", "A"], function(S, O, gt) {
            gt._isPm = gt._locale.isPM(S), gt._meridiem = S;
          }), Ee(["h", "hh"], function(S, O, gt) {
            O[He] = Hn(S), Z(gt).bigHour = !0;
          }), Ee("hmm", function(S, O, gt) {
            var St = S.length - 2;
            O[He] = Hn(S.substr(0, St)), O[Ae] = Hn(S.substr(St)), Z(gt).bigHour = !0;
          }), Ee("hmmss", function(S, O, gt) {
            var St = S.length - 4, Yt = S.length - 2;
            O[He] = Hn(S.substr(0, St)), O[Ae] = Hn(S.substr(St, 2)), O[be] = Hn(S.substr(Yt)), Z(gt).bigHour = !0;
          }), Ee("Hmm", function(S, O, gt) {
            var St = S.length - 2;
            O[He] = Hn(S.substr(0, St)), O[Ae] = Hn(S.substr(St));
          }), Ee("Hmmss", function(S, O, gt) {
            var St = S.length - 4, Yt = S.length - 2;
            O[He] = Hn(S.substr(0, St)), O[Ae] = Hn(S.substr(St, 2)), O[be] = Hn(S.substr(Yt));
          });
          var Ra = vn("Hours", !0), la, $n = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: le, monthsShort: Qe, week: { dow: 0, doy: 6 }, weekdays: Lo, weekdaysMin: Mo, weekdaysShort: $s, meridiemParse: /[ap]\.?m?\.?/i }, xn = {}, Vn = {};
          function ua(S, O) {
            var gt, St = Math.min(S.length, O.length);
            for (gt = 0; gt < St; gt += 1) if (S[gt] !== O[gt]) return gt;
            return St;
          }
          function Ui(S) {
            return S && S.toLowerCase().replace("_", "-");
          }
          function si(S) {
            var O = null;
            if (xn[S] === void 0 && k && k.exports && function(gt) {
              return !(!gt || !gt.match("^[^/\\\\]*$"));
            }(S)) try {
              O = la._abbr, w(5358)("./" + S), ai(O);
            } catch (gt) {
              xn[S] = null;
            }
            return xn[S];
          }
          function ai(S, O) {
            var gt;
            return S && ((gt = n(O) ? Ei(S) : Va(S, O)) ? la = gt : typeof console != "undefined" && console.warn && console.warn("Locale " + S + " not found. Did you forget to load it?")), la._abbr;
          }
          function Va(S, O) {
            if (O !== null) {
              var gt, St = $n;
              if (O.abbr = S, xn[S] != null) jt("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), St = xn[S]._config;
              else if (O.parentLocale != null) if (xn[O.parentLocale] != null) St = xn[O.parentLocale]._config;
              else {
                if ((gt = si(O.parentLocale)) == null) return Vn[O.parentLocale] || (Vn[O.parentLocale] = []), Vn[O.parentLocale].push({ name: S, config: O }), null;
                St = gt._config;
              }
              return xn[S] = new ne(Ce(St, O)), Vn[S] && Vn[S].forEach(function(Yt) {
                Va(Yt.name, Yt.config);
              }), ai(S), xn[S];
            }
            return delete xn[S], null;
          }
          function Ei(S) {
            var O;
            if (S && S._locale && S._locale._abbr && (S = S._locale._abbr), !S) return la;
            if (!m(S)) {
              if (O = si(S)) return O;
              S = [S];
            }
            return function(gt) {
              for (var St, Yt, re, fe, je = 0; je < gt.length; ) {
                for (St = (fe = Ui(gt[je]).split("-")).length, Yt = (Yt = Ui(gt[je + 1])) ? Yt.split("-") : null; St > 0; ) {
                  if (re = si(fe.slice(0, St).join("-"))) return re;
                  if (Yt && Yt.length >= St && ua(fe, Yt) >= St - 1) break;
                  St--;
                }
                je++;
              }
              return la;
            }(S);
          }
          function Rr(S) {
            var O, gt = S._a;
            return gt && Z(S).overflow === -2 && (O = gt[Ue] < 0 || gt[Ue] > 11 ? Ue : gt[Xe] < 1 || gt[Xe] > ye(gt[Ne], gt[Ue]) ? Xe : gt[He] < 0 || gt[He] > 24 || gt[He] === 24 && (gt[Ae] !== 0 || gt[be] !== 0 || gt[We] !== 0) ? He : gt[Ae] < 0 || gt[Ae] > 59 ? Ae : gt[be] < 0 || gt[be] > 59 ? be : gt[We] < 0 || gt[We] > 999 ? We : -1, Z(S)._overflowDayOfYear && (O < Ne || O > Xe) && (O = Xe), Z(S)._overflowWeeks && O === -1 && (O = zn), Z(S)._overflowWeekday && O === -1 && (O = Pe), Z(S).overflow = O), S;
          }
          var eo = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Do = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Ki = /Z|[+-]\d\d(?::?\d\d)?/, ar = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]], ms = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], Ti = /^\/?Date\((-?\d+)/i, Bo = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, no = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
          function fs(S) {
            var O, gt, St, Yt, re, fe, je = S._i, De = eo.exec(je) || Do.exec(je), bn = ar.length, Un = ms.length;
            if (De) {
              for (Z(S).iso = !0, O = 0, gt = bn; O < gt; O++) if (ar[O][1].exec(De[1])) {
                Yt = ar[O][0], St = ar[O][2] !== !1;
                break;
              }
              if (Yt == null) return void (S._isValid = !1);
              if (De[3]) {
                for (O = 0, gt = Un; O < gt; O++) if (ms[O][1].exec(De[3])) {
                  re = (De[2] || " ") + ms[O][0];
                  break;
                }
                if (re == null) return void (S._isValid = !1);
              }
              if (!St && re != null) return void (S._isValid = !1);
              if (De[4]) {
                if (!Ki.exec(De[4])) return void (S._isValid = !1);
                fe = "Z";
              }
              S._f = Yt + (re || "") + (fe || ""), ir(S);
            } else S._isValid = !1;
          }
          function ao(S) {
            var O = parseInt(S, 10);
            return O <= 49 ? 2e3 + O : O <= 999 ? 1900 + O : O;
          }
          function hs(S) {
            var O, gt, St, Yt, re, fe, je, De, bn = Bo.exec(function(Un) {
              return Un.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
            }(S._i));
            if (bn) {
              if (gt = bn[4], St = bn[3], Yt = bn[2], re = bn[5], fe = bn[6], je = bn[7], De = [ao(gt), Qe.indexOf(St), parseInt(Yt, 10), parseInt(re, 10), parseInt(fe, 10)], je && De.push(parseInt(je, 10)), O = De, !function(Un, Kn, ga) {
                return !Un || $s.indexOf(Un) === new Date(Kn[0], Kn[1], Kn[2]).getDay() || (Z(ga).weekdayMismatch = !0, ga._isValid = !1, !1);
              }(bn[1], O, S)) return;
              S._a = O, S._tzm = function(Un, Kn, ga) {
                if (Un) return no[Un];
                if (Kn) return 0;
                var Ea = parseInt(ga, 10), Na = Ea % 100;
                return (Ea - Na) / 100 * 60 + Na;
              }(bn[8], bn[9], bn[10]), S._d = ei.apply(null, S._a), S._d.setUTCMinutes(S._d.getUTCMinutes() - S._tzm), Z(S).rfc2822 = !0;
            } else S._isValid = !1;
          }
          function Cr(S, O, gt) {
            return S != null ? S : O != null ? O : gt;
          }
          function ma(S) {
            var O, gt, St, Yt, re, fe = [];
            if (!S._d) {
              for (St = function(je) {
                var De = new Date(d.now());
                return je._useUTC ? [De.getUTCFullYear(), De.getUTCMonth(), De.getUTCDate()] : [De.getFullYear(), De.getMonth(), De.getDate()];
              }(S), S._w && S._a[Xe] == null && S._a[Ue] == null && function(je) {
                var De, bn, Un, Kn, ga, Ea, Na, Vi, xr;
                (De = je._w).GG != null || De.W != null || De.E != null ? (ga = 1, Ea = 4, bn = Cr(De.GG, je._a[Ne], Ma(da(), 1, 4).year), Un = Cr(De.W, 1), ((Kn = Cr(De.E, 1)) < 1 || Kn > 7) && (Vi = !0)) : (ga = je._locale._week.dow, Ea = je._locale._week.doy, xr = Ma(da(), ga, Ea), bn = Cr(De.gg, je._a[Ne], xr.year), Un = Cr(De.w, xr.week), De.d != null ? ((Kn = De.d) < 0 || Kn > 6) && (Vi = !0) : De.e != null ? (Kn = De.e + ga, (De.e < 0 || De.e > 6) && (Vi = !0)) : Kn = ga), Un < 1 || Un > ba(bn, ga, Ea) ? Z(je)._overflowWeeks = !0 : Vi != null ? Z(je)._overflowWeekday = !0 : (Na = nr(bn, Un, Kn, ga, Ea), je._a[Ne] = Na.year, je._dayOfYear = Na.dayOfYear);
              }(S), S._dayOfYear != null && (re = Cr(S._a[Ne], St[Ne]), (S._dayOfYear > pn(re) || S._dayOfYear === 0) && (Z(S)._overflowDayOfYear = !0), gt = ei(re, 0, S._dayOfYear), S._a[Ue] = gt.getUTCMonth(), S._a[Xe] = gt.getUTCDate()), O = 0; O < 3 && S._a[O] == null; ++O) S._a[O] = fe[O] = St[O];
              for (; O < 7; O++) S._a[O] = fe[O] = S._a[O] == null ? O === 2 ? 1 : 0 : S._a[O];
              S._a[He] === 24 && S._a[Ae] === 0 && S._a[be] === 0 && S._a[We] === 0 && (S._nextDay = !0, S._a[He] = 0), S._d = (S._useUTC ? ei : _a).apply(null, fe), Yt = S._useUTC ? S._d.getUTCDay() : S._d.getDay(), S._tzm != null && S._d.setUTCMinutes(S._d.getUTCMinutes() - S._tzm), S._nextDay && (S._a[He] = 24), S._w && S._w.d !== void 0 && S._w.d !== Yt && (Z(S).weekdayMismatch = !0);
            }
          }
          function ir(S) {
            if (S._f !== d.ISO_8601) if (S._f !== d.RFC_2822) {
              S._a = [], Z(S).empty = !0;
              var O, gt, St, Yt, re, fe, je, De = "" + S._i, bn = De.length, Un = 0;
              for (je = (St = En(S._f, S._locale).match(Le) || []).length, O = 0; O < je; O++) Yt = St[O], (gt = (De.match(Zn(Yt, S)) || [])[0]) && ((re = De.substr(0, De.indexOf(gt))).length > 0 && Z(S).unusedInput.push(re), De = De.slice(De.indexOf(gt) + gt.length), Un += gt.length), ln[Yt] ? (gt ? Z(S).empty = !1 : Z(S).unusedTokens.push(Yt), Re(Yt, gt, S)) : S._strict && !gt && Z(S).unusedTokens.push(Yt);
              Z(S).charsLeftOver = bn - Un, De.length > 0 && Z(S).unusedInput.push(De), S._a[He] <= 12 && Z(S).bigHour === !0 && S._a[He] > 0 && (Z(S).bigHour = void 0), Z(S).parsedDateParts = S._a.slice(0), Z(S).meridiem = S._meridiem, S._a[He] = function(Kn, ga, Ea) {
                var Na;
                return Ea == null ? ga : Kn.meridiemHour != null ? Kn.meridiemHour(ga, Ea) : (Kn.isPM != null && ((Na = Kn.isPM(Ea)) && ga < 12 && (ga += 12), Na || ga !== 12 || (ga = 0)), ga);
              }(S._locale, S._a[He], S._meridiem), (fe = Z(S).era) !== null && (S._a[Ne] = S._locale.erasConvertYear(fe, S._a[Ne])), ma(S), Rr(S);
            } else hs(S);
            else fs(S);
          }
          function Dr(S) {
            var O = S._i, gt = S._f;
            return S._locale = S._locale || Ei(S._l), O === null || gt === void 0 && O === "" ? Q({ nullInput: !0 }) : (typeof O == "string" && (S._i = O = S._locale.preparse(O)), D(O) ? new X(Rr(O)) : (l(O) ? S._d = O : m(gt) ? function(St) {
              var Yt, re, fe, je, De, bn, Un = !1, Kn = St._f.length;
              if (Kn === 0) return Z(St).invalidFormat = !0, void (St._d = /* @__PURE__ */ new Date(NaN));
              for (je = 0; je < Kn; je++) De = 0, bn = !1, Yt = zt({}, St), St._useUTC != null && (Yt._useUTC = St._useUTC), Yt._f = St._f[je], ir(Yt), V(Yt) && (bn = !0), De += Z(Yt).charsLeftOver, De += 10 * Z(Yt).unusedTokens.length, Z(Yt).score = De, Un ? De < fe && (fe = De, re = Yt) : (fe == null || De < fe || bn) && (fe = De, re = Yt, bn && (Un = !0));
              p(St, re || Yt);
            }(S) : gt ? ir(S) : function(St) {
              var Yt = St._i;
              n(Yt) ? St._d = new Date(d.now()) : l(Yt) ? St._d = new Date(Yt.valueOf()) : typeof Yt == "string" ? function(re) {
                var fe = Ti.exec(re._i);
                fe === null ? (fs(re), re._isValid === !1 && (delete re._isValid, hs(re), re._isValid === !1 && (delete re._isValid, re._strict ? re._isValid = !1 : d.createFromInputFallback(re)))) : re._d = /* @__PURE__ */ new Date(+fe[1]);
              }(St) : m(Yt) ? (St._a = h(Yt.slice(0), function(re) {
                return parseInt(re, 10);
              }), ma(St)) : b(Yt) ? function(re) {
                if (!re._d) {
                  var fe = Ft(re._i), je = fe.day === void 0 ? fe.date : fe.day;
                  re._a = h([fe.year, fe.month, je, fe.hour, fe.minute, fe.second, fe.millisecond], function(De) {
                    return De && parseInt(De, 10);
                  }), ma(re);
                }
              }(St) : o(Yt) ? St._d = new Date(Yt) : d.createFromInputFallback(St);
            }(S), V(S) || (S._d = null), S));
          }
          function Br(S, O, gt, St, Yt) {
            var re, fe = {};
            return O !== !0 && O !== !1 || (St = O, O = void 0), gt !== !0 && gt !== !1 || (St = gt, gt = void 0), (b(S) && T(S) || m(S) && S.length === 0) && (S = void 0), fe._isAMomentObject = !0, fe._useUTC = fe._isUTC = Yt, fe._l = gt, fe._i = S, fe._f = O, fe._strict = St, (re = new X(Rr(Dr(fe))))._nextDay && (re.add(1, "d"), re._nextDay = void 0), re;
          }
          function da(S, O, gt, St) {
            return Br(S, O, gt, St, !1);
          }
          d.createFromInputFallback = Mt("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(S) {
            S._d = /* @__PURE__ */ new Date(S._i + (S._useUTC ? " UTC" : ""));
          }), d.ISO_8601 = function() {
          }, d.RFC_2822 = function() {
          };
          var gi = Mt("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
            var S = da.apply(null, arguments);
            return this.isValid() && S.isValid() ? S < this ? this : S : Q();
          }), xo = Mt("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
            var S = da.apply(null, arguments);
            return this.isValid() && S.isValid() ? S > this ? this : S : Q();
          });
          function ki(S, O) {
            var gt, St;
            if (O.length === 1 && m(O[0]) && (O = O[0]), !O.length) return da();
            for (gt = O[0], St = 1; St < O.length; ++St) O[St].isValid() && !O[St][S](gt) || (gt = O[St]);
            return gt;
          }
          var ps = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
          function Is(S) {
            var O = Ft(S), gt = O.year || 0, St = O.quarter || 0, Yt = O.month || 0, re = O.week || O.isoWeek || 0, fe = O.day || 0, je = O.hour || 0, De = O.minute || 0, bn = O.second || 0, Un = O.millisecond || 0;
            this._isValid = function(Kn) {
              var ga, Ea, Na = !1, Vi = ps.length;
              for (ga in Kn) if (y(Kn, ga) && (yn.call(ps, ga) === -1 || Kn[ga] != null && isNaN(Kn[ga]))) return !1;
              for (Ea = 0; Ea < Vi; ++Ea) if (Kn[ps[Ea]]) {
                if (Na) return !1;
                parseFloat(Kn[ps[Ea]]) !== Hn(Kn[ps[Ea]]) && (Na = !0);
              }
              return !0;
            }(O), this._milliseconds = +Un + 1e3 * bn + 6e4 * De + 1e3 * je * 60 * 60, this._days = +fe + 7 * re, this._months = +Yt + 3 * St + 12 * gt, this._data = {}, this._locale = Ei(), this._bubble();
          }
          function io(S) {
            return S instanceof Is;
          }
          function ro(S) {
            return S < 0 ? -1 * Math.round(-1 * S) : Math.round(S);
          }
          function No(S, O) {
            _e(S, 0, 0, function() {
              var gt = this.utcOffset(), St = "+";
              return gt < 0 && (gt = -gt, St = "-"), St + Ht(~~(gt / 60), 2) + O + Ht(~~gt % 60, 2);
            });
          }
          No("Z", ":"), No("ZZ", ""), ze("Z", an), ze("ZZ", an), Ee(["Z", "ZZ"], function(S, O, gt) {
            gt._useUTC = !0, gt._tzm = Cs(an, S);
          });
          var rd = /([\+\-]|\d\d)/gi;
          function Cs(S, O) {
            var gt, St, Yt = (O || "").match(S);
            return Yt === null ? null : (St = 60 * (gt = ((Yt[Yt.length - 1] || []) + "").match(rd) || ["-", 0, 0])[1] + Hn(gt[2])) === 0 ? 0 : gt[0] === "+" ? St : -St;
          }
          function ys(S, O) {
            var gt, St;
            return O._isUTC ? (gt = O.clone(), St = (D(S) || l(S) ? S.valueOf() : da(S).valueOf()) - gt.valueOf(), gt._d.setTime(gt._d.valueOf() + St), d.updateOffset(gt, !1), gt) : da(S).local();
          }
          function Gl(S) {
            return -Math.round(S._d.getTimezoneOffset());
          }
          function zl() {
            return !!this.isValid() && this._isUTC && this._offset === 0;
          }
          d.updateOffset = function() {
          };
          var Ic = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, Yl = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
          function Li(S, O) {
            var gt, St, Yt, re, fe, je, De = S, bn = null;
            return io(S) ? De = { ms: S._milliseconds, d: S._days, M: S._months } : o(S) || !isNaN(+S) ? (De = {}, O ? De[O] = +S : De.milliseconds = +S) : (bn = Ic.exec(S)) ? (gt = bn[1] === "-" ? -1 : 1, De = { y: 0, d: Hn(bn[Xe]) * gt, h: Hn(bn[He]) * gt, m: Hn(bn[Ae]) * gt, s: Hn(bn[be]) * gt, ms: Hn(ro(1e3 * bn[We])) * gt }) : (bn = Yl.exec(S)) ? (gt = bn[1] === "-" ? -1 : 1, De = { y: jr(bn[2], gt), M: jr(bn[3], gt), w: jr(bn[4], gt), d: jr(bn[5], gt), h: jr(bn[6], gt), m: jr(bn[7], gt), s: jr(bn[8], gt) }) : De == null ? De = {} : typeof De == "object" && ("from" in De || "to" in De) && (re = da(De.from), fe = da(De.to), Yt = re.isValid() && fe.isValid() ? (fe = ys(fe, re), re.isBefore(fe) ? je = sd(re, fe) : ((je = sd(fe, re)).milliseconds = -je.milliseconds, je.months = -je.months), je) : { milliseconds: 0, months: 0 }, (De = {}).ms = Yt.milliseconds, De.M = Yt.months), St = new Is(De), io(S) && y(S, "_locale") && (St._locale = S._locale), io(S) && y(S, "_isValid") && (St._isValid = S._isValid), St;
          }
          function jr(S, O) {
            var gt = S && parseFloat(S.replace(",", "."));
            return (isNaN(gt) ? 0 : gt) * O;
          }
          function sd(S, O) {
            var gt = {};
            return gt.months = O.month() - S.month() + 12 * (O.year() - S.year()), S.clone().add(gt.months, "M").isAfter(O) && --gt.months, gt.milliseconds = +O - +S.clone().add(gt.months, "M"), gt;
          }
          function Hl(S, O) {
            return function(gt, St) {
              var Yt;
              return St === null || isNaN(+St) || (jt(O, "moment()." + O + "(period, number) is deprecated. Please use moment()." + O + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), Yt = gt, gt = St, St = Yt), Pl(this, Li(gt, St), S), this;
            };
          }
          function Pl(S, O, gt, St) {
            var Yt = O._milliseconds, re = ro(O._days), fe = ro(O._months);
            S.isValid() && (St = St == null || St, fe && jn(S, Pn(S, "Month") + fe * gt), re && In(S, "Date", Pn(S, "Date") + re * gt), Yt && S._d.setTime(S._d.valueOf() + Yt * gt), St && d.updateOffset(S, re || fe));
          }
          Li.fn = Is.prototype, Li.invalid = function() {
            return Li(NaN);
          };
          var od = Hl(1, "add"), so = Hl(-1, "subtract");
          function Fl(S) {
            return typeof S == "string" || S instanceof String;
          }
          function Go(S) {
            return D(S) || l(S) || Fl(S) || o(S) || function(O) {
              var gt = m(O), St = !1;
              return gt && (St = O.filter(function(Yt) {
                return !o(Yt) && Fl(O);
              }).length === 0), gt && St;
            }(S) || function(O) {
              var gt, St, Yt = b(O) && !T(O), re = !1, fe = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], je = fe.length;
              for (gt = 0; gt < je; gt += 1) St = fe[gt], re = re || y(O, St);
              return Yt && re;
            }(S) || S == null;
          }
          function pa(S, O) {
            if (S.date() < O.date()) return -pa(O, S);
            var gt = 12 * (O.year() - S.year()) + (O.month() - S.month()), St = S.clone().add(gt, "months");
            return -(gt + (O - St < 0 ? (O - St) / (St - S.clone().add(gt - 1, "months")) : (O - St) / (S.clone().add(gt + 1, "months") - St))) || 0;
          }
          function oo(S) {
            var O;
            return S === void 0 ? this._locale._abbr : ((O = Ei(S)) != null && (this._locale = O), this);
          }
          d.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", d.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
          var qa = Mt("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(S) {
            return S === void 0 ? this.localeData() : this.locale(S);
          });
          function zo() {
            return this._locale;
          }
          var Yo = 1e3, As = 6e4, Ho = 36e5, Ol = 126227808e5;
          function Zr(S, O) {
            return (S % O + O) % O;
          }
          function Po(S, O, gt) {
            return S < 100 && S >= 0 ? new Date(S + 400, O, gt) - Ol : new Date(S, O, gt).valueOf();
          }
          function Ul(S, O, gt) {
            return S < 100 && S >= 0 ? Date.UTC(S + 400, O, gt) - Ol : Date.UTC(S, O, gt);
          }
          function Fo(S, O) {
            return O.erasAbbrRegex(S);
          }
          function Kl() {
            var S, O, gt, St, Yt, re = [], fe = [], je = [], De = [], bn = this.eras();
            for (S = 0, O = bn.length; S < O; ++S) gt = qn(bn[S].name), St = qn(bn[S].abbr), Yt = qn(bn[S].narrow), fe.push(gt), re.push(St), je.push(Yt), De.push(gt), De.push(St), De.push(Yt);
            this._erasRegex = new RegExp("^(" + De.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + fe.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + re.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + je.join("|") + ")", "i");
          }
          function Oo(S, O) {
            _e(0, [S, S.length], 0, O);
          }
          function ld(S, O, gt, St, Yt) {
            var re;
            return S == null ? Ma(this, St, Yt).year : (O > (re = ba(S, St, Yt)) && (O = re), Vl.call(this, S, O, gt, St, Yt));
          }
          function Vl(S, O, gt, St, Yt) {
            var re = nr(S, O, gt, St, Yt), fe = ei(re.year, 0, re.dayOfYear);
            return this.year(fe.getUTCFullYear()), this.month(fe.getUTCMonth()), this.date(fe.getUTCDate()), this;
          }
          _e("N", 0, 0, "eraAbbr"), _e("NN", 0, 0, "eraAbbr"), _e("NNN", 0, 0, "eraAbbr"), _e("NNNN", 0, 0, "eraName"), _e("NNNNN", 0, 0, "eraNarrow"), _e("y", ["y", 1], "yo", "eraYear"), _e("y", ["yy", 2], 0, "eraYear"), _e("y", ["yyy", 3], 0, "eraYear"), _e("y", ["yyyy", 4], 0, "eraYear"), ze("N", Fo), ze("NN", Fo), ze("NNN", Fo), ze("NNNN", function(S, O) {
            return O.erasNameRegex(S);
          }), ze("NNNNN", function(S, O) {
            return O.erasNarrowRegex(S);
          }), Ee(["N", "NN", "NNN", "NNNN", "NNNNN"], function(S, O, gt, St) {
            var Yt = gt._locale.erasParse(S, St, gt._strict);
            Yt ? Z(gt).era = Yt : Z(gt).invalidEra = S;
          }), ze("y", ae), ze("yy", ae), ze("yyy", ae), ze("yyyy", ae), ze("yo", function(S, O) {
            return O._eraYearOrdinalRegex || ae;
          }), Ee(["y", "yy", "yyy", "yyyy"], Ne), Ee(["yo"], function(S, O, gt, St) {
            var Yt;
            gt._locale._eraYearOrdinalRegex && (Yt = S.match(gt._locale._eraYearOrdinalRegex)), gt._locale.eraYearOrdinalParse ? O[Ne] = gt._locale.eraYearOrdinalParse(S, Yt) : O[Ne] = parseInt(S, 10);
          }), _e(0, ["gg", 2], 0, function() {
            return this.weekYear() % 100;
          }), _e(0, ["GG", 2], 0, function() {
            return this.isoWeekYear() % 100;
          }), Oo("gggg", "weekYear"), Oo("ggggg", "weekYear"), Oo("GGGG", "isoWeekYear"), Oo("GGGGG", "isoWeekYear"), ze("G", Qt), ze("g", Qt), ze("GG", Gt, x), ze("gg", Gt, x), ze("GGGG", Ot, pt), ze("gggg", Ot, pt), ze("GGGGG", Kt, lt), ze("ggggg", Kt, lt), xe(["gggg", "ggggg", "GGGG", "GGGGG"], function(S, O, gt, St) {
            O[St.substr(0, 2)] = Hn(S);
          }), xe(["gg", "GG"], function(S, O, gt, St) {
            O[St] = d.parseTwoDigitYear(S);
          }), _e("Q", 0, "Qo", "quarter"), ze("Q", tt), Ee("Q", function(S, O) {
            O[Ue] = 3 * (Hn(S) - 1);
          }), _e("D", ["DD", 2], "Do", "date"), ze("D", Gt, Te), ze("DD", Gt, x), ze("Do", function(S, O) {
            return S ? O._dayOfMonthOrdinalParse || O._ordinalParse : O._dayOfMonthOrdinalParseLenient;
          }), Ee(["D", "DD"], Xe), Ee("Do", function(S, O) {
            O[Xe] = Hn(S.match(Gt)[0]);
          });
          var ud = vn("Date", !0);
          _e("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), ze("DDD", Jt), ze("DDDD", U), Ee(["DDD", "DDDD"], function(S, O, gt) {
            gt._dayOfYear = Hn(S);
          }), _e("m", ["mm", 2], 0, "minute"), ze("m", Gt, ge), ze("mm", Gt, x), Ee(["m", "mm"], Ae);
          var dd = vn("Minutes", !1);
          _e("s", ["ss", 2], 0, "second"), ze("s", Gt, ge), ze("ss", Gt, x), Ee(["s", "ss"], be);
          var yr, Xl, gd = vn("Seconds", !1);
          for (_e("S", 0, 0, function() {
            return ~~(this.millisecond() / 100);
          }), _e(0, ["SS", 2], 0, function() {
            return ~~(this.millisecond() / 10);
          }), _e(0, ["SSS", 3], 0, "millisecond"), _e(0, ["SSSS", 4], 0, function() {
            return 10 * this.millisecond();
          }), _e(0, ["SSSSS", 5], 0, function() {
            return 100 * this.millisecond();
          }), _e(0, ["SSSSSS", 6], 0, function() {
            return 1e3 * this.millisecond();
          }), _e(0, ["SSSSSSS", 7], 0, function() {
            return 1e4 * this.millisecond();
          }), _e(0, ["SSSSSSSS", 8], 0, function() {
            return 1e5 * this.millisecond();
          }), _e(0, ["SSSSSSSSS", 9], 0, function() {
            return 1e6 * this.millisecond();
          }), ze("S", Jt, tt), ze("SS", Jt, x), ze("SSS", Jt, U), yr = "SSSS"; yr.length <= 9; yr += "S") ze(yr, ae);
          function Cc(S, O) {
            O[We] = Hn(1e3 * ("0." + S));
          }
          for (yr = "S"; yr.length <= 9; yr += "S") Ee(yr, Cc);
          Xl = vn("Milliseconds", !1), _e("z", 0, 0, "zoneAbbr"), _e("zz", 0, 0, "zoneName");
          var un = X.prototype;
          function Wl(S) {
            return S;
          }
          un.add = od, un.calendar = function(S, O) {
            arguments.length === 1 && (arguments[0] ? Go(arguments[0]) ? (S = arguments[0], O = void 0) : function(fe) {
              var je, De = b(fe) && !T(fe), bn = !1, Un = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
              for (je = 0; je < Un.length; je += 1) bn = bn || y(fe, Un[je]);
              return De && bn;
            }(arguments[0]) && (O = arguments[0], S = void 0) : (S = void 0, O = void 0));
            var gt = S || da(), St = ys(gt, this).startOf("day"), Yt = d.calendarFormat(this, St) || "sameElse", re = O && (At(O[Yt]) ? O[Yt].call(this, gt) : O[Yt]);
            return this.format(re || this.localeData().calendar(Yt, this, da(gt)));
          }, un.clone = function() {
            return new X(this);
          }, un.diff = function(S, O, gt) {
            var St, Yt, re;
            if (!this.isValid()) return NaN;
            if (!(St = ys(S, this)).isValid()) return NaN;
            switch (Yt = 6e4 * (St.utcOffset() - this.utcOffset()), O = Nt(O)) {
              case "year":
                re = pa(this, St) / 12;
                break;
              case "month":
                re = pa(this, St);
                break;
              case "quarter":
                re = pa(this, St) / 3;
                break;
              case "second":
                re = (this - St) / 1e3;
                break;
              case "minute":
                re = (this - St) / 6e4;
                break;
              case "hour":
                re = (this - St) / 36e5;
                break;
              case "day":
                re = (this - St - Yt) / 864e5;
                break;
              case "week":
                re = (this - St - Yt) / 6048e5;
                break;
              default:
                re = this - St;
            }
            return gt ? re : Aa(re);
          }, un.endOf = function(S) {
            var O, gt;
            if ((S = Nt(S)) === void 0 || S === "millisecond" || !this.isValid()) return this;
            switch (gt = this._isUTC ? Ul : Po, S) {
              case "year":
                O = gt(this.year() + 1, 0, 1) - 1;
                break;
              case "quarter":
                O = gt(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
              case "month":
                O = gt(this.year(), this.month() + 1, 1) - 1;
                break;
              case "week":
                O = gt(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
              case "isoWeek":
                O = gt(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
              case "day":
              case "date":
                O = gt(this.year(), this.month(), this.date() + 1) - 1;
                break;
              case "hour":
                O = this._d.valueOf(), O += Ho - Zr(O + (this._isUTC ? 0 : this.utcOffset() * As), Ho) - 1;
                break;
              case "minute":
                O = this._d.valueOf(), O += As - Zr(O, As) - 1;
                break;
              case "second":
                O = this._d.valueOf(), O += Yo - Zr(O, Yo) - 1;
            }
            return this._d.setTime(O), d.updateOffset(this, !0), this;
          }, un.format = function(S) {
            S || (S = this.isUtc() ? d.defaultFormatUtc : d.defaultFormat);
            var O = Rn(this, S);
            return this.localeData().postformat(O);
          }, un.from = function(S, O) {
            return this.isValid() && (D(S) && S.isValid() || da(S).isValid()) ? Li({ to: this, from: S }).locale(this.locale()).humanize(!O) : this.localeData().invalidDate();
          }, un.fromNow = function(S) {
            return this.from(da(), S);
          }, un.to = function(S, O) {
            return this.isValid() && (D(S) && S.isValid() || da(S).isValid()) ? Li({ from: this, to: S }).locale(this.locale()).humanize(!O) : this.localeData().invalidDate();
          }, un.toNow = function(S) {
            return this.to(da(), S);
          }, un.get = function(S) {
            return At(this[S = Nt(S)]) ? this[S]() : this;
          }, un.invalidAt = function() {
            return Z(this).overflow;
          }, un.isAfter = function(S, O) {
            var gt = D(S) ? S : da(S);
            return !(!this.isValid() || !gt.isValid()) && ((O = Nt(O) || "millisecond") === "millisecond" ? this.valueOf() > gt.valueOf() : gt.valueOf() < this.clone().startOf(O).valueOf());
          }, un.isBefore = function(S, O) {
            var gt = D(S) ? S : da(S);
            return !(!this.isValid() || !gt.isValid()) && ((O = Nt(O) || "millisecond") === "millisecond" ? this.valueOf() < gt.valueOf() : this.clone().endOf(O).valueOf() < gt.valueOf());
          }, un.isBetween = function(S, O, gt, St) {
            var Yt = D(S) ? S : da(S), re = D(O) ? O : da(O);
            return !!(this.isValid() && Yt.isValid() && re.isValid()) && ((St = St || "()")[0] === "(" ? this.isAfter(Yt, gt) : !this.isBefore(Yt, gt)) && (St[1] === ")" ? this.isBefore(re, gt) : !this.isAfter(re, gt));
          }, un.isSame = function(S, O) {
            var gt, St = D(S) ? S : da(S);
            return !(!this.isValid() || !St.isValid()) && ((O = Nt(O) || "millisecond") === "millisecond" ? this.valueOf() === St.valueOf() : (gt = St.valueOf(), this.clone().startOf(O).valueOf() <= gt && gt <= this.clone().endOf(O).valueOf()));
          }, un.isSameOrAfter = function(S, O) {
            return this.isSame(S, O) || this.isAfter(S, O);
          }, un.isSameOrBefore = function(S, O) {
            return this.isSame(S, O) || this.isBefore(S, O);
          }, un.isValid = function() {
            return V(this);
          }, un.lang = qa, un.locale = oo, un.localeData = zo, un.max = xo, un.min = gi, un.parsingFlags = function() {
            return p({}, Z(this));
          }, un.set = function(S, O) {
            if (typeof S == "object") {
              var gt, St = function(re) {
                var fe, je = [];
                for (fe in re) y(re, fe) && je.push({ unit: fe, priority: ve[fe] });
                return je.sort(function(De, bn) {
                  return De.priority - bn.priority;
                }), je;
              }(S = Ft(S)), Yt = St.length;
              for (gt = 0; gt < Yt; gt++) this[St[gt].unit](S[St[gt].unit]);
            } else if (At(this[S = Nt(S)])) return this[S](O);
            return this;
          }, un.startOf = function(S) {
            var O, gt;
            if ((S = Nt(S)) === void 0 || S === "millisecond" || !this.isValid()) return this;
            switch (gt = this._isUTC ? Ul : Po, S) {
              case "year":
                O = gt(this.year(), 0, 1);
                break;
              case "quarter":
                O = gt(this.year(), this.month() - this.month() % 3, 1);
                break;
              case "month":
                O = gt(this.year(), this.month(), 1);
                break;
              case "week":
                O = gt(this.year(), this.month(), this.date() - this.weekday());
                break;
              case "isoWeek":
                O = gt(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
              case "day":
              case "date":
                O = gt(this.year(), this.month(), this.date());
                break;
              case "hour":
                O = this._d.valueOf(), O -= Zr(O + (this._isUTC ? 0 : this.utcOffset() * As), Ho);
                break;
              case "minute":
                O = this._d.valueOf(), O -= Zr(O, As);
                break;
              case "second":
                O = this._d.valueOf(), O -= Zr(O, Yo);
            }
            return this._d.setTime(O), d.updateOffset(this, !0), this;
          }, un.subtract = so, un.toArray = function() {
            var S = this;
            return [S.year(), S.month(), S.date(), S.hour(), S.minute(), S.second(), S.millisecond()];
          }, un.toObject = function() {
            var S = this;
            return { years: S.year(), months: S.month(), date: S.date(), hours: S.hours(), minutes: S.minutes(), seconds: S.seconds(), milliseconds: S.milliseconds() };
          }, un.toDate = function() {
            return new Date(this.valueOf());
          }, un.toISOString = function(S) {
            if (!this.isValid()) return null;
            var O = S !== !0, gt = O ? this.clone().utc() : this;
            return gt.year() < 0 || gt.year() > 9999 ? Rn(gt, O ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : At(Date.prototype.toISOString) ? O ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", Rn(gt, "Z")) : Rn(gt, O ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }, un.inspect = function() {
            if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
            var S, O, gt, St = "moment", Yt = "";
            return this.isLocal() || (St = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", Yt = "Z"), S = "[" + St + '("]', O = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", gt = Yt + '[")]', this.format(S + O + "-MM-DD[T]HH:mm:ss.SSS" + gt);
          }, typeof Symbol != "undefined" && Symbol.for != null && (un[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          }), un.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, un.toString = function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }, un.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, un.valueOf = function() {
            return this._d.valueOf() - 6e4 * (this._offset || 0);
          }, un.creationData = function() {
            return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
          }, un.eraName = function() {
            var S, O, gt, St = this.localeData().eras();
            for (S = 0, O = St.length; S < O; ++S)
              if (gt = this.clone().startOf("day").valueOf(), St[S].since <= gt && gt <= St[S].until || St[S].until <= gt && gt <= St[S].since) return St[S].name;
            return "";
          }, un.eraNarrow = function() {
            var S, O, gt, St = this.localeData().eras();
            for (S = 0, O = St.length; S < O; ++S)
              if (gt = this.clone().startOf("day").valueOf(), St[S].since <= gt && gt <= St[S].until || St[S].until <= gt && gt <= St[S].since) return St[S].narrow;
            return "";
          }, un.eraAbbr = function() {
            var S, O, gt, St = this.localeData().eras();
            for (S = 0, O = St.length; S < O; ++S)
              if (gt = this.clone().startOf("day").valueOf(), St[S].since <= gt && gt <= St[S].until || St[S].until <= gt && gt <= St[S].since) return St[S].abbr;
            return "";
          }, un.eraYear = function() {
            var S, O, gt, St, Yt = this.localeData().eras();
            for (S = 0, O = Yt.length; S < O; ++S) if (gt = Yt[S].since <= Yt[S].until ? 1 : -1, St = this.clone().startOf("day").valueOf(), Yt[S].since <= St && St <= Yt[S].until || Yt[S].until <= St && St <= Yt[S].since) return (this.year() - d(Yt[S].since).year()) * gt + Yt[S].offset;
            return this.year();
          }, un.year = wn, un.isLeapYear = function() {
            return Ie(this.year());
          }, un.weekYear = function(S) {
            return ld.call(this, S, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
          }, un.isoWeekYear = function(S) {
            return ld.call(this, S, this.isoWeek(), this.isoWeekday(), 1, 4);
          }, un.quarter = un.quarters = function(S) {
            return S == null ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (S - 1) + this.month() % 3);
          }, un.month = ha, un.daysInMonth = function() {
            return ye(this.year(), this.month());
          }, un.week = un.weeks = function(S) {
            var O = this.localeData().week(this);
            return S == null ? O : this.add(7 * (S - O), "d");
          }, un.isoWeek = un.isoWeeks = function(S) {
            var O = Ma(this, 1, 4).week;
            return S == null ? O : this.add(7 * (S - O), "d");
          }, un.weeksInYear = function() {
            var S = this.localeData()._week;
            return ba(this.year(), S.dow, S.doy);
          }, un.weeksInWeekYear = function() {
            var S = this.localeData()._week;
            return ba(this.weekYear(), S.dow, S.doy);
          }, un.isoWeeksInYear = function() {
            return ba(this.year(), 1, 4);
          }, un.isoWeeksInISOWeekYear = function() {
            return ba(this.isoWeekYear(), 1, 4);
          }, un.date = ud, un.day = un.days = function(S) {
            if (!this.isValid()) return S != null ? this : NaN;
            var O = Pn(this, "Day");
            return S != null ? (S = function(gt, St) {
              return typeof gt != "string" ? gt : isNaN(gt) ? typeof (gt = St.weekdaysParse(gt)) == "number" ? gt : null : parseInt(gt, 10);
            }(S, this.localeData()), this.add(S - O, "d")) : O;
          }, un.weekday = function(S) {
            if (!this.isValid()) return S != null ? this : NaN;
            var O = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return S == null ? O : this.add(S - O, "d");
          }, un.isoWeekday = function(S) {
            if (!this.isValid()) return S != null ? this : NaN;
            if (S != null) {
              var O = function(gt, St) {
                return typeof gt == "string" ? St.weekdaysParse(gt) % 7 || 7 : isNaN(gt) ? null : gt;
              }(S, this.localeData());
              return this.day(this.day() % 7 ? O : O - 7);
            }
            return this.day() || 7;
          }, un.dayOfYear = function(S) {
            var O = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return S == null ? O : this.add(S - O, "d");
          }, un.hour = un.hours = Ra, un.minute = un.minutes = dd, un.second = un.seconds = gd, un.millisecond = un.milliseconds = Xl, un.utcOffset = function(S, O, gt) {
            var St, Yt = this._offset || 0;
            if (!this.isValid()) return S != null ? this : NaN;
            if (S != null) {
              if (typeof S == "string") {
                if ((S = Cs(an, S)) === null) return this;
              } else Math.abs(S) < 16 && !gt && (S *= 60);
              return !this._isUTC && O && (St = Gl(this)), this._offset = S, this._isUTC = !0, St != null && this.add(St, "m"), Yt !== S && (!O || this._changeInProgress ? Pl(this, Li(S - Yt, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, d.updateOffset(this, !0), this._changeInProgress = null)), this;
            }
            return this._isUTC ? Yt : Gl(this);
          }, un.utc = function(S) {
            return this.utcOffset(0, S);
          }, un.local = function(S) {
            return this._isUTC && (this.utcOffset(0, S), this._isUTC = !1, S && this.subtract(Gl(this), "m")), this;
          }, un.parseZone = function() {
            if (this._tzm != null) this.utcOffset(this._tzm, !1, !0);
            else if (typeof this._i == "string") {
              var S = Cs(me, this._i);
              S != null ? this.utcOffset(S) : this.utcOffset(0, !0);
            }
            return this;
          }, un.hasAlignedHourOffset = function(S) {
            return !!this.isValid() && (S = S ? da(S).utcOffset() : 0, (this.utcOffset() - S) % 60 == 0);
          }, un.isDST = function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
          }, un.isLocal = function() {
            return !!this.isValid() && !this._isUTC;
          }, un.isUtcOffset = function() {
            return !!this.isValid() && this._isUTC;
          }, un.isUtc = zl, un.isUTC = zl, un.zoneAbbr = function() {
            return this._isUTC ? "UTC" : "";
          }, un.zoneName = function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }, un.dates = Mt("dates accessor is deprecated. Use date instead.", ud), un.months = Mt("months accessor is deprecated. Use month instead", ha), un.years = Mt("years accessor is deprecated. Use year instead", wn), un.zone = Mt("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(S, O) {
            return S != null ? (typeof S != "string" && (S = -S), this.utcOffset(S, O), this) : -this.utcOffset();
          }), un.isDSTShifted = Mt("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
            if (!n(this._isDSTShifted)) return this._isDSTShifted;
            var S, O = {};
            return zt(O, this), (O = Dr(O))._a ? (S = O._isUTC ? z(O._a) : da(O._a), this._isDSTShifted = this.isValid() && function(gt, St, Yt) {
              var re, fe = Math.min(gt.length, St.length), je = Math.abs(gt.length - St.length), De = 0;
              for (re = 0; re < fe; re++) Hn(gt[re]) !== Hn(St[re]) && De++;
              return De + je;
            }(O._a, S.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
          });
          var ia = ne.prototype;
          function lo(S, O, gt, St) {
            var Yt = Ei(), re = z().set(St, O);
            return Yt[gt](re, S);
          }
          function Uo(S, O, gt) {
            if (o(S) && (O = S, S = void 0), S = S || "", O != null) return lo(S, O, gt, "month");
            var St, Yt = [];
            for (St = 0; St < 12; St++) Yt[St] = lo(S, St, gt, "month");
            return Yt;
          }
          function uo(S, O, gt, St) {
            typeof S == "boolean" ? (o(O) && (gt = O, O = void 0), O = O || "") : (gt = O = S, S = !1, o(O) && (gt = O, O = void 0), O = O || "");
            var Yt, re = Ei(), fe = S ? re._week.dow : 0, je = [];
            if (gt != null) return lo(O, (gt + fe) % 7, St, "day");
            for (Yt = 0; Yt < 7; Yt++) je[Yt] = lo(O, (Yt + fe) % 7, St, "day");
            return je;
          }
          ia.calendar = function(S, O, gt) {
            var St = this._calendar[S] || this._calendar.sameElse;
            return At(St) ? St.call(O, gt) : St;
          }, ia.longDateFormat = function(S) {
            var O = this._longDateFormat[S], gt = this._longDateFormat[S.toUpperCase()];
            return O || !gt ? O : (this._longDateFormat[S] = gt.match(Le).map(function(St) {
              return St === "MMMM" || St === "MM" || St === "DD" || St === "dddd" ? St.slice(1) : St;
            }).join(""), this._longDateFormat[S]);
          }, ia.invalidDate = function() {
            return this._invalidDate;
          }, ia.ordinal = function(S) {
            return this._ordinal.replace("%d", S);
          }, ia.preparse = Wl, ia.postformat = Wl, ia.relativeTime = function(S, O, gt, St) {
            var Yt = this._relativeTime[gt];
            return At(Yt) ? Yt(S, O, gt, St) : Yt.replace(/%d/i, S);
          }, ia.pastFuture = function(S, O) {
            var gt = this._relativeTime[S > 0 ? "future" : "past"];
            return At(gt) ? gt(O) : gt.replace(/%s/i, O);
          }, ia.set = function(S) {
            var O, gt;
            for (gt in S) y(S, gt) && (At(O = S[gt]) ? this[gt] = O : this["_" + gt] = O);
            this._config = S, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
          }, ia.eras = function(S, O) {
            var gt, St, Yt, re = this._eras || Ei("en")._eras;
            for (gt = 0, St = re.length; gt < St; ++gt) switch (typeof re[gt].since == "string" && (Yt = d(re[gt].since).startOf("day"), re[gt].since = Yt.valueOf()), typeof re[gt].until) {
              case "undefined":
                re[gt].until = 1 / 0;
                break;
              case "string":
                Yt = d(re[gt].until).startOf("day").valueOf(), re[gt].until = Yt.valueOf();
            }
            return re;
          }, ia.erasParse = function(S, O, gt) {
            var St, Yt, re, fe, je, De = this.eras();
            for (S = S.toUpperCase(), St = 0, Yt = De.length; St < Yt; ++St) if (re = De[St].name.toUpperCase(), fe = De[St].abbr.toUpperCase(), je = De[St].narrow.toUpperCase(), gt) switch (O) {
              case "N":
              case "NN":
              case "NNN":
                if (fe === S) return De[St];
                break;
              case "NNNN":
                if (re === S) return De[St];
                break;
              case "NNNNN":
                if (je === S) return De[St];
            }
            else if ([re, fe, je].indexOf(S) >= 0) return De[St];
          }, ia.erasConvertYear = function(S, O) {
            var gt = S.since <= S.until ? 1 : -1;
            return O === void 0 ? d(S.since).year() : d(S.since).year() + (O - S.offset) * gt;
          }, ia.erasAbbrRegex = function(S) {
            return y(this, "_erasAbbrRegex") || Kl.call(this), S ? this._erasAbbrRegex : this._erasRegex;
          }, ia.erasNameRegex = function(S) {
            return y(this, "_erasNameRegex") || Kl.call(this), S ? this._erasNameRegex : this._erasRegex;
          }, ia.erasNarrowRegex = function(S) {
            return y(this, "_erasNarrowRegex") || Kl.call(this), S ? this._erasNarrowRegex : this._erasRegex;
          }, ia.months = function(S, O) {
            return S ? m(this._months) ? this._months[S.month()] : this._months[(this._months.isFormat || on).test(O) ? "format" : "standalone"][S.month()] : m(this._months) ? this._months : this._months.standalone;
          }, ia.monthsShort = function(S, O) {
            return S ? m(this._monthsShort) ? this._monthsShort[S.month()] : this._monthsShort[on.test(O) ? "format" : "standalone"][S.month()] : m(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
          }, ia.monthsParse = function(S, O, gt) {
            var St, Yt, re;
            if (this._monthsParseExact) return oa.call(this, S, O, gt);
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), St = 0; St < 12; St++)
              if (Yt = z([2e3, St]), gt && !this._longMonthsParse[St] && (this._longMonthsParse[St] = new RegExp("^" + this.months(Yt, "").replace(".", "") + "$", "i"), this._shortMonthsParse[St] = new RegExp("^" + this.monthsShort(Yt, "").replace(".", "") + "$", "i")), gt || this._monthsParse[St] || (re = "^" + this.months(Yt, "") + "|^" + this.monthsShort(Yt, ""), this._monthsParse[St] = new RegExp(re.replace(".", ""), "i")), gt && O === "MMMM" && this._longMonthsParse[St].test(S) || gt && O === "MMM" && this._shortMonthsParse[St].test(S) || !gt && this._monthsParse[St].test(S)) return St;
          }, ia.monthsRegex = function(S) {
            return this._monthsParseExact ? (y(this, "_monthsRegex") || va.call(this), S ? this._monthsStrictRegex : this._monthsRegex) : (y(this, "_monthsRegex") || (this._monthsRegex = Wn), this._monthsStrictRegex && S ? this._monthsStrictRegex : this._monthsRegex);
          }, ia.monthsShortRegex = function(S) {
            return this._monthsParseExact ? (y(this, "_monthsRegex") || va.call(this), S ? this._monthsShortStrictRegex : this._monthsShortRegex) : (y(this, "_monthsShortRegex") || (this._monthsShortRegex = Dn), this._monthsShortStrictRegex && S ? this._monthsShortStrictRegex : this._monthsShortRegex);
          }, ia.week = function(S) {
            return Ma(S, this._week.dow, this._week.doy).week;
          }, ia.firstDayOfYear = function() {
            return this._week.doy;
          }, ia.firstDayOfWeek = function() {
            return this._week.dow;
          }, ia.weekdays = function(S, O) {
            var gt = m(this._weekdays) ? this._weekdays : this._weekdays[S && S !== !0 && this._weekdays.isFormat.test(O) ? "format" : "standalone"];
            return S === !0 ? Ka(gt, this._week.dow) : S ? gt[S.day()] : gt;
          }, ia.weekdaysMin = function(S) {
            return S === !0 ? Ka(this._weekdaysMin, this._week.dow) : S ? this._weekdaysMin[S.day()] : this._weekdaysMin;
          }, ia.weekdaysShort = function(S) {
            return S === !0 ? Ka(this._weekdaysShort, this._week.dow) : S ? this._weekdaysShort[S.day()] : this._weekdaysShort;
          }, ia.weekdaysParse = function(S, O, gt) {
            var St, Yt, re;
            if (this._weekdaysParseExact) return Fe.call(this, S, O, gt);
            for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), St = 0; St < 7; St++)
              if (Yt = z([2e3, 1]).day(St), gt && !this._fullWeekdaysParse[St] && (this._fullWeekdaysParse[St] = new RegExp("^" + this.weekdays(Yt, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[St] = new RegExp("^" + this.weekdaysShort(Yt, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[St] = new RegExp("^" + this.weekdaysMin(Yt, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[St] || (re = "^" + this.weekdays(Yt, "") + "|^" + this.weekdaysShort(Yt, "") + "|^" + this.weekdaysMin(Yt, ""), this._weekdaysParse[St] = new RegExp(re.replace(".", ""), "i")), gt && O === "dddd" && this._fullWeekdaysParse[St].test(S) || gt && O === "ddd" && this._shortWeekdaysParse[St].test(S) || gt && O === "dd" && this._minWeekdaysParse[St].test(S) || !gt && this._weekdaysParse[St].test(S)) return St;
          }, ia.weekdaysRegex = function(S) {
            return this._weekdaysParseExact ? (y(this, "_weekdaysRegex") || dn.call(this), S ? this._weekdaysStrictRegex : this._weekdaysRegex) : (y(this, "_weekdaysRegex") || (this._weekdaysRegex = Ro), this._weekdaysStrictRegex && S ? this._weekdaysStrictRegex : this._weekdaysRegex);
          }, ia.weekdaysShortRegex = function(S) {
            return this._weekdaysParseExact ? (y(this, "_weekdaysRegex") || dn.call(this), S ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (y(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = cs), this._weekdaysShortStrictRegex && S ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
          }, ia.weekdaysMinRegex = function(S) {
            return this._weekdaysParseExact ? (y(this, "_weekdaysRegex") || dn.call(this), S ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (y(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = to), this._weekdaysMinStrictRegex && S ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
          }, ia.isPM = function(S) {
            return (S + "").toLowerCase().charAt(0) === "p";
          }, ia.meridiem = function(S, O, gt) {
            return S > 11 ? gt ? "pm" : "PM" : gt ? "am" : "AM";
          }, ai("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(S) {
            var O = S % 10;
            return S + (Hn(S % 100 / 10) === 1 ? "th" : O === 1 ? "st" : O === 2 ? "nd" : O === 3 ? "rd" : "th");
          } }), d.lang = Mt("moment.lang is deprecated. Use moment.locale instead.", ai), d.langData = Mt("moment.langData is deprecated. Use moment.localeData instead.", Ei);
          var rr = Math.abs;
          function cd(S, O, gt, St) {
            var Yt = Li(O, gt);
            return S._milliseconds += St * Yt._milliseconds, S._days += St * Yt._days, S._months += St * Yt._months, S._bubble();
          }
          function jl(S) {
            return S < 0 ? Math.floor(S) : Math.ceil(S);
          }
          function Zl(S) {
            return 4800 * S / 146097;
          }
          function Ko(S) {
            return 146097 * S / 4800;
          }
          function ci(S) {
            return function() {
              return this.as(S);
            };
          }
          var md = ci("ms"), fd = ci("s"), yc = ci("m"), hd = ci("h"), Ac = ci("d"), _c = ci("w"), bc = ci("M"), Jl = ci("Q"), Sc = ci("y"), pd = md;
          function Jr(S) {
            return function() {
              return this.isValid() ? this._data[S] : NaN;
            };
          }
          var go = Jr("milliseconds"), Ql = Jr("seconds"), Id = Jr("minutes"), Vo = Jr("hours"), Cd = Jr("days"), wc = Jr("months"), yd = Jr("years"), Ar = Math.round, Qr = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
          function ql(S, O, gt, St, Yt) {
            return Yt.relativeTime(O || 1, !!gt, S, St);
          }
          var $l = Math.abs;
          function qr(S) {
            return (S > 0) - (S < 0) || +S;
          }
          function Xo() {
            if (!this.isValid()) return this.localeData().invalidDate();
            var S, O, gt, St, Yt, re, fe, je, De = $l(this._milliseconds) / 1e3, bn = $l(this._days), Un = $l(this._months), Kn = this.asSeconds();
            return Kn ? (S = Aa(De / 60), O = Aa(S / 60), De %= 60, S %= 60, gt = Aa(Un / 12), Un %= 12, St = De ? De.toFixed(3).replace(/\.?0+$/, "") : "", Yt = Kn < 0 ? "-" : "", re = qr(this._months) !== qr(Kn) ? "-" : "", fe = qr(this._days) !== qr(Kn) ? "-" : "", je = qr(this._milliseconds) !== qr(Kn) ? "-" : "", Yt + "P" + (gt ? re + gt + "Y" : "") + (Un ? re + Un + "M" : "") + (bn ? fe + bn + "D" : "") + (O || S || De ? "T" : "") + (O ? je + O + "H" : "") + (S ? je + S + "M" : "") + (De ? je + St + "S" : "")) : "P0D";
          }
          var aa = Is.prototype;
          return aa.isValid = function() {
            return this._isValid;
          }, aa.abs = function() {
            var S = this._data;
            return this._milliseconds = rr(this._milliseconds), this._days = rr(this._days), this._months = rr(this._months), S.milliseconds = rr(S.milliseconds), S.seconds = rr(S.seconds), S.minutes = rr(S.minutes), S.hours = rr(S.hours), S.months = rr(S.months), S.years = rr(S.years), this;
          }, aa.add = function(S, O) {
            return cd(this, S, O, 1);
          }, aa.subtract = function(S, O) {
            return cd(this, S, O, -1);
          }, aa.as = function(S) {
            if (!this.isValid()) return NaN;
            var O, gt, St = this._milliseconds;
            if ((S = Nt(S)) === "month" || S === "quarter" || S === "year") switch (O = this._days + St / 864e5, gt = this._months + Zl(O), S) {
              case "month":
                return gt;
              case "quarter":
                return gt / 3;
              case "year":
                return gt / 12;
            }
            else switch (O = this._days + Math.round(Ko(this._months)), S) {
              case "week":
                return O / 7 + St / 6048e5;
              case "day":
                return O + St / 864e5;
              case "hour":
                return 24 * O + St / 36e5;
              case "minute":
                return 1440 * O + St / 6e4;
              case "second":
                return 86400 * O + St / 1e3;
              case "millisecond":
                return Math.floor(864e5 * O) + St;
              default:
                throw new Error("Unknown unit " + S);
            }
          }, aa.asMilliseconds = md, aa.asSeconds = fd, aa.asMinutes = yc, aa.asHours = hd, aa.asDays = Ac, aa.asWeeks = _c, aa.asMonths = bc, aa.asQuarters = Jl, aa.asYears = Sc, aa.valueOf = pd, aa._bubble = function() {
            var S, O, gt, St, Yt, re = this._milliseconds, fe = this._days, je = this._months, De = this._data;
            return re >= 0 && fe >= 0 && je >= 0 || re <= 0 && fe <= 0 && je <= 0 || (re += 864e5 * jl(Ko(je) + fe), fe = 0, je = 0), De.milliseconds = re % 1e3, S = Aa(re / 1e3), De.seconds = S % 60, O = Aa(S / 60), De.minutes = O % 60, gt = Aa(O / 60), De.hours = gt % 24, fe += Aa(gt / 24), je += Yt = Aa(Zl(fe)), fe -= jl(Ko(Yt)), St = Aa(je / 12), je %= 12, De.days = fe, De.months = je, De.years = St, this;
          }, aa.clone = function() {
            return Li(this);
          }, aa.get = function(S) {
            return S = Nt(S), this.isValid() ? this[S + "s"]() : NaN;
          }, aa.milliseconds = go, aa.seconds = Ql, aa.minutes = Id, aa.hours = Vo, aa.days = Cd, aa.weeks = function() {
            return Aa(this.days() / 7);
          }, aa.months = wc, aa.years = yd, aa.humanize = function(S, O) {
            if (!this.isValid()) return this.localeData().invalidDate();
            var gt, St, Yt = !1, re = Qr;
            return typeof S == "object" && (O = S, S = !1), typeof S == "boolean" && (Yt = S), typeof O == "object" && (re = Object.assign({}, Qr, O), O.s != null && O.ss == null && (re.ss = O.s - 1)), St = function(fe, je, De, bn) {
              var Un = Li(fe).abs(), Kn = Ar(Un.as("s")), ga = Ar(Un.as("m")), Ea = Ar(Un.as("h")), Na = Ar(Un.as("d")), Vi = Ar(Un.as("M")), xr = Ar(Un.as("w")), tu = Ar(Un.as("y")), Nr = Kn <= De.ss && ["s", Kn] || Kn < De.s && ["ss", Kn] || ga <= 1 && ["m"] || ga < De.m && ["mm", ga] || Ea <= 1 && ["h"] || Ea < De.h && ["hh", Ea] || Na <= 1 && ["d"] || Na < De.d && ["dd", Na];
              return De.w != null && (Nr = Nr || xr <= 1 && ["w"] || xr < De.w && ["ww", xr]), (Nr = Nr || Vi <= 1 && ["M"] || Vi < De.M && ["MM", Vi] || tu <= 1 && ["y"] || ["yy", tu])[2] = je, Nr[3] = +fe > 0, Nr[4] = bn, ql.apply(null, Nr);
            }(this, !Yt, re, gt = this.localeData()), Yt && (St = gt.pastFuture(+this, St)), gt.postformat(St);
          }, aa.toISOString = Xo, aa.toString = Xo, aa.toJSON = Xo, aa.locale = oo, aa.localeData = zo, aa.toIsoString = Mt("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Xo), aa.lang = qa, _e("X", 0, 0, "unix"), _e("x", 0, 0, "valueOf"), ze("x", Qt), ze("X", /[+-]?\d+(\.\d{1,3})?/), Ee("X", function(S, O, gt) {
            gt._d = new Date(1e3 * parseFloat(S));
          }), Ee("x", function(S, O, gt) {
            gt._d = new Date(Hn(S));
          }), d.version = "2.30.1", B = da, d.fn = un, d.min = function() {
            return ki("isBefore", [].slice.call(arguments, 0));
          }, d.max = function() {
            return ki("isAfter", [].slice.call(arguments, 0));
          }, d.now = function() {
            return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
          }, d.utc = z, d.unix = function(S) {
            return da(1e3 * S);
          }, d.months = function(S, O) {
            return Uo(S, O, "months");
          }, d.isDate = l, d.locale = ai, d.invalid = Q, d.duration = Li, d.isMoment = D, d.weekdays = function(S, O, gt) {
            return uo(S, O, gt, "weekdays");
          }, d.parseZone = function() {
            return da.apply(null, arguments).parseZone();
          }, d.localeData = Ei, d.isDuration = io, d.monthsShort = function(S, O) {
            return Uo(S, O, "monthsShort");
          }, d.weekdaysMin = function(S, O, gt) {
            return uo(S, O, gt, "weekdaysMin");
          }, d.defineLocale = Va, d.updateLocale = function(S, O) {
            if (O != null) {
              var gt, St, Yt = $n;
              xn[S] != null && xn[S].parentLocale != null ? xn[S].set(Ce(xn[S]._config, O)) : ((St = si(S)) != null && (Yt = St._config), O = Ce(Yt, O), St == null && (O.abbr = S), (gt = new ne(O)).parentLocale = xn[S], xn[S] = gt), ai(S);
            } else xn[S] != null && (xn[S].parentLocale != null ? (xn[S] = xn[S].parentLocale, S === ai() && ai(S)) : xn[S] != null && delete xn[S]);
            return xn[S];
          }, d.locales = function() {
            return at(xn);
          }, d.weekdaysShort = function(S, O, gt) {
            return uo(S, O, gt, "weekdaysShort");
          }, d.normalizeUnits = Nt, d.relativeTimeRounding = function(S) {
            return S === void 0 ? Ar : typeof S == "function" && (Ar = S, !0);
          }, d.relativeTimeThreshold = function(S, O) {
            return Qr[S] !== void 0 && (O === void 0 ? Qr[S] : (Qr[S] = O, S === "s" && (Qr.ss = O - 1), !0));
          }, d.calendarFormat = function(S, O) {
            var gt = S.diff(O, "days", !0);
            return gt < -6 ? "sameElse" : gt < -1 ? "lastWeek" : gt < 0 ? "lastDay" : gt < 1 ? "sameDay" : gt < 2 ? "nextDay" : gt < 7 ? "nextWeek" : "sameElse";
          }, d.prototype = un, d.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, d;
        }();
      }, 3282: function(k) {
        function g(c) {
          if (typeof c != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(c));
        }
        function w(c, d) {
          for (var m, b = "", y = 0, T = -1, n = 0, o = 0; o <= c.length; ++o) {
            if (o < c.length) m = c.charCodeAt(o);
            else {
              if (m === 47) break;
              m = 47;
            }
            if (m === 47) {
              if (!(T === o - 1 || n === 1)) if (T !== o - 1 && n === 2) {
                if (b.length < 2 || y !== 2 || b.charCodeAt(b.length - 1) !== 46 || b.charCodeAt(b.length - 2) !== 46) {
                  if (b.length > 2) {
                    var l = b.lastIndexOf("/");
                    if (l !== b.length - 1) {
                      l === -1 ? (b = "", y = 0) : y = (b = b.slice(0, l)).length - 1 - b.lastIndexOf("/"), T = o, n = 0;
                      continue;
                    }
                  } else if (b.length === 2 || b.length === 1) {
                    b = "", y = 0, T = o, n = 0;
                    continue;
                  }
                }
                d && (b.length > 0 ? b += "/.." : b = "..", y = 2);
              } else b.length > 0 ? b += "/" + c.slice(T + 1, o) : b = c.slice(T + 1, o), y = o - T - 1;
              T = o, n = 0;
            } else m === 46 && n !== -1 ? ++n : n = -1;
          }
          return b;
        }
        var B = { resolve: function() {
          for (var c, d = "", m = !1, b = arguments.length - 1; b >= -1 && !m; b--) {
            var y;
            b >= 0 ? y = arguments[b] : (c === void 0 && (c = process.cwd()), y = c), g(y), y.length !== 0 && (d = y + "/" + d, m = y.charCodeAt(0) === 47);
          }
          return d = w(d, !m), m ? d.length > 0 ? "/" + d : "/" : d.length > 0 ? d : ".";
        }, normalize: function(c) {
          if (g(c), c.length === 0) return ".";
          var d = c.charCodeAt(0) === 47, m = c.charCodeAt(c.length - 1) === 47;
          return (c = w(c, !d)).length !== 0 || d || (c = "."), c.length > 0 && m && (c += "/"), d ? "/" + c : c;
        }, isAbsolute: function(c) {
          return g(c), c.length > 0 && c.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0) return ".";
          for (var c, d = 0; d < arguments.length; ++d) {
            var m = arguments[d];
            g(m), m.length > 0 && (c === void 0 ? c = m : c += "/" + m);
          }
          return c === void 0 ? "." : B.normalize(c);
        }, relative: function(c, d) {
          if (g(c), g(d), c === d || (c = B.resolve(c)) === (d = B.resolve(d))) return "";
          for (var m = 1; m < c.length && c.charCodeAt(m) === 47; ++m) ;
          for (var b = c.length, y = b - m, T = 1; T < d.length && d.charCodeAt(T) === 47; ++T) ;
          for (var n = d.length - T, o = y < n ? y : n, l = -1, h = 0; h <= o; ++h) {
            if (h === o) {
              if (n > o) {
                if (d.charCodeAt(T + h) === 47) return d.slice(T + h + 1);
                if (h === 0) return d.slice(T + h);
              } else y > o && (c.charCodeAt(m + h) === 47 ? l = h : h === 0 && (l = 0));
              break;
            }
            var p = c.charCodeAt(m + h);
            if (p !== d.charCodeAt(T + h)) break;
            p === 47 && (l = h);
          }
          var z = "";
          for (h = m + l + 1; h <= b; ++h) h !== b && c.charCodeAt(h) !== 47 || (z.length === 0 ? z += ".." : z += "/..");
          return z.length > 0 ? z + d.slice(T + l) : (T += l, d.charCodeAt(T) === 47 && ++T, d.slice(T));
        }, _makeLong: function(c) {
          return c;
        }, dirname: function(c) {
          if (g(c), c.length === 0) return ".";
          for (var d = c.charCodeAt(0), m = d === 47, b = -1, y = !0, T = c.length - 1; T >= 1; --T) if ((d = c.charCodeAt(T)) === 47) {
            if (!y) {
              b = T;
              break;
            }
          } else y = !1;
          return b === -1 ? m ? "/" : "." : m && b === 1 ? "//" : c.slice(0, b);
        }, basename: function(c, d) {
          if (d !== void 0 && typeof d != "string") throw new TypeError('"ext" argument must be a string');
          g(c);
          var m, b = 0, y = -1, T = !0;
          if (d !== void 0 && d.length > 0 && d.length <= c.length) {
            if (d.length === c.length && d === c) return "";
            var n = d.length - 1, o = -1;
            for (m = c.length - 1; m >= 0; --m) {
              var l = c.charCodeAt(m);
              if (l === 47) {
                if (!T) {
                  b = m + 1;
                  break;
                }
              } else o === -1 && (T = !1, o = m + 1), n >= 0 && (l === d.charCodeAt(n) ? --n == -1 && (y = m) : (n = -1, y = o));
            }
            return b === y ? y = o : y === -1 && (y = c.length), c.slice(b, y);
          }
          for (m = c.length - 1; m >= 0; --m) if (c.charCodeAt(m) === 47) {
            if (!T) {
              b = m + 1;
              break;
            }
          } else y === -1 && (T = !1, y = m + 1);
          return y === -1 ? "" : c.slice(b, y);
        }, extname: function(c) {
          g(c);
          for (var d = -1, m = 0, b = -1, y = !0, T = 0, n = c.length - 1; n >= 0; --n) {
            var o = c.charCodeAt(n);
            if (o !== 47) b === -1 && (y = !1, b = n + 1), o === 46 ? d === -1 ? d = n : T !== 1 && (T = 1) : d !== -1 && (T = -1);
            else if (!y) {
              m = n + 1;
              break;
            }
          }
          return d === -1 || b === -1 || T === 0 || T === 1 && d === b - 1 && d === m + 1 ? "" : c.slice(d, b);
        }, format: function(c) {
          if (c === null || typeof c != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof c);
          return function(d, m) {
            var b = m.dir || m.root, y = m.base || (m.name || "") + (m.ext || "");
            return b ? b === m.root ? b + y : b + "/" + y : y;
          }(0, c);
        }, parse: function(c) {
          g(c);
          var d = { root: "", dir: "", base: "", ext: "", name: "" };
          if (c.length === 0) return d;
          var m, b = c.charCodeAt(0), y = b === 47;
          y ? (d.root = "/", m = 1) : m = 0;
          for (var T = -1, n = 0, o = -1, l = !0, h = c.length - 1, p = 0; h >= m; --h) if ((b = c.charCodeAt(h)) !== 47) o === -1 && (l = !1, o = h + 1), b === 46 ? T === -1 ? T = h : p !== 1 && (p = 1) : T !== -1 && (p = -1);
          else if (!l) {
            n = h + 1;
            break;
          }
          return T === -1 || o === -1 || p === 0 || p === 1 && T === o - 1 && T === n + 1 ? o !== -1 && (d.base = d.name = n === 0 && y ? c.slice(1, o) : c.slice(n, o)) : (n === 0 && y ? (d.name = c.slice(1, T), d.base = c.slice(1, o)) : (d.name = c.slice(n, T), d.base = c.slice(n, o)), d.ext = c.slice(T, o)), n > 0 ? d.dir = c.slice(0, n - 1) : y && (d.dir = "/"), d;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        B.posix = B, k.exports = B;
      }, 3515: function(k, g, w) {
        k.exports = c;
        var B = w(9826).EventEmitter;
        function c() {
          B.call(this);
        }
        w(7523)(c, B), c.Readable = w(2762), c.Writable = w(3726), c.Duplex = w(884), c.Transform = w(6756), c.PassThrough = w(1390), c.finished = w(2896), c.pipeline = w(8460), c.Stream = c, c.prototype.pipe = function(d, m) {
          var b = this;
          function y(z) {
            d.writable && d.write(z) === !1 && b.pause && b.pause();
          }
          function T() {
            b.readable && b.resume && b.resume();
          }
          b.on("data", y), d.on("drain", T), d._isStdio || m && m.end === !1 || (b.on("end", o), b.on("close", l));
          var n = !1;
          function o() {
            n || (n = !0, d.end());
          }
          function l() {
            n || (n = !0, typeof d.destroy == "function" && d.destroy());
          }
          function h(z) {
            if (p(), B.listenerCount(this, "error") === 0) throw z;
          }
          function p() {
            b.removeListener("data", y), d.removeListener("drain", T), b.removeListener("end", o), b.removeListener("close", l), b.removeListener("error", h), d.removeListener("error", h), b.removeListener("end", p), b.removeListener("close", p), d.removeListener("close", p);
          }
          return b.on("error", h), d.on("error", h), b.on("end", p), b.on("close", p), d.on("close", p), d.emit("pipe", b), d;
        };
      }, 1602: function(k) {
        var g = {};
        function w(c, d, m) {
          m || (m = Error);
          var b = function(y) {
            var T, n;
            function o(l, h, p) {
              return y.call(this, function(z, Z, V) {
                return typeof d == "string" ? d : d(z, Z, V);
              }(l, h, p)) || this;
            }
            return n = y, (T = o).prototype = Object.create(n.prototype), T.prototype.constructor = T, T.__proto__ = n, o;
          }(m);
          b.prototype.name = m.name, b.prototype.code = c, g[c] = b;
        }
        function B(c, d) {
          if (Array.isArray(c)) {
            var m = c.length;
            return c = c.map(function(b) {
              return String(b);
            }), m > 2 ? "one of ".concat(d, " ").concat(c.slice(0, m - 1).join(", "), ", or ") + c[m - 1] : m === 2 ? "one of ".concat(d, " ").concat(c[0], " or ").concat(c[1]) : "of ".concat(d, " ").concat(c[0]);
          }
          return "of ".concat(d, " ").concat(String(c));
        }
        w("ERR_INVALID_OPT_VALUE", function(c, d) {
          return 'The value "' + d + '" is invalid for option "' + c + '"';
        }, TypeError), w("ERR_INVALID_ARG_TYPE", function(c, d, m) {
          var b, y, T, n, o;
          if (typeof d == "string" && (y = "not ", d.substr(0, 4) === y) ? (b = "must not be", d = d.replace(/^not /, "")) : b = "must be", function(h, p, z) {
            return (z === void 0 || z > h.length) && (z = h.length), h.substring(z - 9, z) === p;
          }(c, " argument")) T = "The ".concat(c, " ").concat(b, " ").concat(B(d, "type"));
          else {
            var l = (typeof o != "number" && (o = 0), o + 1 > (n = c).length || n.indexOf(".", o) === -1 ? "argument" : "property");
            T = 'The "'.concat(c, '" ').concat(l, " ").concat(b, " ").concat(B(d, "type"));
          }
          return T + ". Received type ".concat(typeof m);
        }, TypeError), w("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), w("ERR_METHOD_NOT_IMPLEMENTED", function(c) {
          return "The " + c + " method is not implemented";
        }), w("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), w("ERR_STREAM_DESTROYED", function(c) {
          return "Cannot call " + c + " after a stream was destroyed";
        }), w("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), w("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), w("ERR_STREAM_WRITE_AFTER_END", "write after end"), w("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), w("ERR_UNKNOWN_ENCODING", function(c) {
          return "Unknown encoding: " + c;
        }, TypeError), w("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), k.exports.F = g;
      }, 884: function(k, g, w) {
        var B = Object.keys || function(l) {
          var h = [];
          for (var p in l) h.push(p);
          return h;
        };
        k.exports = T;
        var c = w(2762), d = w(3726);
        w(7523)(T, c);
        for (var m = B(d.prototype), b = 0; b < m.length; b++) {
          var y = m[b];
          T.prototype[y] || (T.prototype[y] = d.prototype[y]);
        }
        function T(l) {
          if (!(this instanceof T)) return new T(l);
          c.call(this, l), d.call(this, l), this.allowHalfOpen = !0, l && (l.readable === !1 && (this.readable = !1), l.writable === !1 && (this.writable = !1), l.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", n)));
        }
        function n() {
          this._writableState.ended || process.nextTick(o, this);
        }
        function o(l) {
          l.end();
        }
        Object.defineProperty(T.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(T.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(T.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(T.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(l) {
          this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = l, this._writableState.destroyed = l);
        } });
      }, 1390: function(k, g, w) {
        k.exports = c;
        var B = w(6756);
        function c(d) {
          if (!(this instanceof c)) return new c(d);
          B.call(this, d);
        }
        w(7523)(c, B), c.prototype._transform = function(d, m, b) {
          b(null, d);
        };
      }, 2762: function(k, g, w) {
        var B;
        k.exports = yt, yt.ReadableState = D, w(9826).EventEmitter;
        var c, d = function(Nt, Ft) {
          return Nt.listeners(Ft).length;
        }, m = w(2611), b = w(44).Buffer, y = (w.g !== void 0 ? w.g : typeof window != "undefined" ? window : typeof self != "undefined" ? self : {}).Uint8Array || function() {
        }, T = w(7199);
        c = T && T.debuglog ? T.debuglog("stream") : function() {
        };
        var n, o, l, h = w(3791), p = w(2410), z = w(1749).getHighWaterMark, Z = w(1602).F, V = Z.ERR_INVALID_ARG_TYPE, Q = Z.ERR_STREAM_PUSH_AFTER_EOF, vt = Z.ERR_METHOD_NOT_IMPLEMENTED, Lt = Z.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        w(7523)(yt, m);
        var zt = p.errorOrDestroy, X = ["error", "close", "destroy", "pause", "resume"];
        function D(Nt, Ft, ve) {
          B = B || w(884), Nt = Nt || {}, typeof ve != "boolean" && (ve = Ft instanceof B), this.objectMode = !!Nt.objectMode, ve && (this.objectMode = this.objectMode || !!Nt.readableObjectMode), this.highWaterMark = z(this, Nt, "readableHighWaterMark", ve), this.buffer = new h(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Nt.emitClose !== !1, this.autoDestroy = !!Nt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Nt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Nt.encoding && (n || (n = w(748).I), this.decoder = new n(Nt.encoding), this.encoding = Nt.encoding);
        }
        function yt(Nt) {
          if (B = B || w(884), !(this instanceof yt)) return new yt(Nt);
          var Ft = this instanceof B;
          this._readableState = new D(Nt, this, Ft), this.readable = !0, Nt && (typeof Nt.read == "function" && (this._read = Nt.read), typeof Nt.destroy == "function" && (this._destroy = Nt.destroy)), m.call(this);
        }
        function Mt(Nt, Ft, ve, q, tt) {
          c("readableAddChunk", Ft);
          var x, U = Nt._readableState;
          if (Ft === null) U.reading = !1, function(pt, lt) {
            if (c("onEofChunk"), !lt.ended) {
              if (lt.decoder) {
                var Gt = lt.decoder.end();
                Gt && Gt.length && (lt.buffer.push(Gt), lt.length += lt.objectMode ? 1 : Gt.length);
              }
              lt.ended = !0, lt.sync ? At(pt) : (lt.needReadable = !1, lt.emittedReadable || (lt.emittedReadable = !0, Ce(pt)));
            }
          }(Nt, U);
          else if (tt || (x = function(pt, lt) {
            var Gt, ee;
            return ee = lt, b.isBuffer(ee) || ee instanceof y || typeof lt == "string" || lt === void 0 || pt.objectMode || (Gt = new V("chunk", ["string", "Buffer", "Uint8Array"], lt)), Gt;
          }(U, Ft)), x) zt(Nt, x);
          else if (U.objectMode || Ft && Ft.length > 0) if (typeof Ft == "string" || U.objectMode || Object.getPrototypeOf(Ft) === b.prototype || (Ft = function(pt) {
            return b.from(pt);
          }(Ft)), q) U.endEmitted ? zt(Nt, new Lt()) : at(Nt, U, Ft, !0);
          else if (U.ended) zt(Nt, new Q());
          else {
            if (U.destroyed) return !1;
            U.reading = !1, U.decoder && !ve ? (Ft = U.decoder.write(Ft), U.objectMode || Ft.length !== 0 ? at(Nt, U, Ft, !1) : ne(Nt, U)) : at(Nt, U, Ft, !1);
          }
          else q || (U.reading = !1, ne(Nt, U));
          return !U.ended && (U.length < U.highWaterMark || U.length === 0);
        }
        function at(Nt, Ft, ve, q) {
          Ft.flowing && Ft.length === 0 && !Ft.sync ? (Ft.awaitDrain = 0, Nt.emit("data", ve)) : (Ft.length += Ft.objectMode ? 1 : ve.length, q ? Ft.buffer.unshift(ve) : Ft.buffer.push(ve), Ft.needReadable && At(Nt)), ne(Nt, Ft);
        }
        Object.defineProperty(yt.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(Nt) {
          this._readableState && (this._readableState.destroyed = Nt);
        } }), yt.prototype.destroy = p.destroy, yt.prototype._undestroy = p.undestroy, yt.prototype._destroy = function(Nt, Ft) {
          Ft(Nt);
        }, yt.prototype.push = function(Nt, Ft) {
          var ve, q = this._readableState;
          return q.objectMode ? ve = !0 : typeof Nt == "string" && ((Ft = Ft || q.defaultEncoding) !== q.encoding && (Nt = b.from(Nt, Ft), Ft = ""), ve = !0), Mt(this, Nt, Ft, !1, ve);
        }, yt.prototype.unshift = function(Nt) {
          return Mt(this, Nt, null, !0, !1);
        }, yt.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        }, yt.prototype.setEncoding = function(Nt) {
          n || (n = w(748).I);
          var Ft = new n(Nt);
          this._readableState.decoder = Ft, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var ve = this._readableState.buffer.head, q = ""; ve !== null; ) q += Ft.write(ve.data), ve = ve.next;
          return this._readableState.buffer.clear(), q !== "" && this._readableState.buffer.push(q), this._readableState.length = q.length, this;
        };
        var Bt = 1073741824;
        function jt(Nt, Ft) {
          return Nt <= 0 || Ft.length === 0 && Ft.ended ? 0 : Ft.objectMode ? 1 : Nt != Nt ? Ft.flowing && Ft.length ? Ft.buffer.head.data.length : Ft.length : (Nt > Ft.highWaterMark && (Ft.highWaterMark = function(ve) {
            return ve >= Bt ? ve = Bt : (ve--, ve |= ve >>> 1, ve |= ve >>> 2, ve |= ve >>> 4, ve |= ve >>> 8, ve |= ve >>> 16, ve++), ve;
          }(Nt)), Nt <= Ft.length ? Nt : Ft.ended ? Ft.length : (Ft.needReadable = !0, 0));
        }
        function At(Nt) {
          var Ft = Nt._readableState;
          c("emitReadable", Ft.needReadable, Ft.emittedReadable), Ft.needReadable = !1, Ft.emittedReadable || (c("emitReadable", Ft.flowing), Ft.emittedReadable = !0, process.nextTick(Ce, Nt));
        }
        function Ce(Nt) {
          var Ft = Nt._readableState;
          c("emitReadable_", Ft.destroyed, Ft.length, Ft.ended), Ft.destroyed || !Ft.length && !Ft.ended || (Nt.emit("readable"), Ft.emittedReadable = !1), Ft.needReadable = !Ft.flowing && !Ft.ended && Ft.length <= Ft.highWaterMark, ln(Nt);
        }
        function ne(Nt, Ft) {
          Ft.readingMore || (Ft.readingMore = !0, process.nextTick(Ht, Nt, Ft));
        }
        function Ht(Nt, Ft) {
          for (; !Ft.reading && !Ft.ended && (Ft.length < Ft.highWaterMark || Ft.flowing && Ft.length === 0); ) {
            var ve = Ft.length;
            if (c("maybeReadMore read 0"), Nt.read(0), ve === Ft.length) break;
          }
          Ft.readingMore = !1;
        }
        function Le(Nt) {
          var Ft = Nt._readableState;
          Ft.readableListening = Nt.listenerCount("readable") > 0, Ft.resumeScheduled && !Ft.paused ? Ft.flowing = !0 : Nt.listenerCount("data") > 0 && Nt.resume();
        }
        function sn(Nt) {
          c("readable nexttick read 0"), Nt.read(0);
        }
        function we(Nt, Ft) {
          c("resume", Ft.reading), Ft.reading || Nt.read(0), Ft.resumeScheduled = !1, Nt.emit("resume"), ln(Nt), Ft.flowing && !Ft.reading && Nt.read(0);
        }
        function ln(Nt) {
          var Ft = Nt._readableState;
          for (c("flow", Ft.flowing); Ft.flowing && Nt.read() !== null; ) ;
        }
        function _e(Nt, Ft) {
          return Ft.length === 0 ? null : (Ft.objectMode ? ve = Ft.buffer.shift() : !Nt || Nt >= Ft.length ? (ve = Ft.decoder ? Ft.buffer.join("") : Ft.buffer.length === 1 ? Ft.buffer.first() : Ft.buffer.concat(Ft.length), Ft.buffer.clear()) : ve = Ft.buffer.consume(Nt, Ft.decoder), ve);
          var ve;
        }
        function Rn(Nt) {
          var Ft = Nt._readableState;
          c("endReadable", Ft.endEmitted), Ft.endEmitted || (Ft.ended = !0, process.nextTick(En, Ft, Nt));
        }
        function En(Nt, Ft) {
          if (c("endReadableNT", Nt.endEmitted, Nt.length), !Nt.endEmitted && Nt.length === 0 && (Nt.endEmitted = !0, Ft.readable = !1, Ft.emit("end"), Nt.autoDestroy)) {
            var ve = Ft._writableState;
            (!ve || ve.autoDestroy && ve.finished) && Ft.destroy();
          }
        }
        function Tn(Nt, Ft) {
          for (var ve = 0, q = Nt.length; ve < q; ve++) if (Nt[ve] === Ft) return ve;
          return -1;
        }
        yt.prototype.read = function(Nt) {
          c("read", Nt), Nt = parseInt(Nt, 10);
          var Ft = this._readableState, ve = Nt;
          if (Nt !== 0 && (Ft.emittedReadable = !1), Nt === 0 && Ft.needReadable && ((Ft.highWaterMark !== 0 ? Ft.length >= Ft.highWaterMark : Ft.length > 0) || Ft.ended)) return c("read: emitReadable", Ft.length, Ft.ended), Ft.length === 0 && Ft.ended ? Rn(this) : At(this), null;
          if ((Nt = jt(Nt, Ft)) === 0 && Ft.ended) return Ft.length === 0 && Rn(this), null;
          var q, tt = Ft.needReadable;
          return c("need readable", tt), (Ft.length === 0 || Ft.length - Nt < Ft.highWaterMark) && c("length less than watermark", tt = !0), Ft.ended || Ft.reading ? c("reading or ended", tt = !1) : tt && (c("do read"), Ft.reading = !0, Ft.sync = !0, Ft.length === 0 && (Ft.needReadable = !0), this._read(Ft.highWaterMark), Ft.sync = !1, Ft.reading || (Nt = jt(ve, Ft))), (q = Nt > 0 ? _e(Nt, Ft) : null) === null ? (Ft.needReadable = Ft.length <= Ft.highWaterMark, Nt = 0) : (Ft.length -= Nt, Ft.awaitDrain = 0), Ft.length === 0 && (Ft.ended || (Ft.needReadable = !0), ve !== Nt && Ft.ended && Rn(this)), q !== null && this.emit("data", q), q;
        }, yt.prototype._read = function(Nt) {
          zt(this, new vt("_read()"));
        }, yt.prototype.pipe = function(Nt, Ft) {
          var ve = this, q = this._readableState;
          switch (q.pipesCount) {
            case 0:
              q.pipes = Nt;
              break;
            case 1:
              q.pipes = [q.pipes, Nt];
              break;
            default:
              q.pipes.push(Nt);
          }
          q.pipesCount += 1, c("pipe count=%d opts=%j", q.pipesCount, Ft);
          var tt = Ft && Ft.end === !1 || Nt === process.stdout || Nt === process.stderr ? Jt : x;
          function x() {
            c("onend"), Nt.end();
          }
          q.endEmitted ? process.nextTick(tt) : ve.once("end", tt), Nt.on("unpipe", function Ot(Kt, ae) {
            c("onunpipe"), Kt === ve && ae && ae.hasUnpiped === !1 && (ae.hasUnpiped = !0, c("cleanup"), Nt.removeListener("close", ee), Nt.removeListener("finish", Vt), Nt.removeListener("drain", U), Nt.removeListener("error", Gt), Nt.removeListener("unpipe", Ot), ve.removeListener("end", x), ve.removeListener("end", Jt), ve.removeListener("data", lt), pt = !0, !q.awaitDrain || Nt._writableState && !Nt._writableState.needDrain || U());
          });
          var U = /* @__PURE__ */ function(Ot) {
            return function() {
              var Kt = Ot._readableState;
              c("pipeOnDrain", Kt.awaitDrain), Kt.awaitDrain && Kt.awaitDrain--, Kt.awaitDrain === 0 && d(Ot, "data") && (Kt.flowing = !0, ln(Ot));
            };
          }(ve);
          Nt.on("drain", U);
          var pt = !1;
          function lt(Ot) {
            c("ondata");
            var Kt = Nt.write(Ot);
            c("dest.write", Kt), Kt === !1 && ((q.pipesCount === 1 && q.pipes === Nt || q.pipesCount > 1 && Tn(q.pipes, Nt) !== -1) && !pt && (c("false write response, pause", q.awaitDrain), q.awaitDrain++), ve.pause());
          }
          function Gt(Ot) {
            c("onerror", Ot), Jt(), Nt.removeListener("error", Gt), d(Nt, "error") === 0 && zt(Nt, Ot);
          }
          function ee() {
            Nt.removeListener("finish", Vt), Jt();
          }
          function Vt() {
            c("onfinish"), Nt.removeListener("close", ee), Jt();
          }
          function Jt() {
            c("unpipe"), ve.unpipe(Nt);
          }
          return ve.on("data", lt), function(Ot, Kt, ae) {
            if (typeof Ot.prependListener == "function") return Ot.prependListener(Kt, ae);
            Ot._events && Ot._events[Kt] ? Array.isArray(Ot._events[Kt]) ? Ot._events[Kt].unshift(ae) : Ot._events[Kt] = [ae, Ot._events[Kt]] : Ot.on(Kt, ae);
          }(Nt, "error", Gt), Nt.once("close", ee), Nt.once("finish", Vt), Nt.emit("pipe", ve), q.flowing || (c("pipe resume"), ve.resume()), Nt;
        }, yt.prototype.unpipe = function(Nt) {
          var Ft = this._readableState, ve = { hasUnpiped: !1 };
          if (Ft.pipesCount === 0) return this;
          if (Ft.pipesCount === 1) return Nt && Nt !== Ft.pipes || (Nt || (Nt = Ft.pipes), Ft.pipes = null, Ft.pipesCount = 0, Ft.flowing = !1, Nt && Nt.emit("unpipe", this, ve)), this;
          if (!Nt) {
            var q = Ft.pipes, tt = Ft.pipesCount;
            Ft.pipes = null, Ft.pipesCount = 0, Ft.flowing = !1;
            for (var x = 0; x < tt; x++) q[x].emit("unpipe", this, { hasUnpiped: !1 });
            return this;
          }
          var U = Tn(Ft.pipes, Nt);
          return U === -1 || (Ft.pipes.splice(U, 1), Ft.pipesCount -= 1, Ft.pipesCount === 1 && (Ft.pipes = Ft.pipes[0]), Nt.emit("unpipe", this, ve)), this;
        }, yt.prototype.on = function(Nt, Ft) {
          var ve = m.prototype.on.call(this, Nt, Ft), q = this._readableState;
          return Nt === "data" ? (q.readableListening = this.listenerCount("readable") > 0, q.flowing !== !1 && this.resume()) : Nt === "readable" && (q.endEmitted || q.readableListening || (q.readableListening = q.needReadable = !0, q.flowing = !1, q.emittedReadable = !1, c("on readable", q.length, q.reading), q.length ? At(this) : q.reading || process.nextTick(sn, this))), ve;
        }, yt.prototype.addListener = yt.prototype.on, yt.prototype.removeListener = function(Nt, Ft) {
          var ve = m.prototype.removeListener.call(this, Nt, Ft);
          return Nt === "readable" && process.nextTick(Le, this), ve;
        }, yt.prototype.removeAllListeners = function(Nt) {
          var Ft = m.prototype.removeAllListeners.apply(this, arguments);
          return Nt !== "readable" && Nt !== void 0 || process.nextTick(Le, this), Ft;
        }, yt.prototype.resume = function() {
          var Nt = this._readableState;
          return Nt.flowing || (c("resume"), Nt.flowing = !Nt.readableListening, function(Ft, ve) {
            ve.resumeScheduled || (ve.resumeScheduled = !0, process.nextTick(we, Ft, ve));
          }(this, Nt)), Nt.paused = !1, this;
        }, yt.prototype.pause = function() {
          return c("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
        }, yt.prototype.wrap = function(Nt) {
          var Ft = this, ve = this._readableState, q = !1;
          for (var tt in Nt.on("end", function() {
            if (c("wrapped end"), ve.decoder && !ve.ended) {
              var U = ve.decoder.end();
              U && U.length && Ft.push(U);
            }
            Ft.push(null);
          }), Nt.on("data", function(U) {
            c("wrapped data"), ve.decoder && (U = ve.decoder.write(U)), ve.objectMode && U == null || (ve.objectMode || U && U.length) && (Ft.push(U) || (q = !0, Nt.pause()));
          }), Nt) this[tt] === void 0 && typeof Nt[tt] == "function" && (this[tt] = /* @__PURE__ */ function(U) {
            return function() {
              return Nt[U].apply(Nt, arguments);
            };
          }(tt));
          for (var x = 0; x < X.length; x++) Nt.on(X[x], this.emit.bind(this, X[x]));
          return this._read = function(U) {
            c("wrapped _read", U), q && (q = !1, Nt.resume());
          }, this;
        }, typeof Symbol == "function" && (yt.prototype[Symbol.asyncIterator] = function() {
          return o === void 0 && (o = w(5857)), o(this);
        }), Object.defineProperty(yt.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(yt.prototype, "readableBuffer", { enumerable: !1, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(yt.prototype, "readableFlowing", { enumerable: !1, get: function() {
          return this._readableState.flowing;
        }, set: function(Nt) {
          this._readableState && (this._readableState.flowing = Nt);
        } }), yt._fromList = _e, Object.defineProperty(yt.prototype, "readableLength", { enumerable: !1, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (yt.from = function(Nt, Ft) {
          return l === void 0 && (l = w(3411)), l(yt, Nt, Ft);
        });
      }, 6756: function(k, g, w) {
        k.exports = n;
        var B = w(1602).F, c = B.ERR_METHOD_NOT_IMPLEMENTED, d = B.ERR_MULTIPLE_CALLBACK, m = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, b = B.ERR_TRANSFORM_WITH_LENGTH_0, y = w(884);
        function T(h, p) {
          var z = this._transformState;
          z.transforming = !1;
          var Z = z.writecb;
          if (Z === null) return this.emit("error", new d());
          z.writechunk = null, z.writecb = null, p != null && this.push(p), Z(h);
          var V = this._readableState;
          V.reading = !1, (V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
        }
        function n(h) {
          if (!(this instanceof n)) return new n(h);
          y.call(this, h), this._transformState = { afterTransform: T.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, h && (typeof h.transform == "function" && (this._transform = h.transform), typeof h.flush == "function" && (this._flush = h.flush)), this.on("prefinish", o);
        }
        function o() {
          var h = this;
          typeof this._flush != "function" || this._readableState.destroyed ? l(this, null, null) : this._flush(function(p, z) {
            l(h, p, z);
          });
        }
        function l(h, p, z) {
          if (p) return h.emit("error", p);
          if (z != null && h.push(z), h._writableState.length) throw new b();
          if (h._transformState.transforming) throw new m();
          return h.push(null);
        }
        w(7523)(n, y), n.prototype.push = function(h, p) {
          return this._transformState.needTransform = !1, y.prototype.push.call(this, h, p);
        }, n.prototype._transform = function(h, p, z) {
          z(new c("_transform()"));
        }, n.prototype._write = function(h, p, z) {
          var Z = this._transformState;
          if (Z.writecb = z, Z.writechunk = h, Z.writeencoding = p, !Z.transforming) {
            var V = this._readableState;
            (Z.needTransform || V.needReadable || V.length < V.highWaterMark) && this._read(V.highWaterMark);
          }
        }, n.prototype._read = function(h) {
          var p = this._transformState;
          p.writechunk === null || p.transforming ? p.needTransform = !0 : (p.transforming = !0, this._transform(p.writechunk, p.writeencoding, p.afterTransform));
        }, n.prototype._destroy = function(h, p) {
          y.prototype._destroy.call(this, h, function(z) {
            p(z);
          });
        };
      }, 3726: function(k, g, w) {
        function B(ne) {
          var Ht = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(Le, sn) {
              var we = Le.entry;
              for (Le.entry = null; we; ) {
                var ln = we.callback;
                sn.pendingcb--, ln(void 0), we = we.next;
              }
              sn.corkedRequestsFree.next = Le;
            })(Ht, ne);
          };
        }
        var c;
        k.exports = yt, yt.WritableState = D;
        var d, m = { deprecate: w(9e3) }, b = w(2611), y = w(44).Buffer, T = (w.g !== void 0 ? w.g : typeof window != "undefined" ? window : typeof self != "undefined" ? self : {}).Uint8Array || function() {
        }, n = w(2410), o = w(1749).getHighWaterMark, l = w(1602).F, h = l.ERR_INVALID_ARG_TYPE, p = l.ERR_METHOD_NOT_IMPLEMENTED, z = l.ERR_MULTIPLE_CALLBACK, Z = l.ERR_STREAM_CANNOT_PIPE, V = l.ERR_STREAM_DESTROYED, Q = l.ERR_STREAM_NULL_VALUES, vt = l.ERR_STREAM_WRITE_AFTER_END, Lt = l.ERR_UNKNOWN_ENCODING, zt = n.errorOrDestroy;
        function X() {
        }
        function D(ne, Ht, Le) {
          c = c || w(884), ne = ne || {}, typeof Le != "boolean" && (Le = Ht instanceof c), this.objectMode = !!ne.objectMode, Le && (this.objectMode = this.objectMode || !!ne.writableObjectMode), this.highWaterMark = o(this, ne, "writableHighWaterMark", Le), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var sn = ne.decodeStrings === !1;
          this.decodeStrings = !sn, this.defaultEncoding = ne.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(we) {
            (function(ln, _e) {
              var Rn = ln._writableState, En = Rn.sync, Tn = Rn.writecb;
              if (typeof Tn != "function") throw new z();
              if (function(Ft) {
                Ft.writing = !1, Ft.writecb = null, Ft.length -= Ft.writelen, Ft.writelen = 0;
              }(Rn), _e) (function(Ft, ve, q, tt, x) {
                --ve.pendingcb, q ? (process.nextTick(x, tt), process.nextTick(Ce, Ft, ve), Ft._writableState.errorEmitted = !0, zt(Ft, tt)) : (x(tt), Ft._writableState.errorEmitted = !0, zt(Ft, tt), Ce(Ft, ve));
              })(ln, Rn, En, _e, Tn);
              else {
                var Nt = jt(Rn) || ln.destroyed;
                Nt || Rn.corked || Rn.bufferProcessing || !Rn.bufferedRequest || Bt(ln, Rn), En ? process.nextTick(at, ln, Rn, Nt, Tn) : at(ln, Rn, Nt, Tn);
              }
            })(Ht, we);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = ne.emitClose !== !1, this.autoDestroy = !!ne.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
        }
        function yt(ne) {
          var Ht = this instanceof (c = c || w(884));
          if (!Ht && !d.call(yt, this)) return new yt(ne);
          this._writableState = new D(ne, this, Ht), this.writable = !0, ne && (typeof ne.write == "function" && (this._write = ne.write), typeof ne.writev == "function" && (this._writev = ne.writev), typeof ne.destroy == "function" && (this._destroy = ne.destroy), typeof ne.final == "function" && (this._final = ne.final)), b.call(this);
        }
        function Mt(ne, Ht, Le, sn, we, ln, _e) {
          Ht.writelen = sn, Ht.writecb = _e, Ht.writing = !0, Ht.sync = !0, Ht.destroyed ? Ht.onwrite(new V("write")) : Le ? ne._writev(we, Ht.onwrite) : ne._write(we, ln, Ht.onwrite), Ht.sync = !1;
        }
        function at(ne, Ht, Le, sn) {
          Le || function(we, ln) {
            ln.length === 0 && ln.needDrain && (ln.needDrain = !1, we.emit("drain"));
          }(ne, Ht), Ht.pendingcb--, sn(), Ce(ne, Ht);
        }
        function Bt(ne, Ht) {
          Ht.bufferProcessing = !0;
          var Le = Ht.bufferedRequest;
          if (ne._writev && Le && Le.next) {
            var sn = Ht.bufferedRequestCount, we = new Array(sn), ln = Ht.corkedRequestsFree;
            ln.entry = Le;
            for (var _e = 0, Rn = !0; Le; ) we[_e] = Le, Le.isBuf || (Rn = !1), Le = Le.next, _e += 1;
            we.allBuffers = Rn, Mt(ne, Ht, !0, Ht.length, we, "", ln.finish), Ht.pendingcb++, Ht.lastBufferedRequest = null, ln.next ? (Ht.corkedRequestsFree = ln.next, ln.next = null) : Ht.corkedRequestsFree = new B(Ht), Ht.bufferedRequestCount = 0;
          } else {
            for (; Le; ) {
              var En = Le.chunk, Tn = Le.encoding, Nt = Le.callback;
              if (Mt(ne, Ht, !1, Ht.objectMode ? 1 : En.length, En, Tn, Nt), Le = Le.next, Ht.bufferedRequestCount--, Ht.writing) break;
            }
            Le === null && (Ht.lastBufferedRequest = null);
          }
          Ht.bufferedRequest = Le, Ht.bufferProcessing = !1;
        }
        function jt(ne) {
          return ne.ending && ne.length === 0 && ne.bufferedRequest === null && !ne.finished && !ne.writing;
        }
        function At(ne, Ht) {
          ne._final(function(Le) {
            Ht.pendingcb--, Le && zt(ne, Le), Ht.prefinished = !0, ne.emit("prefinish"), Ce(ne, Ht);
          });
        }
        function Ce(ne, Ht) {
          var Le = jt(Ht);
          if (Le && (function(we, ln) {
            ln.prefinished || ln.finalCalled || (typeof we._final != "function" || ln.destroyed ? (ln.prefinished = !0, we.emit("prefinish")) : (ln.pendingcb++, ln.finalCalled = !0, process.nextTick(At, we, ln)));
          }(ne, Ht), Ht.pendingcb === 0 && (Ht.finished = !0, ne.emit("finish"), Ht.autoDestroy))) {
            var sn = ne._readableState;
            (!sn || sn.autoDestroy && sn.endEmitted) && ne.destroy();
          }
          return Le;
        }
        w(7523)(yt, b), D.prototype.getBuffer = function() {
          for (var ne = this.bufferedRequest, Ht = []; ne; ) Ht.push(ne), ne = ne.next;
          return Ht;
        }, function() {
          try {
            Object.defineProperty(D.prototype, "buffer", { get: m.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch (ne) {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (d = Function.prototype[Symbol.hasInstance], Object.defineProperty(yt, Symbol.hasInstance, { value: function(ne) {
          return !!d.call(this, ne) || this === yt && ne && ne._writableState instanceof D;
        } })) : d = function(ne) {
          return ne instanceof this;
        }, yt.prototype.pipe = function() {
          zt(this, new Z());
        }, yt.prototype.write = function(ne, Ht, Le) {
          var sn, we = this._writableState, ln = !1, _e = !we.objectMode && (sn = ne, y.isBuffer(sn) || sn instanceof T);
          return _e && !y.isBuffer(ne) && (ne = function(Rn) {
            return y.from(Rn);
          }(ne)), typeof Ht == "function" && (Le = Ht, Ht = null), _e ? Ht = "buffer" : Ht || (Ht = we.defaultEncoding), typeof Le != "function" && (Le = X), we.ending ? function(Rn, En) {
            var Tn = new vt();
            zt(Rn, Tn), process.nextTick(En, Tn);
          }(this, Le) : (_e || function(Rn, En, Tn, Nt) {
            var Ft;
            return Tn === null ? Ft = new Q() : typeof Tn == "string" || En.objectMode || (Ft = new h("chunk", ["string", "Buffer"], Tn)), !Ft || (zt(Rn, Ft), process.nextTick(Nt, Ft), !1);
          }(this, we, ne, Le)) && (we.pendingcb++, ln = function(Rn, En, Tn, Nt, Ft, ve) {
            if (!Tn) {
              var q = function(pt, lt, Gt) {
                return pt.objectMode || pt.decodeStrings === !1 || typeof lt != "string" || (lt = y.from(lt, Gt)), lt;
              }(En, Nt, Ft);
              Nt !== q && (Tn = !0, Ft = "buffer", Nt = q);
            }
            var tt = En.objectMode ? 1 : Nt.length;
            En.length += tt;
            var x = En.length < En.highWaterMark;
            if (x || (En.needDrain = !0), En.writing || En.corked) {
              var U = En.lastBufferedRequest;
              En.lastBufferedRequest = { chunk: Nt, encoding: Ft, isBuf: Tn, callback: ve, next: null }, U ? U.next = En.lastBufferedRequest : En.bufferedRequest = En.lastBufferedRequest, En.bufferedRequestCount += 1;
            } else Mt(Rn, En, !1, tt, Nt, Ft, ve);
            return x;
          }(this, we, _e, ne, Ht, Le)), ln;
        }, yt.prototype.cork = function() {
          this._writableState.corked++;
        }, yt.prototype.uncork = function() {
          var ne = this._writableState;
          ne.corked && (ne.corked--, ne.writing || ne.corked || ne.bufferProcessing || !ne.bufferedRequest || Bt(this, ne));
        }, yt.prototype.setDefaultEncoding = function(ne) {
          if (typeof ne == "string" && (ne = ne.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ne + "").toLowerCase()) > -1)) throw new Lt(ne);
          return this._writableState.defaultEncoding = ne, this;
        }, Object.defineProperty(yt.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(yt.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), yt.prototype._write = function(ne, Ht, Le) {
          Le(new p("_write()"));
        }, yt.prototype._writev = null, yt.prototype.end = function(ne, Ht, Le) {
          var sn = this._writableState;
          return typeof ne == "function" ? (Le = ne, ne = null, Ht = null) : typeof Ht == "function" && (Le = Ht, Ht = null), ne != null && this.write(ne, Ht), sn.corked && (sn.corked = 1, this.uncork()), sn.ending || function(we, ln, _e) {
            ln.ending = !0, Ce(we, ln), _e && (ln.finished ? process.nextTick(_e) : we.once("finish", _e)), ln.ended = !0, we.writable = !1;
          }(this, sn, Le), this;
        }, Object.defineProperty(yt.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(yt.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(ne) {
          this._writableState && (this._writableState.destroyed = ne);
        } }), yt.prototype.destroy = n.destroy, yt.prototype._undestroy = n.undestroy, yt.prototype._destroy = function(ne, Ht) {
          Ht(ne);
        };
      }, 5857: function(k, g, w) {
        var B;
        function c(Q, vt, Lt) {
          return (vt = function(zt) {
            var X = function(D) {
              if (typeof D != "object" || D === null) return D;
              var yt = D[Symbol.toPrimitive];
              if (yt !== void 0) {
                var Mt = yt.call(D, "string");
                if (typeof Mt != "object") return Mt;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(D);
            }(zt);
            return typeof X == "symbol" ? X : String(X);
          }(vt)) in Q ? Object.defineProperty(Q, vt, { value: Lt, enumerable: !0, configurable: !0, writable: !0 }) : Q[vt] = Lt, Q;
        }
        var d = w(2896), m = Symbol("lastResolve"), b = Symbol("lastReject"), y = Symbol("error"), T = Symbol("ended"), n = Symbol("lastPromise"), o = Symbol("handlePromise"), l = Symbol("stream");
        function h(Q, vt) {
          return { value: Q, done: vt };
        }
        function p(Q) {
          var vt = Q[m];
          if (vt !== null) {
            var Lt = Q[l].read();
            Lt !== null && (Q[n] = null, Q[m] = null, Q[b] = null, vt(h(Lt, !1)));
          }
        }
        function z(Q) {
          process.nextTick(p, Q);
        }
        var Z = Object.getPrototypeOf(function() {
        }), V = Object.setPrototypeOf((c(B = { get stream() {
          return this[l];
        }, next: function() {
          var Q = this, vt = this[y];
          if (vt !== null) return Promise.reject(vt);
          if (this[T]) return Promise.resolve(h(void 0, !0));
          if (this[l].destroyed) return new Promise(function(D, yt) {
            process.nextTick(function() {
              Q[y] ? yt(Q[y]) : D(h(void 0, !0));
            });
          });
          var Lt, zt = this[n];
          if (zt) Lt = new Promise(/* @__PURE__ */ function(D, yt) {
            return function(Mt, at) {
              D.then(function() {
                yt[T] ? Mt(h(void 0, !0)) : yt[o](Mt, at);
              }, at);
            };
          }(zt, this));
          else {
            var X = this[l].read();
            if (X !== null) return Promise.resolve(h(X, !1));
            Lt = new Promise(this[o]);
          }
          return this[n] = Lt, Lt;
        } }, Symbol.asyncIterator, function() {
          return this;
        }), c(B, "return", function() {
          var Q = this;
          return new Promise(function(vt, Lt) {
            Q[l].destroy(null, function(zt) {
              zt ? Lt(zt) : vt(h(void 0, !0));
            });
          });
        }), B), Z);
        k.exports = function(Q) {
          var vt, Lt = Object.create(V, (c(vt = {}, l, { value: Q, writable: !0 }), c(vt, m, { value: null, writable: !0 }), c(vt, b, { value: null, writable: !0 }), c(vt, y, { value: null, writable: !0 }), c(vt, T, { value: Q._readableState.endEmitted, writable: !0 }), c(vt, o, { value: function(zt, X) {
            var D = Lt[l].read();
            D ? (Lt[n] = null, Lt[m] = null, Lt[b] = null, zt(h(D, !1))) : (Lt[m] = zt, Lt[b] = X);
          }, writable: !0 }), vt));
          return Lt[n] = null, d(Q, function(zt) {
            if (zt && zt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var X = Lt[b];
              return X !== null && (Lt[n] = null, Lt[m] = null, Lt[b] = null, X(zt)), void (Lt[y] = zt);
            }
            var D = Lt[m];
            D !== null && (Lt[n] = null, Lt[m] = null, Lt[b] = null, D(h(void 0, !0))), Lt[T] = !0;
          }), Q.on("readable", z.bind(null, Lt)), Lt;
        };
      }, 3791: function(k, g, w) {
        function B(o, l) {
          var h = Object.keys(o);
          if (Object.getOwnPropertySymbols) {
            var p = Object.getOwnPropertySymbols(o);
            l && (p = p.filter(function(z) {
              return Object.getOwnPropertyDescriptor(o, z).enumerable;
            })), h.push.apply(h, p);
          }
          return h;
        }
        function c(o) {
          for (var l = 1; l < arguments.length; l++) {
            var h = arguments[l] != null ? arguments[l] : {};
            l % 2 ? B(Object(h), !0).forEach(function(p) {
              d(o, p, h[p]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(h)) : B(Object(h)).forEach(function(p) {
              Object.defineProperty(o, p, Object.getOwnPropertyDescriptor(h, p));
            });
          }
          return o;
        }
        function d(o, l, h) {
          return (l = b(l)) in o ? Object.defineProperty(o, l, { value: h, enumerable: !0, configurable: !0, writable: !0 }) : o[l] = h, o;
        }
        function m(o, l) {
          for (var h = 0; h < l.length; h++) {
            var p = l[h];
            p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(o, b(p.key), p);
          }
        }
        function b(o) {
          var l = function(h) {
            if (typeof h != "object" || h === null) return h;
            var p = h[Symbol.toPrimitive];
            if (p !== void 0) {
              var z = p.call(h, "string");
              if (typeof z != "object") return z;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(h);
          }(o);
          return typeof l == "symbol" ? l : String(l);
        }
        var y = w(44).Buffer, T = w(3779).inspect, n = T && T.custom || "inspect";
        k.exports = function() {
          function o() {
            (function(p, z) {
              if (!(p instanceof z)) throw new TypeError("Cannot call a class as a function");
            })(this, o), this.head = null, this.tail = null, this.length = 0;
          }
          var l, h;
          return l = o, (h = [{ key: "push", value: function(p) {
            var z = { data: p, next: null };
            this.length > 0 ? this.tail.next = z : this.head = z, this.tail = z, ++this.length;
          } }, { key: "unshift", value: function(p) {
            var z = { data: p, next: this.head };
            this.length === 0 && (this.tail = z), this.head = z, ++this.length;
          } }, { key: "shift", value: function() {
            if (this.length !== 0) {
              var p = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, p;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(p) {
            if (this.length === 0) return "";
            for (var z = this.head, Z = "" + z.data; z = z.next; ) Z += p + z.data;
            return Z;
          } }, { key: "concat", value: function(p) {
            if (this.length === 0) return y.alloc(0);
            for (var z, Z, V, Q = y.allocUnsafe(p >>> 0), vt = this.head, Lt = 0; vt; ) z = vt.data, Z = Q, V = Lt, y.prototype.copy.call(z, Z, V), Lt += vt.data.length, vt = vt.next;
            return Q;
          } }, { key: "consume", value: function(p, z) {
            var Z;
            return p < this.head.data.length ? (Z = this.head.data.slice(0, p), this.head.data = this.head.data.slice(p)) : Z = p === this.head.data.length ? this.shift() : z ? this._getString(p) : this._getBuffer(p), Z;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(p) {
            var z = this.head, Z = 1, V = z.data;
            for (p -= V.length; z = z.next; ) {
              var Q = z.data, vt = p > Q.length ? Q.length : p;
              if (vt === Q.length ? V += Q : V += Q.slice(0, p), (p -= vt) == 0) {
                vt === Q.length ? (++Z, z.next ? this.head = z.next : this.head = this.tail = null) : (this.head = z, z.data = Q.slice(vt));
                break;
              }
              ++Z;
            }
            return this.length -= Z, V;
          } }, { key: "_getBuffer", value: function(p) {
            var z = y.allocUnsafe(p), Z = this.head, V = 1;
            for (Z.data.copy(z), p -= Z.data.length; Z = Z.next; ) {
              var Q = Z.data, vt = p > Q.length ? Q.length : p;
              if (Q.copy(z, z.length - p, 0, vt), (p -= vt) == 0) {
                vt === Q.length ? (++V, Z.next ? this.head = Z.next : this.head = this.tail = null) : (this.head = Z, Z.data = Q.slice(vt));
                break;
              }
              ++V;
            }
            return this.length -= V, z;
          } }, { key: n, value: function(p, z) {
            return T(this, c(c({}, z), {}, { depth: 0, customInspect: !1 }));
          } }]) && m(l.prototype, h), Object.defineProperty(l, "prototype", { writable: !1 }), o;
        }();
      }, 2410: function(k) {
        function g(c, d) {
          B(c, d), w(c);
        }
        function w(c) {
          c._writableState && !c._writableState.emitClose || c._readableState && !c._readableState.emitClose || c.emit("close");
        }
        function B(c, d) {
          c.emit("error", d);
        }
        k.exports = { destroy: function(c, d) {
          var m = this, b = this._readableState && this._readableState.destroyed, y = this._writableState && this._writableState.destroyed;
          return b || y ? (d ? d(c) : c && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(B, this, c)) : process.nextTick(B, this, c)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(c || null, function(T) {
            !d && T ? m._writableState ? m._writableState.errorEmitted ? process.nextTick(w, m) : (m._writableState.errorEmitted = !0, process.nextTick(g, m, T)) : process.nextTick(g, m, T) : d ? (process.nextTick(w, m), d(T)) : process.nextTick(w, m);
          }), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }, errorOrDestroy: function(c, d) {
          var m = c._readableState, b = c._writableState;
          m && m.autoDestroy || b && b.autoDestroy ? c.destroy(d) : c.emit("error", d);
        } };
      }, 2896: function(k, g, w) {
        var B = w(1602).F.ERR_STREAM_PREMATURE_CLOSE;
        function c() {
        }
        k.exports = function d(m, b, y) {
          if (typeof b == "function") return d(m, null, b);
          b || (b = {}), y = /* @__PURE__ */ function(vt) {
            var Lt = !1;
            return function() {
              if (!Lt) {
                Lt = !0;
                for (var zt = arguments.length, X = new Array(zt), D = 0; D < zt; D++) X[D] = arguments[D];
                vt.apply(this, X);
              }
            };
          }(y || c);
          var T = b.readable || b.readable !== !1 && m.readable, n = b.writable || b.writable !== !1 && m.writable, o = function() {
            m.writable || h();
          }, l = m._writableState && m._writableState.finished, h = function() {
            n = !1, l = !0, T || y.call(m);
          }, p = m._readableState && m._readableState.endEmitted, z = function() {
            T = !1, p = !0, n || y.call(m);
          }, Z = function(vt) {
            y.call(m, vt);
          }, V = function() {
            var vt;
            return T && !p ? (m._readableState && m._readableState.ended || (vt = new B()), y.call(m, vt)) : n && !l ? (m._writableState && m._writableState.ended || (vt = new B()), y.call(m, vt)) : void 0;
          }, Q = function() {
            m.req.on("finish", h);
          };
          return function(vt) {
            return vt.setHeader && typeof vt.abort == "function";
          }(m) ? (m.on("complete", h), m.on("abort", V), m.req ? Q() : m.on("request", Q)) : n && !m._writableState && (m.on("end", o), m.on("close", o)), m.on("end", z), m.on("finish", h), b.error !== !1 && m.on("error", Z), m.on("close", V), function() {
            m.removeListener("complete", h), m.removeListener("abort", V), m.removeListener("request", Q), m.req && m.req.removeListener("finish", h), m.removeListener("end", o), m.removeListener("close", o), m.removeListener("finish", h), m.removeListener("end", z), m.removeListener("error", Z), m.removeListener("close", V);
          };
        };
      }, 3411: function(k) {
        k.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, 8460: function(k, g, w) {
        var B, c = w(1602).F, d = c.ERR_MISSING_ARGS, m = c.ERR_STREAM_DESTROYED;
        function b(n) {
          if (n) throw n;
        }
        function y(n) {
          n();
        }
        function T(n, o) {
          return n.pipe(o);
        }
        k.exports = function() {
          for (var n = arguments.length, o = new Array(n), l = 0; l < n; l++) o[l] = arguments[l];
          var h, p = function(Z) {
            return Z.length ? typeof Z[Z.length - 1] != "function" ? b : Z.pop() : b;
          }(o);
          if (Array.isArray(o[0]) && (o = o[0]), o.length < 2) throw new d("streams");
          var z = o.map(function(Z, V) {
            var Q = V < o.length - 1;
            return function(vt, Lt, zt, X) {
              X = /* @__PURE__ */ function(Mt) {
                var at = !1;
                return function() {
                  at || (at = !0, Mt.apply(void 0, arguments));
                };
              }(X);
              var D = !1;
              vt.on("close", function() {
                D = !0;
              }), B === void 0 && (B = w(2896)), B(vt, { readable: Lt, writable: zt }, function(Mt) {
                if (Mt) return X(Mt);
                D = !0, X();
              });
              var yt = !1;
              return function(Mt) {
                if (!D && !yt) return yt = !0, function(at) {
                  return at.setHeader && typeof at.abort == "function";
                }(vt) ? vt.abort() : typeof vt.destroy == "function" ? vt.destroy() : void X(Mt || new m("pipe"));
              };
            }(Z, Q, V > 0, function(vt) {
              h || (h = vt), vt && z.forEach(y), Q || (z.forEach(y), p(h));
            });
          });
          return o.reduce(T);
        };
      }, 1749: function(k, g, w) {
        var B = w(1602).F.ERR_INVALID_OPT_VALUE;
        k.exports = { getHighWaterMark: function(c, d, m, b) {
          var y = function(T, n, o) {
            return T.highWaterMark != null ? T.highWaterMark : n ? T[o] : null;
          }(d, b, m);
          if (y != null) {
            if (!isFinite(y) || Math.floor(y) !== y || y < 0) throw new B(b ? m : "highWaterMark", y);
            return Math.floor(y);
          }
          return c.objectMode ? 16 : 16384;
        } };
      }, 2611: function(k, g, w) {
        k.exports = w(9826).EventEmitter;
      }, 748: function(k, g, w) {
        var B = w(4598).Buffer, c = B.isEncoding || function(p) {
          switch ((p = "" + p) && p.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function d(p) {
          var z;
          switch (this.encoding = function(Z) {
            var V = function(Q) {
              if (!Q) return "utf8";
              for (var vt; ; ) switch (Q) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return Q;
                default:
                  if (vt) return;
                  Q = ("" + Q).toLowerCase(), vt = !0;
              }
            }(Z);
            if (typeof V != "string" && (B.isEncoding === c || !c(Z))) throw new Error("Unknown encoding: " + Z);
            return V || Z;
          }(p), this.encoding) {
            case "utf16le":
              this.text = y, this.end = T, z = 4;
              break;
            case "utf8":
              this.fillLast = b, z = 4;
              break;
            case "base64":
              this.text = n, this.end = o, z = 3;
              break;
            default:
              return this.write = l, void (this.end = h);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(z);
        }
        function m(p) {
          return p <= 127 ? 0 : p >> 5 == 6 ? 2 : p >> 4 == 14 ? 3 : p >> 3 == 30 ? 4 : p >> 6 == 2 ? -1 : -2;
        }
        function b(p) {
          var z = this.lastTotal - this.lastNeed, Z = function(V, Q) {
            if ((192 & Q[0]) != 128) return V.lastNeed = 0, "";
            if (V.lastNeed > 1 && Q.length > 1) {
              if ((192 & Q[1]) != 128) return V.lastNeed = 1, "";
              if (V.lastNeed > 2 && Q.length > 2 && (192 & Q[2]) != 128) return V.lastNeed = 2, "";
            }
          }(this, p);
          return Z !== void 0 ? Z : this.lastNeed <= p.length ? (p.copy(this.lastChar, z, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (p.copy(this.lastChar, z, 0, p.length), void (this.lastNeed -= p.length));
        }
        function y(p, z) {
          if ((p.length - z) % 2 == 0) {
            var Z = p.toString("utf16le", z);
            if (Z) {
              var V = Z.charCodeAt(Z.length - 1);
              if (V >= 55296 && V <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1], Z.slice(0, -1);
            }
            return Z;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = p[p.length - 1], p.toString("utf16le", z, p.length - 1);
        }
        function T(p) {
          var z = p && p.length ? this.write(p) : "";
          if (this.lastNeed) {
            var Z = this.lastTotal - this.lastNeed;
            return z + this.lastChar.toString("utf16le", 0, Z);
          }
          return z;
        }
        function n(p, z) {
          var Z = (p.length - z) % 3;
          return Z === 0 ? p.toString("base64", z) : (this.lastNeed = 3 - Z, this.lastTotal = 3, Z === 1 ? this.lastChar[0] = p[p.length - 1] : (this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1]), p.toString("base64", z, p.length - Z));
        }
        function o(p) {
          var z = p && p.length ? this.write(p) : "";
          return this.lastNeed ? z + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : z;
        }
        function l(p) {
          return p.toString(this.encoding);
        }
        function h(p) {
          return p && p.length ? this.write(p) : "";
        }
        g.I = d, d.prototype.write = function(p) {
          if (p.length === 0) return "";
          var z, Z;
          if (this.lastNeed) {
            if ((z = this.fillLast(p)) === void 0) return "";
            Z = this.lastNeed, this.lastNeed = 0;
          } else Z = 0;
          return Z < p.length ? z ? z + this.text(p, Z) : this.text(p, Z) : z || "";
        }, d.prototype.end = function(p) {
          var z = p && p.length ? this.write(p) : "";
          return this.lastNeed ? z + "" : z;
        }, d.prototype.text = function(p, z) {
          var Z = function(Q, vt, Lt) {
            var zt = vt.length - 1;
            if (zt < Lt) return 0;
            var X = m(vt[zt]);
            return X >= 0 ? (X > 0 && (Q.lastNeed = X - 1), X) : --zt < Lt || X === -2 ? 0 : (X = m(vt[zt])) >= 0 ? (X > 0 && (Q.lastNeed = X - 2), X) : --zt < Lt || X === -2 ? 0 : (X = m(vt[zt])) >= 0 ? (X > 0 && (X === 2 ? X = 0 : Q.lastNeed = X - 3), X) : 0;
          }(this, p, z);
          if (!this.lastNeed) return p.toString("utf8", z);
          this.lastTotal = Z;
          var V = p.length - (Z - this.lastNeed);
          return p.copy(this.lastChar, 0, V), p.toString("utf8", z, V);
        }, d.prototype.fillLast = function(p) {
          if (this.lastNeed <= p.length) return p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, p.length), this.lastNeed -= p.length;
        };
      }, 4598: function(k, g, w) {
        var B = w(44), c = B.Buffer;
        function d(b, y) {
          for (var T in b) y[T] = b[T];
        }
        function m(b, y, T) {
          return c(b, y, T);
        }
        c.from && c.alloc && c.allocUnsafe && c.allocUnsafeSlow ? k.exports = B : (d(B, g), g.Buffer = m), d(c, m), m.from = function(b, y, T) {
          if (typeof b == "number") throw new TypeError("Argument must not be a number");
          return c(b, y, T);
        }, m.alloc = function(b, y, T) {
          if (typeof b != "number") throw new TypeError("Argument must be a number");
          var n = c(b);
          return y !== void 0 ? typeof T == "string" ? n.fill(y, T) : n.fill(y) : n.fill(0), n;
        }, m.allocUnsafe = function(b) {
          if (typeof b != "number") throw new TypeError("Argument must be a number");
          return c(b);
        }, m.allocUnsafeSlow = function(b) {
          if (typeof b != "number") throw new TypeError("Argument must be a number");
          return B.SlowBuffer(b);
        };
      }, 8571: function(k, g, w) {
        var B;
        (function(c, d) {
          var m = "function", b = "undefined", y = "object", T = "string", n = "major", o = "model", l = "name", h = "type", p = "vendor", z = "version", Z = "architecture", V = "console", Q = "mobile", vt = "tablet", Lt = "smarttv", zt = "wearable", X = "embedded", D = "Amazon", yt = "Apple", Mt = "ASUS", at = "BlackBerry", Bt = "Browser", jt = "Chrome", At = "Firefox", Ce = "Google", ne = "Huawei", Ht = "LG", Le = "Microsoft", sn = "Motorola", we = "Opera", ln = "Samsung", _e = "Sharp", Rn = "Sony", En = "Xiaomi", Tn = "Zebra", Nt = "Facebook", Ft = "Chromium OS", ve = "Mac OS", q = function(Kt) {
            for (var ae = {}, Qt = 0; Qt < Kt.length; Qt++) ae[Kt[Qt].toUpperCase()] = Kt[Qt];
            return ae;
          }, tt = function(Kt, ae) {
            return typeof Kt === T && x(ae).indexOf(x(Kt)) !== -1;
          }, x = function(Kt) {
            return Kt.toLowerCase();
          }, U = function(Kt, ae) {
            if (typeof Kt === T) return Kt = Kt.replace(/^\s\s*/, ""), typeof ae === b ? Kt : Kt.substring(0, 500);
          }, pt = function(Kt, ae) {
            for (var Qt, me, an, Ge, Te, ge, ze = 0; ze < ae.length && !Te; ) {
              var Zn = ae[ze], qn = ae[ze + 1];
              for (Qt = me = 0; Qt < Zn.length && !Te && Zn[Qt]; ) if (Te = Zn[Qt++].exec(Kt)) for (an = 0; an < qn.length; an++) ge = Te[++me], typeof (Ge = qn[an]) === y && Ge.length > 0 ? Ge.length === 2 ? typeof Ge[1] == m ? this[Ge[0]] = Ge[1].call(this, ge) : this[Ge[0]] = Ge[1] : Ge.length === 3 ? typeof Ge[1] !== m || Ge[1].exec && Ge[1].test ? this[Ge[0]] = ge ? ge.replace(Ge[1], Ge[2]) : d : this[Ge[0]] = ge ? Ge[1].call(this, ge, Ge[2]) : d : Ge.length === 4 && (this[Ge[0]] = ge ? Ge[3].call(this, ge.replace(Ge[1], Ge[2])) : d) : this[Ge] = ge || d;
              ze += 2;
            }
          }, lt = function(Kt, ae) {
            for (var Qt in ae) if (typeof ae[Qt] === y && ae[Qt].length > 0) {
              for (var me = 0; me < ae[Qt].length; me++) if (tt(ae[Qt][me], Kt)) return Qt === "?" ? d : Qt;
            } else if (tt(ae[Qt], Kt)) return Qt === "?" ? d : Qt;
            return Kt;
          }, Gt = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ee = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [z, [l, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [z, [l, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [l, z], [/opios[\/ ]+([\w\.]+)/i], [z, [l, we + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [z, [l, we + " GX"]], [/\bopr\/([\w\.]+)/i], [z, [l, we]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [z, [l, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [l, z], [/\bddg\/([\w\.]+)/i], [z, [l, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [z, [l, "UC" + Bt]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [z, [l, "WeChat"]], [/konqueror\/([\w\.]+)/i], [z, [l, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [z, [l, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [z, [l, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [z, [l, "Smart Lenovo " + Bt]], [/(avast|avg)\/([\w\.]+)/i], [[l, /(.+)/, "$1 Secure " + Bt], z], [/\bfocus\/([\w\.]+)/i], [z, [l, At + " Focus"]], [/\bopt\/([\w\.]+)/i], [z, [l, we + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [z, [l, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [z, [l, "Dolphin"]], [/coast\/([\w\.]+)/i], [z, [l, we + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [z, [l, "MIUI " + Bt]], [/fxios\/([-\w\.]+)/i], [z, [l, At]], [/\bqihu|(qi?ho?o?|360)browser/i], [[l, "360 " + Bt]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[l, /(.+)/, "$1 " + Bt], z], [/samsungbrowser\/([\w\.]+)/i], [z, [l, ln + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[l, /_/g, " "], z], [/metasr[\/ ]?([\d\.]+)/i], [z, [l, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[l, "Sogou Mobile"], z], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [l, z], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [l], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[l, Nt], z], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [l, z], [/\bgsa\/([\w\.]+) .*safari\//i], [z, [l, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [z, [l, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [z, [l, jt + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[l, jt + " WebView"], z], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [z, [l, "Android " + Bt]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [l, z], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [z, [l, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [z, l], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [l, [z, lt, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [l, z], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[l, "Netscape"], z], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [z, [l, At + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [l, z], [/(cobalt)\/([\w\.]+)/i], [l, [z, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[Z, "amd64"]], [/(ia32(?=;))/i], [[Z, x]], [/((?:i[346]|x)86)[;\)]/i], [[Z, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[Z, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[Z, "armhf"]], [/windows (ce|mobile); ppc;/i], [[Z, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[Z, /ower/, "", x]], [/(sun4\w)[;\)]/i], [[Z, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[Z, x]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [o, [p, ln], [h, vt]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [o, [p, ln], [h, Q]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [o, [p, yt], [h, Q]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [o, [p, yt], [h, vt]], [/(macintosh);/i], [o, [p, yt]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [o, [p, _e], [h, Q]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [o, [p, ne], [h, vt]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [o, [p, ne], [h, Q]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[o, /_/g, " "], [p, En], [h, Q]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[o, /_/g, " "], [p, En], [h, vt]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [o, [p, "OPPO"], [h, Q]], [/\b(opd2\d{3}a?) bui/i], [o, [p, "OPPO"], [h, vt]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [o, [p, "Vivo"], [h, Q]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [o, [p, "Realme"], [h, Q]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [o, [p, sn], [h, Q]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [o, [p, sn], [h, vt]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [o, [p, Ht], [h, vt]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [o, [p, Ht], [h, Q]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [o, [p, "Lenovo"], [h, vt]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[o, /_/g, " "], [p, "Nokia"], [h, Q]], [/(pixel c)\b/i], [o, [p, Ce], [h, vt]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [o, [p, Ce], [h, Q]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [o, [p, Rn], [h, Q]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[o, "Xperia Tablet"], [p, Rn], [h, vt]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [o, [p, "OnePlus"], [h, Q]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [o, [p, D], [h, vt]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[o, /(.+)/g, "Fire Phone $1"], [p, D], [h, Q]], [/(playbook);[-\w\),; ]+(rim)/i], [o, p, [h, vt]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [o, [p, at], [h, Q]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [o, [p, Mt], [h, vt]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [o, [p, Mt], [h, Q]], [/(nexus 9)/i], [o, [p, "HTC"], [h, vt]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [p, [o, /_/g, " "], [h, Q]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [o, [p, "Acer"], [h, vt]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [o, [p, "Meizu"], [h, Q]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [o, [p, "Ulefone"], [h, Q]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [p, o, [h, Q]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [p, o, [h, vt]], [/(surface duo)/i], [o, [p, Le], [h, vt]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [o, [p, "Fairphone"], [h, Q]], [/(u304aa)/i], [o, [p, "AT&T"], [h, Q]], [/\bsie-(\w*)/i], [o, [p, "Siemens"], [h, Q]], [/\b(rct\w+) b/i], [o, [p, "RCA"], [h, vt]], [/\b(venue[\d ]{2,7}) b/i], [o, [p, "Dell"], [h, vt]], [/\b(q(?:mv|ta)\w+) b/i], [o, [p, "Verizon"], [h, vt]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [o, [p, "Barnes & Noble"], [h, vt]], [/\b(tm\d{3}\w+) b/i], [o, [p, "NuVision"], [h, vt]], [/\b(k88) b/i], [o, [p, "ZTE"], [h, vt]], [/\b(nx\d{3}j) b/i], [o, [p, "ZTE"], [h, Q]], [/\b(gen\d{3}) b.+49h/i], [o, [p, "Swiss"], [h, Q]], [/\b(zur\d{3}) b/i], [o, [p, "Swiss"], [h, vt]], [/\b((zeki)?tb.*\b) b/i], [o, [p, "Zeki"], [h, vt]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[p, "Dragon Touch"], o, [h, vt]], [/\b(ns-?\w{0,9}) b/i], [o, [p, "Insignia"], [h, vt]], [/\b((nxa|next)-?\w{0,9}) b/i], [o, [p, "NextBook"], [h, vt]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[p, "Voice"], o, [h, Q]], [/\b(lvtel\-)?(v1[12]) b/i], [[p, "LvTel"], o, [h, Q]], [/\b(ph-1) /i], [o, [p, "Essential"], [h, Q]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [o, [p, "Envizen"], [h, vt]], [/\b(trio[-\w\. ]+) b/i], [o, [p, "MachSpeed"], [h, vt]], [/\btu_(1491) b/i], [o, [p, "Rotor"], [h, vt]], [/(shield[\w ]+) b/i], [o, [p, "Nvidia"], [h, vt]], [/(sprint) (\w+)/i], [p, o, [h, Q]], [/(kin\.[onetw]{3})/i], [[o, /\./g, " "], [p, Le], [h, Q]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [o, [p, Tn], [h, vt]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [o, [p, Tn], [h, Q]], [/smart-tv.+(samsung)/i], [p, [h, Lt]], [/hbbtv.+maple;(\d+)/i], [[o, /^/, "SmartTV"], [p, ln], [h, Lt]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[p, Ht], [h, Lt]], [/(apple) ?tv/i], [p, [o, yt + " TV"], [h, Lt]], [/crkey/i], [[o, jt + "cast"], [p, Ce], [h, Lt]], [/droid.+aft(\w+)( bui|\))/i], [o, [p, D], [h, Lt]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [o, [p, _e], [h, Lt]], [/(bravia[\w ]+)( bui|\))/i], [o, [p, Rn], [h, Lt]], [/(mitv-\w{5}) bui/i], [o, [p, En], [h, Lt]], [/Hbbtv.*(technisat) (.*);/i], [p, o, [h, Lt]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[p, U], [o, U], [h, Lt]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[h, Lt]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [p, o, [h, V]], [/droid.+; (shield) bui/i], [o, [p, "Nvidia"], [h, V]], [/(playstation [345portablevi]+)/i], [o, [p, Rn], [h, V]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [o, [p, Le], [h, V]], [/((pebble))app/i], [p, o, [h, zt]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [o, [p, yt], [h, zt]], [/droid.+; (glass) \d/i], [o, [p, Ce], [h, zt]], [/droid.+; (wt63?0{2,3})\)/i], [o, [p, Tn], [h, zt]], [/(quest( \d| pro)?)/i], [o, [p, Nt], [h, zt]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [p, [h, X]], [/(aeobc)\b/i], [o, [p, D], [h, X]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [o, [h, Q]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [o, [h, vt]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[h, vt]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[h, Q]], [/(android[-\w\. ]{0,9});.+buil/i], [o, [p, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [z, [l, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [z, [l, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [l, z], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [z, l]], os: [[/microsoft (windows) (vista|xp)/i], [l, z], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [l, [z, lt, Gt]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[z, lt, Gt], [l, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[z, /_/g, "."], [l, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[l, ve], [z, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [z, l], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [l, z], [/\(bb(10);/i], [z, [l, at]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [z, [l, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [z, [l, At + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [z, [l, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [z, [l, "watchOS"]], [/crkey\/([\d\.]+)/i], [z, [l, jt + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[l, Ft], z], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [l, z], [/(sunos) ?([\w\.\d]*)/i], [[l, "Solaris"], z], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [l, z]] }, Vt = function(Kt, ae) {
            if (typeof Kt === y && (ae = Kt, Kt = d), !(this instanceof Vt)) return new Vt(Kt, ae).getResult();
            var Qt = typeof c !== b && c.navigator ? c.navigator : d, me = Kt || (Qt && Qt.userAgent ? Qt.userAgent : ""), an = Qt && Qt.userAgentData ? Qt.userAgentData : d, Ge = ae ? function(ge, ze) {
              var Zn = {};
              for (var qn in ge) ze[qn] && ze[qn].length % 2 == 0 ? Zn[qn] = ze[qn].concat(ge[qn]) : Zn[qn] = ge[qn];
              return Zn;
            }(ee, ae) : ee, Te = Qt && Qt.userAgent == me;
            return this.getBrowser = function() {
              var ge, ze = {};
              return ze[l] = d, ze[z] = d, pt.call(ze, me, Ge.browser), ze[n] = typeof (ge = ze[z]) === T ? ge.replace(/[^\d\.]/g, "").split(".")[0] : d, Te && Qt && Qt.brave && typeof Qt.brave.isBrave == m && (ze[l] = "Brave"), ze;
            }, this.getCPU = function() {
              var ge = {};
              return ge[Z] = d, pt.call(ge, me, Ge.cpu), ge;
            }, this.getDevice = function() {
              var ge = {};
              return ge[p] = d, ge[o] = d, ge[h] = d, pt.call(ge, me, Ge.device), Te && !ge[h] && an && an.mobile && (ge[h] = Q), Te && ge[o] == "Macintosh" && Qt && typeof Qt.standalone !== b && Qt.maxTouchPoints && Qt.maxTouchPoints > 2 && (ge[o] = "iPad", ge[h] = vt), ge;
            }, this.getEngine = function() {
              var ge = {};
              return ge[l] = d, ge[z] = d, pt.call(ge, me, Ge.engine), ge;
            }, this.getOS = function() {
              var ge = {};
              return ge[l] = d, ge[z] = d, pt.call(ge, me, Ge.os), Te && !ge[l] && an && an.platform && an.platform != "Unknown" && (ge[l] = an.platform.replace(/chrome os/i, Ft).replace(/macos/i, ve)), ge;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return me;
            }, this.setUA = function(ge) {
              return me = typeof ge === T && ge.length > 500 ? U(ge, 500) : ge, this;
            }, this.setUA(me), this;
          };
          Vt.VERSION = "1.0.38", Vt.BROWSER = q([l, z, n]), Vt.CPU = q([Z]), Vt.DEVICE = q([o, p, h, V, Q, Lt, vt, zt, X]), Vt.ENGINE = Vt.OS = q([l, z]), typeof g !== b ? (k.exports && (g = k.exports = Vt), g.UAParser = Vt) : w.amdO ? (B = function() {
            return Vt;
          }.call(g, w, g, k)) === d || (k.exports = B) : typeof c !== b && (c.UAParser = Vt);
          var Jt = typeof c !== b && (c.jQuery || c.Zepto);
          if (Jt && !Jt.ua) {
            var Ot = new Vt();
            Jt.ua = Ot.getResult(), Jt.ua.get = function() {
              return Ot.getUA();
            }, Jt.ua.set = function(Kt) {
              Ot.setUA(Kt);
              var ae = Ot.getResult();
              for (var Qt in ae) Jt.ua[Qt] = ae[Qt];
            };
          }
        })(typeof window == "object" ? window : this);
      }, 9e3: function(k, g, w) {
        function B(c) {
          try {
            if (!w.g.localStorage) return !1;
          } catch (m) {
            return !1;
          }
          var d = w.g.localStorage[c];
          return d != null && String(d).toLowerCase() === "true";
        }
        k.exports = function(c, d) {
          if (B("noDeprecation")) return c;
          var m = !1;
          return function() {
            if (!m) {
              if (B("throwDeprecation")) throw new Error(d);
              B("traceDeprecation") ? console.trace(d) : console.warn(d), m = !0;
            }
            return c.apply(this, arguments);
          };
        };
      }, 3779: function() {
      }, 7199: function() {
      }, 5393: function(k, g, w) {
        var B = w(4952), c = w(138), d = w(649), m = w(8986), b = typeof window != "undefined" && window || xy, y = b.dashjs;
        y || (y = b.dashjs = {}), y.MediaPlayer = B.A, y.FactoryMaker = c.A, y.Debug = d.A, y.Version = (0, m.i)();
      }, 649: function(k, g, w) {
        var B = w(8850), c = w(3621), d = w(138);
        function m(y) {
          y = y || {};
          const T = this.context, n = (0, B.A)(T).getInstance(), o = y.settings, l = [];
          let h, p, z, Z;
          function V(yt) {
            return yt && yt.bind ? yt.bind(window.console) : window.console.log.bind(window.console);
          }
          function Q() {
            for (var yt = arguments.length, Mt = new Array(yt), at = 0; at < yt; at++) Mt[at] = arguments[at];
            D(1, this, ...Mt);
          }
          function vt() {
            for (var yt = arguments.length, Mt = new Array(yt), at = 0; at < yt; at++) Mt[at] = arguments[at];
            D(2, this, ...Mt);
          }
          function Lt() {
            for (var yt = arguments.length, Mt = new Array(yt), at = 0; at < yt; at++) Mt[at] = arguments[at];
            D(3, this, ...Mt);
          }
          function zt() {
            for (var yt = arguments.length, Mt = new Array(yt), at = 0; at < yt; at++) Mt[at] = arguments[at];
            D(4, this, ...Mt);
          }
          function X() {
            for (var yt = arguments.length, Mt = new Array(yt), at = 0; at < yt; at++) Mt[at] = arguments[at];
            D(5, this, ...Mt);
          }
          function D(yt, Mt) {
            let at = "", Bt = null;
            p && (Bt = (/* @__PURE__ */ new Date()).getTime(), at += "[" + (Bt - Z) + "]"), z && Mt && Mt.getClassName && (at += "[" + Mt.getClassName() + "]", Mt.getType && (at += "[" + Mt.getType() + "]")), at.length > 0 && (at += " ");
            for (var jt = arguments.length, At = new Array(jt > 2 ? jt - 2 : 0), Ce = 2; Ce < jt; Ce++) At[Ce - 2] = arguments[Ce];
            Array.apply(null, At).forEach(function(ne) {
              at += ne + " ";
            }), l[yt] && o && o.get().debug.logLevel >= yt && l[yt](at), o && o.get().debug.dispatchEvent && n.trigger(c.A.LOG, { message: at, level: yt });
          }
          return h = { getLogger: function(yt) {
            return { fatal: Q.bind(yt), error: vt.bind(yt), warn: Lt.bind(yt), info: zt.bind(yt), debug: X.bind(yt) };
          }, setLogTimestampVisible: function(yt) {
            p = yt;
          }, setCalleeNameVisible: function(yt) {
            z = yt;
          } }, p = !0, z = !0, Z = (/* @__PURE__ */ new Date()).getTime(), typeof window != "undefined" && window.console && (l[1] = V(window.console.error), l[2] = V(window.console.error), l[3] = V(window.console.warn), l[4] = V(window.console.info), l[5] = V(window.console.debug)), h;
        }
        m.__dashjs_factory_name = "Debug";
        const b = d.A.getSingletonFactory(m);
        b.LOG_LEVEL_NONE = 0, b.LOG_LEVEL_FATAL = 1, b.LOG_LEVEL_ERROR = 2, b.LOG_LEVEL_WARNING = 3, b.LOG_LEVEL_INFO = 4, b.LOG_LEVEL_DEBUG = 5, d.A.updateSingletonFactory(m.__dashjs_factory_name, b), g.A = b;
      }, 8850: function(k, g, w) {
        var B = w(138), c = w(1191);
        function d() {
          let b = {};
          function y(l, h, p) {
            let z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, Z = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
            if (!l) throw new Error("event type cannot be null or undefined");
            if (!h || typeof h != "function") throw new Error("listener must be a function: " + h);
            let V = z.priority || 0;
            if (n(l, h, p) >= 0) return;
            b[l] = b[l] || [];
            const Q = { callback: h, scope: p, priority: V, executeOnlyOnce: Z };
            p && p.getStreamId && (Q.streamId = p.getStreamId()), p && p.getType && (Q.mediaType = p.getType()), z && z.mode && (Q.mode = z.mode), b[l].some((vt, Lt) => {
              if (vt && V > vt.priority) return b[l].splice(Lt, 0, Q), !0;
            }) || b[l].push(Q);
          }
          function T(l, h, p) {
            if (!l || !h || !b[l]) return;
            const z = n(l, h, p);
            z < 0 || (b[l][z] = null);
          }
          function n(l, h, p) {
            let z = -1;
            return b[l] && b[l].some((Z, V) => {
              if (Z && Z.callback === h && (!p || p === Z.scope)) return z = V, !0;
            }), z;
          }
          return { on: function(l, h, p) {
            y(l, h, p, arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {});
          }, once: function(l, h, p) {
            y(l, h, p, arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, !0);
          }, off: T, trigger: function(l) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!l || !b[l]) return;
            if (h = h || {}, h.hasOwnProperty("type")) throw new Error("'type' is a reserved word for event dispatching");
            h.type = l, p.streamId && (h.streamId = p.streamId), p.mediaType && (h.mediaType = p.mediaType);
            const z = [];
            b[l].filter((Z) => !(!Z || p.streamId && Z.streamId && Z.streamId !== p.streamId || p.mediaType && Z.mediaType && Z.mediaType !== p.mediaType || p.mode && Z.mode && Z.mode !== p.mode || !Z.mode && p.mode && p.mode === c.A.EVENT_MODE_ON_RECEIVE)).forEach((Z) => {
              Z && Z.callback.call(Z.scope, h), Z.executeOnlyOnce && z.push(Z);
            }), z.forEach((Z) => {
              T(l, Z.callback, Z.scope);
            });
          }, reset: function() {
            b = {};
          } };
        }
        d.__dashjs_factory_name = "EventBus";
        const m = B.A.getSingletonFactory(d);
        m.EVENT_PRIORITY_LOW = 0, m.EVENT_PRIORITY_HIGH = 5e3, B.A.updateSingletonFactory(d.__dashjs_factory_name, m), g.A = m;
      }, 138: function(k, g) {
        const w = function() {
          let B, c = [];
          const d = {}, m = {};
          function b(o, l) {
            for (const h in c) {
              const p = c[h];
              if (p.context === o && p.name === l) return p.instance;
            }
            return null;
          }
          function y(o, l) {
            return l[o];
          }
          function T(o, l, h) {
            o in h && (h[o] = l);
          }
          function n(o, l, h) {
            let p;
            const z = o.__dashjs_factory_name, Z = l[z];
            if (Z) {
              let V = Z.instance;
              if (!Z.override) return V.apply({ context: l, factory: B }, h);
              p = o.apply({ context: l }, h), V = V.apply({ context: l, factory: B, parent: p }, h);
              for (const Q in V) p.hasOwnProperty(Q) && (p[Q] = V[Q]);
            } else p = o.apply({ context: l }, h);
            return p.getClassName = function() {
              return z;
            }, p;
          }
          return B = { extend: function(o, l, h, p) {
            !p[o] && l && (p[o] = { instance: l, override: h });
          }, getSingletonInstance: b, setSingletonInstance: function(o, l, h) {
            for (const p in c) {
              const z = c[p];
              if (z.context === o && z.name === l) return void (c[p].instance = h);
            }
            c.push({ name: l, context: o, instance: h });
          }, deleteSingletonInstances: function(o) {
            c = c.filter((l) => l.context !== o);
          }, getSingletonFactory: function(o) {
            let l = y(o.__dashjs_factory_name, d);
            return l || (l = function(h) {
              let p;
              return h === void 0 && (h = {}), { getInstance: function() {
                return p || (p = b(h, o.__dashjs_factory_name)), p || (p = n(o, h, arguments), c.push({ name: o.__dashjs_factory_name, context: h, instance: p })), p;
              } };
            }, d[o.__dashjs_factory_name] = l), l;
          }, getSingletonFactoryByName: function(o) {
            return y(o, d);
          }, updateSingletonFactory: function(o, l) {
            T(o, l, d);
          }, getClassFactory: function(o) {
            let l = y(o.__dashjs_factory_name, m);
            return l || (l = function(h) {
              return h === void 0 && (h = {}), { create: function() {
                return n(o, h, arguments);
              } };
            }, m[o.__dashjs_factory_name] = l), l;
          }, getClassFactoryByName: function(o) {
            return y(o, m);
          }, updateClassFactory: function(o, l) {
            T(o, l, m);
          } }, B;
        }();
        g.A = w;
      }, 8261: function(k, g, w) {
        var B = w(138), c = w(7263), d = w(649), m = w(5212), b = w(7568), y = w(8850), T = w(3621);
        function n() {
          let l;
          const h = this.context, p = (0, y.A)(h).getInstance(), z = { "streaming.delay.liveDelay": T.A.SETTING_UPDATED_LIVE_DELAY, "streaming.delay.liveDelayFragmentCount": T.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, "streaming.liveCatchup.enabled": T.A.SETTING_UPDATED_CATCHUP_ENABLED, "streaming.liveCatchup.playbackRate.min": T.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, "streaming.liveCatchup.playbackRate.max": T.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, "streaming.abr.rules.throughputRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.bolaRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.insufficientBufferRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.switchHistoryRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.droppedFramesRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.abandonRequestsRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.l2ARule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.loLPRule.active": T.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.maxBitrate.video": T.A.SETTING_UPDATED_MAX_BITRATE, "streaming.abr.maxBitrate.audio": T.A.SETTING_UPDATED_MAX_BITRATE, "streaming.abr.minBitrate.video": T.A.SETTING_UPDATED_MIN_BITRATE, "streaming.abr.minBitrate.audio": T.A.SETTING_UPDATED_MIN_BITRATE }, Z = { debug: { logLevel: d.A.LOG_LEVEL_WARNING, dispatchEvent: !1 }, streaming: { abandonLoadTimeout: 1e4, wallclockTimeUpdateInterval: 100, manifestUpdateRetryInterval: 100, liveUpdateTimeThresholdInMilliseconds: 0, cacheInitSegments: !1, applyServiceDescription: !0, applyProducerReferenceTime: !0, applyContentSteering: !0, enableManifestDurationMismatchFix: !0, parseInbandPrft: !1, enableManifestTimescaleMismatchFix: !1, capabilities: { filterUnsupportedEssentialProperties: !0, supportedEssentialProperties: [{ schemeIdUri: m.A.FONT_DOWNLOAD_DVB_SCHEME }, { schemeIdUri: m.A.COLOUR_PRIMARIES_SCHEME_ID_URI, value: /1|5|6|7/ }, { schemeIdUri: m.A.URL_QUERY_INFO_SCHEME }, { schemeIdUri: m.A.EXT_URL_QUERY_INFO_SCHEME }, { schemeIdUri: m.A.MATRIX_COEFFICIENTS_SCHEME_ID_URI, value: /0|1|5|6/ }, { schemeIdUri: m.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI, value: /1|6|13|14|15/ }, ...m.A.THUMBNAILS_SCHEME_ID_URIS.map((vt) => ({ schemeIdUri: vt }))], useMediaCapabilitiesApi: !0, filterVideoColorimetryEssentialProperties: !1, filterHDRMetadataFormatEssentialProperties: !1 }, events: { eventControllerRefreshDelay: 100, deleteEventMessageDataTimeout: 1e4 }, timeShiftBuffer: { calcFromSegmentTimeline: !1, fallbackToSegmentTimeline: !0 }, metrics: { maxListDepth: 100 }, delay: { liveDelayFragmentCount: NaN, liveDelay: NaN, useSuggestedPresentationDelay: !0 }, protection: { keepProtectionMediaKeys: !1, ignoreEmeEncryptedEvent: !1, detectPlayreadyMessageFormat: !0, ignoreKeyStatuses: !1 }, buffer: { enableSeekDecorrelationFix: !1, fastSwitchEnabled: null, flushBufferAtTrackSwitch: !1, reuseExistingSourceBuffers: !0, bufferPruningInterval: 10, bufferToKeep: 20, bufferTimeAtTopQuality: 30, bufferTimeAtTopQualityLongForm: 60, initialBufferLevel: NaN, bufferTimeDefault: 18, longFormContentDurationThreshold: 600, stallThreshold: 0.3, lowLatencyStallThreshold: 0.3, useAppendWindow: !0, setStallState: !0, avoidCurrentTimeRangePruning: !1, useChangeType: !0, mediaSourceDurationInfinity: !0, resetSourceBuffersForTrackSwitch: !1, syntheticStallEvents: { enabled: !1, ignoreReadyState: !1 } }, gaps: { jumpGaps: !0, jumpLargeGaps: !0, smallGapLimit: 1.5, threshold: 0.3, enableSeekFix: !0, enableStallFix: !1, stallSeek: 0.1 }, utcSynchronization: { enabled: !0, useManifestDateHeaderTimeSource: !0, backgroundAttempts: 2, timeBetweenSyncAttempts: 30, maximumTimeBetweenSyncAttempts: 600, minimumTimeBetweenSyncAttempts: 2, timeBetweenSyncAttemptsAdjustmentFactor: 2, maximumAllowedDrift: 100, enableBackgroundSyncAfterSegmentDownloadError: !0, defaultTimingSource: { scheme: "urn:mpeg:dash:utc:http-xsdate:2014", value: "https://time.akamai.com/?iso&ms" } }, scheduling: { defaultTimeout: 500, lowLatencyTimeout: 0, scheduleWhilePaused: !0 }, text: { defaultEnabled: !0, dispatchForManualRendering: !1, extendSegmentedCues: !0, imsc: { displayForcedOnlyMode: !1, enableRollUp: !0 }, webvtt: { customRenderingEnabled: !1 } }, liveCatchup: { maxDrift: NaN, playbackRate: { min: NaN, max: NaN }, playbackBufferMin: 0.5, enabled: null, mode: m.A.LIVE_CATCHUP_MODE_DEFAULT }, lastBitrateCachingInfo: { enabled: !0, ttl: 36e4 }, lastMediaSettingsCachingInfo: { enabled: !0, ttl: 36e4 }, saveLastMediaSettingsForCurrentStreamingSession: !0, cacheLoadThresholds: { video: 10, audio: 5 }, trackSwitchMode: { audio: m.A.TRACK_SWITCH_MODE_ALWAYS_REPLACE, video: m.A.TRACK_SWITCH_MODE_NEVER_REPLACE, mesh: m.A.TRACK_SWITCH_MODE_NEVER_REPLACE }, ignoreSelectionPriority: !1, prioritizeRoleMain: !0, assumeDefaultRoleAsMain: !0, selectionModeForInitialTrack: m.A.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY, fragmentRequestTimeout: 2e4, fragmentRequestProgressTimeout: -1, manifestRequestTimeout: 1e4, retryIntervals: { [b.G.MPD_TYPE]: 500, [b.G.XLINK_EXPANSION_TYPE]: 500, [b.G.MEDIA_SEGMENT_TYPE]: 1e3, [b.G.INIT_SEGMENT_TYPE]: 1e3, [b.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 1e3, [b.G.INDEX_SEGMENT_TYPE]: 1e3, [b.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE]: 1e3, [b.G.LICENSE]: 1e3, [b.G.OTHER_TYPE]: 1e3, lowLatencyReductionFactor: 10 }, retryAttempts: { [b.G.MPD_TYPE]: 3, [b.G.XLINK_EXPANSION_TYPE]: 1, [b.G.MEDIA_SEGMENT_TYPE]: 3, [b.G.INIT_SEGMENT_TYPE]: 3, [b.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 3, [b.G.INDEX_SEGMENT_TYPE]: 3, [b.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE]: 3, [b.G.LICENSE]: 3, [b.G.OTHER_TYPE]: 3, lowLatencyMultiplyFactor: 5 }, abr: { limitBitrateByPortal: !1, usePixelRatioInLimitBitrateByPortal: !1, enableSupplementalPropertyAdaptationSetSwitching: !0, rules: { throughputRule: { active: !0 }, bolaRule: { active: !0 }, insufficientBufferRule: { active: !0, parameters: { throughputSafetyFactor: 0.7, segmentIgnoreCount: 2 } }, switchHistoryRule: { active: !0, parameters: { sampleSize: 8, switchPercentageThreshold: 0.075 } }, droppedFramesRule: { active: !1, parameters: { minimumSampleSize: 375, droppedFramesPercentageThreshold: 0.15 } }, abandonRequestsRule: { active: !0, parameters: { abandonDurationMultiplier: 1.8, minSegmentDownloadTimeThresholdInMs: 500, minThroughputSamplesThreshold: 6 } }, l2ARule: { active: !1 }, loLPRule: { active: !1 } }, throughput: { averageCalculationMode: m.A.THROUGHPUT_CALCULATION_MODES.EWMA, lowLatencyDownloadTimeCalculationMode: m.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING, useResourceTimingApi: !0, useNetworkInformationApi: { xhr: !1, fetch: !1 }, useDeadTimeLatency: !0, bandwidthSafetyFactor: 0.9, sampleSettings: { live: 3, vod: 4, enableSampleSizeAdjustment: !0, decreaseScale: 0.7, increaseScale: 1.3, maxMeasurementsToKeep: 20, averageLatencySampleAmount: 4 }, ewma: { throughputSlowHalfLifeSeconds: 8, throughputFastHalfLifeSeconds: 3, latencySlowHalfLifeCount: 2, latencyFastHalfLifeCount: 1, weightDownloadTimeMultiplicationFactor: 15e-4 } }, maxBitrate: { audio: -1, video: -1, mesh: -1 }, minBitrate: { audio: -1, video: -1, mesh: -1 }, initialBitrate: { audio: -1, video: -1, mesh: 0 }, autoSwitchBitrate: { audio: !0, video: !0, mesh: !1 } }, cmcd: { applyParametersFromMpd: !0, enabled: !1, sid: null, cid: null, rtp: null, rtpSafetyFactor: 5, mode: m.A.CMCD_MODE_QUERY, enabledKeys: m.A.CMCD_AVAILABLE_KEYS, includeInRequests: ["segment", "mpd"], version: 1 }, cmsd: { enabled: !1, abr: { applyMb: !1, etpWeightRatio: 0 } }, defaultSchemeIdUri: { viewpoint: "", audioChannelConfiguration: "urn:mpeg:mpegB:cicp:ChannelConfiguration", role: "urn:mpeg:dash:role:2011", accessibility: "urn:mpeg:dash:role:2011" } }, errors: { recoverAttempts: { mediaErrorDecode: 5 } } };
          let V = c.A.clone(Z);
          function Q(vt, Lt, zt) {
            for (let X in vt) vt.hasOwnProperty(X) && (Lt.hasOwnProperty(X) ? typeof vt[X] != "object" || vt[X] instanceof RegExp || vt[X] instanceof Array || vt[X] === null ? (Lt[X] = c.A.clone(vt[X]), z[zt + X] && p.trigger(z[zt + X])) : Q(vt[X], Lt[X], zt.slice() + X + ".") : console.error("Settings parameter " + zt + X + " is not supported"));
          }
          return l = { get: function() {
            return V;
          }, update: function(vt) {
            typeof vt == "object" && Q(vt, V, "");
          }, reset: function() {
            V = c.A.clone(Z);
          } }, l;
        }
        n.__dashjs_factory_name = "Settings";
        let o = B.A.getSingletonFactory(n);
        g.A = o;
      }, 7263: function(k, g, w) {
        var B = w(3282), c = w(8571), d = w(5212);
        class m {
          static mixin(y, T, n) {
            let o, l = {};
            if (y) for (let h in T) T.hasOwnProperty(h) && (o = T[h], h in y && (y[h] === o || h in l && l[h] === o) || (typeof y[h] == "object" && y[h] !== null ? y[h] = m.mixin(y[h], o, n) : y[h] = n(o)));
            return y;
          }
          static clone(y) {
            if (!y || typeof y != "object") return y;
            if (y instanceof RegExp) return new RegExp(y);
            let T;
            if (y instanceof Array) {
              T = [];
              for (let n = 0, o = y.length; n < o; ++n) n in y && T.push(m.clone(y[n]));
            } else T = {};
            return m.mixin(T, y, m.clone);
          }
          static addAdditionalQueryParameterToUrl(y, T) {
            try {
              if (!T || T.length === 0) return y;
              let n = y;
              return T.forEach((o) => {
                let { key: l, value: h } = o;
                const p = n.includes("?") ? "&" : "?";
                n += `${p}${encodeURIComponent(l)}=${encodeURIComponent(h)}`;
              }), n;
            } catch (n) {
              return y;
            }
          }
          static removeQueryParameterFromUrl(y, T) {
            if (!y || !T) return y;
            const n = new URL(y), o = new URLSearchParams(n.search);
            if (!o || o.size === 0 || !o.has(T)) return y;
            o.delete(T);
            const l = Array.from(o.entries()).map((p) => {
              let [z, Z] = p;
              return `${z}=${Z}`;
            }).join("&"), h = `${n.origin}${n.pathname}`;
            return l ? `${h}?${l}` : h;
          }
          static parseHttpHeaders(y) {
            let T = {};
            if (!y) return T;
            let n = y.trim().split(`\r
`);
            for (let o = 0, l = n.length; o < l; o++) {
              let h = n[o], p = h.indexOf(": ");
              p > 0 && (T[h.substring(0, p)] = h.substring(p + 2));
            }
            return T;
          }
          static parseQueryParams(y) {
            const T = [], n = new URLSearchParams(y);
            for (const [o, l] of n.entries()) T.push({ key: decodeURIComponent(o), value: decodeURIComponent(l) });
            return T;
          }
          static generateUuid() {
            let y = (/* @__PURE__ */ new Date()).getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(T) {
              const n = (y + 16 * Math.random()) % 16 | 0;
              return y = Math.floor(y / 16), (T == "x" ? n : 3 & n | 8).toString(16);
            });
          }
          static generateHashCode(y) {
            let T = 0;
            if (y.length === 0) return T;
            for (let n = 0; n < y.length; n++) T = (T << 5) - T + y.charCodeAt(n), T |= 0;
            return T;
          }
          static getRelativeUrl(y, T) {
            try {
              const n = new URL(y), o = new URL(T);
              if (n.protocol = o.protocol, n.origin !== o.origin) return T;
              let l = B.relative(n.pathname.substr(0, n.pathname.lastIndexOf("/")), o.pathname.substr(0, o.pathname.lastIndexOf("/")));
              const h = l.length === 0 ? 1 : 0;
              return l += o.pathname.substr(o.pathname.lastIndexOf("/") + h, o.pathname.length - 1), o.pathname.length < l.length ? o.pathname : l;
            } catch (n) {
              return T;
            }
          }
          static getHostFromUrl(y) {
            try {
              return new URL(y).host;
            } catch (T) {
              return null;
            }
          }
          static parseUserAgent() {
            let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            try {
              const T = y === null && typeof navigator != "undefined" ? navigator.userAgent.toLowerCase() : "";
              return (0, c.UAParser)(T);
            } catch (T) {
              return {};
            }
          }
          static stringHasProtocol(y) {
            return /(http(s?)):\/\//i.test(y);
          }
          static bufferSourceToDataView(y) {
            return m.toDataView(y, DataView);
          }
          static bufferSourceToInt8(y) {
            return m.toDataView(y, Uint8Array);
          }
          static uint8ArrayToString(y) {
            return new TextDecoder("utf-8").decode(y);
          }
          static bufferSourceToHex(y) {
            const T = m.bufferSourceToInt8(y);
            let n = "";
            for (let o of T) o = o.toString(16), o.length === 1 && (o = "0" + o), n += o;
            return n;
          }
          static toDataView(y, T) {
            const n = m.getArrayBuffer(y);
            let o = 1;
            "BYTES_PER_ELEMENT" in DataView && (o = DataView.BYTES_PER_ELEMENT);
            const l = ((y.byteOffset || 0) + y.byteLength) / o, h = (y.byteOffset || 0) / o, p = Math.floor(Math.max(0, Math.min(h, l)));
            return new T(n, p, Math.floor(Math.min(p + Math.max(1 / 0, 0), l)) - p);
          }
          static getArrayBuffer(y) {
            return y instanceof ArrayBuffer ? y : y.buffer;
          }
          static getCodecFamily(y) {
            const { base: T, profile: n } = m._getCodecParts(y);
            switch (T) {
              case "mp4a":
                switch (n) {
                  case "69":
                  case "6b":
                  case "40.34":
                    return d.A.CODEC_FAMILIES.MP3;
                  case "66":
                  case "67":
                  case "68":
                  case "40.2":
                  case "40.02":
                  case "40.5":
                  case "40.05":
                  case "40.29":
                  case "40.42":
                    return d.A.CODEC_FAMILIES.AAC;
                  case "a5":
                    return d.A.CODEC_FAMILIES.AC3;
                  case "e6":
                    return d.A.CODEC_FAMILIES.EC3;
                  case "b2":
                    return d.A.CODEC_FAMILIES.DTSX;
                  case "a9":
                    return d.A.CODEC_FAMILIES.DTSC;
                }
                break;
              case "avc1":
              case "avc3":
                return d.A.CODEC_FAMILIES.AVC;
              case "hvc1":
              case "hvc3":
                return d.A.CODEC_FAMILIES.HEVC;
              default:
                return T;
            }
            return T;
          }
          static _getCodecParts(y) {
            const [T, ...n] = y.split(".");
            return { base: T, profile: n.join(".") };
          }
        }
        g.A = m;
      }, 8986: function(k, g, w) {
        w.d(g, { i: function() {
          return c;
        } });
        const B = "5.0.3";
        function c() {
          return B;
        }
      }, 8748: function(k, g) {
        g.A = class {
          extend(w, B) {
            if (!w) return;
            let c = !!B && B.override, d = !!B && B.publicOnly;
            for (const m in w) !w.hasOwnProperty(m) || this[m] && !c || d && w[m].indexOf("public_") === -1 || (this[m] = w[m]);
          }
        };
      }, 5734: function(k, g, w) {
        var B = w(7252);
        class c extends B.A {
          constructor() {
            super(), this.ATTEMPT_BACKGROUND_SYNC = "attemptBackgroundSync", this.BUFFERING_COMPLETED = "bufferingCompleted", this.BUFFER_CLEARED = "bufferCleared", this.BYTES_APPENDED_END_FRAGMENT = "bytesAppendedEndFragment", this.BUFFER_REPLACEMENT_STARTED = "bufferReplacementStarted", this.CHECK_FOR_EXISTENCE_COMPLETED = "checkForExistenceCompleted", this.CMSD_STATIC_HEADER = "cmsdStaticHeader", this.CURRENT_TRACK_CHANGED = "currentTrackChanged", this.DATA_UPDATE_COMPLETED = "dataUpdateCompleted", this.INBAND_EVENTS = "inbandEvents", this.INITIAL_STREAM_SWITCH = "initialStreamSwitch", this.INIT_FRAGMENT_LOADED = "initFragmentLoaded", this.INIT_FRAGMENT_NEEDED = "initFragmentNeeded", this.INTERNAL_MANIFEST_LOADED = "internalManifestLoaded", this.ORIGINAL_MANIFEST_LOADED = "originalManifestLoaded", this.LOADING_COMPLETED = "loadingCompleted", this.LOADING_PROGRESS = "loadingProgress", this.LOADING_DATA_PROGRESS = "loadingDataProgress", this.LOADING_ABANDONED = "loadingAborted", this.MANIFEST_UPDATED = "manifestUpdated", this.MEDIA_FRAGMENT_LOADED = "mediaFragmentLoaded", this.MEDIA_FRAGMENT_NEEDED = "mediaFragmentNeeded", this.MEDIAINFO_UPDATED = "mediaInfoUpdated", this.QUOTA_EXCEEDED = "quotaExceeded", this.SEGMENT_LOCATION_BLACKLIST_ADD = "segmentLocationBlacklistAdd", this.SEGMENT_LOCATION_BLACKLIST_CHANGED = "segmentLocationBlacklistChanged", this.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD = "serviceLocationBlacklistAdd", this.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED = "serviceLocationBlacklistChanged", this.SERVICE_LOCATION_LOCATION_BLACKLIST_ADD = "serviceLocationLocationBlacklistAdd", this.SERVICE_LOCATION_LOCATION_BLACKLIST_CHANGED = "serviceLocationLocationBlacklistChanged", this.SET_FRAGMENTED_TEXT_AFTER_DISABLED = "setFragmentedTextAfterDisabled", this.SET_NON_FRAGMENTED_TEXT = "setNonFragmentedText", this.SOURCE_BUFFER_ERROR = "sourceBufferError", this.STREAMS_COMPOSED = "streamsComposed", this.STREAM_BUFFERING_COMPLETED = "streamBufferingCompleted", this.STREAM_REQUESTING_COMPLETED = "streamRequestingCompleted", this.TEXT_TRACKS_QUEUE_INITIALIZED = "textTracksQueueInitialized", this.TIME_SYNCHRONIZATION_COMPLETED = "timeSynchronizationComplete", this.UPDATE_TIME_SYNC_OFFSET = "updateTimeSyncOffset", this.URL_RESOLUTION_FAILED = "urlResolutionFailed", this.VIDEO_CHUNK_RECEIVED = "videoChunkReceived", this.WALLCLOCK_TIME_UPDATED = "wallclockTimeUpdated", this.XLINK_ELEMENT_LOADED = "xlinkElementLoaded", this.XLINK_READY = "xlinkReady", this.SEEK_TARGET = "seekTarget", this.SETTING_UPDATED_LIVE_DELAY = "settingUpdatedLiveDelay", this.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT = "settingUpdatedLiveDelayFragmentCount", this.SETTING_UPDATED_CATCHUP_ENABLED = "settingUpdatedCatchupEnabled", this.SETTING_UPDATED_PLAYBACK_RATE_MIN = "settingUpdatedPlaybackRateMin", this.SETTING_UPDATED_PLAYBACK_RATE_MAX = "settingUpdatedPlaybackRateMax", this.SETTING_UPDATED_ABR_ACTIVE_RULES = "settingUpdatedAbrActiveRules", this.SETTING_UPDATED_MAX_BITRATE = "settingUpdatedMaxBitrate", this.SETTING_UPDATED_MIN_BITRATE = "settingUpdatedMinBitrate";
          }
        }
        g.A = c;
      }, 3621: function(k, g, w) {
        var B = w(5734);
        class c extends B.A {
        }
        let d = new c();
        g.A = d;
      }, 7252: function(k, g) {
        g.A = class {
          extend(w, B) {
            if (!w) return;
            let c = !!B && B.override, d = !!B && B.publicOnly;
            for (const m in w) !w.hasOwnProperty(m) || this[m] && !c || d && w[m].indexOf("public_") === -1 || (this[m] = w[m]);
          }
        };
      }, 8854: function(k, g) {
        g.A = { ACCESSIBILITY: "Accessibility", ADAPTATION_SET: "AdaptationSet", ADAPTATION_SETS: "adaptationSets", ADAPTATION_SET_SWITCHING_SCHEME_ID_URI: "urn:mpeg:dash:adaptation-set-switching:2016", ADD: "add", ASSET_IDENTIFIER: "AssetIdentifier", AUDIO_CHANNEL_CONFIGURATION: "AudioChannelConfiguration", AUDIO_SAMPLING_RATE: "audioSamplingRate", AVAILABILITY_END_TIME: "availabilityEndTime", AVAILABILITY_START_TIME: "availabilityStartTime", AVAILABILITY_TIME_COMPLETE: "availabilityTimeComplete", AVAILABILITY_TIME_OFFSET: "availabilityTimeOffset", BANDWITH: "bandwidth", BASE_URL: "BaseURL", BITSTREAM_SWITCHING: "BitstreamSwitching", BITSTREAM_SWITCHING_MINUS: "bitstreamSwitching", BYTE_RANGE: "byteRange", CAPTION: "caption", CENC_DEFAULT_KID: "cenc:default_KID", CLIENT_DATA_REPORTING: "ClientDataReporting", CLIENT_REQUIREMENT: "clientRequirement", CMCD_PARAMETERS: "CMCDParameters", CODECS: "codecs", CODEC_PRIVATE_DATA: "codecPrivateData", CODING_DEPENDENCY: "codingDependency", CONTENT_COMPONENT: "ContentComponent", CONTENT_PROTECTION: "ContentProtection", CONTENT_STEERING: "ContentSteering", CONTENT_STEERING_RESPONSE: { VERSION: "VERSION", TTL: "TTL", RELOAD_URI: "RELOAD-URI", PATHWAY_PRIORITY: "PATHWAY-PRIORITY", PATHWAY_CLONES: "PATHWAY-CLONES", BASE_ID: "BASE-ID", ID: "ID", URI_REPLACEMENT: "URI-REPLACEMENT", HOST: "HOST", PARAMS: "PARAMS" }, CONTENT_TYPE: "contentType", DEFAULT_SERVICE_LOCATION: "defaultServiceLocation", DEPENDENCY_ID: "dependencyId", DURATION: "duration", DVB_PRIORITY: "dvb:priority", DVB_WEIGHT: "dvb:weight", DVB_URL: "dvb:url", DVB_MIMETYPE: "dvb:mimeType", DVB_FONTFAMILY: "dvb:fontFamily", DYNAMIC: "dynamic", END_NUMBER: "endNumber", ESSENTIAL_PROPERTY: "EssentialProperty", EVENT: "Event", EVENT_STREAM: "EventStream", FORCED_SUBTITLE: "forced-subtitle", FRAMERATE: "frameRate", FRAME_PACKING: "FramePacking", GROUP_LABEL: "GroupLabel", HEIGHT: "height", ID: "id", INBAND: "inband", INBAND_EVENT_STREAM: "InbandEventStream", INDEX: "index", INDEX_RANGE: "indexRange", INITIALIZATION: "Initialization", INITIALIZATION_MINUS: "initialization", LA_URL: "Laurl", LA_URL_LOWER_CASE: "laurl", LABEL: "Label", LANG: "lang", LOCATION: "Location", MAIN: "main", MAXIMUM_SAP_PERIOD: "maximumSAPPeriod", MAX_PLAYOUT_RATE: "maxPlayoutRate", MAX_SEGMENT_DURATION: "maxSegmentDuration", MAX_SUBSEGMENT_DURATION: "maxSubsegmentDuration", MEDIA: "media", MEDIA_PRESENTATION_DURATION: "mediaPresentationDuration", MEDIA_RANGE: "mediaRange", MEDIA_STREAM_STRUCTURE_ID: "mediaStreamStructureId", METRICS: "Metrics", METRICS_MINUS: "metrics", MIME_TYPE: "mimeType", MINIMUM_UPDATE_PERIOD: "minimumUpdatePeriod", MIN_BUFFER_TIME: "minBufferTime", MP4_PROTECTION_SCHEME: "urn:mpeg:dash:mp4protection:2011", MPD: "MPD", MPD_TYPE: "mpd", MPD_PATCH_TYPE: "mpdpatch", ORIGINAL_MPD_ID: "mpdId", ORIGINAL_PUBLISH_TIME: "originalPublishTime", PATCH_LOCATION: "PatchLocation", PERIOD: "Period", PRESENTATION_TIME: "presentationTime", PRESENTATION_TIME_OFFSET: "presentationTimeOffset", PRO: "pro", PRODUCER_REFERENCE_TIME: "ProducerReferenceTime", PRODUCER_REFERENCE_TIME_TYPE: { ENCODER: "encoder", CAPTURED: "captured", APPLICATION: "application" }, PROFILES: "profiles", PSSH: "pssh", PUBLISH_TIME: "publishTime", QUALITY_RANKING: "qualityRanking", QUERY_BEFORE_START: "queryBeforeStart", QUERY_PART: "$querypart$", RANGE: "range", RATING: "Rating", REF: "ref", REF_ID: "refId", REMOVE: "remove", REPLACE: "replace", REPORTING: "Reporting", REPRESENTATION: "Representation", REPRESENTATION_INDEX: "RepresentationIndex", ROBUSTNESS: "robustness", ROLE: "Role", S: "S", SAR: "sar", SCAN_TYPE: "scanType", SEGMENT_ALIGNMENT: "segmentAlignment", SEGMENT_BASE: "SegmentBase", SEGMENT_LIST: "SegmentList", SEGMENT_PROFILES: "segmentProfiles", SEGMENT_TEMPLATE: "SegmentTemplate", SEGMENT_TIMELINE: "SegmentTimeline", SEGMENT_TYPE: "segment", SEGMENT_URL: "SegmentURL", SERVICE_DESCRIPTION: "ServiceDescription", SERVICE_DESCRIPTION_LATENCY: "Latency", SERVICE_DESCRIPTION_OPERATING_BANDWIDTH: "OperatingBandwidth", SERVICE_DESCRIPTION_OPERATING_QUALITY: "OperatingQuality", SERVICE_DESCRIPTION_PLAYBACK_RATE: "PlaybackRate", SERVICE_DESCRIPTION_SCOPE: "Scope", SERVICE_LOCATION: "serviceLocation", SERVICE_LOCATIONS: "serviceLocations", SOURCE_URL: "sourceURL", START: "start", START_NUMBER: "startNumber", START_WITH_SAP: "startWithSAP", STATIC: "static", STEERING_TYPE: "steering", SUBSET: "Subset", SUBTITLE: "subtitle", SUB_REPRESENTATION: "SubRepresentation", SUB_SEGMENT_ALIGNMENT: "subsegmentAlignment", SUGGESTED_PRESENTATION_DELAY: "suggestedPresentationDelay", SUPPLEMENTAL_PROPERTY: "SupplementalProperty", SUPPLEMENTAL_CODECS: "scte214:supplementalCodecs", TIMESCALE: "timescale", TIMESHIFT_BUFFER_DEPTH: "timeShiftBufferDepth", TTL: "ttl", TYPE: "type", UTC_TIMING: "UTCTiming", VALUE: "value", VIEWPOINT: "Viewpoint", WALL_CLOCK_TIME: "wallClockTime", WIDTH: "width" };
      }, 5717: function(k, g) {
        g.A = class {
          constructor() {
            this.schemeIdUri = "", this.value = "";
          }
        };
      }, 4952: function(k, g, w) {
        w.d(g, { A: function() {
          return zw;
        } });
        class B {
          constructor() {
            this.time = null, this.verboseLevel = 0;
          }
          log(f, C) {
            if (this.verboseLevel >= f) {
              const _ = typeof C == "function" ? C() : C;
              console.log(`${this.time} [${f}] ${_}`);
            }
          }
        }
        class c {
          constructor() {
            this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
          }
          reset() {
            this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
          }
          setStyles(f) {
            const C = ["foreground", "underline", "italics", "background", "flash"];
            for (let _ = 0; _ < C.length; _++) {
              const v = C[_];
              Object.prototype.hasOwnProperty.call(f, v) && (this[v] = f[v]);
            }
          }
          isDefault() {
            return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
          }
          equals(f) {
            return this.foreground === f.foreground && this.underline === f.underline && this.italics === f.italics && this.background === f.background && this.flash === f.flash;
          }
          copy(f) {
            this.foreground = f.foreground, this.underline = f.underline, this.italics = f.italics, this.background = f.background, this.flash = f.flash;
          }
        }
        class d {
          constructor() {
            this.uchar = " ", this.penState = new c();
          }
          reset() {
            this.uchar = " ", this.penState.reset();
          }
          setChar(f, C) {
            this.uchar = f, this.penState.copy(C);
          }
          setPenState(f) {
            this.penState.copy(f);
          }
          equals(f) {
            return this.uchar === f.uchar && this.penState.equals(f.penState);
          }
          copy(f) {
            this.uchar = f.uchar, this.penState.copy(f.penState);
          }
          isEmpty() {
            return this.uchar === " " && this.penState.isDefault();
          }
        }
        const m = 100, b = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, y = function(A) {
          return String.fromCharCode(b[A] || A);
        };
        class T {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new B();
            this.chars = [], this.cueStartTime = null, this.pos = 0, this.currPenState = new c();
            for (let C = 0; C < m; C++) this.chars.push(new d());
            this.logger = f;
          }
          equals(f) {
            for (let C = 0; C < m; C++) if (!this.chars[C].equals(f.chars[C])) return !1;
            return !0;
          }
          copy(f) {
            for (let C = 0; C < m; C++) this.chars[C].copy(f.chars[C]);
          }
          isEmpty() {
            let f = !0;
            for (let C = 0; C < m; C++) if (!this.chars[C].isEmpty()) {
              f = !1;
              break;
            }
            return f;
          }
          setCursor(f) {
            this.pos !== f && (this.pos = f), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > m && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = m);
          }
          moveCursor(f) {
            const C = this.pos + f;
            if (f > 1) for (let _ = this.pos + 1; _ < C + 1; _++) this.chars[_].setPenState(this.currPenState);
            this.setCursor(C);
          }
          backSpace() {
            this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
          }
          insertChar(f) {
            f >= 144 && this.backSpace();
            const C = y(f);
            this.pos >= m ? this.logger.log(0, () => "Cannot insert " + f.toString(16) + " (" + C + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(C, this.currPenState), this.moveCursor(1));
          }
          clearFromPos(f) {
            let C;
            for (C = f; C < m; C++) this.chars[C].reset();
          }
          clear() {
            this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
          }
          clearToEndOfRow() {
            this.clearFromPos(this.pos);
          }
          getTextString() {
            const f = [];
            let C = !0;
            for (let _ = 0; _ < m; _++) {
              const v = this.chars[_].uchar;
              v !== " " && (C = !1), f.push(v);
            }
            return C ? "" : f.join("");
          }
          setPenStyles(f) {
            this.currPenState.setStyles(f), this.chars[this.pos].setPenState(this.currPenState);
          }
        }
        const n = 15;
        class o {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new B();
            this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null;
            for (let C = 0; C < n; C++) this.rows.push(new T(f));
            this.logger = f;
          }
          reset() {
            for (let f = 0; f < n; f++) this.rows[f].clear();
            this.currRow = 14;
          }
          equals(f) {
            let C = !0;
            for (let _ = 0; _ < n; _++) if (!this.rows[_].equals(f.rows[_])) {
              C = !1;
              break;
            }
            return C;
          }
          copy(f) {
            for (let C = 0; C < n; C++) this.rows[C].copy(f.rows[C]);
          }
          isEmpty() {
            let f = !0;
            for (let C = 0; C < n; C++) if (!this.rows[C].isEmpty()) {
              f = !1;
              break;
            }
            return f;
          }
          backSpace() {
            this.rows[this.currRow].backSpace();
          }
          clearToEndOfRow() {
            this.rows[this.currRow].clearToEndOfRow();
          }
          insertChar(f) {
            this.rows[this.currRow].insertChar(f);
          }
          setPen(f) {
            this.rows[this.currRow].setPenStyles(f);
          }
          moveCursor(f) {
            this.rows[this.currRow].moveCursor(f);
          }
          setCursor(f) {
            this.logger.log(2, "setCursor: " + f), this.rows[this.currRow].setCursor(f);
          }
          setPAC(f) {
            this.logger.log(2, () => "pacData = " + JSON.stringify(f));
            let C = f.row - 1;
            if (this.nrRollUpRows && C < this.nrRollUpRows - 1 && (C = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== C) {
              for (let H = 0; H < n; H++) this.rows[H].clear();
              const M = this.currRow + 1 - this.nrRollUpRows, Y = this.lastOutputScreen;
              if (Y) {
                const H = Y.rows[M].cueStartTime, L = this.logger.time;
                if (H !== null && L !== null && H < L) for (let W = 0; W < this.nrRollUpRows; W++) this.rows[C - this.nrRollUpRows + W + 1].copy(Y.rows[M + W]);
              }
            }
            this.currRow = C;
            const _ = this.rows[this.currRow];
            if (f.indent !== null) {
              const M = f.indent, Y = Math.max(M - 1, 0);
              _.setCursor(f.indent), f.color = _.chars[Y].penState.foreground;
            }
            const v = { foreground: f.color, underline: f.underline, italics: f.italics, background: "black", flash: !1 };
            this.setPen(v);
          }
          setBkgData(f) {
            this.logger.log(2, () => "bkgData = " + JSON.stringify(f)), this.backSpace(), this.setPen(f), this.insertChar(32);
          }
          setRollUpRows(f) {
            this.nrRollUpRows = f;
          }
          rollUp() {
            if (this.nrRollUpRows === null) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            this.logger.log(1, () => this.getDisplayText());
            const f = this.currRow + 1 - this.nrRollUpRows, C = this.rows.splice(f, 1)[0];
            C.clear(), this.rows.splice(this.currRow, 0, C), this.logger.log(2, "Rolling up");
          }
          getDisplayText(f) {
            f = f || !1;
            const C = [];
            let _ = "", v = -1;
            for (let M = 0; M < n; M++) {
              const Y = this.rows[M].getTextString();
              Y && (v = M + 1, f ? C.push("Row " + v + ": '" + Y + "'") : C.push(Y.trim()));
            }
            return C.length > 0 && (_ = f ? "[" + C.join(" | ") + "]" : C.join(`
`)), _;
          }
          getTextAndFormat() {
            return this.rows;
          }
        }
        class l {
          constructor(f, C) {
            let _ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new B();
            this.chNr = f, this.outputFilter = C, this.mode = null, this.displayedMemory = new o(_), this.nonDisplayedMemory = new o(_), this.lastOutputScreen = new o(_), this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = _, this.logger.log(2, "new Cea608Channel(" + this.chNr + ")");
          }
          reset() {
            var f, C;
            this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), (C = (f = this.outputFilter) === null || f === void 0 ? void 0 : f.reset) === null || C === void 0 || C.call(f), this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
          }
          setPAC(f) {
            this.writeScreen.setPAC(f);
          }
          setBkgData(f) {
            this.writeScreen.setBkgData(f);
          }
          setMode(f) {
            f !== this.mode && (this.mode = f, this.logger.log(2, () => "MODE=" + f), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.setRollUpRows(null), this.nonDisplayedMemory.setRollUpRows(null)), this.mode = f);
          }
          insertChars(f) {
            for (let _ = 0; _ < f.length; _++) this.writeScreen.insertChar(f[_]);
            const C = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
            this.logger.log(2, () => C + ": " + this.writeScreen.getDisplayText(!0)), this.mode !== "MODE_PAINT-ON" && this.mode !== "MODE_ROLL-UP" || (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
          }
          ccRCL() {
            this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
          }
          ccBS() {
            this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
          }
          ccAOF() {
          }
          ccAON() {
          }
          ccDER() {
            this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
          }
          ccRU(f) {
            this.logger.log(2, "RU(" + f + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(f);
          }
          ccFON() {
            this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
          }
          ccRDC() {
            this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
          }
          ccTR() {
            this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
          }
          ccRTD() {
            this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
          }
          ccEDM() {
            this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
          }
          ccCR() {
            this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
          }
          ccENM() {
            this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
          }
          ccEOC() {
            if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
              const f = this.displayedMemory;
              this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = f, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate(!0);
          }
          ccTO(f) {
            this.logger.log(2, "TO(" + f + ") - Tab Offset"), this.writeScreen.moveCursor(f);
          }
          ccMIDROW(f) {
            const C = { flash: !1 };
            if (C.underline = f % 2 == 1, C.italics = f >= 46, C.italics) C.foreground = "white";
            else {
              const _ = Math.floor(f / 2) - 16, v = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
              C.foreground = v[_];
            }
            this.logger.log(2, "MIDROW: " + JSON.stringify(C)), this.writeScreen.setPen(C);
          }
          outputDataUpdate() {
            let f = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            const C = this.logger.time;
            C !== null && this.outputFilter && (this.cueStartTime !== null || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, C, this.lastOutputScreen), f && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : C) : this.cueStartTime = C, this.lastOutputScreen.copy(this.displayedMemory));
          }
          cueSplitAtTime(f) {
            this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, f, this.displayedMemory), this.cueStartTime = f));
          }
        }
        const h = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
        function p(A, f, C) {
          return C.a === A && C.b === f;
        }
        const z = function(A) {
          const f = [];
          for (let C = 0; C < A.length; C++) f.push(A[C].toString(16));
          return f;
        }, Z = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, V = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, Q = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, vt = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 };
        function Lt(A, f, C) {
          C.a = A, C.b = f;
        }
        class zt {
          constructor(f, C, _) {
            this.currentChannel = 0, this.cmdHistory = { a: null, b: null }, this.lastTime = null;
            const v = this.logger = new B();
            this.channels = [null, new l(f, C, v), new l(f + 1, _, v)];
          }
          addData(f, C) {
            this.lastTime = f, this.logger.time = f;
            for (let _ = 0; _ < C.length; _ += 2) {
              const v = 127 & C[_], M = 127 & C[_ + 1];
              let Y = !1, H = null;
              if (this.lastTime !== null && (f = this.lastTime + 0.5 * _ * 1001 / 3e4, this.logger.time = f), v === 0 && M === 0) continue;
              this.logger.log(3, () => "[" + z([C[_], C[_ + 1]]) + "] -> (" + z([v, M]) + ")");
              const L = this.cmdHistory;
              if (v >= 16 && v <= 31) {
                if (p(v, M, L)) {
                  Lt(null, null, L), this.logger.log(3, () => "Repeated command (" + z([v, M]) + ") is dropped");
                  continue;
                }
                Lt(v, M, this.cmdHistory), Y = this.parseCmd(v, M), Y || (Y = this.parseMidrow(v, M)), Y || (Y = this.parsePAC(v, M)), Y || (Y = this.parseBackgroundAttributes(v, M));
              } else Lt(null, null, L);
              if (!Y && (H = this.parseChars(v, M), H.length)) {
                const W = this.currentChannel;
                W && W > 0 ? this.channels[W].insertChars(H) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
              }
              Y || H || this.logger.log(2, () => "Couldn't parse cleaned data " + z([v, M]) + " orig: " + z([C[_], C[_ + 1]]));
            }
          }
          parseCmd(f, C) {
            if (!((f === 20 || f === 28 || f === 21 || f === 29) && C >= 32 && C <= 47 || (f === 23 || f === 31) && C >= 33 && C <= 35)) return !1;
            const _ = f === 20 || f === 21 || f === 23 ? 1 : 2, v = this.channels[_];
            return f === 20 || f === 21 || f === 28 || f === 29 ? C === 32 ? v.ccRCL() : C === 33 ? v.ccBS() : C === 34 ? v.ccAOF() : C === 35 ? v.ccAON() : C === 36 ? v.ccDER() : C === 37 ? v.ccRU(2) : C === 38 ? v.ccRU(3) : C === 39 ? v.ccRU(4) : C === 40 ? v.ccFON() : C === 41 ? v.ccRDC() : C === 42 ? v.ccTR() : C === 43 ? v.ccRTD() : C === 44 ? v.ccEDM() : C === 45 ? v.ccCR() : C === 46 ? v.ccENM() : C === 47 && v.ccEOC() : v.ccTO(C - 32), this.currentChannel = _, !0;
          }
          parseMidrow(f, C) {
            let _ = 0;
            if ((f === 17 || f === 25) && C >= 32 && C <= 47) {
              if (_ = f === 17 ? 1 : 2, _ !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
              const v = this.channels[_];
              return !!v && (v.ccMIDROW(C), this.logger.log(3, () => "MIDROW (" + z([f, C]) + ")"), !0);
            }
            return !1;
          }
          parsePAC(f, C) {
            let _;
            if (!((f >= 17 && f <= 23 || f >= 25 && f <= 31) && C >= 64 && C <= 127 || (f === 16 || f === 24) && C >= 64 && C <= 95)) return !1;
            const v = f <= 23 ? 1 : 2;
            _ = C >= 64 && C <= 95 ? v === 1 ? Q[f] : vt[f] : v === 1 ? Z[f] : V[f];
            const M = this.channels[v];
            return !!M && (M.setPAC(this.interpretPAC(_, C)), this.currentChannel = v, !0);
          }
          interpretPAC(f, C) {
            let _;
            const v = { color: null, italics: !1, indent: null, underline: !1, row: f };
            return _ = C > 95 ? C - 96 : C - 64, v.underline = !(1 & ~_), _ <= 13 ? v.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(_ / 2)] : _ <= 15 ? (v.italics = !0, v.color = "white") : v.indent = 4 * Math.floor((_ - 16) / 2), v;
          }
          parseChars(f, C) {
            let _, v = [], M = null;
            if (f >= 25 ? (_ = 2, M = f - 8) : (_ = 1, M = f), M >= 17 && M <= 19) {
              let Y;
              Y = M === 17 ? C + 80 : M === 18 ? C + 112 : C + 144, this.logger.log(2, () => "Special char '" + y(Y) + "' in channel " + _), v = [Y];
            } else f >= 32 && f <= 127 && (v = C === 0 ? [f] : [f, C]);
            return v && this.logger.log(3, () => "Char codes =  " + z(v).join(",")), v;
          }
          parseBackgroundAttributes(f, C) {
            if (!((f === 16 || f === 24) && C >= 32 && C <= 47 || (f === 23 || f === 31) && C >= 45 && C <= 47)) return !1;
            let _;
            const v = {};
            f === 16 || f === 24 ? (_ = Math.floor((C - 32) / 2), v.background = h[_], C % 2 == 1 && (v.background = v.background + "_semi")) : C === 45 ? v.background = "transparent" : (v.foreground = "black", C === 47 && (v.underline = !0));
            const M = f <= 23 ? 1 : 2;
            return this.channels[M].setBkgData(v), !0;
          }
          reset() {
            for (let f = 0; f < Object.keys(this.channels).length; f++) {
              const C = this.channels[f];
              C && C.reset();
            }
            Lt(null, null, this.cmdHistory);
          }
          cueSplitAtTime(f) {
            for (let C = 0; C < this.channels.length; C++) {
              const _ = this.channels[C];
              _ && _.cueSplitAtTime(f);
            }
          }
        }
        var X = w(5212), D = w(8854), yt = { TCP_CONNECTION: "TcpList", HTTP_REQUEST: "HttpList", TRACK_SWITCH: "RepSwitchList", BUFFER_LEVEL: "BufferLevel", BUFFER_LOADED: "bufferLoaded", ABANDON_LOAD: "abandonload", ALLOW_LOAD: "allowload", BUFFER_EMPTY: "bufferStalled", BUFFER_STATE: "BufferState", DVR_INFO: "DVRInfo", DROPPED_FRAMES: "DroppedFrames", SCHEDULING_INFO: "SchedulingInfo", REQUESTS_QUEUE: "RequestsQueue", MANIFEST_UPDATE: "ManifestUpdate", MANIFEST_UPDATE_STREAM_INFO: "ManifestUpdatePeriodInfo", MANIFEST_UPDATE_TRACK_INFO: "ManifestUpdateRepresentationInfo", PLAY_LIST: "PlayList", DVB_ERRORS: "DVBErrors", HTTP_REQUEST_DVB_REPORTING_TYPE: "DVBReporting" }, Mt = w(8850), at = w(3621), Bt = w(138), jt = w(649), At = w(1191);
        function Ce() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht, _t;
          function Ct() {
            Pt(), it = !1, R = 0, G = 0, ut = 0, J = !1, mt = !0, wt = !1, ht = !1, $ = NaN, ot = NaN, L && (f.off(at.A.DATA_UPDATE_COMPLETED, de, C), f.off(at.A.MANIFEST_UPDATED, Je, C), f.off(at.A.STREAMS_COMPOSED, $e, C), f.off(At.A.PLAYBACK_ENDED, Ke, C), f.off(At.A.STREAM_INITIALIZING, $t, C), f.off(At.A.REPRESENTATION_SWITCH, Se, C), f.off(At.A.BUFFER_LEVEL_STATE_CHANGED, nn, C), ie(), L.removeEventListener("canplay", Be), L.removeEventListener("canplaythrough", Oe), L.removeEventListener("play", _n), L.removeEventListener("waiting", ke), L.removeEventListener("playing", rn), L.removeEventListener("pause", Cn), L.removeEventListener("error", qe), L.removeEventListener("seeking", Nn), L.removeEventListener("seeked", Gn), L.removeEventListener("timeupdate", Xt), L.removeEventListener("progress", ce), L.removeEventListener("ratechange", oe), L.removeEventListener("loadedmetadata", pe), L.removeEventListener("loadeddata", en), L.removeEventListener("stalled", tn), L.removeEventListener("ended", mn), L.removeEventListener("volumechange", se)), K = null, L = null, F = null, et = null;
          }
          function bt() {
            return parseFloat((Rt(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) - dt()).toFixed(5));
          }
          function Rt(ue) {
            const Tt = ue || F;
            return Tt.start + Tt.duration;
          }
          function xt() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            F && L && L.getElement() ? (ue && et && It(dt()), L.play()) : it = !0;
          }
          function Pt() {
            F && L && L.pause();
          }
          function N(ue) {
            let Tt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Zt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], he = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
            F && L && L.getElement() && ue !== (isNaN($) ? L.getTime() : $) && (P = Zt === !0, P || ($ = ue), _.info("Requesting seek to time: " + ue + (P ? " (internal)" : "")), et && he && It(ue), L.setCurrentTime(ue, Tt));
          }
          function ct() {
            if (!F || !L || !et) return;
            const ue = v && v.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO, Tt = Y.getCurrentDVRInfo(ue);
            return Tt && Tt.range ? Tt.range.end : 0;
          }
          function It(ue) {
            const Tt = new Date(W.getClientReferenceTime()), Zt = H.getRegularPeriods()[0];
            R = W.calcPresentationTimeFromWallTime(Tt, Zt) - ue;
          }
          function dt() {
            return F && L ? L.getTime() : null;
          }
          function nt() {
            return F && L ? L.isPaused() : null;
          }
          function ft() {
            return F && L ? L.isSeeking() : null;
          }
          function rt() {
            return F && L ? L.isStalled() : null;
          }
          function Et() {
            return F && L ? L.getPlaybackRate() : null;
          }
          function kt() {
            return F && L ? L.getEnded() : null;
          }
          function Dt() {
            return et;
          }
          function Ut() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            if (nt() || !et || L.getReadyState() === 0 || ft() || J) return;
            ue || (ue = v.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO);
            const Tt = dt(), Zt = function(he, qt) {
              const Me = Y.getCurrentDVRInfo(qt), Ve = Me ? Me.range : null;
              let fn;
              return Ve ? (fn = he > Ve.end ? Math.max(Ve.end - R, Ve.start) : he > 0 && he + 0.25 < Ve.start && Math.abs(he - Ve.start) < 31536e4 ? wt ? Math.max(Ve.end - R, Ve.start) : Ve.start : he, fn) : NaN;
            }(Tt, ue);
            !isNaN(Zt) && Zt !== Tt && !ft() && (rt() || j || L.getReadyState() === 1) && (_.debug(`UpdateCurrentTime: Seek to actual time: ${Zt} from currentTime: ${Tt}`), N(Zt, !1, !1));
          }
          function Wt() {
            K === null && (K = setInterval(() => {
              (function() {
                if (f.trigger(at.A.WALLCLOCK_TIME_UPDATED, { isDynamic: et, time: /* @__PURE__ */ new Date() }), Dt()) {
                  const ue = Date.now();
                  (isNaN(ot) || ue > ot + _t.get().streaming.liveUpdateTimeThresholdInMilliseconds) && (v.addDVRMetric(), nt() ? function() {
                    const Tt = Date.now();
                    (!st || Tt > st + 500) && (st = Tt, Xt());
                  }() : Ut(), ot = ue);
                }
              })();
            }, _t.get().streaming.wallclockTimeUpdateInterval));
          }
          function ie() {
            clearInterval(K), K = null;
          }
          function de(ue) {
            const Tt = ue.currentRepresentation, Zt = Tt ? Tt.mediaInfo.streamInfo : null;
            Zt !== null && F.id === Zt.id && (F = Zt);
          }
          function Be() {
            f.trigger(at.A.CAN_PLAY);
          }
          function Oe() {
            f.trigger(at.A.CAN_PLAY_THROUGH);
          }
          function nn(ue) {
            ue.streamId === v.getActiveStreamInfo().id && (j = ue.state === yt.BUFFER_EMPTY, _t.get().streaming.buffer.setStallState && L.setStallState(ue.mediaType, ue.state === yt.BUFFER_EMPTY));
          }
          function _n() {
            _.info("Native video element event: play"), Ut(), Wt(), f.trigger(at.A.PLAYBACK_STARTED, { startTime: dt() });
          }
          function ke() {
            _.info("Native video element event: waiting"), f.trigger(at.A.PLAYBACK_WAITING, { playingTime: dt() });
          }
          function rn() {
            _.info("Native video element event: playing"), P = !1, f.trigger(at.A.PLAYBACK_PLAYING, { playingTime: dt() });
          }
          function Cn() {
            _.info("Native video element event: pause"), f.trigger(at.A.PLAYBACK_PAUSED, { ended: kt() });
          }
          function Nn() {
            if (P) return;
            let ue = dt();
            isNaN($) || $ === ue || (ue = $), $ = NaN, _.info("Seeking to: " + ue), Wt(), f.trigger(at.A.PLAYBACK_SEEKING, { seekTime: ue, streamId: F.id });
          }
          function Gn() {
            _.info("Native video element event: seeked"), P = !1, f.trigger(at.A.PLAYBACK_SEEKED);
          }
          function Xt() {
            F && f.trigger(at.A.PLAYBACK_TIME_UPDATED, { timeToEnd: bt(), time: dt(), streamId: F.id });
          }
          function ce() {
            f.trigger(at.A.PLAYBACK_PROGRESS, { streamId: F.id });
          }
          function oe() {
            const ue = Et();
            _.info("Native video element event: ratechange: ", ue), f.trigger(at.A.PLAYBACK_RATE_CHANGED, { playbackRate: ue });
          }
          function pe() {
            _.info("Native video element event: loadedmetadata"), f.trigger(at.A.PLAYBACK_METADATA_LOADED), Wt();
          }
          function en() {
            _.info("Native video element event: loadeddata"), f.trigger(at.A.PLAYBACK_LOADED_DATA);
          }
          function mn() {
            _.info("Native video element event: ended"), Pt(), ie();
            const ue = v ? v.getActiveStreamInfo() : null;
            ue && f.trigger(at.A.PLAYBACK_ENDED, { isLast: ue.isLast });
          }
          function se() {
            f.trigger(at.A.PLAYBACK_VOLUME_CHANGED);
          }
          function Ke(ue) {
            if (K && ue.isLast) {
              _.info("onPlaybackEnded -- PLAYBACK_ENDED but native video element didn't fire ended");
              const Tt = ue.seekTime ? ue.seekTime : Rt();
              L.setCurrentTime(Tt), Pt(), ie();
            }
          }
          function qe(ue) {
            const Tt = ue.target || ue.srcElement;
            f.trigger(at.A.PLAYBACK_ERROR, { error: Tt.error });
          }
          function Ze() {
            et = !1;
          }
          function tn(ue) {
            f.trigger(at.A.PLAYBACK_STALLED, { e: ue });
          }
          function $t(ue) {
            var Tt;
            (Tt = ue.mediaInfo) && Tt.supplementalProperties && Tt.supplementalProperties.find((Zt) => Zt.schemeIdUri === X.A.SUPPLEMENTAL_PROPERTY_DVB_LL_SCHEME) && (_.debug("Low Latency critical SupplementalProperty set: Enabling low Latency"), wt = !0);
          }
          function Se(ue) {
            const Tt = v.getActiveStreamInfo();
            ue && Tt && ue.currentRepresentation && ue.streamId && ue.streamId === Tt.id && ue.mediaType && (ue.mediaType === X.A.VIDEO || ue.mediaType === X.A.AUDIO || ue.mediaType === X.A.MESH) && (mt = ue.currentRepresentation.availabilityTimeComplete, wt = !mt, wt && !ht && (ht = !0));
          }
          function Je() {
            J = !0;
          }
          function $e() {
            J = !1;
          }
          return C = { computeAndSetLiveDelay: function(ue, Tt) {
            let Zt, he, qt;
            const Me = !isNaN(ue) && isFinite(ue) ? ue : NaN;
            let Ve = H.getSuggestedPresentationDelay();
            const fn = M.getServiceDescriptionSettings();
            return Zt = isNaN(_t.get().streaming.delay.liveDelay) ? _t.get().streaming.delay.liveDelayFragmentCount === null || isNaN(_t.get().streaming.delay.liveDelayFragmentCount) || isNaN(Me) ? fn && !isNaN(fn.liveDelay) && fn.liveDelay > 0 ? fn.liveDelay : _t.get().streaming.delay.useSuggestedPresentationDelay === !0 && Ve !== null && !isNaN(Ve) && Ve > 0 ? Ve : isNaN(Me) ? Tt && !isNaN(Tt.minBufferTime) ? 4 * Tt.minBufferTime : 4 * F.manifestInfo.minBufferTime : 4 * Me : Me * _t.get().streaming.delay.liveDelayFragmentCount : _t.get().streaming.delay.liveDelay, qt = H.getAvailabilityStartTime(), qt !== null && (ut = qt), he = Tt && Tt.dvrWindowSize > 0 ? Math.min(Zt, Tt.dvrWindowSize) : Zt, R = he, G = he, he;
          }, getAvailabilityStartTime: function() {
            return ut;
          }, getBufferLevel: function() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, Tt = null;
            return v.getActiveStreamProcessors().forEach((Zt) => {
              if (!ue || ue.length === 0 || ue.indexOf(Zt.getType()) === -1) {
                const he = Zt.getBufferLevel();
                Tt = Tt === null ? he : Math.min(Tt, he);
              }
            }), Tt;
          }, getCurrentLiveLatency: function() {
            if (!et || isNaN(ut)) return NaN;
            let ue = dt();
            if (isNaN(ue) || ue === 0) return 0;
            const Tt = (/* @__PURE__ */ new Date()).getTime() + 1e3 * W.getClientTimeOffset();
            return Math.max(((Tt - ut - 1e3 * ue) / 1e3).toFixed(3), 0);
          }, getEnded: kt, getInitialCatchupModeActivated: function() {
            return ht;
          }, getIsDynamic: Dt, getIsManifestUpdateInProgress: function() {
            return J;
          }, getLiveDelay: function() {
            return R;
          }, getLowLatencyModeEnabled: function() {
            return wt;
          }, getOriginalLiveDelay: function() {
            return G;
          }, getPlaybackRate: Et, getPlaybackStalled: function() {
            return j;
          }, getPlayedRanges: function() {
            return F && L ? L.getPlayedRanges() : null;
          }, getStreamController: function() {
            return v;
          }, getStreamEndTime: Rt, getTime: dt, getTimeToStreamEnd: bt, initialize: function(ue, Tt) {
            F = ue, Tt !== !0 && (L.addEventListener("canplay", Be), L.addEventListener("canplaythrough", Oe), L.addEventListener("play", _n), L.addEventListener("waiting", ke), L.addEventListener("playing", rn), L.addEventListener("pause", Cn), L.addEventListener("error", qe), L.addEventListener("seeking", Nn), L.addEventListener("seeked", Gn), L.addEventListener("timeupdate", Xt), L.addEventListener("progress", ce), L.addEventListener("ratechange", oe), L.addEventListener("loadedmetadata", pe), L.addEventListener("loadeddata", en), L.addEventListener("stalled", tn), L.addEventListener("ended", mn), L.addEventListener("volumechange", se), et = F.manifestInfo.isDynamic, j = !1, P = !1, f.on(at.A.DATA_UPDATE_COMPLETED, de, C), f.on(at.A.MANIFEST_UPDATED, Je, C), f.on(at.A.STREAMS_COMPOSED, $e, C), f.on(At.A.PLAYBACK_ENDED, Ke, C, { priority: Mt.A.EVENT_PRIORITY_HIGH }), f.on(At.A.STREAM_INITIALIZING, $t, C), f.on(At.A.REPRESENTATION_SWITCH, Se, C), f.on(At.A.BUFFER_LEVEL_STATE_CHANGED, nn, C), f.on(At.A.DYNAMIC_TO_STATIC, Ze, C), it && (it = !1, xt()));
          }, isPaused: nt, isProgressing: function() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 500;
            return new Promise((Tt) => {
              let Zt = -1, he = null;
              const qt = (Ve) => {
                clearTimeout(he), he = null, f.off(At.A.PLAYBACK_TIME_UPDATED, Me, C), Tt(Ve);
              }, Me = (Ve) => {
                Zt < 0 ? Zt = Ve.time : Ve.time > Zt + 0.1 && qt(!0);
              };
              he = setTimeout(() => {
                qt(!1);
              }, ue), f.on(At.A.PLAYBACK_TIME_UPDATED, Me, C);
            });
          }, isSeeking: ft, isStalled: rt, pause: Pt, play: xt, reset: Ct, seek: N, seekToCurrentLive: function() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], Tt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Zt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const he = ct();
            he !== 0 && N(he - R, ue, Tt, Zt);
          }, seekToOriginalLive: function() {
            let ue = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], Tt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Zt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const he = ct();
            he !== 0 && (R = G, N(he - R, ue, Tt, Zt));
          }, setConfig: function(ue) {
            ue && (ue.streamController && (v = ue.streamController), ue.serviceDescriptionController && (M = ue.serviceDescriptionController), ue.dashMetrics && (Y = ue.dashMetrics), ue.adapter && (H = ue.adapter), ue.videoModel && (L = ue.videoModel), ue.timelineConverter && (W = ue.timelineConverter), ue.settings && (_t = ue.settings));
          }, updateCurrentTime: Ut }, _ = (0, jt.A)(A).getInstance().getLogger(C), Ct(), C;
        }
        Ce.__dashjs_factory_name = "PlaybackController";
        var ne = Bt.A.getSingletonFactory(Ce), Ht = w(7568);
        class Le {
          constructor(f) {
            this.action = Le.ACTION_DOWNLOAD, this.availabilityEndTime = null, this.availabilityStartTime = null, this.bandwidth = NaN, this.bytesLoaded = NaN, this.bytesTotal = NaN, this.delayLoadingTime = NaN, this.duration = NaN, this.endDate = null, this.firstByteDate = null, this.index = NaN, this.mediaStartTime = NaN, this.mediaType = null, this.range = null, this.representation = null, this.responseType = "arraybuffer", this.retryAttempts = 0, this.serviceLocation = null, this.startDate = null, this.startTime = NaN, this.timescale = NaN, this.type = null, this.url = f || null, this.wallStartTime = null;
          }
          isInitializationRequest() {
            return this.type && this.type === Ht.G.INIT_SEGMENT_TYPE;
          }
          setInfo(f) {
            this.type = f && f.init ? Ht.G.INIT_SEGMENT_TYPE : Ht.G.MEDIA_SEGMENT_TYPE, this.url = f && f.url ? f.url : null, this.range = f && f.range ? f.range.start + "-" + f.range.end : null, this.mediaType = f && f.mediaType ? f.mediaType : null, this.representation = f && f.representation ? f.representation : null;
          }
        }
        Le.ACTION_DOWNLOAD = "download", Le.ACTION_COMPLETE = "complete";
        var sn = Le;
        const we = "loading", ln = "executed", _e = "failed";
        function Rn(A) {
          const f = (A = A || {}).eventBus, C = A.events, _ = A.dashMetrics, v = A.fragmentLoader, M = A.debug, Y = A.streamInfo, H = A.type;
          let L, W, K, R;
          function G(P) {
            return !!P && function(j) {
              let J = !1;
              return j.some((ht) => {
                if (_t = P, Ct = ht, !isNaN(_t.index) && _t.startTime === Ct.startTime && _t.adaptationIndex === Ct.adaptationIndex && _t.type === Ct.type || function(bt, Rt) {
                  return bt.representation.id === Rt.representation.id;
                }(P, ht) || function(bt, Rt) {
                  return bt.action === sn.ACTION_COMPLETE && bt.action === Rt.action;
                }(P, ht)) return J = !0, J;
                var _t, Ct;
              }), J;
            }(K);
          }
          function F(P) {
            return isNaN(P.duration) ? 0.25 : Math.min(P.duration / 8, 0.5);
          }
          function et(P) {
            K = K.filter((j) => {
              const J = F(j);
              return isNaN(j.startTime) || P !== void 0 && j.startTime >= P - J;
            });
          }
          function it(P, j) {
            j <= P + 0.5 || (K = K.filter((J) => {
              const ht = F(J);
              return isNaN(J.startTime) || J.startTime >= j - ht || isNaN(J.duration) || J.startTime + J.duration <= P + ht;
            }));
          }
          function st(P, j, J) {
            for (let ht = P.length - 1; ht >= 0; ht--) {
              const _t = P[ht], Ct = _t.startTime, bt = Ct + _t.duration;
              if (J = isNaN(J) ? F(_t) : J, !isNaN(Ct) && !isNaN(bt) && j + J >= Ct && j - J < bt || isNaN(Ct) && isNaN(j)) return _t;
            }
            return null;
          }
          function ot(P, j) {
            _.addSchedulingInfo(P, j), _.addRequestsQueue(P.mediaType, R, K);
          }
          function ut(P) {
            P.sender === v && (R.splice(R.indexOf(P.request), 1), P.response && !P.error && K.push(P.request), ot(P.request, P.error ? _e : ln), f.trigger(C.FRAGMENT_LOADING_COMPLETED, { request: P.request, response: P.response, error: P.error, sender: this }, { streamId: Y.id, mediaType: H }));
          }
          function mt(P) {
            P.sender === v && f.trigger(C.FRAGMENT_LOADING_PROGRESS, { request: P.request, response: P.response, error: P.error, sender: this }, { streamId: Y.id, mediaType: H });
          }
          function wt(P) {
            P.sender === v && f.trigger(C.FRAGMENT_LOADING_ABANDONED, { request: P.request }, { streamId: Y.id, mediaType: H });
          }
          function $() {
            K = [], R = [], v && v.resetInitialSettings();
          }
          return L = { abortRequests: function() {
            W.debug("abort requests"), v.abort(), R = [];
          }, executeRequest: function(P) {
            P.action === sn.ACTION_DOWNLOAD ? (ot(P, we), R.push(P), function(j) {
              f.trigger(C.FRAGMENT_LOADING_STARTED, { request: j }, { streamId: Y.id, mediaType: H }), v.load(j);
            }(P)) : W.warn("Unknown request action.");
          }, getRequests: function(P) {
            const j = P ? P.state instanceof Array ? P.state : [P.state] : [];
            let J = [];
            return j.forEach((ht) => {
              const _t = function(Ct) {
                let bt;
                switch (Ct) {
                  case we:
                    bt = R;
                    break;
                  case ln:
                    bt = K;
                    break;
                  default:
                    bt = [];
                }
                return bt;
              }(ht);
              J = J.concat(function(Ct, bt) {
                return bt.hasOwnProperty("time") ? [st(Ct, bt.time, bt.threshold)] : Ct.filter((Rt) => {
                  for (const xt in bt) if (xt !== "state" && bt.hasOwnProperty(xt) && Rt[xt] != bt[xt]) return !1;
                  return !0;
                });
              }(_t, P));
            }), J;
          }, getStreamId: function() {
            return Y.id;
          }, getType: function() {
            return H;
          }, isFragmentLoaded: G, isFragmentLoadedOrPending: function(P) {
            let j, J = !1, ht = 0;
            if (J = G(P), !J) for (ht = 0; ht < R.length; ht++) j = R[ht], P.url === j.url && P.startTime === j.startTime && (J = !0);
            return J;
          }, removeExecutedRequestsAfterTime: function(P) {
            K = K.filter((j) => isNaN(j.startTime) || P !== void 0 && j.startTime < P);
          }, removeExecutedRequestsBeforeTime: et, reset: function() {
            f.off(C.LOADING_COMPLETED, ut, this), f.off(C.LOADING_DATA_PROGRESS, mt, this), f.off(C.LOADING_ABANDONED, wt, this), v && v.reset(), $();
          }, resetInitialSettings: $, syncExecutedRequestsWithBufferedRange: function(P, j) {
            if (!P || P.length === 0) return void et();
            let J = 0;
            for (let ht = 0, _t = P.length; ht < _t; ht++) it(J, P.start(ht)), J = P.end(ht);
            j > 0 && it(J, j);
          } }, W = M.getLogger(L), $(), f.on(C.LOADING_COMPLETED, ut, L), f.on(C.LOADING_DATA_PROGRESS, mt, L), f.on(C.LOADING_ABANDONED, wt, L), L;
        }
        Rn.__dashjs_factory_name = "FragmentModel";
        const En = Bt.A.getClassFactory(Rn);
        En.FRAGMENT_MODEL_LOADING = we, En.FRAGMENT_MODEL_EXECUTED = ln, En.FRAGMENT_MODEL_CANCELED = "canceled", En.FRAGMENT_MODEL_FAILED = _e, Bt.A.updateClassFactory(Rn.__dashjs_factory_name, En);
        var Tn = En, Nt = w(1944), Ft = w(8748);
        class ve extends Ft.A {
          constructor() {
            super(), this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE = 10, this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE = 11, this.XLINK_LOADER_LOADING_FAILURE_ERROR_CODE = 12, this.SEGMENT_BASE_LOADER_ERROR_CODE = 15, this.TIME_SYNC_FAILED_ERROR_CODE = 16, this.FRAGMENT_LOADER_LOADING_FAILURE_ERROR_CODE = 17, this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_CODE = 18, this.URL_RESOLUTION_FAILED_GENERIC_ERROR_CODE = 19, this.APPEND_ERROR_CODE = 20, this.REMOVE_ERROR_CODE = 21, this.DATA_UPDATE_FAILED_ERROR_CODE = 22, this.CAPABILITY_MEDIASOURCE_ERROR_CODE = 23, this.CAPABILITY_MEDIAKEYS_ERROR_CODE = 24, this.DOWNLOAD_ERROR_ID_MANIFEST_CODE = 25, this.DOWNLOAD_ERROR_ID_SIDX_CODE = 26, this.DOWNLOAD_ERROR_ID_CONTENT_CODE = 27, this.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE = 28, this.DOWNLOAD_ERROR_ID_XLINK_CODE = 29, this.MANIFEST_ERROR_ID_PARSE_CODE = 31, this.MANIFEST_ERROR_ID_NOSTREAMS_CODE = 32, this.TIMED_TEXT_ERROR_ID_PARSE_CODE = 33, this.MANIFEST_ERROR_ID_MULTIPLEXED_CODE = 34, this.MEDIASOURCE_TYPE_UNSUPPORTED_CODE = 35, this.NO_SUPPORTED_KEY_IDS = 36, this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE = "parsing failed for ", this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE = "Failed loading manifest: ", this.XLINK_LOADER_LOADING_FAILURE_ERROR_MESSAGE = "Failed loading Xlink element: ", this.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE = "Segments update failed", this.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE = "no segments are available yet", this.SEGMENT_BASE_LOADER_ERROR_MESSAGE = "error loading segment ranges from sidx", this.TIME_SYNC_FAILED_ERROR_MESSAGE = "Failed to synchronize client and server time", this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_MESSAGE = "request is null", this.URL_RESOLUTION_FAILED_GENERIC_ERROR_MESSAGE = "Failed to resolve a valid URL", this.APPEND_ERROR_MESSAGE = "chunk is not defined", this.REMOVE_ERROR_MESSAGE = "Removing data from the SourceBuffer", this.DATA_UPDATE_FAILED_ERROR_MESSAGE = "Data update failed", this.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE = "mediasource is not supported", this.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE = "mediakeys is not supported", this.TIMED_TEXT_ERROR_MESSAGE_PARSE = "parsing error :", this.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE = "Error creating source buffer of type : ", this.NO_SUPPORTED_KEY_IDS_MESSAGE = "All possible Adaptation Sets have an invalid key status";
          }
        }
        var q = new ve(), tt = w(8261);
        function x(A) {
          const f = this.context, C = (0, tt.A)(f).getInstance(), _ = A.textController, v = A.eventBus;
          let M, Y, H, L, W, K, R = [], G = [], F = !1, et = A.mediaSource, it = null;
          function st(Ct) {
            return Ct.mimeType + ';codecs="' + Ct.codecs + '"';
          }
          function ot(Ct) {
            return L = _.getTextSourceBuffer(Ct), Promise.resolve();
          }
          function ut() {
            if (typeof L.addEventListener == "function") try {
              L.addEventListener("updateend", J, !1), L.addEventListener("error", ht, !1), L.addEventListener("abort", ht, !1);
            } catch (Ct) {
              K = setInterval(J, 50);
            }
            else K = setInterval(J, 50);
          }
          function mt() {
            try {
              typeof L.removeEventListener == "function" && (L.removeEventListener("updateend", J, !1), L.removeEventListener("error", ht, !1), L.removeEventListener("abort", ht, !1)), clearInterval(K);
            } catch (Ct) {
              H.error(Ct);
            }
          }
          function wt(Ct) {
            return new Promise((bt) => {
              L && C.get().streaming.buffer.useAppendWindow ? _t(() => {
                try {
                  if (!L) return void bt();
                  let Rt = et.duration, xt = 0;
                  Ct && !isNaN(Ct.start) && !isNaN(Ct.duration) && isFinite(Ct.duration) && (Rt = Ct.start + Ct.duration), Ct && !isNaN(Ct.start) && (xt = Ct.start), L.appendWindowEnd === Rt && L.appendWindowStart === xt || (L.appendWindowStart = 0, L.appendWindowEnd = Rt + 0.01, L.appendWindowStart = Math.max(xt - 0.1, 0), H.debug(`Updated append window for ${W.type}. Set start to ${L.appendWindowStart} and end to ${L.appendWindowEnd}`)), bt();
                } catch (Rt) {
                  H.warn("Failed to set append window"), bt();
                }
              }) : bt();
            });
          }
          function $(Ct) {
            return new Promise((bt) => {
              L ? _t(() => {
                try {
                  L.timestampOffset === Ct || isNaN(Ct) || (L.timestampOffset = Ct, H.debug(`Set MSE timestamp offset to ${Ct}`)), bt();
                } catch (Rt) {
                  bt();
                }
              }) : bt();
            });
          }
          function P() {
            if (!F && G.length > 0) {
              F = !0;
              const Ct = G[0];
              G.splice(0, 1);
              const bt = function() {
                F = !1, G.length > 0 && P.call(this), Ct && Ct.data && Ct.data.segmentType && Ct.data.segmentType !== Ht.G.INIT_SEGMENT_TYPE && delete Ct.data.bytes, Ct.promise.resolve({ chunk: Ct.data });
              };
              try {
                if (it = Ct.request, Ct.data.bytes.byteLength === 0) bt.call(this);
                else {
                  try {
                    H.debug(`Appending ${Ct.data.segmentType} from period ${Ct.data.streamId} to buffer. Request URL: ${Ct.request.url}, Representation: ID: ${Ct.data.representation.id}, bitrate: ${Ct.data.representation.bitrateInKbit}`);
                  } catch (Rt) {
                  }
                  L.appendBuffer ? L.appendBuffer(Ct.data.bytes) : L.append(Ct.data.bytes, Ct.data), _t(bt.bind(this));
                }
              } catch (Rt) {
                H.fatal('SourceBuffer append failed "' + Rt + '"'), G.length > 0 ? P() : F = !1, delete Ct.data.bytes, Ct.promise.reject({ chunk: Ct.data, error: new Nt.A(Rt.code, Rt.message) });
              }
            }
          }
          function j() {
            R.length > 0 && !L.updating && (R.shift()(), j());
          }
          function J() {
            L.updating || j();
          }
          function ht(Ct) {
            const bt = Ct.target || {};
            (function(Rt, xt) {
              let Pt = xt || {};
              v.trigger(Rt, Pt, { streamId: W.streamInfo.id, mediaType: Y });
            })(at.A.SOURCE_BUFFER_ERROR, { error: bt, lastRequestAppended: it });
          }
          function _t(Ct) {
            try {
              R.push(Ct), L.updating || j();
            } catch (bt) {
              H.error(bt);
            }
          }
          return M = { abort: function() {
            return new Promise((Ct) => {
              try {
                G = [], et.readyState === "open" ? _t(() => {
                  try {
                    L && L.abort(), Ct();
                  } catch (bt) {
                    Ct();
                  }
                }) : (L && L.setTextTrack && et.readyState === "ended" && L.abort(), Ct());
              } catch (bt) {
                Ct();
              }
            });
          }, abortBeforeAppend: function() {
            return new Promise((Ct) => {
              _t(() => {
                const bt = L.appendWindowStart, Rt = L.appendWindowEnd;
                L && (L.abort(), L.appendWindowStart = bt, L.appendWindowEnd = Rt), Ct();
              });
            });
          }, append: function(Ct) {
            let bt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return new Promise((Rt, xt) => {
              Ct ? (G.push({ data: Ct, promise: { resolve: Rt, reject: xt }, request: bt }), _t(P.bind(this))) : xt({ chunk: Ct, error: new Nt.A(q.APPEND_ERROR_CODE, q.APPEND_ERROR_MESSAGE) });
            });
          }, changeType: function(Ct) {
            const bt = st(Ct);
            return new Promise((Rt) => {
              _t(() => {
                L.changeType && (H.debug(`Changing SourceBuffer codec to ${bt}`), L.changeType(bt)), Rt();
              });
            });
          }, getAllBufferRanges: function() {
            try {
              return L.buffered;
            } catch (Ct) {
              return H.error("getAllBufferRanges exception: " + Ct.message), null;
            }
          }, getBuffer: function() {
            return L;
          }, getType: function() {
            return Y;
          }, initializeForFirstUse: function(Ct, bt) {
            W = Ct;
            const Rt = Ct.streamInfo;
            Y = W.type;
            const xt = bt ? st(bt) : Ct.codec;
            try {
              if (xt.match(/application\/mp4;\s*codecs="(stpp|wvtt).*"/i)) return ot(Rt);
              L = et.addSourceBuffer(xt), ut();
              const Pt = [];
              return Pt.push(wt(W.streamInfo)), bt && bt.mseTimeOffset !== void 0 && Pt.push($(bt.mseTimeOffset)), Promise.all(Pt);
            } catch (Pt) {
              return W.type == X.A.TEXT && !W.isFragmented || xt.indexOf('codecs="stpp') !== -1 || xt.indexOf('codecs="vtt') !== -1 || xt.indexOf("text/vtt") !== -1 ? ot(Rt) : Promise.reject(Pt);
            }
          }, initializeForStreamSwitch: function(Ct, bt, Rt) {
            W = Ct, Y = W.type, function(xt) {
              L = xt.getBuffer();
            }(Rt), ut();
          }, remove: function(Ct) {
            return new Promise((bt, Rt) => {
              const xt = Ct.start, Pt = Ct.end;
              xt >= 0 && Pt > xt ? _t(function() {
                try {
                  L.remove(xt, Pt), _t(function() {
                    bt({ from: xt, to: Pt, unintended: !1 }), Ct.resolve && Ct.resolve();
                  });
                } catch (N) {
                  Rt({ from: xt, to: Pt, unintended: !1, error: new Nt.A(q.REMOVE_ERROR_CODE, q.REMOVE_ERROR_MESSAGE) }), Ct.reject && Ct.reject(N);
                }
              }) : bt();
            });
          }, removeEventListeners: mt, reset: function() {
            if (L) {
              try {
                R = [], mt(), F = !1, G = [], L.getClassName && L.getClassName() === "TextSourceBuffer" || (H.debug("Removing sourcebuffer from media source"), et.removeSourceBuffer(L));
              } catch (Ct) {
              }
              L = null;
            }
            it = null;
          }, updateAppendWindow: wt, updateTimestampOffset: $ }, H = (0, jt.A)(f).getInstance().getLogger(M), M;
        }
        x.__dashjs_factory_name = "SourceBufferSink";
        var U = Bt.A.getClassFactory(x);
        function pt(A) {
          const f = this.context;
          let C, _, v, M = [], Y = A;
          function H(L, W) {
            return M = M.filter((K) => !((isNaN(W) || K.start < W) && (isNaN(L) || K.end > L))), Promise.resolve();
          }
          return C = { getAllBufferRanges: function() {
            let L = [];
            for (let K = 0; K < M.length; K++) {
              let R = M[K];
              L.length === 0 || R.start > L[L.length - 1].end ? L.push({ start: R.start, end: R.end }) : L[L.length - 1].end = R.end;
            }
            const W = { start: function(K) {
              return L[K].start;
            }, end: function(K) {
              return L[K].end;
            } };
            return Object.defineProperty(W, "length", { get: function() {
              return L.length;
            } }), W;
          }, append: function(L) {
            return L.segmentType !== "InitializationSegment" ? (M.push(L), M.sort(function(W, K) {
              return W.start - K.start;
            }), v = null) : v = L, _.debug("PreBufferSink appended chunk s: " + L.start + "; e: " + L.end), Y && Y({ chunk: L }), Promise.resolve();
          }, remove: H, abort: function() {
            return Promise.resolve();
          }, discharge: function(L, W) {
            const K = function(R, G) {
              return M.filter((F) => (isNaN(G) || F.start < G) && (isNaN(R) || F.end > R));
            }(L, W);
            return v && (K.push(v), v = null), H(L, W), K;
          }, reset: function() {
            M = [], v = null, Y = null;
          }, updateTimestampOffset: function() {
            return Promise.resolve();
          }, waitForUpdateEnd: function(L) {
            L();
          }, getBuffer: function() {
            return this;
          } }, _ = (0, jt.A)(f).getInstance().getLogger(C), C;
        }
        pt.__dashjs_factory_name = "PreBufferSink";
        var lt = Bt.A.getClassFactory(pt);
        function Gt() {
          let A = {};
          return { save: function(f) {
            const C = f.streamId, _ = f.representation.id;
            A[C] = A[C] || {}, A[C][_] = f;
          }, extract: function(f, C) {
            return A && A[f] && A[f][C] ? A[f][C] : null;
          }, reset: function() {
            A = {};
          } };
        }
        Gt.__dashjs_factory_name = "InitCache";
        var ee = Bt.A.getSingletonFactory(Gt);
        const Vt = 0.01, Jt = "BufferController";
        function Ot(A) {
          const f = (A = A || {}).capabilities, C = this.context, _ = (0, Mt.A)(C).getInstance(), v = A.fragmentModel, M = A.playbackController, Y = A.representationController, H = A.settings, L = A.streamInfo, W = A.textController, K = A.type;
          let R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht, _t, Ct, bt, Rt, xt, Pt;
          function N($t) {
            let Se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return new Promise((Je, $e) => {
              st = $t, mt && Se && typeof mt.discharge == "function" ? (wt = mt, ct(Se).then(() => {
                Je();
              }).catch((ue) => {
                $e(ue);
              })) : Je();
            });
          }
          function ct($t) {
            let Se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], Je = arguments.length > 2 ? arguments[2] : void 0;
            return new Promise(($e, ue) => {
              bt && $t ? st ? ($ = !1, function(Tt, Zt, he) {
                return new Promise((qt) => {
                  mt = U(C).create({ mediaSource: st, textController: W, eventBus: _ }), function(Me, Ve, fn) {
                    const Bn = Y.getCurrentRepresentation();
                    return Ve && Ve[K] && (K === X.A.VIDEO || K === X.A.AUDIO || K === X.A.MESH) ? function(Sn, Ia, Pa, sr) {
                      mt.initializeForStreamSwitch(Sn, Ia, Pa[K]);
                      const oi = [];
                      return oi.push(mt.abortBeforeAppend()), oi.push(oe()), oi.push(kt(Ia, sr)), Ia && Ia.mseTimeOffset !== void 0 && oi.push(ce(Ia)), Promise.allSettled(oi);
                    }(Me, Bn, Ve, fn) : function(Sn, Ia) {
                      return mt.initializeForFirstUse(Sn, Ia);
                    }(Me, Bn);
                  }(Tt, Zt, he).then(() => ce(Y.getCurrentRepresentation())).then(() => {
                    qt(mt);
                  }).catch((Me) => {
                    G.warn("Caught error on create SourceBuffer: " + Me), qt(mt);
                  });
                });
              }($t, Se, Je).then((Tt) => {
                $e(Tt);
              }).catch((Tt) => {
                ue(Tt);
              })) : ($ = !0, function() {
                return new Promise((Tt, Zt) => {
                  mt = lt(C).create(rt.bind(this)), ce(Y.getCurrentRepresentation()).then(() => {
                    Tt(mt);
                  }).catch(() => {
                    Zt();
                  });
                });
              }().then((Tt) => {
                $e(Tt);
              }).catch((Tt) => {
                ue(Tt);
              })) : $e(null);
            });
          }
          function It($t) {
            H.get().streaming.cacheInitSegments && (G.info("Init fragment finished loading saving to", K + "'s init cache"), bt.save($t.chunk)), G.debug(`Appending init fragment for type ${K}, representationId ${$t.chunk.representation.id} and bandwidth ${$t.chunk.representation.bandwidth}`), nt($t.chunk);
          }
          function dt($t) {
            nt($t.chunk, $t.request);
          }
          function nt($t) {
            let Se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            mt && (mt.append($t, Se).then((Je) => {
              rt(Je);
            }).catch((Je) => {
              rt(Je);
            }), $t.representation.mediaInfo.type === X.A.VIDEO && Ze(at.A.VIDEO_CHUNK_RECEIVED, { chunk: $t }));
          }
          function ft($t) {
            if ($t && $t.length > 0) for (let Se = 0, Je = $t.length; Se < Je; Se++) G.debug("Buffered range: " + $t.start(Se) + " - " + $t.end(Se) + ", currentTime = ", M.getTime());
          }
          function rt($t) {
            if ($t.error) return $t.error.code === 22 && function() {
              if (Ct = !0, it = 0.8 * se(), G.warn("Quota exceeded, Critical Buffer: " + it), it > 0) {
                const $e = Math.max(0.2 * it, 1), ue = it - $e, Tt = Math.min(H.get().streaming.buffer.bufferTimeAtTopQuality, 0.9 * ue), Zt = Math.min(H.get().streaming.buffer.bufferTimeAtTopQualityLongForm, 0.9 * ue), he = { streaming: { buffer: { bufferToKeep: parseFloat($e.toFixed(5)), bufferTimeAtTopQuality: parseFloat(Tt.toFixed(5)), bufferTimeAtTopQualityLongForm: parseFloat(Zt.toFixed(5)) } } };
                H.update(he);
              }
            }(), void ($t.error.code !== 22 && qe() || (G.warn("Clearing playback buffer to overcome quota exceed situation"), Ze(at.A.QUOTA_EXCEEDED, { criticalBufferLevel: it, quotaExceededTime: $t.chunk.start }), Nn(Cn())));
            if (!mt || (Oe(), Ct = !1, J = $t.chunk, !J || !J.endFragment)) return;
            J && !isNaN(J.index) && (ot = Math.max(J.index, ot), nn());
            const Se = mt.getAllBufferRanges();
            J.segmentType === Ht.G.MEDIA_SEGMENT_TYPE && (ft(Se), Wt(), function() {
              if (isNaN(Pt) || $) return;
              if (K !== X.A.AUDIO && K !== X.A.VIDEO && K !== X.A.MESH) return void (Pt = NaN);
              const $e = M.getTime(), ue = Be($e, 0), Tt = Be(Pt, 0);
              if (ue && Tt && ue.start === Tt.start) return void (Pt = NaN);
              const Zt = Y.getCurrentRepresentation().segmentDuration, he = Be(Pt, Zt);
              he && (H.get().streaming.buffer.enableSeekDecorrelationFix && Math.abs($e - Pt) > Zt ? Pt <= he.end && M.seek(Math.max(Pt, he.start), !1, !0) : $e < he.start && M.seek(he.start, !1, !0));
            }());
            let Je = !1;
            P && (P.indexOf(J) > 0 && (Je = !0), P = null), J && !Je && Ze(at.A.BYTES_APPENDED_END_FRAGMENT, { startTime: J.start, index: J.index, bufferedRanges: Se, segmentType: J.segmentType, mediaType: K, representationId: J.representation.id });
          }
          function Et($t, Se) {
            const Je = [];
            return Je.push(ce($t)), Je.push(mt ? mt.abort() : Promise.resolve()), Je.push(kt($t, Se)), Promise.allSettled(Je);
          }
          function kt($t, Se) {
            return $t && Se ? $t && Se && $t.mimeType === Se.mimeType && $t.codecFamily === Se.codecFamily ? (G.debug(`Switching to new codec ${$t.codecs} without changeType as previous codec ${Se.codecs} is compatible.`), Promise.resolve()) : H.get().streaming.buffer.useChangeType && f.supportsChangeType() ? (G.debug(`Using changeType() to switch from codec ${Se.codecs} to ${$t.codecs}`), mt.changeType($t)) : (G.debug("changeType() not available"), Promise.resolve()) : (G.warn("BufferController._changeCodec() is missing the information about the Representations. Doing nothing"), Promise.resolve());
          }
          function Dt() {
            return new Promise(($t, Se) => {
              let Je = Ut();
              if (!Je || Je.length === 0) return Wt(), void $t();
              Nn(Je).then(() => {
                $t();
              }).catch(($e) => {
                Se($e);
              });
            });
          }
          function Ut($t) {
            const Se = [], Je = mt.getAllBufferRanges();
            if (!Je || Je.length === 0) return Se;
            if (!$t && $t !== 0 || isNaN($t)) Se.push({ start: Je.start(0), end: Je.end(Je.length - 1) + 0.5 });
            else {
              const $e = function(Tt, Zt) {
                const he = H.get().streaming.buffer.bufferToKeep, qt = Zt.start(0);
                if (Tt - qt > he) {
                  let Me = Math.max(0, Tt - he);
                  const Ve = v.getRequests({ state: Tn.FRAGMENT_MODEL_EXECUTED, time: Tt, threshold: Vt })[0];
                  if (Ve && (Me = Math.min(Ve.startTime, Me)), Me > 0) return { start: qt, end: Me };
                }
                return null;
              }($t, Je), ue = function(Tt, Zt) {
                const he = Zt.end(Zt.length - 1) + 0.5, qt = Ke(Tt), Me = L.manifestInfo.duration >= H.get().streaming.buffer.longFormContentDurationThreshold ? H.get().streaming.buffer.bufferTimeAtTopQualityLongForm : H.get().streaming.buffer.bufferTimeAtTopQuality;
                let Ve = isNaN(qt) ? Tt : Math.min(qt, Tt + Me);
                if (Ve >= Zt.end(Zt.length - 1)) return null;
                const fn = v.getRequests({ state: Tn.FRAGMENT_MODEL_EXECUTED, time: Tt, threshold: Vt })[0];
                if (fn && (Ve = Math.max(fn.startTime + fn.duration, Ve)), H.get().streaming.buffer.avoidCurrentTimeRangePruning) {
                  for (let Bn = 0; Bn < Zt.length; Bn++) if (Zt.start(Bn) <= Tt && Tt <= Zt.end(Bn) && Zt.start(Bn) <= Ve && Ve <= Zt.end(Bn)) {
                    let Sn = Ve;
                    Ve = Bn + 1 < Zt.length ? Zt.start(Bn + 1) : Zt.end(Bn) + 1, G.debug("Buffered range [" + Zt.start(Bn) + ", " + Zt.end(Bn) + "] overlaps with targetTime " + Tt + " and range to be pruned [" + Sn + ", " + he + "], using [" + Ve + ", " + he + "] instead" + (Ve < he ? "" : " (no actual pruning)"));
                    break;
                  }
                }
                return Ve < Zt.end(Zt.length - 1) ? { start: Ve, end: he } : null;
              }($t, Je);
              $e && Se.push($e), ue && Se.push(ue);
            }
            return Se;
          }
          function Wt() {
            (!xt || K === X.A.TEXT && W.isTextEnabled()) && Oe();
          }
          function ie() {
            _n();
          }
          function de() {
            _n(), Pt = NaN;
          }
          function Be($t, Se) {
            if (!mt) return null;
            const Je = mt.getAllBufferRanges();
            let $e, ue, Tt = 0, Zt = 0, he = null, qt = null, Me = 0;
            const Ve = isNaN(Se) ? 0.15 : Se;
            if (Je != null) {
              for (ue = 0, $e = Je.length; ue < $e; ue++) if (Tt = Je.start(ue), Zt = Je.end(ue), he === null) Me = Math.abs(Tt - $t), ($t >= Tt && $t < Zt || Me <= Ve) && (he = Tt, qt = Zt);
              else {
                if (Me = Tt - qt, !(Me <= Ve)) break;
                qt = Zt;
              }
              if (he !== null) return { start: he, end: qt };
            }
            return null;
          }
          function Oe() {
            if (M) {
              let $t = M.getTime() || 0;
              $ && ($t = isNaN(Pt) ? 0 : Pt);
              const Se = H.get().streaming.gaps.jumpGaps && !isNaN(H.get().streaming.gaps.smallGapLimit) ? H.get().streaming.gaps.smallGapLimit : NaN;
              et = Math.max(function(Je, $e) {
                let ue, Tt;
                return H.get().streaming.gaps.jumpGaps && ($e = H.get().streaming.gaps.smallGapLimit), ue = Be(Je, $e), Tt = ue === null ? 0 : ue.end - Je, Tt;
              }($t, Se), 0), Ze(at.A.BUFFER_LEVEL_UPDATED, { mediaType: K, bufferLevel: et }), _n();
            }
          }
          function nn() {
            const $t = ot >= ut - 1, Se = M.getTimeToStreamEnd(L) - et < 1e-5;
            !$t && !Se || F || (mn(!0), G.debug(`checkIfBufferingCompleted trigger BUFFERING_COMPLETED for stream id ${L.id} and type ${K}`));
          }
          function _n() {
            if (K !== X.A.AUDIO && K !== X.A.VIDEO && K !== X.A.MESH) return;
            const $t = M.getLowLatencyModeEnabled() ? H.get().streaming.buffer.lowLatencyStallThreshold : H.get().streaming.buffer.stallThreshold;
            et <= $t && !F ? ke(yt.BUFFER_EMPTY) : (F || et > $t) && ke(yt.BUFFER_LOADED);
          }
          function ke($t) {
            j === $t || $t === yt.BUFFER_EMPTY && M.getTime() === 0 || K === X.A.TEXT && !W.isTextEnabled() || (j = $t, Ze(at.A.BUFFER_LEVEL_STATE_CHANGED, { state: $t }), Ze($t === yt.BUFFER_LOADED ? at.A.BUFFER_LOADED : at.A.BUFFER_EMPTY), G.debug($t === yt.BUFFER_LOADED ? "Got enough buffer to start" : "Waiting for more buffer before starting playback"));
          }
          function rn() {
            mt && K !== X.A.TEXT && (F || Nn(Cn()));
          }
          function Cn() {
            const $t = [], Se = mt.getAllBufferRanges();
            if (!Se || Se.length === 0) return $t;
            const Je = M.getTime();
            let $e = Math.max(0, Je - H.get().streaming.buffer.bufferToKeep);
            const ue = v.getRequests({ state: Tn.FRAGMENT_MODEL_EXECUTED, time: Je, threshold: Vt })[0];
            if (ue) $e = Math.min(ue.startTime, $e);
            else if (Je === 0 && M.getIsDynamic()) return [];
            if (Se.start(0) <= $e) {
              const Tt = { start: 0, end: $e };
              for (let Zt = 0; Zt < Se.length && Se.end(Zt) <= $e; Zt++) Tt.end = Se.end(Zt);
              Tt.start < Tt.end && $t.push(Tt);
            }
            return $t;
          }
          function Nn($t) {
            return new Promise((Se, Je) => {
              if (!$t || !mt || $t.length === 0) return Oe(), void Se();
              const $e = [];
              $t.forEach((ue) => {
                $e.push(function(Tt) {
                  return new Promise((Zt, he) => {
                    Tt.resolve = Zt, Tt.reject = he, Rt.push(Tt);
                  });
                }(ue));
              }), _t || Gn(), Promise.all($e).then(() => {
                Se();
              }).catch((ue) => {
                Je(ue);
              });
            });
          }
          function Gn() {
            try {
              if (Rt.length === 0 || !mt) return G.debug("Nothing to prune, halt pruning"), Rt = [], void (_t = !1);
              const $t = mt.getBuffer();
              if (!$t || !$t.buffered || $t.buffered.length === 0) return G.debug("SourceBuffer is empty (or does not exist), halt pruning"), Rt = [], void (_t = !1);
              const Se = Rt.shift();
              G.debug(`${K}: Removing buffer from: ${Se.start} to ${Se.end}`), _t = !0, M.getTime() < Se.end && mn(!1), mt.remove(Se).then((Je) => {
                Xt(Je);
              }).catch((Je) => {
                Xt(Je);
              });
            } catch ($t) {
              _t = !1;
            }
          }
          function Xt($t) {
            G.debug("onRemoved buffer from:", $t.from, "to", $t.to), mt && (ft(mt.getAllBufferRanges()), Rt.length === 0 && (_t = !1, Oe()), $t.unintended && (G.warn("Detected unintended removal from:", $t.from, "to", $t.to, "setting streamprocessor time to", $t.from), Ze(at.A.SEEK_TARGET, { time: $t.from })), _t ? Gn() : (xt ? xt = !1 : Oe(), Ze(at.A.BUFFER_CLEARED, { from: $t.from, to: $t.to, unintended: $t.unintended, hasEnoughSpaceToAppend: qe(), quotaExceeded: Ct })));
          }
          function ce($t) {
            return new Promise((Se) => {
              $t && $t.mseTimeOffset !== void 0 && mt && mt.updateTimestampOffset ? mt.updateTimestampOffset($t.mseTimeOffset).then(() => {
                Se();
              }).catch(() => {
                Se();
              }) : Se();
            });
          }
          function oe() {
            return mt && !F ? mt.updateAppendWindow(L) : Promise.resolve();
          }
          function pe() {
            ht++, ht * (H.get().streaming.wallclockTimeUpdateInterval / 1e3) >= H.get().streaming.buffer.bufferPruningInterval && (ht = 0, rn());
          }
          function en() {
            _n();
          }
          function mn($t) {
            F = $t, F ? Ze(at.A.BUFFERING_COMPLETED) : ut = Number.POSITIVE_INFINITY;
          }
          function se() {
            try {
              const $t = mt.getAllBufferRanges();
              let Se, Je, $e = 0;
              if (!$t) return $e;
              for (Je = 0, Se = $t.length; Je < Se; Je++) $e += $t.end(Je) - $t.start(Je);
              return $e;
            } catch ($t) {
              return 0;
            }
          }
          function Ke($t) {
            try {
              let Se = $t;
              const Je = mt.getAllBufferRanges();
              if (!Je || Je.length === 0) return NaN;
              let $e = 0;
              for (; Se === $t && $e < Je.length; ) {
                const ue = Je.start($e), Tt = Je.end($e);
                Se >= ue && Se <= Tt && (Se = Tt), $e += 1;
              }
              return Se === $t ? NaN : Se;
            } catch (Se) {
              return NaN;
            }
          }
          function qe() {
            const $t = se();
            return isNaN($t) || $t < it;
          }
          function Ze($t, Se) {
            let Je = Se || {};
            _.trigger($t, Je, { streamId: L.id, mediaType: K });
          }
          function tn($t, Se) {
            if (it = Number.POSITIVE_INFINITY, j = void 0, ut = Number.POSITIVE_INFINITY, ot = 0, J = null, F = !1, _t = !1, Ct = !1, et = 0, ht = 0, Rt = [], Pt = NaN, $ = !1, mt) {
              let Je = mt;
              mt = null, $t || (Se ? Je.removeEventListeners() : Je.abort().then(() => {
                Je.reset(Se), Je = null;
              }));
            }
            xt = !1;
          }
          return R = { appendInitSegmentFromCache: function($t) {
            const Se = bt.extract(L.id, $t);
            return !!Se && (G.debug(`Appending init fragment for type ${K}, representationId ${Se.representation.id} and bandwidth ${Se.representation.bandwidth}`), nt(Se), !0);
          }, clearBuffers: Nn, createBufferSink: ct, dischargePreBuffer: function() {
            if (mt && wt && typeof wt.discharge == "function") {
              const $t = wt.getAllBufferRanges();
              if ($t.length > 0) {
                let $e = "Beginning " + K + "PreBuffer discharge, adding buffer for:";
                for (let ue = 0; ue < $t.length; ue++) $e += " start: " + $t.start(ue) + ", end: " + $t.end(ue) + ";";
                G.debug($e);
              } else G.debug("PreBuffer discharge requested, but there were no media segments in the PreBuffer.");
              P = [];
              let Se = wt.discharge(), Je = null;
              for (let $e = 0; $e < Se.length; $e++) {
                const ue = Se[$e];
                if (ue.segmentType !== Ht.G.INIT_SEGMENT_TYPE) {
                  const Tt = bt.extract(ue.streamId, ue.representation.id);
                  Tt && Je !== Tt && (P.push(Tt), mt.append(Tt), Je = Tt);
                }
                P.push(ue), mt.append(ue);
              }
              wt.reset(), wt = null;
            }
          }, getAllRangesWithSafetyFactor: Ut, getBuffer: function() {
            return mt;
          }, getBufferControllerType: function() {
            return Jt;
          }, getBufferLevel: function() {
            return et;
          }, getContinuousBufferTimeForTargetTime: Ke, getIsBufferingCompleted: function() {
            return F;
          }, getIsPruningInProgress: function() {
            return _t;
          }, getMediaSource: function() {
            return st;
          }, getRangeAt: Be, getStreamId: function() {
            return L.id;
          }, getType: function() {
            return K;
          }, hasBufferAtTime: function($t) {
            try {
              const Se = mt.getAllBufferRanges();
              if (!Se || Se.length === 0) return !1;
              let Je = 0;
              for (; Je < Se.length; ) {
                const $e = Se.start(Je), ue = Se.end(Je);
                if ($t >= $e && $t <= ue) return !0;
                Je += 1;
              }
              return !1;
            } catch (Se) {
              return G.error(Se), !1;
            }
          }, initialize: function($t) {
            N($t), _.on(at.A.INIT_FRAGMENT_LOADED, It, R), _.on(at.A.MEDIA_FRAGMENT_LOADED, dt, R), _.on(at.A.WALLCLOCK_TIME_UPDATED, pe, R), _.on(At.A.PLAYBACK_PLAYING, de, R), _.on(At.A.PLAYBACK_PROGRESS, Wt, R), _.on(At.A.PLAYBACK_TIME_UPDATED, Wt, R), _.on(At.A.PLAYBACK_RATE_CHANGED, en, R), _.on(At.A.PLAYBACK_STALLED, ie, R);
          }, prepareForAbandonQualitySwitch: function($t, Se) {
            return Et($t, Se);
          }, prepareForDefaultQualitySwitch: function($t, Se) {
            return Et($t, Se);
          }, prepareForFastQualitySwitch: function($t, Se) {
            return Et($t, Se);
          }, prepareForForceReplacementQualitySwitch: function($t, Se) {
            return new Promise((Je) => {
              const $e = [];
              $e.push(mt.abort()), $e.push(oe()), $e.push(Dt()), $e.push(ce($t)), $e.push(kt($t, Se)), Promise.allSettled($e).then(() => {
                mn(!1), Je();
              });
            });
          }, prepareForNonReplacementTrackSwitch: function($t, Se) {
            return new Promise((Je) => {
              const $e = [];
              $e.push(oe()), $e.push(kt($t, Se)), Promise.allSettled($e).then(() => {
                Je();
              });
            });
          }, prepareForPlaybackSeek: function() {
            return F && mn(!1), mt.abort();
          }, prepareForReplacementTrackSwitch: function($t, Se) {
            return new Promise((Je) => {
              const $e = [];
              $e.push(mt.abort()), $e.push(oe()), $e.push(kt($t, Se)), $e.push(Dt()), $e.push(ce($t)), Promise.allSettled($e).then(() => {
                mn(!1), Je();
              });
            });
          }, pruneAllSafely: Dt, pruneBuffer: rn, reset: function($t, Se) {
            _.off(at.A.INIT_FRAGMENT_LOADED, It, this), _.off(at.A.MEDIA_FRAGMENT_LOADED, dt, this), _.off(at.A.WALLCLOCK_TIME_UPDATED, pe, this), _.off(At.A.PLAYBACK_PLAYING, de, this), _.off(At.A.PLAYBACK_PROGRESS, Wt, this), _.off(At.A.PLAYBACK_TIME_UPDATED, Wt, this), _.off(At.A.PLAYBACK_RATE_CHANGED, en, this), _.off(At.A.PLAYBACK_STALLED, ie, this), tn($t, Se);
          }, segmentRequestingCompleted: function($t) {
            isNaN($t) || (ut = $t, nn());
          }, setIsBufferingCompleted: mn, setMediaSource: N, setSeekTarget: function($t) {
            Pt = $t;
          }, updateAppendWindow: oe, updateBufferTimestampOffset: ce }, G = (0, jt.A)(C).getInstance().getLogger(R), bt = ee(C).getInstance(), tn(), R;
        }
        Ot.__dashjs_factory_name = Jt;
        var Kt = Bt.A.getClassFactory(Ot);
        const ae = "NotFragmentedTextBufferController";
        function Qt(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = A.textController, v = A.errHandler, M = A.streamInfo, Y = A.type;
          let H, L, W, K, R, G;
          function F(st) {
            K = st;
          }
          function et(st) {
            L !== st && (L = st, L && function(ot) {
              let ut = {};
              C.trigger(ot, ut, { streamId: M.id, mediaType: Y });
            }(at.A.BUFFERING_COMPLETED));
          }
          function it(st) {
            st.chunk.bytes && !L && (G.save(st.chunk), R.append(st.chunk), et(!0));
          }
          return H = { initialize: function(st) {
            F(st);
          }, getStreamId: function() {
            return M.id;
          }, getType: function() {
            return Y;
          }, getBufferControllerType: function() {
            return ae;
          }, createBufferSink: function(st) {
            return new Promise((ot, ut) => {
              try {
                R = U(f).create({ mediaSource: K, textController: _, eventBus: C }), R.initializeForFirstUse(st), W || (R.getBuffer() && typeof R.getBuffer().initialize == "function" && R.getBuffer().initialize(), W = !0), ot(R);
              } catch (mt) {
                v.error(new Nt.A(q.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, q.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + Y)), ut(mt);
              }
            });
          }, dischargePreBuffer: function() {
          }, getBuffer: function() {
            return R;
          }, getBufferLevel: function() {
            return 0;
          }, getRangeAt: function() {
            return null;
          }, pruneBuffer: function() {
          }, hasBufferAtTime: function() {
            return !0;
          }, getAllRangesWithSafetyFactor: function() {
            return [];
          }, getContinuousBufferTimeForTargetTime: function() {
            return Number.POSITIVE_INFINITY;
          }, setMediaSource: F, getMediaSource: function() {
            return K;
          }, appendInitSegmentFromCache: function(st) {
            return G.extract(M.id, st) !== null;
          }, getIsBufferingCompleted: function() {
            return L;
          }, setIsBufferingCompleted: et, getIsPruningInProgress: function() {
            return !1;
          }, reset: function(st) {
            C.off(at.A.INIT_FRAGMENT_LOADED, it, H), !st && R && (R.abort(), R.reset(), R = null);
          }, clearBuffers: function() {
            return Promise.resolve();
          }, prepareForPlaybackSeek: function() {
            return Promise.resolve();
          }, prepareForReplacementTrackSwitch: function() {
            return L = !1, Promise.resolve();
          }, setSeekTarget: function() {
          }, updateAppendWindow: function() {
            return Promise.resolve();
          }, pruneAllSafely: function() {
            return Promise.resolve();
          }, updateBufferTimestampOffset: function() {
            return Promise.resolve();
          }, segmentRequestingCompleted: function() {
          } }, W = !1, K = null, L = !1, G = ee(f).getInstance(), C.on(at.A.INIT_FRAGMENT_LOADED, it, H), H;
        }
        Qt.__dashjs_factory_name = ae;
        var me = Bt.A.getClassFactory(Qt);
        function an(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = A.dashMetrics, v = A.mediaPlayerModel, M = A.fragmentModel, Y = A.abrController, H = A.playbackController, L = A.textController, W = A.type, K = A.bufferController, R = A.representationController, G = A.settings;
          let F, et, it, st, ot, ut, mt, wt, $, P, j, J;
          function ht() {
            j = !0;
          }
          function _t() {
            j = !1;
          }
          function Ct(ft) {
            if (K.getIsBufferingCompleted()) return;
            bt();
            const rt = isNaN(ft) ? 0 : ft;
            ot = setTimeout(Rt, rt);
          }
          function bt() {
            ot && (clearTimeout(ot), ot = null);
          }
          function Rt() {
            try {
              if (function() {
                try {
                  return W === X.A.TEXT && !L.isTextEnabled() || H.isPaused() && (!H.getStreamController().getInitialPlayback() || !H.getStreamController().getAutoPlay()) && !G.get().streaming.scheduling.scheduleWhilePaused;
                } catch (ft) {
                  return !1;
                }
              }()) return void bt();
              if (function() {
                try {
                  return !!j && R.getCurrentRepresentation() && (wt == null || $ || function() {
                    const ft = R.getCurrentRepresentation();
                    if (!W || !ft) return !0;
                    let rt = ft && ft.segmentDuration && !isNaN(ft.segmentDuration) ? ft.segmentDuration : 0;
                    const Et = _.getCurrentBufferLevel(W), kt = xt();
                    return (kt <= rt || H.getLowLatencyModeEnabled() || W === X.A.AUDIO && ut) && (rt = 0), Et + rt < kt;
                  }());
                } catch (ft) {
                  return !1;
                }
              }()) {
                let ft = !1;
                J && (ft = Y.checkPlaybackQuality(W, et.id)), ft || function() {
                  const rt = R.getCurrentRepresentation();
                  P || rt.id !== wt || $ ? ($ ? (it.debug("Switch track for " + W + ", representation id = " + rt.id), $ = !1) : it.debug("Quality has changed, get init request for representationid = " + rt.id), W === X.A.MESH && (J = !1, P = !1, window.initMesh = !0), C.trigger(at.A.INIT_FRAGMENT_NEEDED, { representationId: rt.id, sender: F }, { streamId: et.id, mediaType: W }), J = !1, P = !1) : (it.debug(`Media segment needed for ${W} and stream id ${et.id}`), C.trigger(at.A.MEDIA_FRAGMENT_NEEDED, {}, { streamId: et.id, mediaType: W }), J = !0);
                }();
              } else Ct(H.getLowLatencyModeEnabled() ? G.get().streaming.scheduling.lowLatencyTimeout : G.get().streaming.scheduling.defaultTimeout);
            } catch (ft) {
              Ct(H.getLowLatencyModeEnabled() ? G.get().streaming.scheduling.lowLatencyTimeout : G.get().streaming.scheduling.defaultTimeout);
            }
          }
          function xt() {
            let ft = NaN;
            const rt = R.getCurrentRepresentation();
            return W && rt && (ft = W === X.A.TEXT ? function() {
              try {
                if (L.isTextEnabled()) {
                  const Et = R.getCurrentRepresentation();
                  if (isNaN(Et.fragmentDuration)) {
                    const kt = _.getCurrentSchedulingInfo(yt.SCHEDULING_INFO);
                    return kt ? kt.duration : 0;
                  }
                  return Et.fragmentDuration;
                }
                return 0;
              } catch (Et) {
                return 0;
              }
            }() : W === X.A.AUDIO && ut ? function() {
              try {
                const Et = _.getCurrentBufferLevel(X.A.VIDEO), kt = R.getCurrentRepresentation();
                return isNaN(kt.fragmentDuration) ? Et + 1 : Math.max(Et + 1, kt.fragmentDuration);
              } catch (Et) {
                return 0;
              }
            }() : function() {
              try {
                const Et = R.getCurrentRepresentation(), kt = Et.mediaInfo.streamInfo;
                return Y.isPlayingAtTopQuality(Et) ? kt.manifestInfo.duration >= G.get().streaming.buffer.longFormContentDurationThreshold ? G.get().streaming.buffer.bufferTimeAtTopQualityLongForm : G.get().streaming.buffer.bufferTimeAtTopQuality : v.getBufferTimeDefaultUnadjusted();
              } catch (Et) {
                return v.getBufferTimeDefaultUnadjusted();
              }
            }()), ft;
          }
          function Pt() {
            N(!0);
          }
          function N(ft) {
            if (H && M) {
              const rt = M.getRequests({ state: Tn.FRAGMENT_MODEL_EXECUTED, time: H.getTime(), threshold: 0 })[0];
              rt && H.getTime() >= rt.startTime && ((!mt.representation || rt.representation.mediaInfo.type === mt.representation.mediaInfo.type && rt.representation.mediaInfo.index !== mt.representation.mediaInfo.index) && ft && (it.debug(`Track change rendered for streamId ${et.id} and type ${W}`), C.trigger(at.A.TRACK_CHANGE_RENDERED, { mediaType: W, oldMediaInfo: mt && mt.representation && mt.representation.mediaInfo ? mt.representation.mediaInfo : null, newMediaInfo: rt.representation.mediaInfo, streamId: et.id })), mt.representation && rt.representation.id === mt.representation.id || !ft || (it.debug(`Quality change rendered for streamId ${et.id} and type ${W}`), C.trigger(at.A.QUALITY_CHANGE_RENDERED, { mediaType: W, oldRepresentation: mt.representation ? mt.representation : null, newRepresentation: rt.representation, streamId: et.id })), mt.representation = rt.representation);
            }
          }
          function ct() {
            M.abortRequests(), bt();
          }
          function It() {
            G.get().streaming.scheduling.scheduleWhilePaused || Ct();
          }
          function dt(ft) {
            _.updatePlayListTraceMetrics({ playbackspeed: ft.playbackRate.toString() });
          }
          function nt() {
            J = !0, st = 0, wt = null, mt = { representation: null }, $ = !1, P = !1, j = !0;
          }
          return F = { clearScheduleTimer: bt, getBufferTarget: xt, getPlaybackController: function() {
            return H;
          }, getStreamId: function() {
            return et.id;
          }, getSwitchTrack: function() {
            return $;
          }, getTimeToLoadDelay: function() {
            return st;
          }, getType: function() {
            return W;
          }, initialize: function(ft) {
            ut = ft, C.on(at.A.URL_RESOLUTION_FAILED, ct, F), C.on(At.A.PLAYBACK_STARTED, It, F), C.on(At.A.PLAYBACK_RATE_CHANGED, dt, F), C.on(At.A.PLAYBACK_TIME_UPDATED, Pt, F), C.on(At.A.MANAGED_MEDIA_SOURCE_START_STREAMING, ht, F), C.on(At.A.MANAGED_MEDIA_SOURCE_END_STREAMING, _t, F);
          }, reset: function() {
            C.off(at.A.URL_RESOLUTION_FAILED, ct, F), C.off(At.A.PLAYBACK_STARTED, It, F), C.off(At.A.PLAYBACK_RATE_CHANGED, dt, F), C.off(At.A.PLAYBACK_TIME_UPDATED, Pt, F), C.off(At.A.MANAGED_MEDIA_SOURCE_START_STREAMING, ht, F), C.off(At.A.MANAGED_MEDIA_SOURCE_END_STREAMING, _t, F), bt(), N(!1), nt(), et = null;
          }, setCheckPlaybackQuality: function(ft) {
            J = ft;
          }, setInitSegmentRequired: function(ft) {
            P = ft;
          }, setLastInitializedRepresentationId: function(ft) {
            wt = ft;
          }, setSwitchTrack: function(ft) {
            $ = ft;
          }, setTimeToLoadDelay: function(ft) {
            st = ft;
          }, startScheduleTimer: Ct }, it = (0, jt.A)(f).getInstance().getLogger(F), nt(), et = A.streamInfo, F;
        }
        an.__dashjs_factory_name = "ScheduleController";
        var Ge = Bt.A.getClassFactory(an);
        const Te = /\$(RepresentationID|Number|SubNumber|Bandwidth|Time)?(?:%0([0-9]+)([diouxX]))?\$/g;
        var ge = class {
          constructor() {
            this.availabilityEndTime = NaN, this.availabilityStartTime = NaN, this.duration = NaN, this.index = null, this.indexRange = null, this.media = null, this.mediaRange = null, this.mediaStartTime = NaN, this.presentationStartTime = NaN, this.replacementNumber = NaN, this.replacementTime = null, this.representation = null, this.wallStartTime = NaN;
          }
        };
        function ze(A, f, C, _, v, M, Y, H) {
          let L = new ge();
          var W;
          return L.representation = A, L.duration = f, L.presentationStartTime = C, L.mediaStartTime = _, L.availabilityStartTime = v.calcAvailabilityStartTimeFromPresentationTime(M, A, Y), L.availabilityEndTime = v.calcAvailabilityEndTimeFromPresentationTime(M + f, A, Y), L.wallStartTime = v.calcWallTimeForSegment(L, Y), L.replacementNumber = (W = H, L.representation.startNumber + W), L.index = H, L;
        }
        function Zn(A, f, C, _) {
          const v = f.adaptation.period;
          if (isFinite(v.duration) && v.start + v.duration <= C.presentationStartTime) return !1;
          if (_) {
            if (f.availabilityTimeOffset === "INF") return !0;
            const M = A.getClientReferenceTime();
            return C.availabilityStartTime.getTime() <= M && (!isFinite(C.availabilityEndTime) || C.availabilityEndTime.getTime() >= M);
          }
          return !0;
        }
        function qn(A, f, C, _, v, M) {
          return A && function(Y, H, L, W, K, R) {
            return Y.replace(Te, (G, F, et, it) => {
              let st, ot;
              switch (F) {
                case void 0:
                  return "$";
                case "RepresentationID":
                  st = H;
                  break;
                case "Number":
                  st = L;
                  break;
                case "SubNumber":
                  st = W;
                  break;
                case "Bandwidth":
                  st = K;
                  break;
                case "Time":
                  if (typeof R == "string") return R;
                  st = R && Math.round(R);
                  break;
                default:
                  st = null;
              }
              if (st == null) return G;
              switch (it) {
                case void 0:
                case "d":
                case "i":
                case "u":
                  ot = st.toString();
                  break;
                case "o":
                  ot = st.toString(8);
                  break;
                case "x":
                  ot = st.toString(16);
                  break;
                case "X":
                  ot = st.toString(16).toUpperCase();
                  break;
                default:
                  ot = st.toString();
              }
              const ut = parseInt(et, 10) || 1;
              return ot.padStart(ut, "0");
            });
          }(A, f, C, _, v, M);
        }
        function Aa(A, f, C, _) {
          let v, M, Y;
          v = C.segmentDuration, isNaN(v) && (v = C.adaptation.period.duration), M = parseFloat((C.adaptation.period.start + _ * v).toFixed(5)), Y = parseFloat((M + v).toFixed(5));
          const H = ze(C, v, M, A.calcMediaTimeFromPresentationTime(M, C), A, Y, f, _);
          return Zn(A, C, H, f) ? H : null;
        }
        function Hn(A, f, C, _, v, M, Y, H, L, W) {
          const K = _ / M, R = v / M;
          let G, F, et;
          return G = A.calcPresentationTimeFromMediaTime(K, C), F = G + R, et = ze(C, R, G, K, A, F, f, L), Zn(A, C, et, f) ? (et.replacementTime = W || _, et.media = qn(Y, void 0, et.replacementNumber, void 0, void 0, et.replacementTime), et.mediaRange = H, et) : null;
        }
        function xa(A) {
          const f = (A = A || {}).eventBus, C = A.events, _ = A.abrController, v = A.dashMetrics, M = A.playbackController, Y = A.timelineConverter, H = A.type, L = A.streamInfo, W = A.segmentsController, K = A.isDynamic;
          let R, G, F;
          function et() {
            return H;
          }
          function it() {
            return F;
          }
          function st() {
            F = null, G = [];
          }
          function ot(P) {
            return new Promise((j, J) => {
              const ht = P.hasInitialization(), _t = P.hasSegments(), Ct = [];
              Ct.push(W.updateInitData(P, ht)), Ct.push(W.updateSegmentData(P, _t)), Promise.all(Ct).then((bt) => {
                var Rt;
                bt[0] && !bt[0].error && (P = function(xt, Pt) {
                  return Pt && !Pt.error && Pt.representation ? Pt.representation : xt;
                }(P, bt[0])), bt[1] && !bt[1].error && (P = function(xt, Pt) {
                  if (!Pt || Pt.error) return;
                  const N = Pt.segments, ct = [];
                  let It, dt, nt, ft, rt = 0;
                  for (It = 0, dt = N ? N.length : 0; It < dt; It++) nt = N[It], ft = Hn(Y, K, xt, nt.startTime, nt.duration, nt.timescale, nt.media, nt.mediaRange, rt), ft && (ct.push(ft), ft = null, rt++);
                  return ct.length > 0 && (xt.segments = ct), xt;
                }(P, bt[1])), P.fragmentDuration = P.segmentDuration ? P.segmentDuration : P.segments && P.segments.length > 0 ? P.segments[0].duration : NaN, (Rt = P).mediaFinishedInformation = W.getMediaFinishedInformation(Rt), function(xt) {
                  let Pt, N = v.getCurrentManifestUpdate(), ct = !1;
                  if (N) {
                    for (let It = 0; It < N.representationInfo.length; It++) if (Pt = N.representationInfo[It], Pt.index === xt.index && Pt.mediaType === et()) {
                      ct = !0;
                      break;
                    }
                    ct || v.addManifestUpdateRepresentationInfo(xt, et());
                  }
                }(P), j();
              }).catch((bt) => {
                J(bt);
              });
            });
          }
          function ut(P) {
            if (!G || G.length === 0) return null;
            const j = G.filter((J) => J.id === P);
            return j.length > 0 ? j[0] : null;
          }
          function mt(P) {
            f.trigger(C.DATA_UPDATE_COMPLETED, { currentRepresentation: F, error: P }, { streamId: L.id, mediaType: H });
          }
          function wt(P) {
            F && F.id === P.id || function(j) {
              (function() {
                if (!(_ && v && M && Y)) throw new Error(X.A.MISSING_CONFIG_ERROR);
              })();
              const J = /* @__PURE__ */ new Date(), ht = 1e3 * M.getTime();
              j && v.addRepresentationSwitch(j.adaptation.type, J, ht, j.id), f.trigger(At.A.REPRESENTATION_SWITCH, { mediaType: H, streamId: L.id, currentRepresentation: j }, { streamId: L.id, mediaType: H });
            }(P), F = P;
          }
          function $(P) {
            if (P.newDuration) {
              const j = it();
              j && j.adaptation.period && (j.adaptation.period.duration = P.newDuration);
            }
          }
          return R = { getCurrentRepresentation: it, getRepresentationById: ut, getStreamId: function() {
            return L.id;
          }, getType: et, prepareQualityChange: function(P) {
            const j = G.filter((J) => J.id === P.id);
            j.length > 0 && wt(j[0]);
          }, reset: function() {
            f.off(At.A.MANIFEST_VALIDITY_CHANGED, $, R), st();
          }, updateData: function(P, j, J) {
            return new Promise((ht, _t) => {
              if (G = P, wt(ut(J)), H !== X.A.VIDEO && H !== X.A.AUDIO && H !== X.A.MESH && (H !== X.A.TEXT || !j)) return mt(), void ht();
              const Ct = [];
              for (let bt = 0, Rt = G.length; bt < Rt; bt++) {
                const xt = G[bt];
                Ct.push(ot(xt));
              }
              Promise.all(Ct).then(() => {
                (function() {
                  _.setPlaybackQuality(H, L, F);
                  const bt = v.getCurrentDVRInfo(H);
                  bt && v.updateManifestUpdateInfo({ latency: bt.range.end - M.getTime() }), mt();
                })(), ht();
              }).catch((bt) => {
                _t(bt);
              });
            });
          } }, st(), f.on(At.A.MANIFEST_VALIDITY_CHANGED, $, R), R;
        }
        xa.__dashjs_factory_name = "RepresentationController";
        var Ee = Bt.A.getClassFactory(xa), xe = w(656);
        function Re(A) {
          const f = (A = A || {}).eventBus, C = A.debug, _ = A.urlUtils, v = A.type, M = A.streamInfo, Y = A.segmentsController, H = A.timelineConverter, L = A.baseURLController;
          let W, K, R, G, F;
          function et() {
            return v;
          }
          function it() {
            R = null;
          }
          function st($, P, j) {
            const J = L.resolve(j.path);
            let ht, _t, Ct = {};
            return J && P !== J.url && _.isRelative(P) ? (ht = J.url, _t = J.serviceLocation, Ct = J.queryParams, P && (ht = _.resolve(P, ht))) : ht = P, !_.isRelative(ht) && ($.url = ht, $.serviceLocation = _t, $.queryParams = Ct, !0);
          }
          function ot($, P) {
            if (P == null) return null;
            const j = new sn(), J = P.representation, ht = J.bandwidth, _t = qn(P.media, J.id, P.replacementNumber, void 0, ht, P.replacementTime);
            return j.mediaType = et(), j.bandwidth = J.bandwidth, j.type = Ht.G.MEDIA_SEGMENT_TYPE, j.range = P.mediaRange, j.startTime = P.presentationStartTime, j.mediaStartTime = P.mediaStartTime, j.duration = P.duration, j.timescale = J.timescale, j.availabilityStartTime = P.availabilityStartTime, j.availabilityEndTime = P.availabilityEndTime, j.availabilityTimeComplete = J.availabilityTimeComplete, j.wallStartTime = P.wallStartTime, j.index = P.index, j.adaptationIndex = J.adaptation.index, j.representation = J, st(j, _t, J) ? j : void 0;
          }
          function ut($, P, j) {
            let J = null;
            if (!P || !P.segmentInfoType) return J;
            const ht = Y.getSegmentByTime(P, j);
            return ht && (R = ht, K.debug("Index for time " + j + " is " + ht.index), J = ot(0, ht)), J;
          }
          function mt($, P, j) {
            let J = null;
            const ht = Y.getSegmentByIndex(P, j, R ? R.mediaStartTime : -1);
            if (ht) J = ot(0, ht), R = ht;
            else {
              if (G && !F) return K.debug(et() + " No segment found at index: " + j + ". Wait for next loop"), null;
              F = !0;
            }
            return J;
          }
          function wt() {
            K.debug("Dynamic stream complete"), F = !0;
          }
          return W = { getCurrentIndex: function() {
            return R ? R.index : -1;
          }, getInitRequest: function($, P) {
            return P ? function(j, J, ht) {
              const _t = new sn(), Ct = J.adaptation.period, bt = Ct.start;
              if (_t.mediaType = ht, _t.type = Ht.G.INIT_SEGMENT_TYPE, _t.range = J.range, _t.availabilityStartTime = H.calcAvailabilityStartTimeFromPresentationTime(bt, J, G), _t.availabilityEndTime = H.calcAvailabilityEndTimeFromPresentationTime(bt + Ct.duration, J, G), _t.representation = J, st(_t, J.initialization, J)) return _t.url = qn(_t.url, void 0, void 0, void 0, J.bandwidth), _t;
            }(0, P, et()) : null;
          }, getNextSegmentRequest: function($, P) {
            if (!P || !P.segmentInfoType) return null;
            let j = R ? R.index + 1 : 0;
            return P && R && P.endNumber && R.replacementNumber && R.replacementNumber >= P.endNumber ? (F = !0, null) : mt(0, P, j);
          }, getNextSegmentRequestIdempotent: function($, P) {
            let j = null, J = R ? R.index + 1 : 0;
            const ht = Y.getSegmentByIndex(P, J, R ? R.mediaStartTime : -1);
            return ht ? (j = ot(0, ht), j) : null;
          }, getSegmentRequestForTime: ut, getStreamId: function() {
            return M.id;
          }, getStreamInfo: function() {
            return M;
          }, getType: et, getValidTimeAheadOfTargetTime: function($, P, j, J) {
            try {
              if (isNaN($) || !P || !j) return NaN;
              if ($ < 0 && ($ = 0), isNaN(J) && (J = 0.5), ut(0, j, $)) return $;
              if (j.adaptation.period.start + j.adaptation.period.duration < $) return NaN;
              const ht = isFinite(j.adaptation.period.duration) ? j.adaptation.period.start + j.adaptation.period.duration : $ + 30;
              let _t = Math.min($ + J, ht), Ct = NaN, bt = null;
              for (; _t <= ht; ) {
                let Rt = null;
                if (_t <= ht && (Rt = ut(0, j, _t)), Rt) {
                  Ct = _t, bt = Rt;
                  break;
                }
                _t += J;
              }
              if (bt) {
                const Rt = bt.startTime + bt.duration;
                return $ > bt.startTime && Rt - $ > J ? $ : !isNaN(bt.startTime) && $ < bt.startTime && Ct > bt.startTime ? bt.startTime + 1e-3 : Math.min(Rt - J, Ct);
              }
              return Ct;
            } catch (ht) {
              return NaN;
            }
          }, initialize: function($) {
            G = $, F = !1, Y.initialize($);
          }, isLastSegmentRequested: function($, P) {
            return !$ || !R ? !1 : F ? !0 : !isFinite($.adaptation.period.duration) || R.presentationStartTime + R.duration > P ? !1 : $.mediaFinishedInformation && !isNaN($.mediaFinishedInformation.numberOfSegments) && !isNaN(R.index) && R.index >= $.mediaFinishedInformation.numberOfSegments - 1 && (!G || $.segmentInfoType === D.A.SEGMENT_TEMPLATE || G && $.segmentInfoType === D.A.SEGMENT_LIST && $.adaptation.period.nextPeriodId) ? !0 : !!(G && $.adaptation.period.nextPeriodId && $.segmentInfoType === D.A.SEGMENT_TIMELINE && $.mediaFinishedInformation && !isNaN($.mediaFinishedInformation.mediaTimeOfLastSignaledSegment) && R && !isNaN(R.mediaStartTime) && !isNaN(R.duration) && R.mediaStartTime + R.duration >= $.mediaFinishedInformation.mediaTimeOfLastSignaledSegment - 0.05);
          }, repeatSegmentRequest: function($, P) {
            return P && P.segmentInfoType ? mt(0, P, R ? R.index : 0) : null;
          }, reset: function() {
            it(), f.off(At.A.DYNAMIC_TO_STATIC, wt, W);
          } }, K = C.getLogger(W), it(), f.on(At.A.DYNAMIC_TO_STATIC, wt, W), W;
        }
        Re.__dashjs_factory_name = "DashHandler";
        var Ie = Bt.A.getClassFactory(Re);
        function Ne() {
          let A;
          const f = /^[a-z][a-z0-9+\-_.]*:/i, C = /^https?:\/\//i, _ = /^https:\/\//i, v = /^([a-z][a-z0-9+\-_.]*:\/\/[^\/]+)\/?/i, M = (F, et) => {
            try {
              return new window.URL(F, et).toString();
            } catch (it) {
              return F;
            }
          }, Y = (F, et) => {
            let it = H;
            if (!et || !K(F)) return F;
            R(F) && (it = L), G(F) && (it = W);
            const st = it(et), ot = st.charAt(st.length - 1) !== "/" && F.charAt(0) !== "/" ? "/" : "";
            return [st, F].join(ot);
          };
          function H(F) {
            const et = F.indexOf("/"), it = F.lastIndexOf("/");
            return et !== -1 ? it === et + 1 ? F : (F.indexOf("?") !== -1 && (F = F.substring(0, F.indexOf("?"))), F.substring(0, it + 1)) : "";
          }
          function L(F) {
            const et = F.match(v);
            return et ? et[1] : "";
          }
          function W(F) {
            const et = F.match(f);
            return et ? et[0] : "";
          }
          function K(F) {
            return !f.test(F);
          }
          function R(F) {
            return K(F) && F.charAt(0) === "/";
          }
          function G(F) {
            return F.indexOf("//") === 0;
          }
          return function() {
            try {
              new window.URL("x", "http://y"), A = M;
            } catch (F) {
            } finally {
              A = A || Y;
            }
          }(), { parseBaseUrl: H, parseOrigin: L, parseScheme: W, isRelative: K, isPathAbsolute: R, isSchemeRelative: G, isHTTPURL: function(F) {
            return C.test(F);
          }, isHTTPS: function(F) {
            return _.test(F);
          }, removeHostname: function(F) {
            return /^(?:\w+\:\/\/)?([^\/]+)(.*)$/.exec(F)[2].substring(1);
          }, resolve: function(F, et) {
            return A(F, et);
          } };
        }
        Ne.__dashjs_factory_name = "DefaultURLUtils";
        var Ue = Bt.A.getSingletonFactory(Ne);
        function Xe() {
          let A, f, C = [];
          const _ = this.context;
          function v(M, Y, H) {
            let L = function(W) {
              let K;
              for (K = 0; K < C.length; K++) if (C[K].regex.test(W)) return C[K].utils;
              return f;
            }(H || Y);
            return L && typeof L[M] == "function" ? L[M](Y, H) : f[M](Y, H);
          }
          return f = Ue(_).getInstance(), A = { registerUrlRegex: function(M, Y) {
            C.push({ regex: M, utils: Y });
          }, parseBaseUrl: function(M) {
            return v("parseBaseUrl", M);
          }, parseOrigin: function(M) {
            return v("parseOrigin", M);
          }, parseScheme: function(M) {
            return v("parseScheme", M);
          }, isRelative: function(M) {
            return v("isRelative", M);
          }, isPathAbsolute: function(M) {
            return v("isPathAbsolute", M);
          }, isSchemeRelative: function(M) {
            return v("isSchemeRelative", M);
          }, isHTTPURL: function(M) {
            return v("isHTTPURL", M);
          }, isHTTPS: function(M) {
            return v("isHTTPS", M);
          }, removeHostname: function(M) {
            return v("removeHostname", M);
          }, resolve: function(M, Y) {
            return v("resolve", M, Y);
          } }, A;
        }
        Xe.__dashjs_factory_name = "URLUtils";
        var He = Bt.A.getSingletonFactory(Xe);
        class Ae {
          constructor() {
            this.start = null, this.mstart = null, this.starttype = null, this.trace = [];
          }
        }
        Ae.INITIAL_PLAYOUT_START_REASON = "initial_playout", Ae.SEEK_START_REASON = "seek", Ae.RESUME_FROM_PAUSE_START_REASON = "resume", Ae.METRICS_COLLECTION_START_REASON = "metrics_collection_start";
        class be {
          constructor() {
            this.representationid = null, this.subreplevel = null, this.start = null, this.mstart = null, this.duration = null, this.playbackspeed = null, this.stopreason = null;
          }
        }
        function We(A, f) {
          const C = (A = A || {}).timelineConverter, _ = A.dashMetrics;
          let v;
          function M() {
            if (!C) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function Y(L, W) {
            const K = L.adaptation.period.mpd.manifest.Period[L.adaptation.period.index].AdaptationSet[L.adaptation.index].Representation[L.index].SegmentTemplate || L.adaptation.period.mpd.manifest.Period[L.adaptation.period.index].AdaptationSet[L.adaptation.index].Representation[L.index].SegmentList, R = K.SegmentTimeline, G = K.SegmentURL;
            let F, et, it, st, ot, ut, mt, wt = 0, $ = -1;
            mt = L.timescale, F = R.S;
            let P = !1;
            for (it = 0, st = F.length; it < st && !P; it++) for (et = F[it], ut = 0, et.hasOwnProperty("r") && (ut = et.r), et.hasOwnProperty("t") && (wt = et.t), ut < 0 && (ut = H(L, F[it + 1], et, mt, wt / mt)), ot = 0; ot <= ut && !P; ot++) $++, P = W(wt, K, G, et, mt, $, it), P && (L.segmentDuration = et.d / mt), wt += et.d;
          }
          function H(L, W, K, R, G) {
            let F;
            if (W && W.hasOwnProperty("t")) F = W.t / R;
            else try {
              let et = 0;
              if (isNaN(L.adaptation.period.start) || isNaN(L.adaptation.period.duration) || !isFinite(L.adaptation.period.duration)) {
                const it = _.getCurrentDVRInfo();
                et = isNaN(it.end) ? 0 : it.end;
              } else et = L.adaptation.period.start + L.adaptation.period.duration;
              F = C.calcMediaTimeFromPresentationTime(et, L), L.segmentDuration = K.d / R;
            } catch (et) {
              F = 0;
            }
            return Math.max(Math.ceil((F - G) / (K.d / R)) - 1, 0);
          }
          return v = { getSegmentByIndex: function(L, W, K) {
            if (M(), !L) return null;
            let R = null, G = !1;
            return Y(L, function(F, et, it, st, ot, ut, mt) {
              if (G || K < 0) {
                let wt = et.media, $ = st.mediaRange;
                return it && (wt = it[mt].media || "", $ = it[mt].mediaRange), R = Hn(C, f, L, F, st.d, ot, wt, $, ut, st.tManifest), !0;
              }
              return F >= K * ot - 0.5 * st.d && (G = !0), !1;
            }), R;
          }, getSegmentByTime: function(L, W) {
            if (M(), !L) return null;
            W === void 0 && (W = null);
            let K = null;
            const R = C.calcMediaTimeFromPresentationTime(W, L);
            return Y(L, function(G, F, et, it, st, ot, ut) {
              const mt = parseFloat((R * st).toPrecision(15));
              if (mt < G + it.d && mt >= G) {
                let wt = F.media, $ = it.mediaRange;
                return et && (wt = et[ut].media || "", $ = et[ut].mediaRange), K = Hn(C, f, L, G, it.d, st, wt, $, ot, it.tManifest), !0;
              }
              return !1;
            }), K;
          }, getMediaFinishedInformation: function(L) {
            if (!L) return 0;
            const W = (L.adaptation.period.mpd.manifest.Period[L.adaptation.period.index].AdaptationSet[L.adaptation.index].Representation[L.index].SegmentTemplate || L.adaptation.period.mpd.manifest.Period[L.adaptation.period.index].AdaptationSet[L.adaptation.index].Representation[L.index].SegmentList).SegmentTimeline;
            let K, R, G, F, et, it, st, ot = 0, ut = 0, mt = 0;
            for (st = L.timescale, K = W.S, F = K.length, G = 0; G < F; G++) for (R = K[G], it = 0, R.hasOwnProperty("r") && (it = R.r), R.hasOwnProperty("t") && (ot = R.t, ut = ot / st), it < 0 && (it = H(L, K[G + 1], R, st, ut)), et = 0; et <= it; et++) mt++, ot += R.d, ut = ot / st;
            return { numberOfSegments: mt, mediaTimeOfLastSignaledSegment: ut };
          } }, v;
        }
        be.REPRESENTATION_SWITCH_STOP_REASON = "representation_switch", be.REBUFFERING_REASON = "rebuffering", be.USER_REQUEST_STOP_REASON = "user_request", be.END_OF_PERIOD_STOP_REASON = "end_of_period", be.END_OF_CONTENT_STOP_REASON = "end_of_content", be.METRICS_COLLECTION_STOP_REASON = "metrics_collection_end", be.FAILURE_STOP_REASON = "failure", We.__dashjs_factory_name = "TimelineSegmentsGetter";
        var zn = Bt.A.getClassFactory(We);
        function Pe(A, f) {
          const C = (A = A || {}).timelineConverter;
          let _;
          function v() {
            if (!C || !C.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function M(Y, H) {
            if (v(), !Y) return null;
            const L = Y.adaptation.period.mpd.manifest.Period[Y.adaptation.period.index].AdaptationSet[Y.adaptation.index].Representation[Y.index].SegmentTemplate;
            H = Math.max(H, 0);
            const W = Aa(C, f, Y, H);
            if (W) {
              if (Y.endNumber && W.replacementNumber > Y.endNumber) return null;
              W.replacementTime = Math.round(H * Y.segmentDuration * Y.timescale, 10), W.media = qn(L.media, void 0, W.replacementNumber, void 0, void 0, W.replacementTime);
            }
            return W;
          }
          return _ = { getSegmentByIndex: M, getSegmentByTime: function(Y, H) {
            if (v(), !Y) return null;
            const L = Y.segmentDuration;
            if (isNaN(L)) return null;
            let W = C.calcPeriodRelativeTimeFromMpdRelativeTime(Y, H);
            return M(Y, Math.floor(W / L));
          }, getMediaFinishedInformation: function(Y) {
            const H = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            if (!Y) return H;
            const L = Y.segmentDuration;
            return isNaN(L) ? H.numberOfSegments = 1 : H.numberOfSegments = Math.ceil(Y.adaptation.period.duration / L), H;
          } }, _;
        }
        Pe.__dashjs_factory_name = "TemplateSegmentsGetter";
        var pn = Bt.A.getClassFactory(Pe);
        function yn(A, f) {
          const C = (A = A || {}).timelineConverter;
          let _;
          function v() {
            if (!C || !C.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function M(Y, H) {
            if (v(), !Y) return null;
            const L = Y.adaptation.period.mpd.manifest.Period[Y.adaptation.period.index].AdaptationSet[Y.adaptation.index].Representation[Y.index].SegmentList, W = L.SegmentURL.length, K = Y && !isNaN(Y.startNumber) ? Y.startNumber : 1, R = Math.max(K - 1, 0), G = Math.max(H - R, 0);
            let F = null;
            if (G < W) {
              const et = L.SegmentURL[G];
              F = Aa(C, f, Y, H), F && (F.replacementTime = (K + H - 1) * Y.segmentDuration, F.media = et.media ? et.media : "", F.mediaRange = et.mediaRange, F.indexRange = et.indexRange);
            }
            return F;
          }
          return _ = { getSegmentByIndex: M, getSegmentByTime: function(Y, H) {
            if (v(), !Y) return null;
            const L = Y.segmentDuration;
            if (isNaN(L)) return null;
            const W = C.calcPeriodRelativeTimeFromMpdRelativeTime(Y, H);
            return M(Y, Math.floor(W / L));
          }, getMediaFinishedInformation: function(Y) {
            const H = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            if (!Y) return H;
            const L = Y.adaptation.period.mpd.manifest.Period[Y.adaptation.period.index].AdaptationSet[Y.adaptation.index].Representation[Y.index].SegmentList, W = Y && !isNaN(Y.startNumber) ? Y.startNumber : 1, K = Math.max(W - 1, 0);
            return H.numberOfSegments = K + L.SegmentURL.length, H;
          } }, _;
        }
        yn.__dashjs_factory_name = "ListSegmentsGetter";
        var wn = Bt.A.getClassFactory(yn);
        function vn(A) {
          const f = (A = A || {}).timelineConverter;
          let C;
          function _() {
            if (!f || !f.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function v(M, Y) {
            if (_(), !M) return null;
            const H = M.segments ? M.segments.length : -1;
            let L;
            if (Y < H && (L = M.segments[Y], L && L.index === Y)) return L;
            for (let W = 0; W < H; W++) if (L = M.segments[W], L && L.index === Y) return L;
            return null;
          }
          return C = { getSegmentByIndex: v, getSegmentByTime: function(M, Y) {
            _();
            const H = function(L, W) {
              if (!L) return -1;
              const K = L.segments, R = K ? K.length : null;
              let G, F, et, it, st, ot = -1;
              if (K && R > 0) {
                for (st = 0; st < R; st++) if (F = K[st], et = F.presentationStartTime, it = F.duration, G = it / 2, W + G >= et && W - G < et + it) {
                  ot = F.index;
                  break;
                }
              }
              return ot;
            }(M, Y);
            return v(M, H);
          }, getMediaFinishedInformation: function(M) {
            const Y = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            return M && M.segments && (Y.numberOfSegments = M.segments.length), Y;
          } }, C;
        }
        vn.__dashjs_factory_name = "SegmentBaseGetter";
        var Pn = Bt.A.getClassFactory(vn);
        function In(A) {
          A = A || {};
          const f = this.context, C = A.dashConstants, _ = A.type, v = A.segmentBaseController;
          let M, Y;
          function H(L) {
            return L ? L.segments ? Y[C.SEGMENT_BASE] : Y[L.segmentInfoType] : null;
          }
          return M = { initialize: function(L) {
            Y[C.SEGMENT_TIMELINE] = zn(f).create(A, L), Y[C.SEGMENT_TEMPLATE] = pn(f).create(A, L), Y[C.SEGMENT_LIST] = wn(f).create(A, L), Y[C.SEGMENT_BASE] = Pn(f).create(A, L);
          }, updateInitData: function(L, W) {
            return W ? Promise.resolve() : v.getSegmentBaseInitSegment({ representation: L, mediaType: _ });
          }, updateSegmentData: function(L, W) {
            return W ? Promise.resolve() : v.getSegmentList({ mimeType: L.mimeType, representation: L, mediaType: _ });
          }, getSegmentByIndex: function(L, W, K) {
            const R = H(L);
            return R ? R.getSegmentByIndex(L, W, K) : null;
          }, getSegmentByTime: function(L, W) {
            const K = H(L);
            return K ? K.getSegmentByTime(L, W) : null;
          }, getMediaFinishedInformation: function(L) {
            const W = H(L);
            return W ? W.getMediaFinishedInformation(L) : { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
          } }, Y = {}, M;
        }
        In.__dashjs_factory_name = "SegmentsController";
        var ye = Bt.A.getClassFactory(In);
        function le() {
          let A;
          return A = { ntpToUTC: function(f) {
            const C = new Date(Date.UTC(1900, 0, 1, 0, 0, 0));
            return new Date(C.getTime() + f).getTime();
          } }, A;
        }
        le.__dashjs_factory_name = "TimeUtils";
        var Qe = Bt.A.getSingletonFactory(le), on = class {
          constructor(A) {
            this.newMediaInfo = A.newMediaInfo, this.previouslySelectedRepresentation = A.previouslySelectedRepresentation, this.newRepresentation = A.newRepresentation;
          }
        };
        function Dn(A) {
          A = A || {};
          let f, C, _, v, M, Y, H, L, W, K, R, G, F, et, it, st, ot = this.context, ut = (0, Mt.A)(ot).getInstance(), mt = A.abrController, wt = A.adapter, $ = A.boxParser, P = A.capabilities, j = A.dashMetrics, J = A.errHandler, ht = A.fragmentModel, _t = A.manifestModel, Ct = A.mediaController, bt = A.mediaPlayerModel, Rt = A.mimeType, xt = A.playbackController, Pt = A.segmentBlacklistController, N = A.settings, ct = A.streamInfo, It = A.textController, dt = A.timelineConverter, nt = A.type;
          function ft() {
            return ct.id;
          }
          function rt() {
            return nt;
          }
          function Et() {
            L = [], _ = null, C = 0, it = !1, et = !1, K = !1, st = !1, _n();
          }
          function kt(qt) {
            return !isNaN(qt) && !isNaN(ct.duration) && isFinite(ct.duration) && qt >= ct.start + ct.duration;
          }
          function Dt(qt) {
            let Me = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            if (qt.sender) {
              if (xt.getIsManifestUpdateInProgress()) ie();
              else if ((!_.isText || It.isTextEnabled()) && f && qt.representationId && !f.appendInitSegmentFromCache(qt.representationId)) {
                const Ve = R.getCurrentRepresentation();
                if (Ve.range === 0) return void Ut();
                const fn = v ? v.getInitRequest(_, Ve) : null;
                fn ? ht.executeRequest(fn) : Me && (G.setInitSegmentRequired(!0), ie());
              }
            }
          }
          function Ut(qt) {
            let Me = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            if (xt.getIsManifestUpdateInProgress() || f.getIsPruningInProgress()) return void ie();
            let Ve = function() {
              let fn;
              if (isNaN(C) || rt() === X.A.TEXT && !It.isTextEnabled()) return null;
              if (v) {
                const Bn = $t();
                fn = it ? v.getSegmentRequestForTime(_, Bn, C) : et ? v.repeatSegmentRequest(_, Bn) : v.getNextSegmentRequest(_, Bn);
              }
              return fn;
            }();
            Ve ? (it = !1, et = !1, function(fn) {
              isNaN(fn.startTime + fn.duration) || (C = fn.startTime + fn.duration), fn.delayLoadingTime = (/* @__PURE__ */ new Date()).getTime() + G.getTimeToLoadDelay(), G.setTimeToLoadDelay(0), function(Bn) {
                let Sn = Bn.url;
                return Bn.range && (Sn = Sn.concat("_", Bn.range)), Pt.contains(Sn);
              }(fn) ? (H.warn(`Fragment request url ${fn.url} for stream id ${ct.id} and media type ${nt} is on the ignore list and will be skipped`), ie()) : (H.debug(`Next fragment request url for stream id ${ct.id} and media type ${nt} is ${fn.url} with request range ${fn.range}`), ht.executeRequest(fn));
            }(Ve)) : function(fn) {
              const Bn = R.getCurrentRepresentation();
              try {
                if (N.get().streaming.gaps.enableSeekFix && (it || xt.getTime() === 0)) {
                  let Sn;
                  if (Y ? Y && Bn.segmentInfoType === D.A.SEGMENT_TIMELINE && (Sn = v.getValidTimeAheadOfTargetTime(C, _, Bn, N.get().streaming.gaps.threshold)) : (Sn = v.getValidTimeAheadOfTargetTime(C, _, Bn, N.get().streaming.gaps.threshold), isNaN(Sn) && C >= Bn.adaptation.period.mpd.mediaPresentationDuration - Bn.segmentDuration && (Sn = C - 0.1)), !isNaN(Sn) && Sn !== C) return void (xt.isSeeking() || xt.getTime() === 0 ? (H.warn(`Adjusting playback time ${Sn} because of gap in the manifest. Seeking by ${Sn - C}`), xt.seek(Sn, !1, !1)) : (H.warn(`Adjusting buffering time ${Sn} because of gap in the manifest. Adjusting time by ${Sn - C}`), he(Sn), fn && ie()));
                }
              } catch (Sn) {
                H.error(Sn);
              }
              Wt() || fn && ie();
            }(Me);
          }
          function Wt() {
            const qt = R.getCurrentRepresentation(), Me = v.isLastSegmentRequested(qt, C);
            if (Me) {
              const Ve = v.getCurrentIndex();
              H.debug(`Segment requesting for stream ${ct.id} has finished`), ut.trigger(at.A.STREAM_REQUESTING_COMPLETED, { segmentIndex: Ve }, { streamId: ct.id, mediaType: nt }), f.segmentRequestingCompleted(Ve), tn();
            }
            return Me;
          }
          function ie() {
            G.startScheduleTimer(xt.getLowLatencyModeEnabled() ? N.get().streaming.scheduling.lowLatencyTimeout : N.get().streaming.scheduling.defaultTimeout);
          }
          function de(qt) {
            j.addBufferState(nt, qt.state, G.getBufferTarget()), qt.state !== yt.BUFFER_EMPTY || xt.isSeeking() || (H.info("Buffer is empty! Stalling!"), j.pushPlayListTraceMetrics(/* @__PURE__ */ new Date(), be.REBUFFERING_REASON));
          }
          function Be(qt) {
            ht.syncExecutedRequestsWithBufferedRange(f.getBuffer().getAllBufferRanges(), ct.duration), qt.quotaExceeded && qt.from > xt.getTime() && he(qt.from), qt.hasEnoughSpaceToAppend && qt.quotaExceeded && G.startScheduleTimer();
          }
          function Oe(qt) {
            if (!qt || !qt.lastRequestAppended || !qt.lastRequestAppended.url) return;
            let Me = qt.lastRequestAppended.url;
            qt.lastRequestAppended.range && (Me = Me.concat("_", qt.lastRequestAppended.range)), H.warn(`Blacklisting segment with url ${Me}`), Pt.add(Me);
          }
          function nn(qt) {
            if (H.debug(`Appended bytes for ${qt.mediaType} and stream id ${qt.streamId}`), qt.segmentType === Ht.G.INIT_SEGMENT_TYPE) {
              const Me = qt.representationId;
              G.setLastInitializedRepresentationId(Me), H.info("[" + nt + "] lastInitializedRepresentationId changed to " + Me);
            }
            W && W.enabled ? ce(W.newRepresentation, W.oldRepresentation) : st || G.startScheduleTimer(0);
          }
          function _n() {
            W = { newRepresentation: null, oldRepresentation: null, enabled: !1 };
          }
          function ke(qt) {
            return new Promise((Me) => {
              if (!R) return Promise.resolve();
              let Ve = null;
              var fn;
              Ve = qt.newRepresentation ? { selectedRepresentation: (fn = qt).newRepresentation, currentMediaInfo: fn.newMediaInfo } : _ !== null && wt.areMediaInfosEqual(_, qt.newMediaInfo) ? function(Sn) {
                return { currentMediaInfo: Sn.newMediaInfo, selectedRepresentation: R.getCurrentRepresentation() };
              }(qt) : function(Sn) {
                let Ia = NaN;
                return Ia = !N.get().streaming.abr.autoSwitchBitrate[Sn.newMediaInfo.type] && Sn.previouslySelectedRepresentation ? Sn.previouslySelectedRepresentation.bitrateInKbit : mt.getInitialBitrateFor(nt), { selectedRepresentation: mt.getOptimalRepresentationForBitrate(Sn.newMediaInfo, Ia, !1), currentMediaInfo: Sn.newMediaInfo };
              }(qt), rn(Ve.currentMediaInfo), ut.trigger();
              const Bn = mt.getPossibleVoRepresentations(_, !1);
              return R.updateData(Bn, _.isFragmented, Ve.selectedRepresentation.id).then(() => {
                (function() {
                  const Sn = R.getCurrentRepresentation();
                  f.getIsBufferingCompleted() || f.updateBufferTimestampOffset(Sn);
                })(), Me();
              }).catch((Sn) => {
                H.error(Sn), Me();
              });
            });
          }
          function rn(qt) {
            wt.areMediaInfosEqual(_, qt) || ut.trigger(At.A.NEW_TRACK_SELECTED, { value: qt }), _ = qt, mt.handleNewMediaInfo(_), ut.trigger(at.A.MEDIAINFO_UPDATED, { mediaType: nt, streamId: ct.id, currentMediaInfo: _ });
          }
          function Cn(qt) {
            const Me = qt.newRepresentation, Ve = qt.oldRepresentation;
            Me && Ve || H.warn("_handleDifferentSwitchTypes() is missing the target representations"), qt.reason && qt.reason.forceReplace ? function(fn, Bn) {
              ht.abortRequests(), ut.trigger(at.A.BUFFER_REPLACEMENT_STARTED, { mediaType: nt, streamId: ct.id }, { mediaType: nt, streamId: ct.id }), G.setCheckPlaybackQuality(!1), f.prepareForForceReplacementQualitySwitch(fn, Bn).then(() => {
                Nn();
              }).catch(() => {
                Nn();
              });
            }(Me, Ve) : qt && qt.reason && qt.reason.forceAbandon ? function(fn, Bn) {
              f.prepareForAbandonQualitySwitch(fn, Bn).then(() => {
                Gn();
              }).catch(() => {
                Gn();
              });
            }(Me, Ve) : bt.getFastSwitchEnabled() ? function(fn, Bn) {
              const Sn = xt.getTime();
              let Ia = 1.5 * (isNaN(fn.fragmentDuration) ? 1 : fn.fragmentDuration);
              const Pa = ht.getRequests({ state: Tn.FRAGMENT_MODEL_EXECUTED, time: Sn + Ia, threshold: 0 })[0];
              if (Pa && !_.isText) {
                const sr = f.getBufferLevel(), oi = mt.getAbandonmentStateFor(ct.id, nt);
                Pa.bandwidth < fn.bandwidth && sr >= Ia && oi === yt.ALLOW_LOAD ? f.prepareForFastQualitySwitch(fn, Bn).then(() => {
                  Xt(Sn, Ia);
                }).catch(() => {
                  Xt(Sn, Ia);
                }) : ce(fn, Bn);
              } else ce(fn, Bn);
            }(Me, Ve) : ce(Me, Ve), j.pushPlayListTraceMetrics(/* @__PURE__ */ new Date(), be.REPRESENTATION_SWITCH_STOP_REASON), j.createPlaylistTraceMetrics(Me.id, 1e3 * xt.getTime(), xt.getPlaybackRate());
          }
          function Nn() {
            ue(), _n(), K = !1;
          }
          function Gn() {
            ht.abortRequests(), et = !0, G.setCheckPlaybackQuality(!1), G.startScheduleTimer(), K = !1;
          }
          function Xt(qt, Me) {
            ht.abortRequests(), he(qt + Me), G.setCheckPlaybackQuality(!1), G.startScheduleTimer(), K = !1;
          }
          function ce(qt, Me) {
            const Ve = ht.getRequests({ state: Tn.FRAGMENT_MODEL_LOADING });
            if (Ve && Ve.length > 0) return H.debug("Preparing for default quality switch: Waiting for ongoing segment request to be finished before applying switch."), W.newRepresentation = qt, W.oldRepresentation = Me, void (W.enabled = !0);
            f.prepareForDefaultQualitySwitch(qt, Me).then(() => {
              oe();
            }).catch(() => {
              oe();
            });
          }
          function oe() {
            G.setCheckPlaybackQuality(!1), _.segmentAlignment || _.subSegmentAlignment ? G.startScheduleTimer() : Tt(), _n(), K = !1;
          }
          function pe(qt) {
            H.info("onFragmentLoadingAbandoned request: " + qt.request.url + " has been aborted"), xt.isSeeking() || G.getSwitchTrack() || K || (H.info("onFragmentLoadingAbandoned request: " + qt.request.url + " has to be downloaded again, origin is not seeking process or switch track call"), qt.request && qt.request.isInitializationRequest() ? G.setInitSegmentRequired(!0) : he(qt.request.startTime + qt.request.duration / 2), G.startScheduleTimer(0));
          }
          function en(qt) {
            H.info("OnFragmentLoadingCompleted for stream id " + ct.id + " and media type " + nt + " - Url:", qt.request ? qt.request.url : "undefined", qt.request.range ? ", Range:" + qt.request.range : ""), _.isText && G.startScheduleTimer(0), qt.error && qt.request.serviceLocation && function(Me) {
              H.info("Fragment loading completed with an error"), Me && Me.request && Me.request.type && (Me.request.type === Ht.G.INIT_SEGMENT_TYPE ? Dt({ representationId: Me.request.representation.id, sender: {} }, !1) : Me.request.type === Ht.G.MEDIA_SEGMENT_TYPE && (he(Me.request.startTime + Me.request.duration / 2), Ut({}, !1)));
            }(qt);
          }
          function mn() {
            he(xt.getTime()), Ze().startScheduleTimer();
          }
          function se(qt) {
            const Me = qt.currentTrackInfo;
            if (!Me) return;
            const Ve = L.find((fn) => fn.index === Me.index && fn.lang === Me.lang);
            Ve && ke(new on({ newMediaInfo: Ve })).then(() => {
              f.setIsBufferingCompleted(!1), he(xt.getTime()), G.setInitSegmentRequired(!0), G.startScheduleTimer();
            });
          }
          function Ke(qt) {
            he(qt.quotaExceededTime), tn();
          }
          function qe() {
            return f ? f.getBuffer() : null;
          }
          function Ze() {
            return G;
          }
          function tn() {
            G && G.clearScheduleTimer();
          }
          function $t() {
            let qt, Me = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN;
            return isNaN(Me) ? qt = R ? R.getCurrentRepresentation() : null : ((0, xe.zQ)(Me), qt = R ? R.getRepresentationById(Me) : null), qt;
          }
          function Se() {
            return !!f && f.getIsBufferingCompleted();
          }
          function Je(qt) {
            if (!N.get().streaming.enableManifestTimescaleMismatchFix) return;
            const Me = qt.chunk, Ve = Me.bytes, fn = $t(Me.representation.id);
            fn && (fn.timescale = $.getMediaTimescaleFromMoov(Ve));
          }
          function $e(qt) {
            const Me = qt.chunk, Ve = Me.bytes, fn = $t(Me.representation.id);
            if (fn) {
              let Bn;
              if (N.get().streaming.parseInbandPrft && qt.request.type === Ht.G.MEDIA_SEGMENT_TYPE) {
                Bn = Bn || $.parse(Ve);
                const Pa = function(sr, oi) {
                  const ws = sr.getBoxes("prft"), mo = [];
                  return ws.forEach((qo) => {
                    mo.push(function(br, vs) {
                      let Ri = "unknown";
                      switch (br.flags) {
                        case 0:
                          Ri = D.A.PRODUCER_REFERENCE_TIME_TYPE.ENCODER;
                          break;
                        case 16:
                          Ri = D.A.PRODUCER_REFERENCE_TIME_TYPE.APPLICATION;
                          break;
                        case 24:
                          Ri = D.A.PRODUCER_REFERENCE_TIME_TYPE.CAPTURED;
                      }
                      let or = 1e3 * br.ntp_timestamp_sec + br.ntp_timestamp_frac / NI(2, 32) * 1e3;
                      return or = Qe(ot).getInstance().ntpToUTC(or), { type: Ri, ntpTimestamp: or, mediaTime: br.media_time / vs };
                    }(qo, oi));
                  }), mo;
                }(Bn, fn.timescale);
                Pa && Pa.length && ut.trigger(At.A.INBAND_PRFT, { data: Pa }, { streamId: ct.id, mediaType: nt });
              }
              const Sn = wt.getEventsFor(fn.mediaInfo, null, ct), Ia = wt.getEventsFor(fn, fn, ct);
              if (Sn && Sn.length > 0 || Ia && Ia.length > 0) {
                const Pa = qt.request;
                Bn = Bn || $.parse(Ve);
                const sr = function(oi, ws, mo, qo) {
                  try {
                    const br = {}, vs = [], Ri = mo.concat(qo);
                    for (let Di = 0, $o = Ri.length; Di < $o; Di++) br[Ri[Di].schemeIdUri + "/" + Ri[Di].value] = Ri[Di];
                    const or = oi.getBoxes("emsg");
                    if (!or || or.length === 0) return vs;
                    const Es = oi.getBox("sidx"), Bd = !Es || isNaN(Es.earliest_presentation_time) || isNaN(Es.timescale) ? ws && !isNaN(ws.mediaStartTime) ? ws.mediaStartTime : 0 : Es.earliest_presentation_time / Es.timescale, xd = Math.max(Bd, 0), Ts = R.getCurrentRepresentation();
                    for (let Di = 0, $o = or.length; Di < $o; Di++) {
                      const iu = wt.getEvent(or[Di], br, xd, Ts);
                      iu && vs.push(iu);
                    }
                    return vs;
                  } catch (br) {
                    return [];
                  }
                }(Bn, Pa, Sn, Ia);
                ut.trigger(at.A.INBAND_EVENTS, { events: sr }, { streamId: ct.id });
              }
            }
          }
          function ue() {
            const qt = xt.getTime();
            N.get().streaming.buffer.flushBufferAtTrackSwitch && xt.seek(qt + 1e-3, !1, !0), he(qt), f.setSeekTarget(qt), G.startScheduleTimer();
          }
          function Tt() {
            const qt = xt.getTime(), Me = f.getContinuousBufferTimeForTargetTime(qt);
            he(isNaN(Me) ? qt : Me), G.startScheduleTimer();
          }
          function Zt(qt) {
            qt && !isNaN(qt.time) && (he(qt.time), f.setSeekTarget(qt.time));
          }
          function he(qt) {
            C = qt, it = !0;
          }
          return M = { checkAndHandleCompletedBuffering: Wt, clearScheduleTimer: tn, createBufferSinks: function(qt, Me) {
            const Ve = qe();
            return Ve ? Promise.resolve(Ve) : f ? f.createBufferSink(_, qt, Me) : Promise.resolve(null);
          }, dischargePreBuffer: function() {
            f.dischargePreBuffer();
          }, finalisePlayList: function(qt, Me) {
            j.pushPlayListTraceMetrics(qt, Me);
          }, getAllMediaInfos: function() {
            return L;
          }, getBuffer: qe, getBufferController: function() {
            return f;
          }, getBufferLevel: function() {
            return f ? f.getBufferLevel() : 0;
          }, getFragmentModel: function() {
            return ht;
          }, getMediaInfo: function() {
            return _;
          }, getMediaSource: function() {
            return f.getMediaSource();
          }, getRepresentation: $t, getRepresentationController: function() {
            return R;
          }, getScheduleController: Ze, getStreamId: ft, getStreamInfo: function() {
            return ct;
          }, getType: rt, initialize: function(qt, Me, Ve) {
            F = ye(ot).create({ events: at.A, eventBus: ut, streamInfo: ct, timelineConverter: dt, dashConstants: D.A, segmentBaseController: A.segmentBaseController, type: nt }), v = Ie(ot).create({ streamInfo: ct, type: nt, timelineConverter: dt, dashMetrics: j, mediaPlayerModel: bt, baseURLController: A.baseURLController, errHandler: J, segmentsController: F, settings: N, boxParser: $, events: at.A, eventBus: ut, errors: q, debug: (0, jt.A)(ot).getInstance(), dashConstants: D.A, constants: X.A, urlUtils: He(ot).getInstance() }), Y = ct.manifestInfo.isDynamic, v.initialize(Y), mt.registerStreamType(nt, M), R = Ee(ot).create({ streamInfo: ct, type: nt, abrController: mt, dashMetrics: j, playbackController: xt, timelineConverter: dt, dashConstants: D.A, events: at.A, eventBus: ut, errors: q, isDynamic: Y, adapter: wt, segmentsController: F }), f = function(fn, Bn) {
              let Sn = null;
              return fn ? (Sn = fn !== X.A.TEXT || Bn ? Kt(ot).create({ abrController: mt, capabilities: P, errHandler: J, fragmentModel: ht, manifestModel: _t, mediaController: Ct, mediaPlayerModel: bt, playbackController: xt, representationController: R, settings: N, streamInfo: ct, textController: It, type: fn }) : me(ot).create({ errHandler: J, fragmentModel: ht, mimeType: Rt, settings: N, streamInfo: ct, textController: It, type: fn }), Sn) : (J.error(new Nt.A(q.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, q.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + "not properly defined")), null);
            }(nt, Ve), f && f.initialize(qt), G = Ge(ot).create({ streamInfo: ct, type: nt, mimeType: Rt, adapter: wt, dashMetrics: j, mediaPlayerModel: bt, fragmentModel: ht, abrController: mt, playbackController: xt, textController: It, mediaController: Ct, bufferController: f, representationController: R, settings: N }), G.initialize(Me), C = 0, it = !1, et = !1;
          }, isBufferingCompleted: Se, prepareInnerPeriodPlaybackSeeking: function(qt) {
            return new Promise((Me) => {
              if (f.hasBufferAtTime(qt.seekTime)) return f.pruneBuffer(), kt(f.getContinuousBufferTimeForTargetTime(qt.seekTime)) && f.setIsBufferingCompleted(!0), void Me();
              tn(), ht.abortRequests(), f.prepareForPlaybackSeek().then(() => {
                const Ve = f.getAllRangesWithSafetyFactor(qt.seekTime);
                return f.clearBuffers(Ve);
              }).then(() => {
                const Ve = f.getContinuousBufferTimeForTargetTime(qt.seekTime);
                if (kt(Ve)) f.setIsBufferingCompleted(!0), Me();
                else {
                  const fn = isNaN(Ve) ? qt.seekTime : Ve;
                  he(fn), f.setSeekTarget(fn);
                  const Bn = [];
                  Bn.push(f.updateAppendWindow());
                  const Sn = $t();
                  Bn.push(f.updateBufferTimestampOffset(Sn)), Promise.all(Bn).then(() => {
                    G.setInitSegmentRequired(!0), G.setCheckPlaybackQuality(!1), G.startScheduleTimer(), Me();
                  });
                }
              }).catch((Ve) => {
                H.error(Ve);
              });
            });
          }, prepareOuterPeriodPlaybackSeeking: function() {
            return new Promise((qt, Me) => {
              try {
                tn(), ht.abortRequests(), f.prepareForPlaybackSeek().then(() => f.pruneAllSafely()).then(() => {
                  qt();
                });
              } catch (Ve) {
                Me(Ve);
              }
            });
          }, prepareQualityChange: function(qt) {
            qt.newRepresentation && (W && W.enabled && H.warn(`Canceling queued representation switch to ${W.newRepresentation.id} for ${nt}`), qt.isAdaptationSetSwitch ? (H.debug(`Preparing quality switch to different AdaptationSet for type ${nt}`), function(Me) {
              const Ve = Me.newRepresentation;
              K = !0, tn(), G.setSwitchTrack(!0);
              const fn = Ve.mediaInfo;
              rn(fn), ke(new on({ newMediaInfo: fn, newRepresentation: Ve })).then(() => {
                Cn(Me);
              });
            }(qt)) : (H.debug(`Preparing quality within the same AdaptationSet for type ${nt}`), function(Me) {
              const Ve = Me.newRepresentation;
              K = !0, tn(), R.prepareQualityChange(Ve), Cn(Me);
            }(qt)));
          }, prepareTrackSwitch: function(qt) {
            let Me = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            return new Promise((Ve) => {
              H.debug(`Preparing track switch for type ${nt}`);
              const fn = nt === X.A.TEXT || Me || N.get().streaming.trackSwitchMode[nt] === X.A.TRACK_SWITCH_MODE_ALWAYS_REPLACE && xt.getTimeToStreamEnd(ct) > N.get().streaming.buffer.stallThreshold;
              f.getIsBufferingCompleted() && !fn ? function(Bn) {
                return new Promise((Sn) => {
                  const Ia = R.getCurrentRepresentation();
                  f.prepareForNonReplacementTrackSwitch(Ia, Bn).then(() => {
                    ut.trigger(at.A.BUFFERING_COMPLETED, {}, { streamId: ct.id, mediaType: nt }), Sn();
                  }).catch(() => {
                    ut.trigger(at.A.BUFFERING_COMPLETED, {}, { streamId: ct.id, mediaType: nt }), Sn();
                  });
                });
              }(qt).then(() => {
                Ve();
              }) : (G.setSwitchTrack(!0), fn ? function(Bn) {
                return new Promise((Sn) => {
                  ut.trigger(at.A.BUFFER_REPLACEMENT_STARTED, { mediaType: nt, streamId: ct.id }, { mediaType: nt, streamId: ct.id }), ht.abortRequests();
                  const Ia = $t();
                  f.prepareForReplacementTrackSwitch(Ia, Bn).then(() => {
                    ue(), Sn();
                  }).catch(() => {
                    ue(), Sn();
                  });
                });
              }(qt).then(() => {
                Ve();
              }) : function(Bn) {
                return new Promise((Sn) => {
                  const Ia = () => {
                    const Pa = ht.getRequests({ state: Tn.FRAGMENT_MODEL_LOADING });
                    if (Pa && Pa.length !== 0) ut.once(At.A.FRAGMENT_LOADING_COMPLETED, Ia, M);
                    else {
                      const sr = $t();
                      f.prepareForNonReplacementTrackSwitch(sr, Bn).then(() => {
                        Tt(), Sn();
                      }).catch((oi) => {
                        H.error(oi), Tt(), Sn();
                      });
                    }
                  };
                  Ia();
                });
              }(qt).then(() => {
                Ve();
              }));
            });
          }, probeNextRequest: function() {
            const qt = $t();
            return v.getNextSegmentRequestIdempotent(_, qt);
          }, reset: function(qt, Me) {
            v && v.reset(), f && (f.reset(qt, Me), f = null), G && (G.reset(), G = null), R && (R.reset(), R = null), F && (F = null), mt && mt.unRegisterStreamType(ft(), nt), ut.off(at.A.INIT_FRAGMENT_NEEDED, Dt, M), ut.off(at.A.MEDIA_FRAGMENT_NEEDED, Ut, M), ut.off(at.A.INIT_FRAGMENT_LOADED, Je, M), ut.off(at.A.MEDIA_FRAGMENT_LOADED, $e, M), ut.off(at.A.BUFFER_LEVEL_STATE_CHANGED, de, M), ut.off(at.A.BUFFER_CLEARED, Be, M), ut.off(at.A.SEEK_TARGET, Zt, M), ut.off(at.A.FRAGMENT_LOADING_ABANDONED, pe, M), ut.off(at.A.FRAGMENT_LOADING_COMPLETED, en, M), ut.off(at.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, mn, M), ut.off(at.A.SET_NON_FRAGMENTED_TEXT, se, M), ut.off(at.A.QUOTA_EXCEEDED, Ke, M), ut.off(at.A.SOURCE_BUFFER_ERROR, Oe, M), ut.off(at.A.BYTES_APPENDED_END_FRAGMENT, nn, M), Et(), nt = null, ct = null;
          }, selectMediaInfo: ke, setExplicitBufferingTime: he, setMediaInfoArray: function(qt) {
            L = qt;
          }, setMediaSource: function(qt) {
            return f.setMediaSource(qt, _);
          }, setTrackSwitchInProgress: function(qt) {
            st = qt;
          }, updateStreamInfo: function(qt) {
            return ct = qt, Se() ? Promise.resolve() : f.updateAppendWindow();
          } }, H = (0, jt.A)(ot).getInstance().getLogger(M), Et(), ut.on(at.A.INIT_FRAGMENT_NEEDED, Dt, M), ut.on(at.A.MEDIA_FRAGMENT_NEEDED, Ut, M), ut.on(at.A.INIT_FRAGMENT_LOADED, Je, M), ut.on(at.A.MEDIA_FRAGMENT_LOADED, $e, M), ut.on(at.A.BUFFER_LEVEL_STATE_CHANGED, de, M), ut.on(at.A.BUFFER_CLEARED, Be, M), ut.on(at.A.SEEK_TARGET, Zt, M), ut.on(at.A.FRAGMENT_LOADING_ABANDONED, pe, M), ut.on(at.A.FRAGMENT_LOADING_COMPLETED, en, M), ut.on(at.A.QUOTA_EXCEEDED, Ke, M), ut.on(at.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, mn, M), ut.on(at.A.SET_NON_FRAGMENTED_TEXT, se, M), ut.on(at.A.SOURCE_BUFFER_ERROR, Oe, M), ut.on(at.A.BYTES_APPENDED_END_FRAGMENT, nn, M), M;
        }
        Dn.__dashjs_factory_name = "StreamProcessor";
        var Wn = Bt.A.getClassFactory(Dn), oa = class {
          constructor() {
            this.streamId = null, this.segmentType = null, this.index = NaN, this.bytes = null, this.start = NaN, this.end = NaN, this.duration = NaN, this.representation = null, this.endFragment = null;
          }
        }, jn = w(7263);
        function ha() {
          let A, f;
          function C() {
            f && (f.onloadend = f.onerror = f.onprogress = f.onload = null, f.abort(), f = null);
          }
          return A = { load: function(_, v) {
            if (f = null, f = new XMLHttpRequest(), f.open(_.method, _.url, !0), _.responseType && (f.responseType = _.responseType), _.headers) for (let M in _.headers) {
              let Y = _.headers[M];
              Y && f.setRequestHeader(M, Y);
            }
            return f.withCredentials = _.credentials === "include", f.timeout = _.timeout, f.onload = function() {
              v.url = this.responseURL, v.status = this.status, v.statusText = this.statusText, v.headers = jn.A.parseHttpHeaders(this.getAllResponseHeaders()), v.data = this.response;
            }, _.customData && (f.onloadend = _.customData.onloadend, f.onprogress = _.customData.onprogress, f.onabort = _.customData.onabort, f.ontimeout = _.customData.ontimeout), f.send(), _.customData.abort = C.bind(this), !0;
          }, abort: C, getXhr: function() {
            return f;
          }, reset: function() {
            C(), A = null;
          }, resetInitialSettings: function() {
            C();
          } }, A;
        }
        ha.__dashjs_factory_name = "XHRLoader";
        var va = Bt.A.getClassFactory(ha);
        function _a() {
          const A = this.context, f = (0, tt.A)(A).getInstance();
          let C, _, v;
          function M(R, G, F) {
            R.customData.reader.read().then(F).catch(function() {
              Y(R);
            });
          }
          function Y(R) {
            R.customData.onloadend && R.customData.onloadend();
          }
          function H() {
            return typeof performance != "undefined" && typeof performance.now == "function" ? performance.now() : Date.now();
          }
          function L() {
            if (this.customData.abortController) this.customData.abortController.abort();
            else if (this.customData.reader) try {
              this.customData.reader.cancel(), this.onabort();
            } catch (R) {
            }
          }
          function W(R, G) {
            try {
              if ((R = R.filter((F) => F.bytes > G / 4 / R.length)).length > 1) {
                let F = 0;
                const et = (R[R.length - 1].timestamp - R[0].timestamp) / R.length;
                return R.forEach((it, st) => {
                  const ot = R[st + 1];
                  if (ot) {
                    const ut = ot.timestamp - it.timestamp;
                    F += ut < et ? ut : 0;
                  }
                }), F;
              }
              return null;
            } catch (F) {
              return null;
            }
          }
          function K(R, G) {
            return 8 * R / G;
          }
          return v = (0, jt.A)(A).getInstance().getLogger(C), C = { abort: L, calculateDownloadedTime: W, load: function(R, G) {
            const F = function(st) {
              const ot = new Headers();
              if (st.headers) for (let ut in st.headers) {
                let mt = st.headers[ut];
                mt && ot.append(ut, mt);
              }
              return ot;
            }(R), et = function(st) {
              let ot;
              return typeof window.AbortController == "function" && (ot = new AbortController(), st.customData.abortController = ot, ot.signal.onabort = st.customData.onabort), st.customData.abort = L.bind(st), ot;
            }(R), it = function(st, ot, ut) {
              return new Request(st.url, { method: st.method, headers: ot, credentials: st.credentials, signal: ut ? ut.signal : void 0 });
            }(R, F, et);
            fetch(it).then((st) => {
              (function(ot, ut, mt) {
                (function(xt, Pt) {
                  xt.status = Pt.status, xt.statusText = Pt.statusText, xt.url = Pt.url;
                  const N = {};
                  for (const ct of Pt.headers.keys()) N[ct] = Pt.headers.get(ct);
                  xt.headers = N;
                })(mt, ot), ot.ok || ut.customData.onloadend();
                let wt = 0, $ = !1, P = new Uint8Array(), j = 0;
                ut.customData.reader = ot.body.getReader();
                let J = [], ht = [], _t = [], Ct = !0;
                const bt = f.get().streaming.abr.throughput.lowLatencyDownloadTimeCalculationMode, Rt = (xt) => {
                  let { value: Pt, done: N } = xt;
                  N ? function() {
                    if (P) {
                      const ct = function() {
                        let It = null;
                        return bt === X.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING ? It = function() {
                          const dt = function(nt, ft) {
                            try {
                              let rt, Et;
                              if (rt = nt.slice(0, -1), Et = ft.slice(0, -1), rt.length !== Et.length && v.warn(`[FetchLoader] Moof and Mdat data arrays have different lengths. Moof: ${rt.length}, Mdat: ${Et.length}`), rt.length <= 1) return null;
                              let kt = [], Dt = 0, Ut = 0;
                              for (let Wt = 0; Wt < rt.length; Wt++) if (rt[Wt] && Et[Wt]) {
                                let ie = Et[Wt].timestamp - rt[Wt].timestamp;
                                if (ie > 1) {
                                  const de = K(Et[Wt].bytes, ie);
                                  kt.push(de), Ut = 0;
                                } else {
                                  Ut === 0 && (Ut = rt[Wt].timestamp, Dt = 0);
                                  let de = Et[Wt].timestamp - Ut;
                                  if (de > 1) {
                                    Dt += Et[Wt].bytes;
                                    const Be = K(Dt, de);
                                    kt.push(Be), Ut = 0;
                                  } else Dt += Et[Wt].bytes;
                                }
                              }
                              return kt.length > 0 ? kt.reduce((Wt, ie) => Wt + ie, 0) / kt.length : null;
                            } catch (rt) {
                              return null;
                            }
                          }(ht, _t);
                          return dt ? 8 * wt / dt : null;
                        }() : bt === X.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.DOWNLOADED_DATA && (It = W(J, wt)), It;
                      }();
                      ut.customData.onprogress({ loaded: wt, total: wt, lengthComputable: !0, time: ct }), mt.data = P.buffer;
                    }
                    ut.customData.onloadend();
                  }() : (Pt && Pt.length > 0 && function(ct) {
                    P = function(dt, nt) {
                      if (dt.length === 0) return nt;
                      const ft = new Uint8Array(dt.length + nt.length);
                      return ft.set(dt), ft.set(nt, dt.length), ft;
                    }(P, ct), wt += ct.length, J.push({ timestamp: H(), bytes: ct.length }), bt === X.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING && Ct && _.findLastTopIsoBoxCompleted(["moof"], P, j).found && (Ct = !1, ht.push({ timestamp: H() }));
                    const It = _.findLastTopIsoBoxCompleted(["moov", "mdat"], P, j);
                    It.found ? function(dt) {
                      const nt = function(ft) {
                        let rt;
                        return ft === P.length ? (rt = P, P = new Uint8Array()) : (rt = new Uint8Array(P.subarray(0, ft)), P = P.subarray(ft)), rt;
                      }(dt.startOffsetOfLastFoundTargetBox + dt.sizeOfLastFoundTargetBox);
                      bt !== X.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING || Ct || (Ct = !0, _t.push({ timestamp: H(), bytes: nt.length })), ut.customData.onprogress({ data: nt.buffer, lengthComputable: !1, noTrace: !0 }), j = 0;
                    }(It) : function(dt) {
                      j = dt.startOffsetOfLastCompletedBox + dt.sizeOfLastCompletedBox, $ || (ut.customData.onprogress({ lengthComputable: !1, noTrace: !0 }), $ = !0);
                    }(It);
                  }(Pt), M(ut, 0, Rt));
                };
                M(ut, 0, Rt);
              })(st, R, G);
            }).catch(() => {
              Y(R);
            });
          }, reset: function() {
          }, setConfig: function(R) {
            _ = R.boxParser;
          } }, C;
        }
        _a.__dashjs_factory_name = "FetchLoader";
        var ei = Bt.A.getClassFactory(_a), ni = w(913), nr = class {
          constructor() {
            this.period = null, this.index = -1, this.type = null;
          }
        };
        class Ma {
          constructor(f, C, _, v) {
            this.url = f || "", this.serviceLocation = C || f || "", this.dvbPriority = _ || 1, this.dvbWeight = v || 1, this.availabilityTimeOffset = 0, this.availabilityTimeComplete = !0, this.queryParams = {};
          }
        }
        Ma.DEFAULT_DVB_PRIORITY = 1, Ma.DEFAULT_DVB_WEIGHT = 1;
        var ba = Ma, Ka = class {
          constructor() {
            this.schemeIdUri = null, this.value = null, this.id = null;
          }
          init(A) {
            A && (this.schemeIdUri = A.schemeIdUri ? A.schemeIdUri : null, this.value = A.value !== null && A.value !== void 0 ? A.value.toString() : null, this.id = A.id ? A.id : null, A[D.A.DVB_URL] && (this.dvbUrl = A[D.A.DVB_URL]), A[D.A.DVB_MIMETYPE] && (this.dvbMimeType = A[D.A.DVB_MIMETYPE]), A[D.A.DVB_FONTFAMILY] && (this.dvbFontFamily = A[D.A.DVB_FONTFAMILY]));
          }
          inArray(A) {
            return !!A && A.some((f) => this.schemeIdUri === f.schemeIdUri && (this.value ? this.value.toString().match(f.value) : "".match(f.value)));
          }
        }, Lo = class extends Ka {
          constructor() {
            super(), this.version = null, this.sessionID = null, this.contentID = null, this.mode = null, this.keys = null, this.includeInRequests = null;
          }
          init(A) {
            var f;
            super.init(A), A && (this.version = A.version, this.sessionID = A.sessionID, this.contentID = A.contentID, this.mode = (f = A.mode) != null ? f : "query", this.keys = A.keys ? A.keys.split(" ") : null, this.includeInRequests = A.includeInRequests ? A.includeInRequests.split(" ") : ["segment"], this.schemeIdUri = A.schemeIdUri);
          }
        }, $s = class {
          constructor() {
            this.adaptationSets = null, this.adaptationSetsArray = [], this.cmcdParameters = null, this.serviceLocations = null, this.serviceLocationsArray = [];
          }
        }, Mo = class extends Ka {
          constructor() {
            super(), this.ref = null, this.refId = null, this.robustness = null, this.keyId = null, this.cencDefaultKid = null, this.pssh = null, this.pro = null, this.laUrl = null;
          }
          init(A) {
            super.init(A), A && (this.ref = A.hasOwnProperty(D.A.REF) ? A[D.A.REF] : null, this.refId = A.hasOwnProperty(D.A.REF_ID) ? A[D.A.REF_ID] : null, this.robustness = A.hasOwnProperty(D.A.ROBUSTNESS) ? A[D.A.ROBUSTNESS] : null, this.cencDefaultKid = A.hasOwnProperty(D.A.CENC_DEFAULT_KID) ? A[D.A.CENC_DEFAULT_KID] : null, this.pssh = A.hasOwnProperty(D.A.PSSH) ? A[D.A.PSSH] : null, this.pro = A.hasOwnProperty(D.A.PRO) ? A[D.A.PRO] : null, this.laUrl = A.hasOwnProperty(D.A.LA_URL) ? A[D.A.LA_URL] : A.hasOwnProperty(D.A.LA_URL_LOWER_CASE) ? A[D.A.LA_URL_LOWER_CASE] : null);
          }
          mergeAttributesFromReference(A) {
            ["schemeIdUri", "value", "id", "robustness", "cencDefaultKid", "pro", "pssh", "laUrl"].forEach((f) => {
              this[f] === null && (this[f] = A[f]);
            });
          }
        }, Ro = class {
          constructor() {
            this.defaultServiceLocation = null, this.defaultServiceLocationArray = [], this.queryBeforeStart = !1, this.serverUrl = null, this.clientRequirement = !0;
          }
        }, cs = class {
          constructor() {
            this.type = "", this.duration = NaN, this.presentationTime = NaN, this.id = NaN, this.messageData = "", this.eventStream = null, this.presentationTimeDelta = NaN, this.parsedMessageData = null;
          }
        }, to = class {
          constructor() {
            this.adaptionSet = null, this.representation = null, this.period = null, this.timescale = 1, this.value = "", this.schemeIdUri = "", this.presentationTimeOffset = 0;
          }
        }, Fe = class {
          constructor() {
            this.availabilityEndTime = Number.POSITIVE_INFINITY, this.availabilityStartTime = null, this.manifest = null, this.maxSegmentDuration = Number.POSITIVE_INFINITY, this.mediaPresentationDuration = NaN, this.minimumUpdatePeriod = NaN, this.publishTime = null, this.suggestedPresentationDelay = 0, this.timeShiftBufferDepth = Number.POSITIVE_INFINITY;
          }
        }, dn = class {
          constructor(A, f) {
            this.url = A || "", this.serviceLocation = f || null, this.queryParams = {};
          }
        }, kn = w(7393), Jn = class {
          constructor(A, f, C) {
            this.url = A || "", this.serviceLocation = f || null, this.ttl = C || NaN, this.queryParams = {};
          }
        };
        class On {
          constructor() {
            this.id = null, this.index = -1, this.duration = NaN, this.start = NaN, this.mpd = null, this.nextPeriodId = null, this.isEncrypted = !1;
          }
        }
        On.DEFAULT_ID = "defaultId";
        var Ra = On, la = class {
          constructor() {
            this.id = null, this.inband = !1, this.type = "encoder", this.applicationScheme = null, this.wallClockTime = null, this.presentationTime = NaN, this.UTCTiming = null;
          }
        }, $n = class {
          constructor() {
            this.absoluteIndex = NaN, this.adaptation = null, this.availabilityTimeComplete = !0, this.availabilityTimeOffset = 0, this.bandwidth = NaN, this.bitrateInKbit = NaN, this.bitsPerPixel = NaN, this.codecFamily = null, this.codecPrivateData = null, this.codecs = null, this.essentialProperties = [], this.fragmentDuration = null, this.frameRate = null, this.height = NaN, this.id = null, this.indexRange = null, this.initialization = null, this.maxPlayoutRate = NaN, this.mediaFinishedInformation = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN }, this.mediaInfo = null, this.mimeType = null, this.mseTimeOffset = NaN, this.pixelsPerSecond = NaN, this.presentationTimeOffset = 0, this.qualityRanking = NaN, this.range = null, this.scanType = null, this.segments = null, this.segmentDuration = NaN, this.segmentInfoType = null, this.supplementalProperties = [], this.startNumber = 1, this.timescale = 1, this.width = NaN, this.endNumber = null;
          }
          hasInitialization() {
            return this.initialization !== null || this.range !== null;
          }
          hasSegments() {
            return this.segmentInfoType !== D.A.BASE_URL && this.segmentInfoType !== D.A.SEGMENT_BASE && !this.indexRange;
          }
        }, xn = w(5717), Vn = w(7840);
        function ua(A) {
          return A && A.includes("P") ? Vn.duration(A).asSeconds() : A;
        }
        function Ui() {
          let A, f, C, _;
          const v = this.context, M = He(v).getInstance(), Y = Number.isInteger || function(N) {
            return typeof N == "number" && isFinite(N) && Math.floor(N) === N;
          };
          function H(N, ct) {
            if (!N) throw new Error("adaptation is not defined");
            if (!ct) throw new Error("type is not defined");
            if (N.Representation && N.Representation.length) {
              const dt = j(N.Representation[0]);
              if (dt && dt.some((nt) => X.A.THUMBNAILS_SCHEME_ID_URIS.indexOf(nt.schemeIdUri) >= 0)) return ct === X.A.IMAGE;
            }
            if (N.ContentComponent && N.ContentComponent.length > 0) {
              if (N.ContentComponent.length > 1) return ct === X.A.MUXED;
              if (N.ContentComponent[0].contentType === ct) return !0;
            }
            const It = ct === X.A.TEXT ? new RegExp("(ttml|vtt|wvtt|stpp)") : new RegExp(ct);
            if (N.Representation && N.Representation.length) {
              const dt = N.Representation[0].codecs;
              if (It.test(dt)) return !0;
            }
            if (N.hasOwnProperty(D.A.MIME_TYPE)) return It.test(N.mimeType);
            if (N.Representation) {
              let dt;
              for (let nt = 0; nt < N.Representation.length; nt++) if (dt = N.Representation[nt], dt.hasOwnProperty(D.A.MIME_TYPE)) return It.test(dt.mimeType);
            }
            return !1;
          }
          function L(N) {
            if (!N) throw new Error("adaptation is not defined");
            if (N.hasOwnProperty(D.A.SEGMENT_TEMPLATE) || N.hasOwnProperty(D.A.SEGMENT_TIMELINE) || N.hasOwnProperty(D.A.SEGMENT_LIST) || N.hasOwnProperty(D.A.SEGMENT_BASE)) return !0;
            if (N.Representation && N.Representation.length > 0) {
              const ct = N.Representation[0];
              if (ct.hasOwnProperty(D.A.SEGMENT_TEMPLATE) || ct.hasOwnProperty(D.A.SEGMENT_TIMELINE) || ct.hasOwnProperty(D.A.SEGMENT_LIST) || ct.hasOwnProperty(D.A.SEGMENT_BASE)) return !0;
            }
            return !1;
          }
          function W(N) {
            return H(N, X.A.MESH);
          }
          function K(N) {
            return H(N, X.A.VIDEO);
          }
          function R(N) {
            return H(N, X.A.TEXT);
          }
          function G(N) {
            return H(N, X.A.IMAGE);
          }
          function F(N) {
            return N && N.Representation && N.Representation.sort((ct, It) => ct.bandwidth - It.bandwidth), N;
          }
          function et(N, ct) {
            return N && N.Period && Y(ct) && N.Period[ct] ? N.Period[ct].AdaptationSet : [];
          }
          function it(N) {
            return N && N.Period ? N.Period : [];
          }
          function st(N) {
            const ct = ot(N);
            return ct && ct.length > 0;
          }
          function ot(N) {
            let ct = [];
            if (!N) return ct;
            const It = ut(N);
            return ct = ct.concat(It), N.hasOwnProperty(D.A.ADAPTATION_SET) && N[D.A.ADAPTATION_SET].length > 0 && N[D.A.ADAPTATION_SET].forEach((dt) => {
              const nt = ut(dt);
              ct = ct.concat(nt);
            }), ct;
          }
          function ut(N) {
            return N && N.hasOwnProperty(D.A.CONTENT_PROTECTION) && N.ContentProtection.length !== 0 ? N[D.A.CONTENT_PROTECTION].map((ct) => {
              const It = new Mo();
              return It.init(ct), It;
            }) : [];
          }
          function mt(N) {
            let ct = !1;
            return N && N.hasOwnProperty("type") && (ct = N.type === D.A.DYNAMIC), ct;
          }
          function wt(N) {
            if (!N) return null;
            const ct = N[D.A.FRAMERATE];
            if (!ct) return null;
            if (typeof ct == "string" && ct.includes("/")) {
              const [It, dt] = ct.split("/").map((nt) => parseInt(nt, 10));
              if (!isNaN(It) && !isNaN(dt) && dt !== 0) return It / dt;
            }
            return parseInt(ct);
          }
          function $(N, ct) {
            return ct && ct.hasOwnProperty(N) && ct[N].length ? ct[N].map((It) => {
              const dt = new Ka();
              return dt.init(It), dt;
            }) : [];
          }
          function P(N, ct) {
            if (!ct) return [];
            let It = function(dt, nt) {
              if (!nt || !nt.length) return [];
              let ft = nt[0][dt] || [];
              return ft.length === 0 ? [] : nt.length === 1 ? ft : ft.filter((rt) => nt.slice(1).every((Et) => Et.hasOwnProperty(dt) && Et[dt].some((kt) => kt.schemeIdUri === rt.schemeIdUri && kt.value === rt.value)));
            }(N, ct[D.A.REPRESENTATION]);
            return ct.hasOwnProperty(N) && ct[N].length && It.push(...ct[N]), It.map((dt) => {
              const nt = new Ka();
              return nt.init(dt), nt;
            });
          }
          function j(N) {
            return $(D.A.ESSENTIAL_PROPERTY, N);
          }
          function J(N) {
            return $(D.A.SUPPLEMENTAL_PROPERTY, N);
          }
          function ht(N) {
            if (!N || !N.S) return NaN;
            let ct = N.S[0], It = N.S[1];
            return ct.hasOwnProperty("d") ? ct.d : It.t - ct.t;
          }
          function _t(N) {
            const ct = N.presentationTimeOffset;
            return N.adaptation.period.start - ct;
          }
          function Ct(N, ct) {
            if (!N) throw new Error("Period cannot be null or undefined");
            let It = Ra.DEFAULT_ID + "_" + ct;
            return N.hasOwnProperty(D.A.ID) && N.id.toString().length > 0 && N.id !== "__proto__" && (It = N.id.toString()), It;
          }
          function bt(N, ct, It) {
            const dt = [];
            let nt;
            if (!N) return dt;
            for (nt = 0; nt < N.length; nt++) {
              const ft = new to();
              if (ft.timescale = 1, ft.representation = ct, !N[nt].hasOwnProperty(X.A.SCHEME_ID_URI)) throw new Error("Invalid EventStream. SchemeIdUri has to be set");
              ft.schemeIdUri = N[nt].schemeIdUri, N[nt].hasOwnProperty(D.A.TIMESCALE) && (ft.timescale = N[nt].timescale), N[nt].hasOwnProperty(D.A.VALUE) && (ft.value = N[nt].value), dt.push(ft), ft.period = It;
            }
            return dt;
          }
          function Rt(N) {
            const ct = [], It = N.BaseURL || [N.baseUri];
            let dt = !1;
            return It.some((nt) => {
              if (nt) {
                const ft = new ba();
                let rt = nt.__text || nt;
                return M.isRelative(rt) && (dt = !0, N.baseUri && (rt = M.resolve(rt, N.baseUri))), ft.url = rt, nt.hasOwnProperty(D.A.SERVICE_LOCATION) && nt.serviceLocation.length ? ft.serviceLocation = nt.serviceLocation : ft.serviceLocation = rt, nt.hasOwnProperty(D.A.DVB_PRIORITY) && (ft.dvbPriority = nt[D.A.DVB_PRIORITY]), nt.hasOwnProperty(D.A.DVB_WEIGHT) && (ft.dvbWeight = nt[D.A.DVB_WEIGHT]), nt.hasOwnProperty(D.A.AVAILABILITY_TIME_OFFSET) && (ft.availabilityTimeOffset = `${ua(nt[D.A.AVAILABILITY_TIME_OFFSET]) || 4}`), nt.hasOwnProperty(D.A.AVAILABILITY_TIME_COMPLETE) && (ft.availabilityTimeComplete = nt[D.A.AVAILABILITY_TIME_COMPLETE] !== "false"), ct.push(ft), dt;
              }
            }), ct;
          }
          function xt(N) {
            const ct = new Ro();
            return ct.serverUrl = N.__text, N.hasOwnProperty(D.A.DEFAULT_SERVICE_LOCATION) && (ct.defaultServiceLocation = N[D.A.DEFAULT_SERVICE_LOCATION], ct.defaultServiceLocationArray = ct.defaultServiceLocation.split(" ")), N.hasOwnProperty(D.A.QUERY_BEFORE_START) && (ct.queryBeforeStart = N[D.A.QUERY_BEFORE_START].toLowerCase() === "true"), N.hasOwnProperty(D.A.CLIENT_REQUIREMENT) && (ct.clientRequirement = N[D.A.CLIENT_REQUIREMENT].toLowerCase() !== "false"), ct;
          }
          function Pt(N) {
            const ct = new $s();
            return N.hasOwnProperty(D.A.CMCD_PARAMETERS) && N[D.A.CMCD_PARAMETERS].schemeIdUri === X.A.CTA_5004_2023_SCHEME && (ct.cmcdParameters = new Lo(), ct.cmcdParameters.init(N[D.A.CMCD_PARAMETERS])), N.hasOwnProperty(D.A.SERVICE_LOCATIONS) && N[D.A.SERVICE_LOCATIONS] !== "" && (ct.serviceLocations = N[D.A.SERVICE_LOCATIONS], ct.serviceLocationsArray = ct.serviceLocations.toString().split(" ")), N.hasOwnProperty(D.A.ADAPTATION_SETS) && N[D.A.ADAPTATION_SETS] !== "" && (ct.adaptationSets = N[D.A.ADAPTATION_SETS], ct.adaptationSetsArray = ct.adaptationSets.toString().split(" ")), ct;
          }
          return A = { getAccessibilityForAdaptation: function(N) {
            return N && N.hasOwnProperty(D.A.ACCESSIBILITY) && N[D.A.ACCESSIBILITY].length ? N[D.A.ACCESSIBILITY].map((ct) => {
              const It = new Ka();
              return It.init(ct), It;
            }) : [];
          }, getAdaptationForId: function(N, ct, It) {
            const dt = et(ct, It);
            let nt, ft;
            for (nt = 0, ft = dt.length; nt < ft; nt++) if (dt[nt].hasOwnProperty(D.A.ID) && dt[nt].id === N) return dt[nt];
            return null;
          }, getAdaptationForIndex: function(N, ct, It) {
            const dt = et(ct, It);
            return dt.length > 0 && Y(N) ? dt[N] : null;
          }, getAdaptationsForPeriod: function(N) {
            const ct = N && Y(N.index) ? N.mpd.manifest.Period[N.index] : null, It = [];
            let dt, nt, ft;
            if (ct && ct.AdaptationSet) for (ft = 0; ft < ct.AdaptationSet.length; ft++) nt = ct.AdaptationSet[ft], dt = new nr(), nt.hasOwnProperty(D.A.ID) && (dt.id = nt.id), dt.index = ft, dt.period = N, H(nt, X.A.MUXED) ? dt.type = X.A.MUXED : H(nt, X.A.AUDIO) ? dt.type = X.A.AUDIO : K(nt) ? dt.type = X.A.VIDEO : R(nt) ? dt.type = X.A.TEXT : G(nt) ? dt.type = X.A.IMAGE : W(nt) ? dt.type = X.A.MESH : f.warn("Unknown Adaptation stream type"), It.push(dt);
            return It;
          }, getAdaptationsForType: function(N, ct, It) {
            const dt = et(N, ct);
            let nt, ft;
            const rt = [];
            for (nt = 0, ft = dt.length; nt < ft; nt++) H(dt[nt], It) && rt.push(F(dt[nt]));
            return rt;
          }, getAudioChannelConfigurationForAdaptation: function(N) {
            return N && N.hasOwnProperty(D.A.AUDIO_CHANNEL_CONFIGURATION) && N[D.A.AUDIO_CHANNEL_CONFIGURATION].length ? N[D.A.AUDIO_CHANNEL_CONFIGURATION].map((ct) => {
              const It = new Ka();
              return It.init(ct), It;
            }) : [];
          }, getAudioChannelConfigurationForRepresentation: function(N) {
            return N && N.hasOwnProperty(D.A.AUDIO_CHANNEL_CONFIGURATION) && N[D.A.AUDIO_CHANNEL_CONFIGURATION].length ? N[D.A.AUDIO_CHANNEL_CONFIGURATION].map((ct) => {
              const It = new Ka();
              return It.init(ct), It;
            }) : [];
          }, getAvailabilityStartTime: function(N) {
            return N && N.hasOwnProperty(D.A.AVAILABILITY_START_TIME) && N.availabilityStartTime !== null ? N.availabilityStartTime.getTime() : null;
          }, getBandwidth: function(N) {
            return N && N.bandwidth ? N.bandwidth : NaN;
          }, getBaseURLsFromElement: Rt, getBitrateListForAdaptation: function(N) {
            const ct = F(N);
            return (ct && ct.Representation ? ct.Representation : []).map((It) => ({ bandwidth: It.bandwidth, width: It.width || 0, height: It.height || 0, scanType: It.scanType || null, id: It.id || null }));
          }, getCodec: function(N, ct, It) {
            let dt = null;
            if (N && N.Representation && N.Representation.length > 0) {
              const nt = Y(ct) && ct >= 0 && ct < N.Representation.length ? N.Representation[ct] : N.Representation[0];
              nt && (dt = nt.mimeType + ';codecs="' + nt.codecs + '"', It && nt.width !== void 0 && (dt += ';width="' + nt.width + '";height="' + nt.height + '"'));
            }
            return dt && (dt = dt.replace(/\sprofiles=[^;]*/g, "")), dt;
          }, getCombinedEssentialPropertiesForAdaptationSet: function(N) {
            return P(D.A.ESSENTIAL_PROPERTY, N);
          }, getCombinedSupplementalPropertiesForAdaptationSet: function(N) {
            return P(D.A.SUPPLEMENTAL_PROPERTY, N);
          }, getContentProtectionByAdaptation: function(N) {
            return ut(N);
          }, getContentProtectionByManifest: function(N) {
            let ct = [];
            if (!N) return ct;
            const It = ut(N);
            return ct = ct.concat(It), N.hasOwnProperty(D.A.PERIOD) && N[D.A.PERIOD].length > 0 && N[D.A.PERIOD].forEach((dt) => {
              const nt = ot(dt);
              ct = ct.concat(nt);
            }), ct;
          }, getContentProtectionByPeriod: ot, getContentSteering: function(N) {
            if (N && N.hasOwnProperty(D.A.CONTENT_STEERING)) return xt(N[D.A.CONTENT_STEERING][0]);
          }, getDuration: function(N) {
            let ct;
            return ct = N && N.hasOwnProperty(D.A.MEDIA_PRESENTATION_DURATION) ? N.mediaPresentationDuration : N && N.type == "dynamic" ? Number.POSITIVE_INFINITY : Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, ct;
          }, getEssentialPropertiesForAdaptationSet: function(N) {
            return $(D.A.ESSENTIAL_PROPERTY, N);
          }, getEssentialPropertiesForRepresentation: j, getEventStreamForAdaptationSet: function(N, ct, It) {
            let dt, nt, ft;
            return N && N.Period && ct && ct.period && Y(ct.period.index) && (nt = N.Period[ct.period.index], nt && nt.AdaptationSet && Y(ct.index) && (ft = nt.AdaptationSet[ct.index], ft && (dt = ft.InbandEventStream))), bt(dt, null, It);
          }, getEventStreamForRepresentation: function(N, ct, It) {
            let dt, nt, ft, rt;
            return N && N.Period && ct && ct.adaptation && ct.adaptation.period && Y(ct.adaptation.period.index) && (nt = N.Period[ct.adaptation.period.index], nt && nt.AdaptationSet && Y(ct.adaptation.index) && (ft = nt.AdaptationSet[ct.adaptation.index], ft && ft.Representation && Y(ct.index) && (rt = ft.Representation[ct.index], rt && (dt = rt.InbandEventStream)))), bt(dt, ct, It);
          }, getEventsForPeriod: function(N) {
            const ct = N && N.mpd && N.mpd.manifest ? N.mpd.manifest : null, It = ct ? ct.Period : null, dt = It && N && Y(N.index) ? It[N.index].EventStream : null, nt = [];
            let ft, rt;
            if (dt) for (ft = 0; ft < dt.length; ft++) {
              const Et = new to();
              if (Et.period = N, Et.timescale = 1, !dt[ft].hasOwnProperty(X.A.SCHEME_ID_URI)) throw new Error("Invalid EventStream. SchemeIdUri has to be set");
              for (Et.schemeIdUri = dt[ft][X.A.SCHEME_ID_URI], dt[ft].hasOwnProperty(D.A.TIMESCALE) && (Et.timescale = dt[ft][D.A.TIMESCALE]), dt[ft].hasOwnProperty(D.A.VALUE) && (Et.value = dt[ft][D.A.VALUE]), dt[ft].hasOwnProperty(D.A.PRESENTATION_TIME_OFFSET) && (Et.presentationTimeOffset = dt[ft][D.A.PRESENTATION_TIME_OFFSET]), rt = 0; dt[ft].Event && rt < dt[ft].Event.length; rt++) {
                const kt = dt[ft].Event[rt], Dt = new cs();
                Dt.presentationTime = 0, Dt.eventStream = Et, kt.hasOwnProperty(D.A.PRESENTATION_TIME) && (Dt.presentationTime = kt.presentationTime);
                const Ut = Et.presentationTimeOffset ? Et.presentationTimeOffset / Et.timescale : 0;
                Dt.calculatedPresentationTime = Dt.presentationTime / Et.timescale + N.start - Ut, kt.hasOwnProperty(D.A.DURATION) && (Dt.duration = kt.duration / Et.timescale), kt.hasOwnProperty(D.A.ID) ? Dt.id = parseInt(kt.id) : Dt.id = null, kt.Signal && kt.Signal.Binary ? Dt.messageData = _.decodeArray(kt.Signal.Binary.toString()) : Dt.messageData = kt.messageData || kt.__cdata || kt.__text, nt.push(Dt);
              }
            }
            return nt;
          }, getFramerate: wt, getId: function(N) {
            return N && N[D.A.ID] || null;
          }, getIndexForAdaptation: function(N, ct, It) {
            if (!N) return -1;
            const dt = et(ct, It);
            for (let nt = 0; nt < dt.length; nt++) if ((0, kn.A)(v).getInstance().areEqual(dt[nt], N)) return nt;
            return -1;
          }, getIsDynamic: mt, getIsFragmented: L, getIsText: R, getIsTypeOf: H, getLabelsForAdaptation: function(N) {
            if (!N || !N.Label) return [];
            const ct = [];
            for (let It = 0; It < N.Label.length; It++) ct.push({ lang: N.Label[It].lang, text: N.Label[It].__text || N.Label[It] });
            return ct;
          }, getLanguageForAdaptation: function(N) {
            let ct = "";
            return N && N.hasOwnProperty(D.A.LANG) && (ct = N.lang), ct;
          }, getLocation: function(N) {
            return N && N.hasOwnProperty(D.A.LOCATION) ? N[D.A.LOCATION].map((ct) => {
              const It = ct.__text || ct, dt = ct.hasOwnProperty(D.A.SERVICE_LOCATION) ? ct[D.A.SERVICE_LOCATION] : null;
              return new dn(It, dt);
            }) : [];
          }, getManifestUpdatePeriod: function(N) {
            let ct = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, It = NaN;
            return N && N.hasOwnProperty(D.A.MINIMUM_UPDATE_PERIOD) && (It = N.minimumUpdatePeriod), isNaN(It) ? It : Math.max(It - ct, 1);
          }, getMimeType: function(N) {
            return N && N.Representation && N.Representation.length > 0 ? N.Representation[0].mimeType : null;
          }, getMpd: function(N) {
            const ct = new Fe();
            return N && (ct.manifest = N, N.hasOwnProperty(D.A.AVAILABILITY_START_TIME) ? ct.availabilityStartTime = new Date(N.availabilityStartTime.getTime()) : N.loadedTime && (ct.availabilityStartTime = new Date(N.loadedTime.getTime())), N.hasOwnProperty(D.A.AVAILABILITY_END_TIME) && (ct.availabilityEndTime = new Date(N.availabilityEndTime.getTime())), N.hasOwnProperty(D.A.MINIMUM_UPDATE_PERIOD) && (ct.minimumUpdatePeriod = N.minimumUpdatePeriod), N.hasOwnProperty(D.A.MEDIA_PRESENTATION_DURATION) && (ct.mediaPresentationDuration = N.mediaPresentationDuration), N.hasOwnProperty(D.A.SUGGESTED_PRESENTATION_DELAY) && (ct.suggestedPresentationDelay = N.suggestedPresentationDelay), N.hasOwnProperty(D.A.TIMESHIFT_BUFFER_DEPTH) && (ct.timeShiftBufferDepth = N.timeShiftBufferDepth), N.hasOwnProperty(D.A.MAX_SEGMENT_DURATION) && (ct.maxSegmentDuration = N.maxSegmentDuration), N.hasOwnProperty(D.A.PUBLISH_TIME) && (ct.publishTime = new Date(N.publishTime))), ct;
          }, getPatchLocation: function(N) {
            return N && N.hasOwnProperty(D.A.PATCH_LOCATION) ? N[D.A.PATCH_LOCATION].map((ct) => {
              const It = ct.__text || ct, dt = ct.hasOwnProperty(D.A.SERVICE_LOCATION) ? ct[D.A.SERVICE_LOCATION] : null;
              let nt = ct.hasOwnProperty(D.A.TTL) ? 1e3 * parseFloat(ct[D.A.TTL]) : NaN;
              return new Jn(It, dt, nt);
            }) : [];
          }, getProducerReferenceTimesForAdaptation: function(N) {
            const ct = N && N.hasOwnProperty(D.A.PRODUCER_REFERENCE_TIME) ? N[D.A.PRODUCER_REFERENCE_TIME] : [];
            (N && N.hasOwnProperty(D.A.REPRESENTATION) ? N[D.A.REPRESENTATION] : []).forEach((dt) => {
              dt.hasOwnProperty(D.A.PRODUCER_REFERENCE_TIME) && ct.push(...dt[D.A.PRODUCER_REFERENCE_TIME]);
            });
            const It = [];
            return ct.forEach((dt) => {
              const nt = new la();
              dt.hasOwnProperty(D.A.ID) && (nt[D.A.ID] = parseInt(dt[D.A.ID]), dt.hasOwnProperty(D.A.WALL_CLOCK_TIME) && (nt[D.A.WALL_CLOCK_TIME] = dt[D.A.WALL_CLOCK_TIME], dt.hasOwnProperty(D.A.PRESENTATION_TIME) && (nt[D.A.PRESENTATION_TIME] = dt[D.A.PRESENTATION_TIME], dt.hasOwnProperty(D.A.INBAND) && (nt[D.A.INBAND] = dt[D.A.INBAND] !== "false"), dt.hasOwnProperty(D.A.TYPE) && (nt[D.A.TYPE] = dt[D.A.TYPE]), It.push(nt))));
            }), It;
          }, getPublishTime: function(N) {
            return N && N.hasOwnProperty(D.A.PUBLISH_TIME) ? new Date(N[D.A.PUBLISH_TIME]) : null;
          }, getRealPeriodForIndex: function(N, ct) {
            const It = it(ct);
            return It.length > 0 && Y(N) ? It[N] : null;
          }, getRealPeriods: it, getRegularPeriods: function(N) {
            const ct = !!N && mt(N.manifest), It = [];
            let dt, nt, ft = null, rt = null, Et = null, kt = null;
            for (nt = 0, dt = N && N.manifest && N.manifest.Period ? N.manifest.Period.length : 0; nt < dt; nt++) rt = N.manifest.Period[nt], rt.hasOwnProperty(D.A.START) ? (kt = new Ra(), kt.start = rt.start) : ft !== null && ft.hasOwnProperty(D.A.DURATION) && Et !== null ? (kt = new Ra(), kt.start = parseFloat((Et.start + Et.duration).toFixed(5))) : nt !== 0 || ct || (kt = new Ra(), kt.start = 0), Et !== null && isNaN(Et.duration) && (kt !== null ? Et.duration = parseFloat((kt.start - Et.start).toFixed(5)) : f.warn("First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback")), kt !== null && (kt.id = Ct(rt, nt), kt.index = nt, kt.mpd = N, kt.isEncrypted = st(rt), rt.hasOwnProperty(D.A.DURATION) && (kt.duration = rt.duration), Et && (Et.nextPeriodId = kt.id), It.push(kt), ft = rt, Et = kt), rt = null, kt = null;
            return It.length === 0 || Et !== null && isNaN(Et.duration) && (Et.duration = parseFloat((function(Dt) {
              (function() {
                if (!C || !C.hasOwnProperty("error")) throw new Error(X.A.MISSING_CONFIG_ERROR);
              })();
              const Ut = mt(Dt.mpd.manifest);
              let Wt;
              return Dt.mpd.manifest.mediaPresentationDuration ? Wt = Dt.mpd.manifest.mediaPresentationDuration : Dt.duration ? Wt = Dt.duration : Ut ? Wt = Number.POSITIVE_INFINITY : C.error(new Nt.A(q.MANIFEST_ERROR_ID_PARSE_CODE, "Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.", Dt)), Wt;
            }(Et) - Et.start).toFixed(5))), It;
          }, getRepresentationCount: function(N) {
            return N && N.Representation ? N.Representation.length : 0;
          }, getRepresentationFor: function(N, ct) {
            return ct && ct.Representation && ct.Representation.length > 0 && Y(N) ? ct.Representation[N] : null;
          }, getRepresentationSortFunction: function() {
            return (N, ct) => N.bandwidth - ct.bandwidth;
          }, getRepresentationsForAdaptation: function(N, ct) {
            const It = [], dt = function(rt) {
              if (rt && rt.period && Y(rt.period.index)) {
                const Et = rt.period.mpd.manifest.Period[rt.period.index];
                if (Et && Et.AdaptationSet && Y(rt.index)) return F(Et.AdaptationSet[rt.index]);
              }
            }(N);
            let nt, ft;
            if (dt && dt.Representation) {
              if (N && N.period && Y(N.period.index)) {
                const rt = Rt(N.period.mpd.manifest);
                rt && (ft = rt[0]);
              }
              for (let rt = 0, Et = dt.Representation.length; rt < Et; ++rt) {
                const kt = dt.Representation[rt], Dt = new $n();
                if (Dt.index = rt, Dt.adaptation = N, Dt.mediaInfo = ct, kt.hasOwnProperty(D.A.ID) && (Dt.id = kt.id), kt.hasOwnProperty(D.A.CODECS) && (Dt.codecs = kt.codecs, Dt.codecFamily = jn.A.getCodecFamily(Dt.codecs)), kt.hasOwnProperty(D.A.MIME_TYPE) && (Dt.mimeType = kt[D.A.MIME_TYPE]), kt.hasOwnProperty(D.A.CODEC_PRIVATE_DATA) && (Dt.codecPrivateData = kt.codecPrivateData), kt.hasOwnProperty(D.A.BANDWITH) && (Dt.bandwidth = kt.bandwidth, Dt.bitrateInKbit = kt.bandwidth / 1e3), kt.hasOwnProperty(D.A.WIDTH) && (Dt.width = kt.width), kt.hasOwnProperty(D.A.HEIGHT) && (Dt.height = kt.height), kt.hasOwnProperty(D.A.SCAN_TYPE) && (Dt.scanType = kt.scanType), kt.hasOwnProperty(D.A.FRAMERATE) && (Dt.frameRate = wt(kt)), kt.hasOwnProperty(D.A.QUALITY_RANKING) && (Dt.qualityRanking = kt[D.A.QUALITY_RANKING]), kt.hasOwnProperty(D.A.MAX_PLAYOUT_RATE) && (Dt.maxPlayoutRate = kt.maxPlayoutRate), kt.hasOwnProperty(D.A.SEGMENT_BASE) ? (nt = kt.SegmentBase, Dt.segmentInfoType = D.A.SEGMENT_BASE) : kt.hasOwnProperty(D.A.SEGMENT_LIST) ? (nt = kt.SegmentList, nt.hasOwnProperty(D.A.SEGMENT_TIMELINE) ? Dt.segmentInfoType = D.A.SEGMENT_TIMELINE : Dt.segmentInfoType = D.A.SEGMENT_LIST) : kt.hasOwnProperty(D.A.SEGMENT_TEMPLATE) ? (nt = kt.SegmentTemplate, nt.hasOwnProperty(D.A.SEGMENT_TIMELINE) ? Dt.segmentInfoType = D.A.SEGMENT_TIMELINE : Dt.segmentInfoType = D.A.SEGMENT_TEMPLATE, nt.hasOwnProperty(D.A.INITIALIZATION_MINUS) && (Dt.initialization = nt.initialization.split("$Bandwidth$").join(kt.bandwidth).split("$RepresentationID$").join(kt.id))) : Dt.segmentInfoType = D.A.BASE_URL, Dt.essentialProperties = j(kt), Dt.supplementalProperties = J(kt), nt) {
                  if (nt.hasOwnProperty(D.A.INITIALIZATION)) {
                    const Ut = nt.Initialization;
                    Ut.hasOwnProperty(D.A.SOURCE_URL) && (Dt.initialization = Ut.sourceURL), Ut.hasOwnProperty(D.A.RANGE) && (Dt.range = Ut.range);
                  } else R(dt) && L(dt) && dt.mimeType && dt.mimeType.indexOf("application/mp4") === -1 && (Dt.range = 0);
                  nt.hasOwnProperty(D.A.TIMESCALE) && (Dt.timescale = nt.timescale), nt.hasOwnProperty(D.A.DURATION) ? Dt.segmentDuration = nt.duration / Dt.timescale : kt.hasOwnProperty(D.A.SEGMENT_TEMPLATE) && (nt = kt.SegmentTemplate, nt.hasOwnProperty(D.A.SEGMENT_TIMELINE) && (Dt.segmentDuration = ht(nt.SegmentTimeline) / Dt.timescale)), nt.hasOwnProperty(D.A.MEDIA) && (Dt.media = nt.media), nt.hasOwnProperty(D.A.START_NUMBER) && (Dt.startNumber = parseInt(nt.startNumber)), nt.hasOwnProperty(D.A.INDEX_RANGE) && (Dt.indexRange = nt.indexRange), nt.hasOwnProperty(D.A.PRESENTATION_TIME_OFFSET) && (Dt.presentationTimeOffset = nt.presentationTimeOffset / Dt.timescale), nt.hasOwnProperty(D.A.AVAILABILITY_TIME_OFFSET) ? Dt.availabilityTimeOffset = ua(nt.availabilityTimeOffset) : ft && ft.availabilityTimeOffset !== void 0 && (Dt.availabilityTimeOffset = ua(ft.availabilityTimeOffset)), nt.hasOwnProperty(D.A.AVAILABILITY_TIME_COMPLETE) ? Dt.availabilityTimeComplete = nt.availabilityTimeComplete !== "false" : ft && ft.availabilityTimeComplete !== void 0 && (Dt.availabilityTimeComplete = ft.availabilityTimeComplete), nt.hasOwnProperty(D.A.END_NUMBER) && (Dt.endNumber = nt[D.A.END_NUMBER]);
                }
                Dt.mseTimeOffset = _t(Dt), Dt.path = [N.period.index, N.index, rt], isNaN(Dt.width) || isNaN(Dt.height) || isNaN(Dt.frameRate) || (Dt.pixelsPerSecond = Math.max(1, Dt.width * Dt.height * Dt.frameRate), isNaN(Dt.bandwidth) || (Dt.bitsPerPixel = Dt.bandwidth / Dt.pixelsPerSecond)), It.push(Dt);
              }
            }
            return It;
          }, getRolesForAdaptation: function(N) {
            return N && N.hasOwnProperty(D.A.ROLE) && N[D.A.ROLE].length ? N[D.A.ROLE].map((ct) => {
              ct.schemeIdUri === X.A.DASH_ROLE_SCHEME_ID && ct.value === "Main" && (ct.value = D.A.MAIN);
              const It = new Ka();
              return It.init(ct), It;
            }) : [];
          }, getSegmentAlignment: function(N) {
            return !(!N || !N.hasOwnProperty(D.A.SEGMENT_ALIGNMENT)) && N[D.A.SEGMENT_ALIGNMENT] === "true";
          }, getSelectionPriority: function(N) {
            try {
              const ct = N && N.selectionPriority !== void 0 ? parseInt(N.selectionPriority) : 1;
              return isNaN(ct) ? 1 : ct;
            } catch (ct) {
              return 1;
            }
          }, getServiceDescriptions: function(N) {
            const ct = [];
            if (N && N.hasOwnProperty(D.A.SERVICE_DESCRIPTION)) for (const It of N.ServiceDescription) {
              let dt = null, nt = null, ft = null, rt = null, Et = null, kt = null, Dt = null, Ut = null;
              for (const Wt in It) if (It.hasOwnProperty(Wt)) if (Wt === D.A.ID) dt = It[Wt];
              else if (Wt === D.A.SERVICE_DESCRIPTION_SCOPE) nt = It[Wt].schemeIdUri;
              else if (Wt === D.A.SERVICE_DESCRIPTION_LATENCY) ft = { target: parseInt(It[Wt].target), max: parseInt(It[Wt].max), min: parseInt(It[Wt].min), referenceId: parseInt(It[Wt].referenceId) };
              else if (Wt === D.A.SERVICE_DESCRIPTION_PLAYBACK_RATE) rt = { max: parseFloat(It[Wt].max), min: parseFloat(It[Wt].min) };
              else if (Wt === D.A.SERVICE_DESCRIPTION_OPERATING_QUALITY) Et = { mediaType: It[Wt].mediaType, max: parseInt(It[Wt].max), min: parseInt(It[Wt].min), target: parseInt(It[Wt].target), type: It[Wt].type, maxQualityDifference: parseInt(It[Wt].maxQualityDifference) };
              else if (Wt === D.A.SERVICE_DESCRIPTION_OPERATING_BANDWIDTH) kt = { mediaType: It[Wt].mediaType, max: parseInt(It[Wt].max), min: parseInt(It[Wt].min), target: parseInt(It[Wt].target) };
              else if (Wt === D.A.CONTENT_STEERING) {
                let ie = It[Wt];
                ie = Array.isArray(ie) ? ie.at(ie.length - 1) : ie, Dt = xt(ie);
              } else Wt === D.A.CLIENT_DATA_REPORTING && (Ut = Pt(It[Wt]));
              ct.push({ id: dt, schemeIdUri: nt, latency: ft, playbackRate: rt, operatingQuality: Et, operatingBandwidth: kt, contentSteering: Dt, clientDataReporting: Ut });
            }
            return ct;
          }, getSubSegmentAlignment: function(N) {
            return !(!N || !N.hasOwnProperty(D.A.SUB_SEGMENT_ALIGNMENT)) && N[D.A.SUB_SEGMENT_ALIGNMENT] === "true";
          }, getSuggestedPresentationDelay: function(N) {
            return N && N.hasOwnProperty(D.A.SUGGESTED_PRESENTATION_DELAY) ? N.suggestedPresentationDelay : null;
          }, getSupplementalPropertiesForAdaptationSet: function(N) {
            return $(D.A.SUPPLEMENTAL_PROPERTY, N);
          }, getSupplementalPropertiesForRepresentation: J, getUTCTimingSources: function(N) {
            const ct = mt(N), It = !!N && N.hasOwnProperty(D.A.AVAILABILITY_START_TIME), dt = N ? N.UTCTiming : null, nt = [];
            return (ct || It) && dt && dt.forEach(function(ft) {
              const rt = new xn.A();
              ft.hasOwnProperty(X.A.SCHEME_ID_URI) && (rt.schemeIdUri = ft.schemeIdUri, ft.hasOwnProperty(D.A.VALUE) && (rt.value = ft.value.toString(), nt.push(rt)));
            }), nt;
          }, getViewpointForAdaptation: function(N) {
            return N && N.hasOwnProperty(D.A.VIEWPOINT) && N[D.A.VIEWPOINT].length ? N[D.A.VIEWPOINT].map((ct) => {
              const It = new Ka();
              return It.init(ct), It;
            }) : [];
          }, hasProfile: function(N, ct) {
            let It = !1;
            return N && N.profiles && N.profiles.length > 0 && (It = N.profiles.indexOf(ct) !== -1), It;
          }, isPeriodEncrypted: st, setConfig: function(N) {
            N && (N.errHandler && (C = N.errHandler), N.BASE64 && (_ = N.BASE64));
          } }, f = (0, jt.A)(v).getInstance().getLogger(A), A;
        }
        Ui.__dashjs_factory_name = "DashManifestModel";
        var si = Bt.A.getSingletonFactory(Ui);
        const ai = { MANIFEST: "m", AUDIO: "a", VIDEO: "v", MUXED: "av", INIT: "i", CAPTION: "c", TIMED_TEXT: "tt", KEY: "k", OTHER: "o" }, Va = ai, Ei = "v", Rr = "l", eo = "d", Do = "s";
        class Ki {
          constructor(f, C) {
            Array.isArray(f) && (f = f.map((_) => _ instanceof Ki ? _ : new Ki(_))), this.value = f, this.params = C;
          }
        }
        const ar = "Dict";
        function ms(A, f, C, _) {
          return new Error(`failed to ${A} "${v = f, Array.isArray(v) ? JSON.stringify(v) : v instanceof Map ? "Map{}" : v instanceof Set ? "Set{}" : typeof v == "object" ? JSON.stringify(v) : String(v)}" as ${C}`, { cause: _ });
          var v;
        }
        function Ti(A, f, C) {
          return ms("serialize", A, f, C);
        }
        class Bo {
          constructor(f) {
            this.description = f;
          }
        }
        const no = "Bare Item", fs = "Boolean", ao = "Byte Sequence", hs = "Integer";
        function Cr(A) {
          return A < -999999999999999 || 999999999999999 < A;
        }
        function ma(A) {
          if (Cr(A)) throw Ti(A, hs);
          return A.toString();
        }
        function ir(A, f) {
          if (A < 0) return -ir(-A, f);
          const C = Math.pow(10, f);
          if (Math.abs(A * C % 1 - 0.5) < Number.EPSILON) {
            const _ = Math.floor(A * C);
            return (_ % 2 == 0 ? _ : _ + 1) / C;
          }
          return Math.round(A * C) / C;
        }
        const Dr = "Decimal";
        function Br(A) {
          const f = ir(A, 3);
          if (Math.floor(Math.abs(f)).toString().length > 12) throw Ti(A, Dr);
          const C = f.toString();
          return C.includes(".") ? C : `${C}.0`;
        }
        const da = "String", gi = /[\x00-\x1f\x7f]+/;
        function xo(A) {
          return A.description || A.toString().slice(7, -1);
        }
        const ki = "Token";
        function ps(A) {
          const f = xo(A);
          if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(f) === !1) throw Ti(f, ki);
          return f;
        }
        function Is(A) {
          switch (typeof A) {
            case "number":
              if (!Number.isFinite(A)) throw Ti(A, no);
              return Number.isInteger(A) ? ma(A) : Br(A);
            case "string":
              return function(f) {
                if (gi.test(f)) throw Ti(f, da);
                return `"${f.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
              }(A);
            case "symbol":
              return ps(A);
            case "boolean":
              return function(f) {
                if (typeof f != "boolean") throw Ti(f, fs);
                return f ? "?1" : "?0";
              }(A);
            case "object":
              if (A instanceof Date) return function(f) {
                return `@${ma(f.getTime() / 1e3)}`;
              }(A);
              if (A instanceof Uint8Array) return function(f) {
                if (ArrayBuffer.isView(f) === !1) throw Ti(f, ao);
                return `:${C = f, btoa(String.fromCharCode(...C))}:`;
                var C;
              }(A);
              if (A instanceof Bo) return ps(A);
            default:
              throw Ti(A, no);
          }
        }
        const io = "Key";
        function ro(A) {
          if (/^[a-z*][a-z0-9\-_.*]*$/.test(A) === !1) throw Ti(A, io);
          return A;
        }
        function No(A) {
          return A == null ? "" : Object.entries(A).map((f) => {
            let [C, _] = f;
            return _ === !0 ? `;${ro(C)}` : `;${ro(C)}=${Is(_)}`;
          }).join("");
        }
        function rd(A) {
          return A instanceof Ki ? `${Is(A.value)}${No(A.params)}` : Is(A);
        }
        const Cs = (A) => Math.round(A), ys = (A) => 100 * Cs(A / 100), Gl = { br: Cs, d: Cs, bl: ys, dl: ys, mtp: ys, nor: (A, f) => (f != null && f.baseUrl && (A = function(C, _) {
          const v = new URL(C), M = new URL(_);
          if (v.origin !== M.origin) return C;
          const Y = v.pathname.split("/").slice(1), H = M.pathname.split("/").slice(1, -1);
          for (; Y[0] === H[0]; ) Y.shift(), H.shift();
          for (; H.length; ) H.shift(), Y.unshift("..");
          return Y.join("/");
        }(A, f.baseUrl)), encodeURIComponent(A)), rtp: ys, tb: Cs };
        function zl(A) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return A ? function(C, _) {
            return function(v) {
              let M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { whitespace: !0 };
              if (typeof v != "object") throw Ti(v, ar);
              const Y = v instanceof Map ? v.entries() : Object.entries(v), H = M != null && M.whitespace ? " " : "";
              return Array.from(Y).map((L) => {
                let [W, K] = L;
                K instanceof Ki == 0 && (K = new Ki(K));
                let R = ro(W);
                var G;
                return K.value === !0 ? R += No(K.params) : (R += "=", Array.isArray(K.value) ? R += `(${(G = K).value.map(rd).join(" ")})${No(G.params)}` : R += rd(K)), R;
              }).join(`,${H}`);
            }(C, _);
          }(function(C, _) {
            const v = {};
            if (C == null || typeof C != "object") return v;
            const M = Object.keys(C).sort(), Y = Object.assign({}, Gl, _ == null ? void 0 : _.formatters), H = _ == null ? void 0 : _.filter;
            return M.forEach((L) => {
              if (H != null && H(L)) return;
              let W = C[L];
              const K = Y[L];
              K && (W = K(W, _)), L === "v" && W === 1 || L == "pr" && W === 1 || function(R) {
                return typeof R == "number" ? Number.isFinite(R) : R != null && R !== "" && R !== !1;
              }(W) && (/* @__PURE__ */ function(R) {
                return R === "ot" || R === "sf" || R === "st";
              }(L) && typeof W == "string" && (W = new Bo(W)), v[L] = W);
            }), v;
          }(A, f), Object.assign({ whitespace: !1 }, f)) : "";
        }
        const Ic = "CMCD-Object", Yl = "CMCD-Request", Li = "CMCD-Session", jr = "CMCD-Status", sd = { [Ic]: ["br", "d", "ot", "tb"], [Yl]: ["bl", "dl", "mtp", "nor", "nrr", "su"], [Li]: ["cid", "pr", "sf", "sid", "st", "v"], [jr]: ["bs", "rtp"] }, Hl = "segment";
        function Pl() {
          let A, f, C, _, v, M, Y, H, L, W, K, R, G, F, et, it, st = this.context, ot = (0, Mt.A)(st).getInstance(), ut = (0, tt.A)(st).getInstance(), mt = (0, jt.A)(st).getInstance();
          function wt() {
            _ = { pr: 1, nor: null, st: null, sf: null, sid: `${jn.A.generateUuid()}`, cid: null }, G = {}, R = {}, F = {}, K = void 0, et = void 0, it = !1, J();
          }
          function $() {
            J();
          }
          function P() {
            et || (et = Date.now());
          }
          function j() {
            et && !_.msd && (_.msd = Date.now() - et);
          }
          function J() {
            if (!Y) return;
            const ft = Y.getStreamController();
            if (!ft || typeof ft.getActiveStream != "function") return;
            const rt = ft.getActiveStream();
            rt && (W = rt.getStreamProcessors());
          }
          function ht(ft) {
            try {
              const rt = Ct(), Et = rt.version ? rt.keys : ut.get().streaming.cmcd.enabledKeys;
              return Object.keys(ft).filter((kt) => Et.includes(kt)).reduce((kt, Dt) => (kt[Dt] = ft[Dt], kt), {});
            } catch (rt) {
              return ft;
            }
          }
          function _t() {
            const ft = Ct();
            return function(rt) {
              if (Object.keys(rt).length) {
                if (parseInt(rt.version) !== 1) return C.error("version parameter must be defined in 1."), !1;
                if (!rt.keys) return C.error("keys parameter must be defined."), !1;
              }
              const Et = rt.version, kt = ut.get().streaming.cmcd && ut.get().streaming.cmcd.enabled;
              return Et || kt;
            }(ft) && function(rt) {
              var Ut;
              let Et = ut.get().streaming.cmcd.includeInRequests;
              rt.version && (Et = (Ut = rt.includeInRequests) != null ? Ut : [Hl]);
              const kt = X.A.CMCD_AVAILABLE_REQUESTS, Dt = Et.filter((Wt) => !kt.includes(Wt));
              return Dt.length === Et.length ? (C.error("None of the request types are supported."), !1) : (Dt.map((Wt) => {
                C.warn(`request type ${Wt} is not supported.`);
              }), !0);
            }(ft) && function(rt) {
              const Et = X.A.CMCD_AVAILABLE_KEYS, kt = X.A.CMCD_V2_AVAILABLE_KEYS, Dt = rt.version ? rt.keys : ut.get().streaming.cmcd.enabledKeys, Ut = ut.get().streaming.cmcd.version, Wt = Dt.filter((ie) => !(Et.includes(ie) || Ut === 2 && kt.includes(ie)));
              return Wt.length === Dt.length && Dt.length > 0 ? (C.error(`None of the keys are implemented for CMCD version ${Ut}.`), !1) : (Wt.map((ie) => {
                C.warn(`key parameter ${ie} is not implemented for CMCD version ${Ut}.`);
              }), !0);
            }(ft);
          }
          function Ct() {
            let ft = {};
            if (H) {
              const rt = H.getServiceDescriptionSettings();
              ut.get().streaming.cmcd.applyParametersFromMpd && rt.clientDataReporting && rt.clientDataReporting.cmcdParameters && (ft = rt.clientDataReporting.cmcdParameters);
            }
            return ft;
          }
          function bt(ft) {
            try {
              let Et = null;
              if (ft.type, (rt = ft.mediaType) !== X.A.VIDEO && rt !== X.A.AUDIO && rt !== X.A.MESH || K && K != X.A.AUDIO || (K = rt), function(kt) {
                const Dt = Ct();
                let Ut = ut.get().streaming.cmcd.includeInRequests;
                Dt.version && (Ut = Dt.includeInRequests ? Dt.includeInRequests : [Hl]);
                const Wt = { [Ht.G.INIT_SEGMENT_TYPE]: "segment", [Ht.G.MEDIA_SEGMENT_TYPE]: "segment", [Ht.G.XLINK_EXPANSION_TYPE]: "xlink", [Ht.G.MPD_TYPE]: "mpd", [Ht.G.CONTENT_STEERING_TYPE]: "steering", [Ht.G.OTHER_TYPE]: "other" };
                return Ut.some((ie) => Wt[kt] === ie);
              }(ft.type)) {
                if (ft.type === Ht.G.MPD_TYPE) return function() {
                  const kt = Pt();
                  return kt.ot = Va.MANIFEST, kt;
                }();
                if (ft.type === Ht.G.MEDIA_SEGMENT_TYPE) return xt(ft.mediaType), Rt(ft, ft.mediaType);
                if (ft.type === Ht.G.INIT_SEGMENT_TYPE) return function() {
                  const kt = Pt();
                  return kt.ot = Va.INIT, kt.su = !0, kt;
                }();
                if (ft.type === Ht.G.OTHER_TYPE || ft.type === Ht.G.XLINK_EXPANSION_TYPE) return function() {
                  const kt = Pt();
                  return kt.ot = Va.OTHER, kt;
                }();
                if (ft.type === Ht.G.LICENSE) return function() {
                  const kt = Pt();
                  return kt.ot = Va.KEY, kt;
                }();
                if (ft.type === Ht.G.CONTENT_STEERING_TYPE) return function(kt) {
                  const Dt = K ? Rt(kt, K) : Pt();
                  return Dt.ot = Va.OTHER, Dt;
                }(ft);
              }
              return Et;
            } catch (Et) {
              return null;
            }
            var rt;
          }
          function Rt(ft, rt) {
            var ke;
            xt(rt);
            const Et = Pt(), kt = function(rn) {
              try {
                return parseInt(rn.bandwidth / 1e3);
              } catch (Cn) {
                return null;
              }
            }(ft), Dt = function(rn) {
              try {
                return isNaN(rn.duration) ? NaN : Math.round(1e3 * rn.duration);
              } catch (Cn) {
                return null;
              }
            }(ft), Ut = function(rn) {
              try {
                return 100 * parseInt(L.getSafeAverageThroughput(rn) / 100);
              } catch (Cn) {
                return null;
              }
            }(rt), Wt = function(rn) {
              try {
                const Cn = _.pr, Nn = M.getCurrentBufferLevel(rn);
                return isNaN(Cn) || isNaN(Nn) ? null : 100 * parseInt(Nn / Cn * 10);
              } catch (Cn) {
                return null;
              }
            }(rt), ie = N(rt), de = function(rn) {
              try {
                const Cn = v.getPossibleVoRepresentationsFilteredBySettings(rn).map((Nn) => Nn.bitrateInKbit);
                return Math.max(...Cn);
              } catch (Cn) {
                return null;
              }
            }((ke = ft.representation) == null ? void 0 : ke.mediaInfo), Be = _.pr, Oe = function(rn) {
              if (W && W.length !== 0) {
                for (let Cn of W) if (Cn.getType() === rn) return Cn.probeNextRequest();
              }
            }(rt);
            let nn;
            rt === X.A.VIDEO && (nn = Va.VIDEO), rt === X.A.AUDIO && (nn = Va.AUDIO), rt === X.A.MESH && (nn = Va.OTHER), rt === X.A.TEXT && (nn = ft.representation.mediaInfo.mimeType === "application/mp4" ? Va.TIMED_TEXT : Va.CAPTION);
            let _n = ut.get().streaming.cmcd.rtp;
            return _n || (_n = function(rn) {
              try {
                let Cn = Y.getPlaybackRate();
                Cn || (Cn = 1);
                let { bandwidth: Nn, mediaType: Gn, representation: Xt, duration: ce } = rn;
                if (!Xt.mediaInfo) return NaN;
                let oe = N(Gn);
                oe === 0 && (oe = 500);
                let pe = Nn * ce / 1e3 / (oe / Cn / 1e3), en = ut.get().streaming.cmcd.rtpSafetyFactor && !isNaN(ut.get().streaming.cmcd.rtpSafetyFactor) ? ut.get().streaming.cmcd.rtpSafetyFactor : 5;
                return 100 * (parseInt(pe * en / 100) + 1);
              } catch (Cn) {
                return NaN;
              }
            }(ft)), isNaN(_n) || (Et.rtp = _n), Oe && (ft.url !== Oe.url ? Et.nor = encodeURIComponent(jn.A.getRelativeUrl(ft.url, Oe.url)) : Oe.range && (Et.nrr = Oe.range)), kt && (Et.br = kt), nn && (Et.ot = nn), isNaN(Dt) || (Et.d = Dt), isNaN(Ut) || (Et.mtp = Ut), isNaN(Wt) || (Et.dl = Wt), isNaN(ie) || (Et.bl = ie), isNaN(de) || (Et.tb = de), isNaN(Be) || Be === 1 || (Et.pr = Be), G[rt] && (Et.bs = !0, G[rt] = !1), !R[rt] && F[rt] || (Et.su = !0, R[rt] = !1, F[rt] = !0), Et;
          }
          function xt(ft) {
            F.hasOwnProperty(ft) || (F[ft] = !1), R.hasOwnProperty(ft) || (R[ft] = !1), G.hasOwnProperty(ft) || (G[ft] = !1);
          }
          function Pt() {
            var kt;
            const ft = Ct(), rt = {};
            let Et = ut.get().streaming.cmcd.cid ? ut.get().streaming.cmcd.cid : _.cid;
            if (Et = ft.contentID ? ft.contentID : Et, rt.v = (kt = ut.get().streaming.cmcd.version) != null ? kt : 1, rt.sid = ut.get().streaming.cmcd.sid ? ut.get().streaming.cmcd.sid : _.sid, rt.sid = ft.sessionID ? ft.sessionID : rt.sid, rt.sid = `${rt.sid}`, Et && (rt.cid = `${Et}`), isNaN(_.pr) || _.pr === 1 || _.pr === null || (rt.pr = _.pr), _.st && (rt.st = _.st), _.sf && (rt.sf = _.sf), rt.v === 2) {
              let Dt = 1e3 * Y.getCurrentLiveLatency();
              isNaN(Dt) || (rt.ltc = Dt);
              const Ut = _.msd;
              it || isNaN(Ut) || (rt.msd = Ut, it = !0);
            }
            return rt;
          }
          function N(ft) {
            try {
              const rt = M.getCurrentBufferLevel(ft);
              return isNaN(rt) ? null : 100 * parseInt(10 * rt);
            } catch (rt) {
              return null;
            }
          }
          function ct(ft) {
            try {
              _.pr = ft.playbackRate;
            } catch (rt) {
            }
          }
          function It(ft) {
            try {
              const rt = A.getIsDynamic(ft.data) ? Rr : Ei, Et = ft.protocol && ft.protocol === "MSS" ? Do : eo;
              _.st = `${rt}`, _.sf = `${Et}`;
            } catch (rt) {
            }
          }
          function dt(ft) {
            try {
              ft.state && ft.mediaType && ft.state === At.A.BUFFER_EMPTY && (G[ft.mediaType] || (G[ft.mediaType] = !0), R[ft.mediaType] || (R[ft.mediaType] = !0));
            } catch (rt) {
            }
          }
          function nt() {
            for (let ft in G) G.hasOwnProperty(ft) && (G[ft] = !0);
            for (let ft in R) R.hasOwnProperty(ft) && (R[ft] = !0);
          }
          return f = { getCmcdData: bt, getQueryParameter: function(ft) {
            try {
              if (_t()) {
                const rt = bt(ft), Et = zl(ht(rt));
                return ot.trigger(ni.A.CMCD_DATA_GENERATED, { url: ft.url, mediaType: ft.mediaType, cmcdData: rt, cmcdString: Et }), { key: "CMCD", value: Et };
              }
              return null;
            } catch (rt) {
              return null;
            }
          }, getHeaderParameters: function(ft) {
            try {
              if (_t()) {
                const rt = bt(ft), Et = function(kt) {
                  let Dt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  const Ut = {};
                  if (!kt) return Ut;
                  const Wt = Object.entries(kt), ie = Object.entries(sd).concat(Object.entries((Dt == null ? void 0 : Dt.customHeaderMap) || {})), de = Wt.reduce((Be, Oe) => {
                    var nn, _n;
                    const [ke, rn] = Oe, Cn = ((nn = ie.find((Nn) => Nn[1].includes(ke))) === null || nn === void 0 ? void 0 : nn[0]) || Yl;
                    return (_n = Be[Cn]) !== null && _n !== void 0 || (Be[Cn] = {}), Be[Cn][ke] = rn, Be;
                  }, {});
                  return Object.entries(de).reduce((Be, Oe) => {
                    let [nn, _n] = Oe;
                    return Be[nn] = zl(_n, Dt), Be;
                  }, Ut);
                }(ht(rt), ut.get().streaming.cmcd.version === 1 ? {} : { customHeaderMap: { [Yl]: ["ltc"], [Li]: ["msd"] } });
                return ot.trigger(ni.A.CMCD_DATA_GENERATED, { url: ft.url, mediaType: ft.mediaType, cmcdData: rt, headers: Et }), Et;
              }
              return null;
            } catch (rt) {
              return null;
            }
          }, getCmcdParametersFromManifest: Ct, setConfig: function(ft) {
            ft && (ft.abrController && (v = ft.abrController), ft.dashMetrics && (M = ft.dashMetrics), ft.throughputController && (L = ft.throughputController), ft.playbackController && (Y = ft.playbackController), ft.serviceDescriptionController && (H = ft.serviceDescriptionController));
          }, reset: function() {
            ot.off(At.A.PLAYBACK_RATE_CHANGED, ct, this), ot.off(At.A.MANIFEST_LOADED, It, this), ot.off(At.A.BUFFER_LEVEL_STATE_CHANGED, dt, f), ot.off(At.A.PLAYBACK_SEEKED, nt, f), ot.off(At.A.PLAYBACK_STARTED, P, f), ot.off(At.A.PLAYBACK_PLAYING, j, f), wt();
          }, initialize: function(ft) {
            ot.on(At.A.PLAYBACK_RATE_CHANGED, ct, f), ot.on(At.A.MANIFEST_LOADED, It, f), ot.on(At.A.BUFFER_LEVEL_STATE_CHANGED, dt, f), ot.on(At.A.PLAYBACK_SEEKED, nt, f), ot.on(At.A.PERIOD_SWITCH_COMPLETED, $, f), ft ? ot.on(At.A.MANIFEST_LOADING_STARTED, P, f) : ot.on(At.A.PLAYBACK_STARTED, P, f), ot.on(At.A.PLAYBACK_PLAYING, j, f);
          }, isCmcdEnabled: _t }, A = si(st).getInstance(), C = mt.getLogger(f), wt(), f;
        }
        Pl.__dashjs_factory_name = "CmcdModel";
        var od = Bt.A.getSingletonFactory(Pl);
        const so = "CMSD-Dynamic", Fl = "CMSD-Static", Go = ai;
        function pa(A, f, C) {
          return ms("parse", A, f, C);
        }
        const oo = "List";
        function qa(A, f) {
          return { value: A, src: f };
        }
        const zo = "Inner List", Yo = "Date", As = `${hs} or ${Dr}`;
        function Ho(A) {
          let f, C = 1, _ = "";
          const v = pa(A, As);
          if (A[0] === "-" && (C = -1, A = A.substring(1)), A.length <= 0) throw v;
          const M = /^(\d+)?/g, Y = M.exec(A);
          if (Y[0].length === 0) throw v;
          if (_ += Y[1], (A = A.substring(M.lastIndex))[0] === ".") {
            if (_.length > 12) throw v;
            const H = /^(\.\d+)?/g, L = H.exec(A);
            if (A = A.substring(H.lastIndex), L[0].length === 0 || L[1].length > 4 || (_ += L[1], _.length > 16)) throw v;
            f = parseFloat(_) * C;
          } else {
            if (_.length > 15) throw v;
            if (f = parseInt(_) * C, Cr(f)) throw pa(_, As);
          }
          return qa(f, A);
        }
        function Ol(A, f) {
          const C = A[0];
          if (C === '"') return function(_) {
            let v = "", M = 0;
            if (_[M] !== '"') throw pa(_, da);
            for (M++; _.length > M; ) {
              if (_[M] === "\\") {
                if (_.length <= M + 1 || (M++, _[M] !== '"' && _[M] !== "\\")) throw pa(_, da);
                v += _[M];
              } else {
                if (_[M] === '"') return qa(v, _.substring(++M));
                if (gi.test(_[M])) throw pa(_, da);
                v += _[M];
              }
              M++;
            }
            throw pa(_, da);
          }(A);
          if (/^[-0-9]/.test(C)) return Ho(A);
          if (C === "?") return function(_) {
            let v = 0;
            if (_[v] !== "?") throw pa(_, fs);
            if (v++, _[v] === "1") return qa(!0, _.substring(++v));
            if (_[v] === "0") return qa(!1, _.substring(++v));
            throw pa(_, fs);
          }(A);
          if (C === ":") return function(_) {
            if (_[0] !== ":" || (_ = _.substring(1)).includes(":") === !1) throw pa(_, ao);
            const v = /(^.*?)(:)/g, M = v.exec(_)[1];
            return _ = _.substring(v.lastIndex), qa(new Uint8Array([...atob(M)].map((Y) => Y.charCodeAt(0))), _);
          }(A);
          if (/^[a-zA-Z*]/.test(C)) return function(_, v) {
            if (/^[a-zA-Z*]$/.test(_[0]) === !1) throw pa(_, ki);
            const M = /^([!#$%&'*+\-.^_`|~\w:/]+)/g, Y = M.exec(_)[1];
            return _ = _.substring(M.lastIndex), qa(Symbol.for(Y), _);
          }(A);
          if (C === "@") return function(_) {
            let v = 0;
            if (_[v] !== "@") throw pa(_, Yo);
            v++;
            const M = Ho(_.substring(v));
            if (Number.isInteger(M.value) === !1) throw pa(_, Yo);
            return qa(new Date(1e3 * M.value), M.src);
          }(A);
          throw pa(A, no);
        }
        function Zr(A) {
          let f = 0;
          if (/^[a-z*]$/.test(A[f]) === !1) throw pa(A, io);
          let C = "";
          for (; A.length > f; ) {
            if (/^[a-z0-9_\-.*]$/.test(A[f]) === !1) return qa(C, A.substring(f));
            C += A[f], f++;
          }
          return qa(C, A.substring(f));
        }
        function Po(A, f) {
          let C;
          for (; A.length > 0 && A[0] === ";"; ) {
            const _ = Zr(A = A.substring(1).trim()), v = _.value;
            let M = !0;
            if ((A = _.src)[0] === "=") {
              const Y = Ol(A = A.substring(1));
              M = Y.value, A = Y.src;
            }
            C == null && (C = {}), C[v] = M;
          }
          return qa(C, A);
        }
        function Ul(A, f) {
          const C = Ol(A), _ = Po(A = C.src);
          return A = _.src, qa(new Ki(C.value, _.value), A);
        }
        function Fo(A, f) {
          return A[0] === "(" ? function(C, _) {
            if (C[0] !== "(") throw pa(C, zo);
            C = C.substring(1);
            const v = [];
            for (; C.length > 0; ) {
              if ((C = C.trim())[0] === ")") {
                const Y = Po(C = C.substring(1));
                return qa(new Ki(v, Y.value), Y.src);
              }
              const M = Ul(C);
              if (v.push(M.value), (C = M.src)[0] !== " " && C[0] !== ")") throw pa(C, zo);
            }
            throw pa(C, zo);
          }(A) : Ul(A);
        }
        const Kl = Fl.toLowerCase(), Oo = so.toLowerCase(), ld = ["mb", "st", "sf", "v"], Vl = "stream", ud = { video: Go.VIDEO, audio: Go.AUDIO, text: Go.TIMED_TEXT, stream: Vl };
        function dd() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M;
          function Y() {
            v = {}, M = {};
          }
          function H(G) {
            G && Object.keys(G).forEach((F) => {
              ld.includes(F) || delete G[F];
            });
          }
          function L(G) {
            try {
              return (F = G) ? Object.entries(function(et, it) {
                try {
                  const { src: st, value: ot } = function(ut, mt) {
                    const wt = {};
                    for (; ut.length > 0; ) {
                      let $;
                      const P = Zr(ut), j = P.value;
                      if ((ut = P.src)[0] === "=") {
                        const J = Fo(ut.substring(1), mt);
                        $ = J.value, ut = J.src;
                      } else {
                        const J = Po(ut, mt);
                        $ = new Ki(!0, J.value), ut = J.src;
                      }
                      if (wt[j] = $, (ut = ut.trim()).length === 0) return qa(wt, ut);
                      if (ut[0] !== "," || (ut = ut.substring(1).trim()).length === 0 || ut[0] === ",") throw pa(ut, ar);
                    }
                    return qa(wt, ut);
                  }(et.trim(), it);
                  if (st !== "") throw pa(st, ar);
                  return ot;
                } catch (st) {
                  throw pa(et, ar, st);
                }
              }(F)).reduce((et, it) => {
                let [st, ot] = it;
                const { value: ut } = ot;
                return et[st] = typeof ut == "symbol" ? xo(ut) : ut, et;
              }, {}) : {};
            } catch (et) {
              _.error("Failed to parse CMSD-Static response header value:", et);
            }
            var F;
          }
          function W(G) {
            try {
              const et = (F = G) ? function(st, ot) {
                try {
                  const { src: ut, value: mt } = function(wt, $) {
                    const P = [];
                    for (; wt.length > 0; ) {
                      const j = Fo(wt, $);
                      if (P.push(j.value), (wt = j.src.trim()).length === 0) return qa(P, wt);
                      if (wt[0] !== "," || (wt = wt.substring(1).trim()).length === 0 || wt[0] === ",") throw pa(wt, oo);
                    }
                    return qa(P, wt);
                  }(st.trim(), ot);
                  if (ut !== "") throw pa(ut, oo);
                  return mt;
                } catch (ut) {
                  throw pa(st, oo, ut);
                }
              }(F) : [], it = et[et.length - 1];
              return (it == null ? void 0 : it.params) || {};
            } catch (et) {
              return _.error("Failed to parse CMSD-Dynamic response header value:", et), {};
            }
            var F;
          }
          function K(G) {
            return ud[G] || Go.OTHER;
          }
          function R(G, F, et) {
            const it = G === Fl ? v : M, st = it[F] || {}, ot = it[Vl] || {};
            return st[et] || ot[et];
          }
          return C = { setConfig: function() {
          }, initialize: function() {
          }, reset: function() {
            Y();
          }, parseResponseHeaders: function(G, F) {
            let et = null, it = null;
            for (const ot in G) {
              const ut = G[ot];
              switch (ot) {
                case Kl:
                  et = L(ut), f.trigger(at.A.CMSD_STATIC_HEADER, et);
                  break;
                case Oo:
                  it || (it = W(ut));
              }
            }
            let st = Vl;
            return et && et.ot ? st = et.ot : F && (st = K(F)), H(v[st]), H(M[st]), et && (v[st] = Object.assign(v[st] || {}, et)), it && (M[st] = Object.assign(M[st] || {}, it)), { static: et, dynamic: it };
          }, getMaxBitrate: function(G) {
            let F = K(G);
            return R(so, F, "mb") || -1;
          }, getEstimatedThroughput: function(G) {
            let F = K(G);
            return R(so, F, "etp") || null;
          }, getResponseDelay: function(G) {
            let F = K(G);
            return R(so, F, "rd") || null;
          }, getRoundTripTime: function(G) {
            let F = K(G);
            return R(so, F, "rtt") || null;
          } }, _ = (0, jt.A)(A).getInstance().getLogger(C), Y(), C;
        }
        dd.__dashjs_factory_name = "CmsdModel";
        var yr = Bt.A.getSingletonFactory(dd), Xl = w(1926);
        function gd() {
          let A, f;
          function C() {
            f = {};
          }
          return A = { reset: function() {
            C();
          }, processResponseHeaders: function(_) {
            if (!(_ && _.headers && _.request && _.request.url)) return;
            const v = _.headers[X.A.COMMON_ACCESS_TOKEN_HEADER];
            if (v) {
              const M = jn.A.getHostFromUrl(_.request.url);
              M && (f[M] = v);
            }
          }, getCommonAccessTokenForUrl: function(_) {
            if (!_) return null;
            const v = jn.A.getHostFromUrl(_);
            return v ? f[v] ? f[v] : null : void 0;
          } }, C(), A;
        }
        gd.__dashjs_factory_name = "CommonAccessTokenController";
        var Cc = Bt.A.getSingletonFactory(gd);
        function un() {
          let A, f;
          return A = { setConfig: function(C) {
            C && C.serviceDescriptionController && (f = C.serviceDescriptionController);
          }, isAdaptationsIncluded: function(C) {
            var v, M;
            const { adaptationSetsArray: _ } = (M = (v = f == null ? void 0 : f.getServiceDescriptionSettings()) == null ? void 0 : v.clientDataReporting) != null ? M : {};
            return !_ || (_ == null ? void 0 : _.length) === 0 || _.includes(C);
          }, isServiceLocationIncluded: function(C, _) {
            var M, Y;
            if (C === Ht.G.CONTENT_STEERING_TYPE) return !0;
            const { serviceLocationsArray: v } = (Y = (M = f == null ? void 0 : f.getServiceDescriptionSettings()) == null ? void 0 : M.clientDataReporting) != null ? Y : {};
            return !v || (v == null ? void 0 : v.length) === 0 || v.includes(_);
          } }, A;
        }
        un.__dashjs_factory_name = "ClientDataReportingController";
        var Wl = Bt.A.getSingletonFactory(un);
        function ia() {
          let A, f, C;
          const _ = this.context;
          function v(M, Y, H, L, W) {
            var R;
            const K = function(G, F) {
              let et = [];
              return et = F === D.A.PERIOD ? G[D.A.SUPPLEMENTAL_PROPERTY] || [] : [...G[D.A.ESSENTIAL_PROPERTY] || [], ...G[D.A.SUPPLEMENTAL_PROPERTY] || []], et.find((it) => it.schemeIdUri === X.A.URL_QUERY_INFO_SCHEME && it.UrlQueryInfo || it.schemeIdUri === X.A.EXT_URL_QUERY_INFO_SCHEME && it.ExtUrlQueryInfo);
            }(Y, W);
            (function(G, F, et, it) {
              et.initialQueryString = "";
              let st = "";
              const ot = (G == null ? void 0 : G.ExtUrlQueryInfo) || (G == null ? void 0 : G.UrlQueryInfo);
              st = ot && ot.queryString ? F && F.length > 0 ? F + "&" + ot.queryString : ot.queryString : F, (ot == null ? void 0 : ot.useMPDUrlQuery) === "true" && it && (st = st ? st + "&" + it : it), et.initialQueryString = st;
            })(K, L.initialQueryString, M, H), function(G, F, et) {
              var st, ot;
              if (!G) return void (F.finalQueryString = et);
              const it = ((st = G == null ? void 0 : G.ExtUrlQueryInfo) == null ? void 0 : st.queryTemplate) || ((ot = G == null ? void 0 : G.UrlQueryInfo) == null ? void 0 : ot.queryTemplate) || "";
              F.finalQueryString = it === D.A.QUERY_PART ? F == null ? void 0 : F.initialQueryString : "";
            }(K, M, L.finalQueryString), M.sameOriginOnly = (R = K == null ? void 0 : K.ExtUrlQueryInfo) == null ? void 0 : R.sameOriginOnly, M.queryParams = jn.A.parseQueryParams(M == null ? void 0 : M.finalQueryString), M.includeInRequests = function(G, F) {
              var et;
              return G ? (et = G.ExtUrlQueryInfo) != null && et.includeInRequests ? G.ExtUrlQueryInfo.includeInRequests.split(" ") : [D.A.SEGMENT_TYPE] : F;
            }(K, L.includeInRequests);
          }
          return f = (0, jt.A)(_).getInstance().getLogger(A), A = { getFinalQueryString: function(M) {
            try {
              if (!C) return null;
              if (M.type === Ht.G.MEDIA_SEGMENT_TYPE || M.type === Ht.G.INIT_SEGMENT_TYPE) {
                const Y = M.representation;
                if (!Y) return null;
                const H = Y.adaptation, L = H.period, W = C.period[L.index].adaptation[H.index].representation[Y.index], K = new URL(M.url), R = !W.sameOriginOnly || C.origin === K.origin;
                if (W.includeInRequests.includes(D.A.SEGMENT_TYPE) && R) return W.queryParams;
              } else if (M.type === Ht.G.MPD_TYPE) {
                if ([D.A.MPD_TYPE, D.A.MPD_PATCH_TYPE].some((Y) => C.includeInRequests.includes(Y))) return C.queryParams;
              } else if (M.type === Ht.G.CONTENT_STEERING_TYPE && C.includeInRequests.includes(D.A.STEERING_TYPE)) return C.queryParams;
            } catch (Y) {
              return f.error(Y), null;
            }
          }, createFinalQueryStrings: function(M) {
            C = { origin: new URL(M.url).origin, period: [] };
            const Y = M.url.split("?")[1];
            v(C, M, Y, { initialQueryString: "", includeInRequests: [] }, D.A.MPD), M.Period.forEach((H) => {
              const L = { adaptation: [] };
              v(L, H, Y, C, D.A.PERIOD), H.AdaptationSet.forEach((W) => {
                const K = { representation: [] };
                v(K, W, Y, L, D.A.ADAPTATION_SET), W.Representation.forEach((R) => {
                  const G = {};
                  v(G, R, Y, K, D.A.REPRESENTATION), K.representation.push(G);
                }), L.adaptation.push(K);
              }), C.period.push(L);
            });
          } }, A;
        }
        ia.__dashjs_factory_name = "ExtUrlQueryInfoController";
        var lo = Bt.A.getSingletonFactory(ia), Uo = class {
          constructor(A) {
            this.url = A.url, this.method = A.method, this.responseType = A.responseType !== void 0 ? A.responseType : null, this.headers = A.headers !== void 0 ? A.headers : {}, this.credentials = A.credentials !== void 0 ? A.credentials : null, this.mode = A.mode !== void 0 ? A.mode : null, this.timeout = A.timeout !== void 0 ? A.timeout : 0, this.cmcd = A.cmcd !== void 0 ? A.cmcd : null, this.customData = A.customData !== void 0 ? A.customData : null;
          }
        }, uo = class {
          constructor(A) {
            this.request = A.request, this.url = A.url !== void 0 ? A.url : null, this.redirected = A.redirected !== void 0 && A.redirected, this.status = A.status !== void 0 ? A.status : null, this.statusText = A.statusText !== void 0 ? A.statusText : "", this.type = A.type !== void 0 ? A.type : "", this.headers = A.headers !== void 0 ? A.headers : {}, this.data = A.data !== void 0 ? A.data : null, this.resourceTiming = A.resourceTiming !== void 0 ? A.resourceTiming : null;
          }
        };
        function rr(A) {
          A = A || {};
          const f = this.context, C = A.errHandler, _ = A.dashMetrics, v = A.mediaPlayerModel, M = A.boxParser, Y = A.errors, H = A.requestTimeout || 0, L = (0, Mt.A)(f).getInstance(), W = (0, tt.A)(f).getInstance();
          let K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j;
          function J(ht, _t) {
            const Ct = function() {
              Pt();
            }, bt = function(ke) {
              const rn = /* @__PURE__ */ new Date();
              rt && (rt = !1, (!ke.lengthComputable || ke.lengthComputable && ke.total !== ke.loaded) && (nt.firstByteDate = rn, ie.resourceTiming.responseStart = rn.getTime())), ke.lengthComputable && (nt.bytesLoaded = ie.length = ke.loaded, nt.bytesTotal = ie.resourceTiming.encodedBodySize = ke.total, ie.length = ke.total, ie.resourceTiming.encodedBodySize = ke.loaded), ke.noTrace || (ft.push({ s: kt, d: ke.time ? ke.time : rn.getTime() - kt.getTime(), b: [ke.loaded ? ke.loaded - Dt : 0], t: ke.throughput }), nt.traces = ft, kt = rn, Dt = ke.loaded), Ut && (clearTimeout(Ut), Ut = null), W.get().streaming.fragmentRequestProgressTimeout > 0 && (Ut = setTimeout(function() {
                j.warn("Abort request " + Wt.url + " due to progress timeout"), Be.abort(Wt), Ct();
              }, W.get().streaming.fragmentRequestProgressTimeout)), ht.progress && ke && ht.progress(ke);
            }, Rt = function() {
              Pt(!0);
            }, xt = function(ke) {
              let rn;
              if (ke.lengthComputable) {
                let Cn = ke.loaded / ke.total * 100;
                rn = "Request timeout: loaded: " + ke.loaded + ", out of: " + ke.total + " : " + Cn.toFixed(3) + "% Completed";
              } else rn = "Request timeout: non-computable download size";
              j.warn(rn);
            }, Pt = function() {
              let ke = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
              R.indexOf(Wt) !== -1 && R.splice(R.indexOf(Wt), 1), Ut && (clearTimeout(Ut), Ut = null), wt.processResponseHeaders(ie), N(), ct(), function(rn) {
                const Cn = mt.getResponseInterceptors();
                return Cn ? Cn.reduce((Nn, Gn) => Nn.then((Xt) => Gn(Xt)), Promise.resolve(rn)) : Promise.resolve(rn);
              }(ie).then((rn) => {
                if (ie = rn, function(Cn, Nn, Gn) {
                  const Xt = Cn.customData.request, ce = W.get().streaming.cmsd && W.get().streaming.cmsd.enabled ? st.parseResponseHeaders(Nn.headers, Xt.mediaType) : null;
                  _.addHttpRequest(Xt, Nn.url, Nn.status, Nn.headers, Gn, ce);
                }(Wt, ie, ft), ke) ht.abort && ht.abort(nt);
                else if (nt.type === Ht.G.MPD_TYPE && (_.addManifestUpdate(nt), L.trigger(at.A.MANIFEST_LOADING_FINISHED, { requestObject: nt })), ie.status >= 200 && ie.status <= 299 && ie.data) ht.success && ht.success(ie.data, ie.statusText, ie.url), ht.complete && ht.complete(nt, ie.statusText);
                else {
                  try {
                    ie.status === 404 && W.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && nt.type === Ht.G.MEDIA_SEGMENT_TYPE && v.getRetryAttemptsForType(Ht.G.MEDIA_SEGMENT_TYPE) === _t && L.trigger(at.A.ATTEMPT_BACKGROUND_SYNC);
                  } catch (Cn) {
                  }
                  dt();
                }
              });
            }, N = function() {
              nt.startDate = Et, nt.endDate = /* @__PURE__ */ new Date(), nt.firstByteDate = nt.firstByteDate || Et;
            }, ct = function() {
              ie.resourceTiming.responseEnd = Date.now(), function(ke, rn) {
                if (!W.get().streaming.abr.throughput.useResourceTimingApi || typeof performance == "undefined" || ke.range) return;
                const Cn = performance.getEntriesByType("resource");
                if (Cn === void 0 || Cn.length <= 0) return;
                let Nn = 0, Gn = null;
                for (; Nn < Cn.length; ) {
                  if (Cn[Nn].name === ke.url) {
                    Gn = Cn[Nn];
                    break;
                  }
                  Nn += 1;
                }
                (function(Xt) {
                  return Xt && !isNaN(Xt.responseStart) && Xt.responseStart > 0 && !isNaN(Xt.responseEnd) && Xt.responseEnd > 0 && !isNaN(Xt.transferSize) && Xt.transferSize > 0;
                })(Gn) && (ke.customData.request.resourceTimingValues = Gn, rn.resourceTiming.startTime = Gn.startTime, rn.resourceTiming.encodedBodySize = Gn.encodedBodySize, rn.resourceTiming.responseStart = Gn.startTime, rn.resourceTiming.responseEnd = Gn.responseEnd, rn.resourceTiming.duration = Gn.duration);
              }(Wt, ie);
            }, It = function(ke, rn, Cn) {
              return new Promise((Nn) => {
                (function(Gn) {
                  const Xt = mt.getRequestInterceptors();
                  return Xt ? Xt.reduce((ce, oe) => ce.then((pe) => oe(pe)), Promise.resolve(Gn)) : Promise.resolve(Gn);
                })(rn).then((Gn) => {
                  (rn = Gn).customData.onloadend = Ct, rn.customData.onprogress = bt, rn.customData.onabort = Rt, rn.customData.ontimeout = xt, Cn.resourceTiming.startTime = Date.now(), ke.load(rn, Cn), Nn();
                });
              });
            }, dt = function() {
              if (_t > 0) {
                _t--, ht && ht.request && (ht.request.retryAttempts += 1);
                let ke = { config: ht };
                F.push(ke), ke.timeout = setTimeout(function() {
                  F.indexOf(ke) !== -1 && (F.splice(F.indexOf(ke), 1), J(ht, _t));
                }, v.getRetryIntervalsForType(nt.type));
              } else {
                if (nt.type === Ht.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE) return;
                C.error(new Nt.A(et[nt.type], nt.url + " is not available", { request: nt, response: ie })), ht.error && ht.error(nt, "error", ie.statusText, ie), ht.complete && ht.complete(nt, ie.statusText);
              }
            }, nt = ht.request, ft = [];
            let rt, Et, kt, Dt, Ut, Wt, ie;
            if (nt.bytesLoaded = NaN, nt.bytesTotal = NaN, nt.firstByteDate = null, nt.traces = [], rt = !0, Et = /* @__PURE__ */ new Date(), kt = Et, Dt = 0, Ut = null, !_ || !C) throw new Error("config object is not correct or missing");
            const de = function(ke) {
              let rn, Cn;
              return ke.hasOwnProperty("availabilityTimeComplete") && ke.availabilityTimeComplete === !1 && window.fetch && ke.responseType === "arraybuffer" && ke.type === Ht.G.MEDIA_SEGMENT_TYPE ? (ut || (ut = ei(f).create(), ut.setConfig({ dashMetrics: _, boxParser: M })), rn = ut, Cn = X.A.FILE_LOADER_TYPES.FETCH) : (ot || (ot = va(f).create()), rn = ot, Cn = X.A.FILE_LOADER_TYPES.XHR), { loader: rn, fileLoaderType: Cn };
            }(nt), Be = de.loader;
            var Oe;
            nt.fileLoaderType = de.fileLoaderType, nt.headers = {}, function(ke) {
              var Nn, Gn;
              const rn = ke == null ? void 0 : ke.serviceLocation, Cn = (Gn = (Nn = ke == null ? void 0 : ke.mediaInfo) == null ? void 0 : Nn.id) == null ? void 0 : Gn.toString();
              if ($.isServiceLocationIncluded(ke.type, rn) && $.isAdaptationsIncluded(Cn) && it.isCmcdEnabled()) {
                const Xt = it.getCmcdParametersFromManifest(), ce = Xt.mode ? Xt.mode : W.get().streaming.cmcd.mode;
                if (ce === X.A.CMCD_MODE_QUERY) {
                  ke.url = jn.A.removeQueryParameterFromUrl(ke.url, X.A.CMCD_QUERY_KEY);
                  const oe = function(pe) {
                    try {
                      const en = [], mn = it.getQueryParameter(pe);
                      return mn && en.push(mn), en;
                    } catch (en) {
                      return [];
                    }
                  }(ke);
                  ke.url = jn.A.addAdditionalQueryParameterToUrl(ke.url, oe);
                } else ce === X.A.CMCD_MODE_HEADER && (ke.headers = Object.assign(ke.headers, it.getHeaderParameters(ke)));
              }
            }(Oe = nt), Oe.retryAttempts === 0 && function(ke) {
              let rn = P.getFinalQueryString(ke);
              rn && (ke.url = jn.A.addAdditionalQueryParameterToUrl(ke.url, rn));
            }(Oe), function(ke) {
              if (ke.queryParams) {
                const rn = Object.keys(ke.queryParams).map((Cn) => ({ key: Cn, value: ke.queryParams[Cn] }));
                ke.url = jn.A.addAdditionalQueryParameterToUrl(ke.url, rn);
              }
            }(Oe), function(ke) {
              const rn = wt.getCommonAccessTokenForUrl(ke.url);
              rn && (ke.headers[X.A.COMMON_ACCESS_TOKEN_HEADER] = rn);
            }(Oe), nt.range && (nt.headers.Range = "bytes=" + nt.range);
            const nn = mt.getXHRWithCredentialsForType(nt.type);
            Wt = new Uo({ url: nt.url, method: Ht.G.GET, responseType: nt.responseType, headers: nt.headers, credentials: nn ? "include" : "omit", timeout: H, cmcd: it.getCmcdData(nt), customData: { request: nt } }), ie = new uo({ request: Wt, resourceTiming: { startTime: Date.now(), encodedBodySize: 0 }, status: 0 });
            let _n = (/* @__PURE__ */ new Date()).getTime();
            if (isNaN(nt.delayLoadingTime) || _n >= nt.delayLoadingTime) return R.push(Wt), It(Be, Wt, ie);
            {
              let ke = { httpRequest: Wt, httpResponse: ie };
              return G.push(ke), ke.delayTimeout = setTimeout(function() {
                if (G.indexOf(ke) !== -1) {
                  G.splice(G.indexOf(ke), 1);
                  try {
                    Et = /* @__PURE__ */ new Date(), kt = Et, R.push(ke.httpRequest), It(Be, ke.httpRequest, ke.httpResponse);
                  } catch (rn) {
                    ke.httpRequest.onloadend();
                  }
                }
              }, nt.delayLoadingTime - _n), Promise.resolve();
            }
          }
          return K = { abort: function() {
            F.forEach((ht) => {
              clearTimeout(ht.timeout), ht.config.request && ht.config.abort && ht.config.abort(ht.config.request);
            }), F = [], G.forEach((ht) => clearTimeout(ht.delayTimeout)), G = [], R.forEach((ht) => {
              const _t = ht.customData;
              _t && (_t.request && _t.request.type === Ht.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE || (_t.onloadend = _t.onprogress = void 0, _t.abort && _t.abort()));
            }), R = [];
          }, load: function(ht) {
            return ht.request ? J(ht, v.getRetryAttemptsForType(ht.request.type)) : (ht.error && ht.error(ht.request, "error"), Promise.resolve());
          }, reset: function() {
            R = [], G = [], F = [], ot && ot.reset(), ut && ut.reset(), ot = null, ut = null;
          }, resetInitialSettings: function() {
            ot && ot.resetInitialSettings();
          }, setConfig: function(ht) {
            ht && (ht.commonAccessTokenController && (wt = ht.commonAccessTokenController), ht.extUrlQueryInfoController && (P = ht.extUrlQueryInfoController));
          } }, j = (0, jt.A)(f).getInstance().getLogger(K), R = [], G = [], F = [], it = od(f).getInstance(), $ = Wl(f).getInstance(), st = yr(f).getInstance(), mt = (0, Xl.A)(f).getInstance(), wt = Cc(f).getInstance(), P = lo(f).getInstance(), et = { [Ht.G.MPD_TYPE]: Y.DOWNLOAD_ERROR_ID_MANIFEST_CODE, [Ht.G.XLINK_EXPANSION_TYPE]: Y.DOWNLOAD_ERROR_ID_XLINK_CODE, [Ht.G.INIT_SEGMENT_TYPE]: Y.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE, [Ht.G.MEDIA_SEGMENT_TYPE]: Y.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ht.G.INDEX_SEGMENT_TYPE]: Y.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ht.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: Y.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ht.G.OTHER_TYPE]: Y.DOWNLOAD_ERROR_ID_CONTENT_CODE }, K;
        }
        rr.__dashjs_factory_name = "HTTPLoader";
        var cd = Bt.A.getClassFactory(rr);
        function jl() {
          let A, f;
          function C() {
            f = {};
          }
          function _() {
            C();
          }
          return _(), A = { getLoader: function(v) {
            for (var M in f) if (f.hasOwnProperty(M) && v.startsWith(M)) return f[M];
            return cd;
          }, registerLoader: function(v, M) {
            f[v] = M;
          }, unregisterLoader: function(v) {
            f[v] && delete f[v];
          }, unregisterAllLoader: C, reset: _ }, A;
        }
        jl.__dashjs_factory_name = "SchemeLoaderFactory";
        var Zl = Bt.A.getSingletonFactory(jl);
        function Ko(A) {
          A = A || {};
          const f = this.context;
          let C, _, v;
          return _ = Zl(f).getInstance(), C = { abort: function() {
            v && v.abort();
          }, load: function(M) {
            v || (v = _.getLoader(M && M.request ? M.request.url : null)(f).create({ errHandler: A.errHandler, mediaPlayerModel: A.mediaPlayerModel, dashMetrics: A.dashMetrics, boxParser: A.boxParser ? A.boxParser : null, constants: A.constants ? A.constants : null, dashConstants: A.dashConstants ? A.dashConstants : null, urlUtils: A.urlUtils ? A.urlUtils : null, requestTimeout: isNaN(A.requestTimeout) ? 0 : A.requestTimeout, errors: A.errors })), v.load(M);
          }, reset: function() {
            _ && (_.reset(), _ = null), v && typeof v.reset == "function" && v.reset(), v = null;
          }, resetInitialSettings: function() {
            v && typeof v.resetInitialSettings == "function" && v.resetInitialSettings();
          } }, C;
        }
        Ko.__dashjs_factory_name = "URLLoader";
        var ci = Bt.A.getClassFactory(Ko), md = class extends sn {
          constructor(A) {
            super(A), this.checkForExistenceOnly = !0;
          }
        };
        function fd(A) {
          A = A || {};
          const f = this.context, C = A.eventBus, _ = A.events, v = A.urlUtils, M = A.errors, Y = A.streamId;
          let H, L;
          return H = { abort: function() {
            L && L.abort();
          }, checkForExistence: function(W) {
            const K = function(R) {
              C.trigger(_.CHECK_FOR_EXISTENCE_COMPLETED, { request: W, exists: R });
            };
            if (W) {
              let R = new md(W.url);
              L.load({ request: R, success: function() {
                K(!0);
              }, error: function() {
                K(!1);
              } });
            } else K(!1);
          }, load: function(W) {
            const K = function(R, G) {
              C.trigger(_.LOADING_COMPLETED, { request: W, response: R || null, error: G || null, sender: H });
            };
            W ? L.load({ request: W, progress: function(R) {
              C.trigger(_.LOADING_PROGRESS, { request: W, stream: R.stream, streamId: Y }), R.data && C.trigger(_.LOADING_DATA_PROGRESS, { request: W, response: R.data || null, error: null, sender: H });
            }, success: function(R) {
              K(R);
            }, error: function(R, G, F) {
              K(void 0, new Nt.A(M.FRAGMENT_LOADER_LOADING_FAILURE_ERROR_CODE, F, G));
            }, abort: function(R) {
              R && C.trigger(_.LOADING_ABANDONED, { mediaType: R.mediaType, request: R, sender: H });
            } }) : K(void 0, new Nt.A(M.FRAGMENT_LOADER_NULL_REQUEST_ERROR_CODE, M.FRAGMENT_LOADER_NULL_REQUEST_ERROR_MESSAGE));
          }, reset: function() {
            L && (L.abort(), L.reset(), L = null);
          }, resetInitialSettings: function() {
            L && L.resetInitialSettings();
          } }, L = ci(f).create({ errHandler: A.errHandler, errors: M, dashMetrics: A.dashMetrics, mediaPlayerModel: A.mediaPlayerModel, urlUtils: v, constants: X.A, boxParser: A.boxParser, dashConstants: A.dashConstants, requestTimeout: A.settings.get().streaming.fragmentRequestTimeout }), H;
        }
        fd.__dashjs_factory_name = "FragmentLoader";
        var yc = Bt.A.getClassFactory(fd);
        function hd(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = A.errHandler, v = A.mediaPlayerModel, M = A.dashMetrics, Y = (0, jt.A)(f).getInstance(), H = A.streamInfo;
          let L, W, K;
          function R() {
            return H.id;
          }
          function G() {
            for (let et in K) K[et].reset();
            K = {};
          }
          function F(et) {
            if (!et.sender) return;
            const it = et.request, st = et.response, ot = it.isInitializationRequest(), ut = it.representation.mediaInfo.streamInfo;
            if (et.error && (it.mediaType === X.A.AUDIO || it.mediaType === X.A.VIDEO || it.mediaType === X.A.MESH || it.mediaType === X.A.TEXT && it.representation.mediaInfo.isFragmented) && C.trigger(at.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD, { entry: et.request.serviceLocation }), !st || !ut) return void W.warn("No " + it.mediaType + " bytes to push or stream is inactive.");
            const mt = function(wt, $, P, j) {
              const J = new oa();
              return J.streamId = P, J.segmentType = $.type, J.start = $.startTime, J.duration = $.duration, J.end = J.start + J.duration, J.bytes = wt, J.index = $.index, J.representation = $.representation, J.endFragment = j, J;
            }(st, it, H.id, et.type !== at.A.FRAGMENT_LOADING_PROGRESS);
            C.trigger(ot ? at.A.INIT_FRAGMENT_LOADED : at.A.MEDIA_FRAGMENT_LOADED, { chunk: mt, request: it }, { streamId: ut.id, mediaType: it.mediaType });
          }
          return L = { getStreamId: R, getModel: function(et) {
            let it = K[et];
            return it || (it = Tn(f).create({ streamInfo: H, type: et, dashMetrics: M, fragmentLoader: yc(f).create({ dashMetrics: M, mediaPlayerModel: v, errHandler: _, settings: A.settings, boxParser: A.boxParser, eventBus: C, events: at.A, errors: q, dashConstants: A.dashConstants, urlUtils: A.urlUtils, streamId: R() }), debug: Y, eventBus: C, events: at.A }), K[et] = it), it;
          }, reset: function() {
            C.off(At.A.FRAGMENT_LOADING_COMPLETED, F, this), C.off(At.A.FRAGMENT_LOADING_PROGRESS, F, this), G();
          } }, W = Y.getLogger(L), G(), C.on(At.A.FRAGMENT_LOADING_COMPLETED, F, L), C.on(At.A.FRAGMENT_LOADING_PROGRESS, F, L), L;
        }
        hd.__dashjs_factory_name = "FragmentController";
        var Ac = Bt.A.getClassFactory(hd), _c = class {
          constructor() {
            this.url = null, this.width = null, this.height = null, this.x = null, this.y = null;
          }
        }, bc = class {
          constructor() {
            this.bitrate = 0, this.width = 0, this.height = 0, this.tilesHor = 0, this.tilesVert = 0, this.widthPerTile = 0, this.heightPerTile = 0, this.startNumber = 0, this.segmentDuration = 0, this.timescale = 0, this.templateUrl = "", this.id = "";
          }
        };
        class Jl {
          constructor(f) {
            if (this.offset = f._offset, this.type = f.type, this.size = f.size, this.boxes = [], f.boxes) for (let C = 0; C < f.boxes.length; C++) this.boxes.push(new Jl(f.boxes[C]));
            switch (this.isComplete = !0, f.type) {
              case "sidx":
                if (this.timescale = f.timescale, this.earliest_presentation_time = f.earliest_presentation_time, this.first_offset = f.first_offset, this.references = f.references, f.references) {
                  this.references = [];
                  for (let C = 0; C < f.references.length; C++) {
                    let _ = { reference_type: f.references[C].reference_type, referenced_size: f.references[C].referenced_size, subsegment_duration: f.references[C].subsegment_duration };
                    this.references.push(_);
                  }
                }
                break;
              case "emsg":
                this.id = f.id, this.version = f.version === 1 ? 1 : 0, this.value = f.value, this.timescale = f.timescale, this.scheme_id_uri = f.scheme_id_uri, this.presentation_time_delta = f.version === 1 ? f.presentation_time : f.presentation_time_delta, this.event_duration = f.event_duration, this.message_data = f.message_data;
                break;
              case "mdhd":
                this.timescale = f.timescale;
                break;
              case "mfhd":
                this.sequence_number = f.sequence_number;
                break;
              case "subs":
                this.entry_count = f.entry_count, this.entries = f.entries;
                break;
              case "tfhd":
                this.base_data_offset = f.base_data_offset, this.sample_description_index = f.sample_description_index, this.default_sample_duration = f.default_sample_duration, this.default_sample_size = f.default_sample_size, this.default_sample_flags = f.default_sample_flags, this.flags = f.flags;
                break;
              case "tfdt":
                this.version = f.version, this.baseMediaDecodeTime = f.baseMediaDecodeTime, this.flags = f.flags;
                break;
              case "trun":
                if (this.sample_count = f.sample_count, this.first_sample_flags = f.first_sample_flags, this.data_offset = f.data_offset, this.flags = f.flags, this.samples = f.samples, f.samples) {
                  this.samples = [];
                  for (let C = 0, _ = f.samples.length; C < _; C++) {
                    let v = { sample_size: f.samples[C].sample_size, sample_duration: f.samples[C].sample_duration, sample_composition_time_offset: f.samples[C].sample_composition_time_offset };
                    this.samples.push(v);
                  }
                }
                break;
              case "prft":
                this.version = f.version, this.reference_track_ID = f.reference_track_ID, this.ntp_timestamp_sec = f.ntp_timestamp_sec, this.ntp_timestamp_frac = f.ntp_timestamp_frac, this.media_time = f.media_time, this.flags = f.flags;
            }
          }
          getChildBox(f) {
            for (let C = 0; C < this.boxes.length; C++) if (this.boxes[C].type === f) return this.boxes[C];
          }
          getChildBoxes(f) {
            let C = [];
            for (let _ = 0; _ < this.boxes.length; _++) this.boxes[_].type === f && C.push(this.boxes[_]);
            return C;
          }
        }
        var Sc = Jl;
        function pd() {
          let A, f;
          function C(v) {
            let M = [];
            if (!v || !f || typeof f.fetchAll != "function") return M;
            let Y, H = f.fetchAll(v);
            for (let L = 0, W = H.length; L < W; L++) Y = _(H[L]), Y && M.push(Y);
            return M;
          }
          function _(v) {
            if (!v) return null;
            let M = new Sc(v);
            return v.hasOwnProperty("_incomplete") && (M.isComplete = !v._incomplete), M;
          }
          return A = { getBox: function(v) {
            return v && f && f.boxes && f.boxes.length !== 0 && typeof f.fetch == "function" ? _(f.fetch(v)) : null;
          }, getBoxes: C, setData: function(v) {
            f = v;
          }, getLastBox: function() {
            if (!f || !f.boxes || !f.boxes.length) return null;
            let v = C(f.boxes[f.boxes.length - 1].type);
            return v.length > 0 ? v[v.length - 1] : null;
          } }, A;
        }
        pd.__dashjs_factory_name = "IsoFile";
        var Jr = Bt.A.getClassFactory(pd), go = w(6877), Ql = class {
          constructor(A) {
            let { found: f, sizeOfLastCompletedBox: C, sizeOfLastFoundTargetBox: _, startOffsetOfLastCompletedBox: v, startOffsetOfLastFoundTargetBox: M, typeOfLastCompletedBox: Y, typeOfLastTargetBox: H } = A;
            this.found = f !== void 0 && f, this.sizeOfLastCompletedBox = C !== void 0 ? C : 0, this.sizeOfLastFoundTargetBox = _ !== void 0 ? _ : 0, this.startOffsetOfLastCompletedBox = v !== void 0 ? v : 0, this.startOffsetOfLastFoundTargetBox = M !== void 0 ? M : 0, this.typeOfLastCompletedBox = Y !== void 0 ? Y : null, this.typeOfLastTargetBox = H !== void 0 ? H : null;
          }
        };
        function Id() {
          let A, f, C = this.context;
          function _(Y) {
            if (!Y) return null;
            Y.fileStart === void 0 && (Y.fileStart = 0);
            let H = go.parseBuffer(Y), L = Jr(C).create();
            return L.setData(H), L;
          }
          function v(Y, H) {
            return Y[H + 3] >>> 0 | Y[H + 2] << 8 >>> 0 | Y[H + 1] << 16 >>> 0 | Y[H] << 24 >>> 0;
          }
          function M(Y, H) {
            return String.fromCharCode(Y[H++]) + String.fromCharCode(Y[H++]) + String.fromCharCode(Y[H++]) + String.fromCharCode(Y[H]);
          }
          return f = { findInitRange: function(Y) {
            let H, L, W = null;
            const K = _(Y);
            if (!K) return W;
            const R = K.getBox("ftyp"), G = K.getBox("moov");
            return A.debug("Searching for initialization."), G && G.isComplete && (H = R ? R.offset : G.offset, L = G.offset + G.size - 1, W = H + "-" + L, A.debug("Found the initialization.  Range: " + W)), W;
          }, findLastTopIsoBoxCompleted: function(Y, H, L) {
            if (L === void 0 && (L = 0), !H || L + 8 >= H.byteLength) return new Ql({ found: !1 });
            const W = H instanceof ArrayBuffer ? new Uint8Array(H) : H;
            let K, R = 0, G = 0, F = null;
            for (; L < W.byteLength; ) {
              const et = v(W, L), it = M(W, L + 4);
              if (et === 0) break;
              L + et <= W.byteLength && (Y.indexOf(it) >= 0 ? K = new Ql({ found: !0, startOffsetOfLastFoundTargetBox: L, sizeOfLastFoundTargetBox: et, typeOfLastTargetBox: it }) : (R = L, G = et, F = it)), L += et;
            }
            return K || new Ql({ found: !1, startOffsetOfLastCompletedBox: R, sizeOfLastCompletedBox: G, typeOfLastCompletedBox: F });
          }, getMediaTimescaleFromMoov: function(Y) {
            let H = _(Y), L = H ? H.getBox("mdhd") : void 0;
            return L ? L.timescale : NaN;
          }, getSamplesInfo: function(Y) {
            if (!Y || Y.byteLength === 0) return { sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN };
            let H, L, W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J = _(Y), ht = J.getBoxes("moof"), _t = J.getBoxes("mfhd");
            P = J.getBoxes("moof").length, $ = _t[_t.length - 1].sequence_number, W = 0, G = [];
            let Ct = -1, bt = -1;
            for (ot = 0; ot < ht.length; ot++) {
              let Rt = ht[ot], xt = Rt.getChildBoxes("traf");
              for (it = 0; it < xt.length; it++) {
                let Pt = xt[it], N = Pt.getChildBox("tfhd"), ct = Pt.getChildBox("tfdt");
                R = ct.baseMediaDecodeTime;
                let It = Pt.getChildBoxes("trun"), dt = Pt.getChildBoxes("subs");
                for (st = 0; st < It.length; st++) {
                  let nt = It[st];
                  for (W = nt.sample_count, wt = (N.base_data_offset || 0) + (nt.data_offset || 0), et = 0; et < W; et++) {
                    F = nt.samples[et], H = F.sample_duration !== void 0 ? F.sample_duration : N.default_sample_duration, K = F.sample_size !== void 0 ? F.sample_size : N.default_sample_size, L = F.sample_composition_time_offset !== void 0 ? F.sample_composition_time_offset : 0;
                    let ft = { dts: R, cts: R + L, duration: H, offset: Rt.offset + wt, size: K, subSizes: [K] };
                    if (dt) for (ut = 0; ut < dt.length; ut++) {
                      let rt = dt[ut];
                      if (Ct < rt.entry_count - 1 && et > bt && (Ct++, bt += rt.entries[Ct].sample_delta), et == bt) {
                        ft.subSizes = [];
                        let Et = rt.entries[Ct];
                        for (mt = 0; mt < Et.subsample_count; mt++) ft.subSizes.push(Et.subsamples[mt].subsample_size);
                      }
                    }
                    G.push(ft), wt += K, R += H;
                  }
                }
                j = R - ct.baseMediaDecodeTime;
              }
            }
            return { sampleList: G, lastSequenceNumber: $, totalDuration: j, numSequences: P };
          }, parse: _ }, A = (0, jt.A)(C).getInstance().getLogger(f), f;
        }
        Id.__dashjs_factory_name = "BoxParser";
        var Vo = Bt.A.getSingletonFactory(Id);
        function Cd(A) {
          const f = this.context, C = A.adapter, _ = A.baseURLController, v = A.streamInfo, M = A.timelineConverter, Y = A.debug, H = A.eventBus, L = A.events, W = A.dashConstants, K = He(f).getInstance();
          let R, G, F, et, it, st, ot, ut, mt;
          function wt(P, j) {
            const J = new bc();
            J.id = P.id, J.bitrate = P.bandwidth, J.width = P.width, J.height = P.height, J.tilesHor = 1, J.tilesVert = 1, P.essentialProperties && P.essentialProperties.forEach((ht) => {
              if (X.A.THUMBNAILS_SCHEME_ID_URIS.indexOf(ht.schemeIdUri) >= 0 && ht.value) {
                const _t = ht.value.split("x");
                _t.length !== 2 || isNaN(_t[0]) || isNaN(_t[1]) || (J.tilesHor = parseInt(_t[0], 10), J.tilesVert = parseInt(_t[1], 10));
              }
            }), j ? ot.updateSegmentData(P).then((ht) => {
              (function(_t, Ct, bt) {
                let Rt = [];
                const xt = function(Pt, N) {
                  const ct = [];
                  let It, dt, nt, ft, rt = 0;
                  for (It = 0, dt = Pt.segments.length; It < dt; It++) nt = Pt.segments[It], ft = Hn(M, C.getIsDynamic(), N, nt.startTime, nt.duration, nt.timescale, nt.media, nt.mediaRange, rt), ft && (ct.push(ft), ft = null, rt++);
                  return ct;
                }(bt, Ct);
                Ct.segments = xt, Ct.fragmentDuration = Ct.segmentDuration || (Ct.segments && Ct.segments.length > 0 ? Ct.segments[0].duration : NaN), _t.segmentDuration = Ct.segments[0].duration, _t.readThumbnail = function(Pt, N) {
                  let ct = null;
                  Rt.some((It) => {
                    if (It.start <= Pt && It.end > Pt) return ct = It.url, !0;
                  }), ct ? N(ct) : Ct.segments.some((It) => {
                    if (It.mediaStartTime <= Pt && It.mediaStartTime + It.duration > Pt) {
                      const dt = _.resolve(Ct.path), nt = new Uo({ method: "get", url: dt.url, responseType: "arraybuffer", customData: { request: { range: It.mediaRange }, onloadend: function(rt) {
                        let Et = mt.getSamplesInfo(rt.target.response), kt = new Blob([rt.target.response.slice(Et.sampleList[0].offset, Et.sampleList[0].offset + Et.sampleList[0].size)], { type: "image/jpeg" }), Dt = window.URL.createObjectURL(kt);
                        Rt.push({ start: It.mediaStartTime, end: It.mediaStartTime + It.duration, url: Dt }), N && N(Dt);
                      } } }), ft = new uo({ request: nt });
                      return ut.load(nt, ft), !0;
                    }
                  });
                };
              })(J, P, ht);
            }) : (J.startNumber = P.startNumber, J.segmentDuration = P.segmentDuration, J.timescale = P.timescale, J.templateUrl = function(ht) {
              const _t = K.isRelative(ht.media) ? K.resolve(ht.media, _.resolve(ht.path).url) : ht.media;
              return _t ? qn(_t, ht.id) : "";
            }(P)), J.tilesHor > 0 && J.tilesVert > 0 && (J.widthPerTile = J.width / J.tilesHor, J.heightPerTile = J.height / J.tilesVert, G.push(J));
          }
          function $() {
            G = [], F = [], it = -1, st = null, et && (et.reset(), et = null);
          }
          return R = { addTracks: function() {
            if (!v || !C || (st = C.getMediaInfoForType(v, X.A.IMAGE), !st)) return;
            const P = C.getVoRepresentations(st);
            P && P.length > 0 && P.forEach((j) => {
              (j.segmentInfoType === D.A.SEGMENT_TEMPLATE && j.segmentDuration > 0 && j.media || j.segmentInfoType === D.A.SEGMENT_TIMELINE) && wt(j), j.segmentInfoType === D.A.SEGMENT_BASE && wt(j, !0), F.push(j);
            }), G.length > 0 && G.sort((j, J) => j.bitrate - J.bitrate);
          }, getCurrentTrack: function() {
            return it < 0 ? null : G[it];
          }, getCurrentTrackIndex: function() {
            return it;
          }, getRepresentations: function() {
            return F;
          }, getThumbnailRequestForTime: function(P) {
            let j;
            const J = C.getVoRepresentations(st);
            for (let ht = 0; ht < J.length; ht++) if (G[it].id === J[ht].id) {
              j = J[ht];
              break;
            }
            return et.getSegmentRequestForTime(st, j, P);
          }, getTracks: function() {
            return G;
          }, reset: $, setTrackById: function(P) {
            if (!G || G.length === 0) return;
            const j = G.findIndex((J) => J.id === P);
            j !== -1 && (it = j);
          }, setTrackByIndex: function(P) {
            G && G.length !== 0 && (P >= G.length && (P = G.length - 1), it = P);
          } }, $(), ut = va(f).create({}), mt = Vo(f).getInstance(), ot = ye(f).create({ events: L, eventBus: H, streamInfo: v, timelineConverter: M, dashConstants: W, dashMetrics: A.dashMetrics, segmentBaseController: A.segmentBaseController, type: X.A.IMAGE }), et = Ie(f).create({ streamInfo: v, type: X.A.IMAGE, timelineConverter: M, segmentsController: ot, baseURLController: _, debug: Y, eventBus: H, events: L, dashConstants: W, urlUtils: K }), et.initialize(!!C && C.getIsDynamic()), R;
        }
        Cd.__dashjs_factory_name = "ThumbnailTracks";
        var wc = Bt.A.getClassFactory(Cd);
        function yd(A) {
          const f = this.context, C = A.streamInfo;
          let _, v;
          function M(H) {
            v.setTrackByIndex(H);
          }
          function Y() {
            v && v.reset();
          }
          return _ = { getCurrentTrack: function() {
            return v.getCurrentTrack();
          }, getCurrentTrackIndex: function() {
            return v.getCurrentTrackIndex();
          }, getPossibleVoRepresentations: function() {
            return v.getRepresentations();
          }, getStreamId: function() {
            return C.id;
          }, initialize: function() {
            v.addTracks();
            const H = v.getTracks();
            H && H.length > 0 && M(0);
          }, provide: function(H, L) {
            if (typeof L != "function") return;
            const W = v.getCurrentTrack();
            let K, R;
            if (!W || W.segmentDuration <= 0 || H == null) return void L(null);
            R = v.getThumbnailRequestForTime(H), R && (W.segmentDuration = R.duration), K = H % W.segmentDuration;
            const G = Math.floor(K * W.tilesHor * W.tilesVert / W.segmentDuration), F = new _c();
            if (F.width = Math.floor(W.widthPerTile), F.height = Math.floor(W.heightPerTile), F.x = Math.floor(G % W.tilesHor) * W.widthPerTile, F.y = Math.floor(G / W.tilesHor) * W.heightPerTile, "readThumbnail" in W) return W.readThumbnail(H, (et) => {
              F.url = et, L(F);
            });
            if (R) F.url = R.url, W.segmentDuration = NaN;
            else {
              const et = Math.floor(H / W.segmentDuration);
              F.url = function(it, st) {
                const ot = st + it.startNumber;
                return qn(it.templateUrl, void 0, ot, void 0, it.bandwidth, (ot - 1) * it.segmentDuration * it.timescale);
              }(W, et);
            }
            L(F);
          }, reset: Y, setTrackByIndex: M, setTrackById: function(H) {
            v.setTrackById(H);
          } }, Y(), v = wc(f).create({ streamInfo: C, adapter: A.adapter, baseURLController: A.baseURLController, timelineConverter: A.timelineConverter, debug: A.debug, eventBus: A.eventBus, events: A.events, dashConstants: A.dashConstants, dashMetrics: A.dashMetrics, segmentBaseController: A.segmentBaseController }), _;
        }
        yd.__dashjs_factory_name = "ThumbnailController";
        var Ar = Bt.A.getClassFactory(yd);
        function Qr(A) {
          let f;
          A = A || {};
          let C = [];
          const _ = (0, Mt.A)(this.context).getInstance(), v = A.updateEventName, M = A.addBlacklistEventName;
          function Y(L) {
            C.indexOf(L) === -1 && (C.push(L), _.trigger(v, { entry: L }));
          }
          function H(L) {
            Y(L.entry);
          }
          return f = { add: Y, remove: function(L) {
            const W = C.indexOf(L);
            W !== -1 && C.splice(W, 1);
          }, contains: function(L) {
            return !!(C.length && L && L.length) && C.indexOf(L) !== -1;
          }, reset: function() {
            M && _.off(M, H, f), C = [];
          } }, M && _.on(M, H, f), f;
        }
        Qr.__dashjs_factory_name = "BlackListController";
        var ql = Bt.A.getClassFactory(Qr);
        const $l = [X.A.MESH, X.A.VIDEO, X.A.AUDIO, X.A.TEXT, X.A.MUXED, X.A.IMAGE];
        function qr(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = He(f).getInstance(), v = A.manifestModel, M = A.mediaPlayerModel, Y = A.dashMetrics, H = A.manifestUpdater, L = A.adapter, W = A.timelineConverter, K = A.capabilities, R = A.errHandler, G = A.abrController, F = A.playbackController, et = A.throughputController, it = A.eventController, st = A.mediaController, ot = A.protectionController, ut = A.textController, mt = A.videoModel;
          let wt = A.streamInfo;
          const $ = A.settings;
          let P, j, J, ht, _t, Ct, bt, Rt, xt, Pt, N, ct, It, dt, nt, ft;
          function rt(se, Ke, qe) {
            return new Promise((Ze, tn) => {
              Be(), nn();
              let $t = mt.getElement();
              const Se = [];
              $l.forEach((Je) => {
                if ((Je !== X.A.TEXT || se) && (Je !== X.A.VIDEO || !$t || $t && /^VIDEO$/i.test($t.nodeName))) {
                  const $e = qe.find((ue) => ue.mediaInfo.type === Je);
                  Se.push(Et(Je, se, $e));
                }
              }), Promise.all(Se).then(() => {
                return Je = Ke, new Promise(($e) => {
                  const ue = {}, Tt = J.map((Zt) => {
                    const he = Zt.getRepresentation();
                    return Zt.createBufferSinks(Je, he);
                  });
                  Promise.all(Tt).then((Zt) => {
                    Zt.forEach((he) => {
                      he && (ue[he.getType()] = he);
                    }), $e(ue);
                  }).catch(() => {
                    $e(ue);
                  });
                });
                var Je;
              }).then((Je) => {
                if (J.length === 0) {
                  const $e = "No streams to play.";
                  R.error(new Nt.A(q.MANIFEST_ERROR_ID_NOSTREAMS_CODE, $e, v.getValue())), j.fatal($e);
                } else pe();
                se && ut.createTracks(wt), Ze(Je);
              }).catch((Je) => {
                tn(Je);
              });
            });
          }
          function Et(se, Ke, qe) {
            let Ze, tn = L.getAllMediaInfoForType(wt, se), $t = [], Se = null;
            if (!tn || tn.length === 0) return j.info("No " + se + " data."), Promise.resolve();
            se === X.A.VIDEO && (bt = !0), se === X.A.AUDIO && (Rt = !0);
            for (let $e = 0, ue = tn.length; $e < ue; $e++) Se = tn[$e], se === X.A.TEXT && Se.isEmbedded && (ut.addEmbeddedTrack(wt, Se), $t.push(Se)), kt(Se) && st.addTrack(Se);
            if ($t.length > 0 && (st.setInitialMediaSettingsForType(se, wt), ut.addMediaInfosToBuffer(wt, se, $t)), tn = tn.filter(($e) => !$e.isEmbedded), tn.length === 0) return Promise.resolve();
            if (se === X.A.IMAGE) return Pt = Ar(f).create({ streamInfo: wt, adapter: L, baseURLController: A.baseURLController, timelineConverter: A.timelineConverter, debug: dt, eventBus: C, events: at.A, dashConstants: D.A, dashMetrics: A.dashMetrics, segmentBaseController: A.segmentBaseController }), Pt.initialize(), Promise.resolve();
            C.trigger(at.A.STREAM_INITIALIZING, { streamInfo: wt, mediaInfo: Se }), st.setInitialMediaSettingsForType(se, wt);
            let Je = function($e, ue) {
              const Tt = $e && $e.length > 0 ? $e[0] : null;
              let Zt = xt.getModel(Tt ? Tt.type : null);
              const he = Tt ? Tt.type : null, qt = Tt ? Tt.mimeType : null, Me = Tt ? Tt.isFragmented : null;
              let Ve = Wn(f).create({ abrController: G, adapter: L, baseURLController: A.baseURLController, boxParser: It, capabilities: K, dashMetrics: A.dashMetrics, errHandler: R, fragmentModel: Zt, manifestModel: v, mediaController: st, mediaPlayerModel: M, mimeType: qt, playbackController: F, segmentBaseController: A.segmentBaseController, segmentBlacklistController: N, settings: $, streamInfo: wt, textController: ut, throughputController: et, timelineConverter: W, type: he });
              return Ve.initialize(ue, bt, Me), J.push(Ve), Ve.setMediaInfoArray($e), he === X.A.TEXT && ut.addMediaInfosToBuffer(wt, he, $e, Zt), Ve;
            }(tn, Ke);
            if (Ze = st.getCurrentTrackFor(se, wt.id), Ze) {
              const $e = se === X.A.TEXT && Ze.isEmbedded ? tn[0] : Ze, ue = new on({ newMediaInfo: $e, previouslySelectedRepresentation: qe });
              return Je.selectMediaInfo(ue);
            }
            return Promise.resolve();
          }
          function kt(se) {
            const Ke = se ? se.type : null;
            let qe;
            return !(Ke !== X.A.MESH && (Ke === X.A.MUXED ? (qe = "Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines", j.fatal(qe), R.error(new Nt.A(q.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, qe, v.getValue())), 1) : Ke !== X.A.TEXT && Ke !== X.A.IMAGE && se.contentProtection && se.contentProtection.length > 0 && !K.supportsEncryptedMedia() && (R.error(new Nt.A(q.CAPABILITY_MEDIAKEYS_ERROR_CODE, q.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE)), 1)));
          }
          function Dt(se) {
            let Ke = J ? J.length : 0;
            for (let qe = 0; qe < Ke; qe++) {
              let Ze = J[qe].getFragmentModel();
              Ze.abortRequests(), Ze.resetInitialSettings(), J[qe].reset(!1, se);
            }
            ut && ut.deactivateStream(wt), Pt && (Pt.reset(), Pt = null), J = [], _t = !1, Ct = !1, en(!1), Wt(!1), C.trigger(at.A.STREAM_DEACTIVATED, { streamInfo: wt });
          }
          function Ut(se) {
            Dt(se), ht = !1, bt = !1, Rt = !1, nt = !1, ft = [];
          }
          function Wt(se) {
            nt = se;
          }
          function ie() {
            return wt ? wt.start : NaN;
          }
          function de() {
            return wt ? wt.id : null;
          }
          function Be() {
            if (!mt || !G) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function Oe(se) {
            se.error && (R.error(se.error), j.fatal(se.error.message));
          }
          function nn() {
            if (it) {
              const se = L.getEventsFor(wt);
              se && se.length > 0 && it.addInlineEvents(se, wt.id);
            }
          }
          function _n(se) {
            let Ke = ke(se);
            return Ke ? Ke.getMediaInfo() : null;
          }
          function ke(se) {
            return se ? J.find((Ke) => Ke.getType() === se) : null;
          }
          function rn() {
            let se = ce();
            const Ke = se.length;
            if (Ke !== 0) {
              for (let qe = 0; qe < Ke; qe++) if (!se[qe].isBufferingCompleted() && (se[qe].getType() === X.A.AUDIO || se[qe].getType() === X.A.VIDEO || se[qe].getType() === X.A.MESH)) return void j.debug("onBufferingCompleted - One streamProcessor has finished but", se[qe].getType(), "one is not buffering completed");
              j.debug("onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED"), Ct = !0, C.trigger(at.A.STREAM_BUFFERING_COMPLETED, { streamInfo: wt }, { streamInfo: wt });
            } else j.warn("onBufferingCompleted - can't trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined");
          }
          function Cn(se) {
            it && it.addInbandEvents(se.events, wt.id);
          }
          function Nn() {
            pe();
          }
          function Gn(se) {
            return se && se.type ? Xt(se.type) : null;
          }
          function Xt(se) {
            return se ? ce().filter(function(Ke) {
              return Ke.getType() === se;
            })[0] : null;
          }
          function ce() {
            let se, Ke, qe = [];
            for (let Ze = 0; Ze < J.length; Ze++) Ke = J[Ze], se = Ke.getType(), se !== X.A.AUDIO && se !== X.A.VIDEO && se !== X.A.TEXT && se !== X.A.MESH || qe.push(Ke);
            return qe;
          }
          function oe() {
            const se = J.length;
            for (let Ke = 0; Ke < se && J[Ke]; Ke++) J[Ke].getScheduleController().startScheduleTimer();
          }
          function pe() {
            const se = J.length;
            if (ot) {
              ot.clearMediaInfoArray();
              for (let Ke = 0; Ke < se && J[Ke]; Ke++) {
                const qe = J[Ke].getType(), Ze = J[Ke].getMediaInfo();
                if (qe === X.A.AUDIO || qe === X.A.VIDEO || qe === X.A.MESH || qe === X.A.TEXT && Ze && Ze.isFragmented) {
                  let tn = J[Ke].getMediaInfo();
                  tn && ot.initializeForMedia(tn);
                }
              }
              ot.handleKeySystemFromManifest();
            }
            ht || (ht = !0, mt.waitForReadyState(X.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, () => {
              C.trigger(at.A.STREAM_INITIALIZED, { streamInfo: wt });
            }));
          }
          function en(se) {
            ct = se;
          }
          function mn() {
            return ct;
          }
          return P = { activate: function(se, Ke) {
            let qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            return new Promise((Ze, tn) => {
              if (!_t) return mn() ? (_t = !0, C.trigger(at.A.STREAM_ACTIVATED, { streamInfo: wt }), void Ze(Ke)) : void function($t, Se) {
                return rt($t, Se, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []);
              }(se, Ke, qe).then(($t) => {
                _t = !0, qe && qe.length > 0 && oe(), C.trigger(at.A.STREAM_ACTIVATED, { streamInfo: wt }), Ze($t);
              }).catch(($t) => {
                tn($t);
              });
              Ze(Ke);
            });
          }, checkAndHandleCompletedBuffering: function() {
            Ct || J.forEach((se) => {
              se.checkAndHandleCompletedBuffering();
            });
          }, deactivate: Dt, getAdapter: function() {
            return L;
          }, getCurrentMediaInfoForType: function(se) {
            const Ke = Xt(se);
            return Ke ? Ke.getMediaInfo() : null;
          }, getCurrentRepresentationForType: function(se) {
            const Ke = Xt(se);
            return Ke ? Ke.getRepresentation() : null;
          }, getDuration: function() {
            return wt ? wt.duration : NaN;
          }, getHasAudioTrack: function() {
            return Rt;
          }, getHasFinishedBuffering: function() {
            return Ct;
          }, getHasVideoTrack: function() {
            return bt;
          }, getId: de, getIsActive: function() {
            return _t;
          }, getIsEndedEventSignaled: function() {
            return nt;
          }, getPreloaded: mn, getRepresentationForTypeById: function(se, Ke) {
            let qe;
            if (se === X.A.IMAGE) {
              if (!Pt) return null;
              qe = Pt.getPossibleVoRepresentations();
            } else
              qe = function($t) {
                let Se = ke($t);
                return Se ? Se.getAllMediaInfos() : [];
              }(se).flatMap(($t) => G.getPossibleVoRepresentationsFilteredBySettings($t, !0));
            if (!qe || qe.length === 0) return null;
            const Ze = qe.filter((tn) => tn.id === Ke);
            return Ze && Ze.length > 0 ? Ze[0] : null;
          }, getRepresentationForTypeByIndex: function(se, Ke) {
            let qe;
            if (se === X.A.IMAGE) {
              if (!Pt) return null;
              qe = Pt.getPossibleVoRepresentations();
            } else {
              const Ze = _n(se);
              qe = G.getPossibleVoRepresentationsFilteredBySettings(Ze, !0);
            }
            return qe[Ke = Math.max(Math.min(Ke, qe.length - 1), 0)];
          }, getRepresentationsByType: function(se) {
            if (Be(), se === X.A.IMAGE) return Pt ? Pt.getPossibleVoRepresentations() : [];
            const Ke = _n(se);
            return G.getPossibleVoRepresentationsFilteredBySettings(Ke, !0);
          }, getStartTime: ie, getStreamId: function() {
            return wt ? wt.id : null;
          }, getStreamInfo: function() {
            return wt;
          }, getStreamProcessors: ce, getThumbnailController: function() {
            return Pt;
          }, initialize: function() {
            C.on(at.A.BUFFERING_COMPLETED, rn, P), C.on(at.A.INBAND_EVENTS, Cn, P), C.on(at.A.DATA_UPDATE_COMPLETED, Nn, P), ot && (C.on(at.A.KEY_ERROR, Oe, P), C.on(at.A.SERVER_CERTIFICATE_UPDATED, Oe, P), C.on(at.A.LICENSE_REQUEST_COMPLETE, Oe, P), C.on(at.A.KEY_SYSTEM_SELECTED, Oe, P), C.on(at.A.KEY_SESSION_CREATED, Oe, P)), ut.initializeForStream(wt), C.trigger(at.A.STREAM_UPDATED, { streamInfo: wt });
          }, initializeForTextWithMediaSource: function(se) {
            return new Promise((Ke, qe) => {
              Et(X.A.TEXT, se, null).then(() => function() {
                const Ze = Xt(X.A.TEXT);
                return Ze ? Ze.createBufferSinks() : Promise.resolve();
              }()).then(() => {
                ut.createTracks(wt), Ke();
              }).catch((Ze) => {
                qe(Ze);
              });
            });
          }, prepareQualityChange: function(se) {
            const Ke = Xt(se.mediaType);
            Ke && Ke.prepareQualityChange(se);
          }, prepareTrackChange: function(se) {
            if (!_t || !wt) return;
            Ct = !1;
            let Ke = se.newMediaInfo, qe = v.getValue(), Ze = Gn(Ke);
            if (!Ze) return;
            let tn = F.getTime();
            if (j.info("Stream -  Process track changed at current time " + tn), qe.refreshManifestOnSwitchTrack) ft.push(se), H.getIsUpdating() || (j.debug("Stream -  Refreshing manifest for switch track"), H.refreshManifest());
            else {
              Ze.clearScheduleTimer(), Ze.setTrackSwitchInProgress(!0);
              const $t = Ze.getRepresentation();
              Ze.selectMediaInfo(new on({ newMediaInfo: Ke })).then(() => {
                const Se = !!(se && se.options && se.options.hasOwnProperty("replaceBuffer")) && se.options.replaceBuffer;
                return Ze.prepareTrackSwitch($t, Se);
              }).then(() => {
                Ze.setTrackSwitchInProgress(!1);
              });
            }
          }, reset: function(se) {
            xt && (xt.reset(), xt = null), G && wt && G.clearDataForStream(wt.id), N && (N.reset(), N = null), ut && wt && ut.clearDataForStream(wt.id), st && wt && st.clearDataForStream(wt.id), Ut(se), wt = null, C.off(at.A.BUFFERING_COMPLETED, rn, P), C.off(at.A.INBAND_EVENTS, Cn, P), C.off(at.A.DATA_UPDATE_COMPLETED, Nn, P), ot && (C.off(at.A.KEY_ERROR, Oe, P), C.off(at.A.SERVER_CERTIFICATE_UPDATED, Oe, P), C.off(at.A.LICENSE_REQUEST_COMPLETE, Oe, P), C.off(at.A.KEY_SYSTEM_SELECTED, Oe, P), C.off(at.A.KEY_SESSION_CREATED, Oe, P));
          }, setIsEndedEventSignaled: Wt, setMediaSource: function(se) {
            return new Promise((Ke, qe) => {
              const Ze = [];
              for (let tn = 0; tn < J.length; ) kt(J[tn].getMediaInfo()) ? (Ze.push(J[tn].setMediaSource(se)), tn++) : (J[tn].reset(), J.splice(tn, 1));
              Promise.all(Ze).then(() => {
                for (let tn = 0; tn < J.length; tn++) J[tn].dischargePreBuffer();
                if (J.length === 0) {
                  const tn = "No streams to play.";
                  R.error(new Nt.A(q.MANIFEST_ERROR_ID_NOSTREAMS_CODE, tn + "nostreams", v.getValue())), j.fatal(tn);
                }
                Ke();
              }).catch((tn) => {
                j.error(tn), qe(tn);
              });
            });
          }, startPreloading: function(se, Ke) {
            let qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            return new Promise((Ze, tn) => {
              mn() ? tn() : (j.info(`[startPreloading] Preloading next stream with id ${de()}`), en(!0), rt(se, Ke, qe).then(() => {
                for (let $t = 0; $t < J.length && J[$t]; $t++) J[$t].setExplicitBufferingTime(ie()), J[$t].getScheduleController().startScheduleTimer();
                Ze();
              }).catch(() => {
                en(!1), tn();
              }));
            });
          }, startScheduleControllers: oe, triggerProtectionError: function(se) {
            Oe(se);
          }, updateData: function(se) {
            return new Promise((Ke) => {
              wt = se, it && nn();
              let qe, Ze = [];
              for (let tn = 0, $t = J.length; tn < $t; tn++) {
                let Se = J[tn];
                const Je = Se.getMediaInfo();
                Ze.push(Se.updateStreamInfo(wt));
                let $e = L.getAllMediaInfoForType(wt, Se.getType());
                if ($e = $e.filter((ue) => !ue.isEmbedded), Se.setMediaInfoArray($e), $e) for (let ue = 0; ue < $e.length; ue++) L.areMediaInfosEqual(Je, $e[ue]) && Ze.push(Se.selectMediaInfo(new on({ newMediaInfo: $e[ue] })));
              }
              Promise.all(Ze).then(() => {
                let tn = [];
                for (; ft.length > 0; ) {
                  let $t = ft.pop(), Se = $t.newMediaInfo;
                  if (qe = Gn($t.oldMediaInfo), !qe) return;
                  const Je = qe.getRepresentation();
                  qe.setTrackSwitchInProgress(!0), tn.push(qe.prepareTrackSwitch(Je)), tn.push(qe.selectMediaInfo(new on({ newMediaInfo: Se })));
                }
                return Promise.all(tn);
              }).then(() => {
                pe(), qe && qe.setTrackSwitchInProgress(!1), C.trigger(at.A.STREAM_UPDATED, { streamInfo: wt }), Ke();
              }).catch((tn) => {
                R.error(tn);
              });
            });
          } }, function() {
            try {
              dt = (0, jt.A)(f).getInstance(), j = dt.getLogger(P), Ut(), It = Vo(f).getInstance(), N = ql(f).create({ updateEventName: at.A.SEGMENT_LOCATION_BLACKLIST_CHANGED, addBlacklistEventName: at.A.SEGMENT_LOCATION_BLACKLIST_ADD }), xt = Ac(f).create({ streamInfo: wt, mediaPlayerModel: M, dashMetrics: Y, errHandler: R, settings: $, boxParser: It, dashConstants: D.A, urlUtils: _ });
            } catch (se) {
              throw se;
            }
          }(), P;
        }
        qr.__dashjs_factory_name = "Stream";
        var Xo = Bt.A.getClassFactory(qr), aa = class {
          constructor(A) {
            this.url = A || null, this.type = Ht.G.CONTENT_STEERING_TYPE, this.responseType = "json";
          }
        }, S = class {
          constructor() {
            this.version = null, this.ttl = 300, this.reloadUri = null, this.pathwayPriority = [], this.pathwayClones = [];
          }
        };
        function O() {
          const A = this.context, f = He(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R, G, F, et, it, st;
          function ot(bt) {
            wt(bt, "baseUrl");
          }
          function ut(bt) {
            wt(bt, "location");
          }
          function mt(bt) {
            var Rt, xt;
            bt && bt.throughputValues && bt.throughputValues.serviceLocation && (Rt = bt.throughputValues.serviceLocation, xt = bt.throughputValues, Y[Rt] || (Y[Rt] = []), Y[Rt].push(xt), Y[Rt].length > 4 && Y[Rt].shift());
          }
          function wt(bt, Rt) {
            if (bt && bt.request && bt.request.serviceLocation) {
              const xt = bt.request.serviceLocation;
              M[Rt].all.indexOf(xt) === -1 && M[Rt].all.push(xt), M[Rt].current = xt;
            }
          }
          function $() {
            const bt = G.getValue();
            let Rt = st.getContentSteering(bt);
            return Rt || (Rt = F.getServiceDescriptionSettings().contentSteering), Rt;
          }
          function P() {
            return new Promise((bt) => {
              try {
                const Rt = $();
                if (!Rt || !Rt.serverUrl) return void bt();
                const xt = function(N) {
                  let ct = N.serverUrl;
                  v && v.reloadUri && (ct = f.isRelative(v.reloadUri) ? f.resolve(v.reloadUri, N.serverUrl) : v.reloadUri);
                  const It = [], dt = M.baseUrl.all.concat(M.location.all);
                  if (dt.length > 0) {
                    const nt = dt.map((Et) => {
                      const kt = function(Dt) {
                        if (!Dt || !Y[Dt] || Y[Dt].length === 0) return -1;
                        const Ut = et.getArithmeticMean(Y[Dt], Y[Dt].length, !0);
                        return parseInt(1e3 * Ut);
                      }(Et);
                      return { serviceLocation: Et, throughput: kt };
                    });
                    let ft = "", rt = "";
                    nt.forEach((Et, kt) => {
                      kt !== 0 && (ft += ",", rt += ","), ft += Et.serviceLocation, rt += Et.throughput > -1 ? Et.throughput : "";
                    }), It.push({ key: "_DASH_pathway", value: `"${ft}"` }), It.push({ key: "_DASH_throughput", value: rt });
                  }
                  return ct = jn.A.addAdditionalQueryParameterToUrl(ct, It), ct;
                }(Rt), Pt = new aa(xt);
                L.load({ request: Pt, success: (N) => {
                  (function(ct) {
                    ct && ct[D.A.CONTENT_STEERING_RESPONSE.VERSION] && parseInt(ct[D.A.CONTENT_STEERING_RESPONSE.VERSION]) === 1 && (v = new S(), v.version = ct[D.A.CONTENT_STEERING_RESPONSE.VERSION], ct[D.A.CONTENT_STEERING_RESPONSE.TTL] && !isNaN(ct[D.A.CONTENT_STEERING_RESPONSE.TTL]) && (v.ttl = ct[D.A.CONTENT_STEERING_RESPONSE.TTL]), ct[D.A.CONTENT_STEERING_RESPONSE.RELOAD_URI] && (v.reloadUri = ct[D.A.CONTENT_STEERING_RESPONSE.RELOAD_URI]), ct[D.A.CONTENT_STEERING_RESPONSE.PATHWAY_PRIORITY] && (v.pathwayPriority = ct[D.A.CONTENT_STEERING_RESPONSE.PATHWAY_PRIORITY]), ct[D.A.CONTENT_STEERING_RESPONSE.PATHWAY_CLONES] && (v.pathwayClones = ct[D.A.CONTENT_STEERING_RESPONSE.PATHWAY_CLONES], v.pathwayClones = v.pathwayClones.filter((It) => function(dt) {
                      return dt[D.A.CONTENT_STEERING_RESPONSE.BASE_ID] && dt[D.A.CONTENT_STEERING_RESPONSE.ID] && dt[D.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT] && dt[D.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][D.A.CONTENT_STEERING_RESPONSE.HOST];
                    }(It))), ht());
                  })(N), it.trigger(At.A.CONTENT_STEERING_REQUEST_COMPLETED, { currentSteeringResponseData: v, url: xt }), bt();
                }, error: (N, ct, It, dt) => {
                  (function(nt, ft) {
                    try {
                      switch (_.warn("Error fetching data from content steering server", nt), ft.status) {
                        case 410:
                          break;
                        case 429:
                          const rt = ft && ft.getResponseHeader ? ft.getResponseHeader("retry-after") : null;
                          rt !== null && (v || (v = {}), v.ttl = parseInt(rt)), ht();
                          break;
                        default:
                          ht();
                      }
                    } catch (rt) {
                      _.error(rt);
                    }
                  })(N, dt), bt(N);
                }, complete: () => {
                  M.baseUrl.all = j(M.baseUrl), M.location.all = j(M.location);
                } });
              } catch (Rt) {
                bt(Rt);
              }
            });
          }
          function j(bt) {
            return bt.all && bt.all.length !== 0 && bt.current ? bt.all.filter((Rt) => Rt === bt.current) : [];
          }
          function J(bt) {
            try {
              const Rt = [];
              return bt && bt.length !== 0 && v && v.pathwayClones && v.pathwayClones.length !== 0 && v.pathwayClones.forEach((xt) => {
                let Pt = bt.filter((ct) => xt[D.A.CONTENT_STEERING_RESPONSE.BASE_ID] === ct.serviceLocation), N = null;
                if (Pt && Pt.length > 0 && (N = Pt[0]), N) {
                  const ct = new URL(N.url);
                  let It = xt[D.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][D.A.CONTENT_STEERING_RESPONSE.HOST];
                  It = jn.A.stringHasProtocol(It) ? It : `${ct.protocol}//${It}`;
                  const dt = { synthesizedUrl: `${It}${ct.pathname}`, serviceLocation: xt[D.A.CONTENT_STEERING_RESPONSE.ID], queryParams: xt[D.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][D.A.CONTENT_STEERING_RESPONSE.PARAMS], reference: N };
                  Rt.push(dt);
                }
              }), Rt;
            } catch (Rt) {
              return _.error(Rt), [];
            }
          }
          function ht() {
            v && v.ttl && !isNaN(v.ttl) && (H && clearTimeout(H), H = setTimeout(() => {
              P();
            }, 1e3 * v.ttl));
          }
          function _t() {
            H && clearTimeout(H), H = null;
          }
          function Ct() {
            v = null, Y = {}, M = { baseUrl: { current: null, all: [] }, location: { current: null, all: [] } }, _t();
          }
          return C = { reset: function() {
            Ct(), it.off(At.A.FRAGMENT_LOADING_STARTED, ot, C), it.off(At.A.MANIFEST_LOADING_STARTED, ut, C), it.off(At.A.THROUGHPUT_MEASUREMENT_STORED, mt, C);
          }, setConfig: function(bt) {
            bt && (bt.adapter && (st = bt.adapter), bt.errHandler && (W = bt.errHandler), bt.dashMetrics && (K = bt.dashMetrics), bt.mediaPlayerModel && (R = bt.mediaPlayerModel), bt.manifestModel && (G = bt.manifestModel), bt.serviceDescriptionController && (F = bt.serviceDescriptionController), bt.throughputController && (et = bt.throughputController), bt.eventBus && (it = bt.eventBus));
          }, loadSteeringData: P, getCurrentSteeringResponseData: function() {
            return v;
          }, shouldQueryBeforeStart: function() {
            const bt = $();
            return !!bt && bt.queryBeforeStart;
          }, getSteeringDataFromManifest: $, stopSteeringRequestTimer: _t, getSynthesizedBaseUrlElements: function(bt) {
            try {
              return J(bt).map((Rt) => {
                const xt = new ba(Rt.synthesizedUrl, Rt.serviceLocation);
                return xt.queryParams = Rt.queryParams, xt.dvbPriority = Rt.reference.dvbPriority, xt.dvbWeight = Rt.reference.dvbWeight, xt.availabilityTimeOffset = Rt.reference.availabilityTimeOffset, xt.availabilityTimeComplete = Rt.reference.availabilityTimeComplete, xt;
              });
            } catch (Rt) {
              return _.error(Rt), [];
            }
          }, getSynthesizedLocationElements: function(bt) {
            try {
              return J(bt).map((Rt) => {
                const xt = new dn(Rt.synthesizedUrl, Rt.serviceLocation);
                return xt.queryParams = Rt.queryParams, xt;
              });
            } catch (Rt) {
              return _.error(Rt), [];
            }
          }, initialize: function() {
            L = ci(A).create({ errHandler: W, dashMetrics: K, mediaPlayerModel: R, errors: q }), it.on(At.A.FRAGMENT_LOADING_STARTED, ot, C), it.on(At.A.MANIFEST_LOADING_STARTED, ut, C), it.on(At.A.THROUGHPUT_MEASUREMENT_STORED, mt, C);
          } }, _ = (0, jt.A)(A).getInstance().getLogger(C), Ct(), C;
        }
        O.__dashjs_factory_name = "ContentSteeringController";
        var gt = Bt.A.getSingletonFactory(O);
        function St() {
          const A = this.context, f = (0, tt.A)(A).getInstance();
          let C, _, v;
          return C = { select: function(M) {
            if (!M || M.length === 0) return null;
            let Y = null;
            return f.get().streaming.applyContentSteering && (Y = function(H) {
              const L = v.getCurrentSteeringResponseData();
              return L && L.pathwayPriority && L.pathwayPriority.length > 0 ? function() {
                let W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], K = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], R = 0, G = null;
                for (; R < W.length; ) {
                  const F = W[R], et = K.findIndex((it) => it.serviceLocation && it.serviceLocation === F);
                  if (et !== -1 && !_.contains(K[et].serviceLocation)) {
                    G = K[et];
                    break;
                  }
                  R += 1;
                }
                return G;
              }(L.pathwayPriority, H) : null;
            }(M)), Y || (Y = function(H) {
              return H[0];
            }(M)), Y;
          }, setConfig: function(M) {
            M.blacklistController && (_ = M.blacklistController), M.contentSteeringController && (v = M.contentSteeringController);
          }, reset: function() {
            _.reset();
          } }, _ = ql(A).create({ updateEventName: at.A.SERVICE_LOCATION_LOCATION_BLACKLIST_CHANGED, addBlacklistEventName: at.A.SERVICE_LOCATION_LOCATION_BLACKLIST_ADD }), v = gt(A).getInstance(), C;
        }
        St.__dashjs_factory_name = "LocationSelector";
        var Yt = Bt.A.getClassFactory(St);
        function re() {
          const A = this.context, f = (0, Mt.A)(A).getInstance(), C = He(A).getInstance();
          let _, v, M, Y, H, L, W, K, R, G, F, et, it, st;
          function ot() {
            M = NaN, W = !1, H = !0, L = !1, ut();
          }
          function ut() {
            Y !== null && (clearTimeout(Y), Y = null);
          }
          function mt(Ct) {
            ut(), L || (isNaN(Ct) && !isNaN(M) && (Ct = 1e3 * M), isNaN(Ct) || (v.debug("Refresh manifest in " + Ct + " milliseconds."), Y = setTimeout(P, Ct)));
          }
          function wt() {
            let Ct = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            W = !0;
            const bt = R.getValue();
            let Rt = bt.url;
            Rt && (Rt = jn.A.removeQueryParameterFromUrl(Rt, X.A.CMCD_QUERY_KEY));
            let xt = null;
            const Pt = F.getPatchLocation(bt), N = G.select(Pt);
            let ct = null;
            if (N && !Ct) Rt = N.url, xt = N.serviceLocation, ct = N.queryParams;
            else {
              const It = function(nt) {
                const ft = F.getLocation(nt), rt = it.getSynthesizedLocationElements(ft);
                return ft.concat(rt);
              }(bt), dt = G.select(It);
              dt && (Rt = dt.url, xt = dt.serviceLocation, ct = dt.queryParams);
            }
            C.isRelative(Rt) && (Rt = C.resolve(Rt, bt.url)), K.load(Rt, xt, ct);
          }
          function $(Ct) {
            if (Ct) {
              if (F.getIsPatch(Ct)) {
                let xt = Ct;
                Ct = R.getValue();
                let Pt = F.isPatchValid(Ct, xt), N = Pt;
                if (Pt) {
                  let ct = F.getPublishTime(Ct);
                  F.applyPatchToManifest(Ct, xt);
                  let It = F.getPublishTime(Ct);
                  N = ct.getTime() !== It.getTime();
                }
                if (!N) return v.debug("Patch provided is invalid, performing full manifest refresh"), void wt(!0);
                Ct.loadedTime = /* @__PURE__ */ new Date();
              }
            } else (Ct = R.getValue()).loadedTime = /* @__PURE__ */ new Date();
            if (R.getValue() && R.getValue().type === D.A.DYNAMIC && Ct.type === D.A.STATIC) return f.trigger(at.A.DYNAMIC_TO_STATIC), W = !1, void (L = !0);
            R.setValue(Ct);
            const bt = /* @__PURE__ */ new Date(), Rt = (bt.getTime() - Ct.loadedTime.getTime()) / 1e3;
            M = F.getManifestUpdatePeriod(Ct, Rt), 1e3 * M > 2147483647 && (M = 2147483647e-3), f.trigger(at.A.MANIFEST_UPDATED, { manifest: Ct }), v.info("Manifest has been refreshed at " + bt + "[" + bt.getTime() / 1e3 + "] "), H || mt();
          }
          function P() {
            H || (W ? mt(st.get().streaming.manifestUpdateRetryInterval) : wt());
          }
          function j(Ct) {
            Ct.error ? Ct.error.code === q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE && et.error(Ct.error) : $(Ct.manifest);
          }
          function J() {
            H = !1, mt();
          }
          function ht() {
            H = !st.get().streaming.scheduling.scheduleWhilePaused, H && ut();
          }
          function _t() {
            W = !1;
          }
          return _ = { initialize: function() {
            ot(), f.on(at.A.STREAMS_COMPOSED, _t, this), f.on(At.A.PLAYBACK_STARTED, J, this), f.on(At.A.PLAYBACK_PAUSED, ht, this), f.on(at.A.INTERNAL_MANIFEST_LOADED, j, this);
          }, setManifest: function(Ct) {
            $(Ct);
          }, refreshManifest: wt, getIsUpdating: function() {
            return W;
          }, setConfig: function(Ct) {
            Ct && (Ct.manifestModel && (R = Ct.manifestModel), Ct.adapter && (F = Ct.adapter), Ct.manifestLoader && (K = Ct.manifestLoader), Ct.errHandler && (et = Ct.errHandler), Ct.locationSelector && (G = Ct.locationSelector), Ct.settings && (st = Ct.settings), Ct.contentSteeringController && (it = Ct.contentSteeringController));
          }, reset: function() {
            f.off(At.A.PLAYBACK_STARTED, J, this), f.off(At.A.PLAYBACK_PAUSED, ht, this), f.off(at.A.STREAMS_COMPOSED, _t, this), f.off(at.A.INTERNAL_MANIFEST_LOADED, j, this), ot();
          } }, v = (0, jt.A)(A).getInstance().getLogger(_), G = Yt(A).create(), _;
        }
        re.__dashjs_factory_name = "ManifestUpdater";
        var fe = Bt.A.getClassFactory(re);
        function je() {
          const A = this.context, f = (0, Mt.A)(A).getInstance(), C = He(A).getInstance();
          let _, v, M, Y, H, L, W, K, R, G, F, et, it, st, ot, ut;
          function mt() {
            K = [], R = [], G = null, F = null, it = null, et = NaN, M = !1, Y = !1, st = H.get().streaming.utcSynchronization.timeBetweenSyncAttempts;
          }
          function wt() {
            H.get().streaming.utcSynchronization.enabled && !M && !Y && it && it.value && it.schemeIdUri && !isNaN(et) && !isNaN(H.get().streaming.utcSynchronization.backgroundAttempts) && (F && (Date.now() - F) / 1e3 < 30 || (K = [], Y = !0, $(isNaN(H.get().streaming.utcSynchronization.backgroundAttempts) ? 2 : H.get().streaming.utcSynchronization.backgroundAttempts)));
          }
          function $(dt) {
            try {
              if (dt <= 0) return void ct();
              const nt = Date.now();
              L[it.schemeIdUri](it.value, function(ft) {
                const rt = Date.now(), Et = j(nt, rt, ft);
                K.push(Et), $(dt - 1);
              }, function() {
                ct();
              });
            } catch (nt) {
              ct();
            }
          }
          function P() {
            let dt = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || 0;
            if (!R || R.length === 0 || dt >= R.length) return void J();
            let nt = R[dt];
            if (nt) if (L.hasOwnProperty(nt.schemeIdUri)) {
              const ft = (/* @__PURE__ */ new Date()).getTime();
              L[nt.schemeIdUri](nt.value, function(rt) {
                const Et = (/* @__PURE__ */ new Date()).getTime(), kt = j(ft, Et, rt);
                it = nt, J(kt);
              }, function() {
                P(dt + 1);
              });
            } else P(dt + 1);
            else J();
          }
          function j(dt, nt, ft) {
            return ft - (nt - (nt - dt) / 2);
          }
          function J() {
            let dt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN, nt = isNaN(dt);
            nt && H.get().streaming.utcSynchronization.useManifestDateHeaderTimeSource ? function() {
              let ft = W.getLatestMPDRequestHeaderValueByID("Date"), rt = ft !== null ? new Date(ft).getTime() : Number.NaN;
              isNaN(rt) ? N(!0) : N(!1, rt - Date.now());
            }() : N(nt, dt);
          }
          function ht(dt) {
            let nt = Date.parse(dt);
            return isNaN(nt) && (nt = function(ft) {
              let rt, Et, kt = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+\-])([0-9]{2})([0-9]{2}))?/.exec(ft);
              return rt = Date.UTC(parseInt(kt[1], 10), parseInt(kt[2], 10) - 1, parseInt(kt[3], 10), parseInt(kt[4], 10), parseInt(kt[5], 10), kt[6] && (parseInt(kt[6], 10) || 0), kt[7] && 1e3 * parseFloat(kt[7]) || 0), kt[9] && kt[10] && (Et = 60 * parseInt(kt[9], 10) + parseInt(kt[10], 10), rt += (kt[8] === "+" ? -1 : 1) * Et * 60 * 1e3), new Date(rt).getTime();
            }(dt)), nt;
          }
          function _t(dt) {
            return Date.parse(dt);
          }
          function Ct(dt) {
            return Date.parse(dt);
          }
          function bt(dt, nt, ft) {
            ft();
          }
          function Rt(dt, nt, ft) {
            let rt = ht(dt);
            isNaN(rt) ? ft() : nt(rt);
          }
          function xt(dt, nt, ft, rt, Et) {
            let kt, Dt, Ut = !1, Wt = new XMLHttpRequest(), ie = Et ? Ht.G.HEAD : Ht.G.GET, de = nt.match(/\S+/g);
            if (nt = de.shift(), kt = function() {
              Ut || (Ut = !0, de.length ? xt(dt, de.join(" "), ft, rt, Et) : rt());
            }, Dt = function() {
              let Be, Oe;
              Wt.status === 200 && (Be = Et ? Wt.getResponseHeader("Date") : Wt.response, Oe = dt(Be), isNaN(Oe) || (ft(Oe), Ut = !0));
            }, C.isRelative(nt)) {
              const Be = ut.resolve();
              Be && (nt = C.resolve(nt, Be.url));
            }
            Wt.open(ie, nt), Wt.timeout = 5e3, Wt.onload = Dt, Wt.onloadend = kt, Wt.send();
          }
          function Pt(dt, nt, ft) {
            xt(Ct, dt, nt, ft, !0);
          }
          function N(dt, nt) {
            if (isNaN(et) || isNaN(nt) || dt || function(ft) {
              try {
                const rt = It(ft), Et = isNaN(st) ? 30 : st, kt = isNaN(H.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? 2 : H.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor, Dt = isNaN(H.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? 600 : H.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts, Ut = isNaN(H.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? 2 : H.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts;
                let Wt;
                rt ? (Wt = Math.min(Et * kt, Dt), v.debug(`Increasing timeBetweenSyncAttempts to ${Wt}`)) : (Wt = Math.max(Et / kt, Ut), v.debug(`Decreasing timeBetweenSyncAttempts to ${Wt}`)), st = Wt;
              } catch (rt) {
              }
            }(nt), !dt && !isNaN(nt)) {
              G = Date.now(), M = !1;
              const ft = isNaN(et);
              et = nt, ft && wt(), v.debug(`Completed UTC sync. Setting client - server offset to ${nt}`);
            }
            dt && (it = null, M = !1, ot.error(new Nt.A(q.TIME_SYNC_FAILED_ERROR_CODE, q.TIME_SYNC_FAILED_ERROR_MESSAGE))), f.trigger(at.A.UPDATE_TIME_SYNC_OFFSET, { offset: nt }), f.trigger(at.A.TIME_SYNCHRONIZATION_COMPLETED);
          }
          function ct() {
            if (!K || K.length === 0) return;
            const dt = K.reduce((nt, ft) => nt + ft, 0) / K.length;
            It(dt) ? v.debug("Completed background UTC sync. Offset is within allowed threshold and is not adjusted.") : (v.debug(`Completed background UTC sync. Setting client - server offset to ${dt}`), et = dt, f.trigger(at.A.UPDATE_TIME_SYNC_OFFSET, { offset: et })), Y = !1, F = Date.now();
          }
          function It(dt) {
            try {
              if (isNaN(et)) return !0;
              const nt = H.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(H.get().streaming.utcSynchronization.maximumAllowedDrift) ? H.get().streaming.utcSynchronization.maximumAllowedDrift : 100;
              return dt >= et - nt && dt <= et + nt;
            } catch (nt) {
              return !0;
            }
          }
          return _ = { initialize: function() {
            mt(), L = { "urn:mpeg:dash:utc:http-head:2014": Pt, "urn:mpeg:dash:utc:http-xsdate:2014": xt.bind(null, ht), "urn:mpeg:dash:utc:http-iso:2014": xt.bind(null, _t), "urn:mpeg:dash:utc:direct:2014": Rt, "urn:mpeg:dash:utc:http-head:2012": Pt, "urn:mpeg:dash:utc:http-xsdate:2012": xt.bind(null, ht), "urn:mpeg:dash:utc:http-iso:2012": xt.bind(null, _t), "urn:mpeg:dash:utc:direct:2012": Rt, "urn:mpeg:dash:utc:http-ntp:2014": bt, "urn:mpeg:dash:utc:ntp:2014": bt, "urn:mpeg:dash:utc:sntp:2014": bt };
          }, attemptSync: function(dt, nt) {
            R = dt, M || (function(ft) {
              try {
                if (!ft || !H.get().streaming.utcSynchronization.enabled) return !1;
                const rt = isNaN(st) ? 30 : st;
                return !(G && rt && !isNaN(rt)) || (Date.now() - G) / 1e3 >= rt;
              } catch (rt) {
                return !0;
              }
            }(nt) ? (M = !0, P()) : f.trigger(at.A.TIME_SYNCHRONIZATION_COMPLETED));
          }, setConfig: function(dt) {
            dt && (dt.dashMetrics && (W = dt.dashMetrics), dt.baseURLController && (ut = dt.baseURLController), dt.errHandler && (ot = dt.errHandler), dt.settings && (H = dt.settings));
          }, reset: function() {
            mt(), f.off(at.A.ATTEMPT_BACKGROUND_SYNC, wt, _);
          } }, v = (0, jt.A)(A).getInstance().getLogger(_), f.on(at.A.ATTEMPT_BACKGROUND_SYNC, wt, _), _;
        }
        je.__dashjs_factory_name = "TimeSyncController";
        const De = Bt.A.getSingletonFactory(je);
        De.HTTP_TIMEOUT_MS = 5e3, Bt.A.updateSingletonFactory(je.__dashjs_factory_name, De);
        var bn = De;
        function Un() {
          let A, f, C, _, v;
          const M = this.context, Y = (0, Mt.A)(M).getInstance();
          return A = { attachMediaSource: function(H) {
            let L = window.URL.createObjectURL(f);
            return H.setSource(L), _ === "managedMediaSource" && (H.setDisableRemotePlayback(!0), f.addEventListener("startstreaming", () => {
              Y.trigger(At.A.MANAGED_MEDIA_SOURCE_START_STREAMING);
            }), f.addEventListener("endstreaming", () => {
              Y.trigger(At.A.MANAGED_MEDIA_SOURCE_END_STREAMING);
            })), L;
          }, createMediaSource: function() {
            let H = "WebKitMediaSource" in window, L = "MediaSource" in window;
            return "ManagedMediaSource" in window ? (f = new ManagedMediaSource(), _ = "managedMediaSource", v.info("Created ManagedMediaSource")) : L ? (f = new MediaSource(), _ = "mediaSource", v.info("Created MediaSource")) : H && (f = new WebKitMediaSource(), v.info("Created WebkitMediaSource")), f;
          }, detachMediaSource: function(H) {
            H.setSource(null);
          }, setConfig: function(H) {
            H && H.settings && (C = H.settings);
          }, setDuration: function H(L) {
            f && f.readyState === "open" && (L === null && isNaN(L) || f.duration !== L && (L !== 1 / 0 || C.get().streaming.buffer.mediaSourceDurationInfinity || (L = Math.pow(2, 32)), function(W) {
              let K = W.sourceBuffers;
              for (let R = 0; R < K.length; R++) if (K[R].updating) return !0;
              return !1;
            }(f) ? setTimeout(H.bind(null, L), 50) : (v.info("Set MediaSource duration:" + L), f.duration = L)));
          }, setSeekable: function(H, L) {
            f && typeof f.setLiveSeekableRange == "function" && typeof f.clearLiveSeekableRange == "function" && f.readyState === "open" && H >= 0 && H < L && (f.clearLiveSeekableRange(), f.setLiveSeekableRange(H, L));
          }, signalEndOfStream: function(H) {
            if (!H || H.readyState !== "open") return;
            let L = H.sourceBuffers;
            for (let W = 0; W < L.length; W++)
              if (L[W].updating || L[W].buffered.length === 0) return;
            v.info("call to mediaSource endOfStream"), H.endOfStream();
          } }, v = (0, jt.A)(M).getInstance().getLogger(A), A;
        }
        Un.__dashjs_factory_name = "MediaSourceController";
        var Kn = Bt.A.getSingletonFactory(Un);
        function ga() {
          const A = "urn:mpeg:dash:event:2012", C = "urn:mpeg:dash:event:callback:2015", M = "discarded", Y = "updated", H = "added", L = this.context, W = (0, Mt.A)(L).getInstance();
          let K, R, G, F, et, it, st, ot, ut, mt, wt;
          function $() {
            if (!st || !ot) throw new Error("setConfig function has to be called previously");
          }
          function P() {
            wt = !1, G = {}, F = {}, et = null, mt = !1, it = Date.now() / 1e3;
          }
          function j() {
            try {
              if (!mt) {
                mt = !0;
                const N = ot.getTime();
                let ct = N - it;
                ct = it > 0 ? Math.max(0, ct) : 0, J(F, ct, N), J(G, ct, N), ht(F), ht(G), it = N, mt = !1;
              }
            } catch (N) {
              mt = !1, R.error(N);
            }
          }
          function J(N, ct, It) {
            try {
              Rt(N, function(nt) {
                if (nt !== void 0) {
                  const ft = isNaN(nt.duration) ? 0 : nt.duration;
                  nt.calculatedPresentationTime <= It && nt.calculatedPresentationTime + ct + ft >= It ? Pt(nt, At.A.EVENT_MODE_ON_START) : (xt(It, ft + ct, nt.calculatedPresentationTime) || function(rt) {
                    try {
                      const Et = rt.eventStream.period.start + rt.eventStream.period.duration;
                      return rt.calculatedPresentationTime > Et;
                    } catch (Et) {
                      return R.error(Et), !1;
                    }
                  }(nt)) && (R.debug(`Removing event ${nt.id} from period ${nt.eventStream.period.id} as it is expired or invalid`), function(rt, Et) {
                    try {
                      const kt = Et.eventStream.schemeIdUri, Dt = Et.eventStream.period.id, Ut = Et.eventStream.value, Wt = Et.id;
                      rt[Dt][kt] = rt[Dt][kt].filter((ie) => Ut && ie.eventStream.value && ie.eventStream.value !== Ut || ie.id !== Wt), rt[Dt][kt].length === 0 && delete rt[Dt][kt];
                    } catch (kt) {
                      R.error(kt);
                    }
                  }(N, nt));
                }
              });
            } catch (dt) {
              R.error(dt);
            }
          }
          function ht(N) {
            try {
              for (const ct in N) N.hasOwnProperty(ct) && Object.keys(N[ct]).length === 0 && delete N[ct];
            } catch (ct) {
              R.error(ct);
            }
          }
          function _t(N, ct) {
            let It = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const dt = N.eventStream.schemeIdUri, nt = N.eventStream.value, ft = N.id;
            let rt = M;
            ct[dt] || (ct[dt] = []);
            const Et = ct[dt].findIndex((kt) => (!nt || kt.eventStream.value && kt.eventStream.value === nt) && kt.id === ft);
            if (Et === -1) ct[dt].push(N), N.triggeredReceivedEvent = !1, N.triggeredStartEvent = !1, rt = H;
            else if (It) {
              const kt = ct[dt][Et];
              N.triggeredReceivedEvent = kt.triggeredReceivedEvent, N.triggeredStartEvent = kt.triggeredStartEvent, ct[dt][Et] = N, rt = Y;
            }
            return rt;
          }
          function Ct(N) {
            try {
              if (N.eventStream.value == 1) {
                const ct = N.calculatedPresentationTime;
                let It;
                It = N.calculatedPresentationTime == 4294967295 ? NaN : N.calculatedPresentationTime + N.duration, W.trigger(At.A.MANIFEST_VALIDITY_CHANGED, { id: N.id, validUntil: ct, newDuration: It, newManifestValidAfter: NaN }, { mode: At.A.EVENT_MODE_ON_START });
              }
            } catch (ct) {
              R.error(ct);
            }
          }
          function bt(N) {
            try {
              const ct = ot.getTime();
              Rt(N, function(It) {
                const dt = It.eventStream && It.eventStream.period && !isNaN(It.eventStream.period.duration) ? It.eventStream.period.duration : NaN, nt = It.eventStream && It.eventStream.period && !isNaN(It.eventStream.period.start) ? It.eventStream.period.start : NaN;
                if (isNaN(dt) || isNaN(nt)) return;
                const ft = It.calculatedPresentationTime;
                Math.abs(ft - ct) < 300 && Pt(It, At.A.EVENT_MODE_ON_START);
              });
            } catch (ct) {
              R.error(ct);
            }
          }
          function Rt(N, ct) {
            try {
              if (N) {
                const It = Object.keys(N);
                for (let dt = 0; dt < It.length; dt++) {
                  const nt = N[It[dt]], ft = Object.keys(nt);
                  for (let rt = 0; rt < ft.length; rt++) nt[ft[rt]].forEach((Et) => {
                    Et !== void 0 && ct(Et);
                  });
                }
              }
            } catch (It) {
              R.error(It);
            }
          }
          function xt(N, ct, It) {
            try {
              return N - ct > It;
            } catch (dt) {
              return R.error(dt), !1;
            }
          }
          function Pt(N, ct) {
            try {
              const It = ot.getTime(), dt = N.id;
              if (ct === At.A.EVENT_MODE_ON_RECEIVE && !N.triggeredReceivedEvent) return R.debug(`Received event ${dt}`), N.triggeredReceivedEvent = !0, void W.trigger(N.eventStream.schemeIdUri, { event: N }, { mode: ct });
              N.triggeredStartEvent || (N.eventStream.schemeIdUri === A && N.eventStream.value == 1 ? N.duration === 0 && N.presentationTimeDelta === 0 || (R.debug(`Starting manifest refresh event ${dt} at ${It}`), function() {
                try {
                  $(), st.refreshManifest();
                } catch (nt) {
                  R.error(nt);
                }
              }()) : N.eventStream.schemeIdUri === C && N.eventStream.value == 1 ? (R.debug(`Starting callback event ${dt} at ${It}`), function(nt) {
                try {
                  let ft = va(L).create({});
                  const rt = new Uo({ method: "get", url: nt, responseType: "arraybuffer", customData: {} }), Et = new uo({ request: rt });
                  ft.load(rt, Et);
                } catch (ft) {
                  R.error(ft);
                }
              }(N.messageData instanceof Uint8Array ? jn.A.uint8ArrayToString(N.messageData) : N.messageData)) : (R.debug(`Starting event ${dt} from period ${N.eventStream.period.id} at ${It}`), W.trigger(N.eventStream.schemeIdUri, { event: N }, { mode: ct }), ut.get().streaming.events.deleteEventMessageDataTimeout > -1 && setTimeout(() => {
                delete N.messageData, delete N.parsedMessageData;
              }, ut.get().streaming.events.deleteEventMessageDataTimeout)), N.triggeredStartEvent = !0);
            } catch (It) {
              R.error(It);
            }
          }
          return K = { addInlineEvents: function(N, ct) {
            try {
              if ($(), G[ct] || (G[ct] = {}), N) for (let It = 0; It < N.length; It++) {
                let dt = N[It];
                if (!xt(ot.getTime(), isNaN(dt.duration) ? 0 : dt.duration, dt.calculatedPresentationTime)) {
                  let nt = _t(dt, G[ct], !0);
                  nt === H ? (R.debug(`Added inline event with id ${dt.id} from period ${ct}`), Pt(dt, At.A.EVENT_MODE_ON_RECEIVE)) : nt === Y && R.debug(`Updated inline event with id ${dt.id} from period ${ct}`);
                }
              }
            } catch (It) {
              throw It;
            }
          }, addInbandEvents: function(N, ct) {
            try {
              $(), F[ct] || (F[ct] = {});
              for (let It = 0; It < N.length; It++) {
                let dt = N[It];
                xt(ot.getTime(), isNaN(dt.duration) ? 0 : dt.duration, dt.calculatedPresentationTime) || (_t(dt, F[ct], !1) === H ? (dt.eventStream.schemeIdUri === A && Ct(dt), R.debug(`Added inband event with id ${dt.id} from period ${ct}`), Pt(dt, At.A.EVENT_MODE_ON_RECEIVE)) : R.debug(`Inband event with scheme_id_uri ${dt.eventStream.schemeIdUri}, value ${dt.eventStream.value}, period id ${ct} and event id ${dt.id} was ignored because it has been added before.`));
              }
              j();
            } catch (It) {
              throw It;
            }
          }, getInbandEvents: function() {
            return F;
          }, getInlineEvents: function() {
            return G;
          }, start: function() {
            try {
              $(), R.debug("Start Event Controller");
              const N = ut.get().streaming.events.eventControllerRefreshDelay;
              wt || isNaN(N) || (wt = !0, et = setInterval(j, N));
            } catch (N) {
              throw N;
            }
          }, setConfig: function(N) {
            try {
              if (!N) return;
              N.manifestUpdater && (st = N.manifestUpdater), N.playbackController && (ot = N.playbackController), N.settings && (ut = N.settings);
            } catch (ct) {
              throw ct;
            }
          }, reset: function() {
            (function() {
              try {
                et !== null && wt && (clearInterval(et), et = null, wt = !1, function() {
                  try {
                    bt(F), bt(G);
                  } catch (N) {
                    R.error(N);
                  }
                }());
              } catch (N) {
                throw N;
              }
            })(), P();
          } }, R = (0, jt.A)(L).getInstance().getLogger(K), P(), K;
        }
        ga.__dashjs_factory_name = "EventController";
        var Ea = Bt.A.getSingletonFactory(ga), Na = { LEVELS: { SUGGESTION: "Suggestion", WARNING: "Warning", ERROR: "Error" }, EVENTS: { NO_UTC_TIMING_ELEMENT: { key: "NO_UTC_TIMING_ELEMENT", message: "No UTCTiming element is present in the manifest. You may experience playback failures. For a detailed validation use https://conformance.dashif.org/" }, NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE: { key: "NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE", message: 'SMPTE 2052-1:2013 defines the attribute name as "imageType" and does not define "imagetype"' }, INVALID_DVR_WINDOW: { key: "INVALID_DVR_WINDOW", message: "No valid segment found when applying a specification compliant DVR window calculation. Using SegmentTimeline entries as a fallback." } } }, Vi = w(445), xr = w(1923);
        function tu() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht, _t, Ct, bt, Rt, xt, Pt, N, ct, It, dt, nt, ft, rt, Et, kt, Dt, Ut, Wt, ie, de, Be, Oe, nn, _n, ke;
          function rn() {
            if (!(H && H.hasOwnProperty("load") && j && j.hasOwnProperty("initialize") && j.hasOwnProperty("reset") && j.hasOwnProperty("getClientTimeOffset") && L && P && K && nt)) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          function Cn() {
            (function() {
              try {
                const te = W.getStreamsInfo();
                if (!ht && te.length === 0) throw new Error("There are no periods in the MPD");
                ht && te.length > 0 && K.updateManifestUpdateInfo({ currentTime: nt.getTime(), buffered: dt.getBufferRange(), presentationStartTime: te[0].start, clientTimeOffset: j.getClientTimeOffset() }), J.length > 0 && function(cn) {
                  cn.length !== 0 ? J = J.filter((An) => {
                    const Yn = cn.filter((Qn) => Qn.id === An.getId()).length > 0 || An.getId() === ht.getId();
                    return Yn || (_.debug(`Removing stream ${An.getId()}`), An.reset(!0), An = null), Yn;
                  }) : _.warn("No periods included in the current manifest. Skipping the filtering of outdated stream objects.");
                }(te);
                const Ye = [];
                for (let cn = 0, An = te.length; cn < An; cn++) {
                  const Yn = te[cn];
                  Ye.push(Gn(Yn)), K.addManifestUpdateStreamInfo(Yn);
                }
                Promise.all(Ye).then(() => new Promise((cn, An) => {
                  ht ? cn() : Xt(te, cn, An);
                })).then(() => {
                  f.trigger(at.A.STREAMS_COMPOSED), Ve();
                }).catch((cn) => {
                  throw cn;
                });
              } catch (te) {
                P.error(new Nt.A(q.MANIFEST_ERROR_ID_NOSTREAMS_CODE, te.message + " nostreamscomposed", L.getValue())), ct = !0, Nd();
              }
            })();
          }
          function Nn() {
            Oe = !0;
          }
          function Gn(te) {
            let Ye = Di(te.id);
            return Ye ? Ye.updateData(te) : (Ye = Xo(A).create({ manifestModel: L, mediaPlayerModel: rt, dashMetrics: K, manifestUpdater: Y, adapter: W, timelineConverter: j, capabilities: v, capabilitiesFilter: M, errHandler: P, baseURLController: et, segmentBaseController: it, textController: Ct, abrController: ot, playbackController: nt, throughputController: ut, eventController: wt, mediaController: mt, protectionController: _t, videoModel: dt, streamInfo: te, settings: Be }), J.push(Ye), Ye.initialize(), Promise.resolve());
          }
          function Xt(te, Ye, cn) {
            try {
              Je();
              const An = K.getCurrentDVRInfo().range;
              if (An.end < An.start) {
                nn && clearTimeout(nn);
                const Qn = Math.min(1e3 * (-1 * (An.end - An.start) + 2), 2147483647);
                return _.debug(`Waiting for ${Qn} ms before playback can start`), f.trigger(at.A.AST_IN_FUTURE, { delay: Qn }), void (nn = setTimeout(() => {
                  Xt(te, Ye, cn);
                }, Qn));
              }
              Be.get().streaming.applyProducerReferenceTime && ft.calculateProducerReferenceTimeOffsets(te);
              const Yn = te[0].manifestInfo;
              if (Be.get().streaming.applyServiceDescription && ft.applyServiceDescription(Yn), W.getIsDynamic()) {
                const Qn = ws(0, Yn);
                nt.computeAndSetLiveDelay(Qn, Yn);
              }
              (Be.get().streaming.applyContentSteering && F.shouldQueryBeforeStart() ? F.loadSteeringData() : Promise.resolve()).then(() => {
                const Qn = L.getValue();
                Qn && et.update(Qn), ce(), Ye();
              }).catch((Qn) => {
                _.error(Qn), ce(), Ye();
              });
            } catch (An) {
              cn(An);
            }
          }
          function ce() {
            const te = function() {
              let An;
              if (W.getIsDynamic()) {
                const Yn = K.getCurrentDVRInfo();
                An = (Yn && Yn.range ? Yn.range.end : 0) - nt.getOriginalLiveDelay();
                const Qn = Yn ? Yn.range : null;
                if (Qn) {
                  if (isNaN(_n) && _n.toString().indexOf("posix:") === -1) {
                    const Bi = Pa(!0);
                    isNaN(Bi) || (_.info(`Start time from URI parameters: ${Bi}`), An = Math.min(An, Bi));
                  } else {
                    _.info(`Start time provided by the app: ${_n}`);
                    const Bi = sr(!0, _n);
                    isNaN(Bi) || (An = Math.min(An, Bi));
                  }
                  const Ga = Be.get().streaming.timeShiftBuffer.calcFromSegmentTimeline ? 0.1 : 0;
                  An = Math.max(An, Qn.start + Ga);
                }
              } else if (An = Gd()[0].getStreamInfo().start, isNaN(_n)) {
                const Yn = Pa(!1);
                isNaN(Yn) || (_.info(`Start time from URI parameters: ${Yn}`), An = Math.max(An, Yn));
              } else {
                _.info(`Start time provided by the app: ${_n}`);
                const Yn = sr(!1, _n);
                isNaN(Yn) || (An = Math.max(An, Yn));
              }
              return An;
            }();
            let Ye = Se(te);
            const cn = Ye !== null ? Ye : J[0];
            f.trigger(at.A.INITIAL_STREAM_SWITCH, { startTime: te }), oe(cn, null, te), Wt || (Wt = setInterval(function() {
              !Pt && nt.getTimeToStreamEnd() <= 0 && !nt.isSeeking() && f.trigger(at.A.PLAYBACK_ENDED, { isLast: Ts().isLast });
            }, 200));
          }
          function oe(te, Ye, cn) {
            try {
              if (Pt || !te || Ye === te && te.getIsActive()) return;
              Pt = !0, f.trigger(at.A.PERIOD_SWITCH_STARTED, { fromStreamInfo: Ye ? Ye.getStreamInfo() : null, toStreamInfo: te.getStreamInfo() });
              let An = !1, Yn = [];
              ht = te, Ye && (An = tn(te, Ye), Yn = mn(Ye), Ye.deactivate(An)), cn = isNaN(cn) ? !An && Ye ? te.getStreamInfo().start : NaN : cn, _.info(`Switch to stream ${te.getId()}. Seektime is ${cn}, current playback time is ${nt.getTime()}. Seamless period switch is set to ${An}`), de = de.filter((Qn) => Qn.getId() !== ht.getId()), nt.initialize(Ts(), !!Ye), dt.getElement() ? pe({ seekTime: cn, keepBuffers: An, streamActivated: !1, representationsFromPreviousPeriod: Yn }) : en({ seekTime: cn, keepBuffers: An });
            } catch (An) {
              Pt = !1;
            }
          }
          function pe(te) {
            let Ye;
            function cn() {
              if (!It || It.readyState !== "open") return;
              _.debug("MediaSource is open!"), window.URL.revokeObjectURL(Ye), It.removeEventListener("sourceopen", cn), It.removeEventListener("webkitsourceopen", cn), Ia();
              const Yn = K.getCurrentDVRInfo();
              R.setSeekable(Yn.range.start, Yn.range.end), te.streamActivated ? (isNaN(te.seekTime) || nt.seek(te.seekTime, !0, !0), ht.setMediaSource(It).then(() => {
                ht.initializeForTextWithMediaSource(It);
              })) : en(te);
            }
            function An() {
              It.addEventListener("sourceopen", cn, !1), It.addEventListener("webkitsourceopen", cn, !1), Ye = R.attachMediaSource(dt), _.debug("MediaSource attached to element.  Waiting on open...");
            }
            It ? te.keepBuffers ? en(te) : (R.detachMediaSource(dt), An()) : (It = R.createMediaSource(), An());
          }
          function en(te) {
            const Ye = te.representationsFromPreviousPeriod || [];
            ht.activate(It, te.keepBuffers ? ie : void 0, Ye).then((cn) => {
              cn && (ie = cn), isNaN(te.seekTime) || (f.trigger(at.A.SEEK_TARGET, { time: te.seekTime }, { streamId: ht.getId() }), nt.seek(te.seekTime, !1, !0), ht.startScheduleControllers()), Pt = !1, f.trigger(at.A.PERIOD_SWITCH_COMPLETED, { toStreamInfo: Ts() });
            });
          }
          function mn(te) {
            return (te ? te.getStreamProcessors() : []).map((Ye) => Ye.getRepresentation());
          }
          function se(te) {
            const Ye = Se(te.seekTime);
            Ye && Ye !== ht ? Ye && Ye !== ht && (Ke(), function(cn, An) {
              const Yn = cn && !isNaN(cn.seekTime) ? cn.seekTime : NaN, Qn = ht.getStreamProcessors().map((Ga) => Ga.prepareOuterPeriodPlaybackSeeking(cn));
              Promise.all(Qn).then(() => {
                oe(An, ht, Yn);
              }).catch((Ga) => {
                P.error(Ga);
              });
            }(te, Ye)) : (Ke(), function(cn) {
              ht.getStreamProcessors().forEach((An) => An.prepareInnerPeriodPlaybackSeeking(cn)), Ri(be.USER_REQUEST_STOP_REASON);
            }(te)), or(Ae.SEEK_START_REASON);
          }
          function Ke() {
            qe();
          }
          function qe() {
            de && de.length > 0 && (de.forEach((te) => {
              te.deactivate(!0);
            }), de = []);
          }
          function Ze(te) {
            if (te.newMediaInfo.streamInfo.id === ht.getId()) {
              if (qe(), Be.get().streaming.buffer.resetSourceBuffersForTrackSwitch && te.oldMediaInfo && te.oldMediaInfo.codec !== te.newMediaInfo.codec) {
                const Ye = nt.getTime();
                return ht.deactivate(!1), void pe({ seekTime: Ye, keepBuffers: !1, streamActivated: !1 });
              }
              ht.prepareTrackChange(te);
            }
          }
          function tn(te, Ye) {
            try {
              return Be.get().streaming.buffer.reuseExistingSourceBuffers && (v.isProtectionCompatible(Ye.getStreamInfo(), te.getStreamInfo()) || Oe) && v.supportsChangeType() && Be.get().streaming.buffer.useChangeType;
            } catch (cn) {
              return !1;
            }
          }
          function $t(te) {
            let Ye = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (It && !te.getPreloaded() && tn(te, Ye)) {
              const cn = mn(Ye);
              te.startPreloading(It, ie, cn).then(() => {
                de.push(te);
              });
            }
          }
          function Se(te) {
            if (isNaN(te)) return null;
            const Ye = J.length;
            for (let cn = 0; cn < Ye; cn++) {
              const An = J[cn];
              if (te < parseFloat((An.getStartTime() + An.getDuration()).toFixed(5))) return An;
            }
            return null;
          }
          function Je() {
            try {
              const te = W.getIsDynamic(), Ye = W.getStreamsInfo()[0].manifestInfo, cn = nt.getTime(), An = j.calcTimeShiftBufferWindow(J, te), Yn = Bn();
              if (An.start === void 0 || An.end === void 0) return;
              Yn && Yn.length !== 0 ? Yn.forEach((Qn) => {
                K.addDVRInfo(Qn.getType(), cn, Ye, An);
              }) : K.addDVRInfo(X.A.VIDEO, cn, Ye, An);
            } catch (te) {
            }
          }
          function $e(te) {
            if (Dt && xt) {
              const Ye = rt.getInitialBufferLevel(), cn = [X.A.TEXT];
              (isNaN(Ye) || Ye <= nt.getBufferLevel(cn) || W.getIsDynamic() && Ye > nt.getLiveDelay()) && (Dt = !1, or(Ae.INITIAL_PLAYOUT_START_REASON), nt.play());
            }
            te && te.mediaType && K.addBufferLevel(te.mediaType, /* @__PURE__ */ new Date(), 1e3 * te.bufferLevel);
          }
          function ue(te) {
            te.streamInfo.id === ht.getId() && qe(), Di(te.streamInfo.id).prepareQualityChange(te);
          }
          function Tt() {
            if (W.getIsDynamic() && nt.getOriginalLiveDelay() !== 0 && ht) {
              const te = W.getStreamsInfo();
              if (te.length > 0) {
                const Ye = te[0].manifestInfo, cn = ws(0, Ye);
                nt.computeAndSetLiveDelay(cn, Ye);
              }
            }
          }
          function Zt() {
            if (br()) {
              const te = dt.getPlaybackQuality();
              te && K.addDroppedFrames(te);
            }
          }
          function he() {
            _.debug("[onPlaybackStarted]"), !Dt && kt && or(Ae.RESUME_FROM_PAUSE_START_REASON), Dt && (Dt = !1), Ut && (Ut = !1, Be.get().streaming.applyContentSteering && !F.shouldQueryBeforeStart() && F.loadSteeringData()), kt = !1;
          }
          function qt(te) {
            _.debug("[onPlaybackPaused]"), te.ended || (kt = !0, Ri(be.USER_REQUEST_STOP_REASON));
          }
          function Me(te) {
            _.debug(`Stream with id ${te.streamInfo.id} finished buffering`);
            const Ye = te.streamInfo.isLast;
            It && Ye ? (_.info("[onStreamBufferingCompleted] calls signalEndOfStream of mediaSourceController."), R.signalEndOfStream(It)) : Ve();
          }
          function Ve() {
            if (!ht) return;
            if (!ht.getHasFinishedBuffering()) return void ht.checkAndHandleCompletedBuffering();
            const te = function() {
              let cn = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
              try {
                const An = cn || ht || null;
                if (An) {
                  const Yn = An.getStreamInfo();
                  return J.filter(function(Qn) {
                    const Ga = Qn.getStreamInfo();
                    return Ga.start > Yn.start && Yn.id !== Ga.id;
                  });
                }
              } catch (An) {
                return [];
              }
            }(ht);
            let Ye = 0;
            for (; Ye < te.length; ) {
              const cn = te[Ye], An = Ye === 0 ? ht : te[Ye - 1];
              !cn.getPreloaded() && An.getHasFinishedBuffering() && It && $t(cn, An), Ye += 1;
            }
          }
          function fn() {
            Wt && (clearInterval(Wt), Wt = null);
          }
          function Bn() {
            return ht ? ht.getStreamProcessors() : [];
          }
          function Sn(te) {
            if (ht && !ht.getIsEndedEventSignaled()) {
              ht.setIsEndedEventSignaled(!0);
              const Ye = function() {
                const cn = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || ht || null;
                if (!cn) return null;
                const An = cn.getStreamInfo(), Yn = An.start;
                let Qn = 0, Ga = -1, Bi = NaN;
                for (; Qn < J.length; ) {
                  const RI = J[Qn].getStreamInfo(), Fc = RI.start - Yn;
                  Fc > 0 && (isNaN(Bi) || Fc < Bi) && An.id !== RI.id && (Bi = Fc, Ga = Qn), Qn += 1;
                }
                return Ga >= 0 ? J[Ga] : null;
              }();
              Ye ? (_.debug(`StreamController onEnded, found next stream with id ${Ye.getStreamInfo().id}. Switching from ${ht.getStreamInfo().id} to ${Ye.getStreamInfo().id}`), oe(Ye, ht, NaN)) : (_.debug("StreamController no next stream found"), ht.setIsEndedEventSignaled(!1)), Ri(Ye ? be.END_OF_PERIOD_STOP_REASON : be.END_OF_CONTENT_STOP_REASON);
            }
            te && te.isLast && (fn(), F.stopSteeringRequestTimer());
          }
          function Ia(te) {
            const Ye = te || Ts().manifestInfo.duration;
            R.setDuration(Ye);
          }
          function Pa(te) {
            const Ye = st.getURIFragmentData();
            if (!Ye || !Ye.t) return NaN;
            const cn = Gd()[0].getStreamInfo().start;
            return Ye.t = Ye.t.split(",")[0], oi(te, Ye.t, cn);
          }
          function sr(te, Ye) {
            let cn = 0;
            return te || (cn = Gd()[0].getStreamInfo().start), oi(te, Ye, cn);
          }
          function oi(te, Ye, cn) {
            const An = W.getRegularPeriods()[0], Yn = Ye.toString(), Qn = Yn.indexOf("posix:") !== -1 ? Yn.substring(6) === "now" ? Date.now() / 1e3 : parseFloat(Yn.substring(6)) : NaN;
            return te && !isNaN(Qn) ? j.calcPresentationTimeFromWallTime(new Date(1e3 * Qn), An) : parseFloat(Yn) + cn;
          }
          function ws(te, Ye) {
            try {
              let cn = NaN;
              return Ye && !isNaN(Ye.maxFragmentDuration) && isFinite(Ye.maxFragmentDuration) ? Ye.maxFragmentDuration : isFinite(cn) ? cn : NaN;
            } catch (cn) {
              return NaN;
            }
          }
          function mo() {
            const te = L.getValue();
            et.initialize(te);
          }
          function qo(te) {
            if (te.error) ct = !0, Nd();
            else {
              _.info("Manifest updated... updating data system wide.");
              const Ye = te.manifest;
              W.updatePeriods(Ye), M.filterUnsupportedFeatures(Ye).then(() => {
                et.initialize(Ye);
                let cn = W.getUTCTimingSources();
                !W.getIsDynamic() || cn && cn.length !== 0 || f.trigger(At.A.CONFORMANCE_VIOLATION, { level: Na.LEVELS.WARNING, event: Na.EVENTS.NO_UTC_TIMING_ELEMENT });
                let An = W.getIsDynamic() ? cn.concat(Et.getUTCTimingSources()) : cn;
                G.attemptSync(An, W.getIsDynamic()), Rt.createFinalQueryStrings(Ye);
              });
            }
          }
          function br() {
            return !!ht && ht.getHasVideoTrack();
          }
          function vs() {
            return !!ht && ht.getHasAudioTrack();
          }
          function Ri(te, Ye) {
            Ye = Ye || /* @__PURE__ */ new Date(), Bn().forEach((cn) => {
              cn.finalisePlayList(Ye, te);
            }), K.addPlayList();
          }
          function or(te) {
            K.createPlaylistMetrics(1e3 * nt.getTime(), te);
          }
          function Es(te) {
            _t.updateKeyStatusesMap(te), function() {
              const Ye = Bn();
              let cn = !1;
              Ye.forEach((An) => {
                const Yn = An.getMediaInfo();
                !Yn || v.areKeyIdsUsable(Yn) ? Yn && v.areKeyIdsExpired(Yn) && function(Qn) {
                  const Ga = Di(Qn.getStreamId());
                  Ga && Ga.triggerProtectionError({ error: new Nt.A(xr.A.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, xr.A.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE) });
                }(An) : (cn = !0, function(Qn) {
                  const Ga = Qn.getAllMediaInfos().filter((Bi) => v.areKeyIdsUsable(Bi));
                  if (Ga && Ga.length !== 0) mt.setTrack(Ga[0], { replaceBuffer: !0 });
                  else {
                    const Bi = Qn.getType();
                    P.error(new Nt.A(q.NO_SUPPORTED_KEY_IDS, `Type: ${Bi}: ${q.NO_SUPPORTED_KEY_IDS_MESSAGE}`));
                  }
                }(An));
              }), cn && (nt.getTime() === 0 ? f.once(At.A.FRAGMENT_LOADING_COMPLETED, () => {
                Bd();
              }, C) : nt.isProgressing(500).then((An) => {
                An || Bd();
              }));
            }();
          }
          function Bd() {
            const te = nt.getTime();
            nt.seek(te + 0.01, !1, !1);
          }
          function xd(te) {
            if (!te.error) return;
            let Ye;
            switch (te.error.code) {
              case 1:
                Ye = "MEDIA_ERR_ABORTED";
                break;
              case 2:
                Ye = "MEDIA_ERR_NETWORK";
                break;
              case 3:
                Ye = "MEDIA_ERR_DECODE", ke.counts.mediaErrorDecode += 1;
                break;
              case 4:
                Ye = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                break;
              case 5:
                Ye = "MEDIA_ERR_ENCRYPTED";
                break;
              default:
                Ye = "UNKNOWN";
            }
            Ye === "MEDIA_ERR_DECODE" && Be.get().errors.recoverAttempts.mediaErrorDecode >= ke.counts.mediaErrorDecode ? function() {
              _.error("A MEDIA_ERR_DECODE occured: Resetting the MediaSource");
              const cn = nt.getTime();
              ht.deactivate(!1), _.info(`MediaSource has been resetted. Resuming playback from time ${cn}`), pe({ seekTime: cn, keepBuffers: !1, streamActivated: !1 });
            }() : (N = !0, te.error.message && (Ye += " (" + te.error.message + ")"), te.error.msExtendedCode && (Ye += " (0x" + (te.error.msExtendedCode >>> 0).toString(16).toUpperCase() + ")"), _.fatal("Video Element Error: " + Ye), te.error && _.fatal(te.error), P.error(new Nt.A(te.error.code, Ye)), Nd());
          }
          function Ts() {
            return ht ? ht.getStreamInfo() : null;
          }
          function Di(te) {
            for (let Ye = 0, cn = J.length; Ye < cn; Ye++) if (J[Ye].getId() === te) return J[Ye];
            return null;
          }
          function $o(te) {
            isNaN(te.newDuration) || Ia(te.newDuration);
          }
          function iu() {
            J = [], _n = NaN, _t = null, Pt = !1, ht = null, N = !1, ct = !1, Dt = !0, Ut = !0, kt = !1, xt = !0, Wt = null, Oe = !1, de = [], nn = null, ke = { counts: { mediaErrorDecode: 0 } };
          }
          function Nd() {
            rn(), G.reset(), Ri(N || ct ? be.FAILURE_STOP_REASON : be.USER_REQUEST_STOP_REASON);
            for (let te = 0, Ye = J ? J.length : 0; te < Ye; te++) J[te].reset(N);
            f.off(At.A.PLAYBACK_TIME_UPDATED, Zt, C), f.off(At.A.PLAYBACK_SEEKING, se, C), f.off(At.A.PLAYBACK_ERROR, xd, C), f.off(At.A.PLAYBACK_STARTED, he, C), f.off(At.A.PLAYBACK_PAUSED, qt, C), f.off(At.A.PLAYBACK_ENDED, Sn, C), f.off(At.A.METRIC_ADDED, MI, C), f.off(At.A.MANIFEST_VALIDITY_CHANGED, $o, C), f.off(At.A.BUFFER_LEVEL_UPDATED, $e, C), f.off(At.A.QUALITY_CHANGE_REQUESTED, ue, C), f.off(At.A.CONTENT_STEERING_REQUEST_COMPLETED, mo, C), at.A.KEY_SESSION_UPDATED && f.off(at.A.KEY_SESSION_UPDATED, Nn, C), f.off(at.A.MANIFEST_UPDATED, qo, C), f.off(at.A.STREAM_BUFFERING_COMPLETED, Me, C), f.off(at.A.TIME_SYNCHRONIZATION_COMPLETED, Cn, C), f.off(at.A.CURRENT_TRACK_CHANGED, Ze, C), f.off(at.A.SETTING_UPDATED_LIVE_DELAY, Tt, C), f.off(at.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, Tt, C), f.off(Vi.A.INTERNAL_KEY_STATUSES_CHANGED, Es, C), et.reset(), Y.reset(), wt.reset(), K.clearAllCurrentMetrics(), L.setValue(null), H.reset(), j.reset(), $.reset(), It && (R.detachMediaSource(dt), It = null), dt = null, _t && (_t = null, bt = null, L.getValue() && f.trigger(at.A.PROTECTION_DESTROYED, { data: L.getValue().url })), fn(), f.trigger(at.A.STREAM_TEARDOWN_COMPLETE), iu();
          }
          function MI(te) {
            if (te.metric === yt.DVR_INFO) {
              const Ye = vs() ? X.A.AUDIO : X.A.VIDEO;
              te.mediaType === Ye && R.setSeekable(te.value.range.start, te.value.range.end);
            }
          }
          function Gd() {
            return J;
          }
          return C = { addDVRMetric: Je, getActiveStream: function() {
            return ht;
          }, getActiveStreamInfo: Ts, getActiveStreamProcessors: Bn, getAutoPlay: function() {
            return xt;
          }, getHasMediaOrInitialisationError: function() {
            return N || ct;
          }, getInitialPlayback: function() {
            return Dt;
          }, getIsStreamSwitchInProgress: function() {
            return Pt;
          }, getStreamById: Di, getStreamForTime: Se, getStreams: Gd, getTimeRelativeToStreamId: function(te, Ye) {
            let cn = null, An = 0, Yn = 0, Qn = null;
            for (let Ga = 0; Ga < J.length; Ga++) {
              if (cn = J[Ga], Yn = cn.getStartTime(), Qn = cn.getDuration(), Number.isFinite(Yn) && (An = Yn), cn.getId() === Ye) return te - An;
              Number.isFinite(Qn) && (An += Qn);
            }
            return null;
          }, hasAudioTrack: vs, hasVideoTrack: br, initialize: function(te, Ye) {
            rn(), xt = te, bt = Ye, j.initialize(), Y = fe(A).create(), Y.setConfig({ manifestModel: L, adapter: W, manifestLoader: H, errHandler: P, settings: Be, contentSteeringController: F }), Y.initialize(), wt = Ea(A).getInstance(), wt.setConfig({ manifestUpdater: Y, playbackController: nt, settings: Be }), wt.start(), Rt = lo(A).getInstance(), G.setConfig({ dashMetrics: K, baseURLController: et, errHandler: P, settings: Be }), G.initialize(), R.setConfig({ settings: Be }), _t && (f.trigger(at.A.PROTECTION_CREATED, { controller: _t }), _t.setMediaElement(dt.getElement()), bt && _t.setProtectionData(bt)), f.on(At.A.PLAYBACK_TIME_UPDATED, Zt, C), f.on(At.A.PLAYBACK_SEEKING, se, C), f.on(At.A.PLAYBACK_ERROR, xd, C), f.on(At.A.PLAYBACK_STARTED, he, C), f.on(At.A.PLAYBACK_PAUSED, qt, C), f.on(At.A.PLAYBACK_ENDED, Sn, C), f.on(At.A.METRIC_ADDED, MI, C), f.on(At.A.MANIFEST_VALIDITY_CHANGED, $o, C), f.on(At.A.BUFFER_LEVEL_UPDATED, $e, C), f.on(At.A.QUALITY_CHANGE_REQUESTED, ue, C), f.on(At.A.CONTENT_STEERING_REQUEST_COMPLETED, mo, C), at.A.KEY_SESSION_UPDATED && f.on(at.A.KEY_SESSION_UPDATED, Nn, C), f.on(at.A.MANIFEST_UPDATED, qo, C), f.on(at.A.STREAM_BUFFERING_COMPLETED, Me, C), f.on(at.A.TIME_SYNCHRONIZATION_COMPLETED, Cn, C), f.on(at.A.CURRENT_TRACK_CHANGED, Ze, C), f.on(at.A.SETTING_UPDATED_LIVE_DELAY, Tt, C), f.on(at.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, Tt, C), f.on(Vi.A.INTERNAL_KEY_STATUSES_CHANGED, Es, C);
          }, load: function(te) {
            let Ye = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            rn(), _n = Ye, H.load(te);
          }, loadWithManifest: function(te) {
            let Ye = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            (function() {
              if (!Y || !Y.hasOwnProperty("setManifest")) throw new Error("initialize function has to be called previously");
            })(), _n = Ye, Y.setManifest(te);
          }, refreshManifest: function() {
            Y.getIsUpdating() || Y.refreshManifest();
          }, reset: Nd, setConfig: function(te) {
            te && (te.capabilities && (v = te.capabilities), te.capabilitiesFilter && (M = te.capabilitiesFilter), te.manifestLoader && (H = te.manifestLoader), te.manifestModel && (L = te.manifestModel), te.mediaPlayerModel && (rt = te.mediaPlayerModel), te.customParametersModel && (Et = te.customParametersModel), te.protectionController && (_t = te.protectionController), te.adapter && (W = te.adapter), te.dashMetrics && (K = te.dashMetrics), te.errHandler && (P = te.errHandler), te.timelineConverter && (j = te.timelineConverter), te.videoModel && (dt = te.videoModel), te.playbackController && (nt = te.playbackController), te.throughputController && (ut = te.throughputController), te.serviceDescriptionController && (ft = te.serviceDescriptionController), te.contentSteeringController && (F = te.contentSteeringController), te.textController && (Ct = te.textController), te.abrController && (ot = te.abrController), te.mediaController && (mt = te.mediaController), te.settings && (Be = te.settings), te.baseURLController && (et = te.baseURLController), te.uriFragmentModel && (st = te.uriFragmentModel), te.segmentBaseController && (it = te.segmentBaseController), te.manifestUpdater && (Y = te.manifestUpdater));
          }, setProtectionData: function(te) {
            bt = te, _t && _t.setProtectionData(bt);
          }, switchToVideoElement: function(te) {
            ht && (nt.initialize(Ts()), pe({ seekTime: te, keepBuffers: !1, streamActivated: !0 }));
          } }, _ = (0, jt.A)(A).getInstance().getLogger(C), G = bn(A).getInstance(), R = Kn(A).getInstance(), $ = ee(A).getInstance(), iu(), C;
        }
        tu.__dashjs_factory_name = "StreamController";
        var Nr = Bt.A.getSingletonFactory(tu);
        function $h() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R, G, F;
          function et() {
            F.debug("Stopping the gap controller"), Y && (clearInterval(Y), Y = null), function() {
              f.off(at.A.WALLCLOCK_TIME_UPDATED, mt, this), f.off(at.A.INITIAL_STREAM_SWITCH, ut, this), f.off(at.A.PLAYBACK_SEEKING, it, this), f.off(at.A.BUFFER_REPLACEMENT_STARTED, st, C), f.off(at.A.TRACK_CHANGE_RENDERED, ot, C);
            }(), Y = null, H = NaN, M = 0, R = null, G = {};
          }
          function it() {
            R && (clearTimeout(R), R = null);
          }
          function st(P) {
            try {
              if (P.streamId !== W.getActiveStreamInfo().id || P.mediaType !== X.A.VIDEO && P.mediaType !== X.A.AUDIO && P.mediaType !== X.A.MESH) return;
              P.streamId === W.getActiveStreamInfo().id && (G[P.mediaType] = !0);
            } catch (j) {
              F.error(j);
            }
          }
          function ot(P) {
            P && P.mediaType && (G[P.mediaType] = !1);
          }
          function ut() {
            Y || function() {
              try {
                Y || (F.debug("Starting the gap controller"), Y = setInterval(() => {
                  wt() && $(L.getTime());
                }, 100));
              } catch (P) {
              }
            }();
          }
          function mt() {
            if (wt(v.get().streaming.gaps.enableSeekFix) && (M++, M >= 10)) {
              const P = L.getTime();
              _ === P ? $(P, !0) : (_ = P, H = NaN), M = 0;
            }
          }
          function wt() {
            let P = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            if (!W.getActiveStream()) return !1;
            const j = Object.keys(G).some((ht) => G[ht]), J = !!P && function() {
              const ht = W.getActiveStream(), _t = parseFloat((ht.getStartTime() + ht.getDuration()).toFixed(5));
              return L.getTime() + v.get().streaming.gaps.threshold >= _t;
            }();
            return !j && v.get().streaming.gaps.jumpGaps && W.getActiveStreamProcessors().length > 0 && (!L.isSeeking() || J) && !L.isPaused() && !W.getIsStreamSwitchInProgress() && !W.getHasMediaOrInitialisationError();
          }
          function $(P) {
            let j = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            const J = v.get().streaming.gaps.enableStallFix, ht = v.get().streaming.gaps.stallSeek, _t = v.get().streaming.gaps.smallGapLimit, Ct = v.get().streaming.gaps.jumpLargeGaps, bt = K.getBufferRange();
            let Rt, xt = NaN, Pt = !1;
            if (Rt = function(ct, It) {
              try {
                if (!ct || ct.length <= 1 && It > 0) return NaN;
                let dt = NaN, nt = 0;
                for (; isNaN(dt) && nt < ct.length; ) {
                  const ft = nt > 0 ? ct.end(nt - 1) : 0;
                  It < ct.start(nt) && ft - It < v.get().streaming.gaps.threshold && (dt = nt), nt += 1;
                }
                return dt;
              } catch (dt) {
                return null;
              }
            }(bt, P), !isNaN(Rt)) {
              const ct = bt.start(Rt), It = ct - P;
              It > 0 && (It <= _t || Ct) && (xt = ct);
            }
            const N = L.getTimeToStreamEnd();
            if (isNaN(xt) && j && isFinite(N) && !isNaN(N) && N < _t && (xt = parseFloat(L.getStreamEndTime().toFixed(5)), Pt = !0), J && isNaN(xt) && j && isNaN(Rt) && function(ct, It) {
              for (let dt = 0, nt = ct.length; dt < nt; dt++) if (It >= ct.start(dt) && It <= ct.end(dt)) return !0;
              return !1;
            }(bt, P) && (ht === 0 ? (F.warn("Toggle play pause to break stall"), K.pause(), K.play()) : (F.warn(`Jumping ${ht}s to break stall`), xt = P + ht)), xt > 0 && H !== xt && xt > P && !R) {
              const ct = xt - P;
              if (Pt) {
                const It = W.getStreamForTime(xt), dt = It && !!It.getPreloaded();
                F.warn(`Jumping to end of stream because of gap from ${P} to ${xt}. Gap duration: ${ct}`), L.seek(xt, !0, dt);
              } else {
                const It = L.getIsDynamic(), dt = Rt > 0 ? bt.end(Rt - 1) : P, nt = It ? 1e3 * Math.max(0, ct - 0.1) : 0;
                R = window.setTimeout(() => {
                  L.seek(xt, !0, !0), F.warn(`Jumping gap occuring in period ${W.getActiveStream().getStreamId()} starting at ${dt} and ending at ${xt}. Jumping by: ${xt - dt}`), R = null;
                }, nt);
              }
              H = xt;
            }
          }
          return C = { reset: et, setConfig: function(P) {
            P && (P.settings && (v = P.settings), P.playbackController && (L = P.playbackController), P.streamController && (W = P.streamController), P.videoModel && (K = P.videoModel));
          }, initialize: function() {
            (function() {
              f.on(at.A.WALLCLOCK_TIME_UPDATED, mt, this), f.on(at.A.INITIAL_STREAM_SWITCH, ut, this), f.on(at.A.PLAYBACK_SEEKING, it, this), f.on(at.A.BUFFER_REPLACEMENT_STARTED, st, C), f.on(at.A.TRACK_CHANGE_RENDERED, ot, C);
            })();
          } }, F = (0, jt.A)(A).getInstance().getLogger(C), et(), C;
        }
        $h.__dashjs_factory_name = "GapController";
        var H0 = Bt.A.getSingletonFactory($h);
        function tp() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R;
          function G() {
            _ = !1;
            const $ = jn.A.parseUserAgent();
            v = $ && $.browser && $.browser.name && $.browser.name.toLowerCase() === "safari";
          }
          function F() {
            _ = !1;
          }
          function et($) {
            if ($.streamId !== H.getActiveStreamInfo().id || !K) return;
            const P = L.getLiveDelay();
            L.getBufferLevel() > P / 2 && (K = !1);
          }
          function it($) {
            $.streamId === H.getActiveStreamInfo().id && (K = $.state === yt.BUFFER_EMPTY);
          }
          function st() {
            W.getCatchupModeEnabled() || M.setPlaybackRate(1);
          }
          function ot() {
            L.getIsDynamic() && W.getCatchupModeEnabled() && (W.getCatchupPlaybackRates().max > 0 || W.getCatchupPlaybackRates().min < 0) && !L.isPaused() && !L.isSeeking() && function() {
              try {
                return !L.getTime() > 0 || _ ? !1 : mt() === X.A.LIVE_CATCHUP_MODE_LOLP ? function($, P) {
                  try {
                    return Math.abs(ut()) > 0 || $ < P;
                  } catch (j) {
                    return !1;
                  }
                }(L.getBufferLevel(), Y.get().streaming.liveCatchup.playbackBufferMin) : function() {
                  try {
                    return Math.abs(ut()) > 0;
                  } catch ($) {
                    return !1;
                  }
                }();
              } catch ($) {
                return !1;
              }
            }() && function() {
              if (!_ && M) {
                let $;
                const P = M.getPlaybackRate(), j = W.getCatchupPlaybackRates(), J = L.getBufferLevel(), ht = ut(), _t = W.getCatchupMaxDrift();
                if (!isNaN(_t) && _t > 0 && ht > _t) R.info("[CatchupController]: Low Latency catchup mechanism. Latency too high, doing a seek to live point"), _ = !0, L.seekToCurrentLive(!0, !1);
                else {
                  const Ct = L.getCurrentLiveLatency(), bt = L.getLiveDelay();
                  $ = mt() === X.A.LIVE_CATCHUP_MODE_LOLP ? function(xt, Pt, N, ct, It) {
                    let dt;
                    if (It < ct) {
                      const nt = Math.abs(xt.min), ft = 5 * (It - ct);
                      dt = 1 - nt + 2 * nt / (1 + Math.pow(Math.E, -ft)), R.debug("[LoL+ playback control_buffer-based] bufferLevel: " + It + ", newRate: " + dt);
                    } else {
                      if (Math.abs(Pt - N) <= 0.02 * N) dt = 1;
                      else {
                        const ft = Pt - N, rt = ft < 0 ? Math.abs(xt.min) : xt.max, Et = 5 * ft;
                        dt = 1 - rt + 2 * rt / (1 + Math.pow(Math.E, -Et));
                      }
                      R.debug("[LoL+ playback control_latency-based] latency: " + Pt + ", newRate: " + dt);
                    }
                    return dt;
                  }(j, Ct, bt, Y.get().streaming.liveCatchup.playbackBufferMin, J) : function(xt, Pt, N, ct) {
                    if (K) return 1;
                    const It = Pt - N, dt = It < 0 ? Math.abs(xt.min) : xt.max, nt = 5 * It;
                    let ft = 1 - dt + 2 * dt / (1 + Math.pow(Math.E, -nt));
                    return L.getPlaybackStalled() && ct <= N / 2 && It > 0 && (ft = 1), ft;
                  }(j, Ct, bt, J);
                  const Rt = v ? 0.25 : 0.02 / (0.5 / j.max);
                  ($ && Math.abs(P - $) >= Rt || $ == 1) && (R.debug(`[CatchupController]: Setting playback rate to ${$}`), M.setPlaybackRate($));
                }
              }
            }();
          }
          function ut() {
            return L.getCurrentLiveLatency() - L.getLiveDelay();
          }
          function mt() {
            const $ = Y.get().streaming.liveCatchup.playbackBufferMin;
            return Y.get().streaming.liveCatchup.mode !== X.A.LIVE_CATCHUP_MODE_LOLP || $ === null || isNaN($) ? X.A.LIVE_CATCHUP_MODE_DEFAULT : X.A.LIVE_CATCHUP_MODE_LOLP;
          }
          function wt() {
            W.getCatchupPlaybackRates(!0);
          }
          return C = { reset: function() {
            f.off(At.A.BUFFER_LEVEL_UPDATED, et, C), f.off(At.A.BUFFER_LEVEL_STATE_CHANGED, it, C), f.off(At.A.PLAYBACK_PROGRESS, ot, C), f.off(At.A.PLAYBACK_TIME_UPDATED, ot, C), f.off(At.A.PLAYBACK_SEEKED, F, C), f.off(at.A.SETTING_UPDATED_CATCHUP_ENABLED, st, C), f.off(at.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, wt, C), f.off(at.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, wt, C), f.off(At.A.STREAM_INITIALIZED, wt, C), G(), M.setPlaybackRate(1, !0);
          }, setConfig: function($) {
            $ && ($.settings && (Y = $.settings), $.videoModel && (M = $.videoModel), $.streamController && (H = $.streamController), $.playbackController && (L = $.playbackController), $.mediaPlayerModel && (W = $.mediaPlayerModel));
          }, initialize: function() {
            f.on(At.A.BUFFER_LEVEL_UPDATED, et, C), f.on(At.A.BUFFER_LEVEL_STATE_CHANGED, it, C), f.on(At.A.PLAYBACK_PROGRESS, ot, C), f.on(At.A.PLAYBACK_TIME_UPDATED, ot, C), f.on(At.A.PLAYBACK_SEEKED, F, C), f.on(at.A.SETTING_UPDATED_CATCHUP_ENABLED, st, C), f.on(at.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, wt, C), f.on(at.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, wt, C), f.on(At.A.STREAM_INITIALIZED, wt, C), wt();
          } }, R = (0, jt.A)(A).getInstance().getLogger(C), G(), C;
        }
        tp.__dashjs_factory_name = "CatchupController";
        var P0 = Bt.A.getSingletonFactory(tp);
        const F0 = [X.A.SERVICE_DESCRIPTION_DVB_LL_SCHEME], ep = "video", np = "audio";
        function ap() {
          const A = this.context;
          let f, C, _, v, M;
          function Y() {
            C = { liveDelay: NaN, liveCatchup: { maxDrift: NaN, playbackRate: { min: NaN, max: NaN } }, minBitrate: {}, maxBitrate: {}, initialBitrate: {}, contentSteering: null, clientDataReporting: null }, _ = [];
          }
          function H(L, W, K) {
            try {
              C[L][W] = K / 1e3;
            } catch (R) {
              v.error(R);
            }
          }
          return f = { getServiceDescriptionSettings: function() {
            return C;
          }, getProducerReferenceTimeOffsets: function() {
            return _;
          }, calculateProducerReferenceTimeOffsets: function(L) {
            try {
              let W = [];
              if (L && L.length > 0) {
                const K = [X.A.VIDEO, X.A.AUDIO, X.A.MESH, X.A.TEXT], R = M.getAvailabilityStartTime() / 1e3;
                L.forEach((G) => {
                  const F = K.reduce((et, it) => et.concat(M.getAllMediaInfoForType(G, it)), []).reduce((et, it) => (M.getProducerReferenceTimes(G, it).forEach((st) => {
                    const ot = M.getVoRepresentations(it);
                    if (ot && ot.length > 0 && ot[0].adaptation && ot[0].segmentInfoType === D.A.SEGMENT_TEMPLATE) {
                      const ut = ot[0], mt = new Date(st[D.A.WALL_CLOCK_TIME]).getTime() / 1e3 - (st[D.A.PRESENTATION_TIME] / ut[D.A.TIMESCALE] - ut[D.A.PRESENTATION_TIME_OFFSET] + G.start), wt = R - mt;
                      et.push({ id: st[D.A.ID], to: wt });
                    }
                  }), et), []);
                  W = W.concat(F);
                });
              }
              _ = W;
            } catch (W) {
              v.error(W), _ = [];
            }
          }, applyServiceDescription: function(L) {
            if (!L || !L.serviceDescriptions) return;
            const W = L.serviceDescriptions.filter((G) => F0.includes(G.schemeIdUri)), K = L.serviceDescriptions.filter((G) => G.schemeIdUri == null);
            let R = W.length > 0 ? W[W.length - 1] : K[K.length - 1];
            R && (R.latency && R.latency.target > 0 && function(G) {
              let F;
              if (G.schemeIdUri, X.A.SERVICE_DESCRIPTION_DVB_LL_SCHEME, F = function(et) {
                return { liveDelay: et.latency.target / 1e3, maxDrift: !isNaN(et.latency.max) && et.latency.max > et.latency.target ? (et.latency.max - et.latency.target + 500) / 1e3 : NaN, referenceId: et.latency.referenceId || NaN };
              }(G), _.length > 0) {
                let { to: et, id: it } = function(st) {
                  let ot, ut = 0, mt = _.filter((wt) => wt.id === st.referenceId);
                  return mt.length === 0 ? (ut = _.length > 0 ? _[0].to : 0, ot = _[0].id || NaN) : (ut = mt[0].to || 0, ot = mt[0].id || NaN), { to: ut, id: ot };
                }(F);
                C.liveDelay = F.liveDelay - et, C.liveCatchup.maxDrift = F.maxDrift, v.debug(`
                Found latency properties coming from service description. Applied time offset of ${et} from ProducerReferenceTime element with id ${it}.
                Live Delay: ${F.liveDelay - et}, Live catchup max drift: ${F.maxDrift}
            `);
              } else C.liveDelay = F.liveDelay, C.liveCatchup.maxDrift = F.maxDrift, v.debug(`Found latency properties coming from service description: Live Delay: ${F.liveDelay}, Live catchup max drift: ${F.maxDrift}`);
            }(R), R.playbackRate && function(G) {
              const F = G.playbackRate.min ? Math.round(1e3 * (G.playbackRate.min - 1)) / 1e3 : NaN, et = G.playbackRate.max ? Math.round(1e3 * (G.playbackRate.max - 1)) / 1e3 : NaN;
              C.liveCatchup.playbackRate.min = F, C.liveCatchup.playbackRate.max = et, v.debug(`Found latency properties coming from service description: Live catchup min playback rate: ${F}`), v.debug(`Found latency properties coming from service description: Live catchup max playback rate: ${et}`);
            }(R), R.operatingQuality, R.operatingBandwidth && function(G) {
              if (!G || !G.operatingBandwidth || !G.operatingBandwidth.mediaType || G.operatingBandwidth.mediaType === "all") return;
              const F = {};
              F.minBandwidth = G.operatingBandwidth.min, F.maxBandwidth = G.operatingBandwidth.max, F.targetBandwidth = G.operatingBandwidth.target;
              const et = [];
              G.operatingBandwidth.mediaType === ep || G.operatingBandwidth.mediaType === np ? et.push(G.operatingBandwidth.mediaType) : G.operatingBandwidth.mediaType === "any" && (et.push(np), et.push(ep), et.push("mesh")), et.forEach((it) => {
                isNaN(F.minBandwidth) || H("minBitrate", it, F.minBandwidth), isNaN(F.maxBandwidth) || H("maxBitrate", it, F.maxBandwidth), isNaN(F.targetBandwidth) || H("initialBitrate", it, F.targetBandwidth);
              });
            }(R), R.contentSteering && function(G) {
              C.contentSteering = G.contentSteering;
            }(R), R.clientDataReporting && function(G) {
              C.clientDataReporting = G.clientDataReporting;
            }(R));
          }, reset: function() {
            Y();
          }, setConfig: function(L) {
            L && L.adapter && (M = L.adapter);
          } }, v = (0, jt.A)(A).getInstance().getLogger(f), Y(), f;
        }
        ap.__dashjs_factory_name = "ServiceDescriptionController";
        var O0 = Bt.A.getSingletonFactory(ap);
        function co() {
          let A = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, f = [];
          if (A.irregular) return A.irregular;
          if (A.regular) return A.regular;
          if (A.language) {
            f = f.concat(A.language, A.extendedLanguageSubtags || [], A.script || [], A.region || [], A.variants || []);
            const C = A.extensions || [];
            let _ = -1;
            for (; ++_ < C.length; ) {
              const v = C[_];
              v.singleton && v.extensions && v.extensions.length > 0 && f.push(v.singleton, ...v.extensions);
            }
          }
          return A.privateuse && A.privateuse.length > 0 && f.push("x", ...A.privateuse), f.join("-");
        }
        function Mi(A) {
          const f = typeof A == "string" ? A.charCodeAt(0) : A;
          return f >= 97 && f <= 122 || f >= 65 && f <= 90;
        }
        function Wo(A) {
          const f = typeof A == "string" ? A.charCodeAt(0) : A;
          return f >= 48 && f <= 57;
        }
        function _s(A) {
          return Mi(A) || Wo(A);
        }
        const U0 = ["art-lojban", "cel-gaulish", "no-bok", "no-nyn", "zh-guoyu", "zh-hakka", "zh-min", "zh-min-nan", "zh-xiang"], ip = { "en-gb-oed": "en-GB-oxendict", "i-ami": "ami", "i-bnn": "bnn", "i-default": null, "i-enochian": null, "i-hak": "hak", "i-klingon": "tlh", "i-lux": "lb", "i-mingo": null, "i-navajo": "nv", "i-pwn": "pwn", "i-tao": "tao", "i-tay": "tay", "i-tsu": "tsu", "sgn-be-fr": "sfb", "sgn-be-nl": "vgt", "sgn-ch-de": "sgg", "art-lojban": "jbo", "cel-gaulish": null, "no-bok": "nb", "no-nyn": "nn", "zh-guoyu": "cmn", "zh-hakka": "hak", "zh-min": null, "zh-min-nan": "nan", "zh-xiang": "hsn" }, K0 = {}.hasOwnProperty;
        function bs(A) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const C = { language: null, extendedLanguageSubtags: [], script: null, region: null, variants: [], extensions: [], privateuse: [], irregular: null, regular: null }, _ = String(A), v = _.toLowerCase();
          let M = 0;
          if (A == null) throw new Error("Expected string, got `" + A + "`");
          if (K0.call(ip, v)) {
            const H = ip[v];
            return f.normalize !== void 0 && f.normalize !== null && !f.normalize || typeof H != "string" ? (C[U0.includes(v) ? "regular" : "irregular"] = _, C) : bs(H);
          }
          for (; Mi(v.charCodeAt(M)) && M < 9; ) M++;
          if (M > 1 && M < 9) {
            if (C.language = _.slice(0, M), M < 4) {
              let H = 0;
              for (; v.charCodeAt(M) === 45 && Mi(v.charCodeAt(M + 1)) && Mi(v.charCodeAt(M + 2)) && Mi(v.charCodeAt(M + 3)) && !Mi(v.charCodeAt(M + 4)); ) {
                if (H > 2) return Y(M, 3, "Too many extended language subtags, expected at most 3 subtags");
                C.extendedLanguageSubtags.push(_.slice(M + 1, M + 4)), M += 4, H++;
              }
            }
            for (v.charCodeAt(M) === 45 && Mi(v.charCodeAt(M + 1)) && Mi(v.charCodeAt(M + 2)) && Mi(v.charCodeAt(M + 3)) && Mi(v.charCodeAt(M + 4)) && !Mi(v.charCodeAt(M + 5)) && (C.script = _.slice(M + 1, M + 5), M += 5), v.charCodeAt(M) === 45 && (Mi(v.charCodeAt(M + 1)) && Mi(v.charCodeAt(M + 2)) && !Mi(v.charCodeAt(M + 3)) ? (C.region = _.slice(M + 1, M + 3), M += 3) : Wo(v.charCodeAt(M + 1)) && Wo(v.charCodeAt(M + 2)) && Wo(v.charCodeAt(M + 3)) && !Wo(v.charCodeAt(M + 4)) && (C.region = _.slice(M + 1, M + 4), M += 4)); v.charCodeAt(M) === 45; ) {
              const H = M + 1;
              let L = H;
              for (; _s(v.charCodeAt(L)); ) {
                if (L - H > 7) return Y(L, 1, "Too long variant, expected at most 8 characters");
                L++;
              }
              if (!(L - H > 4 || L - H > 3 && Wo(v.charCodeAt(H)))) break;
              C.variants.push(_.slice(H, L)), M = L;
            }
            for (; v.charCodeAt(M) === 45 && v.charCodeAt(M + 1) !== 120 && _s(v.charCodeAt(M + 1)) && v.charCodeAt(M + 2) === 45 && _s(v.charCodeAt(M + 3)); ) {
              let H = M + 2, L = 0;
              for (; v.charCodeAt(H) === 45 && _s(v.charCodeAt(H + 1)) && _s(v.charCodeAt(H + 2)); ) {
                const W = H + 1;
                for (H = W + 2, L++; _s(v.charCodeAt(H)); ) {
                  if (H - W > 7) return Y(H, 2, "Too long extension, expected at most 8 characters");
                  H++;
                }
              }
              if (!L) return Y(H, 4, "Empty extension, extensions must have at least 2 characters of content");
              C.extensions.push({ singleton: _.charAt(M + 1), extensions: _.slice(M + 3, H).split("-") }), M = H;
            }
          } else M = 0;
          if (M === 0 && v.charCodeAt(M) === 120 || v.charCodeAt(M) === 45 && v.charCodeAt(M + 1) === 120) {
            M = M ? M + 2 : 1;
            let H = M;
            for (; v.charCodeAt(H) === 45 && _s(v.charCodeAt(H + 1)); ) {
              const L = M + 1;
              for (H = L; _s(v.charCodeAt(H)); ) {
                if (H - L > 7) return Y(H, 5, "Too long private-use area, expected at most 8 characters");
                H++;
              }
              C.privateuse.push(_.slice(M + 1, H)), M = H;
            }
          }
          return M !== _.length ? Y(M, 6, "Found superfluous content after tag") : C;
          function Y(H, L, W) {
            return f.warning && f.warning(W, L, H), f.forgiving ? C : { language: null, extendedLanguageSubtags: [], script: null, region: null, variants: [], extensions: [], privateuse: [], irregular: null, regular: null };
          }
        }
        function V0(A, f) {
          return function(C, _) {
            let v = rp(C, "tag");
            const M = rp(_ == null ? "*" : _, "range"), Y = [];
            let H = -1;
            for (; ++H < M.length; ) {
              const L = M[H].toLowerCase();
              if (!f && L === "*") continue;
              let W = -1;
              const K = [];
              for (; ++W < v.length; ) if (A(v[W].toLowerCase(), L)) {
                if (!f) return v[W];
                Y.push(v[W]);
              } else K.push(v[W]);
              v = K;
            }
            return f ? Y : void 0;
          };
        }
        const vc = V0(function(A, f) {
          const C = A.split("-"), _ = f.split("-");
          let v = 0, M = 0;
          if (_[M] !== "*" && C[v] !== _[M]) return !1;
          for (v++, M++; M < _.length; ) if (_[M] !== "*") {
            if (!C[v]) return !1;
            if (C[v] !== _[M]) {
              if (C[v].length === 1) return !1;
              v++;
            } else v++, M++;
          } else M++;
          return !0;
        }, !0);
        function rp(A, f) {
          const C = A && typeof A == "string" ? [A] : A;
          if (!C || typeof C != "object" || !("length" in C)) throw new Error("Invalid " + f + " `" + C + "`, expected non-empty string");
          return C;
        }
        const Ec = [{ from: "in", to: "id" }, { from: "iw", to: "he" }, { from: "ji", to: "yi" }, { from: "jw", to: "jv" }, { from: "mo", to: "ro" }, { from: "scc", to: "sr" }, { from: "scr", to: "hr" }, { from: "aam", to: "aas" }, { from: "adp", to: "dz" }, { from: "aue", to: "ktz" }, { from: "ayx", to: "nun" }, { from: "bgm", to: "bcg" }, { from: "bjd", to: "drl" }, { from: "ccq", to: "rki" }, { from: "cjr", to: "mom" }, { from: "cka", to: "cmr" }, { from: "cmk", to: "xch" }, { from: "coy", to: "pij" }, { from: "cqu", to: "quh" }, { from: "drh", to: "mn" }, { from: "drw", to: "fa-af" }, { from: "gav", to: "dev" }, { from: "gfx", to: "vaj" }, { from: "ggn", to: "gvr" }, { from: "gti", to: "nyc" }, { from: "guv", to: "duz" }, { from: "hrr", to: "jal" }, { from: "ibi", to: "opa" }, { from: "ilw", to: "gal" }, { from: "jeg", to: "oyb" }, { from: "kgc", to: "tdf" }, { from: "kgh", to: "kml" }, { from: "koj", to: "kwv" }, { from: "krm", to: "bmf" }, { from: "ktr", to: "dtp" }, { from: "kvs", to: "gdj" }, { from: "kwq", to: "yam" }, { from: "kxe", to: "tvd" }, { from: "kzj", to: "dtp" }, { from: "kzt", to: "dtp" }, { from: "lii", to: "raq" }, { from: "lmm", to: "rmx" }, { from: "meg", to: "cir" }, { from: "mst", to: "mry" }, { from: "mwj", to: "vaj" }, { from: "myt", to: "mry" }, { from: "nad", to: "xny" }, { from: "ncp", to: "kdz" }, { from: "nnx", to: "ngv" }, { from: "nts", to: "pij" }, { from: "oun", to: "vaj" }, { from: "pcr", to: "adx" }, { from: "pmc", to: "huw" }, { from: "pmu", to: "phr" }, { from: "ppa", to: "bfy" }, { from: "ppr", to: "lcq" }, { from: "pry", to: "prt" }, { from: "puz", to: "pub" }, { from: "sca", to: "hle" }, { from: "skk", to: "oyb" }, { from: "tdu", to: "dtp" }, { from: "thc", to: "tpo" }, { from: "thx", to: "oyb" }, { from: "tie", to: "ras" }, { from: "tkk", to: "twm" }, { from: "tlw", to: "weo" }, { from: "tmp", to: "tyj" }, { from: "tne", to: "kak" }, { from: "tnf", to: "fa-af" }, { from: "tsf", to: "taj" }, { from: "uok", to: "ema" }, { from: "xba", to: "cax" }, { from: "xia", to: "acn" }, { from: "xkh", to: "waw" }, { from: "xsj", to: "suj" }, { from: "ybd", to: "rki" }, { from: "yma", to: "lrr" }, { from: "ymt", to: "mtm" }, { from: "yos", to: "zom" }, { from: "yuu", to: "yug" }, { from: "asd", to: "snz" }, { from: "dit", to: "dif" }, { from: "llo", to: "ngt" }, { from: "myd", to: "aog" }, { from: "nns", to: "nbr" }, { from: "agp", to: "apf" }, { from: "ais", to: "ami" }, { from: "ajt", to: "aeb" }, { from: "baz", to: "nvo" }, { from: "bhk", to: "fbl" }, { from: "bic", to: "bir" }, { from: "bjq", to: "bzc" }, { from: "bkb", to: "ebk" }, { from: "blg", to: "iba" }, { from: "btb", to: "beb" }, { from: "daf", to: "dnj" }, { from: "dap", to: "njz" }, { from: "djl", to: "dze" }, { from: "dkl", to: "aqd" }, { from: "drr", to: "kzk" }, { from: "dud", to: "uth" }, { from: "duj", to: "dwu" }, { from: "dwl", to: "dbt" }, { from: "elp", to: "amq" }, { from: "gbc", to: "wny" }, { from: "ggo", to: "esg" }, { from: "ggr", to: "gtu" }, { from: "gio", to: "aou" }, { from: "gli", to: "kzk" }, { from: "ill", to: "ilm" }, { from: "izi", to: "eza" }, { from: "jar", to: "jgk" }, { from: "kdv", to: "zkd" }, { from: "kgd", to: "ncq" }, { from: "kpp", to: "jkm" }, { from: "kxl", to: "kru" }, { from: "kzh", to: "dgl" }, { from: "lak", to: "ksp" }, { from: "leg", to: "enl" }, { from: "mgx", to: "jbk" }, { from: "mnt", to: "wnn" }, { from: "mof", to: "xnt" }, { from: "mwd", to: "dmw" }, { from: "nbf", to: "nru" }, { from: "nbx", to: "ekc" }, { from: "nln", to: "azd" }, { from: "nlr", to: "nrk" }, { from: "noo", to: "dtd" }, { from: "nxu", to: "bpp" }, { from: "pat", to: "kxr" }, { from: "rmr", to: "emx" }, { from: "sap", to: "aqt" }, { from: "sgl", to: "isk" }, { from: "smd", to: "kmb" }, { from: "snb", to: "iba" }, { from: "sul", to: "sgd" }, { from: "sum", to: "ulw" }, { from: "tgg", to: "bjp" }, { from: "thw", to: "ola" }, { from: "tid", to: "itd" }, { from: "unp", to: "wro" }, { from: "wgw", to: "wgb" }, { from: "wit", to: "nol" }, { from: "wiw", to: "nwo" }, { from: "xrq", to: "dmw" }, { from: "yen", to: "ynq" }, { from: "yiy", to: "yrm" }, { from: "zir", to: "scv" }, { from: "sgn-br", to: "bzs" }, { from: "sgn-co", to: "csn" }, { from: "sgn-de", to: "gsg" }, { from: "sgn-dk", to: "dsl" }, { from: "sgn-fr", to: "fsl" }, { from: "sgn-gb", to: "bfi" }, { from: "sgn-gr", to: "gss" }, { from: "sgn-ie", to: "isg" }, { from: "sgn-it", to: "ise" }, { from: "sgn-jp", to: "jsl" }, { from: "sgn-mx", to: "mfs" }, { from: "sgn-ni", to: "ncs" }, { from: "sgn-nl", to: "dse" }, { from: "sgn-no", to: "nsi" }, { from: "sgn-pt", to: "psr" }, { from: "sgn-se", to: "swl" }, { from: "sgn-us", to: "ase" }, { from: "sgn-za", to: "sfs" }, { from: "sgn-es", to: "ssp" }, { from: "zh-cmn", to: "zh" }, { from: "zh-cmn-hans", to: "zh-hans" }, { from: "zh-cmn-hant", to: "zh-hant" }, { from: "zh-gan", to: "gan" }, { from: "zh-wuu", to: "wuu" }, { from: "zh-yue", to: "yue" }, { from: "no-bokmal", to: "nb" }, { from: "no-nynorsk", to: "nn" }, { from: "aa-saaho", to: "ssy" }, { from: "sh", to: "sr-latn" }, { from: "cnr", to: "sr-me" }, { from: "tl", to: "fil" }, { from: "aju", to: "jrb" }, { from: "als", to: "sq" }, { from: "arb", to: "ar" }, { from: "ayr", to: "ay" }, { from: "azj", to: "az" }, { from: "bcc", to: "bal" }, { from: "bcl", to: "bik" }, { from: "bxk", to: "luy" }, { from: "bxr", to: "bua" }, { from: "cld", to: "syr" }, { from: "cmn", to: "zh" }, { from: "cwd", to: "cr" }, { from: "dgo", to: "doi" }, { from: "dhd", to: "mwr" }, { from: "dik", to: "din" }, { from: "diq", to: "zza" }, { from: "lbk", to: "bnc" }, { from: "ekk", to: "et" }, { from: "emk", to: "man" }, { from: "esk", to: "ik" }, { from: "fat", to: "ak" }, { from: "fuc", to: "ff" }, { from: "gaz", to: "om" }, { from: "gbo", to: "grb" }, { from: "gno", to: "gon" }, { from: "gug", to: "gn" }, { from: "gya", to: "gba" }, { from: "hdn", to: "hai" }, { from: "hea", to: "hmn" }, { from: "ike", to: "iu" }, { from: "kmr", to: "ku" }, { from: "knc", to: "kr" }, { from: "kng", to: "kg" }, { from: "knn", to: "kok" }, { from: "kpv", to: "kv" }, { from: "lvs", to: "lv" }, { from: "mhr", to: "chm" }, { from: "mup", to: "raj" }, { from: "khk", to: "mn" }, { from: "npi", to: "ne" }, { from: "ojg", to: "oj" }, { from: "ory", to: "or" }, { from: "pbu", to: "ps" }, { from: "pes", to: "fa" }, { from: "plt", to: "mg" }, { from: "pnb", to: "lah" }, { from: "quz", to: "qu" }, { from: "rmy", to: "rom" }, { from: "spy", to: "kln" }, { from: "src", to: "sc" }, { from: "swh", to: "sw" }, { from: "ttq", to: "tmh" }, { from: "tw", to: "ak" }, { from: "umu", to: "del" }, { from: "uzn", to: "uz" }, { from: "xpe", to: "kpe" }, { from: "xsl", to: "den" }, { from: "ydd", to: "yi" }, { from: "zai", to: "zap" }, { from: "zsm", to: "ms" }, { from: "zyb", to: "za" }, { from: "him", to: "srx" }, { from: "mnk", to: "man" }, { from: "bh", to: "bho" }, { from: "prs", to: "fa-af" }, { from: "swc", to: "sw-cd" }, { from: "aar", to: "aa" }, { from: "abk", to: "ab" }, { from: "ave", to: "ae" }, { from: "afr", to: "af" }, { from: "aka", to: "ak" }, { from: "amh", to: "am" }, { from: "arg", to: "an" }, { from: "ara", to: "ar" }, { from: "asm", to: "as" }, { from: "ava", to: "av" }, { from: "aym", to: "ay" }, { from: "aze", to: "az" }, { from: "bak", to: "ba" }, { from: "bel", to: "be" }, { from: "bul", to: "bg" }, { from: "bih", to: "bho" }, { from: "bis", to: "bi" }, { from: "bam", to: "bm" }, { from: "ben", to: "bn" }, { from: "bod", to: "bo" }, { from: "bre", to: "br" }, { from: "bos", to: "bs" }, { from: "cat", to: "ca" }, { from: "che", to: "ce" }, { from: "cha", to: "ch" }, { from: "cos", to: "co" }, { from: "cre", to: "cr" }, { from: "ces", to: "cs" }, { from: "chu", to: "cu" }, { from: "chv", to: "cv" }, { from: "cym", to: "cy" }, { from: "dan", to: "da" }, { from: "deu", to: "de" }, { from: "div", to: "dv" }, { from: "dzo", to: "dz" }, { from: "ewe", to: "ee" }, { from: "ell", to: "el" }, { from: "eng", to: "en" }, { from: "epo", to: "eo" }, { from: "spa", to: "es" }, { from: "est", to: "et" }, { from: "eus", to: "eu" }, { from: "fas", to: "fa" }, { from: "ful", to: "ff" }, { from: "fin", to: "fi" }, { from: "fij", to: "fj" }, { from: "fao", to: "fo" }, { from: "fra", to: "fr" }, { from: "fry", to: "fy" }, { from: "gle", to: "ga" }, { from: "gla", to: "gd" }, { from: "glg", to: "gl" }, { from: "grn", to: "gn" }, { from: "guj", to: "gu" }, { from: "glv", to: "gv" }, { from: "hau", to: "ha" }, { from: "heb", to: "he" }, { from: "hin", to: "hi" }, { from: "hmo", to: "ho" }, { from: "hrv", to: "hr" }, { from: "hat", to: "ht" }, { from: "hun", to: "hu" }, { from: "hye", to: "hy" }, { from: "her", to: "hz" }, { from: "ina", to: "ia" }, { from: "ind", to: "id" }, { from: "ile", to: "ie" }, { from: "ibo", to: "ig" }, { from: "iii", to: "ii" }, { from: "ipk", to: "ik" }, { from: "ido", to: "io" }, { from: "isl", to: "is" }, { from: "ita", to: "it" }, { from: "iku", to: "iu" }, { from: "jpn", to: "ja" }, { from: "jav", to: "jv" }, { from: "kat", to: "ka" }, { from: "kon", to: "kg" }, { from: "kik", to: "ki" }, { from: "kua", to: "kj" }, { from: "kaz", to: "kk" }, { from: "kal", to: "kl" }, { from: "khm", to: "km" }, { from: "kan", to: "kn" }, { from: "kor", to: "ko" }, { from: "kau", to: "kr" }, { from: "kas", to: "ks" }, { from: "kur", to: "ku" }, { from: "kom", to: "kv" }, { from: "cor", to: "kw" }, { from: "kir", to: "ky" }, { from: "lat", to: "la" }, { from: "ltz", to: "lb" }, { from: "lug", to: "lg" }, { from: "lim", to: "li" }, { from: "lin", to: "ln" }, { from: "lao", to: "lo" }, { from: "lit", to: "lt" }, { from: "lub", to: "lu" }, { from: "lav", to: "lv" }, { from: "mlg", to: "mg" }, { from: "mah", to: "mh" }, { from: "mri", to: "mi" }, { from: "mkd", to: "mk" }, { from: "mal", to: "ml" }, { from: "mon", to: "mn" }, { from: "mol", to: "ro" }, { from: "mar", to: "mr" }, { from: "msa", to: "ms" }, { from: "mlt", to: "mt" }, { from: "mya", to: "my" }, { from: "nau", to: "na" }, { from: "nob", to: "nb" }, { from: "nde", to: "nd" }, { from: "nep", to: "ne" }, { from: "ndo", to: "ng" }, { from: "nld", to: "nl" }, { from: "nno", to: "nn" }, { from: "nor", to: "no" }, { from: "nbl", to: "nr" }, { from: "nav", to: "nv" }, { from: "nya", to: "ny" }, { from: "oci", to: "oc" }, { from: "oji", to: "oj" }, { from: "orm", to: "om" }, { from: "ori", to: "or" }, { from: "oss", to: "os" }, { from: "pan", to: "pa" }, { from: "pli", to: "pi" }, { from: "pol", to: "pl" }, { from: "pus", to: "ps" }, { from: "por", to: "pt" }, { from: "que", to: "qu" }, { from: "roh", to: "rm" }, { from: "run", to: "rn" }, { from: "ron", to: "ro" }, { from: "rus", to: "ru" }, { from: "kin", to: "rw" }, { from: "san", to: "sa" }, { from: "srd", to: "sc" }, { from: "snd", to: "sd" }, { from: "sme", to: "se" }, { from: "sag", to: "sg" }, { from: "hbs", to: "sr-latn" }, { from: "sin", to: "si" }, { from: "slk", to: "sk" }, { from: "slv", to: "sl" }, { from: "smo", to: "sm" }, { from: "sna", to: "sn" }, { from: "som", to: "so" }, { from: "sqi", to: "sq" }, { from: "srp", to: "sr" }, { from: "ssw", to: "ss" }, { from: "sot", to: "st" }, { from: "sun", to: "su" }, { from: "swe", to: "sv" }, { from: "swa", to: "sw" }, { from: "tam", to: "ta" }, { from: "tel", to: "te" }, { from: "tgk", to: "tg" }, { from: "tha", to: "th" }, { from: "tir", to: "ti" }, { from: "tuk", to: "tk" }, { from: "tgl", to: "fil" }, { from: "tsn", to: "tn" }, { from: "ton", to: "to" }, { from: "tur", to: "tr" }, { from: "tso", to: "ts" }, { from: "tat", to: "tt" }, { from: "twi", to: "ak" }, { from: "tah", to: "ty" }, { from: "uig", to: "ug" }, { from: "ukr", to: "uk" }, { from: "urd", to: "ur" }, { from: "uzb", to: "uz" }, { from: "ven", to: "ve" }, { from: "vie", to: "vi" }, { from: "vol", to: "vo" }, { from: "wln", to: "wa" }, { from: "wol", to: "wo" }, { from: "xho", to: "xh" }, { from: "yid", to: "yi" }, { from: "yor", to: "yo" }, { from: "zha", to: "za" }, { from: "zho", to: "zh" }, { from: "zul", to: "zu" }, { from: "alb", to: "sq" }, { from: "arm", to: "hy" }, { from: "baq", to: "eu" }, { from: "bur", to: "my" }, { from: "chi", to: "zh" }, { from: "cze", to: "cs" }, { from: "dut", to: "nl" }, { from: "fre", to: "fr" }, { from: "geo", to: "ka" }, { from: "ger", to: "de" }, { from: "gre", to: "el" }, { from: "ice", to: "is" }, { from: "mac", to: "mk" }, { from: "mao", to: "mi" }, { from: "may", to: "ms" }, { from: "per", to: "fa" }, { from: "rum", to: "ro" }, { from: "slo", to: "sk" }, { from: "tib", to: "bo" }, { from: "wel", to: "cy" }, { from: "und-aaland", to: "und-ax" }, { from: "hy-arevmda", to: "hyw" }, { from: "und-arevmda", to: "und" }, { from: "und-arevela", to: "und" }, { from: "und-lojban", to: "und" }, { from: "und-saaho", to: "und" }, { from: "und-bokmal", to: "und" }, { from: "und-nynorsk", to: "und" }, { from: "und-hakka", to: "und" }, { from: "und-xiang", to: "und" }, { from: "und-hepburn-heploc", to: "und-alalc97" }], eu = [{ from: { field: "script", value: "qaai" }, to: { field: "script", value: "zinh" } }, { from: { field: "region", value: "bu" }, to: { field: "region", value: "mm" } }, { from: { field: "region", value: "ct" }, to: { field: "region", value: "ki" } }, { from: { field: "region", value: "dd" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "dy" }, to: { field: "region", value: "bj" } }, { from: { field: "region", value: "fx" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "hv" }, to: { field: "region", value: "bf" } }, { from: { field: "region", value: "jt" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "mi" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "nh" }, to: { field: "region", value: "vu" } }, { from: { field: "region", value: "nq" }, to: { field: "region", value: "aq" } }, { from: { field: "region", value: "pu" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "pz" }, to: { field: "region", value: "pa" } }, { from: { field: "region", value: "qu" }, to: { field: "region", value: "eu" } }, { from: { field: "region", value: "rh" }, to: { field: "region", value: "zw" } }, { from: { field: "region", value: "tp" }, to: { field: "region", value: "tl" } }, { from: { field: "region", value: "uk" }, to: { field: "region", value: "gb" } }, { from: { field: "region", value: "vd" }, to: { field: "region", value: "vn" } }, { from: { field: "region", value: "wk" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "yd" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "zr" }, to: { field: "region", value: "cd" } }, { from: { field: "region", value: "230" }, to: { field: "region", value: "et" } }, { from: { field: "region", value: "280" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "736" }, to: { field: "region", value: "sd" } }, { from: { field: "region", value: "886" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "958" }, to: { field: "region", value: "aa" } }, { from: { field: "region", value: "020" }, to: { field: "region", value: "ad" } }, { from: { field: "region", value: "784" }, to: { field: "region", value: "ae" } }, { from: { field: "region", value: "004" }, to: { field: "region", value: "af" } }, { from: { field: "region", value: "028" }, to: { field: "region", value: "ag" } }, { from: { field: "region", value: "660" }, to: { field: "region", value: "ai" } }, { from: { field: "region", value: "008" }, to: { field: "region", value: "al" } }, { from: { field: "region", value: "051" }, to: { field: "region", value: "am" } }, { from: { field: "region", value: "024" }, to: { field: "region", value: "ao" } }, { from: { field: "region", value: "010" }, to: { field: "region", value: "aq" } }, { from: { field: "region", value: "032" }, to: { field: "region", value: "ar" } }, { from: { field: "region", value: "016" }, to: { field: "region", value: "as" } }, { from: { field: "region", value: "040" }, to: { field: "region", value: "at" } }, { from: { field: "region", value: "036" }, to: { field: "region", value: "au" } }, { from: { field: "region", value: "533" }, to: { field: "region", value: "aw" } }, { from: { field: "region", value: "248" }, to: { field: "region", value: "ax" } }, { from: { field: "region", value: "031" }, to: { field: "region", value: "az" } }, { from: { field: "region", value: "070" }, to: { field: "region", value: "ba" } }, { from: { field: "region", value: "052" }, to: { field: "region", value: "bb" } }, { from: { field: "region", value: "050" }, to: { field: "region", value: "bd" } }, { from: { field: "region", value: "056" }, to: { field: "region", value: "be" } }, { from: { field: "region", value: "854" }, to: { field: "region", value: "bf" } }, { from: { field: "region", value: "100" }, to: { field: "region", value: "bg" } }, { from: { field: "region", value: "048" }, to: { field: "region", value: "bh" } }, { from: { field: "region", value: "108" }, to: { field: "region", value: "bi" } }, { from: { field: "region", value: "204" }, to: { field: "region", value: "bj" } }, { from: { field: "region", value: "652" }, to: { field: "region", value: "bl" } }, { from: { field: "region", value: "060" }, to: { field: "region", value: "bm" } }, { from: { field: "region", value: "096" }, to: { field: "region", value: "bn" } }, { from: { field: "region", value: "068" }, to: { field: "region", value: "bo" } }, { from: { field: "region", value: "535" }, to: { field: "region", value: "bq" } }, { from: { field: "region", value: "076" }, to: { field: "region", value: "br" } }, { from: { field: "region", value: "044" }, to: { field: "region", value: "bs" } }, { from: { field: "region", value: "064" }, to: { field: "region", value: "bt" } }, { from: { field: "region", value: "104" }, to: { field: "region", value: "mm" } }, { from: { field: "region", value: "074" }, to: { field: "region", value: "bv" } }, { from: { field: "region", value: "072" }, to: { field: "region", value: "bw" } }, { from: { field: "region", value: "112" }, to: { field: "region", value: "by" } }, { from: { field: "region", value: "084" }, to: { field: "region", value: "bz" } }, { from: { field: "region", value: "124" }, to: { field: "region", value: "ca" } }, { from: { field: "region", value: "166" }, to: { field: "region", value: "cc" } }, { from: { field: "region", value: "180" }, to: { field: "region", value: "cd" } }, { from: { field: "region", value: "140" }, to: { field: "region", value: "cf" } }, { from: { field: "region", value: "178" }, to: { field: "region", value: "cg" } }, { from: { field: "region", value: "756" }, to: { field: "region", value: "ch" } }, { from: { field: "region", value: "384" }, to: { field: "region", value: "ci" } }, { from: { field: "region", value: "184" }, to: { field: "region", value: "ck" } }, { from: { field: "region", value: "152" }, to: { field: "region", value: "cl" } }, { from: { field: "region", value: "120" }, to: { field: "region", value: "cm" } }, { from: { field: "region", value: "156" }, to: { field: "region", value: "cn" } }, { from: { field: "region", value: "170" }, to: { field: "region", value: "co" } }, { from: { field: "region", value: "188" }, to: { field: "region", value: "cr" } }, { from: { field: "region", value: "192" }, to: { field: "region", value: "cu" } }, { from: { field: "region", value: "132" }, to: { field: "region", value: "cv" } }, { from: { field: "region", value: "531" }, to: { field: "region", value: "cw" } }, { from: { field: "region", value: "162" }, to: { field: "region", value: "cx" } }, { from: { field: "region", value: "196" }, to: { field: "region", value: "cy" } }, { from: { field: "region", value: "203" }, to: { field: "region", value: "cz" } }, { from: { field: "region", value: "278" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "276" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "262" }, to: { field: "region", value: "dj" } }, { from: { field: "region", value: "208" }, to: { field: "region", value: "dk" } }, { from: { field: "region", value: "212" }, to: { field: "region", value: "dm" } }, { from: { field: "region", value: "214" }, to: { field: "region", value: "do" } }, { from: { field: "region", value: "012" }, to: { field: "region", value: "dz" } }, { from: { field: "region", value: "218" }, to: { field: "region", value: "ec" } }, { from: { field: "region", value: "233" }, to: { field: "region", value: "ee" } }, { from: { field: "region", value: "818" }, to: { field: "region", value: "eg" } }, { from: { field: "region", value: "732" }, to: { field: "region", value: "eh" } }, { from: { field: "region", value: "232" }, to: { field: "region", value: "er" } }, { from: { field: "region", value: "724" }, to: { field: "region", value: "es" } }, { from: { field: "region", value: "231" }, to: { field: "region", value: "et" } }, { from: { field: "region", value: "246" }, to: { field: "region", value: "fi" } }, { from: { field: "region", value: "242" }, to: { field: "region", value: "fj" } }, { from: { field: "region", value: "238" }, to: { field: "region", value: "fk" } }, { from: { field: "region", value: "583" }, to: { field: "region", value: "fm" } }, { from: { field: "region", value: "234" }, to: { field: "region", value: "fo" } }, { from: { field: "region", value: "250" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "249" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "266" }, to: { field: "region", value: "ga" } }, { from: { field: "region", value: "826" }, to: { field: "region", value: "gb" } }, { from: { field: "region", value: "308" }, to: { field: "region", value: "gd" } }, { from: { field: "region", value: "268" }, to: { field: "region", value: "ge" } }, { from: { field: "region", value: "254" }, to: { field: "region", value: "gf" } }, { from: { field: "region", value: "831" }, to: { field: "region", value: "gg" } }, { from: { field: "region", value: "288" }, to: { field: "region", value: "gh" } }, { from: { field: "region", value: "292" }, to: { field: "region", value: "gi" } }, { from: { field: "region", value: "304" }, to: { field: "region", value: "gl" } }, { from: { field: "region", value: "270" }, to: { field: "region", value: "gm" } }, { from: { field: "region", value: "324" }, to: { field: "region", value: "gn" } }, { from: { field: "region", value: "312" }, to: { field: "region", value: "gp" } }, { from: { field: "region", value: "226" }, to: { field: "region", value: "gq" } }, { from: { field: "region", value: "300" }, to: { field: "region", value: "gr" } }, { from: { field: "region", value: "239" }, to: { field: "region", value: "gs" } }, { from: { field: "region", value: "320" }, to: { field: "region", value: "gt" } }, { from: { field: "region", value: "316" }, to: { field: "region", value: "gu" } }, { from: { field: "region", value: "624" }, to: { field: "region", value: "gw" } }, { from: { field: "region", value: "328" }, to: { field: "region", value: "gy" } }, { from: { field: "region", value: "344" }, to: { field: "region", value: "hk" } }, { from: { field: "region", value: "334" }, to: { field: "region", value: "hm" } }, { from: { field: "region", value: "340" }, to: { field: "region", value: "hn" } }, { from: { field: "region", value: "191" }, to: { field: "region", value: "hr" } }, { from: { field: "region", value: "332" }, to: { field: "region", value: "ht" } }, { from: { field: "region", value: "348" }, to: { field: "region", value: "hu" } }, { from: { field: "region", value: "360" }, to: { field: "region", value: "id" } }, { from: { field: "region", value: "372" }, to: { field: "region", value: "ie" } }, { from: { field: "region", value: "376" }, to: { field: "region", value: "il" } }, { from: { field: "region", value: "833" }, to: { field: "region", value: "im" } }, { from: { field: "region", value: "356" }, to: { field: "region", value: "in" } }, { from: { field: "region", value: "086" }, to: { field: "region", value: "io" } }, { from: { field: "region", value: "368" }, to: { field: "region", value: "iq" } }, { from: { field: "region", value: "364" }, to: { field: "region", value: "ir" } }, { from: { field: "region", value: "352" }, to: { field: "region", value: "is" } }, { from: { field: "region", value: "380" }, to: { field: "region", value: "it" } }, { from: { field: "region", value: "832" }, to: { field: "region", value: "je" } }, { from: { field: "region", value: "388" }, to: { field: "region", value: "jm" } }, { from: { field: "region", value: "400" }, to: { field: "region", value: "jo" } }, { from: { field: "region", value: "392" }, to: { field: "region", value: "jp" } }, { from: { field: "region", value: "404" }, to: { field: "region", value: "ke" } }, { from: { field: "region", value: "417" }, to: { field: "region", value: "kg" } }, { from: { field: "region", value: "116" }, to: { field: "region", value: "kh" } }, { from: { field: "region", value: "296" }, to: { field: "region", value: "ki" } }, { from: { field: "region", value: "174" }, to: { field: "region", value: "km" } }, { from: { field: "region", value: "659" }, to: { field: "region", value: "kn" } }, { from: { field: "region", value: "408" }, to: { field: "region", value: "kp" } }, { from: { field: "region", value: "410" }, to: { field: "region", value: "kr" } }, { from: { field: "region", value: "414" }, to: { field: "region", value: "kw" } }, { from: { field: "region", value: "136" }, to: { field: "region", value: "ky" } }, { from: { field: "region", value: "398" }, to: { field: "region", value: "kz" } }, { from: { field: "region", value: "418" }, to: { field: "region", value: "la" } }, { from: { field: "region", value: "422" }, to: { field: "region", value: "lb" } }, { from: { field: "region", value: "662" }, to: { field: "region", value: "lc" } }, { from: { field: "region", value: "438" }, to: { field: "region", value: "li" } }, { from: { field: "region", value: "144" }, to: { field: "region", value: "lk" } }, { from: { field: "region", value: "430" }, to: { field: "region", value: "lr" } }, { from: { field: "region", value: "426" }, to: { field: "region", value: "ls" } }, { from: { field: "region", value: "440" }, to: { field: "region", value: "lt" } }, { from: { field: "region", value: "442" }, to: { field: "region", value: "lu" } }, { from: { field: "region", value: "428" }, to: { field: "region", value: "lv" } }, { from: { field: "region", value: "434" }, to: { field: "region", value: "ly" } }, { from: { field: "region", value: "504" }, to: { field: "region", value: "ma" } }, { from: { field: "region", value: "492" }, to: { field: "region", value: "mc" } }, { from: { field: "region", value: "498" }, to: { field: "region", value: "md" } }, { from: { field: "region", value: "499" }, to: { field: "region", value: "me" } }, { from: { field: "region", value: "663" }, to: { field: "region", value: "mf" } }, { from: { field: "region", value: "450" }, to: { field: "region", value: "mg" } }, { from: { field: "region", value: "584" }, to: { field: "region", value: "mh" } }, { from: { field: "region", value: "807" }, to: { field: "region", value: "mk" } }, { from: { field: "region", value: "466" }, to: { field: "region", value: "ml" } }, { from: { field: "region", value: "496" }, to: { field: "region", value: "mn" } }, { from: { field: "region", value: "446" }, to: { field: "region", value: "mo" } }, { from: { field: "region", value: "580" }, to: { field: "region", value: "mp" } }, { from: { field: "region", value: "474" }, to: { field: "region", value: "mq" } }, { from: { field: "region", value: "478" }, to: { field: "region", value: "mr" } }, { from: { field: "region", value: "500" }, to: { field: "region", value: "ms" } }, { from: { field: "region", value: "470" }, to: { field: "region", value: "mt" } }, { from: { field: "region", value: "480" }, to: { field: "region", value: "mu" } }, { from: { field: "region", value: "462" }, to: { field: "region", value: "mv" } }, { from: { field: "region", value: "454" }, to: { field: "region", value: "mw" } }, { from: { field: "region", value: "484" }, to: { field: "region", value: "mx" } }, { from: { field: "region", value: "458" }, to: { field: "region", value: "my" } }, { from: { field: "region", value: "508" }, to: { field: "region", value: "mz" } }, { from: { field: "region", value: "516" }, to: { field: "region", value: "na" } }, { from: { field: "region", value: "540" }, to: { field: "region", value: "nc" } }, { from: { field: "region", value: "562" }, to: { field: "region", value: "ne" } }, { from: { field: "region", value: "574" }, to: { field: "region", value: "nf" } }, { from: { field: "region", value: "566" }, to: { field: "region", value: "ng" } }, { from: { field: "region", value: "558" }, to: { field: "region", value: "ni" } }, { from: { field: "region", value: "528" }, to: { field: "region", value: "nl" } }, { from: { field: "region", value: "578" }, to: { field: "region", value: "no" } }, { from: { field: "region", value: "524" }, to: { field: "region", value: "np" } }, { from: { field: "region", value: "520" }, to: { field: "region", value: "nr" } }, { from: { field: "region", value: "570" }, to: { field: "region", value: "nu" } }, { from: { field: "region", value: "554" }, to: { field: "region", value: "nz" } }, { from: { field: "region", value: "512" }, to: { field: "region", value: "om" } }, { from: { field: "region", value: "591" }, to: { field: "region", value: "pa" } }, { from: { field: "region", value: "604" }, to: { field: "region", value: "pe" } }, { from: { field: "region", value: "258" }, to: { field: "region", value: "pf" } }, { from: { field: "region", value: "598" }, to: { field: "region", value: "pg" } }, { from: { field: "region", value: "608" }, to: { field: "region", value: "ph" } }, { from: { field: "region", value: "586" }, to: { field: "region", value: "pk" } }, { from: { field: "region", value: "616" }, to: { field: "region", value: "pl" } }, { from: { field: "region", value: "666" }, to: { field: "region", value: "pm" } }, { from: { field: "region", value: "612" }, to: { field: "region", value: "pn" } }, { from: { field: "region", value: "630" }, to: { field: "region", value: "pr" } }, { from: { field: "region", value: "275" }, to: { field: "region", value: "ps" } }, { from: { field: "region", value: "620" }, to: { field: "region", value: "pt" } }, { from: { field: "region", value: "585" }, to: { field: "region", value: "pw" } }, { from: { field: "region", value: "600" }, to: { field: "region", value: "py" } }, { from: { field: "region", value: "634" }, to: { field: "region", value: "qa" } }, { from: { field: "region", value: "959" }, to: { field: "region", value: "qm" } }, { from: { field: "region", value: "960" }, to: { field: "region", value: "qn" } }, { from: { field: "region", value: "962" }, to: { field: "region", value: "qp" } }, { from: { field: "region", value: "963" }, to: { field: "region", value: "qq" } }, { from: { field: "region", value: "964" }, to: { field: "region", value: "qr" } }, { from: { field: "region", value: "965" }, to: { field: "region", value: "qs" } }, { from: { field: "region", value: "966" }, to: { field: "region", value: "qt" } }, { from: { field: "region", value: "967" }, to: { field: "region", value: "eu" } }, { from: { field: "region", value: "968" }, to: { field: "region", value: "qv" } }, { from: { field: "region", value: "969" }, to: { field: "region", value: "qw" } }, { from: { field: "region", value: "970" }, to: { field: "region", value: "qx" } }, { from: { field: "region", value: "971" }, to: { field: "region", value: "qy" } }, { from: { field: "region", value: "972" }, to: { field: "region", value: "qz" } }, { from: { field: "region", value: "638" }, to: { field: "region", value: "re" } }, { from: { field: "region", value: "642" }, to: { field: "region", value: "ro" } }, { from: { field: "region", value: "688" }, to: { field: "region", value: "rs" } }, { from: { field: "region", value: "643" }, to: { field: "region", value: "ru" } }, { from: { field: "region", value: "646" }, to: { field: "region", value: "rw" } }, { from: { field: "region", value: "682" }, to: { field: "region", value: "sa" } }, { from: { field: "region", value: "090" }, to: { field: "region", value: "sb" } }, { from: { field: "region", value: "690" }, to: { field: "region", value: "sc" } }, { from: { field: "region", value: "729" }, to: { field: "region", value: "sd" } }, { from: { field: "region", value: "752" }, to: { field: "region", value: "se" } }, { from: { field: "region", value: "702" }, to: { field: "region", value: "sg" } }, { from: { field: "region", value: "654" }, to: { field: "region", value: "sh" } }, { from: { field: "region", value: "705" }, to: { field: "region", value: "si" } }, { from: { field: "region", value: "744" }, to: { field: "region", value: "sj" } }, { from: { field: "region", value: "703" }, to: { field: "region", value: "sk" } }, { from: { field: "region", value: "694" }, to: { field: "region", value: "sl" } }, { from: { field: "region", value: "674" }, to: { field: "region", value: "sm" } }, { from: { field: "region", value: "686" }, to: { field: "region", value: "sn" } }, { from: { field: "region", value: "706" }, to: { field: "region", value: "so" } }, { from: { field: "region", value: "740" }, to: { field: "region", value: "sr" } }, { from: { field: "region", value: "728" }, to: { field: "region", value: "ss" } }, { from: { field: "region", value: "678" }, to: { field: "region", value: "st" } }, { from: { field: "region", value: "222" }, to: { field: "region", value: "sv" } }, { from: { field: "region", value: "534" }, to: { field: "region", value: "sx" } }, { from: { field: "region", value: "760" }, to: { field: "region", value: "sy" } }, { from: { field: "region", value: "748" }, to: { field: "region", value: "sz" } }, { from: { field: "region", value: "796" }, to: { field: "region", value: "tc" } }, { from: { field: "region", value: "148" }, to: { field: "region", value: "td" } }, { from: { field: "region", value: "260" }, to: { field: "region", value: "tf" } }, { from: { field: "region", value: "768" }, to: { field: "region", value: "tg" } }, { from: { field: "region", value: "764" }, to: { field: "region", value: "th" } }, { from: { field: "region", value: "762" }, to: { field: "region", value: "tj" } }, { from: { field: "region", value: "772" }, to: { field: "region", value: "tk" } }, { from: { field: "region", value: "626" }, to: { field: "region", value: "tl" } }, { from: { field: "region", value: "795" }, to: { field: "region", value: "tm" } }, { from: { field: "region", value: "788" }, to: { field: "region", value: "tn" } }, { from: { field: "region", value: "776" }, to: { field: "region", value: "to" } }, { from: { field: "region", value: "792" }, to: { field: "region", value: "tr" } }, { from: { field: "region", value: "780" }, to: { field: "region", value: "tt" } }, { from: { field: "region", value: "798" }, to: { field: "region", value: "tv" } }, { from: { field: "region", value: "158" }, to: { field: "region", value: "tw" } }, { from: { field: "region", value: "834" }, to: { field: "region", value: "tz" } }, { from: { field: "region", value: "804" }, to: { field: "region", value: "ua" } }, { from: { field: "region", value: "800" }, to: { field: "region", value: "ug" } }, { from: { field: "region", value: "581" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "840" }, to: { field: "region", value: "us" } }, { from: { field: "region", value: "858" }, to: { field: "region", value: "uy" } }, { from: { field: "region", value: "860" }, to: { field: "region", value: "uz" } }, { from: { field: "region", value: "336" }, to: { field: "region", value: "va" } }, { from: { field: "region", value: "670" }, to: { field: "region", value: "vc" } }, { from: { field: "region", value: "862" }, to: { field: "region", value: "ve" } }, { from: { field: "region", value: "092" }, to: { field: "region", value: "vg" } }, { from: { field: "region", value: "850" }, to: { field: "region", value: "vi" } }, { from: { field: "region", value: "704" }, to: { field: "region", value: "vn" } }, { from: { field: "region", value: "548" }, to: { field: "region", value: "vu" } }, { from: { field: "region", value: "876" }, to: { field: "region", value: "wf" } }, { from: { field: "region", value: "882" }, to: { field: "region", value: "ws" } }, { from: { field: "region", value: "973" }, to: { field: "region", value: "xa" } }, { from: { field: "region", value: "974" }, to: { field: "region", value: "xb" } }, { from: { field: "region", value: "975" }, to: { field: "region", value: "xc" } }, { from: { field: "region", value: "976" }, to: { field: "region", value: "xd" } }, { from: { field: "region", value: "977" }, to: { field: "region", value: "xe" } }, { from: { field: "region", value: "978" }, to: { field: "region", value: "xf" } }, { from: { field: "region", value: "979" }, to: { field: "region", value: "xg" } }, { from: { field: "region", value: "980" }, to: { field: "region", value: "xh" } }, { from: { field: "region", value: "981" }, to: { field: "region", value: "xi" } }, { from: { field: "region", value: "982" }, to: { field: "region", value: "xj" } }, { from: { field: "region", value: "983" }, to: { field: "region", value: "xk" } }, { from: { field: "region", value: "984" }, to: { field: "region", value: "xl" } }, { from: { field: "region", value: "985" }, to: { field: "region", value: "xm" } }, { from: { field: "region", value: "986" }, to: { field: "region", value: "xn" } }, { from: { field: "region", value: "987" }, to: { field: "region", value: "xo" } }, { from: { field: "region", value: "988" }, to: { field: "region", value: "xp" } }, { from: { field: "region", value: "989" }, to: { field: "region", value: "xq" } }, { from: { field: "region", value: "990" }, to: { field: "region", value: "xr" } }, { from: { field: "region", value: "991" }, to: { field: "region", value: "xs" } }, { from: { field: "region", value: "992" }, to: { field: "region", value: "xt" } }, { from: { field: "region", value: "993" }, to: { field: "region", value: "xu" } }, { from: { field: "region", value: "994" }, to: { field: "region", value: "xv" } }, { from: { field: "region", value: "995" }, to: { field: "region", value: "xw" } }, { from: { field: "region", value: "996" }, to: { field: "region", value: "xx" } }, { from: { field: "region", value: "997" }, to: { field: "region", value: "xy" } }, { from: { field: "region", value: "998" }, to: { field: "region", value: "xz" } }, { from: { field: "region", value: "720" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "887" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "175" }, to: { field: "region", value: "yt" } }, { from: { field: "region", value: "710" }, to: { field: "region", value: "za" } }, { from: { field: "region", value: "894" }, to: { field: "region", value: "zm" } }, { from: { field: "region", value: "716" }, to: { field: "region", value: "zw" } }, { from: { field: "region", value: "999" }, to: { field: "region", value: "zz" } }, { from: { field: "variants", value: "polytoni" }, to: { field: "variants", value: "polyton" } }, { from: { field: "variants", value: "heploc" }, to: { field: "variants", value: "alalc97" } }], Tc = { region: { 172: ["ru", "am", "az", "by", "ge", "kg", "kz", "md", "tj", "tm", "ua", "uz"], 200: ["cz", "sk"], 530: ["cw", "sx", "bq"], 532: ["cw", "sx", "bq"], 536: ["sa", "iq"], 582: ["fm", "mh", "mp", "pw"], 810: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], 830: ["je", "gg"], 890: ["rs", "me", "si", "hr", "mk", "ba"], 891: ["rs", "me"], an: ["cw", "sx", "bq"], cs: ["rs", "me"], fq: ["aq", "tf"], nt: ["sa", "iq"], pc: ["fm", "mh", "mp", "pw"], su: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], yu: ["rs", "me"], "062": ["034", "143"], ant: ["cw", "sx", "bq"], scg: ["rs", "me"], ntz: ["sa", "iq"], sun: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], yug: ["rs", "me"] } }, Ad = { aa: "aa-latn-et", aaa: "aaa-latn-ng", aab: "aab-latn-ng", aac: "aac-latn-pg", aad: "aad-latn-pg", aae: "aae-latn-it", "aae-grek": "aae-grek-it", aaf: "aaf-mlym-in", "aaf-arab": "aaf-arab-in", aag: "aag-latn-pg", aah: "aah-latn-pg", aai: "aai-latn-zz", aak: "aak-latn-zz", aal: "aal-latn-cm", aan: "aan-latn-br", aao: "aao-arab-dz", aap: "aap-latn-br", aaq: "aaq-latn-us", aas: "aas-latn-tz", aat: "aat-grek-gr", aau: "aau-latn-zz", aaw: "aaw-latn-pg", aax: "aax-latn-id", aaz: "aaz-latn-id", ab: "ab-cyrl-ge", aba: "aba-latn-ci", abb: "abb-latn-cm", abc: "abc-latn-ph", abd: "abd-latn-ph", abe: "abe-latn-ca", abf: "abf-latn-my", abg: "abg-latn-pg", abh: "abh-arab-tj", abi: "abi-latn-zz", abl: "abl-rjng-id", "abl-latn": "abl-latn-id", abm: "abm-latn-ng", abn: "abn-latn-ng", abo: "abo-latn-ng", abp: "abp-latn-ph", abq: "abq-cyrl-zz", abr: "abr-latn-gh", abs: "abs-latn-id", abt: "abt-latn-zz", abu: "abu-latn-ci", abv: "abv-arab-bh", abw: "abw-latn-pg", abx: "abx-latn-ph", aby: "aby-latn-zz", abz: "abz-latn-id", aca: "aca-latn-co", acb: "acb-latn-ng", acd: "acd-latn-zz", ace: "ace-latn-id", acf: "acf-latn-lc", ach: "ach-latn-ug", acm: "acm-arab-iq", acn: "acn-latn-cn", acp: "acp-latn-ng", acq: "acq-arab-ye", acr: "acr-latn-gt", acs: "acs-latn-br", act: "act-latn-nl", acu: "acu-latn-ec", acv: "acv-latn-us", acw: "acw-arab-sa", acx: "acx-arab-om", acy: "acy-latn-cy", "acy-arab": "acy-arab-cy", "acy-grek": "acy-grek-cy", acz: "acz-latn-sd", ada: "ada-latn-gh", adb: "adb-latn-tl", add: "add-latn-cm", ade: "ade-latn-zz", adf: "adf-arab-om", adg: "adg-latn-au", adh: "adh-latn-ug", adi: "adi-latn-in", "adi-tibt": "adi-tibt-cn", adj: "adj-latn-zz", adl: "adl-latn-in", adn: "adn-latn-id", ado: "ado-latn-pg", adp: "adp-tibt-bt", adq: "adq-latn-gh", adr: "adr-latn-id", adt: "adt-latn-au", adu: "adu-latn-ng", adw: "adw-latn-br", adx: "adx-tibt-cn", ady: "ady-cyrl-ru", adz: "adz-latn-zz", ae: "ae-avst-ir", aea: "aea-latn-au", aeb: "aeb-arab-tn", aec: "aec-arab-eg", aee: "aee-arab-af", aek: "aek-latn-nc", ael: "ael-latn-cm", aem: "aem-latn-vn", aeq: "aeq-arab-pk", aer: "aer-latn-au", aeu: "aeu-latn-cn", aew: "aew-latn-pg", aey: "aey-latn-zz", aez: "aez-latn-pg", af: "af-latn-za", afb: "afb-arab-kw", afd: "afd-latn-pg", afe: "afe-latn-ng", afh: "afh-latn-gh", afi: "afi-latn-pg", afk: "afk-latn-pg", afn: "afn-latn-ng", afo: "afo-latn-ng", afp: "afp-latn-pg", afs: "afs-latn-mx", afu: "afu-latn-gh", afz: "afz-latn-id", aga: "aga-latn-pe", agb: "agb-latn-ng", agc: "agc-latn-zz", agd: "agd-latn-zz", age: "age-latn-pg", agf: "agf-latn-id", agg: "agg-latn-zz", agh: "agh-latn-cd", agi: "agi-deva-in", agj: "agj-ethi-et", "agj-arab": "agj-arab-et", agk: "agk-latn-ph", agl: "agl-latn-pg", agm: "agm-latn-zz", agn: "agn-latn-ph", ago: "ago-latn-zz", agq: "agq-latn-cm", agr: "agr-latn-pe", ags: "ags-latn-cm", agt: "agt-latn-ph", agu: "agu-latn-gt", agv: "agv-latn-ph", agw: "agw-latn-sb", agx: "agx-cyrl-ru", agy: "agy-latn-ph", agz: "agz-latn-ph", aha: "aha-latn-zz", ahb: "ahb-latn-vu", ahg: "ahg-ethi-et", ahh: "ahh-latn-id", ahi: "ahi-latn-ci", ahk: "ahk-latn-mm", "ahk-mymr": "ahk-mymr-mm", "ahk-th": "ahk-latn-th", "ahk-thai": "ahk-thai-th", ahl: "ahl-latn-zz", ahm: "ahm-latn-ci", ahn: "ahn-latn-ng", aho: "aho-ahom-in", ahp: "ahp-latn-ci", ahr: "ahr-deva-in", ahs: "ahs-latn-ng", aht: "aht-latn-us", aia: "aia-latn-sb", aib: "aib-arab-cn", aic: "aic-latn-pg", aid: "aid-latn-au", aie: "aie-latn-pg", aif: "aif-latn-pg", aig: "aig-latn-ag", aij: "aij-hebr-il", aik: "aik-latn-ng", ail: "ail-latn-pg", aim: "aim-latn-in", ain: "ain-kana-jp", "ain-latn": "ain-latn-jp", aio: "aio-mymr-in", aip: "aip-latn-id", aiq: "aiq-arab-af", air: "air-latn-id", ait: "ait-latn-br", aiw: "aiw-latn-et", "aiw-arab": "aiw-arab-et", "aiw-ethi": "aiw-ethi-et", aix: "aix-latn-pg", aiy: "aiy-latn-cf", aja: "aja-latn-ss", ajg: "ajg-latn-zz", aji: "aji-latn-nc", ajn: "ajn-latn-au", ajp: "ajp-arab-jo", ajt: "ajt-arab-tn", ajw: "ajw-latn-ng", ajz: "ajz-latn-in", ak: "ak-latn-gh", akb: "akb-latn-id", "akb-batk": "akb-batk-id", akc: "akc-latn-id", akd: "akd-latn-ng", ake: "ake-latn-gy", akf: "akf-latn-ng", akg: "akg-latn-id", akh: "akh-latn-pg", aki: "aki-latn-pg", akk: "akk-xsux-iq", akl: "akl-latn-ph", ako: "ako-latn-sr", akp: "akp-latn-gh", akq: "akq-latn-pg", akr: "akr-latn-vu", aks: "aks-latn-tg", akt: "akt-latn-pg", aku: "aku-latn-cm", akv: "akv-cyrl-ru", akw: "akw-latn-cg", akz: "akz-latn-us", ala: "ala-latn-zz", alc: "alc-latn-cl", ald: "ald-latn-ci", ale: "ale-latn-us", alf: "alf-latn-ng", alh: "alh-latn-au", ali: "ali-latn-zz", alj: "alj-latn-ph", alk: "alk-laoo-la", all: "all-mlym-in", alm: "alm-latn-vu", aln: "aln-latn-xk", alo: "alo-latn-id", alp: "alp-latn-id", alq: "alq-latn-ca", alr: "alr-cyrl-ru", alt: "alt-cyrl-ru", alu: "alu-latn-sb", alw: "alw-ethi-et", alx: "alx-latn-pg", aly: "aly-latn-au", alz: "alz-latn-cd", am: "am-ethi-et", ama: "ama-latn-br", amb: "amb-latn-ng", amc: "amc-latn-pe", ame: "ame-latn-pe", amf: "amf-latn-et", "amf-ethi": "amf-ethi-et", amg: "amg-latn-au", ami: "ami-latn-tw", amj: "amj-latn-td", amk: "amk-latn-id", amm: "amm-latn-zz", amn: "amn-latn-zz", amo: "amo-latn-ng", amp: "amp-latn-zz", amq: "amq-latn-id", amr: "amr-latn-pe", ams: "ams-jpan-jp", amt: "amt-latn-pg", amu: "amu-latn-mx", amv: "amv-latn-id", amw: "amw-syrc-sy", "amw-arab": "amw-arab-sy", "amw-armi": "amw-armi-sy", "amw-latn": "amw-latn-sy", amx: "amx-latn-au", amy: "amy-latn-au", amz: "amz-latn-au", an: "an-latn-es", ana: "ana-latn-co", anb: "anb-latn-pe", anc: "anc-latn-zz", and: "and-latn-id", ane: "ane-latn-nc", anf: "anf-latn-gh", ang: "ang-latn-gb", anh: "anh-latn-pg", ani: "ani-cyrl-ru", anj: "anj-latn-pg", ank: "ank-latn-zz", anl: "anl-latn-mm", anm: "anm-latn-in", ann: "ann-latn-ng", ano: "ano-latn-co", anp: "anp-deva-in", anr: "anr-deva-in", ans: "ans-latn-co", ant: "ant-latn-au", anu: "anu-ethi-et", "anu-arab": "anu-arab-ss", "anu-latn": "anu-latn-ss", anv: "anv-latn-cm", anw: "anw-latn-ng", anx: "anx-latn-pg", any: "any-latn-zz", anz: "anz-latn-pg", aoa: "aoa-latn-st", aob: "aob-latn-pg", aoc: "aoc-latn-ve", aod: "aod-latn-pg", aoe: "aoe-latn-pg", aof: "aof-latn-pg", aog: "aog-latn-pg", aoi: "aoi-latn-au", aoj: "aoj-latn-zz", aok: "aok-latn-nc", aol: "aol-latn-id", aom: "aom-latn-zz", aon: "aon-latn-pg", aor: "aor-latn-vu", aos: "aos-latn-id", aot: "aot-beng-bd", "aot-latn": "aot-latn-in", aox: "aox-latn-gy", aoz: "aoz-latn-id", apb: "apb-latn-sb", apc: "apc-arab-sy", apd: "apd-arab-tg", ape: "ape-latn-zz", apf: "apf-latn-ph", apg: "apg-latn-id", aph: "aph-deva-np", api: "api-latn-br", apj: "apj-latn-us", apk: "apk-latn-us", apl: "apl-latn-us", apm: "apm-latn-us", apn: "apn-latn-br", apo: "apo-latn-pg", app: "app-latn-vu", apr: "apr-latn-zz", aps: "aps-latn-zz", apt: "apt-latn-in", apu: "apu-latn-br", apv: "apv-latn-br", apw: "apw-latn-us", apx: "apx-latn-id", apy: "apy-latn-br", apz: "apz-latn-zz", aqc: "aqc-cyrl-ru", aqd: "aqd-latn-ml", aqg: "aqg-latn-ng", aqk: "aqk-latn-ng", aqm: "aqm-latn-id", aqn: "aqn-latn-ph", aqr: "aqr-latn-nc", aqt: "aqt-latn-py", aqz: "aqz-latn-br", ar: "ar-arab-eg", arc: "arc-armi-ir", "arc-nbat": "arc-nbat-jo", "arc-palm": "arc-palm-sy", ard: "ard-latn-au", are: "are-latn-au", arh: "arh-latn-zz", ari: "ari-latn-us", arj: "arj-latn-br", ark: "ark-latn-br", arl: "arl-latn-pe", arn: "arn-latn-cl", aro: "aro-latn-bo", arp: "arp-latn-us", arq: "arq-arab-dz", arr: "arr-latn-br", ars: "ars-arab-sa", aru: "aru-latn-br", arw: "arw-latn-sr", arx: "arx-latn-br", ary: "ary-arab-ma", arz: "arz-arab-eg", as: "as-beng-in", asa: "asa-latn-tz", asb: "asb-latn-ca", asc: "asc-latn-id", ase: "ase-sgnw-us", asg: "asg-latn-zz", ash: "ash-latn-pe", asi: "asi-latn-id", asj: "asj-latn-cm", ask: "ask-arab-af", asl: "asl-latn-id", asn: "asn-latn-br", aso: "aso-latn-zz", ass: "ass-latn-cm", ast: "ast-latn-es", asu: "asu-latn-br", asv: "asv-latn-cd", asx: "asx-latn-pg", asy: "asy-latn-id", asz: "asz-latn-id", ata: "ata-latn-zz", atb: "atb-latn-cn", "atb-lisu": "atb-lisu-cn", atc: "atc-latn-pe", atd: "atd-latn-ph", ate: "ate-latn-pg", atg: "atg-latn-zz", ati: "ati-latn-ci", atj: "atj-latn-ca", atk: "atk-latn-ph", atl: "atl-latn-ph", atm: "atm-latn-ph", atn: "atn-arab-ir", ato: "ato-latn-cm", atp: "atp-latn-ph", atq: "atq-latn-id", atr: "atr-latn-br", ats: "ats-latn-us", att: "att-latn-ph", atu: "atu-latn-ss", atv: "atv-cyrl-ru", atw: "atw-latn-us", atx: "atx-latn-br", aty: "aty-latn-vu", atz: "atz-latn-ph", aua: "aua-latn-sb", auc: "auc-latn-ec", aud: "aud-latn-sb", aug: "aug-latn-bj", auh: "auh-latn-zm", aui: "aui-latn-pg", auj: "auj-arab-ly", "auj-latn": "auj-latn-ly", "auj-tfng": "auj-tfng-ly", auk: "auk-latn-pg", aul: "aul-latn-vu", aum: "aum-latn-ng", aun: "aun-latn-pg", auo: "auo-latn-ng", aup: "aup-latn-pg", auq: "auq-latn-id", aur: "aur-latn-pg", aut: "aut-latn-pf", auu: "auu-latn-id", auw: "auw-latn-id", auy: "auy-latn-zz", auz: "auz-arab-uz", av: "av-cyrl-ru", avb: "avb-latn-pg", avd: "avd-arab-ir", avi: "avi-latn-ci", avk: "avk-latn-001", avl: "avl-arab-zz", avm: "avm-latn-au", avn: "avn-latn-zz", avo: "avo-latn-br", avs: "avs-latn-pe", avt: "avt-latn-zz", avu: "avu-latn-zz", avv: "avv-latn-br", awa: "awa-deva-in", awb: "awb-latn-zz", awc: "awc-latn-ng", awe: "awe-latn-br", awg: "awg-latn-au", awh: "awh-latn-id", awi: "awi-latn-pg", awk: "awk-latn-au", awm: "awm-latn-pg", awn: "awn-ethi-et", awo: "awo-latn-zz", awr: "awr-latn-id", aws: "aws-latn-id", awt: "awt-latn-br", awu: "awu-latn-id", awv: "awv-latn-id", aww: "aww-latn-pg", awx: "awx-latn-zz", awy: "awy-latn-id", axb: "axb-latn-ar", axe: "axe-latn-au", axg: "axg-latn-br", axk: "axk-latn-cf", axl: "axl-latn-au", axm: "axm-armn-am", axx: "axx-latn-nc", ay: "ay-latn-bo", aya: "aya-latn-pg", ayb: "ayb-latn-zz", ayc: "ayc-latn-pe", ayd: "ayd-latn-au", aye: "aye-latn-ng", ayg: "ayg-latn-tg", ayh: "ayh-arab-ye", ayi: "ayi-latn-ng", ayk: "ayk-latn-ng", ayl: "ayl-arab-ly", ayn: "ayn-arab-ye", ayo: "ayo-latn-py", ayp: "ayp-arab-iq", ayq: "ayq-latn-pg", ays: "ays-latn-ph", ayt: "ayt-latn-ph", ayu: "ayu-latn-ng", ayz: "ayz-latn-id", az: "az-latn-az", "az-arab": "az-arab-ir", "az-iq": "az-arab-iq", "az-ir": "az-arab-ir", "az-ru": "az-cyrl-ru", azb: "azb-arab-ir", "azb-cyrl": "azb-cyrl-az", "azb-latn": "azb-latn-az", azd: "azd-latn-mx", azg: "azg-latn-mx", azm: "azm-latn-mx", azn: "azn-latn-mx", azo: "azo-latn-cm", azt: "azt-latn-ph", azz: "azz-latn-mx", ba: "ba-cyrl-ru", baa: "baa-latn-sb", bab: "bab-latn-gw", bac: "bac-latn-id", bae: "bae-latn-ve", baf: "baf-latn-cm", bag: "bag-latn-cm", bah: "bah-latn-bs", baj: "baj-latn-id", bal: "bal-arab-pk", ban: "ban-latn-id", bao: "bao-latn-co", bap: "bap-deva-np", bar: "bar-latn-at", bas: "bas-latn-cm", bau: "bau-latn-ng", bav: "bav-latn-zz", baw: "baw-latn-cm", bax: "bax-bamu-cm", bay: "bay-latn-id", bba: "bba-latn-zz", bbb: "bbb-latn-zz", bbc: "bbc-latn-id", bbd: "bbd-latn-zz", bbe: "bbe-latn-cd", bbf: "bbf-latn-pg", bbg: "bbg-latn-ga", bbi: "bbi-latn-cm", bbj: "bbj-latn-cm", bbk: "bbk-latn-cm", bbl: "bbl-geor-ge", bbm: "bbm-latn-cd", bbn: "bbn-latn-pg", bbo: "bbo-latn-bf", bbp: "bbp-latn-zz", bbq: "bbq-latn-cm", bbr: "bbr-latn-zz", bbs: "bbs-latn-ng", bbt: "bbt-latn-ng", bbu: "bbu-latn-ng", bbv: "bbv-latn-pg", bbw: "bbw-latn-cm", bbx: "bbx-latn-cm", bby: "bby-latn-cm", bca: "bca-latn-cn", "bca-hani": "bca-hani-cn", bcb: "bcb-latn-sn", bcd: "bcd-latn-id", bce: "bce-latn-cm", bcf: "bcf-latn-zz", bcg: "bcg-latn-gn", bch: "bch-latn-zz", bci: "bci-latn-ci", bcj: "bcj-latn-au", bck: "bck-latn-au", bcm: "bcm-latn-zz", bcn: "bcn-latn-zz", bco: "bco-latn-zz", bcp: "bcp-latn-cd", bcq: "bcq-ethi-zz", bcr: "bcr-latn-ca", bcs: "bcs-latn-ng", bct: "bct-latn-cd", bcu: "bcu-latn-zz", bcv: "bcv-latn-ng", bcw: "bcw-latn-cm", bcy: "bcy-latn-ng", bcz: "bcz-latn-sn", bda: "bda-latn-sn", bdb: "bdb-latn-id", bdc: "bdc-latn-co", bdd: "bdd-latn-zz", bde: "bde-latn-ng", bdf: "bdf-latn-pg", bdg: "bdg-latn-my", bdh: "bdh-latn-ss", bdi: "bdi-latn-sd", bdj: "bdj-latn-ss", bdk: "bdk-latn-az", bdl: "bdl-latn-id", bdm: "bdm-latn-td", bdn: "bdn-latn-cm", bdo: "bdo-latn-td", bdp: "bdp-latn-tz", bdq: "bdq-latn-vn", bdr: "bdr-latn-my", bds: "bds-latn-tz", bdt: "bdt-latn-cf", bdu: "bdu-latn-cm", bdv: "bdv-orya-in", bdw: "bdw-latn-id", bdx: "bdx-latn-id", bdy: "bdy-latn-au", bdz: "bdz-arab-pk", be: "be-cyrl-by", bea: "bea-latn-ca", "bea-cans": "bea-cans-ca", beb: "beb-latn-cm", bec: "bec-latn-cm", bed: "bed-latn-id", bee: "bee-deva-in", bef: "bef-latn-zz", beh: "beh-latn-zz", bei: "bei-latn-id", bej: "bej-arab-sd", bek: "bek-latn-pg", bem: "bem-latn-zm", beo: "beo-latn-pg", bep: "bep-latn-id", beq: "beq-latn-cg", bes: "bes-latn-td", bet: "bet-latn-zz", beu: "beu-latn-id", bev: "bev-latn-ci", bew: "bew-latn-id", bex: "bex-latn-zz", bey: "bey-latn-pg", bez: "bez-latn-tz", bfa: "bfa-latn-ss", "bfa-arab": "bfa-arab-ss", bfb: "bfb-deva-in", bfc: "bfc-latn-cn", bfd: "bfd-latn-cm", bfe: "bfe-latn-id", bff: "bff-latn-cf", bfg: "bfg-latn-id", bfh: "bfh-latn-pg", bfj: "bfj-latn-cm", bfl: "bfl-latn-cf", bfm: "bfm-latn-cm", bfn: "bfn-latn-tl", bfo: "bfo-latn-bf", bfp: "bfp-latn-cm", bfq: "bfq-taml-in", bfs: "bfs-latn-cn", "bfs-hani": "bfs-hani-cn", bft: "bft-arab-pk", bfu: "bfu-tibt-in", "bfu-takr": "bfu-takr-in", bfw: "bfw-orya-in", bfx: "bfx-latn-ph", bfy: "bfy-deva-in", bfz: "bfz-deva-in", bg: "bg-cyrl-bg", bga: "bga-latn-ng", bgb: "bgb-latn-id", bgc: "bgc-deva-in", bgd: "bgd-deva-in", bgf: "bgf-latn-cm", bgg: "bgg-latn-in", bgi: "bgi-latn-ph", bgj: "bgj-latn-cm", bgn: "bgn-arab-pk", bgo: "bgo-latn-gn", bgp: "bgp-arab-pk", bgq: "bgq-deva-in", bgr: "bgr-latn-in", bgs: "bgs-latn-ph", bgt: "bgt-latn-sb", bgu: "bgu-latn-ng", bgv: "bgv-latn-id", bgw: "bgw-deva-in", bgx: "bgx-grek-tr", bgy: "bgy-latn-id", bgz: "bgz-latn-id", bha: "bha-deva-in", bhb: "bhb-deva-in", bhc: "bhc-latn-id", bhd: "bhd-deva-in", "bhd-arab": "bhd-arab-in", "bhd-takr": "bhd-takr-in", bhe: "bhe-arab-pk", bhf: "bhf-latn-pg", bhg: "bhg-latn-zz", bhh: "bhh-cyrl-il", "bhh-hebr": "bhh-hebr-il", "bhh-latn": "bhh-latn-il", bhi: "bhi-deva-in", bhj: "bhj-deva-np", bhl: "bhl-latn-zz", bhm: "bhm-arab-om", bhn: "bhn-syrc-ge", bho: "bho-deva-in", bhp: "bhp-latn-id", bhq: "bhq-latn-id", bhr: "bhr-latn-mg", bhs: "bhs-latn-cm", bht: "bht-takr-in", "bht-deva": "bht-deva-in", "bht-latn": "bht-latn-in", bhu: "bhu-deva-in", bhv: "bhv-latn-id", bhw: "bhw-latn-id", bhy: "bhy-latn-zz", bhz: "bhz-latn-id", bi: "bi-latn-vu", bia: "bia-latn-au", bib: "bib-latn-zz", bid: "bid-latn-td", bie: "bie-latn-pg", bif: "bif-latn-gw", big: "big-latn-zz", bik: "bik-latn-ph", bil: "bil-latn-ng", bim: "bim-latn-zz", bin: "bin-latn-ng", bio: "bio-latn-zz", bip: "bip-latn-cd", biq: "biq-latn-zz", bir: "bir-latn-pg", bit: "bit-latn-pg", biu: "biu-latn-in", biv: "biv-latn-gh", biw: "biw-latn-cm", biy: "biy-deva-in", biz: "biz-latn-cd", bja: "bja-latn-cd", bjb: "bjb-latn-au", bjc: "bjc-latn-pg", bjf: "bjf-syrc-il", bjg: "bjg-latn-gw", bjh: "bjh-latn-zz", bji: "bji-ethi-zz", bjj: "bjj-deva-in", bjk: "bjk-latn-pg", bjl: "bjl-latn-pg", bjm: "bjm-arab-iq", bjn: "bjn-latn-id", bjo: "bjo-latn-zz", bjp: "bjp-latn-pg", bjr: "bjr-latn-zz", bjs: "bjs-latn-bb", bjt: "bjt-latn-sn", bju: "bju-latn-cm", bjv: "bjv-latn-td", bjw: "bjw-latn-ci", bjx: "bjx-latn-ph", bjy: "bjy-latn-au", bjz: "bjz-latn-zz", bka: "bka-latn-ng", bkc: "bkc-latn-zz", bkd: "bkd-latn-ph", bkf: "bkf-latn-cd", bkg: "bkg-latn-cf", bkh: "bkh-latn-cm", bki: "bki-latn-vu", bkj: "bkj-latn-cf", bkl: "bkl-latn-id", bkm: "bkm-latn-cm", bkn: "bkn-latn-id", bko: "bko-latn-cm", bkp: "bkp-latn-cd", bkq: "bkq-latn-zz", bkr: "bkr-latn-id", bks: "bks-latn-ph", bkt: "bkt-latn-cd", bku: "bku-latn-ph", bkv: "bkv-latn-zz", bkw: "bkw-latn-cg", bkx: "bkx-latn-tl", bky: "bky-latn-ng", bkz: "bkz-latn-id", bla: "bla-latn-ca", blb: "blb-latn-sb", blc: "blc-latn-ca", bld: "bld-latn-id", ble: "ble-latn-gw", blf: "blf-latn-id", blg: "blg-latn-my", blh: "blh-latn-lr", bli: "bli-latn-cd", blj: "blj-latn-id", blk: "blk-mymr-mm", blm: "blm-latn-ss", bln: "bln-latn-ph", blo: "blo-latn-bj", blp: "blp-latn-sb", blq: "blq-latn-pg", blr: "blr-latn-cn", "blr-tale": "blr-tale-cn", "blr-thai": "blr-thai-th", bls: "bls-latn-id", blt: "blt-tavt-vn", blv: "blv-latn-ao", blw: "blw-latn-ph", blx: "blx-latn-ph", bly: "bly-latn-bj", blz: "blz-latn-id", bm: "bm-latn-ml", bma: "bma-latn-ng", bmb: "bmb-latn-cd", bmc: "bmc-latn-pg", bmd: "bmd-latn-gn", bme: "bme-latn-cf", bmf: "bmf-latn-sl", bmg: "bmg-latn-cd", bmh: "bmh-latn-zz", bmi: "bmi-latn-td", bmj: "bmj-deva-np", bmk: "bmk-latn-zz", bml: "bml-latn-cd", bmm: "bmm-latn-mg", bmn: "bmn-latn-pg", bmo: "bmo-latn-cm", bmp: "bmp-latn-pg", bmq: "bmq-latn-ml", bmr: "bmr-latn-co", bms: "bms-latn-ne", bmu: "bmu-latn-zz", bmv: "bmv-latn-cm", bmw: "bmw-latn-cg", bmx: "bmx-latn-pg", bmz: "bmz-latn-pg", bn: "bn-beng-bd", bna: "bna-latn-id", bnb: "bnb-latn-my", bnc: "bnc-latn-ph", bnd: "bnd-latn-id", bne: "bne-latn-id", bnf: "bnf-latn-id", bng: "bng-latn-zz", bni: "bni-latn-cd", bnj: "bnj-latn-ph", bnk: "bnk-latn-vu", bnm: "bnm-latn-zz", bnn: "bnn-latn-tw", bno: "bno-latn-ph", bnp: "bnp-latn-zz", bnq: "bnq-latn-id", bnr: "bnr-latn-vu", bns: "bns-deva-in", bnu: "bnu-latn-id", bnv: "bnv-latn-id", bnw: "bnw-latn-pg", bnx: "bnx-latn-cd", bny: "bny-latn-my", bnz: "bnz-latn-cm", bo: "bo-tibt-cn", boa: "boa-latn-pe", bob: "bob-latn-ke", boe: "boe-latn-cm", bof: "bof-latn-bf", boh: "boh-latn-cd", boj: "boj-latn-zz", bok: "bok-latn-cg", bol: "bol-latn-ng", bom: "bom-latn-zz", bon: "bon-latn-zz", boo: "boo-latn-ml", bop: "bop-latn-pg", boq: "boq-latn-pg", bor: "bor-latn-br", bot: "bot-latn-ss", bou: "bou-latn-tz", bov: "bov-latn-gh", bow: "bow-latn-pg", box: "box-latn-bf", boy: "boy-latn-cf", boz: "boz-latn-ml", "boz-arab": "boz-arab-ml", bpa: "bpa-latn-vu", bpc: "bpc-latn-cm", bpd: "bpd-latn-cf", bpe: "bpe-latn-pg", bpg: "bpg-latn-id", bph: "bph-cyrl-ru", bpi: "bpi-latn-pg", bpj: "bpj-latn-cd", bpk: "bpk-latn-nc", bpl: "bpl-latn-au", bpm: "bpm-latn-pg", bpo: "bpo-latn-id", bpp: "bpp-latn-id", bpq: "bpq-latn-id", bpr: "bpr-latn-ph", bps: "bps-latn-ph", bpt: "bpt-latn-au", bpu: "bpu-latn-pg", bpv: "bpv-latn-id", bpw: "bpw-latn-pg", bpx: "bpx-deva-in", bpy: "bpy-beng-in", bpz: "bpz-latn-id", bqa: "bqa-latn-bj", bqb: "bqb-latn-id", bqc: "bqc-latn-zz", bqd: "bqd-latn-cm", bqf: "bqf-latn-gn", "bqf-arab": "bqf-arab-gn", bqg: "bqg-latn-tg", bqi: "bqi-arab-ir", bqj: "bqj-latn-sn", bqk: "bqk-latn-cf", bql: "bql-latn-pg", bqm: "bqm-latn-cm", bqo: "bqo-latn-cm", bqp: "bqp-latn-zz", bqq: "bqq-latn-id", bqr: "bqr-latn-id", bqs: "bqs-latn-pg", bqt: "bqt-latn-cm", bqu: "bqu-latn-cd", bqv: "bqv-latn-ci", bqw: "bqw-latn-ng", bqx: "bqx-latn-ng", bqz: "bqz-latn-cm", br: "br-latn-fr", bra: "bra-deva-in", brb: "brb-khmr-kh", "brb-laoo": "brb-laoo-la", "brb-latn": "brb-latn-vn", brc: "brc-latn-gy", brd: "brd-deva-np", brf: "brf-latn-cd", brg: "brg-latn-bo", brh: "brh-arab-pk", bri: "bri-latn-cm", brj: "brj-latn-vu", brk: "brk-arab-sd", brl: "brl-latn-bw", brm: "brm-latn-cd", brn: "brn-latn-cr", brp: "brp-latn-id", brq: "brq-latn-pg", brr: "brr-latn-sb", brs: "brs-latn-id", brt: "brt-latn-ng", bru: "bru-latn-vn", "bru-laoo": "bru-laoo-la", "bru-thai": "bru-thai-la", brv: "brv-laoo-la", brx: "brx-deva-in", bry: "bry-latn-pg", brz: "brz-latn-zz", bs: "bs-latn-ba", bsa: "bsa-latn-id", bsb: "bsb-latn-bn", bsc: "bsc-latn-sn", bse: "bse-latn-cm", bsf: "bsf-latn-ng", bsh: "bsh-arab-af", bsi: "bsi-latn-cm", bsj: "bsj-latn-zz", bsk: "bsk-arab-pk", "bsk-latn": "bsk-latn-pk", bsl: "bsl-latn-ng", bsm: "bsm-latn-id", bsn: "bsn-latn-co", bso: "bso-latn-td", bsp: "bsp-latn-gn", bsq: "bsq-bass-lr", bsr: "bsr-latn-ng", bss: "bss-latn-cm", bst: "bst-ethi-zz", bsu: "bsu-latn-id", bsv: "bsv-latn-gn", "bsv-arab": "bsv-arab-gn", bsw: "bsw-latn-et", "bsw-ethi": "bsw-ethi-et", bsx: "bsx-latn-ng", bsy: "bsy-latn-my", bta: "bta-latn-ng", btc: "btc-latn-cm", btd: "btd-batk-id", bte: "bte-latn-ng", btf: "btf-latn-td", btg: "btg-latn-ci", bth: "bth-latn-my", bti: "bti-latn-id", btj: "btj-latn-id", btm: "btm-batk-id", btn: "btn-latn-ph", bto: "bto-latn-ph", btp: "btp-latn-pg", btq: "btq-latn-my", btr: "btr-latn-vu", bts: "bts-latn-id", "bts-batk": "bts-batk-id", btt: "btt-latn-zz", btu: "btu-latn-ng", btv: "btv-deva-pk", btw: "btw-latn-ph", btx: "btx-latn-id", "btx-batk": "btx-batk-id", bty: "bty-latn-id", btz: "btz-latn-id", bua: "bua-cyrl-ru", bub: "bub-latn-td", buc: "buc-latn-yt", bud: "bud-latn-zz", bue: "bue-latn-ca", buf: "buf-latn-cd", bug: "bug-latn-id", buh: "buh-latn-cn", bui: "bui-latn-cg", buj: "buj-latn-ng", buk: "buk-latn-zz", bum: "bum-latn-cm", bun: "bun-latn-sl", buo: "buo-latn-zz", bup: "bup-latn-id", buq: "buq-latn-pg", bus: "bus-latn-zz", but: "but-latn-pg", buu: "buu-latn-zz", buv: "buv-latn-pg", buw: "buw-latn-ga", bux: "bux-latn-ng", buy: "buy-latn-sl", buz: "buz-latn-ng", bva: "bva-latn-td", bvb: "bvb-latn-gq", bvc: "bvc-latn-sb", bvd: "bvd-latn-sb", bve: "bve-latn-id", bvf: "bvf-latn-td", bvg: "bvg-latn-cm", bvh: "bvh-latn-ng", bvi: "bvi-latn-ss", bvj: "bvj-latn-ng", bvk: "bvk-latn-id", bvm: "bvm-latn-cm", bvn: "bvn-latn-pg", bvo: "bvo-latn-td", bvq: "bvq-latn-cf", bvr: "bvr-latn-au", bvt: "bvt-latn-id", bvu: "bvu-latn-id", bvv: "bvv-latn-ve", bvw: "bvw-latn-ng", bvx: "bvx-latn-cg", bvy: "bvy-latn-ph", bvz: "bvz-latn-id", bwa: "bwa-latn-nc", bwb: "bwb-latn-fj", bwc: "bwc-latn-zm", bwd: "bwd-latn-zz", bwe: "bwe-mymr-mm", "bwe-latn": "bwe-latn-mm", bwf: "bwf-latn-pg", bwg: "bwg-latn-mz", bwh: "bwh-latn-cm", bwi: "bwi-latn-ve", bwj: "bwj-latn-bf", bwk: "bwk-latn-pg", bwl: "bwl-latn-cd", bwm: "bwm-latn-pg", bwo: "bwo-latn-et", "bwo-ethi": "bwo-ethi-et", bwp: "bwp-latn-id", bwq: "bwq-latn-bf", bwr: "bwr-latn-zz", bws: "bws-latn-cd", bwt: "bwt-latn-cm", bwu: "bwu-latn-gh", bww: "bww-latn-cd", bwx: "bwx-latn-cn", bwy: "bwy-latn-bf", bwz: "bwz-latn-cg", bxa: "bxa-latn-sb", bxb: "bxb-latn-ss", bxc: "bxc-latn-gq", bxf: "bxf-latn-pg", bxg: "bxg-latn-cd", bxh: "bxh-latn-zz", bxi: "bxi-latn-au", bxj: "bxj-latn-au", bxl: "bxl-latn-bf", bxm: "bxm-cyrl-mn", "bxm-latn": "bxm-latn-mn", "bxm-mong": "bxm-mong-mn", bxn: "bxn-latn-au", bxo: "bxo-latn-ng", bxp: "bxp-latn-cm", bxq: "bxq-latn-ng", bxs: "bxs-latn-cm", bxu: "bxu-mong-cn", "bxu-cyrl": "bxu-cyrl-cn", "bxu-latn": "bxu-latn-cn", bxv: "bxv-latn-td", bxw: "bxw-latn-ml", bxz: "bxz-latn-pg", bya: "bya-latn-ph", byb: "byb-latn-cm", byc: "byc-latn-ng", byd: "byd-latn-id", bye: "bye-latn-zz", byf: "byf-latn-ng", byh: "byh-deva-np", byi: "byi-latn-cd", byj: "byj-latn-ng", byk: "byk-latn-cn", byl: "byl-latn-id", bym: "bym-latn-au", byn: "byn-ethi-er", byp: "byp-latn-ng", byr: "byr-latn-zz", bys: "bys-latn-zz", byv: "byv-latn-cm", byw: "byw-deva-np", byx: "byx-latn-zz", byz: "byz-latn-pg", bza: "bza-latn-zz", bzb: "bzb-latn-id", bzc: "bzc-latn-mg", bzd: "bzd-latn-cr", bze: "bze-latn-ml", bzf: "bzf-latn-zz", bzh: "bzh-latn-zz", bzi: "bzi-thai-th", bzj: "bzj-latn-bz", bzk: "bzk-latn-ni", bzl: "bzl-latn-id", bzm: "bzm-latn-cd", bzn: "bzn-latn-id", bzo: "bzo-latn-cd", bzp: "bzp-latn-id", bzq: "bzq-latn-id", bzr: "bzr-latn-au", bzt: "bzt-latn-001", bzu: "bzu-latn-id", bzv: "bzv-latn-cm", bzw: "bzw-latn-zz", bzx: "bzx-latn-ml", bzy: "bzy-latn-ng", bzz: "bzz-latn-ng", ca: "ca-latn-es", caa: "caa-latn-gt", cab: "cab-latn-hn", cac: "cac-latn-gt", cad: "cad-latn-us", cae: "cae-latn-sn", caf: "caf-latn-ca", "caf-cans": "caf-cans-ca", cag: "cag-latn-py", cah: "cah-latn-pe", caj: "caj-latn-ar", cak: "cak-latn-gt", cal: "cal-latn-mp", cam: "cam-latn-nc", can: "can-latn-zz", cao: "cao-latn-bo", cap: "cap-latn-bo", caq: "caq-latn-in", car: "car-latn-ve", cas: "cas-latn-bo", cav: "cav-latn-bo", caw: "caw-latn-bo", cax: "cax-latn-bo", cay: "cay-latn-ca", caz: "caz-latn-bo", cbb: "cbb-latn-co", cbc: "cbc-latn-co", cbd: "cbd-latn-co", cbg: "cbg-latn-co", cbi: "cbi-latn-ec", cbj: "cbj-latn-zz", cbk: "cbk-latn-ph", "cbk-brai": "cbk-brai-ph", cbl: "cbl-latn-mm", cbn: "cbn-thai-th", cbo: "cbo-latn-ng", cbq: "cbq-latn-ng", cbr: "cbr-latn-pe", cbs: "cbs-latn-pe", cbt: "cbt-latn-pe", cbu: "cbu-latn-pe", cbv: "cbv-latn-co", cbw: "cbw-latn-ph", cby: "cby-latn-co", ccc: "ccc-latn-pe", ccd: "ccd-latn-br", cce: "cce-latn-mz", ccg: "ccg-latn-ng", cch: "cch-latn-ng", ccj: "ccj-latn-gw", ccl: "ccl-latn-tz", ccm: "ccm-latn-my", cco: "cco-latn-mx", ccp: "ccp-cakm-bd", ccr: "ccr-latn-sv", cde: "cde-telu-in", cdf: "cdf-latn-in", "cdf-beng": "cdf-beng-in", cdh: "cdh-deva-in", "cdh-takr": "cdh-takr-in", cdi: "cdi-gujr-in", cdj: "cdj-deva-in", cdm: "cdm-deva-np", "cdm-latn": "cdm-latn-np", cdo: "cdo-hans-cn", "cdo-hant": "cdo-hant-cn", "cdo-latn": "cdo-latn-cn", cdr: "cdr-latn-ng", cdz: "cdz-beng-in", ce: "ce-cyrl-ru", cea: "cea-latn-us", ceb: "ceb-latn-ph", ceg: "ceg-latn-py", cek: "cek-latn-mm", cen: "cen-latn-ng", cet: "cet-latn-ng", cey: "cey-latn-mm", cfa: "cfa-latn-zz", cfd: "cfd-latn-ng", cfg: "cfg-latn-ng", cfm: "cfm-latn-mm", "cfm-beng": "cfm-beng-in", cga: "cga-latn-pg", cgc: "cgc-latn-ph", cgg: "cgg-latn-ug", cgk: "cgk-tibt-bt", ch: "ch-latn-gu", chb: "chb-latn-co", chd: "chd-latn-mx", chf: "chf-latn-mx", chg: "chg-arab-tm", chh: "chh-latn-us", chj: "chj-latn-mx", chk: "chk-latn-fm", chl: "chl-latn-us", chm: "chm-cyrl-ru", chn: "chn-latn-us", "chn-dupl": "chn-dupl-us", cho: "cho-latn-us", chp: "chp-latn-ca", chq: "chq-latn-mx", chr: "chr-cher-us", cht: "cht-latn-pe", chw: "chw-latn-mz", chx: "chx-deva-np", chy: "chy-latn-us", chz: "chz-latn-mx", cia: "cia-latn-id", "cia-arab": "cia-arab-id", "cia-hang": "cia-hang-id", cib: "cib-latn-bj", cic: "cic-latn-us", cie: "cie-latn-ng", cih: "cih-deva-in", cim: "cim-latn-it", cin: "cin-latn-br", cip: "cip-latn-mx", cir: "cir-latn-nc", ciw: "ciw-latn-us", "ciw-cans": "ciw-cans-us", ciy: "ciy-latn-ve", cja: "cja-arab-kh", cje: "cje-latn-vn", cjh: "cjh-latn-us", cji: "cji-cyrl-ru", cjk: "cjk-latn-ao", cjm: "cjm-cham-vn", cjn: "cjn-latn-pg", cjo: "cjo-latn-pe", cjp: "cjp-latn-cr", cjs: "cjs-latn-ru", "cjs-cyrl": "cjs-cyrl-ru", cjv: "cjv-latn-zz", cjy: "cjy-hans-cn", "cjy-hant": "cjy-hant-cn", ckb: "ckb-arab-iq", ckl: "ckl-latn-zz", ckm: "ckm-latn-hr", "ckm-glag": "ckm-glag-hr", ckn: "ckn-latn-mm", cko: "cko-latn-zz", ckq: "ckq-latn-td", ckr: "ckr-latn-pg", cks: "cks-latn-nc", ckt: "ckt-cyrl-ru", cku: "cku-latn-us", ckv: "ckv-latn-tw", ckx: "ckx-latn-cm", cky: "cky-latn-zz", ckz: "ckz-latn-gt", cla: "cla-latn-zz", clc: "clc-latn-ca", cle: "cle-latn-mx", clh: "clh-arab-pk", cli: "cli-latn-gh", clj: "clj-latn-mm", clk: "clk-latn-in", "clk-tibt": "clk-tibt-cn", cll: "cll-latn-gh", clm: "clm-latn-us", clo: "clo-latn-mx", clt: "clt-latn-mm", clu: "clu-latn-ph", clw: "clw-cyrl-ru", cly: "cly-latn-mx", cma: "cma-latn-vn", cme: "cme-latn-zz", cmg: "cmg-soyo-mn", cmi: "cmi-latn-co", cml: "cml-latn-id", cmo: "cmo-latn-vn", "cmo-kh": "cmo-latn-kh", "cmo-khmr": "cmo-khmr-kh", cmr: "cmr-latn-mm", cms: "cms-latn-it", cmt: "cmt-latn-za", cna: "cna-tibt-in", cnb: "cnb-latn-mm", cnc: "cnc-latn-vn", cng: "cng-latn-cn", cnh: "cnh-latn-mm", cni: "cni-latn-pe", cnk: "cnk-latn-mm", cnl: "cnl-latn-mx", cnp: "cnp-hans-cn", "cnp-hant": "cnp-hant-cn", cnq: "cnq-latn-cm", cns: "cns-latn-id", cnt: "cnt-latn-mx", cnw: "cnw-latn-mm", cnx: "cnx-latn-gb", co: "co-latn-fr", coa: "coa-latn-au", cob: "cob-latn-mx", coc: "coc-latn-mx", cod: "cod-latn-pe", coe: "coe-latn-co", cof: "cof-latn-ec", cog: "cog-thai-th", coh: "coh-latn-ke", coj: "coj-latn-mx", cok: "cok-latn-mx", col: "col-latn-us", com: "com-latn-us", coo: "coo-latn-ca", cop: "cop-copt-eg", coq: "coq-latn-us", cot: "cot-latn-pe", cou: "cou-latn-sn", cox: "cox-latn-pe", coz: "coz-latn-mx", cpa: "cpa-latn-mx", cpb: "cpb-latn-pe", cpc: "cpc-latn-pe", cpg: "cpg-grek-gr", cpi: "cpi-latn-nr", cpn: "cpn-latn-gh", cpo: "cpo-latn-bf", cps: "cps-latn-ph", cpu: "cpu-latn-pe", cpx: "cpx-latn-cn", cpy: "cpy-latn-pe", cqd: "cqd-latn-cn", cr: "cr-cans-ca", crb: "crb-latn-vc", crc: "crc-latn-vu", crd: "crd-latn-us", crf: "crf-latn-co", crg: "crg-latn-ca", crh: "crh-cyrl-ua", cri: "cri-latn-st", crj: "crj-cans-ca", "crj-latn": "crj-latn-ca", crk: "crk-cans-ca", crl: "crl-cans-ca", crm: "crm-cans-ca", crn: "crn-latn-mx", cro: "cro-latn-us", crq: "crq-latn-ar", crs: "crs-latn-sc", crt: "crt-latn-ar", crv: "crv-latn-in", crw: "crw-latn-vn", crx: "crx-latn-ca", "crx-cans": "crx-cans-ca", cry: "cry-latn-ng", crz: "crz-latn-us", cs: "cs-latn-cz", csa: "csa-latn-mx", csb: "csb-latn-pl", csh: "csh-mymr-mm", "csh-latn": "csh-latn-mm", csj: "csj-latn-mm", csk: "csk-latn-sn", csm: "csm-latn-us", cso: "cso-latn-mx", csp: "csp-hans-cn", "csp-hant": "csp-hant-cn", css: "css-latn-us", cst: "cst-latn-us", csv: "csv-latn-mm", csw: "csw-cans-ca", csy: "csy-latn-mm", csz: "csz-latn-us", cta: "cta-latn-mx", ctc: "ctc-latn-us", ctd: "ctd-pauc-mm", cte: "cte-latn-mx", ctg: "ctg-beng-bd", "ctg-arab": "ctg-arab-bd", "ctg-latn": "ctg-latn-bd", cth: "cth-latn-mm", ctl: "ctl-latn-mx", ctm: "ctm-latn-us", ctn: "ctn-deva-np", cto: "cto-latn-co", ctp: "ctp-latn-mx", cts: "cts-latn-ph", ctt: "ctt-taml-in", ctu: "ctu-latn-mx", ctz: "ctz-latn-mx", cu: "cu-cyrl-ru", "cu-glag": "cu-glag-bg", cua: "cua-latn-vn", cub: "cub-latn-co", cuc: "cuc-latn-mx", cuh: "cuh-latn-ke", cui: "cui-latn-co", cuj: "cuj-latn-pe", cuk: "cuk-latn-pa", cul: "cul-latn-br", cuo: "cuo-latn-ve", cup: "cup-latn-us", cut: "cut-latn-mx", cuu: "cuu-lana-cn", cuv: "cuv-latn-cm", cux: "cux-latn-mx", cv: "cv-cyrl-ru", cvg: "cvg-latn-in", "cvg-tibt": "cvg-tibt-in", cvn: "cvn-latn-mx", cwa: "cwa-latn-tz", cwb: "cwb-latn-mz", cwe: "cwe-latn-tz", cwg: "cwg-latn-my", cwt: "cwt-latn-sn", cy: "cy-latn-gb", cya: "cya-latn-mx", cyb: "cyb-latn-bo", cyo: "cyo-latn-ph", czh: "czh-hans-cn", "czh-hant": "czh-hant-cn", czk: "czk-hebr-cz", czn: "czn-latn-mx", czt: "czt-latn-mm", da: "da-latn-dk", daa: "daa-latn-td", dac: "dac-latn-pg", dad: "dad-latn-zz", dae: "dae-latn-cm", daf: "daf-latn-ci", dag: "dag-latn-zz", dah: "dah-latn-zz", dai: "dai-latn-td", daj: "daj-latn-sd", dak: "dak-latn-us", dal: "dal-latn-ke", dam: "dam-latn-ng", dao: "dao-latn-mm", daq: "daq-deva-in", dar: "dar-cyrl-ru", das: "das-latn-ci", dau: "dau-latn-td", dav: "dav-latn-ke", daw: "daw-latn-ph", dax: "dax-latn-au", daz: "daz-latn-id", dba: "dba-latn-ml", dbb: "dbb-latn-ng", dbd: "dbd-latn-zz", dbe: "dbe-latn-id", dbf: "dbf-latn-id", dbg: "dbg-latn-ml", dbi: "dbi-latn-ng", dbj: "dbj-latn-my", "dbj-arab": "dbj-arab-my", dbl: "dbl-latn-au", dbm: "dbm-latn-ng", dbn: "dbn-latn-id", dbo: "dbo-latn-ng", dbp: "dbp-latn-ng", dbq: "dbq-latn-zz", dbt: "dbt-latn-ml", dbu: "dbu-latn-ml", dbv: "dbv-latn-ng", dbw: "dbw-latn-ml", dby: "dby-latn-pg", dcc: "dcc-arab-in", dcr: "dcr-latn-vi", dda: "dda-latn-au", ddd: "ddd-latn-ss", dde: "dde-latn-cg", ddg: "ddg-latn-tl", ddi: "ddi-latn-pg", ddj: "ddj-latn-au", ddn: "ddn-latn-zz", ddo: "ddo-cyrl-ru", ddr: "ddr-latn-au", dds: "dds-latn-ml", ddw: "ddw-latn-id", de: "de-latn-de", dec: "dec-latn-sd", ded: "ded-latn-zz", dee: "dee-latn-lr", def: "def-arab-ir", deg: "deg-latn-ng", deh: "deh-arab-pk", dei: "dei-latn-id", dek: "dek-latn-cm", del: "del-latn-us", dem: "dem-latn-id", den: "den-latn-ca", deq: "deq-latn-cf", der: "der-beng-in", "der-latn": "der-latn-in", des: "des-latn-br", dev: "dev-latn-pg", dez: "dez-latn-cd", dga: "dga-latn-zz", dgb: "dgb-latn-ml", dgc: "dgc-latn-ph", dgd: "dgd-latn-bf", dge: "dge-latn-pg", dgg: "dgg-latn-pg", dgh: "dgh-latn-zz", dgi: "dgi-latn-zz", dgk: "dgk-latn-cf", dgl: "dgl-arab-zz", dgn: "dgn-latn-au", dgr: "dgr-latn-ca", dgs: "dgs-latn-bf", dgt: "dgt-latn-au", dgw: "dgw-latn-au", dgx: "dgx-latn-pg", dgz: "dgz-latn-zz", dhg: "dhg-latn-au", dhi: "dhi-deva-np", dhl: "dhl-latn-au", dhm: "dhm-latn-ao", dhn: "dhn-gujr-in", dho: "dho-deva-in", dhr: "dhr-latn-au", dhs: "dhs-latn-tz", dhu: "dhu-latn-au", dhv: "dhv-latn-nc", dhw: "dhw-deva-np", dhx: "dhx-latn-au", dia: "dia-latn-zz", dib: "dib-latn-ss", dic: "dic-latn-ci", did: "did-latn-ss", dif: "dif-latn-au", dig: "dig-latn-ke", dih: "dih-latn-mx", dii: "dii-latn-cm", dij: "dij-latn-id", dil: "dil-latn-sd", din: "din-latn-ss", "din-arab": "din-arab-ss", dio: "dio-latn-ng", dip: "dip-latn-ss", dir: "dir-latn-ng", dis: "dis-latn-in", "dis-beng": "dis-beng-in", diu: "diu-latn-na", diw: "diw-latn-ss", dix: "dix-latn-vu", diy: "diy-latn-id", diz: "diz-latn-cd", dja: "dja-latn-au", djb: "djb-latn-au", djc: "djc-latn-td", djd: "djd-latn-au", dje: "dje-latn-ne", djf: "djf-latn-au", dji: "dji-latn-au", djj: "djj-latn-au", djk: "djk-latn-sr", djm: "djm-latn-ml", djn: "djn-latn-au", djo: "djo-latn-id", djr: "djr-latn-au", dju: "dju-latn-pg", djw: "djw-latn-au", dka: "dka-tibt-bt", dkg: "dkg-latn-ng", dkk: "dkk-latn-id", dkr: "dkr-latn-my", dks: "dks-latn-ss", dkx: "dkx-latn-cm", dlg: "dlg-cyrl-ru", dlm: "dlm-latn-hr", dln: "dln-latn-in", dma: "dma-latn-ga", dmb: "dmb-latn-ml", dmc: "dmc-latn-pg", dmd: "dmd-latn-au", dme: "dme-latn-cm", dmf: "dmf-medf-ng", dmg: "dmg-latn-my", dmk: "dmk-arab-pk", dml: "dml-arab-pk", dmm: "dmm-latn-cm", dmo: "dmo-latn-cm", dmr: "dmr-latn-id", dms: "dms-latn-id", dmu: "dmu-latn-id", dmv: "dmv-latn-my", dmw: "dmw-latn-au", dmx: "dmx-latn-mz", dmy: "dmy-latn-id", dna: "dna-latn-id", dnd: "dnd-latn-pg", dne: "dne-latn-tz", dng: "dng-cyrl-kg", "dng-arab": "dng-arab-kg", dni: "dni-latn-id", dnj: "dnj-latn-ci", dnk: "dnk-latn-id", dnn: "dnn-latn-bf", dno: "dno-latn-cd", dnr: "dnr-latn-pg", dnt: "dnt-latn-id", dnu: "dnu-mymr-mm", dnv: "dnv-mymr-mm", dnw: "dnw-latn-id", dny: "dny-latn-br", doa: "doa-latn-pg", dob: "dob-latn-zz", doc: "doc-latn-cn", doe: "doe-latn-tz", dof: "dof-latn-pg", doh: "doh-latn-ng", doi: "doi-deva-in", dok: "dok-latn-id", dol: "dol-latn-pg", don: "don-latn-pg", doo: "doo-latn-cd", dop: "dop-latn-zz", dor: "dor-latn-sb", dos: "dos-latn-bf", dot: "dot-latn-ng", dov: "dov-latn-zw", dow: "dow-latn-zz", dox: "dox-ethi-et", doy: "doy-latn-gh", dpp: "dpp-latn-my", drc: "drc-latn-pt", dre: "dre-tibt-np", drg: "drg-latn-my", drh: "drh-mong-cn", dri: "dri-latn-zz", drl: "drl-latn-au", drn: "drn-latn-id", dro: "dro-latn-my", drq: "drq-deva-np", drs: "drs-ethi-zz", drt: "drt-latn-nl", dru: "dru-latn-tw", dry: "dry-deva-np", dsb: "dsb-latn-de", dsh: "dsh-latn-ke", dsi: "dsi-latn-td", dsn: "dsn-latn-id", dso: "dso-orya-in", dsq: "dsq-latn-ml", "dsq-arab": "dsq-arab-ml", dta: "dta-latn-cn", "dta-cyrl": "dta-cyrl-cn", "dta-hans": "dta-hans-cn", dtb: "dtb-latn-my", dtd: "dtd-latn-ca", dth: "dth-latn-au", dti: "dti-latn-ml", dtk: "dtk-latn-ml", dtm: "dtm-latn-ml", dto: "dto-latn-ml", dtp: "dtp-latn-my", dtr: "dtr-latn-my", dts: "dts-latn-zz", dtt: "dtt-latn-ml", dtu: "dtu-latn-ml", dty: "dty-deva-np", dua: "dua-latn-cm", dub: "dub-gujr-in", duc: "duc-latn-zz", dud: "dud-latn-zz", due: "due-latn-ph", duf: "duf-latn-nc", dug: "dug-latn-zz", duh: "duh-deva-in", "duh-gujr": "duh-gujr-in", dui: "dui-latn-pg", duk: "duk-latn-pg", dul: "dul-latn-ph", dum: "dum-latn-nl", dun: "dun-latn-id", duo: "duo-latn-ph", dup: "dup-latn-id", duq: "duq-latn-id", dur: "dur-latn-cm", dus: "dus-deva-np", duu: "duu-latn-cn", duv: "duv-latn-id", duw: "duw-latn-id", dux: "dux-latn-ml", duy: "duy-latn-ph", duz: "duz-latn-cm", dv: "dv-thaa-mv", dva: "dva-latn-zz", dwa: "dwa-latn-ng", dwk: "dwk-orya-in", dwr: "dwr-latn-et", "dwr-ethi": "dwr-ethi-et", dws: "dws-latn-001", dwu: "dwu-latn-au", dww: "dww-latn-zz", dwy: "dwy-latn-au", dwz: "dwz-deva-np", dya: "dya-latn-bf", dyb: "dyb-latn-au", dyd: "dyd-latn-au", dyg: "dyg-latn-ph", dyi: "dyi-latn-ci", dym: "dym-latn-ml", dyn: "dyn-latn-au", dyo: "dyo-latn-sn", dyu: "dyu-latn-bf", dyy: "dyy-latn-au", dz: "dz-tibt-bt", dza: "dza-latn-ng", dze: "dze-latn-au", dzg: "dzg-latn-zz", dzl: "dzl-tibt-bt", dzn: "dzn-latn-cd", eaa: "eaa-latn-au", ebc: "ebc-latn-id", ebg: "ebg-latn-ng", ebk: "ebk-latn-ph", ebo: "ebo-latn-cg", ebr: "ebr-latn-ci", ebu: "ebu-latn-ke", ecr: "ecr-grek-gr", ecy: "ecy-cprt-cy", ee: "ee-latn-gh", efa: "efa-latn-ng", efe: "efe-latn-cd", efi: "efi-latn-ng", ega: "ega-latn-ci", egl: "egl-latn-it", egm: "egm-latn-tz", ego: "ego-latn-ng", egy: "egy-egyp-eg", ehu: "ehu-latn-ng", eip: "eip-latn-id", eit: "eit-latn-pg", eiv: "eiv-latn-pg", eja: "eja-latn-gw", eka: "eka-latn-zz", eke: "eke-latn-ng", ekg: "ekg-latn-id", eki: "eki-latn-ng", ekl: "ekl-latn-bd", ekm: "ekm-latn-cm", eko: "eko-latn-mz", "eko-arab": "eko-arab-mz", ekp: "ekp-latn-ng", ekr: "ekr-latn-ng", eky: "eky-kali-mm", el: "el-grek-gr", ele: "ele-latn-pg", elk: "elk-latn-pg", elm: "elm-latn-ng", elo: "elo-latn-ke", elu: "elu-latn-pg", ema: "ema-latn-zz", emb: "emb-latn-id", eme: "eme-latn-gf", emg: "emg-deva-np", emi: "emi-latn-zz", emm: "emm-latn-mx", emn: "emn-latn-cm", emp: "emp-latn-pa", ems: "ems-latn-us", "ems-cyrl": "ems-cyrl-us", emu: "emu-deva-in", emw: "emw-latn-id", emx: "emx-latn-fr", emz: "emz-latn-cm", en: "en-latn-us", "en-shaw": "en-shaw-gb", ena: "ena-latn-pg", enb: "enb-latn-ke", enc: "enc-latn-vn", end: "end-latn-id", enf: "enf-cyrl-ru", enh: "enh-cyrl-ru", enl: "enl-latn-py", enm: "enm-latn-gb", enn: "enn-latn-zz", eno: "eno-latn-id", enq: "enq-latn-zz", enr: "enr-latn-id", env: "env-latn-ng", enw: "enw-latn-ng", enx: "enx-latn-py", eo: "eo-latn-001", eot: "eot-latn-ci", epi: "epi-latn-ng", era: "era-taml-in", erg: "erg-latn-vu", erh: "erh-latn-ng", eri: "eri-latn-zz", erk: "erk-latn-vu", err: "err-latn-au", ert: "ert-latn-id", erw: "erw-latn-id", es: "es-latn-es", ese: "ese-latn-bo", esg: "esg-gonm-in", esh: "esh-arab-ir", esi: "esi-latn-us", esm: "esm-latn-ci", ess: "ess-latn-us", "ess-cyrl": "ess-cyrl-us", esu: "esu-latn-us", esy: "esy-latn-ph", et: "et-latn-ee", etb: "etb-latn-ng", etn: "etn-latn-vu", eto: "eto-latn-cm", etr: "etr-latn-zz", ets: "ets-latn-ng", ett: "ett-ital-it", etu: "etu-latn-zz", etx: "etx-latn-zz", etz: "etz-latn-id", eu: "eu-latn-es", eve: "eve-cyrl-ru", evh: "evh-latn-ng", evn: "evn-cyrl-ru", "evn-latn": "evn-latn-cn", "evn-mong": "evn-mong-cn", ewo: "ewo-latn-cm", ext: "ext-latn-es", eya: "eya-latn-us", eyo: "eyo-latn-ke", eza: "eza-latn-zz", eze: "eze-latn-ng", fa: "fa-arab-ir", faa: "faa-latn-zz", fab: "fab-latn-zz", fad: "fad-latn-pg", faf: "faf-latn-sb", fag: "fag-latn-zz", fah: "fah-latn-ng", fai: "fai-latn-zz", faj: "faj-latn-pg", fak: "fak-latn-cm", fal: "fal-latn-cm", fam: "fam-latn-ng", fan: "fan-latn-gq", fap: "fap-latn-sn", far: "far-latn-sb", fau: "fau-latn-id", fax: "fax-latn-es", fay: "fay-arab-ir", faz: "faz-arab-ir", fbl: "fbl-latn-ph", fer: "fer-latn-ss", ff: "ff-latn-sn", "ff-adlm": "ff-adlm-gn", ffi: "ffi-latn-zz", ffm: "ffm-latn-ml", fgr: "fgr-latn-td", fi: "fi-latn-fi", fia: "fia-arab-sd", fie: "fie-latn-ng", fif: "fif-latn-sa", fil: "fil-latn-ph", fip: "fip-latn-tz", fir: "fir-latn-ng", fit: "fit-latn-se", fiw: "fiw-latn-pg", fj: "fj-latn-fj", fkk: "fkk-latn-ng", fkv: "fkv-latn-no", fla: "fla-latn-us", flh: "flh-latn-id", fli: "fli-latn-ng", fll: "fll-latn-cm", fln: "fln-latn-au", flr: "flr-latn-zz", fly: "fly-latn-za", fmp: "fmp-latn-zz", fmu: "fmu-deva-in", fnb: "fnb-latn-vu", fng: "fng-latn-za", fni: "fni-latn-td", fo: "fo-latn-fo", fod: "fod-latn-zz", foi: "foi-latn-pg", fom: "fom-latn-cd", fon: "fon-latn-bj", for: "for-latn-zz", fos: "fos-latn-tw", fpe: "fpe-latn-zz", fqs: "fqs-latn-zz", fr: "fr-latn-fr", frc: "frc-latn-us", frd: "frd-latn-id", frk: "frk-latn-de", frm: "frm-latn-fr", fro: "fro-latn-fr", frp: "frp-latn-fr", frq: "frq-latn-pg", frr: "frr-latn-de", frs: "frs-latn-de", frt: "frt-latn-vu", fub: "fub-arab-cm", fud: "fud-latn-wf", fue: "fue-latn-zz", fuf: "fuf-latn-gn", fuh: "fuh-latn-zz", fui: "fui-latn-td", fum: "fum-latn-ng", fun: "fun-latn-br", fuq: "fuq-latn-ne", fur: "fur-latn-it", fut: "fut-latn-vu", fuu: "fuu-latn-cd", fuv: "fuv-latn-ng", fuy: "fuy-latn-zz", fvr: "fvr-latn-sd", fwa: "fwa-latn-nc", fwe: "fwe-latn-na", fy: "fy-latn-nl", ga: "ga-latn-ie", gaa: "gaa-latn-gh", gab: "gab-latn-td", gac: "gac-latn-in", "gac-deva": "gac-deva-in", gad: "gad-latn-ph", gae: "gae-latn-ve", gaf: "gaf-latn-zz", gag: "gag-latn-md", gah: "gah-latn-zz", gai: "gai-latn-pg", gaj: "gaj-latn-zz", gak: "gak-latn-id", gal: "gal-latn-tl", gam: "gam-latn-zz", gan: "gan-hans-cn", gao: "gao-latn-pg", gap: "gap-latn-pg", gaq: "gaq-orya-in", gar: "gar-latn-pg", gas: "gas-gujr-in", gat: "gat-latn-pg", gau: "gau-telu-in", gaw: "gaw-latn-zz", gax: "gax-latn-et", "gax-ethi": "gax-ethi-et", gay: "gay-latn-id", gba: "gba-latn-zz", gbb: "gbb-latn-au", gbd: "gbd-latn-au", gbe: "gbe-latn-pg", gbf: "gbf-latn-zz", gbg: "gbg-latn-cf", gbh: "gbh-latn-bj", gbi: "gbi-latn-id", gbj: "gbj-orya-in", gbk: "gbk-deva-in", "gbk-takr": "gbk-takr-in", gbl: "gbl-gujr-in", "gbl-deva": "gbl-deva-in", gbm: "gbm-deva-in", gbn: "gbn-latn-ss", gbp: "gbp-latn-cf", gbq: "gbq-latn-cf", gbr: "gbr-latn-ng", gbs: "gbs-latn-bj", gbu: "gbu-latn-au", gbv: "gbv-latn-cf", gbw: "gbw-latn-au", gbx: "gbx-latn-bj", gby: "gby-latn-zz", gbz: "gbz-arab-ir", gcc: "gcc-latn-pg", gcd: "gcd-latn-au", gcf: "gcf-latn-gp", gcl: "gcl-latn-gd", gcn: "gcn-latn-pg", gcr: "gcr-latn-gf", gct: "gct-latn-ve", gd: "gd-latn-gb", gdb: "gdb-orya-in", "gdb-telu": "gdb-telu-in", gdc: "gdc-latn-au", gdd: "gdd-latn-pg", gde: "gde-latn-zz", gdf: "gdf-latn-ng", gdg: "gdg-latn-ph", gdh: "gdh-latn-au", gdi: "gdi-latn-cf", gdj: "gdj-latn-au", gdk: "gdk-latn-td", gdl: "gdl-latn-et", "gdl-ethi": "gdl-ethi-et", gdm: "gdm-latn-td", gdn: "gdn-latn-zz", gdo: "gdo-cyrl-ru", gdq: "gdq-latn-ye", gdr: "gdr-latn-zz", gdt: "gdt-latn-au", gdu: "gdu-latn-ng", gdx: "gdx-deva-in", gea: "gea-latn-ng", geb: "geb-latn-zz", gec: "gec-latn-lr", ged: "ged-latn-ng", gef: "gef-latn-id", geg: "geg-latn-ng", geh: "geh-latn-ca", gei: "gei-latn-id", gej: "gej-latn-zz", gek: "gek-latn-ng", gel: "gel-latn-zz", geq: "geq-latn-cf", ges: "ges-latn-id", gev: "gev-latn-ga", gew: "gew-latn-ng", gex: "gex-latn-so", gey: "gey-latn-cd", gez: "gez-ethi-et", gfk: "gfk-latn-zz", gga: "gga-latn-sb", ggb: "ggb-latn-lr", ggd: "ggd-latn-au", gge: "gge-latn-au", ggg: "ggg-arab-pk", ggk: "ggk-latn-au", ggl: "ggl-latn-pg", ggn: "ggn-deva-np", ggt: "ggt-latn-pg", ggu: "ggu-latn-ci", ggw: "ggw-latn-pg", gha: "gha-arab-ly", "gha-latn": "gha-latn-ly", "gha-tfng": "gha-tfng-ly", ghc: "ghc-latn-gb", ghe: "ghe-deva-np", ghk: "ghk-latn-mm", ghn: "ghn-latn-sb", ghr: "ghr-arab-pk", ghs: "ghs-latn-zz", ght: "ght-tibt-np", gia: "gia-latn-au", gib: "gib-latn-ng", gic: "gic-latn-za", gid: "gid-latn-cm", gie: "gie-latn-ci", gig: "gig-arab-pk", gih: "gih-latn-au", gil: "gil-latn-ki", gim: "gim-latn-zz", gin: "gin-cyrl-ru", gip: "gip-latn-pg", giq: "giq-latn-vn", gir: "gir-latn-vn", gis: "gis-latn-cm", git: "git-latn-ca", gix: "gix-latn-cd", giy: "giy-latn-au", giz: "giz-latn-cm", gjk: "gjk-arab-pk", gjm: "gjm-latn-au", gjn: "gjn-latn-zz", gjr: "gjr-latn-au", gju: "gju-arab-pk", gka: "gka-latn-pg", gkd: "gkd-latn-pg", gke: "gke-latn-cm", gkn: "gkn-latn-zz", gko: "gko-latn-au", gkp: "gkp-latn-zz", gku: "gku-latn-za", gl: "gl-latn-es", glb: "glb-latn-ng", glc: "glc-latn-td", gld: "gld-cyrl-ru", glh: "glh-arab-af", glj: "glj-latn-td", glk: "glk-arab-ir", gll: "gll-latn-au", glo: "glo-latn-ng", glr: "glr-latn-lr", glu: "glu-latn-td", glw: "glw-latn-ng", gma: "gma-latn-au", gmb: "gmb-latn-sb", gmd: "gmd-latn-ng", gmg: "gmg-latn-pg", gmh: "gmh-latn-de", gmm: "gmm-latn-zz", gmn: "gmn-latn-cm", gmr: "gmr-latn-au", gmu: "gmu-latn-pg", gmv: "gmv-ethi-zz", gmx: "gmx-latn-tz", gmy: "gmy-linb-gr", gmz: "gmz-latn-ng", gn: "gn-latn-py", gna: "gna-latn-bf", gnb: "gnb-latn-in", gnc: "gnc-latn-es", gnd: "gnd-latn-zz", gne: "gne-latn-ng", gng: "gng-latn-zz", gnh: "gnh-latn-ng", gni: "gni-latn-au", gnj: "gnj-latn-ci", gnk: "gnk-latn-bw", gnl: "gnl-latn-au", gnm: "gnm-latn-pg", gnn: "gnn-latn-au", gnq: "gnq-latn-my", gnr: "gnr-latn-au", gnt: "gnt-latn-pg", gnu: "gnu-latn-pg", gnw: "gnw-latn-bo", gnz: "gnz-latn-cf", goa: "goa-latn-ci", gob: "gob-latn-co", goc: "goc-latn-pg", god: "god-latn-zz", goe: "goe-tibt-bt", gof: "gof-ethi-zz", gog: "gog-latn-tz", goh: "goh-latn-de", goi: "goi-latn-zz", gok: "gok-deva-in", gol: "gol-latn-lr", gom: "gom-deva-in", gon: "gon-telu-in", goo: "goo-latn-fj", gop: "gop-latn-id", goq: "goq-latn-id", gor: "gor-latn-id", gos: "gos-latn-nl", got: "got-goth-ua", gou: "gou-latn-cm", gov: "gov-latn-ci", gow: "gow-latn-tz", gox: "gox-latn-cd", goy: "goy-latn-td", gpa: "gpa-latn-ng", gpe: "gpe-latn-gh", gpn: "gpn-latn-pg", gqa: "gqa-latn-ng", gqn: "gqn-latn-br", gqr: "gqr-latn-td", gra: "gra-deva-in", "gra-gujr": "gra-gujr-in", grb: "grb-latn-zz", grc: "grc-cprt-cy", "grc-linb": "grc-linb-gr", grd: "grd-latn-ng", grg: "grg-latn-pg", grh: "grh-latn-ng", gri: "gri-latn-sb", grj: "grj-latn-lr", grm: "grm-latn-my", grq: "grq-latn-pg", grs: "grs-latn-id", grt: "grt-beng-in", gru: "gru-ethi-et", "gru-latn": "gru-latn-et", grv: "grv-latn-lr", grw: "grw-latn-zz", grx: "grx-latn-pg", gry: "gry-latn-lr", grz: "grz-latn-pg", gsl: "gsl-latn-sn", gsn: "gsn-latn-pg", gso: "gso-latn-cf", gsp: "gsp-latn-pg", gsw: "gsw-latn-ch", gta: "gta-latn-br", gtu: "gtu-latn-au", gu: "gu-gujr-in", gua: "gua-latn-ng", gub: "gub-latn-br", guc: "guc-latn-co", gud: "gud-latn-zz", gue: "gue-latn-au", guf: "guf-latn-au", guh: "guh-latn-co", gui: "gui-latn-bo", guk: "guk-latn-et", "guk-ethi": "guk-ethi-et", gul: "gul-latn-us", gum: "gum-latn-co", gun: "gun-latn-br", guo: "guo-latn-co", gup: "gup-latn-au", guq: "guq-latn-py", gur: "gur-latn-gh", gut: "gut-latn-cr", guu: "guu-latn-ve", guw: "guw-latn-zz", gux: "gux-latn-zz", guz: "guz-latn-ke", gv: "gv-latn-im", gva: "gva-latn-py", gvc: "gvc-latn-br", gve: "gve-latn-pg", gvf: "gvf-latn-zz", gvj: "gvj-latn-br", gvl: "gvl-latn-td", gvm: "gvm-latn-ng", gvn: "gvn-latn-au", gvo: "gvo-latn-br", gvp: "gvp-latn-br", gvr: "gvr-deva-np", gvs: "gvs-latn-zz", gvy: "gvy-latn-au", gwa: "gwa-latn-ci", gwb: "gwb-latn-ng", gwc: "gwc-arab-zz", gwd: "gwd-latn-et", gwe: "gwe-latn-tz", gwf: "gwf-arab-pk", gwg: "gwg-latn-ng", gwi: "gwi-latn-ca", gwj: "gwj-latn-bw", gwm: "gwm-latn-au", gwn: "gwn-latn-ng", gwr: "gwr-latn-ug", gwt: "gwt-arab-zz", gwu: "gwu-latn-au", gww: "gww-latn-au", gwx: "gwx-latn-gh", gxx: "gxx-latn-ci", gyb: "gyb-latn-pg", gyd: "gyd-latn-au", gye: "gye-latn-ng", gyf: "gyf-latn-au", gyg: "gyg-latn-cf", gyi: "gyi-latn-zz", gyl: "gyl-latn-et", "gyl-ethi": "gyl-ethi-et", gym: "gym-latn-pa", gyn: "gyn-latn-gy", gyo: "gyo-deva-np", gyr: "gyr-latn-bo", gyy: "gyy-latn-au", gyz: "gyz-latn-ng", gza: "gza-latn-sd", gzi: "gzi-arab-ir", gzn: "gzn-latn-id", ha: "ha-latn-ng", "ha-cm": "ha-arab-cm", "ha-sd": "ha-arab-sd", haa: "haa-latn-us", hac: "hac-arab-ir", had: "had-latn-id", hae: "hae-latn-et", hag: "hag-latn-zz", hah: "hah-latn-pg", hai: "hai-latn-ca", haj: "haj-latn-in", "haj-beng": "haj-beng-in", hak: "hak-hans-cn", hal: "hal-latn-vn", ham: "ham-latn-zz", han: "han-latn-tz", hao: "hao-latn-pg", hap: "hap-latn-id", haq: "haq-latn-tz", har: "har-ethi-et", "har-arab": "har-arab-et", "har-latn": "har-latn-et", has: "has-latn-ca", hav: "hav-latn-cd", haw: "haw-latn-us", hax: "hax-latn-ca", hay: "hay-latn-tz", haz: "haz-arab-af", hba: "hba-latn-cd", hbb: "hbb-latn-zz", hbn: "hbn-latn-sd", hbo: "hbo-hebr-il", hbu: "hbu-latn-tl", hch: "hch-latn-mx", hdy: "hdy-ethi-zz", he: "he-hebr-il", hed: "hed-latn-td", heg: "heg-latn-id", heh: "heh-latn-tz", hei: "hei-latn-ca", hem: "hem-latn-cd", hgm: "hgm-latn-na", hgw: "hgw-latn-pg", hhi: "hhi-latn-pg", hhr: "hhr-latn-sn", hhy: "hhy-latn-zz", hi: "hi-deva-in", "hi-latn": "hi-latn-in", hia: "hia-latn-zz", hib: "hib-latn-pe", hid: "hid-latn-us", hif: "hif-latn-fj", hig: "hig-latn-zz", hih: "hih-latn-zz", hii: "hii-takr-in", "hii-deva": "hii-deva-in", hij: "hij-latn-cm", hik: "hik-latn-id", hil: "hil-latn-ph", hio: "hio-latn-bw", hir: "hir-latn-br", hit: "hit-xsux-tr", hiw: "hiw-latn-vu", hix: "hix-latn-br", hji: "hji-latn-id", hka: "hka-latn-tz", hke: "hke-latn-cd", hkh: "hkh-arab-in", "hkh-deva": "hkh-deva-in", "hkh-latn": "hkh-latn-in", hkk: "hkk-latn-pg", hla: "hla-latn-zz", hlb: "hlb-deva-in", hld: "hld-latn-vn", hlt: "hlt-latn-mm", hlu: "hlu-hluw-tr", hma: "hma-latn-cn", hmb: "hmb-latn-ml", hmd: "hmd-plrd-cn", hmf: "hmf-latn-vn", hmj: "hmj-bopo-cn", hmm: "hmm-latn-cn", hmn: "hmn-latn-cn", "hmn-bopo": "hmn-bopo-cn", "hmn-hmng": "hmn-hmng-cn", hmp: "hmp-latn-cn", hmq: "hmq-bopo-cn", hmr: "hmr-latn-in", hms: "hms-latn-cn", hmt: "hmt-latn-zz", hmu: "hmu-latn-id", hmv: "hmv-latn-vn", hmw: "hmw-latn-cn", hmy: "hmy-latn-cn", hmz: "hmz-latn-cn", "hmz-plrd": "hmz-plrd-cn", hna: "hna-latn-cm", hnd: "hnd-arab-pk", hne: "hne-deva-in", hng: "hng-latn-ao", hnh: "hnh-latn-bw", hni: "hni-latn-cn", hnj: "hnj-hmnp-us", "hnj-au": "hnj-laoo-au", "hnj-cn": "hnj-laoo-cn", "hnj-fr": "hnj-laoo-fr", "hnj-gf": "hnj-laoo-gf", "hnj-la": "hnj-laoo-la", "hnj-laoo": "hnj-laoo-la", "hnj-mm": "hnj-laoo-mm", "hnj-sr": "hnj-laoo-sr", "hnj-th": "hnj-laoo-th", "hnj-us": "hnj-hmnp-us", "hnj-vn": "hnj-laoo-vn", hnn: "hnn-latn-ph", hno: "hno-arab-pk", hns: "hns-latn-sr", ho: "ho-latn-pg", hoa: "hoa-latn-sb", hob: "hob-latn-pg", hoc: "hoc-deva-in", hod: "hod-latn-ng", hoe: "hoe-latn-ng", hoh: "hoh-arab-om", hoi: "hoi-latn-us", hoj: "hoj-deva-in", hol: "hol-latn-ao", hom: "hom-latn-ss", hoo: "hoo-latn-cd", hop: "hop-latn-us", hor: "hor-latn-td", hot: "hot-latn-zz", hov: "hov-latn-id", how: "how-hani-cn", hoy: "hoy-deva-in", hpo: "hpo-mymr-mm", hr: "hr-latn-hr", hra: "hra-latn-in", hrc: "hrc-latn-pg", hre: "hre-latn-vn", hrk: "hrk-latn-id", hrm: "hrm-latn-cn", "hrm-hmng": "hrm-hmng-cn", hro: "hro-latn-vn", hrp: "hrp-latn-au", hrt: "hrt-syrc-tr", hru: "hru-latn-in", hrw: "hrw-latn-pg", hrx: "hrx-latn-br", hrz: "hrz-arab-ir", hsb: "hsb-latn-de", hsn: "hsn-hans-cn", hss: "hss-arab-om", ht: "ht-latn-ht", hti: "hti-latn-id", hto: "hto-latn-co", hts: "hts-latn-tz", htu: "htu-latn-id", htx: "htx-xsux-tr", hu: "hu-latn-hu", hub: "hub-latn-pe", huc: "huc-latn-bw", hud: "hud-latn-id", hue: "hue-latn-mx", huf: "huf-latn-pg", hug: "hug-latn-pe", huh: "huh-latn-cl", hui: "hui-latn-zz", huk: "huk-latn-id", hul: "hul-latn-pg", hum: "hum-latn-cd", hup: "hup-latn-us", hur: "hur-latn-ca", hus: "hus-latn-mx", hut: "hut-deva-np", "hut-tibt": "hut-tibt-np", huu: "huu-latn-pe", huv: "huv-latn-mx", huw: "huw-latn-id", hux: "hux-latn-pe", huy: "huy-hebr-il", huz: "huz-cyrl-ru", hvc: "hvc-latn-ht", hve: "hve-latn-mx", hvk: "hvk-latn-nc", hvn: "hvn-latn-id", hvv: "hvv-latn-mx", hwa: "hwa-latn-ci", hwc: "hwc-latn-us", hwo: "hwo-latn-ng", hy: "hy-armn-am", hya: "hya-latn-cm", hyw: "hyw-armn-am", hz: "hz-latn-na", ia: "ia-latn-001", iai: "iai-latn-nc", ian: "ian-latn-zz", iar: "iar-latn-zz", iba: "iba-latn-my", ibb: "ibb-latn-ng", ibd: "ibd-latn-au", ibe: "ibe-latn-ng", ibg: "ibg-latn-ph", ibh: "ibh-latn-vn", ibl: "ibl-latn-ph", ibm: "ibm-latn-ng", ibn: "ibn-latn-ng", ibr: "ibr-latn-ng", ibu: "ibu-latn-id", iby: "iby-latn-zz", ica: "ica-latn-zz", ich: "ich-latn-zz", icr: "icr-latn-co", id: "id-latn-id", ida: "ida-latn-ke", idb: "idb-latn-in", idc: "idc-latn-ng", idd: "idd-latn-zz", ide: "ide-latn-ng", idi: "idi-latn-zz", idr: "idr-latn-ss", ids: "ids-latn-ng", idt: "idt-latn-tl", idu: "idu-latn-zz", ie: "ie-latn-001", ifa: "ifa-latn-ph", ifb: "ifb-latn-ph", ife: "ife-latn-tg", iff: "iff-latn-vu", ifk: "ifk-latn-ph", ifm: "ifm-latn-cg", ifu: "ifu-latn-ph", ify: "ify-latn-ph", ig: "ig-latn-ng", igb: "igb-latn-zz", ige: "ige-latn-zz", igg: "igg-latn-pg", igl: "igl-latn-ng", igm: "igm-latn-pg", ign: "ign-latn-bo", igo: "igo-latn-pg", igs: "igs-latn-001", "igs-grek": "igs-grek-001", igw: "igw-latn-ng", ihb: "ihb-latn-id", ihi: "ihi-latn-ng", ihp: "ihp-latn-id", ihw: "ihw-latn-au", ii: "ii-yiii-cn", iin: "iin-latn-au", ijc: "ijc-latn-ng", ije: "ije-latn-ng", ijj: "ijj-latn-zz", ijn: "ijn-latn-ng", ijs: "ijs-latn-ng", ik: "ik-latn-us", iki: "iki-latn-ng", ikk: "ikk-latn-zz", ikl: "ikl-latn-ng", iko: "iko-latn-ng", ikp: "ikp-latn-ng", ikr: "ikr-latn-au", ikt: "ikt-latn-ca", "ikt-cans": "ikt-cans-ca", ikv: "ikv-latn-ng", ikw: "ikw-latn-zz", ikx: "ikx-latn-zz", ikz: "ikz-latn-tz", ila: "ila-latn-id", ilb: "ilb-latn-zm", ilg: "ilg-latn-au", ili: "ili-latn-cn", "ili-arab": "ili-arab-cn", "ili-cyrl": "ili-cyrl-kz", ilk: "ilk-latn-ph", ilm: "ilm-latn-my", ilo: "ilo-latn-ph", ilp: "ilp-latn-ph", ilu: "ilu-latn-id", ilv: "ilv-latn-ng", imi: "imi-latn-pg", iml: "iml-latn-us", imn: "imn-latn-pg", imo: "imo-latn-zz", imr: "imr-latn-id", ims: "ims-latn-it", imt: "imt-latn-ss", imy: "imy-lyci-tr", in: "in-latn-id", inb: "inb-latn-co", ing: "ing-latn-us", inh: "inh-cyrl-ru", inj: "inj-latn-co", inn: "inn-latn-ph", ino: "ino-latn-pg", inp: "inp-latn-pe", int: "int-mymr-mm", io: "io-latn-001", ior: "ior-ethi-et", iou: "iou-latn-zz", iow: "iow-latn-us", ipi: "ipi-latn-pg", ipo: "ipo-latn-pg", iqu: "iqu-latn-pe", iqw: "iqw-latn-ng", ire: "ire-latn-id", irh: "irh-latn-id", iri: "iri-latn-zz", irk: "irk-latn-tz", irn: "irn-latn-br", iru: "iru-taml-in", "iru-mlym": "iru-mlym-in", irx: "irx-latn-id", iry: "iry-latn-ph", is: "is-latn-is", isa: "isa-latn-pg", isc: "isc-latn-pe", isd: "isd-latn-ph", ish: "ish-latn-ng", isi: "isi-latn-ng", isk: "isk-arab-af", "isk-cyrl": "isk-cyrl-tj", ism: "ism-latn-id", isn: "isn-latn-tz", iso: "iso-latn-ng", ist: "ist-latn-hr", isu: "isu-latn-cm", it: "it-latn-it", itb: "itb-latn-ph", itd: "itd-latn-id", ite: "ite-latn-bo", iti: "iti-latn-ph", itk: "itk-hebr-it", itl: "itl-cyrl-ru", itm: "itm-latn-ng", ito: "ito-latn-bo", itr: "itr-latn-pg", its: "its-latn-ng", itt: "itt-latn-ph", itv: "itv-latn-ph", itw: "itw-latn-ng", itx: "itx-latn-id", ity: "ity-latn-ph", itz: "itz-latn-gt", iu: "iu-cans-ca", ium: "ium-latn-cn", "ium-hani": "ium-hani-cn", "ium-laoo": "ium-laoo-la", "ium-thai": "ium-thai-th", ivb: "ivb-latn-ph", ivv: "ivv-latn-ph", iw: "iw-hebr-il", iwk: "iwk-latn-ph", iwm: "iwm-latn-zz", iwo: "iwo-latn-id", iws: "iws-latn-zz", ixc: "ixc-latn-mx", ixl: "ixl-latn-gt", iya: "iya-latn-ng", iyo: "iyo-latn-cm", iyx: "iyx-latn-cg", izh: "izh-latn-ru", izi: "izi-latn-zz", izr: "izr-latn-ng", izz: "izz-latn-ng", ja: "ja-jpan-jp", jaa: "jaa-latn-br", jab: "jab-latn-zz", jac: "jac-latn-gt", jad: "jad-arab-gn", jae: "jae-latn-pg", jaf: "jaf-latn-ng", jah: "jah-latn-my", jaj: "jaj-latn-sb", jak: "jak-latn-my", jal: "jal-latn-id", jam: "jam-latn-jm", jan: "jan-latn-au", jao: "jao-latn-au", jaq: "jaq-latn-id", jar: "jar-latn-zz", jas: "jas-latn-nc", jat: "jat-arab-af", jau: "jau-latn-id", jax: "jax-latn-id", jay: "jay-latn-au", jaz: "jaz-latn-nc", jbe: "jbe-hebr-il", jbi: "jbi-latn-au", jbj: "jbj-latn-id", jbk: "jbk-latn-pg", jbm: "jbm-latn-ng", jbn: "jbn-arab-ly", jbo: "jbo-latn-001", jbr: "jbr-latn-id", jbt: "jbt-latn-br", jbu: "jbu-latn-zz", jbw: "jbw-latn-au", jct: "jct-cyrl-ua", "jct-latn": "jct-latn-ua", jda: "jda-tibt-in", jdg: "jdg-arab-pk", jdt: "jdt-cyrl-ru", "jdt-hebr": "jdt-hebr-ru", "jdt-latn": "jdt-latn-az", jeb: "jeb-latn-pe", jee: "jee-deva-np", jeh: "jeh-latn-vn", "jeh-laoo": "jeh-laoo-la", jei: "jei-latn-id", jek: "jek-latn-ci", jel: "jel-latn-id", jen: "jen-latn-zz", jer: "jer-latn-ng", jet: "jet-latn-pg", jeu: "jeu-latn-td", jgb: "jgb-latn-cd", jge: "jge-geor-ge", "jge-hebr": "jge-hebr-il", jgk: "jgk-latn-zz", jgo: "jgo-latn-cm", jhi: "jhi-latn-my", ji: "ji-hebr-ua", jia: "jia-latn-cm", jib: "jib-latn-zz", jic: "jic-latn-hn", jid: "jid-latn-ng", jie: "jie-latn-ng", jig: "jig-latn-au", jil: "jil-latn-pg", jim: "jim-latn-cm", jit: "jit-latn-tz", jiu: "jiu-latn-cn", jiv: "jiv-latn-ec", jiy: "jiy-latn-cn", jje: "jje-hang-kr", jjr: "jjr-latn-ng", jka: "jka-latn-id", jkm: "jkm-mymr-mm", "jkm-brai": "jkm-brai-mm", "jkm-latn": "jkm-latn-mm", jko: "jko-latn-pg", jku: "jku-latn-ng", jle: "jle-latn-sd", jma: "jma-latn-pg", jmb: "jmb-latn-ng", jmc: "jmc-latn-tz", jmd: "jmd-latn-id", jmi: "jmi-latn-ng", jml: "jml-deva-np", jmn: "jmn-latn-mm", jmr: "jmr-latn-gh", jms: "jms-latn-ng", jmw: "jmw-latn-pg", jmx: "jmx-latn-mx", jna: "jna-takr-in", jnd: "jnd-arab-pk", jng: "jng-latn-au", jni: "jni-latn-ng", jnj: "jnj-latn-et", "jnj-ethi": "jnj-ethi-et", jnl: "jnl-deva-in", jns: "jns-deva-in", "jns-latn": "jns-latn-in", "jns-takr": "jns-takr-in", job: "job-latn-cd", jod: "jod-latn-ci", jog: "jog-arab-pk", jor: "jor-latn-bo", jow: "jow-latn-ml", jpa: "jpa-hebr-ps", jpr: "jpr-hebr-il", jqr: "jqr-latn-pe", jra: "jra-latn-zz", jrr: "jrr-latn-ng", jrt: "jrt-latn-ng", jru: "jru-latn-ve", jua: "jua-latn-br", jub: "jub-latn-ng", jud: "jud-latn-ci", juh: "juh-latn-ng", jui: "jui-latn-au", juk: "juk-latn-ng", jul: "jul-deva-np", jum: "jum-latn-sd", jun: "jun-orya-in", juo: "juo-latn-ng", jup: "jup-latn-br", jur: "jur-latn-br", jut: "jut-latn-dk", juu: "juu-latn-ng", juw: "juw-latn-ng", juy: "juy-orya-in", jv: "jv-latn-id", jvd: "jvd-latn-id", jvn: "jvn-latn-sr", jw: "jw-latn-id", jwi: "jwi-latn-gh", jya: "jya-tibt-cn", jye: "jye-hebr-il", jyy: "jyy-latn-td", ka: "ka-geor-ge", kaa: "kaa-cyrl-uz", kab: "kab-latn-dz", kac: "kac-latn-mm", kad: "kad-latn-zz", kag: "kag-latn-my", kah: "kah-latn-cf", kai: "kai-latn-zz", kaj: "kaj-latn-ng", kak: "kak-latn-ph", kam: "kam-latn-ke", kao: "kao-latn-ml", kap: "kap-cyrl-ru", kaq: "kaq-latn-pe", kav: "kav-latn-br", kaw: "kaw-kawi-id", kax: "kax-latn-id", kay: "kay-latn-br", kba: "kba-latn-au", kbb: "kbb-latn-br", kbc: "kbc-latn-br", kbd: "kbd-cyrl-ru", kbe: "kbe-latn-au", kbh: "kbh-latn-co", kbi: "kbi-latn-id", kbj: "kbj-latn-cd", kbk: "kbk-latn-pg", kbl: "kbl-latn-td", kbm: "kbm-latn-zz", kbn: "kbn-latn-cf", kbo: "kbo-latn-ss", kbp: "kbp-latn-zz", kbq: "kbq-latn-zz", kbr: "kbr-latn-et", "kbr-ethi": "kbr-ethi-et", kbs: "kbs-latn-ga", kbt: "kbt-latn-pg", kbu: "kbu-arab-pk", kbv: "kbv-latn-id", kbw: "kbw-latn-pg", kbx: "kbx-latn-zz", kby: "kby-arab-ne", kbz: "kbz-latn-ng", kca: "kca-cyrl-ru", kcb: "kcb-latn-pg", kcc: "kcc-latn-ng", kcd: "kcd-latn-id", kce: "kce-latn-ng", kcf: "kcf-latn-ng", kcg: "kcg-latn-ng", kch: "kch-latn-ng", kci: "kci-latn-ng", kcj: "kcj-latn-gw", kck: "kck-latn-zw", kcl: "kcl-latn-zz", kcm: "kcm-latn-cf", kcn: "kcn-latn-ug", kco: "kco-latn-pg", kcp: "kcp-latn-sd", kcq: "kcq-latn-ng", kcs: "kcs-latn-ng", kct: "kct-latn-zz", kcu: "kcu-latn-tz", kcv: "kcv-latn-cd", kcw: "kcw-latn-cd", kcz: "kcz-latn-tz", kda: "kda-latn-au", kdc: "kdc-latn-tz", kdd: "kdd-latn-au", kde: "kde-latn-tz", kdf: "kdf-latn-pg", kdg: "kdg-latn-cd", kdh: "kdh-latn-tg", kdi: "kdi-latn-ug", kdj: "kdj-latn-ug", kdk: "kdk-latn-nc", kdl: "kdl-latn-zz", kdm: "kdm-latn-ng", kdn: "kdn-latn-zw", kdp: "kdp-latn-ng", kdq: "kdq-beng-in", kdr: "kdr-latn-lt", "kdr-cyrl": "kdr-cyrl-ua", kdt: "kdt-thai-th", kdw: "kdw-latn-id", kdx: "kdx-latn-ng", kdy: "kdy-latn-id", kdz: "kdz-latn-cm", kea: "kea-latn-cv", keb: "keb-latn-ga", kec: "kec-latn-sd", ked: "ked-latn-tz", kee: "kee-latn-us", kef: "kef-latn-tg", keg: "keg-latn-sd", keh: "keh-latn-pg", kei: "kei-latn-id", kek: "kek-latn-gt", kel: "kel-latn-cd", kem: "kem-latn-tl", ken: "ken-latn-cm", keo: "keo-latn-ug", ker: "ker-latn-td", kes: "kes-latn-ng", ket: "ket-cyrl-ru", keu: "keu-latn-tg", kew: "kew-latn-pg", kex: "kex-deva-in", "kex-gujr": "kex-gujr-in", key: "key-telu-in", kez: "kez-latn-zz", kfa: "kfa-knda-in", kfb: "kfb-deva-in", kfc: "kfc-telu-in", kfd: "kfd-knda-in", kfe: "kfe-taml-in", kff: "kff-latn-in", "kff-deva": "kff-deva-in", "kff-orya": "kff-orya-in", "kff-telu": "kff-telu-in", kfh: "kfh-mlym-in", kfi: "kfi-taml-in", "kfi-knda": "kfi-knda-in", kfk: "kfk-deva-in", "kfk-takr": "kfk-takr-in", kfl: "kfl-latn-cm", kfm: "kfm-arab-ir", kfn: "kfn-latn-cm", kfo: "kfo-latn-ci", kfp: "kfp-deva-in", kfq: "kfq-deva-in", kfr: "kfr-deva-in", kfs: "kfs-deva-in", kfv: "kfv-latn-in", kfw: "kfw-latn-in", kfx: "kfx-deva-in", "kfx-takr": "kfx-takr-in", kfy: "kfy-deva-in", kfz: "kfz-latn-bf", kg: "kg-latn-cd", kga: "kga-latn-ci", kgb: "kgb-latn-id", kge: "kge-latn-id", kgf: "kgf-latn-zz", kgj: "kgj-deva-np", kgk: "kgk-latn-br", kgl: "kgl-latn-au", kgm: "kgm-latn-br", kgo: "kgo-latn-sd", kgp: "kgp-latn-br", kgq: "kgq-latn-id", kgr: "kgr-latn-id", kgs: "kgs-latn-au", kgt: "kgt-latn-ng", kgu: "kgu-latn-pg", kgv: "kgv-latn-id", kgw: "kgw-latn-id", kgx: "kgx-latn-id", kgy: "kgy-deva-np", kha: "kha-latn-in", khb: "khb-talu-cn", khc: "khc-latn-id", khd: "khd-latn-id", khe: "khe-latn-id", khf: "khf-thai-la", khg: "khg-tibt-cn", khh: "khh-latn-id", khj: "khj-latn-ng", khl: "khl-latn-pg", khn: "khn-deva-in", khp: "khp-latn-id", khq: "khq-latn-ml", khr: "khr-latn-in", "khr-deva": "khr-deva-in", khs: "khs-latn-zz", kht: "kht-mymr-in", khu: "khu-latn-ao", khv: "khv-cyrl-ru", khw: "khw-arab-pk", khx: "khx-latn-cd", khy: "khy-latn-cd", khz: "khz-latn-zz", ki: "ki-latn-ke", kia: "kia-latn-td", kib: "kib-latn-sd", kic: "kic-latn-us", kid: "kid-latn-cm", kie: "kie-latn-td", kif: "kif-deva-np", kig: "kig-latn-id", kih: "kih-latn-pg", kij: "kij-latn-zz", kil: "kil-latn-ng", kim: "kim-cyrl-ru", kio: "kio-latn-us", kip: "kip-deva-np", kiq: "kiq-latn-id", kis: "kis-latn-pg", kit: "kit-latn-pg", kiu: "kiu-latn-tr", kiv: "kiv-latn-tz", kiw: "kiw-latn-zz", kix: "kix-latn-in", kiy: "kiy-latn-id", kiz: "kiz-latn-tz", kj: "kj-latn-na", kja: "kja-latn-id", kjb: "kjb-latn-gt", kjc: "kjc-latn-id", kjd: "kjd-latn-zz", kje: "kje-latn-id", kjg: "kjg-laoo-la", kjh: "kjh-cyrl-ru", kji: "kji-latn-sb", kjj: "kjj-latn-az", kjk: "kjk-latn-id", kjl: "kjl-deva-np", kjm: "kjm-latn-vn", kjn: "kjn-latn-au", kjo: "kjo-deva-in", kjp: "kjp-mymr-mm", "kjp-thai": "kjp-thai-th", kjq: "kjq-latn-us", kjr: "kjr-latn-id", kjs: "kjs-latn-zz", kjt: "kjt-thai-th", kju: "kju-latn-us", kjx: "kjx-latn-pg", kjy: "kjy-latn-zz", kk: "kk-cyrl-kz", "kk-af": "kk-arab-af", "kk-arab": "kk-arab-cn", "kk-cn": "kk-arab-cn", "kk-ir": "kk-arab-ir", "kk-mn": "kk-arab-mn", kka: "kka-latn-ng", kkb: "kkb-latn-id", kkc: "kkc-latn-zz", kkd: "kkd-latn-ng", kke: "kke-latn-gn", "kke-arab": "kke-arab-gn", kkf: "kkf-tibt-in", kkg: "kkg-latn-ph", kkh: "kkh-lana-mm", kki: "kki-latn-tz", kkj: "kkj-latn-cm", kkk: "kkk-latn-sb", kkl: "kkl-latn-id", kkm: "kkm-latn-ng", kko: "kko-latn-sd", kkp: "kkp-latn-au", kkq: "kkq-latn-cd", kkr: "kkr-latn-ng", kks: "kks-latn-ng", kkt: "kkt-deva-np", kku: "kku-latn-ng", kkv: "kkv-latn-id", kkw: "kkw-latn-cg", kkx: "kkx-latn-id", kky: "kky-latn-au", kkz: "kkz-latn-ca", kl: "kl-latn-gl", kla: "kla-latn-us", klb: "klb-latn-mx", klc: "klc-latn-cm", kld: "kld-latn-au", kle: "kle-deva-np", klf: "klf-latn-td", klg: "klg-latn-ph", klh: "klh-latn-pg", kli: "kli-latn-id", klj: "klj-arab-ir", klk: "klk-latn-ng", kll: "kll-latn-ph", klm: "klm-latn-pg", kln: "kln-latn-ke", klo: "klo-latn-ng", klp: "klp-latn-pg", klq: "klq-latn-zz", klr: "klr-deva-np", kls: "kls-latn-pk", "kls-arab": "kls-arab-pk", klt: "klt-latn-zz", klu: "klu-latn-lr", klv: "klv-latn-vu", klw: "klw-latn-id", klx: "klx-latn-zz", kly: "kly-latn-id", klz: "klz-latn-id", km: "km-khmr-kh", kma: "kma-latn-gh", kmb: "kmb-latn-ao", kmc: "kmc-latn-cn", "kmc-hani": "kmc-hani-cn", kmd: "kmd-latn-ph", kme: "kme-latn-cm", kmf: "kmf-latn-pg", kmg: "kmg-latn-pg", kmh: "kmh-latn-zz", kmi: "kmi-latn-ng", kmj: "kmj-deva-in", kmk: "kmk-latn-ph", kml: "kml-latn-ph", kmm: "kmm-latn-in", kmn: "kmn-latn-pg", kmo: "kmo-latn-zz", kmp: "kmp-latn-cm", kmq: "kmq-latn-et", kms: "kms-latn-zz", kmt: "kmt-latn-id", kmu: "kmu-latn-zz", kmv: "kmv-latn-br", kmw: "kmw-latn-zz", kmx: "kmx-latn-pg", kmy: "kmy-latn-ng", kmz: "kmz-arab-ir", kn: "kn-knda-in", kna: "kna-latn-ng", knb: "knb-latn-ph", knd: "knd-latn-id", kne: "kne-latn-ph", knf: "knf-latn-gw", kni: "kni-latn-ng", knj: "knj-latn-gt", knk: "knk-latn-sl", "knk-arab": "knk-arab-sl", knl: "knl-latn-id", knm: "knm-latn-br", kno: "kno-latn-sl", knp: "knp-latn-zz", knq: "knq-latn-my", knr: "knr-latn-pg", kns: "kns-latn-my", "kns-thai": "kns-thai-th", knt: "knt-latn-br", knu: "knu-latn-gn", knv: "knv-latn-pg", knw: "knw-latn-na", knx: "knx-latn-id", kny: "kny-latn-cd", knz: "knz-latn-bf", ko: "ko-kore-kr", koa: "koa-latn-pg", koc: "koc-latn-ng", kod: "kod-latn-id", koe: "koe-latn-ss", kof: "kof-latn-ng", kog: "kog-latn-co", koh: "koh-latn-cg", koi: "koi-cyrl-ru", kok: "kok-deva-in", kol: "kol-latn-zz", koo: "koo-latn-ug", kop: "kop-latn-pg", koq: "koq-latn-ga", kos: "kos-latn-fm", kot: "kot-latn-cm", kou: "kou-latn-td", kov: "kov-latn-ng", kow: "kow-latn-ng", koy: "koy-latn-us", koz: "koz-latn-zz", kpa: "kpa-latn-ng", kpc: "kpc-latn-co", kpd: "kpd-latn-id", kpe: "kpe-latn-lr", kpf: "kpf-latn-zz", kpg: "kpg-latn-fm", kph: "kph-latn-gh", kpi: "kpi-latn-id", kpj: "kpj-latn-br", kpk: "kpk-latn-ng", kpl: "kpl-latn-cd", kpm: "kpm-latn-vn", kpn: "kpn-latn-br", kpo: "kpo-latn-zz", kpq: "kpq-latn-id", kpr: "kpr-latn-zz", kps: "kps-latn-id", kpt: "kpt-cyrl-ru", kpu: "kpu-latn-id", kpw: "kpw-latn-pg", kpx: "kpx-latn-zz", kpy: "kpy-cyrl-ru", kpz: "kpz-latn-ug", kqa: "kqa-latn-pg", kqb: "kqb-latn-zz", kqc: "kqc-latn-pg", kqd: "kqd-syrc-iq", kqe: "kqe-latn-ph", kqf: "kqf-latn-zz", kqg: "kqg-latn-bf", kqh: "kqh-latn-tz", kqi: "kqi-latn-pg", kqj: "kqj-latn-pg", kqk: "kqk-latn-bj", kql: "kql-latn-pg", kqm: "kqm-latn-ci", kqn: "kqn-latn-zm", kqo: "kqo-latn-lr", kqp: "kqp-latn-td", kqq: "kqq-latn-br", kqr: "kqr-latn-my", kqs: "kqs-latn-zz", kqt: "kqt-latn-my", kqu: "kqu-latn-za", kqv: "kqv-latn-id", kqw: "kqw-latn-pg", kqx: "kqx-latn-cm", kqy: "kqy-ethi-zz", kqz: "kqz-latn-za", kr: "kr-latn-zz", kra: "kra-deva-np", krb: "krb-latn-us", krc: "krc-cyrl-ru", krd: "krd-latn-tl", kre: "kre-latn-br", krf: "krf-latn-vu", krh: "krh-latn-ng", kri: "kri-latn-sl", krj: "krj-latn-ph", krk: "krk-cyrl-ru", krl: "krl-latn-ru", krn: "krn-latn-lr", krp: "krp-latn-ng", krr: "krr-khmr-kh", krs: "krs-latn-zz", krt: "krt-latn-ne", kru: "kru-deva-in", krv: "krv-khmr-kh", krw: "krw-latn-lr", krx: "krx-latn-sn", kry: "kry-latn-az", krz: "krz-latn-id", ks: "ks-arab-in", ksa: "ksa-latn-ng", ksb: "ksb-latn-tz", ksc: "ksc-latn-ph", ksd: "ksd-latn-zz", kse: "kse-latn-pg", ksf: "ksf-latn-cm", ksg: "ksg-latn-sb", ksh: "ksh-latn-de", ksi: "ksi-latn-pg", ksj: "ksj-latn-zz", ksk: "ksk-latn-us", ksl: "ksl-latn-pg", ksm: "ksm-latn-ng", ksn: "ksn-latn-ph", kso: "kso-latn-ng", ksp: "ksp-latn-cf", ksq: "ksq-latn-ng", ksr: "ksr-latn-zz", kss: "kss-latn-lr", kst: "kst-latn-bf", ksu: "ksu-mymr-in", ksv: "ksv-latn-cd", ksw: "ksw-mymr-mm", "ksw-latn": "ksw-latn-mm", ksx: "ksx-latn-id", ksz: "ksz-deva-in", kta: "kta-latn-vn", ktb: "ktb-ethi-zz", ktc: "ktc-latn-ng", ktd: "ktd-latn-au", ktf: "ktf-latn-cd", ktg: "ktg-latn-au", kth: "kth-latn-td", kti: "kti-latn-id", ktj: "ktj-latn-ci", ktk: "ktk-latn-pg", ktl: "ktl-arab-ir", ktm: "ktm-latn-zz", ktn: "ktn-latn-br", kto: "kto-latn-zz", ktp: "ktp-plrd-cn", ktq: "ktq-latn-ph", ktr: "ktr-latn-my", kts: "kts-latn-id", ktt: "ktt-latn-id", ktu: "ktu-latn-cd", ktv: "ktv-latn-vn", ktw: "ktw-latn-us", ktx: "ktx-latn-br", kty: "kty-latn-cd", ktz: "ktz-latn-na", ku: "ku-latn-tr", "ku-arab": "ku-arab-iq", "ku-lb": "ku-arab-lb", "ku-yezi": "ku-yezi-ge", kub: "kub-latn-zz", kuc: "kuc-latn-id", kud: "kud-latn-zz", kue: "kue-latn-zz", kuf: "kuf-laoo-la", kug: "kug-latn-ng", kuh: "kuh-latn-ng", kui: "kui-latn-br", kuj: "kuj-latn-zz", kuk: "kuk-latn-id", kul: "kul-latn-ng", kum: "kum-cyrl-ru", kun: "kun-latn-zz", kuo: "kuo-latn-pg", kup: "kup-latn-zz", kuq: "kuq-latn-br", kus: "kus-latn-zz", kut: "kut-latn-ca", kuu: "kuu-latn-us", kuv: "kuv-latn-id", kuw: "kuw-latn-cf", kux: "kux-latn-au", kuy: "kuy-latn-au", kuz: "kuz-latn-cl", kv: "kv-cyrl-ru", kva: "kva-cyrl-ru", kvb: "kvb-latn-id", kvc: "kvc-latn-pg", kvd: "kvd-latn-id", kve: "kve-latn-my", kvf: "kvf-latn-td", kvg: "kvg-latn-zz", kvh: "kvh-latn-id", kvi: "kvi-latn-td", kvj: "kvj-latn-cm", kvl: "kvl-latn-mm", kvm: "kvm-latn-cm", kvn: "kvn-latn-co", kvo: "kvo-latn-id", kvp: "kvp-latn-id", kvq: "kvq-mymr-mm", "kvq-latn": "kvq-latn-mm", kvr: "kvr-latn-id", kvt: "kvt-mymr-mm", kvv: "kvv-latn-id", kvw: "kvw-latn-id", kvx: "kvx-arab-pk", kvy: "kvy-kali-mm", kvz: "kvz-latn-id", kw: "kw-latn-gb", kwa: "kwa-latn-br", kwb: "kwb-latn-ng", kwc: "kwc-latn-cg", kwd: "kwd-latn-sb", kwe: "kwe-latn-id", kwf: "kwf-latn-sb", kwg: "kwg-latn-td", kwh: "kwh-latn-id", kwi: "kwi-latn-co", kwj: "kwj-latn-zz", kwk: "kwk-latn-ca", kwl: "kwl-latn-ng", kwm: "kwm-latn-na", kwn: "kwn-latn-na", kwo: "kwo-latn-zz", kwp: "kwp-latn-ci", kwq: "kwq-latn-zz", kwr: "kwr-latn-id", kws: "kws-latn-cd", kwt: "kwt-latn-id", kwu: "kwu-latn-cm", kwv: "kwv-latn-td", kww: "kww-latn-sr", kwy: "kwy-latn-cd", kwz: "kwz-latn-ao", kxa: "kxa-latn-zz", kxb: "kxb-latn-ci", kxc: "kxc-ethi-zz", kxd: "kxd-latn-bn", "kxd-arab": "kxd-arab-bn", kxe: "kxe-latn-zz", kxf: "kxf-mymr-mm", "kxf-latn": "kxf-latn-mm", kxi: "kxi-latn-my", kxj: "kxj-latn-td", kxk: "kxk-mymr-mm", kxl: "kxl-deva-in", kxm: "kxm-thai-th", kxn: "kxn-latn-my", kxo: "kxo-latn-br", kxp: "kxp-arab-pk", kxq: "kxq-latn-id", kxr: "kxr-latn-pg", kxt: "kxt-latn-pg", kxv: "kxv-orya-in", "kxv-latn": "kxv-latn-in", "kxv-telu": "kxv-telu-in", kxw: "kxw-latn-zz", kxx: "kxx-latn-cg", kxy: "kxy-latn-vn", kxz: "kxz-latn-zz", ky: "ky-cyrl-kg", "ky-arab": "ky-arab-cn", "ky-cn": "ky-arab-cn", "ky-latn": "ky-latn-tr", "ky-tr": "ky-latn-tr", kya: "kya-latn-tz", kyb: "kyb-latn-ph", kyc: "kyc-latn-pg", kyd: "kyd-latn-id", kye: "kye-latn-zz", kyf: "kyf-latn-ci", kyg: "kyg-latn-pg", kyh: "kyh-latn-us", kyi: "kyi-latn-my", kyj: "kyj-latn-ph", kyk: "kyk-latn-ph", kyl: "kyl-latn-us", kym: "kym-latn-cf", kyn: "kyn-latn-ph", kyo: "kyo-latn-id", kyq: "kyq-latn-td", kyr: "kyr-latn-br", kys: "kys-latn-my", kyt: "kyt-latn-id", kyu: "kyu-kali-mm", "kyu-latn": "kyu-latn-mm", "kyu-mymr": "kyu-mymr-mm", kyv: "kyv-deva-np", kyw: "kyw-deva-in", "kyw-beng": "kyw-beng-in", "kyw-orya": "kyw-orya-in", kyx: "kyx-latn-zz", kyy: "kyy-latn-pg", kyz: "kyz-latn-br", kza: "kza-latn-bf", kzb: "kzb-latn-id", kzc: "kzc-latn-ci", kzd: "kzd-latn-id", kze: "kze-latn-pg", kzf: "kzf-latn-id", kzh: "kzh-arab-zz", kzi: "kzi-latn-my", kzj: "kzj-latn-my", kzk: "kzk-latn-sb", kzl: "kzl-latn-id", kzm: "kzm-latn-id", kzn: "kzn-latn-mw", kzo: "kzo-latn-ga", kzp: "kzp-latn-id", kzr: "kzr-latn-zz", kzs: "kzs-latn-my", kzt: "kzt-latn-my", kzu: "kzu-latn-id", kzv: "kzv-latn-id", kzw: "kzw-latn-br", kzx: "kzx-latn-id", kzy: "kzy-latn-cd", kzz: "kzz-latn-id", la: "la-latn-va", laa: "laa-latn-ph", lab: "lab-lina-gr", lac: "lac-latn-mx", lad: "lad-hebr-il", lae: "lae-deva-in", "lae-tibt": "lae-tibt-in", lag: "lag-latn-tz", lah: "lah-arab-pk", lai: "lai-latn-mw", laj: "laj-latn-ug", lal: "lal-latn-cd", lam: "lam-latn-zm", lan: "lan-latn-ng", lap: "lap-latn-td", laq: "laq-latn-vn", lar: "lar-latn-gh", las: "las-latn-zz", lau: "lau-latn-id", law: "law-latn-id", lax: "lax-latn-in", "lax-beng": "lax-beng-in", laz: "laz-latn-pg", lb: "lb-latn-lu", lbb: "lbb-latn-pg", lbc: "lbc-lisu-cn", lbe: "lbe-cyrl-ru", lbf: "lbf-deva-in", "lbf-tibt": "lbf-tibt-cn", lbi: "lbi-latn-cm", lbj: "lbj-tibt-in", "lbj-arab": "lbj-arab-in", lbl: "lbl-latn-ph", lbm: "lbm-deva-in", lbn: "lbn-latn-la", "lbn-laoo": "lbn-laoo-la", lbo: "lbo-laoo-la", "lbo-latn": "lbo-latn-us", lbq: "lbq-latn-pg", lbr: "lbr-deva-np", lbt: "lbt-latn-vn", lbu: "lbu-latn-zz", lbv: "lbv-latn-pg", lbw: "lbw-latn-id", lbx: "lbx-latn-id", lby: "lby-latn-au", lbz: "lbz-latn-au", lcc: "lcc-latn-id", lcd: "lcd-latn-id", lce: "lce-latn-id", lcf: "lcf-latn-id", lch: "lch-latn-ao", lcl: "lcl-latn-id", lcm: "lcm-latn-zz", lcp: "lcp-thai-cn", lcq: "lcq-latn-id", lcs: "lcs-latn-id", lda: "lda-latn-ci", ldb: "ldb-latn-zz", ldd: "ldd-latn-ng", ldg: "ldg-latn-ng", ldh: "ldh-latn-ng", ldi: "ldi-latn-cg", ldj: "ldj-latn-ng", ldk: "ldk-latn-ng", ldl: "ldl-latn-ng", ldm: "ldm-latn-gn", ldn: "ldn-latn-001", ldo: "ldo-latn-ng", ldp: "ldp-latn-ng", ldq: "ldq-latn-ng", lea: "lea-latn-cd", leb: "leb-latn-zm", lec: "lec-latn-bo", led: "led-latn-zz", lee: "lee-latn-zz", lef: "lef-latn-gh", leh: "leh-latn-zm", lei: "lei-latn-pg", lej: "lej-latn-cd", lek: "lek-latn-pg", lel: "lel-latn-cd", lem: "lem-latn-zz", len: "len-latn-hn", leo: "leo-latn-cm", lep: "lep-lepc-in", leq: "leq-latn-zz", ler: "ler-latn-pg", les: "les-latn-cd", let: "let-latn-pg", leu: "leu-latn-zz", lev: "lev-latn-id", lew: "lew-latn-id", lex: "lex-latn-id", ley: "ley-latn-id", lez: "lez-cyrl-ru", lfa: "lfa-latn-cm", lfn: "lfn-latn-001", "lfn-cyrl": "lfn-cyrl-001", lg: "lg-latn-ug", lga: "lga-latn-sb", lgb: "lgb-latn-sb", lgg: "lgg-latn-zz", lgh: "lgh-latn-vn", lgi: "lgi-latn-id", lgk: "lgk-latn-vu", lgl: "lgl-latn-sb", lgm: "lgm-latn-cd", lgn: "lgn-latn-et", lgo: "lgo-latn-ss", lgq: "lgq-latn-gh", lgr: "lgr-latn-sb", lgt: "lgt-latn-pg", lgu: "lgu-latn-sb", lgz: "lgz-latn-cd", lha: "lha-latn-vn", lhh: "lhh-latn-id", lhi: "lhi-latn-cn", lhm: "lhm-deva-np", lhn: "lhn-latn-my", lhs: "lhs-syrc-sy", lht: "lht-latn-vu", lhu: "lhu-latn-cn", li: "li-latn-nl", lia: "lia-latn-zz", lib: "lib-latn-pg", lic: "lic-latn-cn", lid: "lid-latn-zz", lie: "lie-latn-cd", lif: "lif-deva-np", "lif-limb": "lif-limb-in", lig: "lig-latn-zz", lih: "lih-latn-zz", lij: "lij-latn-it", lik: "lik-latn-cd", lil: "lil-latn-ca", lio: "lio-latn-id", lip: "lip-latn-gh", liq: "liq-latn-et", lir: "lir-latn-lr", lis: "lis-lisu-cn", liu: "liu-latn-sd", liv: "liv-latn-lv", liw: "liw-latn-id", lix: "lix-latn-id", liy: "liy-latn-cf", liz: "liz-latn-cd", lja: "lja-latn-au", lje: "lje-latn-id", lji: "lji-latn-id", ljl: "ljl-latn-id", ljp: "ljp-latn-id", ljw: "ljw-latn-au", ljx: "ljx-latn-au", lka: "lka-latn-tl", lkb: "lkb-latn-ke", lkc: "lkc-latn-vn", lkd: "lkd-latn-br", lke: "lke-latn-ug", lkh: "lkh-tibt-bt", lki: "lki-arab-ir", lkj: "lkj-latn-my", lkl: "lkl-latn-pg", lkm: "lkm-latn-au", lkn: "lkn-latn-vu", lko: "lko-latn-ke", lkr: "lkr-latn-ss", lks: "lks-latn-ke", lkt: "lkt-latn-us", lku: "lku-latn-au", lky: "lky-latn-ss", lla: "lla-latn-ng", llb: "llb-latn-mz", llc: "llc-latn-gn", lld: "lld-latn-it", lle: "lle-latn-zz", llf: "llf-latn-pg", llg: "llg-latn-id", lli: "lli-latn-cg", llj: "llj-latn-au", llk: "llk-latn-my", lll: "lll-latn-pg", llm: "llm-latn-id", lln: "lln-latn-zz", llp: "llp-latn-vu", llq: "llq-latn-id", llu: "llu-latn-sb", llx: "llx-latn-fj", lma: "lma-latn-gn", lmb: "lmb-latn-vu", lmc: "lmc-latn-au", lmd: "lmd-latn-sd", lme: "lme-latn-td", lmf: "lmf-latn-id", lmg: "lmg-latn-pg", lmh: "lmh-deva-np", lmi: "lmi-latn-cd", lmj: "lmj-latn-id", lmk: "lmk-latn-in", "lmk-mymr": "lmk-mymr-in", lml: "lml-latn-vu", lmn: "lmn-telu-in", lmo: "lmo-latn-it", lmp: "lmp-latn-zz", lmq: "lmq-latn-id", lmr: "lmr-latn-id", lmu: "lmu-latn-vu", lmv: "lmv-latn-fj", lmw: "lmw-latn-us", lmx: "lmx-latn-cm", lmy: "lmy-latn-id", ln: "ln-latn-cd", lna: "lna-latn-cf", lnb: "lnb-latn-na", lnd: "lnd-latn-id", lnh: "lnh-latn-my", lni: "lni-latn-pg", lnj: "lnj-latn-au", lnl: "lnl-latn-cf", lnm: "lnm-latn-pg", lnn: "lnn-latn-vu", lns: "lns-latn-zz", lnu: "lnu-latn-zz", lnw: "lnw-latn-au", lnz: "lnz-latn-cd", lo: "lo-laoo-la", loa: "loa-latn-id", lob: "lob-latn-bf", loc: "loc-latn-ph", loe: "loe-latn-id", log: "log-latn-cd", loh: "loh-latn-ss", loi: "loi-latn-ci", loj: "loj-latn-zz", lok: "lok-latn-zz", lol: "lol-latn-cd", lom: "lom-latn-lr", lon: "lon-latn-mw", loo: "loo-latn-cd", lop: "lop-latn-ng", loq: "loq-latn-cd", lor: "lor-latn-zz", los: "los-latn-zz", lot: "lot-latn-ss", "lot-arab": "lot-arab-ss", lou: "lou-latn-us", low: "low-latn-my", lox: "lox-latn-id", loy: "loy-deva-np", "loy-tibt": "loy-tibt-np", loz: "loz-latn-zm", lpa: "lpa-latn-vu", lpe: "lpe-latn-id", lpn: "lpn-latn-mm", lpo: "lpo-plrd-cn", "lpo-lisu": "lpo-lisu-cn", lpx: "lpx-latn-ss", lqr: "lqr-latn-ss", lra: "lra-latn-my", lrc: "lrc-arab-ir", lrg: "lrg-latn-au", lri: "lri-latn-ke", lrk: "lrk-arab-pk", lrl: "lrl-arab-ir", lrm: "lrm-latn-ke", lrn: "lrn-latn-id", lro: "lro-latn-sd", lrt: "lrt-latn-id", lrv: "lrv-latn-vu", lrz: "lrz-latn-vu", lsa: "lsa-arab-ir", lsd: "lsd-hebr-il", lse: "lse-latn-cd", lsi: "lsi-latn-mm", lsm: "lsm-latn-ug", lsr: "lsr-latn-pg", lss: "lss-arab-pk", lt: "lt-latn-lt", ltg: "ltg-latn-lv", lth: "lth-latn-ug", lti: "lti-latn-id", ltn: "ltn-latn-br", lto: "lto-latn-ke", lts: "lts-latn-ke", ltu: "ltu-latn-id", lu: "lu-latn-cd", lua: "lua-latn-cd", luc: "luc-latn-ug", lud: "lud-latn-ru", lue: "lue-latn-zm", luf: "luf-latn-pg", lui: "lui-latn-us", luj: "luj-latn-cd", luk: "luk-tibt-bt", lul: "lul-latn-ss", lum: "lum-latn-ao", lun: "lun-latn-zm", luo: "luo-latn-ke", lup: "lup-latn-ga", luq: "luq-latn-cu", lur: "lur-latn-id", lus: "lus-latn-in", "lus-beng": "lus-beng-bd", "lus-brai": "lus-brai-in", lut: "lut-latn-us", luu: "luu-deva-np", luv: "luv-arab-om", luw: "luw-latn-cm", luy: "luy-latn-ke", luz: "luz-arab-ir", lv: "lv-latn-lv", lva: "lva-latn-tl", lvi: "lvi-latn-la", lvk: "lvk-latn-sb", lvu: "lvu-latn-id", lwa: "lwa-latn-cd", lwe: "lwe-latn-id", lwg: "lwg-latn-ke", lwh: "lwh-latn-vn", lwl: "lwl-thai-th", lwm: "lwm-thai-cn", lwo: "lwo-latn-ss", "lwo-za": "lwo-latn-za", lwt: "lwt-latn-id", lww: "lww-latn-vu", lxm: "lxm-latn-pg", lya: "lya-tibt-bt", lyn: "lyn-latn-zm", lzh: "lzh-hans-cn", lzl: "lzl-latn-vu", lzn: "lzn-latn-mm", lzz: "lzz-latn-tr", maa: "maa-latn-mx", mab: "mab-latn-mx", mad: "mad-latn-id", mae: "mae-latn-ng", maf: "maf-latn-cm", mag: "mag-deva-in", mai: "mai-deva-in", maj: "maj-latn-mx", mak: "mak-latn-id", mam: "mam-latn-gt", man: "man-latn-gm", "man-gn": "man-nkoo-gn", "man-nkoo": "man-nkoo-gn", maq: "maq-latn-mx", mas: "mas-latn-ke", mat: "mat-latn-mx", mau: "mau-latn-mx", mav: "mav-latn-br", maw: "maw-latn-zz", max: "max-latn-id", maz: "maz-latn-mx", mba: "mba-latn-ph", mbb: "mbb-latn-ph", mbc: "mbc-latn-br", mbd: "mbd-latn-ph", mbf: "mbf-latn-sg", mbh: "mbh-latn-zz", mbi: "mbi-latn-ph", mbj: "mbj-latn-br", mbk: "mbk-latn-pg", mbl: "mbl-latn-br", mbm: "mbm-latn-cg", mbn: "mbn-latn-co", mbo: "mbo-latn-zz", mbp: "mbp-latn-co", mbq: "mbq-latn-zz", mbr: "mbr-latn-co", mbs: "mbs-latn-ph", mbt: "mbt-latn-ph", mbu: "mbu-latn-zz", mbv: "mbv-latn-gn", mbw: "mbw-latn-zz", mbx: "mbx-latn-pg", mby: "mby-arab-pk", mbz: "mbz-latn-mx", mca: "mca-latn-py", mcb: "mcb-latn-pe", mcc: "mcc-latn-pg", mcd: "mcd-latn-pe", mce: "mce-latn-mx", mcf: "mcf-latn-pe", mcg: "mcg-latn-ve", mch: "mch-latn-ve", mci: "mci-latn-zz", mcj: "mcj-latn-ng", mck: "mck-latn-ao", mcl: "mcl-latn-co", mcm: "mcm-latn-my", mcn: "mcn-latn-td", mco: "mco-latn-mx", mcp: "mcp-latn-zz", mcq: "mcq-latn-zz", mcr: "mcr-latn-zz", mcs: "mcs-latn-cm", mct: "mct-latn-cm", mcu: "mcu-latn-zz", mcv: "mcv-latn-pg", mcw: "mcw-latn-td", mcx: "mcx-latn-cf", mcy: "mcy-latn-pg", mcz: "mcz-latn-pg", mda: "mda-latn-zz", mdb: "mdb-latn-pg", mdc: "mdc-latn-pg", mdd: "mdd-latn-cm", mde: "mde-arab-zz", mdf: "mdf-cyrl-ru", mdg: "mdg-latn-td", mdh: "mdh-latn-ph", mdi: "mdi-latn-cd", mdj: "mdj-latn-zz", mdk: "mdk-latn-cd", mdm: "mdm-latn-cd", mdn: "mdn-latn-cf", mdp: "mdp-latn-cd", mdq: "mdq-latn-cd", mdr: "mdr-latn-id", mds: "mds-latn-pg", mdt: "mdt-latn-cg", mdu: "mdu-latn-cg", mdv: "mdv-latn-mx", mdw: "mdw-latn-cg", mdx: "mdx-ethi-zz", mdy: "mdy-ethi-et", "mdy-latn": "mdy-latn-et", mdz: "mdz-latn-br", mea: "mea-latn-cm", meb: "meb-latn-pg", mec: "mec-latn-au", med: "med-latn-zz", mee: "mee-latn-zz", meh: "meh-latn-mx", mej: "mej-latn-id", mek: "mek-latn-zz", mel: "mel-latn-my", mem: "mem-latn-au", men: "men-latn-sl", meo: "meo-latn-my", "meo-arab": "meo-arab-my", mep: "mep-latn-au", meq: "meq-latn-cm", mer: "mer-latn-ke", mes: "mes-latn-td", met: "met-latn-zz", meu: "meu-latn-zz", mev: "mev-latn-lr", mew: "mew-latn-ng", mey: "mey-latn-mr", "mey-arab": "mey-arab-mr", mez: "mez-latn-us", mfa: "mfa-arab-th", mfb: "mfb-latn-id", mfc: "mfc-latn-cd", mfd: "mfd-latn-cm", mfe: "mfe-latn-mu", mff: "mff-latn-cm", mfg: "mfg-latn-gn", "mfg-arab": "mfg-arab-gn", mfh: "mfh-latn-cm", mfi: "mfi-arab-cm", "mfi-latn": "mfi-latn-cm", mfj: "mfj-latn-cm", mfk: "mfk-latn-cm", mfl: "mfl-latn-ng", mfm: "mfm-latn-ng", mfn: "mfn-latn-zz", mfo: "mfo-latn-zz", mfp: "mfp-latn-id", mfq: "mfq-latn-zz", mfr: "mfr-latn-au", mft: "mft-latn-pg", mfu: "mfu-latn-ao", mfv: "mfv-latn-gw", mfw: "mfw-latn-pg", mfx: "mfx-latn-et", "mfx-ethi": "mfx-ethi-et", mfy: "mfy-latn-mx", mfz: "mfz-latn-ss", mg: "mg-latn-mg", mgb: "mgb-latn-td", mgc: "mgc-latn-ss", mgd: "mgd-latn-ss", "mgd-arab": "mgd-arab-ss", mge: "mge-latn-td", mgf: "mgf-latn-id", mgg: "mgg-latn-cm", mgh: "mgh-latn-mz", mgi: "mgi-latn-ng", mgj: "mgj-latn-ng", mgk: "mgk-latn-id", mgl: "mgl-latn-zz", mgm: "mgm-latn-tl", mgn: "mgn-latn-cf", mgo: "mgo-latn-cm", mgp: "mgp-deva-np", mgq: "mgq-latn-tz", mgr: "mgr-latn-zm", mgs: "mgs-latn-tz", mgt: "mgt-latn-pg", mgu: "mgu-latn-pg", mgv: "mgv-latn-tz", mgw: "mgw-latn-tz", mgy: "mgy-latn-tz", mgz: "mgz-latn-tz", mh: "mh-latn-mh", mhb: "mhb-latn-ga", mhc: "mhc-latn-mx", mhd: "mhd-latn-tz", mhe: "mhe-latn-my", mhf: "mhf-latn-pg", mhg: "mhg-latn-au", mhi: "mhi-latn-zz", mhj: "mhj-arab-af", mhk: "mhk-latn-cm", mhl: "mhl-latn-zz", mhm: "mhm-latn-mz", mhn: "mhn-latn-it", mho: "mho-latn-zm", mhp: "mhp-latn-id", mhq: "mhq-latn-us", mhs: "mhs-latn-id", mht: "mht-latn-ve", mhu: "mhu-latn-in", mhw: "mhw-latn-bw", mhx: "mhx-latn-mm", mhy: "mhy-latn-id", mhz: "mhz-latn-id", mi: "mi-latn-nz", mia: "mia-latn-us", mib: "mib-latn-mx", mic: "mic-latn-ca", mid: "mid-mand-iq", mie: "mie-latn-mx", mif: "mif-latn-zz", mig: "mig-latn-mx", mih: "mih-latn-mx", mii: "mii-latn-mx", mij: "mij-latn-cm", mik: "mik-latn-us", mil: "mil-latn-mx", mim: "mim-latn-mx", min: "min-latn-id", mio: "mio-latn-mx", mip: "mip-latn-mx", miq: "miq-latn-ni", mir: "mir-latn-mx", mit: "mit-latn-mx", miu: "miu-latn-mx", miw: "miw-latn-zz", mix: "mix-latn-mx", miy: "miy-latn-mx", miz: "miz-latn-mx", mjb: "mjb-latn-tl", mjc: "mjc-latn-mx", mjd: "mjd-latn-us", mje: "mje-latn-td", mjg: "mjg-latn-cn", mjh: "mjh-latn-tz", mji: "mji-latn-cn", mjj: "mjj-latn-pg", mjk: "mjk-latn-pg", mjl: "mjl-deva-in", "mjl-takr": "mjl-takr-in", mjm: "mjm-latn-pg", mjn: "mjn-latn-pg", mjq: "mjq-mlym-in", mjr: "mjr-mlym-in", mjs: "mjs-latn-ng", mjt: "mjt-deva-in", "mjt-beng": "mjt-beng-bd", mju: "mju-telu-in", mjv: "mjv-mlym-in", mjw: "mjw-latn-in", mjx: "mjx-latn-bd", "mjx-beng": "mjx-beng-bd", mjy: "mjy-latn-us", mjz: "mjz-deva-np", mk: "mk-cyrl-mk", mka: "mka-latn-ci", mkb: "mkb-deva-in", mkc: "mkc-latn-pg", mke: "mke-deva-in", mkf: "mkf-latn-ng", mki: "mki-arab-zz", mkj: "mkj-latn-fm", mkk: "mkk-latn-cm", mkl: "mkl-latn-zz", mkm: "mkm-thai-th", mkn: "mkn-latn-id", mko: "mko-latn-ng", mkp: "mkp-latn-zz", mkr: "mkr-latn-pg", mks: "mks-latn-mx", mkt: "mkt-latn-nc", mku: "mku-latn-gn", mkv: "mkv-latn-vu", mkw: "mkw-latn-zz", mkx: "mkx-latn-ph", mky: "mky-latn-id", mkz: "mkz-latn-tl", ml: "ml-mlym-in", mla: "mla-latn-vu", mlb: "mlb-latn-cm", mlc: "mlc-latn-vn", mle: "mle-latn-zz", mlf: "mlf-thai-la", "mlf-latn": "mlf-latn-la", mlh: "mlh-latn-pg", mli: "mli-latn-id", mlj: "mlj-latn-td", mlk: "mlk-latn-ke", mll: "mll-latn-vu", mln: "mln-latn-sb", mlo: "mlo-latn-sn", mlp: "mlp-latn-zz", mlq: "mlq-latn-sn", "mlq-arab": "mlq-arab-sn", mlr: "mlr-latn-cm", mls: "mls-latn-sd", mlu: "mlu-latn-sb", mlv: "mlv-latn-vu", mlw: "mlw-latn-cm", mlx: "mlx-latn-vu", mlz: "mlz-latn-ph", mma: "mma-latn-ng", mmb: "mmb-latn-id", mmc: "mmc-latn-mx", mmd: "mmd-latn-cn", "mmd-hans": "mmd-hans-cn", "mmd-hant": "mmd-hant-cn", mme: "mme-latn-vu", mmf: "mmf-latn-ng", mmg: "mmg-latn-vu", mmh: "mmh-latn-br", mmi: "mmi-latn-pg", mmm: "mmm-latn-vu", mmn: "mmn-latn-ph", mmo: "mmo-latn-zz", mmp: "mmp-latn-pg", mmq: "mmq-latn-pg", mmr: "mmr-latn-cn", mmt: "mmt-latn-pg", mmu: "mmu-latn-zz", mmv: "mmv-latn-br", mmw: "mmw-latn-vu", mmx: "mmx-latn-zz", mmy: "mmy-latn-td", mmz: "mmz-latn-cd", mn: "mn-cyrl-mn", "mn-cn": "mn-mong-cn", "mn-mong": "mn-mong-cn", mna: "mna-latn-zz", mnb: "mnb-latn-id", mnd: "mnd-latn-br", mne: "mne-latn-td", mnf: "mnf-latn-zz", mng: "mng-latn-vn", mnh: "mnh-latn-cd", mni: "mni-beng-in", mnj: "mnj-arab-af", mnl: "mnl-latn-vu", mnm: "mnm-latn-pg", mnn: "mnn-latn-vn", mnp: "mnp-latn-cn", mnq: "mnq-latn-my", mnr: "mnr-latn-us", mns: "mns-cyrl-ru", mnu: "mnu-latn-id", mnv: "mnv-latn-sb", mnw: "mnw-mymr-mm", mnx: "mnx-latn-id", mny: "mny-latn-mz", mnz: "mnz-latn-id", mo: "mo-latn-ro", moa: "moa-latn-zz", moc: "moc-latn-ar", mod: "mod-latn-us", moe: "moe-latn-ca", mog: "mog-latn-id", moh: "moh-latn-ca", moi: "moi-latn-ng", moj: "moj-latn-cg", mok: "mok-latn-id", mom: "mom-latn-ni", moo: "moo-latn-vn", mop: "mop-latn-bz", moq: "moq-latn-id", mor: "mor-latn-sd", mos: "mos-latn-bf", mot: "mot-latn-co", mou: "mou-latn-td", mov: "mov-latn-us", mow: "mow-latn-cg", mox: "mox-latn-zz", moy: "moy-latn-et", "moy-ethi": "moy-ethi-et", moz: "moz-latn-td", mpa: "mpa-latn-tz", mpb: "mpb-latn-au", mpc: "mpc-latn-au", mpd: "mpd-latn-br", mpe: "mpe-latn-et", "mpe-ethi": "mpe-ethi-et", mpg: "mpg-latn-td", mph: "mph-latn-au", mpi: "mpi-latn-cm", mpj: "mpj-latn-au", mpk: "mpk-latn-td", mpl: "mpl-latn-pg", mpm: "mpm-latn-mx", mpn: "mpn-latn-pg", mpo: "mpo-latn-pg", mpp: "mpp-latn-zz", mpq: "mpq-latn-br", mpr: "mpr-latn-sb", mps: "mps-latn-zz", mpt: "mpt-latn-zz", mpu: "mpu-latn-br", mpv: "mpv-latn-pg", mpw: "mpw-latn-br", mpx: "mpx-latn-zz", mpy: "mpy-latn-id", mpz: "mpz-thai-th", mqa: "mqa-latn-id", mqb: "mqb-latn-cm", mqc: "mqc-latn-id", mqe: "mqe-latn-pg", mqf: "mqf-latn-id", mqg: "mqg-latn-id", mqh: "mqh-latn-mx", mqi: "mqi-latn-id", mqj: "mqj-latn-id", mqk: "mqk-latn-ph", mql: "mql-latn-zz", mqm: "mqm-latn-pf", mqn: "mqn-latn-id", mqo: "mqo-latn-id", mqp: "mqp-latn-id", mqq: "mqq-latn-my", mqr: "mqr-latn-id", mqs: "mqs-latn-id", mqu: "mqu-latn-ss", mqv: "mqv-latn-pg", mqw: "mqw-latn-pg", mqx: "mqx-latn-id", "mqx-bugi": "mqx-bugi-id", mqy: "mqy-latn-id", mqz: "mqz-latn-pg", mr: "mr-deva-in", mra: "mra-thai-th", mrb: "mrb-latn-vu", mrc: "mrc-latn-us", mrd: "mrd-deva-np", mrf: "mrf-latn-id", mrg: "mrg-latn-in", "mrg-beng": "mrg-beng-in", "mrg-deva": "mrg-deva-in", mrh: "mrh-latn-in", mrj: "mrj-cyrl-ru", mrk: "mrk-latn-nc", mrl: "mrl-latn-fm", mrm: "mrm-latn-vu", mrn: "mrn-latn-sb", mro: "mro-mroo-bd", mrp: "mrp-latn-vu", mrq: "mrq-latn-pf", mrr: "mrr-deva-in", mrs: "mrs-latn-vu", mrt: "mrt-latn-ng", mru: "mru-latn-cm", mrv: "mrv-latn-pf", mrw: "mrw-latn-ph", "mrw-arab": "mrw-arab-ph", mrx: "mrx-latn-id", mry: "mry-latn-ph", mrz: "mrz-latn-id", ms: "ms-latn-my", "ms-cc": "ms-arab-cc", msb: "msb-latn-ph", msc: "msc-latn-gn", mse: "mse-latn-td", msf: "msf-latn-id", msg: "msg-latn-id", msh: "msh-latn-mg", msi: "msi-latn-my", msj: "msj-latn-cd", msk: "msk-latn-ph", msl: "msl-latn-id", msm: "msm-latn-ph", msn: "msn-latn-vu", mso: "mso-latn-id", msp: "msp-latn-br", msq: "msq-latn-nc", mss: "mss-latn-id", msu: "msu-latn-pg", msv: "msv-latn-cm", msw: "msw-latn-gw", msx: "msx-latn-pg", msy: "msy-latn-pg", msz: "msz-latn-pg", mt: "mt-latn-mt", mta: "mta-latn-ph", mtb: "mtb-latn-ci", mtc: "mtc-latn-zz", mtd: "mtd-latn-id", mte: "mte-latn-sb", mtf: "mtf-latn-zz", mtg: "mtg-latn-id", mth: "mth-latn-id", mti: "mti-latn-zz", mtj: "mtj-latn-id", mtk: "mtk-latn-cm", mtl: "mtl-latn-ng", mtm: "mtm-cyrl-ru", mtn: "mtn-latn-ni", mto: "mto-latn-mx", mtp: "mtp-latn-bo", mtq: "mtq-latn-vn", mtr: "mtr-deva-in", mts: "mts-latn-pe", mtt: "mtt-latn-vu", mtu: "mtu-latn-mx", mtv: "mtv-latn-pg", mtw: "mtw-latn-ph", mtx: "mtx-latn-mx", mty: "mty-latn-pg", mua: "mua-latn-cm", mub: "mub-latn-td", muc: "muc-latn-cm", mud: "mud-cyrl-ru", mue: "mue-latn-ec", mug: "mug-latn-cm", muh: "muh-latn-ss", mui: "mui-latn-id", muj: "muj-latn-td", muk: "muk-tibt-np", mum: "mum-latn-pg", muo: "muo-latn-cm", muq: "muq-latn-cn", mur: "mur-latn-zz", mus: "mus-latn-us", mut: "mut-deva-in", muu: "muu-latn-ke", muv: "muv-taml-in", mux: "mux-latn-pg", muy: "muy-latn-cm", muz: "muz-ethi-et", "muz-latn": "muz-latn-et", mva: "mva-latn-zz", mvd: "mvd-latn-id", mvf: "mvf-mong-cn", "mvf-phag": "mvf-phag-cn", mvg: "mvg-latn-mx", mvh: "mvh-latn-td", mvk: "mvk-latn-pg", mvl: "mvl-latn-au", mvn: "mvn-latn-zz", mvo: "mvo-latn-sb", mvp: "mvp-latn-id", mvq: "mvq-latn-pg", mvr: "mvr-latn-id", mvs: "mvs-latn-id", mvt: "mvt-latn-vu", mvu: "mvu-latn-td", mvv: "mvv-latn-my", mvw: "mvw-latn-tz", mvx: "mvx-latn-id", mvy: "mvy-arab-pk", mvz: "mvz-ethi-et", "mvz-arab": "mvz-arab-et", mwa: "mwa-latn-pg", mwb: "mwb-latn-pg", mwc: "mwc-latn-pg", mwe: "mwe-latn-tz", mwf: "mwf-latn-au", mwg: "mwg-latn-pg", mwh: "mwh-latn-pg", mwi: "mwi-latn-vu", mwk: "mwk-latn-ml", mwl: "mwl-latn-pt", mwm: "mwm-latn-td", mwn: "mwn-latn-zm", mwo: "mwo-latn-vu", mwp: "mwp-latn-au", mwq: "mwq-latn-mm", mwr: "mwr-deva-in", mws: "mws-latn-ke", mwt: "mwt-mymr-mm", "mwt-thai": "mwt-thai-th", mwu: "mwu-latn-ss", mwv: "mwv-latn-id", mww: "mww-hmnp-us", mwz: "mwz-latn-cd", mxa: "mxa-latn-mx", mxb: "mxb-latn-mx", mxc: "mxc-latn-zw", mxd: "mxd-latn-id", mxe: "mxe-latn-vu", mxf: "mxf-latn-cm", mxg: "mxg-latn-ao", mxh: "mxh-latn-cd", mxi: "mxi-latn-es", mxj: "mxj-latn-in", mxk: "mxk-latn-pg", mxl: "mxl-latn-bj", mxm: "mxm-latn-zz", mxn: "mxn-latn-id", mxo: "mxo-latn-zm", mxp: "mxp-latn-mx", mxq: "mxq-latn-mx", mxr: "mxr-latn-my", mxs: "mxs-latn-mx", mxt: "mxt-latn-mx", mxu: "mxu-latn-cm", mxv: "mxv-latn-mx", mxw: "mxw-latn-pg", mxx: "mxx-latn-ci", mxy: "mxy-latn-mx", mxz: "mxz-latn-id", my: "my-mymr-mm", myb: "myb-latn-td", myc: "myc-latn-cd", mye: "mye-latn-ga", myf: "myf-latn-et", myg: "myg-latn-cm", myh: "myh-latn-us", myj: "myj-latn-ss", myk: "myk-latn-zz", myl: "myl-latn-id", mym: "mym-ethi-zz", myp: "myp-latn-br", myr: "myr-latn-pe", myu: "myu-latn-br", myv: "myv-cyrl-ru", myw: "myw-latn-zz", myx: "myx-latn-ug", myy: "myy-latn-co", myz: "myz-mand-ir", mza: "mza-latn-mx", mzd: "mzd-latn-cm", mze: "mze-latn-pg", mzh: "mzh-latn-ar", mzi: "mzi-latn-mx", mzj: "mzj-latn-lr", mzk: "mzk-latn-zz", mzl: "mzl-latn-mx", mzm: "mzm-latn-zz", mzn: "mzn-arab-ir", mzo: "mzo-latn-br", mzp: "mzp-latn-zz", mzq: "mzq-latn-id", mzr: "mzr-latn-br", mzt: "mzt-latn-my", mzu: "mzu-latn-pg", mzv: "mzv-latn-cf", mzw: "mzw-latn-zz", mzx: "mzx-latn-gy", mzz: "mzz-latn-zz", na: "na-latn-nr", naa: "naa-latn-id", nab: "nab-latn-br", nac: "nac-latn-zz", nae: "nae-latn-id", naf: "naf-latn-zz", nag: "nag-latn-in", naj: "naj-latn-gn", nak: "nak-latn-zz", nal: "nal-latn-pg", nam: "nam-latn-au", nan: "nan-hans-cn", nao: "nao-deva-np", nap: "nap-latn-it", naq: "naq-latn-na", nar: "nar-latn-ng", nas: "nas-latn-zz", nat: "nat-latn-ng", naw: "naw-latn-gh", nax: "nax-latn-pg", nay: "nay-latn-au", naz: "naz-latn-mx", nb: "nb-latn-no", nba: "nba-latn-ao", nbb: "nbb-latn-ng", nbc: "nbc-latn-in", nbd: "nbd-latn-cd", nbe: "nbe-latn-in", nbh: "nbh-latn-ng", nbi: "nbi-latn-in", nbj: "nbj-latn-au", nbk: "nbk-latn-pg", nbm: "nbm-latn-cf", nbn: "nbn-latn-id", nbo: "nbo-latn-ng", nbp: "nbp-latn-ng", nbq: "nbq-latn-id", nbr: "nbr-latn-ng", nbt: "nbt-latn-in", "nbt-deva": "nbt-deva-in", nbu: "nbu-latn-in", nbv: "nbv-latn-cm", nbw: "nbw-latn-cd", nby: "nby-latn-pg", nca: "nca-latn-zz", ncb: "ncb-latn-in", "ncb-deva": "ncb-deva-in", ncc: "ncc-latn-pg", ncd: "ncd-deva-np", nce: "nce-latn-zz", ncf: "ncf-latn-zz", ncg: "ncg-latn-ca", nch: "nch-latn-mx", nci: "nci-latn-mx", ncj: "ncj-latn-mx", nck: "nck-latn-au", ncl: "ncl-latn-mx", ncm: "ncm-latn-pg", ncn: "ncn-latn-pg", nco: "nco-latn-zz", ncq: "ncq-laoo-la", "ncq-thai": "ncq-thai-la", ncr: "ncr-latn-cm", nct: "nct-latn-in", "nct-beng": "nct-beng-in", ncu: "ncu-latn-zz", ncx: "ncx-latn-mx", ncz: "ncz-latn-us", nd: "nd-latn-zw", nda: "nda-latn-cg", ndb: "ndb-latn-cm", ndc: "ndc-latn-mz", ndd: "ndd-latn-ng", ndf: "ndf-cyrl-ru", ndg: "ndg-latn-tz", ndh: "ndh-latn-tz", ndi: "ndi-latn-ng", ndj: "ndj-latn-tz", ndk: "ndk-latn-cd", ndl: "ndl-latn-cd", ndm: "ndm-latn-td", ndn: "ndn-latn-cg", ndp: "ndp-latn-ug", ndq: "ndq-latn-ao", ndr: "ndr-latn-ng", nds: "nds-latn-de", ndt: "ndt-latn-cd", ndu: "ndu-latn-cm", ndv: "ndv-latn-sn", ndw: "ndw-latn-cd", ndx: "ndx-latn-id", ndy: "ndy-latn-cf", "ndy-td": "ndy-latn-td", ndz: "ndz-latn-ss", ne: "ne-deva-np", nea: "nea-latn-id", neb: "neb-latn-zz", nec: "nec-latn-id", ned: "ned-latn-ng", nee: "nee-latn-nc", neg: "neg-cyrl-ru", neh: "neh-tibt-bt", nei: "nei-xsux-tr", nej: "nej-latn-pg", nek: "nek-latn-nc", nem: "nem-latn-nc", nen: "nen-latn-nc", neo: "neo-latn-vn", neq: "neq-latn-mx", ner: "ner-latn-id", net: "net-latn-pg", neu: "neu-latn-001", new: "new-deva-np", nex: "nex-latn-zz", ney: "ney-latn-ci", nez: "nez-latn-us", nfa: "nfa-latn-id", nfd: "nfd-latn-ng", nfl: "nfl-latn-sb", nfr: "nfr-latn-zz", nfu: "nfu-latn-cm", ng: "ng-latn-na", nga: "nga-latn-zz", ngb: "ngb-latn-zz", ngc: "ngc-latn-cd", ngd: "ngd-latn-cf", nge: "nge-latn-cm", ngg: "ngg-latn-cf", ngh: "ngh-latn-za", ngi: "ngi-latn-ng", ngj: "ngj-latn-cm", ngk: "ngk-latn-au", ngl: "ngl-latn-mz", ngm: "ngm-latn-fm", ngn: "ngn-latn-cm", ngp: "ngp-latn-tz", ngq: "ngq-latn-tz", ngr: "ngr-latn-sb", ngs: "ngs-latn-ng", ngt: "ngt-laoo-la", ngu: "ngu-latn-mx", ngv: "ngv-latn-cm", ngw: "ngw-latn-ng", ngx: "ngx-latn-ng", ngy: "ngy-latn-cm", ngz: "ngz-latn-cg", nha: "nha-latn-au", nhb: "nhb-latn-zz", nhc: "nhc-latn-mx", nhd: "nhd-latn-py", nhe: "nhe-latn-mx", nhf: "nhf-latn-au", nhg: "nhg-latn-mx", nhi: "nhi-latn-mx", nhk: "nhk-latn-mx", nhm: "nhm-latn-mx", nhn: "nhn-latn-mx", nho: "nho-latn-pg", nhp: "nhp-latn-mx", nhq: "nhq-latn-mx", nhr: "nhr-latn-bw", nht: "nht-latn-mx", nhu: "nhu-latn-cm", nhv: "nhv-latn-mx", nhw: "nhw-latn-mx", nhx: "nhx-latn-mx", nhy: "nhy-latn-mx", nhz: "nhz-latn-mx", nia: "nia-latn-id", nib: "nib-latn-pg", nid: "nid-latn-au", nie: "nie-latn-td", nif: "nif-latn-zz", nig: "nig-latn-au", nih: "nih-latn-tz", nii: "nii-latn-zz", nij: "nij-latn-id", nil: "nil-latn-id", nim: "nim-latn-tz", nin: "nin-latn-zz", nio: "nio-cyrl-ru", niq: "niq-latn-ke", nir: "nir-latn-id", nis: "nis-latn-pg", nit: "nit-telu-in", niu: "niu-latn-nu", niv: "niv-cyrl-ru", "niv-latn": "niv-latn-ru", niw: "niw-latn-pg", nix: "nix-latn-cd", niy: "niy-latn-zz", niz: "niz-latn-zz", nja: "nja-latn-ng", njb: "njb-latn-in", njd: "njd-latn-tz", njh: "njh-latn-in", nji: "nji-latn-au", njj: "njj-latn-cm", njl: "njl-latn-ss", njm: "njm-latn-in", njn: "njn-latn-in", njo: "njo-latn-in", njr: "njr-latn-ng", njs: "njs-latn-id", njt: "njt-latn-sr", nju: "nju-latn-au", njx: "njx-latn-cg", njy: "njy-latn-cm", njz: "njz-latn-in", "njz-beng": "njz-beng-in", nka: "nka-latn-zm", nkb: "nkb-latn-in", nkc: "nkc-latn-cm", nkd: "nkd-latn-in", nke: "nke-latn-sb", nkf: "nkf-latn-in", nkg: "nkg-latn-zz", nkh: "nkh-latn-in", nki: "nki-latn-in", "nki-beng": "nki-beng-in", nkj: "nkj-latn-id", nkk: "nkk-latn-vu", nkm: "nkm-latn-pg", nkn: "nkn-latn-ao", nko: "nko-latn-zz", nkq: "nkq-latn-gh", nkr: "nkr-latn-fm", nks: "nks-latn-id", nkt: "nkt-latn-tz", nku: "nku-latn-ci", nkv: "nkv-latn-mw", nkw: "nkw-latn-cd", nkx: "nkx-latn-ng", nkz: "nkz-latn-ng", nl: "nl-latn-nl", nla: "nla-latn-cm", nlc: "nlc-latn-id", nle: "nle-latn-ke", nlg: "nlg-latn-sb", nli: "nli-arab-af", nlj: "nlj-latn-cd", nlk: "nlk-latn-id", nlm: "nlm-arab-pk", nlo: "nlo-latn-cd", nlq: "nlq-latn-mm", nlu: "nlu-latn-gh", nlv: "nlv-latn-mx", nlw: "nlw-latn-au", nlx: "nlx-deva-in", nly: "nly-latn-au", nlz: "nlz-latn-sb", nma: "nma-latn-in", nmb: "nmb-latn-vu", nmc: "nmc-latn-td", nmd: "nmd-latn-ga", nme: "nme-latn-in", nmf: "nmf-latn-in", nmg: "nmg-latn-cm", nmh: "nmh-latn-in", nmi: "nmi-latn-ng", nmj: "nmj-latn-cf", nmk: "nmk-latn-vu", nml: "nml-latn-cm", nmm: "nmm-deva-np", "nmm-tibt": "nmm-tibt-np", nmn: "nmn-latn-bw", nmo: "nmo-latn-in", "nmo-beng": "nmo-beng-in", nmp: "nmp-latn-au", nmq: "nmq-latn-zw", nmr: "nmr-latn-cm", nms: "nms-latn-vu", nmt: "nmt-latn-fm", nmu: "nmu-latn-us", nmv: "nmv-latn-au", nmw: "nmw-latn-pg", nmx: "nmx-latn-pg", nmz: "nmz-latn-zz", nn: "nn-latn-no", nna: "nna-latn-au", nnb: "nnb-latn-cd", nnc: "nnc-latn-td", nnd: "nnd-latn-vu", nne: "nne-latn-ao", nnf: "nnf-latn-zz", nng: "nng-latn-in", "nng-beng": "nng-beng-in", nnh: "nnh-latn-cm", nni: "nni-latn-id", nnj: "nnj-latn-et", nnk: "nnk-latn-zz", nnl: "nnl-latn-in", nnm: "nnm-latn-zz", nnn: "nnn-latn-td", nnp: "nnp-wcho-in", nnq: "nnq-latn-tz", nnr: "nnr-latn-au", nnt: "nnt-latn-us", nnu: "nnu-latn-gh", nnv: "nnv-latn-au", nnw: "nnw-latn-bf", nny: "nny-latn-au", nnz: "nnz-latn-cm", no: "no-latn-no", noa: "noa-latn-co", noc: "noc-latn-pg", nod: "nod-lana-th", noe: "noe-deva-in", nof: "nof-latn-pg", nog: "nog-cyrl-ru", noh: "noh-latn-pg", noi: "noi-deva-in", noj: "noj-latn-co", nok: "nok-latn-us", nom: "nom-latn-pe", non: "non-runr-se", nop: "nop-latn-zz", noq: "noq-latn-cd", nos: "nos-yiii-cn", not: "not-latn-pe", nou: "nou-latn-zz", nov: "nov-latn-001", now: "now-latn-tz", noy: "noy-latn-td", npb: "npb-tibt-bt", npg: "npg-latn-mm", nph: "nph-latn-in", npl: "npl-latn-mx", npn: "npn-latn-pg", npo: "npo-latn-in", nps: "nps-latn-id", npu: "npu-latn-in", npx: "npx-latn-sb", npy: "npy-latn-id", nqg: "nqg-latn-bj", nqk: "nqk-latn-bj", nql: "nql-latn-ao", nqm: "nqm-latn-id", nqn: "nqn-latn-pg", nqo: "nqo-nkoo-gn", nqq: "nqq-latn-mm", nqt: "nqt-latn-ng", nqy: "nqy-latn-mm", nr: "nr-latn-za", nra: "nra-latn-ga", nrb: "nrb-latn-zz", nre: "nre-latn-in", nrf: "nrf-latn-je", nrg: "nrg-latn-vu", nri: "nri-latn-in", nrk: "nrk-latn-au", nrl: "nrl-latn-au", nrm: "nrm-latn-my", nrp: "nrp-latn-it", nru: "nru-latn-cn", "nru-hans": "nru-hans-cn", "nru-hant": "nru-hant-cn", nrx: "nrx-latn-au", nrz: "nrz-latn-pg", nsa: "nsa-latn-in", nsb: "nsb-latn-za", nsc: "nsc-latn-ng", nsd: "nsd-yiii-cn", nse: "nse-latn-zm", nsf: "nsf-yiii-cn", nsg: "nsg-latn-tz", nsh: "nsh-latn-cm", nsk: "nsk-cans-ca", nsm: "nsm-latn-in", nsn: "nsn-latn-zz", nso: "nso-latn-za", nsq: "nsq-latn-us", nss: "nss-latn-zz", nst: "nst-tnsa-in", nsu: "nsu-latn-mx", nsv: "nsv-yiii-cn", nsw: "nsw-latn-vu", nsx: "nsx-latn-ao", nsy: "nsy-latn-id", nsz: "nsz-latn-us", ntd: "ntd-latn-my", nte: "nte-latn-mz", ntg: "ntg-latn-au", nti: "nti-latn-bf", ntj: "ntj-latn-au", ntk: "ntk-latn-tz", ntm: "ntm-latn-zz", nto: "nto-latn-cd", ntp: "ntp-latn-mx", ntr: "ntr-latn-zz", ntu: "ntu-latn-sb", ntx: "ntx-latn-mm", nty: "nty-yiii-vn", ntz: "ntz-arab-ir", nua: "nua-latn-nc", nuc: "nuc-latn-br", nud: "nud-latn-pg", nue: "nue-latn-cd", nuf: "nuf-latn-cn", nug: "nug-latn-au", nuh: "nuh-latn-ng", nui: "nui-latn-zz", nuj: "nuj-latn-ug", nuk: "nuk-latn-ca", num: "num-latn-to", nun: "nun-latn-mm", nuo: "nuo-latn-vn", nup: "nup-latn-zz", nuq: "nuq-latn-pg", nur: "nur-latn-pg", nus: "nus-latn-ss", nut: "nut-latn-vn", nuu: "nuu-latn-cd", nuv: "nuv-latn-zz", nuw: "nuw-latn-fm", nux: "nux-latn-zz", nuy: "nuy-latn-au", nuz: "nuz-latn-mx", nv: "nv-latn-us", nvh: "nvh-latn-vu", nvm: "nvm-latn-pg", nvo: "nvo-latn-cm", nwb: "nwb-latn-zz", nwc: "nwc-newa-np", "nwc-brah": "nwc-brah-np", "nwc-deva": "nwc-deva-np", "nwc-sidd": "nwc-sidd-np", nwe: "nwe-latn-cm", nwg: "nwg-latn-au", nwi: "nwi-latn-vu", nwm: "nwm-latn-ss", nwo: "nwo-latn-au", nwr: "nwr-latn-pg", nww: "nww-latn-tz", nwx: "nwx-deva-np", nxa: "nxa-latn-tl", nxd: "nxd-latn-cd", nxe: "nxe-latn-id", nxg: "nxg-latn-id", nxi: "nxi-latn-tz", nxl: "nxl-latn-id", nxn: "nxn-latn-au", nxo: "nxo-latn-ga", nxq: "nxq-latn-cn", nxr: "nxr-latn-zz", nxx: "nxx-latn-id", ny: "ny-latn-mw", nyb: "nyb-latn-gh", nyc: "nyc-latn-cd", nyd: "nyd-latn-ke", nye: "nye-latn-ao", nyf: "nyf-latn-ke", nyg: "nyg-latn-cd", nyh: "nyh-latn-au", nyi: "nyi-latn-sd", nyj: "nyj-latn-cd", nyk: "nyk-latn-ao", nyl: "nyl-thai-th", nym: "nym-latn-tz", nyn: "nyn-latn-ug", nyo: "nyo-latn-ug", nyp: "nyp-latn-ug", nyq: "nyq-arab-ir", nyr: "nyr-latn-mw", nys: "nys-latn-au", nyt: "nyt-latn-au", nyu: "nyu-latn-mz", nyv: "nyv-latn-au", nyx: "nyx-latn-au", nyy: "nyy-latn-tz", nza: "nza-latn-cm", nzb: "nzb-latn-ga", nzd: "nzd-latn-cd", nzi: "nzi-latn-gh", nzk: "nzk-latn-cf", nzm: "nzm-latn-in", nzu: "nzu-latn-cg", nzy: "nzy-latn-td", nzz: "nzz-latn-ml", oaa: "oaa-cyrl-ru", oac: "oac-cyrl-ru", oar: "oar-syrc-sy", oav: "oav-geor-ge", obi: "obi-latn-us", obk: "obk-latn-ph", obl: "obl-latn-cm", obm: "obm-phnx-jo", obo: "obo-latn-ph", obr: "obr-mymr-mm", obt: "obt-latn-fr", obu: "obu-latn-ng", oc: "oc-latn-fr", oca: "oca-latn-pe", oco: "oco-latn-gb", ocu: "ocu-latn-mx", oda: "oda-latn-ng", odk: "odk-arab-pk", odt: "odt-latn-nl", odu: "odu-latn-ng", ofu: "ofu-latn-ng", ogb: "ogb-latn-ng", ogc: "ogc-latn-zz", ogg: "ogg-latn-ng", ogo: "ogo-latn-ng", ogu: "ogu-latn-ng", oht: "oht-xsux-tr", oia: "oia-latn-id", oie: "oie-latn-ss", oin: "oin-latn-pg", oj: "oj-cans-ca", ojb: "ojb-latn-ca", "ojb-cans": "ojb-cans-ca", ojc: "ojc-latn-ca", ojs: "ojs-cans-ca", ojv: "ojv-latn-sb", ojw: "ojw-latn-ca", "ojw-cans": "ojw-cans-ca", oka: "oka-latn-ca", okb: "okb-latn-ng", okc: "okc-latn-cd", okd: "okd-latn-ng", oke: "oke-latn-ng", okg: "okg-latn-au", oki: "oki-latn-ke", okk: "okk-latn-pg", okm: "okm-hang-kr", oko: "oko-hani-kr", okr: "okr-latn-zz", oks: "oks-latn-ng", oku: "oku-latn-cm", okv: "okv-latn-zz", okx: "okx-latn-ng", okz: "okz-khmr-kh", ola: "ola-deva-np", "ola-tibt": "ola-tibt-cn", old: "old-latn-tz", ole: "ole-tibt-bt", olk: "olk-latn-au", olm: "olm-latn-ng", olo: "olo-latn-ru", olr: "olr-latn-vu", olt: "olt-latn-lt", olu: "olu-latn-ao", om: "om-latn-et", oma: "oma-latn-us", omb: "omb-latn-vu", omc: "omc-latn-pe", omg: "omg-latn-pe", omi: "omi-latn-cd", omk: "omk-cyrl-ru", oml: "oml-latn-cd", omo: "omo-latn-pg", omp: "omp-mtei-in", omr: "omr-modi-in", omt: "omt-latn-ke", omu: "omu-latn-pe", omw: "omw-latn-pg", ona: "ona-latn-ar", one: "one-latn-ca", ong: "ong-latn-zz", oni: "oni-latn-id", onj: "onj-latn-pg", onk: "onk-latn-pg", onn: "onn-latn-zz", ono: "ono-latn-ca", onp: "onp-latn-in", "onp-deva": "onp-deva-in", onr: "onr-latn-pg", ons: "ons-latn-zz", ont: "ont-latn-pg", onu: "onu-latn-vu", onx: "onx-latn-id", ood: "ood-latn-us", oon: "oon-deva-in", oor: "oor-latn-za", opa: "opa-latn-ng", opk: "opk-latn-id", opm: "opm-latn-zz", opo: "opo-latn-pg", opt: "opt-latn-mx", opy: "opy-latn-br", or: "or-orya-in", ora: "ora-latn-sb", orc: "orc-latn-ke", ore: "ore-latn-pe", org: "org-latn-ng", orn: "orn-latn-my", oro: "oro-latn-zz", orr: "orr-latn-ng", ors: "ors-latn-my", ort: "ort-telu-in", oru: "oru-arab-zz", orv: "orv-cyrl-ru", orw: "orw-latn-br", orx: "orx-latn-ng", orz: "orz-latn-id", os: "os-cyrl-ge", osa: "osa-osge-us", osc: "osc-ital-it", "osc-latn": "osc-latn-it", osi: "osi-java-id", oso: "oso-latn-ng", osp: "osp-latn-es", ost: "ost-latn-cm", osu: "osu-latn-pg", osx: "osx-latn-de", ota: "ota-arab-zz", otb: "otb-tibt-cn", otd: "otd-latn-id", ote: "ote-latn-mx", oti: "oti-latn-br", otk: "otk-orkh-mn", otl: "otl-latn-mx", otm: "otm-latn-mx", otn: "otn-latn-mx", otq: "otq-latn-mx", otr: "otr-latn-sd", ots: "ots-latn-mx", ott: "ott-latn-mx", otu: "otu-latn-br", otw: "otw-latn-ca", otx: "otx-latn-mx", oty: "oty-gran-in", otz: "otz-latn-mx", oub: "oub-latn-lr", oue: "oue-latn-pg", oui: "oui-ougr-143", oum: "oum-latn-pg", ovd: "ovd-latn-se", owi: "owi-latn-pg", owl: "owl-latn-gb", oyd: "oyd-latn-et", oym: "oym-latn-br", oyy: "oyy-latn-pg", ozm: "ozm-latn-zz", pa: "pa-guru-in", "pa-arab": "pa-arab-pk", "pa-pk": "pa-arab-pk", pab: "pab-latn-br", pac: "pac-latn-vn", pad: "pad-latn-br", pae: "pae-latn-cd", paf: "paf-latn-br", pag: "pag-latn-ph", pah: "pah-latn-br", pai: "pai-latn-ng", pak: "pak-latn-br", pal: "pal-phli-ir", "pal-phlp": "pal-phlp-cn", pam: "pam-latn-ph", pao: "pao-latn-us", pap: "pap-latn-cw", paq: "paq-cyrl-tj", par: "par-latn-us", pas: "pas-latn-id", pau: "pau-latn-pw", pav: "pav-latn-br", paw: "paw-latn-us", pax: "pax-latn-br", pay: "pay-latn-hn", paz: "paz-latn-br", pbb: "pbb-latn-co", pbc: "pbc-latn-gy", pbe: "pbe-latn-mx", pbf: "pbf-latn-mx", pbg: "pbg-latn-ve", pbh: "pbh-latn-ve", pbi: "pbi-latn-zz", pbl: "pbl-latn-ng", pbm: "pbm-latn-mx", pbn: "pbn-latn-ng", pbo: "pbo-latn-gw", pbp: "pbp-latn-gn", pbr: "pbr-latn-tz", pbs: "pbs-latn-mx", pbt: "pbt-arab-af", pbv: "pbv-latn-in", pby: "pby-latn-pg", pca: "pca-latn-mx", pcb: "pcb-khmr-kh", pcc: "pcc-latn-cn", "pcc-hani": "pcc-hani-cn", pcd: "pcd-latn-fr", pce: "pce-mymr-mm", "pce-thai": "pce-thai-th", pcf: "pcf-mlym-in", pcg: "pcg-mlym-in", "pcg-knda": "pcg-knda-in", "pcg-taml": "pcg-taml-in", pch: "pch-deva-in", pci: "pci-deva-in", "pci-orya": "pci-orya-in", pcj: "pcj-telu-in", pck: "pck-latn-in", pcm: "pcm-latn-ng", pcn: "pcn-latn-ng", pcp: "pcp-latn-bo", pcw: "pcw-latn-ng", pda: "pda-latn-pg", pdc: "pdc-latn-us", pdn: "pdn-latn-id", pdo: "pdo-latn-id", pdt: "pdt-latn-ca", pdu: "pdu-latn-mm", "pdu-mymr": "pdu-mymr-mm", pea: "pea-latn-id", peb: "peb-latn-us", ped: "ped-latn-zz", pee: "pee-latn-id", peg: "peg-orya-in", pei: "pei-latn-mx", pek: "pek-latn-pg", pel: "pel-latn-id", pem: "pem-latn-cd", peo: "peo-xpeo-ir", pep: "pep-latn-pg", peq: "peq-latn-us", pev: "pev-latn-ve", pex: "pex-latn-zz", pey: "pey-latn-id", pez: "pez-latn-my", pfa: "pfa-latn-fm", pfe: "pfe-latn-cm", pfl: "pfl-latn-de", pga: "pga-latn-ss", pgd: "pgd-khar-pk", pgg: "pgg-deva-in", pgi: "pgi-latn-pg", pgk: "pgk-latn-vu", pgl: "pgl-ogam-ie", pgn: "pgn-ital-it", pgs: "pgs-latn-ng", pgu: "pgu-latn-id", phd: "phd-deva-in", phg: "phg-latn-vn", phh: "phh-latn-vn", phk: "phk-mymr-in", phl: "phl-arab-zz", phm: "phm-latn-mz", phn: "phn-phnx-lb", pho: "pho-laoo-la", phr: "phr-arab-pk", pht: "pht-thai-th", phv: "phv-arab-af", phw: "phw-deva-np", pi: "pi-sinh-in", "pi-brah": "pi-brah-in", "pi-deva": "pi-deva-in", "pi-khar": "pi-khar-in", "pi-khmr": "pi-khmr-in", "pi-mymr": "pi-mymr-in", "pi-thai": "pi-thai-in", pia: "pia-latn-mx", pib: "pib-latn-pe", pic: "pic-latn-ga", pid: "pid-latn-ve", pif: "pif-latn-fm", pig: "pig-latn-pe", pih: "pih-latn-nf", pij: "pij-latn-co", pil: "pil-latn-zz", pim: "pim-latn-us", pin: "pin-latn-pg", pio: "pio-latn-co", pip: "pip-latn-zz", pir: "pir-latn-br", pis: "pis-latn-sb", pit: "pit-latn-au", piu: "piu-latn-au", piv: "piv-latn-sb", piw: "piw-latn-tz", pix: "pix-latn-pg", piy: "piy-latn-ng", piz: "piz-latn-nc", pjt: "pjt-latn-au", pka: "pka-brah-in", pkb: "pkb-latn-ke", pkg: "pkg-latn-pg", pkh: "pkh-latn-bd", "pkh-deva": "pkh-deva-bd", pkn: "pkn-latn-au", pko: "pko-latn-ke", pkp: "pkp-latn-ck", pkr: "pkr-mlym-in", pku: "pku-latn-id", pl: "pl-latn-pl", pla: "pla-latn-zz", plb: "plb-latn-vu", plc: "plc-latn-ph", pld: "pld-latn-gb", ple: "ple-latn-id", plg: "plg-latn-ar", plh: "plh-latn-id", plj: "plj-latn-ng", plk: "plk-arab-pk", pll: "pll-mymr-mm", pln: "pln-latn-co", plo: "plo-latn-mx", plr: "plr-latn-ci", pls: "pls-latn-mx", plu: "plu-latn-br", plv: "plv-latn-ph", plw: "plw-latn-ph", plz: "plz-latn-my", pma: "pma-latn-vu", pmb: "pmb-latn-cd", pmd: "pmd-latn-au", pme: "pme-latn-nc", pmf: "pmf-latn-id", pmh: "pmh-brah-in", pmi: "pmi-latn-cn", pmj: "pmj-latn-cn", pml: "pml-latn-tn", pmm: "pmm-latn-cm", pmn: "pmn-latn-cm", pmo: "pmo-latn-id", pmq: "pmq-latn-mx", pmr: "pmr-latn-pg", pms: "pms-latn-it", pmt: "pmt-latn-pf", pmw: "pmw-latn-us", pmx: "pmx-latn-in", pmy: "pmy-latn-id", pmz: "pmz-latn-mx", pna: "pna-latn-my", pnc: "pnc-latn-id", pnd: "pnd-latn-ao", pne: "pne-latn-my", png: "png-latn-zz", pnh: "pnh-latn-ck", pni: "pni-latn-id", pnj: "pnj-latn-au", pnk: "pnk-latn-bo", pnl: "pnl-latn-bf", pnm: "pnm-latn-my", pnn: "pnn-latn-zz", pno: "pno-latn-pe", pnp: "pnp-latn-id", pnq: "pnq-latn-bf", pnr: "pnr-latn-pg", pns: "pns-latn-id", pnt: "pnt-grek-gr", pnv: "pnv-latn-au", pnw: "pnw-latn-au", pny: "pny-latn-cm", pnz: "pnz-latn-cf", poc: "poc-latn-gt", poe: "poe-latn-mx", pof: "pof-latn-cd", pog: "pog-latn-br", poh: "poh-latn-gt", poi: "poi-latn-mx", pok: "pok-latn-br", pom: "pom-latn-us", pon: "pon-latn-fm", poo: "poo-latn-us", pop: "pop-latn-nc", poq: "poq-latn-mx", pos: "pos-latn-mx", pot: "pot-latn-us", pov: "pov-latn-gw", pow: "pow-latn-mx", poy: "poy-latn-tz", ppa: "ppa-deva-in", ppe: "ppe-latn-pg", ppi: "ppi-latn-mx", ppk: "ppk-latn-id", ppl: "ppl-latn-sv", ppm: "ppm-latn-id", ppn: "ppn-latn-pg", ppo: "ppo-latn-zz", ppp: "ppp-latn-cd", ppq: "ppq-latn-pg", pps: "pps-latn-mx", ppt: "ppt-latn-pg", pqa: "pqa-latn-ng", pqm: "pqm-latn-ca", pra: "pra-khar-pk", prc: "prc-arab-af", prd: "prd-arab-ir", pre: "pre-latn-st", prf: "prf-latn-ph", prg: "prg-latn-001", prh: "prh-latn-ph", pri: "pri-latn-nc", prk: "prk-latn-mm", prm: "prm-latn-pg", pro: "pro-latn-fr", prp: "prp-gujr-in", prq: "prq-latn-pe", prr: "prr-latn-br", prt: "prt-thai-th", pru: "pru-latn-id", prw: "prw-latn-pg", prx: "prx-arab-in", "prx-tibt": "prx-tibt-in", ps: "ps-arab-af", psa: "psa-latn-id", pse: "pse-latn-id", psh: "psh-arab-af", psi: "psi-arab-af", psm: "psm-latn-bo", psn: "psn-latn-id", psq: "psq-latn-pg", pss: "pss-latn-zz", pst: "pst-arab-pk", psw: "psw-latn-vu", pt: "pt-latn-br", pta: "pta-latn-py", pth: "pth-latn-br", pti: "pti-latn-au", ptn: "ptn-latn-id", pto: "pto-latn-br", ptp: "ptp-latn-zz", ptr: "ptr-latn-vu", ptt: "ptt-latn-id", ptu: "ptu-latn-id", ptv: "ptv-latn-vu", pua: "pua-latn-mx", pub: "pub-latn-in", puc: "puc-latn-id", pud: "pud-latn-id", pue: "pue-latn-ar", puf: "puf-latn-id", pug: "pug-latn-bf", pui: "pui-latn-co", puj: "puj-latn-id", pum: "pum-deva-np", puo: "puo-latn-vn", pup: "pup-latn-pg", puq: "puq-latn-pe", pur: "pur-latn-br", put: "put-latn-id", puu: "puu-latn-ga", puw: "puw-latn-fm", pux: "pux-latn-pg", puy: "puy-latn-us", pwa: "pwa-latn-zz", pwb: "pwb-latn-ng", pwg: "pwg-latn-pg", pwm: "pwm-latn-ph", pwn: "pwn-latn-tw", pwo: "pwo-mymr-mm", pwr: "pwr-deva-in", pww: "pww-thai-th", pxm: "pxm-latn-mx", pye: "pye-latn-ci", pym: "pym-latn-ng", pyn: "pyn-latn-br", pyu: "pyu-latn-tw", "pyu-hani": "pyu-hani-tw", pyx: "pyx-mymr-mm", pyy: "pyy-latn-mm", pzh: "pzh-latn-tw", pzn: "pzn-latn-mm", qu: "qu-latn-pe", qua: "qua-latn-us", qub: "qub-latn-pe", quc: "quc-latn-gt", qud: "qud-latn-ec", quf: "quf-latn-pe", qug: "qug-latn-ec", qui: "qui-latn-us", quk: "quk-latn-pe", qul: "qul-latn-bo", qum: "qum-latn-gt", qun: "qun-latn-us", qup: "qup-latn-pe", quq: "quq-latn-es", qur: "qur-latn-pe", qus: "qus-latn-ar", quv: "quv-latn-gt", quw: "quw-latn-ec", qux: "qux-latn-pe", quy: "quy-latn-pe", qva: "qva-latn-pe", qvc: "qvc-latn-pe", qve: "qve-latn-pe", qvh: "qvh-latn-pe", qvi: "qvi-latn-ec", qvj: "qvj-latn-ec", qvl: "qvl-latn-pe", qvm: "qvm-latn-pe", qvn: "qvn-latn-pe", qvo: "qvo-latn-pe", qvp: "qvp-latn-pe", qvs: "qvs-latn-pe", qvw: "qvw-latn-pe", qvz: "qvz-latn-ec", qwa: "qwa-latn-pe", qwc: "qwc-latn-pe", qwh: "qwh-latn-pe", qwm: "qwm-latn-ru", "qwm-cyrl": "qwm-cyrl-ru", "qwm-runr": "qwm-runr-ru", qws: "qws-latn-pe", qwt: "qwt-latn-us", qxa: "qxa-latn-pe", qxc: "qxc-latn-pe", qxh: "qxh-latn-pe", qxl: "qxl-latn-ec", qxn: "qxn-latn-pe", qxo: "qxo-latn-pe", qxp: "qxp-latn-pe", qxq: "qxq-arab-ir", qxr: "qxr-latn-ec", qxt: "qxt-latn-pe", qxu: "qxu-latn-pe", qxw: "qxw-latn-pe", qya: "qya-latn-001", qyp: "qyp-latn-us", raa: "raa-deva-np", rab: "rab-deva-np", rac: "rac-latn-id", rad: "rad-latn-vn", raf: "raf-deva-np", rag: "rag-latn-ke", rah: "rah-beng-in", "rah-latn": "rah-latn-in", rai: "rai-latn-zz", raj: "raj-deva-in", rak: "rak-latn-pg", ram: "ram-latn-br", ran: "ran-latn-id", rao: "rao-latn-zz", rap: "rap-latn-cl", rar: "rar-latn-ck", rav: "rav-deva-np", raw: "raw-latn-mm", rax: "rax-latn-ng", ray: "ray-latn-pf", raz: "raz-latn-id", rbb: "rbb-mymr-mm", rbk: "rbk-latn-ph", rbl: "rbl-latn-ph", rbp: "rbp-latn-au", rcf: "rcf-latn-re", rdb: "rdb-arab-ir", rea: "rea-latn-pg", reb: "reb-latn-id", ree: "ree-latn-my", reg: "reg-latn-tz", rei: "rei-orya-in", "rei-telu": "rei-telu-in", rej: "rej-latn-id", rel: "rel-latn-zz", rem: "rem-latn-pe", ren: "ren-latn-vn", res: "res-latn-zz", ret: "ret-latn-id", rey: "rey-latn-bo", rga: "rga-latn-vu", rgn: "rgn-latn-it", rgr: "rgr-latn-pe", rgs: "rgs-latn-vn", rgu: "rgu-latn-id", rhg: "rhg-rohg-mm", rhp: "rhp-latn-pg", ria: "ria-latn-in", rif: "rif-latn-ma", ril: "ril-latn-mm", rim: "rim-latn-tz", rin: "rin-latn-ng", rir: "rir-latn-id", rit: "rit-latn-au", riu: "riu-latn-id", rjg: "rjg-latn-id", rji: "rji-deva-np", rjs: "rjs-deva-np", rka: "rka-khmr-kh", rkb: "rkb-latn-br", rkh: "rkh-latn-ck", rki: "rki-mymr-mm", rkm: "rkm-latn-bf", rkt: "rkt-beng-bd", rkw: "rkw-latn-au", rm: "rm-latn-ch", rma: "rma-latn-ni", rmb: "rmb-latn-au", rmc: "rmc-latn-sk", rmd: "rmd-latn-dk", rme: "rme-latn-gb", rmf: "rmf-latn-fi", rmg: "rmg-latn-no", rmh: "rmh-latn-id", rmi: "rmi-armn-am", rmk: "rmk-latn-pg", rml: "rml-latn-pl", "rml-cyrl": "rml-cyrl-by", rmm: "rmm-latn-id", rmn: "rmn-latn-rs", "rmn-cyrl": "rmn-cyrl-bg", "rmn-grek": "rmn-grek-gr", rmo: "rmo-latn-ch", rmp: "rmp-latn-pg", rmq: "rmq-latn-es", rmt: "rmt-arab-ir", rmu: "rmu-latn-se", rmw: "rmw-latn-gb", rmx: "rmx-latn-vn", rmz: "rmz-mymr-in", rn: "rn-latn-bi", rna: "rna-latn-zz", rnd: "rnd-latn-cd", rng: "rng-latn-mz", rnl: "rnl-latn-in", rnn: "rnn-latn-id", rnr: "rnr-latn-au", rnw: "rnw-latn-tz", ro: "ro-latn-ro", rob: "rob-latn-id", roc: "roc-latn-vn", rod: "rod-latn-ng", roe: "roe-latn-pg", rof: "rof-latn-tz", rog: "rog-latn-vn", rol: "rol-latn-ph", rom: "rom-latn-ro", "rom-cyrl": "rom-cyrl-ro", roo: "roo-latn-zz", rop: "rop-latn-au", ror: "ror-latn-id", rou: "rou-latn-td", row: "row-latn-id", rpn: "rpn-latn-vu", rpt: "rpt-latn-pg", rri: "rri-latn-sb", rro: "rro-latn-zz", rrt: "rrt-latn-au", rsk: "rsk-cyrl-rs", rtc: "rtc-latn-mm", rth: "rth-latn-id", rtm: "rtm-latn-fj", rtw: "rtw-deva-in", ru: "ru-cyrl-ru", rub: "rub-latn-ug", ruc: "ruc-latn-ug", rue: "rue-cyrl-ua", ruf: "ruf-latn-tz", rug: "rug-latn-sb", rui: "rui-latn-tz", ruk: "ruk-latn-ng", ruo: "ruo-latn-hr", rup: "rup-latn-ro", "rup-grek": "rup-grek-gr", ruq: "ruq-latn-gr", rut: "rut-cyrl-ru", "rut-latn": "rut-latn-az", ruu: "ruu-latn-my", ruy: "ruy-latn-ng", ruz: "ruz-latn-ng", rw: "rw-latn-rw", rwa: "rwa-latn-pg", rwk: "rwk-latn-tz", rwl: "rwl-latn-tz", rwm: "rwm-latn-ug", rwo: "rwo-latn-zz", rwr: "rwr-deva-in", rxd: "rxd-latn-au", rxw: "rxw-latn-au", ryu: "ryu-kana-jp", sa: "sa-deva-in", saa: "saa-latn-td", sab: "sab-latn-pa", sac: "sac-latn-us", sad: "sad-latn-tz", sae: "sae-latn-br", saf: "saf-latn-gh", sah: "sah-cyrl-ru", saj: "saj-latn-id", sak: "sak-latn-ga", sam: "sam-samr-ps", "sam-hebr": "sam-hebr-ps", "sam-syrc": "sam-syrc-ps", sao: "sao-latn-id", saq: "saq-latn-ke", sar: "sar-latn-bo", sas: "sas-latn-id", sat: "sat-olck-in", sau: "sau-latn-id", sav: "sav-latn-sn", saw: "saw-latn-id", sax: "sax-latn-vu", say: "say-latn-ng", saz: "saz-saur-in", sba: "sba-latn-zz", sbb: "sbb-latn-sb", sbc: "sbc-latn-pg", sbd: "sbd-latn-bf", sbe: "sbe-latn-zz", sbg: "sbg-latn-id", sbh: "sbh-latn-pg", sbi: "sbi-latn-pg", sbj: "sbj-latn-td", sbk: "sbk-latn-tz", sbl: "sbl-latn-ph", sbm: "sbm-latn-tz", sbn: "sbn-arab-pk", sbo: "sbo-latn-my", sbp: "sbp-latn-tz", sbq: "sbq-latn-pg", sbr: "sbr-latn-id", sbs: "sbs-latn-na", sbt: "sbt-latn-id", sbu: "sbu-tibt-in", "sbu-deva": "sbu-deva-in", sbv: "sbv-latn-it", sbw: "sbw-latn-ga", sbx: "sbx-latn-id", sby: "sby-latn-zm", sbz: "sbz-latn-cf", sc: "sc-latn-it", scb: "scb-latn-vn", sce: "sce-latn-cn", "sce-arab": "sce-arab-cn", scf: "scf-latn-pa", scg: "scg-latn-id", sch: "sch-latn-in", sci: "sci-latn-lk", sck: "sck-deva-in", scl: "scl-arab-zz", scn: "scn-latn-it", sco: "sco-latn-gb", scp: "scp-deva-np", scs: "scs-latn-ca", "scs-cans": "scs-cans-ca", sct: "sct-laoo-la", scu: "scu-takr-in", scv: "scv-latn-ng", scw: "scw-latn-ng", scx: "scx-grek-it", sd: "sd-arab-pk", "sd-deva": "sd-deva-in", "sd-in": "sd-deva-in", "sd-khoj": "sd-khoj-in", "sd-sind": "sd-sind-in", sda: "sda-latn-id", sdb: "sdb-arab-iq", sdc: "sdc-latn-it", sde: "sde-latn-ng", sdf: "sdf-arab-iq", sdg: "sdg-arab-af", sdh: "sdh-arab-ir", sdj: "sdj-latn-cg", sdk: "sdk-latn-pg", sdn: "sdn-latn-it", sdo: "sdo-latn-my", sdq: "sdq-latn-id", sds: "sds-arab-tn", sdu: "sdu-latn-id", sdx: "sdx-latn-my", se: "se-latn-no", sea: "sea-latn-my", seb: "seb-latn-ci", sec: "sec-latn-ca", sed: "sed-latn-vn", see: "see-latn-us", sef: "sef-latn-ci", seg: "seg-latn-tz", seh: "seh-latn-mz", sei: "sei-latn-mx", sej: "sej-latn-pg", sek: "sek-latn-ca", "sek-cans": "sek-cans-ca", sel: "sel-cyrl-ru", sen: "sen-latn-bf", seo: "seo-latn-pg", sep: "sep-latn-bf", seq: "seq-latn-bf", ser: "ser-latn-us", ses: "ses-latn-ml", set: "set-latn-id", seu: "seu-latn-id", sev: "sev-latn-ci", sew: "sew-latn-pg", sey: "sey-latn-ec", sez: "sez-latn-mm", sfe: "sfe-latn-ph", sfm: "sfm-plrd-cn", sfw: "sfw-latn-gh", sg: "sg-latn-cf", sga: "sga-ogam-ie", sgb: "sgb-latn-ph", sgc: "sgc-latn-ke", sgd: "sgd-latn-ph", sge: "sge-latn-id", sgh: "sgh-cyrl-tj", "sgh-arab": "sgh-arab-af", "sgh-latn": "sgh-latn-tj", sgi: "sgi-latn-cm", sgj: "sgj-deva-in", sgm: "sgm-latn-ke", sgp: "sgp-latn-in", sgr: "sgr-arab-ir", sgs: "sgs-latn-lt", sgt: "sgt-tibt-bt", sgu: "sgu-latn-id", sgw: "sgw-ethi-zz", sgy: "sgy-arab-af", sgz: "sgz-latn-zz", sha: "sha-latn-ng", shb: "shb-latn-br", shc: "shc-latn-cd", shd: "shd-arab-pk", she: "she-latn-et", shg: "shg-latn-bw", shh: "shh-latn-us", shi: "shi-tfng-ma", shj: "shj-latn-sd", shk: "shk-latn-zz", shm: "shm-arab-ir", shn: "shn-mymr-mm", sho: "sho-latn-ng", shp: "shp-latn-pe", shq: "shq-latn-zm", shr: "shr-latn-cd", shs: "shs-latn-ca", sht: "sht-latn-us", shu: "shu-arab-zz", shv: "shv-arab-om", shw: "shw-latn-sd", shy: "shy-latn-dz", "shy-arab": "shy-arab-dz", "shy-tfng": "shy-tfng-dz", shz: "shz-latn-ml", si: "si-sinh-lk", sia: "sia-cyrl-ru", sib: "sib-latn-my", sid: "sid-latn-et", sie: "sie-latn-zm", sif: "sif-latn-bf", sig: "sig-latn-zz", sih: "sih-latn-nc", sii: "sii-latn-in", sij: "sij-latn-pg", sik: "sik-latn-br", sil: "sil-latn-zz", sim: "sim-latn-zz", sip: "sip-tibt-in", siq: "siq-latn-pg", sir: "sir-latn-ng", sis: "sis-latn-us", siu: "siu-latn-pg", siv: "siv-latn-pg", siw: "siw-latn-pg", six: "six-latn-pg", siy: "siy-arab-ir", siz: "siz-arab-eg", sja: "sja-latn-co", sjb: "sjb-latn-id", sjd: "sjd-cyrl-ru", sje: "sje-latn-se", sjg: "sjg-latn-td", sjl: "sjl-latn-in", sjm: "sjm-latn-ph", sjp: "sjp-deva-in", "sjp-beng": "sjp-beng-in", sjr: "sjr-latn-zz", sjt: "sjt-cyrl-ru", sju: "sju-latn-se", sjw: "sjw-latn-us", sk: "sk-latn-sk", ska: "ska-latn-us", skb: "skb-thai-th", skc: "skc-latn-zz", skd: "skd-latn-us", ske: "ske-latn-vu", skf: "skf-latn-br", skg: "skg-latn-mg", skh: "skh-latn-id", ski: "ski-latn-id", skj: "skj-deva-np", skm: "skm-latn-pg", skn: "skn-latn-ph", sko: "sko-latn-id", skp: "skp-latn-my", skq: "skq-latn-bf", skr: "skr-arab-pk", sks: "sks-latn-zz", skt: "skt-latn-cd", sku: "sku-latn-vu", skv: "skv-latn-id", skw: "skw-latn-gy", skx: "skx-latn-id", sky: "sky-latn-sb", skz: "skz-latn-id", sl: "sl-latn-si", slc: "slc-latn-co", sld: "sld-latn-zz", slg: "slg-latn-id", slh: "slh-latn-us", sli: "sli-latn-pl", slj: "slj-latn-br", sll: "sll-latn-zz", slm: "slm-latn-ph", sln: "sln-latn-us", slp: "slp-latn-id", slq: "slq-arab-ir", slr: "slr-latn-cn", slu: "slu-latn-id", slw: "slw-latn-pg", slx: "slx-latn-cd", sly: "sly-latn-id", slz: "slz-latn-id", sm: "sm-latn-ws", sma: "sma-latn-se", smb: "smb-latn-pg", smc: "smc-latn-pg", smd: "smd-latn-ao", smf: "smf-latn-pg", smg: "smg-latn-pg", smh: "smh-yiii-cn", smj: "smj-latn-se", smk: "smk-latn-ph", sml: "sml-latn-ph", smn: "smn-latn-fi", smp: "smp-samr-il", smq: "smq-latn-zz", smr: "smr-latn-id", sms: "sms-latn-fi", smt: "smt-latn-in", smu: "smu-khmr-kh", smw: "smw-latn-id", smx: "smx-latn-cd", smy: "smy-arab-ir", smz: "smz-latn-pg", sn: "sn-latn-zw", snb: "snb-latn-my", snc: "snc-latn-zz", sne: "sne-latn-my", snf: "snf-latn-sn", sng: "sng-latn-cd", "sng-brai": "sng-brai-cd", sni: "sni-latn-pe", snj: "snj-latn-cf", snk: "snk-latn-ml", snl: "snl-latn-ph", snm: "snm-latn-ug", snn: "snn-latn-co", sno: "sno-latn-us", snp: "snp-latn-zz", snq: "snq-latn-ga", snr: "snr-latn-pg", sns: "sns-latn-vu", snu: "snu-latn-id", snv: "snv-latn-my", snw: "snw-latn-gh", snx: "snx-latn-zz", sny: "sny-latn-zz", snz: "snz-latn-pg", so: "so-latn-so", soa: "soa-tavt-th", "soa-thai": "soa-thai-th", sob: "sob-latn-id", soc: "soc-latn-cd", sod: "sod-latn-cd", soe: "soe-latn-cd", sog: "sog-sogd-uz", soi: "soi-deva-np", sok: "sok-latn-zz", sol: "sol-latn-pg", soo: "soo-latn-cd", sop: "sop-latn-cd", soq: "soq-latn-zz", sor: "sor-latn-td", sos: "sos-latn-bf", sou: "sou-thai-th", sov: "sov-latn-pw", sow: "sow-latn-pg", sox: "sox-latn-cm", soy: "soy-latn-zz", soz: "soz-latn-tz", spb: "spb-latn-id", spc: "spc-latn-ve", spd: "spd-latn-zz", spe: "spe-latn-pg", spg: "spg-latn-my", spi: "spi-latn-id", spk: "spk-latn-pg", spl: "spl-latn-zz", spm: "spm-latn-pg", spn: "spn-latn-py", spo: "spo-latn-us", spp: "spp-latn-ml", spq: "spq-latn-pe", spr: "spr-latn-id", sps: "sps-latn-zz", spt: "spt-tibt-in", spv: "spv-orya-in", sq: "sq-latn-al", sqa: "sqa-latn-ng", sqh: "sqh-latn-ng", sqm: "sqm-latn-cf", sqo: "sqo-arab-ir", sqq: "sqq-laoo-la", sqt: "sqt-arab-ye", "sqt-latn": "sqt-latn-ye", squ: "squ-latn-ca", sr: "sr-cyrl-rs", "sr-me": "sr-latn-me", "sr-ro": "sr-latn-ro", "sr-ru": "sr-latn-ru", "sr-tr": "sr-latn-tr", sra: "sra-latn-pg", srb: "srb-sora-in", sre: "sre-latn-id", srf: "srf-latn-pg", srg: "srg-latn-ph", srh: "srh-arab-cn", sri: "sri-latn-co", srk: "srk-latn-my", srl: "srl-latn-id", srm: "srm-latn-sr", srn: "srn-latn-sr", sro: "sro-latn-it", srq: "srq-latn-bo", srr: "srr-latn-sn", srs: "srs-latn-ca", srt: "srt-latn-id", sru: "sru-latn-br", srv: "srv-latn-ph", srw: "srw-latn-id", srx: "srx-deva-in", sry: "sry-latn-pg", srz: "srz-arab-ir", ss: "ss-latn-za", ssb: "ssb-latn-ph", ssc: "ssc-latn-tz", ssd: "ssd-latn-zz", sse: "sse-latn-ph", "sse-arab": "sse-arab-ph", ssf: "ssf-latn-tw", ssg: "ssg-latn-zz", ssh: "ssh-arab-ae", ssj: "ssj-latn-pg", ssl: "ssl-latn-gh", ssm: "ssm-latn-my", ssn: "ssn-latn-ke", sso: "sso-latn-pg", ssq: "ssq-latn-id", sss: "sss-laoo-la", "sss-thai": "sss-thai-th", sst: "sst-latn-pg", ssu: "ssu-latn-pg", ssv: "ssv-latn-vu", ssx: "ssx-latn-pg", ssy: "ssy-latn-er", ssz: "ssz-latn-pg", st: "st-latn-za", sta: "sta-latn-zm", stb: "stb-latn-ph", ste: "ste-latn-id", stf: "stf-latn-pg", stg: "stg-latn-vn", sth: "sth-latn-ie", sti: "sti-latn-vn", "sti-kh": "sti-latn-kh", stj: "stj-latn-bf", stk: "stk-latn-zz", stl: "stl-latn-nl", stm: "stm-latn-pg", stn: "stn-latn-sb", sto: "sto-latn-ca", stp: "stp-latn-mx", stq: "stq-latn-de", str: "str-latn-ca", sts: "sts-arab-af", stt: "stt-latn-vn", stv: "stv-ethi-et", "stv-arab": "stv-arab-et", stw: "stw-latn-fm", sty: "sty-cyrl-ru", su: "su-latn-id", sua: "sua-latn-zz", sub: "sub-latn-cd", suc: "suc-latn-ph", sue: "sue-latn-zz", sug: "sug-latn-pg", sui: "sui-latn-pg", suj: "suj-latn-tz", suk: "suk-latn-tz", suo: "suo-latn-pg", suq: "suq-latn-et", "suq-ethi": "suq-ethi-et", sur: "sur-latn-zz", sus: "sus-latn-gn", sut: "sut-latn-ni", suv: "suv-latn-in", "suv-beng": "suv-beng-in", "suv-deva": "suv-deva-in", suw: "suw-latn-tz", suy: "suy-latn-br", suz: "suz-deva-np", sv: "sv-latn-se", sva: "sva-geor-ge", "sva-cyrl": "sva-cyrl-ge", "sva-latn": "sva-latn-ge", svb: "svb-latn-pg", svc: "svc-latn-vc", sve: "sve-latn-id", svm: "svm-latn-it", svs: "svs-latn-sb", sw: "sw-latn-tz", swb: "swb-arab-yt", swc: "swc-latn-cd", swf: "swf-latn-cd", swg: "swg-latn-de", swi: "swi-hani-cn", swj: "swj-latn-ga", swk: "swk-latn-mw", swm: "swm-latn-pg", swo: "swo-latn-br", swp: "swp-latn-zz", swq: "swq-latn-cm", swr: "swr-latn-id", sws: "sws-latn-id", swt: "swt-latn-id", swu: "swu-latn-id", swv: "swv-deva-in", sww: "sww-latn-vu", swx: "swx-latn-br", swy: "swy-latn-td", sxb: "sxb-latn-ke", sxe: "sxe-latn-ga", sxn: "sxn-latn-id", sxr: "sxr-latn-tw", sxs: "sxs-latn-ng", sxu: "sxu-latn-de", "sxu-runr": "sxu-runr-de", sxw: "sxw-latn-zz", sya: "sya-latn-id", syb: "syb-latn-ph", syc: "syc-syrc-tr", syi: "syi-latn-ga", syk: "syk-latn-ng", syl: "syl-beng-bd", sym: "sym-latn-bf", syn: "syn-syrc-ir", syo: "syo-latn-kh", syr: "syr-syrc-iq", sys: "sys-latn-td", syw: "syw-deva-np", syx: "syx-latn-ga", sza: "sza-latn-my", szb: "szb-latn-id", szc: "szc-latn-my", szd: "szd-latn-my", szg: "szg-latn-cd", szl: "szl-latn-pl", szn: "szn-latn-id", szp: "szp-latn-id", szv: "szv-latn-cm", szw: "szw-latn-id", szy: "szy-latn-tw", ta: "ta-taml-in", taa: "taa-latn-us", tab: "tab-cyrl-ru", tac: "tac-latn-mx", tad: "tad-latn-id", tae: "tae-latn-br", taf: "taf-latn-br", tag: "tag-latn-sd", taj: "taj-deva-np", tak: "tak-latn-ng", tal: "tal-latn-zz", tan: "tan-latn-zz", tao: "tao-latn-tw", tap: "tap-latn-cd", taq: "taq-latn-zz", tar: "tar-latn-mx", tas: "tas-latn-vn", tau: "tau-latn-us", tav: "tav-latn-co", taw: "taw-latn-pg", tax: "tax-latn-td", tay: "tay-latn-tw", "tay-hans": "tay-hans-tw", "tay-hant": "tay-hant-tw", taz: "taz-latn-sd", tba: "tba-latn-br", tbc: "tbc-latn-zz", tbd: "tbd-latn-zz", tbe: "tbe-latn-sb", tbf: "tbf-latn-zz", tbg: "tbg-latn-zz", tbh: "tbh-latn-au", tbi: "tbi-latn-sd", tbj: "tbj-latn-pg", tbk: "tbk-tagb-ph", "tbk-hano": "tbk-hano-ph", "tbk-latn": "tbk-latn-ph", tbl: "tbl-latn-ph", tbm: "tbm-latn-cd", tbn: "tbn-latn-co", tbo: "tbo-latn-zz", tbp: "tbp-latn-id", tbs: "tbs-latn-pg", tbt: "tbt-latn-cd", tbu: "tbu-latn-mx", tbv: "tbv-latn-pg", tbw: "tbw-latn-ph", tbx: "tbx-latn-pg", tby: "tby-latn-id", tbz: "tbz-latn-zz", tca: "tca-latn-br", tcb: "tcb-latn-us", tcc: "tcc-latn-tz", tcd: "tcd-latn-gh", tce: "tce-latn-ca", tcf: "tcf-latn-mx", tcg: "tcg-latn-id", tch: "tch-latn-tc", tci: "tci-latn-zz", tck: "tck-latn-ga", tcm: "tcm-latn-id", tcn: "tcn-tibt-np", tco: "tco-mymr-mm", tcp: "tcp-latn-mm", tcq: "tcq-latn-id", tcs: "tcs-latn-au", tcu: "tcu-latn-mx", tcw: "tcw-latn-mx", tcx: "tcx-taml-in", tcy: "tcy-knda-in", tcz: "tcz-latn-in", tda: "tda-tfng-ne", "tda-arab": "tda-arab-ne", "tda-latn": "tda-latn-ne", tdb: "tdb-deva-in", "tdb-beng": "tdb-beng-in", "tdb-kthi": "tdb-kthi-in", tdc: "tdc-latn-co", tdd: "tdd-tale-cn", tde: "tde-latn-ml", tdg: "tdg-deva-np", tdh: "tdh-deva-np", tdi: "tdi-latn-id", tdj: "tdj-latn-id", tdk: "tdk-latn-ng", tdl: "tdl-latn-ng", tdm: "tdm-latn-gy", tdn: "tdn-latn-id", tdo: "tdo-latn-ng", tdq: "tdq-latn-ng", tdr: "tdr-latn-vn", tds: "tds-latn-id", tdt: "tdt-latn-tl", tdu: "tdu-latn-my", tdv: "tdv-latn-ng", tdx: "tdx-latn-mg", tdy: "tdy-latn-ph", te: "te-telu-in", tea: "tea-latn-my", teb: "teb-latn-ec", tec: "tec-latn-ke", ted: "ted-latn-zz", tee: "tee-latn-mx", teg: "teg-latn-ga", teh: "teh-latn-ar", tei: "tei-latn-pg", tek: "tek-latn-cd", tem: "tem-latn-sl", ten: "ten-latn-co", teo: "teo-latn-ug", tep: "tep-latn-mx", teq: "teq-latn-sd", ter: "ter-latn-br", tes: "tes-java-id", tet: "tet-latn-tl", teu: "teu-latn-ug", tev: "tev-latn-id", tew: "tew-latn-us", tex: "tex-latn-ss", tey: "tey-latn-sd", tfi: "tfi-latn-zz", tfn: "tfn-latn-us", tfo: "tfo-latn-id", tfr: "tfr-latn-pa", tft: "tft-latn-id", tg: "tg-cyrl-tj", "tg-arab": "tg-arab-pk", "tg-pk": "tg-arab-pk", tga: "tga-latn-ke", tgb: "tgb-latn-my", tgc: "tgc-latn-zz", tgd: "tgd-latn-ng", tge: "tge-deva-np", tgf: "tgf-tibt-bt", tgh: "tgh-latn-tt", tgi: "tgi-latn-pg", tgj: "tgj-latn-in", tgn: "tgn-latn-ph", tgo: "tgo-latn-zz", tgp: "tgp-latn-vu", tgq: "tgq-latn-my", tgs: "tgs-latn-vu", tgt: "tgt-latn-ph", "tgt-hano": "tgt-hano-ph", "tgt-tagb": "tgt-tagb-ph", tgu: "tgu-latn-zz", tgv: "tgv-latn-br", tgw: "tgw-latn-ci", tgx: "tgx-latn-ca", tgy: "tgy-latn-ss", tgz: "tgz-latn-au", th: "th-thai-th", thd: "thd-latn-au", the: "the-deva-np", thf: "thf-deva-np", thh: "thh-latn-mx", thi: "thi-tale-la", thk: "thk-latn-ke", thl: "thl-deva-np", thm: "thm-thai-th", thp: "thp-latn-ca", "thp-dupl": "thp-dupl-ca", thq: "thq-deva-np", thr: "thr-deva-np", ths: "ths-deva-np", tht: "tht-latn-ca", thu: "thu-latn-ss", thv: "thv-latn-dz", "thv-arab": "thv-arab-dz", "thv-tfng": "thv-tfng-dz", thy: "thy-latn-ng", thz: "thz-latn-ne", "thz-tfng": "thz-tfng-ne", ti: "ti-ethi-et", tic: "tic-latn-sd", tif: "tif-latn-zz", tig: "tig-ethi-er", tih: "tih-latn-my", tii: "tii-latn-cd", tij: "tij-deva-np", tik: "tik-latn-zz", til: "til-latn-us", tim: "tim-latn-zz", tin: "tin-cyrl-ru", tio: "tio-latn-zz", tip: "tip-latn-id", tiq: "tiq-latn-bf", tis: "tis-latn-ph", tit: "tit-latn-co", tiu: "tiu-latn-ph", tiv: "tiv-latn-ng", tiw: "tiw-latn-au", tix: "tix-latn-us", tiy: "tiy-latn-ph", tja: "tja-latn-lr", tjg: "tjg-latn-id", tji: "tji-latn-cn", tjj: "tjj-latn-au", tjl: "tjl-mymr-mm", tjn: "tjn-latn-ci", tjo: "tjo-arab-dz", tjp: "tjp-latn-au", tjs: "tjs-latn-cn", tju: "tju-latn-au", tjw: "tjw-latn-au", tk: "tk-latn-tm", tka: "tka-latn-br", tkb: "tkb-deva-in", tkd: "tkd-latn-tl", tke: "tke-latn-mz", tkf: "tkf-latn-br", tkg: "tkg-latn-mg", tkl: "tkl-latn-tk", tkp: "tkp-latn-sb", tkq: "tkq-latn-ng", tkr: "tkr-latn-az", tks: "tks-arab-ir", tkt: "tkt-deva-np", tku: "tku-latn-mx", tkv: "tkv-latn-pg", tkw: "tkw-latn-sb", tkx: "tkx-latn-id", tkz: "tkz-latn-vn", tl: "tl-latn-ph", tla: "tla-latn-mx", tlb: "tlb-latn-id", tlc: "tlc-latn-mx", tld: "tld-latn-id", tlf: "tlf-latn-zz", tlg: "tlg-latn-id", tli: "tli-latn-us", "tli-cyrl": "tli-cyrl-us", tlj: "tlj-latn-ug", tlk: "tlk-latn-id", tll: "tll-latn-cd", tlm: "tlm-latn-vu", tln: "tln-latn-id", tlp: "tlp-latn-mx", tlq: "tlq-latn-mm", tlr: "tlr-latn-sb", tls: "tls-latn-vu", tlt: "tlt-latn-id", tlu: "tlu-latn-id", tlv: "tlv-latn-id", tlx: "tlx-latn-zz", tly: "tly-latn-az", tma: "tma-latn-td", tmb: "tmb-latn-vu", tmc: "tmc-latn-td", tmd: "tmd-latn-pg", tme: "tme-latn-br", tmf: "tmf-latn-py", tmg: "tmg-latn-id", tmh: "tmh-latn-ne", tmi: "tmi-latn-vu", tmj: "tmj-latn-id", tmk: "tmk-deva-np", tml: "tml-latn-id", tmm: "tmm-latn-vn", tmn: "tmn-latn-id", tmo: "tmo-latn-my", tmq: "tmq-latn-pg", tmr: "tmr-syrc-il", tmt: "tmt-latn-vu", tmu: "tmu-latn-id", tmv: "tmv-latn-cd", tmw: "tmw-latn-my", tmy: "tmy-latn-zz", tmz: "tmz-latn-ve", tn: "tn-latn-za", tna: "tna-latn-bo", tnb: "tnb-latn-co", tnc: "tnc-latn-co", tnd: "tnd-latn-co", tng: "tng-latn-td", tnh: "tnh-latn-zz", tni: "tni-latn-id", tnk: "tnk-latn-vu", tnl: "tnl-latn-vu", tnm: "tnm-latn-id", tnn: "tnn-latn-vu", tno: "tno-latn-bo", tnp: "tnp-latn-vu", tnq: "tnq-latn-pr", tnr: "tnr-latn-sn", tns: "tns-latn-pg", tnt: "tnt-latn-id", tnv: "tnv-cakm-bd", tnw: "tnw-latn-id", tnx: "tnx-latn-sb", tny: "tny-latn-tz", to: "to-latn-to", tob: "tob-latn-ar", toc: "toc-latn-mx", tod: "tod-latn-gn", tof: "tof-latn-zz", tog: "tog-latn-mw", toh: "toh-latn-mz", toi: "toi-latn-zm", toj: "toj-latn-mx", tok: "tok-latn-001", tol: "tol-latn-us", tom: "tom-latn-id", too: "too-latn-mx", top: "top-latn-mx", toq: "toq-latn-zz", tor: "tor-latn-cd", tos: "tos-latn-mx", tou: "tou-latn-vn", tov: "tov-arab-ir", tow: "tow-latn-us", tox: "tox-latn-pw", toy: "toy-latn-id", toz: "toz-latn-cm", tpa: "tpa-latn-pg", tpc: "tpc-latn-mx", tpe: "tpe-latn-bd", "tpe-beng": "tpe-beng-bd", tpf: "tpf-latn-id", tpg: "tpg-latn-id", tpi: "tpi-latn-pg", tpj: "tpj-latn-py", tpk: "tpk-latn-br", tpl: "tpl-latn-mx", tpm: "tpm-latn-zz", tpn: "tpn-latn-br", tpp: "tpp-latn-mx", tpr: "tpr-latn-br", tpt: "tpt-latn-mx", tpu: "tpu-khmr-kh", tpv: "tpv-latn-mp", tpx: "tpx-latn-mx", tpy: "tpy-latn-br", tpz: "tpz-latn-zz", tqb: "tqb-latn-br", tql: "tql-latn-vu", tqm: "tqm-latn-pg", tqn: "tqn-latn-us", tqo: "tqo-latn-zz", tqp: "tqp-latn-pg", tqt: "tqt-latn-mx", tqu: "tqu-latn-sb", tqw: "tqw-latn-us", tr: "tr-latn-tr", tra: "tra-arab-af", trb: "trb-latn-pg", trc: "trc-latn-mx", tre: "tre-latn-id", trf: "trf-latn-tt", trg: "trg-hebr-il", trh: "trh-latn-pg", tri: "tri-latn-sr", trj: "trj-latn-td", trl: "trl-latn-gb", trm: "trm-arab-af", trn: "trn-latn-bo", tro: "tro-latn-in", trp: "trp-latn-in", "trp-beng": "trp-beng-in", trq: "trq-latn-mx", trr: "trr-latn-pe", trs: "trs-latn-mx", trt: "trt-latn-id", tru: "tru-latn-tr", trv: "trv-latn-tw", trw: "trw-arab-pk", trx: "trx-latn-my", try: "try-latn-in", trz: "trz-latn-br", ts: "ts-latn-za", tsa: "tsa-latn-cg", tsb: "tsb-latn-et", tsc: "tsc-latn-mz", tsd: "tsd-grek-gr", tsf: "tsf-deva-np", tsg: "tsg-latn-ph", tsh: "tsh-latn-cm", tsi: "tsi-latn-ca", tsj: "tsj-tibt-bt", tsl: "tsl-latn-vn", tsp: "tsp-latn-bf", tsr: "tsr-latn-vu", tst: "tst-latn-ml", tsu: "tsu-latn-tw", tsv: "tsv-latn-ga", tsw: "tsw-latn-zz", tsx: "tsx-latn-pg", tsz: "tsz-latn-mx", tt: "tt-cyrl-ru", ttb: "ttb-latn-ng", ttc: "ttc-latn-gt", ttd: "ttd-latn-zz", tte: "tte-latn-zz", ttf: "ttf-latn-cm", tth: "tth-laoo-la", tti: "tti-latn-id", ttj: "ttj-latn-ug", ttk: "ttk-latn-co", ttl: "ttl-latn-zm", ttm: "ttm-latn-ca", ttn: "ttn-latn-id", tto: "tto-laoo-la", ttp: "ttp-latn-id", ttr: "ttr-latn-zz", tts: "tts-thai-th", ttt: "ttt-latn-az", ttu: "ttu-latn-pg", ttv: "ttv-latn-pg", ttw: "ttw-latn-my", tty: "tty-latn-id", tua: "tua-latn-pg", tub: "tub-latn-us", tuc: "tuc-latn-pg", tud: "tud-latn-br", tue: "tue-latn-co", tuf: "tuf-latn-co", tug: "tug-latn-td", tuh: "tuh-latn-zz", tui: "tui-latn-cm", tuj: "tuj-latn-id", tul: "tul-latn-zz", tum: "tum-latn-mw", tun: "tun-latn-us", tuo: "tuo-latn-br", tuq: "tuq-latn-zz", tus: "tus-latn-ca", tuu: "tuu-latn-us", tuv: "tuv-latn-ke", tux: "tux-latn-br", tuy: "tuy-latn-ke", tuz: "tuz-latn-bf", tva: "tva-latn-sb", tvd: "tvd-latn-zz", tve: "tve-latn-id", tvk: "tvk-latn-vu", tvl: "tvl-latn-tv", tvm: "tvm-latn-id", tvn: "tvn-mymr-mm", tvo: "tvo-latn-id", tvs: "tvs-latn-ke", tvt: "tvt-latn-in", tvu: "tvu-latn-zz", tvw: "tvw-latn-id", tvx: "tvx-latn-tw", twa: "twa-latn-us", twb: "twb-latn-ph", twd: "twd-latn-nl", twe: "twe-latn-id", twf: "twf-latn-us", twg: "twg-latn-id", twh: "twh-latn-zz", twl: "twl-latn-mz", twm: "twm-deva-in", twn: "twn-latn-cm", two: "two-latn-bw", twp: "twp-latn-pg", twq: "twq-latn-ne", twr: "twr-latn-mx", twt: "twt-latn-br", twu: "twu-latn-id", tww: "tww-latn-pg", twx: "twx-latn-mz", twy: "twy-latn-id", txa: "txa-latn-my", txe: "txe-latn-id", txg: "txg-tang-cn", txi: "txi-latn-br", txj: "txj-latn-ng", txm: "txm-latn-id", txn: "txn-latn-id", txo: "txo-toto-in", txq: "txq-latn-id", txs: "txs-latn-id", txt: "txt-latn-id", txu: "txu-latn-br", txx: "txx-latn-my", txy: "txy-latn-mg", ty: "ty-latn-pf", tya: "tya-latn-zz", tye: "tye-latn-ng", tyh: "tyh-latn-vn", tyi: "tyi-latn-cg", tyj: "tyj-latn-vn", tyl: "tyl-latn-vn", tyn: "tyn-latn-id", typ: "typ-latn-au", tyr: "tyr-tavt-vn", tys: "tys-latn-vn", tyt: "tyt-latn-vn", "tyt-tavt": "tyt-tavt-vn", tyu: "tyu-latn-bw", tyv: "tyv-cyrl-ru", tyx: "tyx-latn-cg", tyy: "tyy-latn-ng", tyz: "tyz-latn-vn", tzh: "tzh-latn-mx", tzj: "tzj-latn-gt", tzl: "tzl-latn-001", tzm: "tzm-latn-ma", tzn: "tzn-latn-id", tzo: "tzo-latn-mx", tzx: "tzx-latn-pg", uam: "uam-latn-br", uar: "uar-latn-pg", uba: "uba-latn-ng", ubi: "ubi-latn-td", ubl: "ubl-latn-ph", ubr: "ubr-latn-pg", ubu: "ubu-latn-zz", uda: "uda-latn-ng", ude: "ude-cyrl-ru", udg: "udg-mlym-in", udi: "udi-aghb-ru", udj: "udj-latn-id", udl: "udl-latn-cm", udm: "udm-cyrl-ru", udu: "udu-latn-sd", ues: "ues-latn-id", ufi: "ufi-latn-pg", ug: "ug-arab-cn", "ug-cyrl": "ug-cyrl-kz", "ug-kz": "ug-cyrl-kz", "ug-mn": "ug-cyrl-mn", uga: "uga-ugar-sy", ugb: "ugb-latn-au", uge: "uge-latn-sb", ugh: "ugh-cyrl-ru", ugo: "ugo-thai-th", uha: "uha-latn-ng", uhn: "uhn-latn-id", uis: "uis-latn-pg", uiv: "uiv-latn-cm", uji: "uji-latn-ng", uk: "uk-cyrl-ua", uka: "uka-latn-id", ukg: "ukg-latn-pg", ukh: "ukh-latn-cf", uki: "uki-orya-in", ukk: "ukk-latn-mm", ukp: "ukp-latn-ng", ukq: "ukq-latn-ng", uku: "uku-latn-ng", ukv: "ukv-latn-ss", ukw: "ukw-latn-ng", uky: "uky-latn-au", ula: "ula-latn-ng", ulb: "ulb-latn-ng", ulc: "ulc-cyrl-ru", ule: "ule-latn-ar", ulf: "ulf-latn-id", uli: "uli-latn-fm", ulk: "ulk-latn-au", ulm: "ulm-latn-id", uln: "uln-latn-pg", ulu: "ulu-latn-id", ulw: "ulw-latn-ni", uma: "uma-latn-us", umb: "umb-latn-ao", umd: "umd-latn-au", umg: "umg-latn-au", umi: "umi-latn-my", umm: "umm-latn-ng", umn: "umn-latn-mm", umo: "umo-latn-br", ump: "ump-latn-au", umr: "umr-latn-au", ums: "ums-latn-id", una: "una-latn-pg", und: "en-latn-us", "und-002": "en-latn-ng", "und-003": "en-latn-us", "und-005": "pt-latn-br", "und-009": "en-latn-au", "und-011": "en-latn-ng", "und-013": "es-latn-mx", "und-014": "sw-latn-tz", "und-015": "ar-arab-eg", "und-017": "sw-latn-cd", "und-018": "en-latn-za", "und-019": "en-latn-us", "und-021": "en-latn-us", "und-029": "es-latn-cu", "und-030": "zh-hans-cn", "und-034": "hi-deva-in", "und-035": "id-latn-id", "und-039": "it-latn-it", "und-053": "en-latn-au", "und-054": "en-latn-pg", "und-057": "en-latn-gu", "und-061": "sm-latn-ws", "und-142": "zh-hans-cn", "und-143": "uz-latn-uz", "und-145": "ar-arab-sa", "und-150": "ru-cyrl-ru", "und-151": "ru-cyrl-ru", "und-154": "en-latn-gb", "und-155": "de-latn-de", "und-202": "en-latn-ng", "und-419": "es-latn-419", "und-ad": "ca-latn-ad", "und-adlm": "ff-adlm-gn", "und-ae": "ar-arab-ae", "und-af": "fa-arab-af", "und-aghb": "udi-aghb-ru", "und-ahom": "aho-ahom-in", "und-al": "sq-latn-al", "und-am": "hy-armn-am", "und-ao": "pt-latn-ao", "und-aq": "und-latn-aq", "und-ar": "es-latn-ar", "und-arab": "ar-arab-eg", "und-arab-cc": "ms-arab-cc", "und-arab-cn": "ug-arab-cn", "und-arab-gb": "ur-arab-gb", "und-arab-id": "ms-arab-id", "und-arab-in": "ur-arab-in", "und-arab-kh": "cja-arab-kh", "und-arab-mm": "rhg-arab-mm", "und-arab-mn": "kk-arab-mn", "und-arab-mu": "ur-arab-mu", "und-arab-ng": "ha-arab-ng", "und-arab-pk": "ur-arab-pk", "und-arab-tg": "apd-arab-tg", "und-arab-th": "mfa-arab-th", "und-arab-tj": "fa-arab-tj", "und-arab-tr": "apc-arab-tr", "und-arab-yt": "swb-arab-yt", "und-armi": "arc-armi-ir", "und-armn": "hy-armn-am", "und-as": "sm-latn-as", "und-at": "de-latn-at", "und-avst": "ae-avst-ir", "und-aw": "nl-latn-aw", "und-ax": "sv-latn-ax", "und-az": "az-latn-az", "und-ba": "bs-latn-ba", "und-bali": "ban-bali-id", "und-bamu": "bax-bamu-cm", "und-bass": "bsq-bass-lr", "und-batk": "bbc-batk-id", "und-bd": "bn-beng-bd", "und-be": "nl-latn-be", "und-beng": "bn-beng-bd", "und-bf": "fr-latn-bf", "und-bg": "bg-cyrl-bg", "und-bh": "ar-arab-bh", "und-bhks": "sa-bhks-in", "und-bi": "rn-latn-bi", "und-bj": "fr-latn-bj", "und-bl": "fr-latn-bl", "und-bn": "ms-latn-bn", "und-bo": "es-latn-bo", "und-bopo": "zh-bopo-tw", "und-bq": "pap-latn-bq", "und-br": "pt-latn-br", "und-brah": "pka-brah-in", "und-brai": "fr-brai-fr", "und-bt": "dz-tibt-bt", "und-bugi": "bug-bugi-id", "und-buhd": "bku-buhd-ph", "und-bv": "und-latn-bv", "und-by": "be-cyrl-by", "und-cakm": "ccp-cakm-bd", "und-cans": "iu-cans-ca", "und-cari": "xcr-cari-tr", "und-cd": "sw-latn-cd", "und-cf": "fr-latn-cf", "und-cg": "fr-latn-cg", "und-ch": "de-latn-ch", "und-cham": "cjm-cham-vn", "und-cher": "chr-cher-us", "und-chrs": "xco-chrs-uz", "und-ci": "fr-latn-ci", "und-cl": "es-latn-cl", "und-cm": "fr-latn-cm", "und-cn": "zh-hans-cn", "und-co": "es-latn-co", "und-copt": "cop-copt-eg", "und-cp": "und-latn-cp", "und-cpmn": "und-cpmn-cy", "und-cpmn-cy": "und-cpmn-cy", "und-cprt": "grc-cprt-cy", "und-cr": "es-latn-cr", "und-cu": "es-latn-cu", "und-cv": "pt-latn-cv", "und-cw": "pap-latn-cw", "und-cy": "el-grek-cy", "und-cyrl": "ru-cyrl-ru", "und-cyrl-al": "mk-cyrl-al", "und-cyrl-ba": "sr-cyrl-ba", "und-cyrl-ge": "ab-cyrl-ge", "und-cyrl-gr": "mk-cyrl-gr", "und-cyrl-md": "uk-cyrl-md", "und-cyrl-ro": "bg-cyrl-ro", "und-cyrl-sk": "uk-cyrl-sk", "und-cyrl-tr": "kbd-cyrl-tr", "und-cyrl-xk": "sr-cyrl-xk", "und-cz": "cs-latn-cz", "und-de": "de-latn-de", "und-deva": "hi-deva-in", "und-deva-bt": "ne-deva-bt", "und-deva-fj": "hif-deva-fj", "und-deva-mu": "bho-deva-mu", "und-deva-pk": "btv-deva-pk", "und-diak": "dv-diak-mv", "und-dj": "aa-latn-dj", "und-dk": "da-latn-dk", "und-do": "es-latn-do", "und-dogr": "doi-dogr-in", "und-dupl": "fr-dupl-fr", "und-dz": "ar-arab-dz", "und-ea": "es-latn-ea", "und-ec": "es-latn-ec", "und-ee": "et-latn-ee", "und-eg": "ar-arab-eg", "und-egyp": "egy-egyp-eg", "und-eh": "ar-arab-eh", "und-elba": "sq-elba-al", "und-elym": "arc-elym-ir", "und-er": "ti-ethi-er", "und-es": "es-latn-es", "und-et": "am-ethi-et", "und-ethi": "am-ethi-et", "und-eu": "en-latn-ie", "und-ez": "de-latn-ez", "und-fi": "fi-latn-fi", "und-fo": "fo-latn-fo", "und-fr": "fr-latn-fr", "und-ga": "fr-latn-ga", "und-ge": "ka-geor-ge", "und-geor": "ka-geor-ge", "und-gf": "fr-latn-gf", "und-gh": "ak-latn-gh", "und-gl": "kl-latn-gl", "und-glag": "cu-glag-bg", "und-gn": "fr-latn-gn", "und-gong": "wsg-gong-in", "und-gonm": "esg-gonm-in", "und-goth": "got-goth-ua", "und-gp": "fr-latn-gp", "und-gq": "es-latn-gq", "und-gr": "el-grek-gr", "und-gran": "sa-gran-in", "und-grek": "el-grek-gr", "und-grek-tr": "bgx-grek-tr", "und-gs": "und-latn-gs", "und-gt": "es-latn-gt", "und-gujr": "gu-gujr-in", "und-guru": "pa-guru-in", "und-gw": "pt-latn-gw", "und-hanb": "zh-hanb-tw", "und-hang": "ko-hang-kr", "und-hani": "zh-hani-cn", "und-hano": "hnn-hano-ph", "und-hans": "zh-hans-cn", "und-hant": "zh-hant-tw", "und-hant-ca": "yue-hant-ca", "und-hebr": "he-hebr-il", "und-hebr-se": "yi-hebr-se", "und-hebr-ua": "yi-hebr-ua", "und-hebr-us": "yi-hebr-us", "und-hira": "ja-hira-jp", "und-hk": "zh-hant-hk", "und-hluw": "hlu-hluw-tr", "und-hm": "und-latn-hm", "und-hmng": "hnj-hmng-la", "und-hmnp": "hnj-hmnp-us", "und-hn": "es-latn-hn", "und-hr": "hr-latn-hr", "und-ht": "ht-latn-ht", "und-hu": "hu-latn-hu", "und-hung": "hu-hung-hu", "und-ic": "es-latn-ic", "und-id": "id-latn-id", "und-il": "he-hebr-il", "und-in": "hi-deva-in", "und-iq": "ar-arab-iq", "und-ir": "fa-arab-ir", "und-is": "is-latn-is", "und-it": "it-latn-it", "und-ital": "ett-ital-it", "und-jamo": "ko-jamo-kr", "und-java": "jv-java-id", "und-jo": "ar-arab-jo", "und-jp": "ja-jpan-jp", "und-jpan": "ja-jpan-jp", "und-kali": "eky-kali-mm", "und-kana": "ja-kana-jp", "und-kawi": "kaw-kawi-id", "und-ke": "sw-latn-ke", "und-kg": "ky-cyrl-kg", "und-kh": "km-khmr-kh", "und-khar": "pra-khar-pk", "und-khmr": "km-khmr-kh", "und-khoj": "sd-khoj-in", "und-kits": "zkt-kits-cn", "und-km": "ar-arab-km", "und-knda": "kn-knda-in", "und-kore": "ko-kore-kr", "und-kp": "ko-kore-kp", "und-kr": "ko-kore-kr", "und-kthi": "bho-kthi-in", "und-kw": "ar-arab-kw", "und-kz": "ru-cyrl-kz", "und-la": "lo-laoo-la", "und-lana": "nod-lana-th", "und-laoo": "lo-laoo-la", "und-laoo-au": "hnj-laoo-au", "und-laoo-cn": "hnj-laoo-cn", "und-laoo-fr": "hnj-laoo-fr", "und-laoo-gf": "hnj-laoo-gf", "und-laoo-mm": "hnj-laoo-mm", "und-laoo-sr": "hnj-laoo-sr", "und-laoo-th": "hnj-laoo-th", "und-laoo-us": "hnj-laoo-us", "und-laoo-vn": "hnj-laoo-vn", "und-latn-af": "tk-latn-af", "und-latn-am": "ku-latn-am", "und-latn-cn": "za-latn-cn", "und-latn-cy": "tr-latn-cy", "und-latn-dz": "fr-latn-dz", "und-latn-et": "en-latn-et", "und-latn-ge": "ku-latn-ge", "und-latn-ir": "tk-latn-ir", "und-latn-km": "fr-latn-km", "und-latn-ma": "fr-latn-ma", "und-latn-mk": "sq-latn-mk", "und-latn-mm": "kac-latn-mm", "und-latn-mo": "pt-latn-mo", "und-latn-mr": "fr-latn-mr", "und-latn-ru": "krl-latn-ru", "und-latn-sy": "fr-latn-sy", "und-latn-tn": "fr-latn-tn", "und-latn-tw": "trv-latn-tw", "und-latn-ua": "pl-latn-ua", "und-lb": "ar-arab-lb", "und-lepc": "lep-lepc-in", "und-li": "de-latn-li", "und-limb": "lif-limb-in", "und-lina": "lab-lina-gr", "und-linb": "grc-linb-gr", "und-lisu": "lis-lisu-cn", "und-lk": "si-sinh-lk", "und-ls": "st-latn-ls", "und-lt": "lt-latn-lt", "und-lu": "fr-latn-lu", "und-lv": "lv-latn-lv", "und-ly": "ar-arab-ly", "und-lyci": "xlc-lyci-tr", "und-lydi": "xld-lydi-tr", "und-ma": "ar-arab-ma", "und-mahj": "hi-mahj-in", "und-maka": "mak-maka-id", "und-mand": "myz-mand-ir", "und-mani": "xmn-mani-cn", "und-marc": "bo-marc-cn", "und-mc": "fr-latn-mc", "und-md": "ro-latn-md", "und-me": "sr-latn-me", "und-medf": "dmf-medf-ng", "und-mend": "men-mend-sl", "und-merc": "xmr-merc-sd", "und-mero": "xmr-mero-sd", "und-mf": "fr-latn-mf", "und-mg": "mg-latn-mg", "und-mk": "mk-cyrl-mk", "und-ml": "bm-latn-ml", "und-mlym": "ml-mlym-in", "und-mm": "my-mymr-mm", "und-mn": "mn-cyrl-mn", "und-mo": "zh-hant-mo", "und-modi": "mr-modi-in", "und-mong": "mn-mong-cn", "und-mq": "fr-latn-mq", "und-mr": "ar-arab-mr", "und-mroo": "mro-mroo-bd", "und-mt": "mt-latn-mt", "und-mtei": "mni-mtei-in", "und-mu": "mfe-latn-mu", "und-mult": "skr-mult-pk", "und-mv": "dv-thaa-mv", "und-mx": "es-latn-mx", "und-my": "ms-latn-my", "und-mymr": "my-mymr-mm", "und-mymr-in": "kht-mymr-in", "und-mymr-th": "mnw-mymr-th", "und-mz": "pt-latn-mz", "und-na": "af-latn-na", "und-nagm": "unr-nagm-in", "und-nand": "sa-nand-in", "und-narb": "xna-narb-sa", "und-nbat": "arc-nbat-jo", "und-nc": "fr-latn-nc", "und-ne": "ha-latn-ne", "und-newa": "new-newa-np", "und-ni": "es-latn-ni", "und-nkoo": "man-nkoo-gn", "und-nl": "nl-latn-nl", "und-no": "nb-latn-no", "und-np": "ne-deva-np", "und-nshu": "zhx-nshu-cn", "und-ogam": "sga-ogam-ie", "und-olck": "sat-olck-in", "und-om": "ar-arab-om", "und-orkh": "otk-orkh-mn", "und-orya": "or-orya-in", "und-osge": "osa-osge-us", "und-osma": "so-osma-so", "und-ougr": "oui-ougr-143", "und-pa": "es-latn-pa", "und-palm": "arc-palm-sy", "und-pauc": "ctd-pauc-mm", "und-pe": "es-latn-pe", "und-perm": "kv-perm-ru", "und-pf": "fr-latn-pf", "und-pg": "tpi-latn-pg", "und-ph": "fil-latn-ph", "und-phag": "lzh-phag-cn", "und-phli": "pal-phli-ir", "und-phlp": "pal-phlp-cn", "und-phnx": "phn-phnx-lb", "und-pk": "ur-arab-pk", "und-pl": "pl-latn-pl", "und-plrd": "hmd-plrd-cn", "und-pm": "fr-latn-pm", "und-pr": "es-latn-pr", "und-prti": "xpr-prti-ir", "und-ps": "ar-arab-ps", "und-pt": "pt-latn-pt", "und-pw": "pau-latn-pw", "und-py": "gn-latn-py", "und-qa": "ar-arab-qa", "und-qo": "en-latn-dg", "und-re": "fr-latn-re", "und-rjng": "rej-rjng-id", "und-ro": "ro-latn-ro", "und-rohg": "rhg-rohg-mm", "und-rs": "sr-cyrl-rs", "und-ru": "ru-cyrl-ru", "und-runr": "non-runr-se", "und-rw": "rw-latn-rw", "und-sa": "ar-arab-sa", "und-samr": "smp-samr-il", "und-sarb": "xsa-sarb-ye", "und-saur": "saz-saur-in", "und-sc": "fr-latn-sc", "und-sd": "ar-arab-sd", "und-se": "sv-latn-se", "und-sgnw": "ase-sgnw-us", "und-shaw": "en-shaw-gb", "und-shrd": "sa-shrd-in", "und-si": "sl-latn-si", "und-sidd": "sa-sidd-in", "und-sind": "sd-sind-in", "und-sinh": "si-sinh-lk", "und-sj": "nb-latn-sj", "und-sk": "sk-latn-sk", "und-sm": "it-latn-sm", "und-sn": "fr-latn-sn", "und-so": "so-latn-so", "und-sogd": "sog-sogd-uz", "und-sogo": "sog-sogo-uz", "und-sora": "srb-sora-in", "und-soyo": "cmg-soyo-mn", "und-sr": "nl-latn-sr", "und-st": "pt-latn-st", "und-sund": "su-sund-id", "und-sv": "es-latn-sv", "und-sy": "ar-arab-sy", "und-sylo": "syl-sylo-bd", "und-syrc": "syr-syrc-iq", "und-tagb": "tbw-tagb-ph", "und-takr": "doi-takr-in", "und-tale": "tdd-tale-cn", "und-talu": "khb-talu-cn", "und-taml": "ta-taml-in", "und-tang": "txg-tang-cn", "und-tavt": "blt-tavt-vn", "und-td": "fr-latn-td", "und-telu": "te-telu-in", "und-tf": "fr-latn-tf", "und-tfng": "zgh-tfng-ma", "und-tg": "fr-latn-tg", "und-tglg": "fil-tglg-ph", "und-th": "th-thai-th", "und-thaa": "dv-thaa-mv", "und-thai": "th-thai-th", "und-thai-cn": "lcp-thai-cn", "und-thai-kh": "kdt-thai-kh", "und-thai-la": "kdt-thai-la", "und-tibt": "bo-tibt-cn", "und-tirh": "mai-tirh-in", "und-tj": "tg-cyrl-tj", "und-tk": "tkl-latn-tk", "und-tl": "pt-latn-tl", "und-tm": "tk-latn-tm", "und-tn": "ar-arab-tn", "und-tnsa": "nst-tnsa-in", "und-to": "to-latn-to", "und-toto": "txo-toto-in", "und-tr": "tr-latn-tr", "und-tv": "tvl-latn-tv", "und-tw": "zh-hant-tw", "und-tz": "sw-latn-tz", "und-ua": "uk-cyrl-ua", "und-ug": "sw-latn-ug", "und-ugar": "uga-ugar-sy", "und-uy": "es-latn-uy", "und-uz": "uz-latn-uz", "und-va": "it-latn-va", "und-vaii": "vai-vaii-lr", "und-ve": "es-latn-ve", "und-vith": "sq-vith-al", "und-vn": "vi-latn-vn", "und-vu": "bi-latn-vu", "und-wara": "hoc-wara-in", "und-wcho": "nnp-wcho-in", "und-wf": "fr-latn-wf", "und-ws": "sm-latn-ws", "und-xk": "sq-latn-xk", "und-xpeo": "peo-xpeo-ir", "und-xsux": "akk-xsux-iq", "und-ye": "ar-arab-ye", "und-yezi": "ku-yezi-ge", "und-yiii": "ii-yiii-cn", "und-yt": "fr-latn-yt", "und-zanb": "cmg-zanb-mn", "und-zw": "sn-latn-zw", une: "une-latn-ng", ung: "ung-latn-au", uni: "uni-latn-pg", unk: "unk-latn-br", unm: "unm-latn-us", unn: "unn-latn-au", unr: "unr-beng-in", "unr-deva": "unr-deva-np", "unr-np": "unr-deva-np", unu: "unu-latn-pg", unx: "unx-beng-in", unz: "unz-latn-id", uok: "uok-latn-zz", uon: "uon-latn-tw", upi: "upi-latn-pg", upv: "upv-latn-vu", ur: "ur-arab-pk", ura: "ura-latn-pe", urb: "urb-latn-br", urc: "urc-latn-au", ure: "ure-latn-bo", urf: "urf-latn-au", urg: "urg-latn-pg", urh: "urh-latn-ng", uri: "uri-latn-zz", urk: "urk-thai-th", urm: "urm-latn-pg", urn: "urn-latn-id", uro: "uro-latn-pg", urp: "urp-latn-br", urr: "urr-latn-vu", urt: "urt-latn-zz", uru: "uru-latn-br", urv: "urv-latn-pg", urw: "urw-latn-zz", urx: "urx-latn-pg", ury: "ury-latn-id", urz: "urz-latn-br", usa: "usa-latn-zz", ush: "ush-arab-pk", usi: "usi-latn-bd", "usi-beng": "usi-beng-bd", usk: "usk-latn-cm", usp: "usp-latn-gt", uss: "uss-latn-ng", usu: "usu-latn-pg", uta: "uta-latn-ng", ute: "ute-latn-us", uth: "uth-latn-zz", utp: "utp-latn-sb", utr: "utr-latn-zz", utu: "utu-latn-pg", uum: "uum-grek-ge", "uum-cyrl": "uum-cyrl-ge", uur: "uur-latn-vu", uve: "uve-latn-nc", uvh: "uvh-latn-zz", uvl: "uvl-latn-zz", uwa: "uwa-latn-au", uya: "uya-latn-ng", uz: "uz-latn-uz", "uz-af": "uz-arab-af", "uz-arab": "uz-arab-af", "uz-cn": "uz-cyrl-cn", uzs: "uzs-arab-af", vaa: "vaa-taml-in", vae: "vae-latn-cf", vaf: "vaf-arab-ir", vag: "vag-latn-zz", vah: "vah-deva-in", vai: "vai-vaii-lr", vaj: "vaj-latn-na", val: "val-latn-pg", vam: "vam-latn-pg", van: "van-latn-zz", vao: "vao-latn-vu", vap: "vap-latn-in", var: "var-latn-mx", vas: "vas-deva-in", "vas-gujr": "vas-gujr-in", vau: "vau-latn-cd", vav: "vav-deva-in", "vav-gujr": "vav-gujr-in", vay: "vay-deva-np", vbb: "vbb-latn-id", vbk: "vbk-latn-ph", ve: "ve-latn-za", vec: "vec-latn-it", vem: "vem-latn-ng", veo: "veo-latn-us", vep: "vep-latn-ru", ver: "ver-latn-ng", vgr: "vgr-arab-pk", vi: "vi-latn-vn", vic: "vic-latn-sx", vid: "vid-latn-tz", vif: "vif-latn-cg", vig: "vig-latn-bf", vil: "vil-latn-ar", vin: "vin-latn-tz", vit: "vit-latn-ng", viv: "viv-latn-zz", vka: "vka-latn-au", vkj: "vkj-latn-td", vkk: "vkk-latn-id", vkl: "vkl-latn-id", vkm: "vkm-latn-br", vkn: "vkn-latn-ng", vko: "vko-latn-id", vkp: "vkp-latn-in", "vkp-deva": "vkp-deva-in", vkt: "vkt-latn-id", vku: "vku-latn-au", vkz: "vkz-latn-ng", vlp: "vlp-latn-vu", vls: "vls-latn-be", vma: "vma-latn-au", vmb: "vmb-latn-au", vmc: "vmc-latn-mx", vmd: "vmd-knda-in", vme: "vme-latn-id", vmf: "vmf-latn-de", vmg: "vmg-latn-pg", vmh: "vmh-arab-ir", vmi: "vmi-latn-au", vmj: "vmj-latn-mx", vmk: "vmk-latn-mz", vml: "vml-latn-au", vmm: "vmm-latn-mx", vmp: "vmp-latn-mx", vmq: "vmq-latn-mx", vmr: "vmr-latn-mz", vms: "vms-latn-id", vmu: "vmu-latn-au", vmw: "vmw-latn-mz", vmx: "vmx-latn-mx", vmy: "vmy-latn-mx", vmz: "vmz-latn-mx", vnk: "vnk-latn-sb", vnm: "vnm-latn-vu", vnp: "vnp-latn-vu", vo: "vo-latn-001", vor: "vor-latn-ng", vot: "vot-latn-ru", vra: "vra-latn-vu", vro: "vro-latn-ee", vrs: "vrs-latn-sb", vrt: "vrt-latn-vu", vto: "vto-latn-id", vum: "vum-latn-ga", vun: "vun-latn-tz", vut: "vut-latn-zz", vwa: "vwa-latn-cn", "vwa-mymr": "vwa-mymr-cn", wa: "wa-latn-be", waa: "waa-latn-us", wab: "wab-latn-pg", wac: "wac-latn-us", wad: "wad-latn-id", wae: "wae-latn-ch", waf: "waf-latn-br", wag: "wag-latn-pg", wah: "wah-latn-id", wai: "wai-latn-id", waj: "waj-latn-zz", wal: "wal-ethi-et", wam: "wam-latn-us", wan: "wan-latn-zz", wap: "wap-latn-gy", waq: "waq-latn-au", war: "war-latn-ph", was: "was-latn-us", wat: "wat-latn-pg", wau: "wau-latn-br", wav: "wav-latn-ng", waw: "waw-latn-br", wax: "wax-latn-pg", way: "way-latn-sr", waz: "waz-latn-pg", wba: "wba-latn-ve", wbb: "wbb-latn-id", wbe: "wbe-latn-id", wbf: "wbf-latn-bf", wbh: "wbh-latn-tz", wbi: "wbi-latn-tz", wbj: "wbj-latn-tz", wbk: "wbk-arab-af", wbl: "wbl-latn-pk", "wbl-arab": "wbl-arab-af", "wbl-cyrl": "wbl-cyrl-tj", wbm: "wbm-latn-cn", wbp: "wbp-latn-au", wbq: "wbq-telu-in", wbr: "wbr-deva-in", wbt: "wbt-latn-au", wbv: "wbv-latn-au", wbw: "wbw-latn-id", wca: "wca-latn-br", wci: "wci-latn-zz", wdd: "wdd-latn-ga", wdg: "wdg-latn-pg", wdj: "wdj-latn-au", wdk: "wdk-latn-au", wdt: "wdt-latn-ca", wdu: "wdu-latn-au", wdy: "wdy-latn-au", wec: "wec-latn-ci", wed: "wed-latn-pg", weg: "weg-latn-au", weh: "weh-latn-cm", wei: "wei-latn-pg", wem: "wem-latn-bj", weo: "weo-latn-id", wep: "wep-latn-de", wer: "wer-latn-zz", wes: "wes-latn-cm", wet: "wet-latn-id", weu: "weu-latn-mm", wew: "wew-latn-id", wfg: "wfg-latn-id", wga: "wga-latn-au", wgb: "wgb-latn-pg", wgg: "wgg-latn-au", wgi: "wgi-latn-zz", wgo: "wgo-latn-id", wgu: "wgu-latn-au", wgy: "wgy-latn-au", wha: "wha-latn-id", whg: "whg-latn-zz", whk: "whk-latn-id", whu: "whu-latn-id", wib: "wib-latn-zz", wic: "wic-latn-us", wie: "wie-latn-au", wif: "wif-latn-au", wig: "wig-latn-au", wih: "wih-latn-au", wii: "wii-latn-pg", wij: "wij-latn-au", wik: "wik-latn-au", wil: "wil-latn-au", wim: "wim-latn-au", win: "win-latn-us", wir: "wir-latn-br", wiu: "wiu-latn-zz", wiv: "wiv-latn-zz", wiy: "wiy-latn-us", wja: "wja-latn-zz", wji: "wji-latn-zz", wka: "wka-latn-tz", wkd: "wkd-latn-id", wkr: "wkr-latn-au", wkw: "wkw-latn-au", wky: "wky-latn-au", wla: "wla-latn-pg", wlg: "wlg-latn-au", wlh: "wlh-latn-tl", wli: "wli-latn-id", wlm: "wlm-latn-gb", wlo: "wlo-arab-id", wlr: "wlr-latn-vu", wls: "wls-latn-wf", wlu: "wlu-latn-au", wlv: "wlv-latn-ar", wlw: "wlw-latn-id", wlx: "wlx-latn-gh", wma: "wma-latn-ng", wmb: "wmb-latn-au", wmc: "wmc-latn-pg", wmd: "wmd-latn-br", wme: "wme-deva-np", wmh: "wmh-latn-tl", wmi: "wmi-latn-au", wmm: "wmm-latn-id", wmn: "wmn-latn-nc", wmo: "wmo-latn-zz", wms: "wms-latn-id", wmt: "wmt-latn-au", wmw: "wmw-latn-mz", "wmw-arab": "wmw-arab-mz", wmx: "wmx-latn-pg", wnb: "wnb-latn-pg", wnc: "wnc-latn-zz", wnd: "wnd-latn-au", wne: "wne-arab-pk", wng: "wng-latn-id", wni: "wni-arab-km", wnk: "wnk-latn-id", wnm: "wnm-latn-au", wnn: "wnn-latn-au", wno: "wno-latn-id", wnp: "wnp-latn-pg", wnu: "wnu-latn-zz", wnw: "wnw-latn-us", wny: "wny-latn-au", wo: "wo-latn-sn", woa: "woa-latn-au", wob: "wob-latn-zz", woc: "woc-latn-pg", wod: "wod-latn-id", woe: "woe-latn-fm", wof: "wof-latn-gm", "wof-arab": "wof-arab-gm", wog: "wog-latn-pg", woi: "woi-latn-id", wok: "wok-latn-cm", wom: "wom-latn-ng", won: "won-latn-cd", woo: "woo-latn-id", wor: "wor-latn-id", wos: "wos-latn-zz", wow: "wow-latn-id", wpc: "wpc-latn-ve", wrb: "wrb-latn-au", wrg: "wrg-latn-au", wrh: "wrh-latn-au", wri: "wri-latn-au", wrk: "wrk-latn-au", wrl: "wrl-latn-au", wrm: "wrm-latn-au", wro: "wro-latn-au", wrp: "wrp-latn-id", wrr: "wrr-latn-au", wrs: "wrs-latn-zz", wru: "wru-latn-id", wrv: "wrv-latn-pg", wrw: "wrw-latn-au", wrx: "wrx-latn-id", wrz: "wrz-latn-au", wsa: "wsa-latn-id", wsg: "wsg-gong-in", wsi: "wsi-latn-vu", wsk: "wsk-latn-zz", wsr: "wsr-latn-pg", wss: "wss-latn-gh", wsu: "wsu-latn-br", wsv: "wsv-arab-af", wtf: "wtf-latn-pg", wth: "wth-latn-au", wti: "wti-latn-et", wtk: "wtk-latn-pg", wtm: "wtm-deva-in", wtw: "wtw-latn-id", "wtw-bugi": "wtw-bugi-id", wua: "wua-latn-au", wub: "wub-latn-au", wud: "wud-latn-tg", wul: "wul-latn-id", wum: "wum-latn-ga", wun: "wun-latn-tz", wur: "wur-latn-au", wut: "wut-latn-pg", wuu: "wuu-hans-cn", wuv: "wuv-latn-zz", wux: "wux-latn-au", wuy: "wuy-latn-id", wwa: "wwa-latn-zz", wwb: "wwb-latn-au", wwo: "wwo-latn-vu", wwr: "wwr-latn-au", www: "www-latn-cm", wxw: "wxw-latn-au", wyb: "wyb-latn-au", wyi: "wyi-latn-au", wym: "wym-latn-pl", wyn: "wyn-latn-us", wyr: "wyr-latn-br", wyy: "wyy-latn-fj", xaa: "xaa-latn-es", xab: "xab-latn-ng", xai: "xai-latn-br", xaj: "xaj-latn-br", xak: "xak-latn-ve", xal: "xal-cyrl-ru", xam: "xam-latn-za", xan: "xan-ethi-et", xao: "xao-latn-vn", xar: "xar-latn-pg", xas: "xas-cyrl-ru", xat: "xat-latn-br", xau: "xau-latn-id", xav: "xav-latn-br", xaw: "xaw-latn-us", xay: "xay-latn-id", xbb: "xbb-latn-au", xbd: "xbd-latn-au", xbe: "xbe-latn-au", xbg: "xbg-latn-au", xbi: "xbi-latn-zz", xbj: "xbj-latn-au", xbm: "xbm-latn-fr", xbn: "xbn-latn-my", xbp: "xbp-latn-au", xbr: "xbr-latn-id", xbw: "xbw-latn-br", xby: "xby-latn-au", xch: "xch-latn-us", xco: "xco-chrs-uz", xcr: "xcr-cari-tr", xda: "xda-latn-au", xdk: "xdk-latn-au", xdo: "xdo-latn-ao", xdq: "xdq-cyrl-ru", xdy: "xdy-latn-id", xed: "xed-latn-cm", xeg: "xeg-latn-za", xem: "xem-latn-id", xer: "xer-latn-br", xes: "xes-latn-zz", xet: "xet-latn-br", xeu: "xeu-latn-pg", xgb: "xgb-latn-ci", xgd: "xgd-latn-au", xgg: "xgg-latn-au", xgi: "xgi-latn-au", xgm: "xgm-latn-au", xgu: "xgu-latn-au", xgw: "xgw-latn-au", xh: "xh-latn-za", xhe: "xhe-arab-pk", xhm: "xhm-khmr-kh", xhv: "xhv-latn-vn", xii: "xii-latn-za", xin: "xin-latn-gt", xir: "xir-latn-br", xis: "xis-orya-in", xiy: "xiy-latn-br", xjb: "xjb-latn-au", xjt: "xjt-latn-au", xka: "xka-arab-pk", xkb: "xkb-latn-bj", xkc: "xkc-arab-ir", xkd: "xkd-latn-id", xke: "xke-latn-id", xkg: "xkg-latn-ml", xkj: "xkj-arab-ir", xkl: "xkl-latn-id", xkn: "xkn-latn-id", xkp: "xkp-arab-ir", xkq: "xkq-latn-id", xkr: "xkr-latn-br", xks: "xks-latn-id", xkt: "xkt-latn-gh", xku: "xku-latn-cg", xkv: "xkv-latn-bw", xkw: "xkw-latn-id", xkx: "xkx-latn-pg", xky: "xky-latn-my", xkz: "xkz-latn-bt", xla: "xla-latn-zz", xlc: "xlc-lyci-tr", xld: "xld-lydi-tr", xly: "xly-elym-ir", xma: "xma-latn-so", xmb: "xmb-latn-cm", xmc: "xmc-latn-mz", xmd: "xmd-latn-cm", xmf: "xmf-geor-ge", xmg: "xmg-latn-cm", xmh: "xmh-latn-au", xmj: "xmj-latn-cm", xmm: "xmm-latn-id", xmn: "xmn-mani-cn", xmo: "xmo-latn-br", xmp: "xmp-latn-au", xmq: "xmq-latn-au", xmr: "xmr-merc-sd", xmt: "xmt-latn-id", xmu: "xmu-latn-au", xmv: "xmv-latn-mg", xmw: "xmw-latn-mg", xmx: "xmx-latn-id", xmy: "xmy-latn-au", xmz: "xmz-latn-id", xna: "xna-narb-sa", xnb: "xnb-latn-tw", xni: "xni-latn-au", xnj: "xnj-latn-tz", xnk: "xnk-latn-au", xnm: "xnm-latn-au", xnn: "xnn-latn-ph", xnq: "xnq-latn-mz", xnr: "xnr-deva-in", xnt: "xnt-latn-us", xnu: "xnu-latn-au", xny: "xny-latn-au", xnz: "xnz-latn-eg", "xnz-arab": "xnz-arab-eg", xoc: "xoc-latn-ng", xod: "xod-latn-id", xog: "xog-latn-ug", xoi: "xoi-latn-pg", xok: "xok-latn-br", xom: "xom-latn-sd", "xom-ethi": "xom-ethi-et", xon: "xon-latn-zz", xoo: "xoo-latn-br", xop: "xop-latn-pg", xor: "xor-latn-br", xow: "xow-latn-pg", xpa: "xpa-latn-au", xpb: "xpb-latn-au", xpd: "xpd-latn-au", xpf: "xpf-latn-au", xpg: "xpg-grek-tr", xph: "xph-latn-au", xpi: "xpi-ogam-gb", xpj: "xpj-latn-au", xpk: "xpk-latn-br", xpl: "xpl-latn-au", xpm: "xpm-cyrl-ru", xpn: "xpn-latn-br", xpo: "xpo-latn-mx", xpq: "xpq-latn-us", xpr: "xpr-prti-ir", xpt: "xpt-latn-au", xpv: "xpv-latn-au", xpw: "xpw-latn-au", xpx: "xpx-latn-au", xpz: "xpz-latn-au", xra: "xra-latn-br", xrb: "xrb-latn-zz", xrd: "xrd-latn-au", xre: "xre-latn-br", xrg: "xrg-latn-au", xri: "xri-latn-br", xrm: "xrm-cyrl-ru", xrn: "xrn-cyrl-ru", xrr: "xrr-latn-it", xru: "xru-latn-au", xrw: "xrw-latn-pg", xsa: "xsa-sarb-ye", xsb: "xsb-latn-ph", xse: "xse-latn-id", xsh: "xsh-latn-ng", xsi: "xsi-latn-zz", xsm: "xsm-latn-zz", xsn: "xsn-latn-ng", xsp: "xsp-latn-pg", xsq: "xsq-latn-mz", xsr: "xsr-deva-np", xss: "xss-cyrl-ru", xsu: "xsu-latn-ve", xsy: "xsy-latn-tw", xta: "xta-latn-mx", xtb: "xtb-latn-mx", xtc: "xtc-latn-sd", xtd: "xtd-latn-mx", xte: "xte-latn-id", xth: "xth-latn-au", xti: "xti-latn-mx", xtj: "xtj-latn-mx", xtl: "xtl-latn-mx", xtm: "xtm-latn-mx", xtn: "xtn-latn-mx", xtp: "xtp-latn-mx", xts: "xts-latn-mx", xtt: "xtt-latn-mx", xtu: "xtu-latn-mx", xtv: "xtv-latn-au", xtw: "xtw-latn-br", xty: "xty-latn-mx", xub: "xub-taml-in", "xub-knda": "xub-knda-in", "xub-mlym": "xub-mlym-in", xud: "xud-latn-au", xuj: "xuj-taml-in", xul: "xul-latn-au", xum: "xum-latn-it", "xum-ital": "xum-ital-it", xun: "xun-latn-au", xuo: "xuo-latn-td", xut: "xut-latn-au", xuu: "xuu-latn-na", xve: "xve-ital-it", xvi: "xvi-arab-af", xvn: "xvn-latn-es", xvo: "xvo-latn-it", xvs: "xvs-latn-it", xwa: "xwa-latn-br", xwd: "xwd-latn-au", xwe: "xwe-latn-zz", xwj: "xwj-latn-au", xwk: "xwk-latn-au", xwl: "xwl-latn-bj", xwo: "xwo-cyrl-ru", xwr: "xwr-latn-id", xwt: "xwt-latn-au", xww: "xww-latn-au", xxb: "xxb-latn-gh", xxk: "xxk-latn-id", xxm: "xxm-latn-au", xxr: "xxr-latn-br", xxt: "xxt-latn-id", xya: "xya-latn-au", xyb: "xyb-latn-au", xyj: "xyj-latn-au", xyk: "xyk-latn-au", xyl: "xyl-latn-br", xyt: "xyt-latn-au", xyy: "xyy-latn-au", xzh: "xzh-marc-cn", xzp: "xzp-latn-mx", yaa: "yaa-latn-pe", yab: "yab-latn-br", yac: "yac-latn-id", yad: "yad-latn-pe", yae: "yae-latn-ve", yaf: "yaf-latn-cd", yag: "yag-latn-cl", yai: "yai-cyrl-tj", yaj: "yaj-latn-cf", yak: "yak-latn-us", yal: "yal-latn-gn", "yal-arab": "yal-arab-gn", yam: "yam-latn-zz", yan: "yan-latn-ni", yao: "yao-latn-mz", yap: "yap-latn-fm", yaq: "yaq-latn-mx", yar: "yar-latn-ve", yas: "yas-latn-zz", yat: "yat-latn-zz", yau: "yau-latn-ve", yav: "yav-latn-cm", yaw: "yaw-latn-br", yax: "yax-latn-ao", yay: "yay-latn-zz", yaz: "yaz-latn-zz", yba: "yba-latn-zz", ybb: "ybb-latn-cm", ybe: "ybe-latn-cn", "ybe-ougr": "ybe-ougr-cn", ybh: "ybh-deva-np", ybi: "ybi-deva-np", ybj: "ybj-latn-ng", ybl: "ybl-latn-ng", ybm: "ybm-latn-pg", ybn: "ybn-latn-br", ybo: "ybo-latn-pg", ybx: "ybx-latn-pg", yby: "yby-latn-zz", ycl: "ycl-latn-cn", ycn: "ycn-latn-co", yda: "yda-latn-au", yde: "yde-latn-pg", ydg: "ydg-arab-pk", ydk: "ydk-latn-pg", yea: "yea-mlym-in", "yea-knda": "yea-knda-in", yec: "yec-latn-de", yee: "yee-latn-pg", yei: "yei-latn-cm", yej: "yej-grek-il", yel: "yel-latn-cd", yer: "yer-latn-zz", yes: "yes-latn-ng", yet: "yet-latn-id", yeu: "yeu-telu-in", yev: "yev-latn-pg", yey: "yey-latn-bw", yga: "yga-latn-au", ygi: "ygi-latn-au", ygl: "ygl-latn-pg", ygm: "ygm-latn-pg", ygp: "ygp-plrd-cn", ygr: "ygr-latn-zz", ygu: "ygu-latn-au", ygw: "ygw-latn-zz", yhd: "yhd-hebr-il", yi: "yi-hebr-001", yia: "yia-latn-au", yig: "yig-yiii-cn", yih: "yih-hebr-de", yii: "yii-latn-au", yij: "yij-latn-au", yil: "yil-latn-au", yim: "yim-latn-in", yir: "yir-latn-id", yis: "yis-latn-pg", yiv: "yiv-yiii-cn", yka: "yka-latn-ph", "yka-arab": "yka-arab-ph", ykg: "ykg-cyrl-ru", yki: "yki-latn-id", ykk: "ykk-latn-pg", ykm: "ykm-latn-pg", yko: "yko-latn-zz", ykr: "ykr-latn-pg", yky: "yky-latn-cf", yla: "yla-latn-pg", ylb: "ylb-latn-pg", yle: "yle-latn-zz", ylg: "ylg-latn-zz", yli: "yli-latn-id", yll: "yll-latn-zz", ylr: "ylr-latn-au", ylu: "ylu-latn-pg", yly: "yly-latn-nc", ymb: "ymb-latn-pg", yme: "yme-latn-pe", ymg: "ymg-latn-cd", ymk: "ymk-latn-mz", "ymk-arab": "ymk-arab-mz", yml: "yml-latn-zz", ymm: "ymm-latn-so", ymn: "ymn-latn-id", ymo: "ymo-latn-pg", ymp: "ymp-latn-pg", yna: "yna-plrd-cn", ynd: "ynd-latn-au", yng: "yng-latn-cd", ynk: "ynk-cyrl-ru", ynl: "ynl-latn-pg", ynq: "ynq-latn-ng", yns: "yns-latn-cd", ynu: "ynu-latn-co", yo: "yo-latn-ng", yob: "yob-latn-pg", yog: "yog-latn-ph", yoi: "yoi-jpan-jp", yok: "yok-latn-us", yol: "yol-latn-gb", yom: "yom-latn-cd", yon: "yon-latn-zz", yot: "yot-latn-ng", yoy: "yoy-thai-th", yra: "yra-latn-pg", yrb: "yrb-latn-zz", yre: "yre-latn-zz", yrk: "yrk-cyrl-ru", yrl: "yrl-latn-br", yrm: "yrm-latn-au", yro: "yro-latn-br", yrs: "yrs-latn-id", yrw: "yrw-latn-pg", yry: "yry-latn-au", ysd: "ysd-yiii-cn", ysn: "ysn-yiii-cn", ysp: "ysp-yiii-cn", ysr: "ysr-cyrl-ru", yss: "yss-latn-zz", ysy: "ysy-plrd-cn", ytw: "ytw-latn-pg", yty: "yty-latn-au", yua: "yua-latn-mx", yub: "yub-latn-au", yuc: "yuc-latn-us", yud: "yud-hebr-il", yue: "yue-hant-hk", "yue-cn": "yue-hans-cn", "yue-hans": "yue-hans-cn", yuf: "yuf-latn-us", yug: "yug-cyrl-ru", yui: "yui-latn-co", yuj: "yuj-latn-zz", yul: "yul-latn-cf", yum: "yum-latn-us", yun: "yun-latn-ng", yup: "yup-latn-co", yuq: "yuq-latn-bo", yur: "yur-latn-us", yut: "yut-latn-zz", yuw: "yuw-latn-zz", yux: "yux-cyrl-ru", yuz: "yuz-latn-bo", yva: "yva-latn-id", yvt: "yvt-latn-ve", ywa: "ywa-latn-pg", ywg: "ywg-latn-au", ywn: "ywn-latn-br", ywq: "ywq-plrd-cn", "ywq-yiii": "ywq-yiii-cn", ywr: "ywr-latn-au", ywu: "ywu-plrd-cn", "ywu-yiii": "ywu-yiii-cn", yww: "yww-latn-au", yxa: "yxa-latn-au", yxg: "yxg-latn-au", yxl: "yxl-latn-au", yxm: "yxm-latn-au", yxu: "yxu-latn-au", yxy: "yxy-latn-au", yyr: "yyr-latn-au", yyu: "yyu-latn-pg", za: "za-latn-cn", zaa: "zaa-latn-mx", zab: "zab-latn-mx", zac: "zac-latn-mx", zad: "zad-latn-mx", zae: "zae-latn-mx", zaf: "zaf-latn-mx", zag: "zag-latn-sd", zah: "zah-latn-ng", zaj: "zaj-latn-tz", zak: "zak-latn-tz", zam: "zam-latn-mx", zao: "zao-latn-mx", zap: "zap-latn-mx", zaq: "zaq-latn-mx", zar: "zar-latn-mx", zas: "zas-latn-mx", zat: "zat-latn-mx", zau: "zau-tibt-in", "zau-arab": "zau-arab-in", zav: "zav-latn-mx", zaw: "zaw-latn-mx", zax: "zax-latn-mx", zay: "zay-latn-et", "zay-ethi": "zay-ethi-et", zaz: "zaz-latn-ng", zba: "zba-arab-001", zbc: "zbc-latn-my", zbe: "zbe-latn-my", zbt: "zbt-latn-id", zbu: "zbu-latn-ng", zbw: "zbw-latn-my", zca: "zca-latn-mx", zch: "zch-hani-cn", zdj: "zdj-arab-km", zea: "zea-latn-nl", zeg: "zeg-latn-pg", zeh: "zeh-hani-cn", zen: "zen-tfng-mr", "zen-arab": "zen-arab-mr", zga: "zga-latn-tz", zgb: "zgb-hani-cn", zgh: "zgh-tfng-ma", zgm: "zgm-hani-cn", zgn: "zgn-hani-cn", zgr: "zgr-latn-pg", zh: "zh-hans-cn", "zh-au": "zh-hant-au", "zh-bn": "zh-hant-bn", "zh-bopo": "zh-bopo-tw", "zh-gb": "zh-hant-gb", "zh-gf": "zh-hant-gf", "zh-hanb": "zh-hanb-tw", "zh-hant": "zh-hant-tw", "zh-hk": "zh-hant-hk", "zh-id": "zh-hant-id", "zh-mo": "zh-hant-mo", "zh-pa": "zh-hant-pa", "zh-pf": "zh-hant-pf", "zh-ph": "zh-hant-ph", "zh-sr": "zh-hant-sr", "zh-th": "zh-hant-th", "zh-tw": "zh-hant-tw", "zh-us": "zh-hant-us", "zh-vn": "zh-hant-vn", zhd: "zhd-hani-cn", "zhd-latn": "zhd-latn-vn", zhi: "zhi-latn-ng", zhn: "zhn-latn-cn", "zhn-hani": "zhn-hani-cn", zhw: "zhw-latn-cm", zhx: "zhx-nshu-cn", zia: "zia-latn-zz", zik: "zik-latn-pg", zil: "zil-latn-gn", zim: "zim-latn-td", zin: "zin-latn-tz", ziw: "ziw-latn-tz", ziz: "ziz-latn-ng", zka: "zka-latn-id", zkb: "zkb-cyrl-ru", zkd: "zkd-latn-mm", zko: "zko-cyrl-ru", zkp: "zkp-latn-br", zkt: "zkt-kits-cn", zku: "zku-latn-au", zkz: "zkz-cyrl-ru", zla: "zla-latn-cd", zlj: "zlj-hani-cn", "zlj-latn": "zlj-latn-cn", zlm: "zlm-latn-tg", zln: "zln-hani-cn", zlq: "zlq-hani-cn", zma: "zma-latn-au", zmb: "zmb-latn-cd", zmc: "zmc-latn-au", zmd: "zmd-latn-au", zme: "zme-latn-au", zmf: "zmf-latn-cd", zmg: "zmg-latn-au", zmh: "zmh-latn-pg", zmi: "zmi-latn-my", zmj: "zmj-latn-au", zmk: "zmk-latn-au", zml: "zml-latn-au", zmm: "zmm-latn-au", zmn: "zmn-latn-ga", zmo: "zmo-latn-sd", zmp: "zmp-latn-cd", zmq: "zmq-latn-cd", zmr: "zmr-latn-au", zms: "zms-latn-cd", zmt: "zmt-latn-au", zmu: "zmu-latn-au", zmv: "zmv-latn-au", zmw: "zmw-latn-cd", zmx: "zmx-latn-cg", zmy: "zmy-latn-au", zmz: "zmz-latn-cd", zna: "zna-latn-td", zne: "zne-latn-zz", zng: "zng-latn-vn", znk: "znk-latn-au", zns: "zns-latn-ng", zoc: "zoc-latn-mx", zoh: "zoh-latn-mx", zom: "zom-latn-in", zoo: "zoo-latn-mx", zoq: "zoq-latn-mx", zor: "zor-latn-mx", zos: "zos-latn-mx", zpa: "zpa-latn-mx", zpb: "zpb-latn-mx", zpc: "zpc-latn-mx", zpd: "zpd-latn-mx", zpe: "zpe-latn-mx", zpf: "zpf-latn-mx", zpg: "zpg-latn-mx", zph: "zph-latn-mx", zpi: "zpi-latn-mx", zpj: "zpj-latn-mx", zpk: "zpk-latn-mx", zpl: "zpl-latn-mx", zpm: "zpm-latn-mx", zpn: "zpn-latn-mx", zpo: "zpo-latn-mx", zpp: "zpp-latn-mx", zpq: "zpq-latn-mx", zpr: "zpr-latn-mx", zps: "zps-latn-mx", zpt: "zpt-latn-mx", zpu: "zpu-latn-mx", zpv: "zpv-latn-mx", zpw: "zpw-latn-mx", zpx: "zpx-latn-mx", zpy: "zpy-latn-mx", zpz: "zpz-latn-mx", zqe: "zqe-hani-cn", "zqe-latn": "zqe-latn-cn", zrn: "zrn-latn-td", zro: "zro-latn-ec", zrp: "zrp-hebr-fr", zrs: "zrs-latn-id", zsa: "zsa-latn-pg", zsr: "zsr-latn-mx", zsu: "zsu-latn-pg", zte: "zte-latn-mx", ztg: "ztg-latn-mx", ztl: "ztl-latn-mx", ztm: "ztm-latn-mx", ztn: "ztn-latn-mx", ztp: "ztp-latn-mx", ztq: "ztq-latn-mx", zts: "zts-latn-mx", ztt: "ztt-latn-mx", ztu: "ztu-latn-mx", ztx: "ztx-latn-mx", zty: "zty-latn-mx", zu: "zu-latn-za", zua: "zua-latn-ng", zuh: "zuh-latn-pg", zum: "zum-arab-om", zun: "zun-latn-us", zuy: "zuy-latn-cm", zyg: "zyg-hani-cn", zyj: "zyj-latn-cn", "zyj-hani": "zyj-hani-cn", zyn: "zyn-hani-cn", zyp: "zyp-latn-mm", zza: "zza-latn-tr", zzj: "zzj-hani-cn" }, _d = {}.hasOwnProperty;
        function bd(A) {
          const { language: f, script: C, region: _ } = A;
          let v;
          var M, Y;
          return C && _ && (v = Ad[co({ language: f, script: C, region: _ })]) ? (A.script = void 0, A.region = void 0) : C && (v = Ad[co({ language: f, script: C })]) ? A.script = void 0 : _ && (v = Ad[co({ language: f, region: _ })]) ? A.region = void 0 : f && (v = Ad[f]), v && (A.language = void 0, M = A, Y = bs(v), M.language || (M.language = Y.language), M.script || (M.script = Y.script), M.region || (M.region = Y.region), Y.variants && M.variants.push(...Y.variants)), co(A);
        }
        function Sd(A, f) {
          const C = {}, _ = bs(String(A || "").toLowerCase(), C), v = co(_);
          if (!v) return v;
          let M = -1;
          for (; ++M < Ec.length; ) {
            let Y = Ec[M].from;
            Y.slice(0, 4) === "und-" && _.language && (Y = _.language + Y.slice(3)), vc(v, Y).length > 0 && X0(_, Y, Ec[M].to);
          }
          for (M = -1; ++M < eu.length; ) sp(_, eu[M].from.field, eu[M].from.value) && op(_, eu[M].to.field, eu[M].to.value);
          if (function(Y) {
            bd(Y);
            const { language: H, script: L, region: W } = Y;
            if (!H) return Y;
            const K = co({ language: H, script: L, region: W });
            K === bd(bs(H)) ? (Y.script = void 0, Y.region = void 0) : W && K === bd(bs(H + "-" + W)) ? Y.script = void 0 : L && K === bd(bs(H + "-" + L)) && (Y.region = void 0);
          }(_), _.variants.sort(), _.extensions.sort(W0), C.warning) {
            let Y;
            for (Y in Tc) if (_d.call(Tc, Y)) {
              const H = Tc[Y], L = _[Y];
              if (L && _d.call(H, L)) {
                const W = H[L];
                C.warning("Deprecated " + Y + " `" + L + "`, expected one of `" + W.join("`, `") + "`", -1, 7);
              }
            }
          }
          return _.script && (_.script = _.script.charAt(0).toUpperCase() + _.script.slice(1)), _.region && (_.region = _.region.toUpperCase()), co(_);
        }
        function X0(A, f, C) {
          const _ = bs(f), v = bs(C), M = [], Y = _.language;
          let H;
          for (H in _) if (_d.call(_, H)) {
            const L = _[H];
            L && sp(A, H, L) && M.push(H);
          }
          for (H in v) if (_d.call(v, H)) {
            const L = v[H];
            Y && L && (M.includes(H) || !A[H]) && op(A, H, H === "language" && L === "und" ? Y : L);
          }
        }
        function sp(A, f, C) {
          let _, v = !1;
          if (C) {
            const M = A[f];
            if (_ = M, Array.isArray(M)) {
              _ = [];
              let Y = -1;
              for (; ++Y < M.length; ) {
                const H = M[Y];
                C.includes(H) ? v = !0 : _.push(H);
              }
            } else M === C && (_ = null, v = !0);
            A[f] = _;
          }
          return v;
        }
        function op(A, f, C) {
          const _ = A[f];
          if (Array.isArray(_)) {
            const v = Array.isArray(C) ? C : [C];
            let M = -1;
            for (; ++M < v.length; ) {
              const Y = v[M];
              _.includes(Y) || _.push(Y);
            }
          } else A[f] = C;
        }
        function W0(A, f) {
          return A.singleton > f.singleton ? 1 : A.singleton < f.singleton ? -1 : 0;
        }
        const j0 = { 0: void 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 5, 7: 7, 8: 2, 9: 3, 10: 4, 11: 6, 12: 7, 13: 22, 14: 7, 15: 10, 16: 9, 17: 11, 18: 13, 19: 11, 20: 13 };
        function lp(A) {
          return A == 0 ? 0 : A.toString(2).match(/1/g).length;
        }
        function kc(A, f) {
          let C, _ = parseInt("0x" + A, 16), v = _ & f[0], M = _ & f[1];
          return C = lp(v) + 2 * lp(M), C;
        }
        function Lc() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L, W, K, R, G;
          function F(rt) {
            if (!(rt && rt.currentRepresentation && rt.currentRepresentation.mediaInfo && rt.currentRepresentation.mediaInfo.type)) return;
            const Et = rt.currentRepresentation.mediaInfo.type;
            L[Et] = rt.currentRepresentation;
          }
          function et(rt, Et) {
            return rt && v[Et] && v[Et][rt] ? v[Et][rt].list : [];
          }
          function it(rt, Et) {
            return rt && v[Et] && v[Et][rt] ? v[Et][rt].current : null;
          }
          function st(rt) {
            let Et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!rt || !rt.streamInfo) return;
            const kt = rt.type, Dt = rt.streamInfo.id, Ut = it(kt, Dt);
            if (v[Dt] && v[Dt][kt] && (v[Dt][kt].current = rt, v[Dt][kt].current && (kt !== X.A.TEXT && !mt(rt, Ut) || kt === X.A.TEXT && rt.isFragmented) && f.trigger(at.A.CURRENT_TRACK_CHANGED, { oldMediaInfo: Ut, newMediaInfo: rt, switchMode: M.get().streaming.trackSwitchMode[kt], options: Et }, { streamId: Dt }), !Et.hasOwnProperty("noSettingsSave") || !Et.noSettingsSave)) {
              let Wt = function(ie) {
                const de = { lang: ie.lang, viewpoint: ie.viewpoint, roles: ie.roles, accessibility: ie.accessibility, audioChannelConfiguration: ie.audioChannelConfiguration, codec: ie.codec };
                return de.lang || de.viewpoint || de.role && de.role.length > 0 || de.accessibility && de.accessibility.length > 0 || de.audioChannelConfiguration && de.audioChannelConfiguration.length > 0 ? de : null;
              }(rt);
              if (!Wt || !v[Dt][kt].storeLastSettings) return;
              Wt.roles && (Wt.role = Wt.roles[0], delete Wt.roles), Wt.accessibility && (Wt.accessibility = Wt.accessibility[0]), Wt.audioChannelConfiguration && (Wt.audioChannelConfiguration = Wt.audioChannelConfiguration[0]), H[kt] = Wt, G.setSavedMediaSettings(kt, Wt);
            }
          }
          function ot(rt, Et) {
            rt && Et && (Y[rt] = Et);
          }
          function ut(rt) {
            return rt ? Y[rt] : null;
          }
          function mt(rt, Et) {
            if (!rt && !Et) return !0;
            if (!rt || !Et) return !1;
            const kt = rt.id === Et.id, Dt = JSON.stringify(rt.viewpoint) === JSON.stringify(Et.viewpoint), Ut = rt.lang === Et.lang, Wt = rt.codec === Et.codec, ie = JSON.stringify(rt.roles) === JSON.stringify(Et.roles), de = JSON.stringify(rt.accessibility) === JSON.stringify(Et.accessibility), Be = JSON.stringify(rt.audioChannelConfiguration) === JSON.stringify(Et.audioChannelConfiguration);
            return kt && Wt && Dt && Ut && ie && de && Be;
          }
          function wt() {
            v = {}, H = {}, L = {}, Y = { audio: null, video: null, text: null, mesh: null }, f.off(At.A.REPRESENTATION_SWITCH, F, C);
          }
          function $(rt, Et, kt) {
            let Dt = [];
            return rt.forEach(function(Ut) {
              Et(kt, Ut) && Dt.push(Ut);
            }), Dt.length !== 0 || Et === _t && M.get().streaming.assumeDefaultRoleAsMain && ft(kt.role, { schemeIdUri: X.A.DASH_ROLE_SCHEME_ID, value: D.A.MAIN }) && (_.info("no track with Role set to main - assuming main as default and searching again"), Dt = $(rt, Ct, null), Dt.length !== 0) ? Dt : (_.info("Filter-Function (" + Et.name + ") resulted in no tracks; setting ignored"), rt);
          }
          function P(rt, Et) {
            try {
              return !rt.lang || rt.lang instanceof RegExp ? Et.lang.match(rt.lang) : Et.lang !== "" && vc(Et.lang, Sd(rt.lang)).length > 0;
            } catch (kt) {
              return !1;
            }
          }
          function j(rt, Et) {
            return rt.index === void 0 || rt.index === null || Et.index === rt.index;
          }
          function J(rt, Et) {
            return rt.id === void 0 || rt.id === null || Et.id === rt.id;
          }
          function ht(rt, Et) {
            return !rt.viewpoint || !!Et.viewpoint.filter(function(kt) {
              return ft(kt, rt.viewpoint);
            })[0];
          }
          function _t(rt, Et) {
            let kt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            return !!Et.roles && (!rt.role || !!Et.roles.filter(function(Dt) {
              return ft(Dt, rt.role);
            })[0] || Et.type === X.A.AUDIO && kt);
          }
          function Ct(rt, Et) {
            return !Et.roles || Et.roles.length === 0;
          }
          function bt(rt, Et) {
            let kt;
            return kt = rt.accessibility ? !!Et.accessibility.filter(function(Dt) {
              return ft(Dt, rt.accessibility);
            })[0] : !Et.accessibility.length, kt;
          }
          function Rt(rt, Et) {
            return !rt.audioChannelConfiguration || !!Et.audioChannelConfiguration.filter(function(kt) {
              return ft(kt, rt.audioChannelConfiguration);
            })[0];
          }
          function xt(rt, Et) {
            return !rt.codec || rt.codec === Et.codec;
          }
          function Pt(rt) {
            let Et = 0, kt = [];
            return rt.forEach((Dt) => {
              isNaN(Dt.selectionPriority) || (Dt.selectionPriority > Et ? (Et = Dt.selectionPriority, kt = [Dt]) : Dt.selectionPriority === Et && kt.push(Dt));
            }), kt;
          }
          function N(rt) {
            let Et, kt = 0, Dt = [];
            return rt.forEach(function(Ut) {
              Et = Math.max.apply(Math, Ut.bitrateList.map(function(Wt) {
                return Wt.bandwidth;
              })), Et > kt ? (kt = Et, Dt = [Ut]) : Et === kt && Dt.push(Ut);
            }), Dt;
          }
          function ct(rt) {
            return rt[0] && rt[0].type === X.A.VIDEO ? function(Et) {
              let kt, Dt = 1 / 0, Ut = [];
              return Et.forEach(function(Wt) {
                kt = Wt.bitrateList.reduce(function(de, Be) {
                  const Oe = Math.max(1, Be.width * Be.height);
                  return de + Be.bandwidth / Oe;
                }, 0) / Wt.bitrateList.length, kt < Dt ? (Dt = kt, Ut = [Wt]) : kt === Dt && Ut.push(Wt);
              }), Ut;
            }(rt) : rt[0] && rt[0].type === X.A.AUDIO ? function(Et) {
              let kt = 1 / 0, Dt = [];
              return Et.forEach(function(Ut) {
                let Wt = Ut.audioChannelConfiguration.reduce(function(de, Be) {
                  return de + (function(Oe) {
                    let nn;
                    if (!Oe || !Oe.schemeIdUri || !Oe.value) return;
                    const _n = Oe.schemeIdUri, ke = Oe.value;
                    return _n === "urn:mpeg:dash:23003:3:audio_channel_configuration:2011" || _n === "urn:mpeg:mpegB:cicp:ChannelConfiguration" ? nn = j0[ke] : _n === "tag:dolby.com,2014:dash:audio_channel_configuration:2011" ? nn = function(rn) {
                      if (rn.length === 4) return kc(rn, [63880, 1648]);
                    }(ke) : _n === "tag:dolby.com,2015:dash:audio_channel_configuration:2015" ? nn = function(rn) {
                      if (rn.length === 6) return rn === "800000" ? 24 : kc(rn, [56834, 205245]);
                    }(ke) : _n === "tag:dts.com,2014:dash:audio_channel_configuration:2012" ? nn = parseInt(ke) : _n === "tag:dts.com,2018:uhd:audio_channel_configuration" && (nn = function(rn) {
                      if (!(rn.length > 8)) return kc(rn, [4294901727, 0]);
                    }(ke)), nn;
                  }(Be) || 0);
                }, 0) / Ut.audioChannelConfiguration.length;
                Ut.hasOwnProperty("supplementalProperties") && Ut.supplementalProperties.some((de) => de.schemeIdUri === "tag:dolby.com,2018:dash:EC3_ExtensionType:2018" && de.value === "JOC") && (Wt = 16), Wt || (Wt = 1);
                let ie = Ut.bitrateList.reduce(function(de, Be) {
                  return de + Be.bandwidth / Wt;
                }, 0) / Ut.bitrateList.length;
                ie < kt ? (kt = ie, Dt = [Ut]) : ie === kt && Dt.push(Ut);
              }), Dt;
            }(rt) : rt;
          }
          function It(rt) {
            let Et, kt = 0, Dt = [];
            return rt.forEach(function(Ut) {
              Et = Ut.representationCount, Et > kt ? (kt = Et, Dt = [Ut]) : Et === kt && Dt.push(Ut);
            }), Dt;
          }
          function dt(rt, Et) {
            if (rt === X.A.TEXT) return function(Ut) {
              if (!Ut || Ut.length === 0) return null;
              const Wt = Ut.filter((ie) => !(ie && ie.roles && ie.roles.length > 0) || ie.roles.every((de) => de.schemeIdUri !== X.A.DASH_ROLE_SCHEME_ID || de.value !== D.A.FORCED_SUBTITLE));
              return Wt.length > 0 ? Wt[0] : Ut[0];
            }(Et);
            let kt;
            const Dt = W.getCustomInitialTrackSelectionFunction();
            if (kt = function(Ut) {
              try {
                let Wt;
                return Wt = function(ie) {
                  try {
                    const de = ie.filter((Be) => {
                      const Oe = Be.type;
                      return Be.bitrateList.some((nn) => {
                        const _n = K.getAbrBitrateParameter("maxBitrate", Oe), ke = K.getAbrBitrateParameter("minBitrate", Oe);
                        return !(_n > -1 && nn.bandwidth > 1e3 * _n || ke > -1 && nn.bandwidth < 1e3 * ke);
                      });
                    });
                    return de.length > 0 ? de : ie;
                  } catch (de) {
                    return _.error(de), ie;
                  }
                }(Ut), Wt = function(ie) {
                  try {
                    if (!M.get().streaming.abr.limitBitrateByPortal) return ie;
                    const { elementWidth: de } = R.getVideoElementSize(), Be = ie.filter((Oe) => Oe.type !== X.A.VIDEO || Oe.bitrateList.some((nn) => nn.width <= de));
                    return Be.length > 0 ? Be : ie;
                  } catch (de) {
                    return _.error(de), ie;
                  }
                }(Wt), Wt;
              } catch (Wt) {
                return _.error(Wt), Ut;
              }
            }(Et), Dt && typeof Dt == "function") kt = Dt(kt);
            else if (L[rt]) kt = function(Ut, Wt) {
              if (!Ut || Ut.length === 0 || !Wt || !L[Wt]) return Ut;
              const ie = L[Wt].bandwidth;
              if (!ie || isNaN(ie)) return Ut;
              let de = { min: NaN, track: null };
              return Ut.forEach((Be) => {
                Be.bitrateList.forEach((Oe) => {
                  const nn = Math.abs(Oe.bandwidth - ie);
                  (isNaN(de.min) || nn < de.min) && (de.min = nn, de.track = Be);
                });
              }), de.track ? [de.track] : Ut;
            }(kt, rt);
            else if (M.get().streaming.ignoreSelectionPriority || (_.info("Trying to find track with highest selectionPriority"), kt = function(Ut) {
              return Pt(Ut);
            }(kt)), kt.length > 1 && M.get().streaming.prioritizeRoleMain && (_.info("Trying to find a main track"), kt = $(kt, _t, { role: { schemeIdUri: X.A.DASH_ROLE_SCHEME_ID, value: D.A.MAIN } })), kt.length > 1) {
              _.info("Selecting track based on selectionModeForInitialTrack");
              let Ut = M.get().streaming.selectionModeForInitialTrack;
              switch (Ut) {
                case X.A.TRACK_SELECTION_MODE_HIGHEST_BITRATE:
                  kt = function(Wt) {
                    let ie = N(Wt);
                    return ie.length > 1 && (ie = It(ie)), ie;
                  }(kt);
                  break;
                case X.A.TRACK_SELECTION_MODE_FIRST_TRACK:
                  kt = nt(kt);
                  break;
                case X.A.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:
                  kt = function(Wt) {
                    let ie = ct(Wt);
                    return ie.length > 1 && (ie = N(ie)), ie;
                  }(kt);
                  break;
                case X.A.TRACK_SELECTION_MODE_WIDEST_RANGE:
                  kt = function(Wt) {
                    let ie = It(Wt);
                    return ie.length > 1 && (ie = N(Wt)), ie;
                  }(kt);
                  break;
                default:
                  _.warn(`Track selection mode ${Ut} is not supported. Falling back to TRACK_SELECTION_MODE_FIRST_TRACK`), kt = nt(kt);
              }
            }
            return kt.length > 0 ? kt[0] : Et[0];
          }
          function nt(rt) {
            return rt[0];
          }
          function ft(rt, Et) {
            return !(!rt || !Et) && JSON.stringify({ schemeIdUri: rt.schemeIdUri, value: rt.value }) === JSON.stringify({ schemeIdUri: Et.schemeIdUri, value: Et.value });
          }
          return C = { addTrack: function(rt) {
            if (!rt) return;
            const Et = rt.type;
            if ((kt = Et) !== X.A.MESH && kt !== X.A.AUDIO && kt !== X.A.VIDEO && kt !== X.A.TEXT && kt !== X.A.IMAGE) return;
            var kt;
            let Dt = rt.streamInfo.id;
            v[Dt] || (v[Dt] = function() {
              const Wt = M.get().streaming.saveLastMediaSettingsForCurrentStreamingSession;
              return { mesh: { list: [], storeLastSettings: !0, current: null }, audio: { list: [], storeLastSettings: Wt, current: null }, video: { list: [], storeLastSettings: Wt, current: null }, text: { list: [], storeLastSettings: Wt, current: null }, image: { list: [], storeLastSettings: Wt, current: null } };
            }());
            const Ut = v[Dt][Et].list;
            for (let Wt = 0, ie = Ut.length; Wt < ie; ++Wt) if (mt(Ut[Wt], rt)) return;
            Ut.push(rt);
          }, areTracksEqual: mt, clearDataForStream: function(rt) {
            v[rt] && delete v[rt];
          }, getCurrentTrackFor: it, getInitialSettings: ut, getTracksFor: et, getTracksWithHighestSelectionPriority: Pt, getTracksWithHighestBitrate: N, getTracksWithHighestEfficiency: ct, getTracksWithWidestRange: It, initialize: function() {
            f.on(At.A.REPRESENTATION_SWITCH, F, C);
          }, isCurrentTrack: function(rt) {
            if (!rt) return !1;
            const Et = rt.type, kt = rt.streamInfo.id;
            return v[kt] && v[kt][Et] && mt(v[kt][Et].current, rt);
          }, matchSettings: function(rt, Et) {
            let kt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            try {
              let Dt = !1;
              if (rt.lang) {
                if (rt.lang instanceof RegExp) Dt = Et.lang.match(rt.lang);
                else if (Et.lang !== "") {
                  const Oe = Sd(rt.lang);
                  Oe && (Dt = vc(Et.lang, Oe).length > 0);
                }
              } else Dt = !0;
              const Ut = rt.index === void 0 || rt.index === null || Et.index === rt.index, Wt = !rt.viewpoint || !!Et.viewpoint.filter(function(Oe) {
                return ft(Oe, rt.viewpoint);
              })[0], ie = !rt.role || !!Et.roles.filter(function(Oe) {
                return ft(Oe, rt.role);
              })[0];
              let de = !rt.accessibility || !!Et.accessibility.filter(function(Oe) {
                return ft(Oe, rt.accessibility);
              })[0], Be = !rt.audioChannelConfiguration || !!Et.audioChannelConfiguration.filter(function(Oe) {
                return ft(Oe, rt.audioChannelConfiguration);
              })[0];
              return Dt && Ut && Wt && (ie || Et.type === X.A.AUDIO && kt) && de && Be;
            } catch (Dt) {
              return !1;
            }
          }, matchSettingsAccessibility: bt, matchSettingsAudioChannelConfig: Rt, matchSettingsIndex: j, matchSettingsLang: P, matchSettingsRole: _t, matchSettingsViewPoint: ht, reset: wt, saveTextSettingsDisabled: function() {
            G.setSavedMediaSettings(X.A.TEXT, null);
          }, selectInitialTrack: dt, setConfig: function(rt) {
            rt && (rt.domStorage && (G = rt.domStorage), rt.settings && (M = rt.settings), rt.customParametersModel && (W = rt.customParametersModel), rt.mediaPlayerModel && (K = rt.mediaPlayerModel), rt.videoModel && (R = rt.videoModel));
          }, setInitialMediaSettingsForType: function(rt, Et) {
            let kt = H[rt] || ut(rt);
            const Dt = et(rt, Et.id);
            let Ut = [];
            kt && Object.keys(kt).length !== 0 || (kt = G.getSavedMediaSettings(rt), kt && delete kt.codec, ot(rt, kt)), Dt && Dt.length !== 0 && (kt && (Ut = Array.from(Dt), _.info("Filtering " + Ut.length + " " + rt + " tracks based on settings"), Ut = $(Ut, J, kt), Ut = $(Ut, P, kt), Ut = $(Ut, j, kt), Ut = $(Ut, ht, kt), rt === X.A.AUDIO && H[rt] || (Ut = $(Ut, _t, kt)), Ut = $(Ut, bt, kt), Ut = $(Ut, Rt, kt), Ut = $(Ut, xt, kt), _.info("Filtering " + rt + " tracks ended, found " + Ut.length + " matching track(s).")), Ut.length === 0 ? st(dt(rt, Dt)) : Ut.length > 1 ? st(dt(rt, Ut)) : st(Ut[0]));
          }, setInitialSettings: ot, setTrack: st }, _ = (0, jt.A)(A).getInstance().getLogger(C), wt(), C;
        }
        Lc.__dashjs_factory_name = "MediaController";
        const up = Bt.A.getSingletonFactory(Lc);
        Bt.A.updateSingletonFactory(Lc.__dashjs_factory_name, up);
        var Z0 = up;
        const wd = NaN;
        class dp {
          constructor(f, C) {
            this.data = { baseUrls: f || null, selectedIdx: C || wd }, this.children = [];
          }
        }
        function gp() {
          let A, f, C, _;
          const v = this.context, M = (0, kn.A)(v).getInstance();
          function Y(K, R, G) {
            const F = H(G);
            K[R] ? M.areEqual(F, K[R].data.baseUrls) || (K[R].data.baseUrls = F, K[R].data.selectedIdx = wd) : K[R] = new dp(F);
          }
          function H(K) {
            let R = C.getBaseURLsFromElement(K);
            const G = _.getSynthesizedBaseUrlElements(R);
            return G && G.length > 0 && G.forEach((F) => {
              const et = R.findIndex((it) => it.serviceLocation === F.serviceLocation);
              et !== -1 ? R[et] = F : R.push(F);
            }), R;
          }
          function L(K, R) {
            const G = R || f;
            K(G.data), G.children && G.children.forEach((F) => L(K, F));
          }
          function W() {
            f = new dp();
          }
          return A = { reset: W, update: function(K) {
            (function(R) {
              (function() {
                if (!C || !C.hasOwnProperty("getBaseURLsFromElement") || !C.hasOwnProperty("getRepresentationSortFunction")) throw new Error("setConfig function has to be called previously");
              })();
              const G = H(R);
              M.areEqual(G, f.data.baseUrls) || (f.data.baseUrls = G, f.data.selectedIdx = wd), R && R.Period && R.Period.forEach((F, et) => {
                Y(f.children, et, F), F.AdaptationSet && F.AdaptationSet.forEach((it, st) => {
                  Y(f.children[et].children, st, it), it.Representation && it.Representation.sort(C.getRepresentationSortFunction()).forEach((ot, ut) => {
                    Y(f.children[et].children[st].children, ut, ot);
                  });
                });
              });
            })(K);
          }, getForPath: function(K) {
            let R = f;
            const G = [R.data];
            return K && K.forEach((F) => {
              R = R.children[F], R && G.push(R.data);
            }), G.filter((F) => F.baseUrls.length);
          }, invalidateSelectedIndexes: function(K) {
            L((R) => {
              isNaN(R.selectedIdx) || K === R.baseUrls[R.selectedIdx].serviceLocation && (R.selectedIdx = wd);
            });
          }, setConfig: function(K) {
            K.adapter && (C = K.adapter), K.contentSteeringController && (_ = K.contentSteeringController);
          }, getBaseUrls: function(K) {
            return H(K);
          } }, W(), A;
        }
        gp.__dashjs_factory_name = "BaseURLTreeModel";
        var J0 = Bt.A.getClassFactory(gp);
        function cp(A) {
          let f;
          const C = (A = A || {}).blacklistController;
          return f = { select: function(_) {
            return _ && function(v) {
              let M, Y, H = 0, L = [], W = 0;
              if (Y = v.sort(function(K, R) {
                let G = K.dvbPriority - R.dvbPriority;
                return isNaN(G) ? 0 : G;
              }).filter(function(K, R, G) {
                return !R || G[0].dvbPriority && K.dvbPriority && G[0].dvbPriority === K.dvbPriority;
              }), Y.length) return Y.length > 1 && (Y.forEach((K) => {
                H += K.dvbWeight, L.push(H);
              }), M = Math.floor(Math.random() * (H - 1)), L.every((K, R) => (W = R, !(M < K)))), Y[W];
            }(function(v) {
              let M = [];
              return v.filter(function(Y) {
                return !C.contains(Y.serviceLocation) || (Y.dvbPriority && M.push(Y.dvbPriority), !1);
              }).filter(function(Y) {
                return !M.length || !Y.dvbPriority || M.indexOf(Y.dvbPriority) === -1;
              });
            }(_));
          } }, f;
        }
        cp.__dashjs_factory_name = "DVBSelector";
        var Q0 = Bt.A.getClassFactory(cp);
        function mp(A) {
          let f;
          const C = (A = A || {}).blacklistController;
          return f = { select: function(_) {
            let v, M = 0;
            return _ && _.some((Y, H) => (M = H, !C.contains(Y.serviceLocation))) && (v = _[M]), v;
          } }, f;
        }
        mp.__dashjs_factory_name = "BasicSelector";
        var q0 = Bt.A.getClassFactory(mp);
        function fp() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M = [];
          function Y() {
            let L = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], W = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], K = 0, R = NaN;
            for (; K < L.length; ) {
              const G = L[K], F = W.findIndex((et) => et.serviceLocation && et.serviceLocation === G);
              if (F !== -1 && !v.contains(W[F].serviceLocation)) {
                R = F;
                break;
              }
              K += 1;
            }
            return R;
          }
          function H(L) {
            const W = _.getCurrentSteeringResponseData();
            if (!W) return;
            const K = L.entry, R = setTimeout(() => {
              v.remove(K), M.splice(M.indexOf(R, 1));
            }, 1e3 * W.ttl);
            M.push(R);
          }
          return C = { selectBaseUrlIndex: function(L) {
            let W = NaN;
            if (isNaN(L.selectedIdx)) {
              const R = _.getSteeringDataFromManifest();
              R && R.defaultServiceLocationArray.length > 0 && (W = Y(R.defaultServiceLocationArray, L.baseUrls));
            }
            const K = _.getCurrentSteeringResponseData();
            return L.baseUrls && L.baseUrls.length && K && K.pathwayPriority && K.pathwayPriority.length && (W = Y(K.pathwayPriority, L.baseUrls)), W;
          }, setConfig: function(L) {
            L.blacklistController && (v = L.blacklistController), L.contentSteeringController && (_ = L.contentSteeringController), f.on(L.addBlacklistEventName, H, C);
          }, reset: function() {
            M.forEach((L) => clearTimeout(L)), M = [];
          } }, _ = gt(A).getInstance(), C;
        }
        fp.__dashjs_factory_name = "ContentSteeringSelector";
        var $0 = Bt.A.getClassFactory(fp);
        function hp() {
          const A = this.context, f = (0, Mt.A)(A).getInstance(), C = (0, tt.A)(A).getInstance();
          let _, v, M, Y, H, L;
          function W() {
            H.reset(), v.reset();
          }
          return _ = { chooseSelector: function(K) {
            (0, xe.sq)(K, "boolean"), L = K ? Y : M;
          }, select: function(K) {
            if (!K) return;
            if (C.get().streaming.applyContentSteering) {
              const G = H.selectBaseUrlIndex(K);
              isNaN(G) || G === -1 || (K.selectedIdx = G);
            }
            if (!isNaN(K.selectedIdx)) return K.baseUrls[K.selectedIdx];
            let R = L.select(K.baseUrls);
            return R ? (K.selectedIdx = K.baseUrls.indexOf(R), R) : (f.trigger(at.A.URL_RESOLUTION_FAILED, { error: new Nt.A(q.URL_RESOLUTION_FAILED_GENERIC_ERROR_CODE, q.URL_RESOLUTION_FAILED_GENERIC_ERROR_MESSAGE) }), void (L === M && W()));
          }, reset: W, setConfig: function(K) {
            K.selector && (L = K.selector), K.contentSteeringSelector && (H = K.contentSteeringSelector);
          } }, v = ql(A).create({ updateEventName: at.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, addBlacklistEventName: at.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD }), M = q0(A).create({ blacklistController: v }), Y = Q0(A).create({ blacklistController: v }), H = $0(A).create(), H.setConfig({ blacklistController: v, addBlacklistEventName: at.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD }), L = M, _;
        }
        hp.__dashjs_factory_name = "BaseURLSelector";
        var tS = Bt.A.getClassFactory(hp);
        function pp() {
          let A, f;
          const C = this.context, _ = (0, Mt.A)(C).getInstance(), v = He(C).getInstance();
          let M, Y, H;
          function L(K) {
            M.update(K), Y.chooseSelector(f.getIsDVB(K)), _.trigger(At.A.BASE_URLS_UPDATED, { baseUrls: W(K) });
          }
          function W(K) {
            return M.getBaseUrls(K);
          }
          return A = { reset: function() {
            M.reset(), Y.reset();
          }, initialize: function(K) {
            M.setConfig({ adapter: f, contentSteeringController: H }), L(K);
          }, resolve: function(K) {
            const R = M.getForPath(K).reduce((G, F) => {
              const et = Y.select(F);
              return et ? (v.isRelative(et.url) ? G.url = v.resolve(et.url, G.url) : (G.url = et.url, G.serviceLocation = et.serviceLocation), G.availabilityTimeOffset = ua(et.availabilityTimeOffset), G.availabilityTimeComplete = et.availabilityTimeComplete, G.queryParams = et.queryParams, G) : new ba();
            }, new ba());
            if (!v.isRelative(R.url)) return R;
          }, setConfig: function(K) {
            K.baseURLTreeModel && (M = K.baseURLTreeModel), K.baseURLSelector && (Y = K.baseURLSelector), K.adapter && (f = K.adapter), K.contentSteeringController && (H = K.contentSteeringController);
          }, getBaseUrls: W, update: L }, M = J0(C).create(), Y = tS(C).create(), _.on(at.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, function(K) {
            M.invalidateSelectedIndexes(K.entry);
          }, A), A;
        }
        pp.__dashjs_factory_name = "BaseURLController";
        var eS = Bt.A.getClassFactory(pp), Ip = class extends sn {
          constructor(A, f) {
            super(), this.url = A || null, this.type = f || null, this.mediaType = X.A.STREAM, this.responseType = "";
          }
        };
        function Cp(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance();
          let _, v = ci(f).create({ errHandler: A.errHandler, dashMetrics: A.dashMetrics, mediaPlayerModel: A.mediaPlayerModel, errors: q });
          return _ = { load: function(M, Y, H) {
            const L = function(W, K) {
              Y.resolved = !0, Y.resolvedContent = W || null, C.trigger(at.A.XLINK_ELEMENT_LOADED, { element: Y, resolveObject: H, error: W || K ? null : new Nt.A(q.XLINK_LOADER_LOADING_FAILURE_ERROR_CODE, q.XLINK_LOADER_LOADING_FAILURE_ERROR_MESSAGE + M) });
            };
            if (M === "urn:mpeg:dash:resolve-to-zero:2013") L(null, !0);
            else {
              const W = new Ip(M, Ht.G.XLINK_EXPANSION_TYPE);
              v.load({ request: W, success: function(K) {
                L(K);
              }, error: function() {
                L(null);
              } });
            }
          }, reset: function() {
            v && (v.abort(), v = null);
          } }, _;
        }
        Cp.__dashjs_factory_name = "XlinkLoader";
        var nS = Bt.A.getClassFactory(Cp);
        const jo = "onLoad";
        function yp(A) {
          A = A || {};
          let f = this.context, C = (0, Mt.A)(f).getInstance();
          const _ = He(f).getInstance();
          let v, M, Y, H;
          function L(F, et, it) {
            let st, ot, ut = {};
            ut.elements = F, ut.type = et, ut.resolveType = it, ut.elements.length === 0 && K(ut);
            for (let mt = 0; mt < ut.elements.length; mt++) st = ut.elements[mt], ot = _.isHTTPURL(st.url) ? st.url : st.originalContent.BaseURL + st.url, H.load(ot, st, ut);
          }
          function W(F) {
            let et, it, st = "";
            if (et = F.element, it = F.resolveObject, et.resolvedContent) {
              let ot = 0;
              et.resolvedContent.indexOf("<?xml") === 0 && (ot = et.resolvedContent.indexOf("?>") + 2), st = et.resolvedContent.substr(0, ot) + "<response>" + et.resolvedContent.substr(ot) + "</response>", et.resolvedContent = M.parseXml(st).response;
            }
            (function(ot) {
              let ut, mt;
              for (ut = 0; ut < ot.elements.length; ut++) if (mt = ot.elements[ut], mt.resolved === !1) return !1;
              return !0;
            })(it) && K(it);
          }
          function K(F) {
            let et, it, st = [];
            if (function(ot) {
              let ut, mt, wt, $, P, j, J = [];
              for ($ = ot.elements.length - 1; $ >= 0; $--) {
                if (ut = ot.elements[$], mt = ut.type, ut.resolvedContent) {
                  if (ut.resolvedContent) for (P = 0; P < ut.resolvedContent[mt].length; P++) wt = ut.resolvedContent[mt][P], J.push(wt);
                } else delete ut.originalContent["xlink:actuate"], delete ut.originalContent["xlink:href"], J.push(ut.originalContent);
                for (ut.parentElement[mt].splice(ut.index, 1), j = 0; j < J.length; j++) ut.parentElement[mt].splice(ut.index + j, 0, J[j]);
                J = [];
              }
              ot.elements.length > 0 && M.getIron().run(Y);
            }(F), F.resolveType === "onActuate" && C.trigger(at.A.XLINK_READY, { manifest: Y }), F.resolveType === jo) switch (F.type) {
              case D.A.PERIOD:
                for (et = 0; et < Y[D.A.PERIOD].length; et++) it = Y[D.A.PERIOD][et], it.hasOwnProperty(D.A.ADAPTATION_SET) && (st = st.concat(R(it[D.A.ADAPTATION_SET], it, D.A.ADAPTATION_SET, jo))), it.hasOwnProperty(D.A.EVENT_STREAM) && (st = st.concat(R(it[D.A.EVENT_STREAM], it, D.A.EVENT_STREAM, jo)));
                L(st, D.A.ADAPTATION_SET, jo);
                break;
              case D.A.ADAPTATION_SET:
                C.trigger(at.A.XLINK_READY, { manifest: Y });
            }
          }
          function R(F, et, it, st) {
            let ot, ut, mt, wt = [];
            for (ut = F.length - 1; ut >= 0; ut--) ot = F[ut], ot.hasOwnProperty("xlink:href") && ot["xlink:href"] === "urn:mpeg:dash:resolve-to-zero:2013" && F.splice(ut, 1);
            for (ut = 0; ut < F.length; ut++) ot = F[ut], ot.hasOwnProperty("xlink:href") && ot.hasOwnProperty("xlink:actuate") && ot["xlink:actuate"] === st && (mt = G(ot["xlink:href"], et, it, ut, st, ot), wt.push(mt));
            return wt;
          }
          function G(F, et, it, st, ot, ut) {
            return { url: F, parentElement: et, type: it, index: st, resolveType: ot, originalContent: ut, resolvedContent: null, resolved: !1 };
          }
          return v = { resolveManifestOnLoad: function(F) {
            let et;
            Y = F, Y.Period ? (et = R(Y.Period, Y, D.A.PERIOD, jo), L(et, D.A.PERIOD, jo)) : C.trigger(at.A.XLINK_READY, { manifest: Y });
          }, setParser: function(F) {
            F && (M = F);
          }, reset: function() {
            C.off(at.A.XLINK_ELEMENT_LOADED, W, v), H && (H.reset(), H = null);
          } }, C.on(at.A.XLINK_ELEMENT_LOADED, W, v), H = nS(f).create({ errHandler: A.errHandler, dashMetrics: A.dashMetrics, mediaPlayerModel: A.mediaPlayerModel, settings: A.settings }), v;
        }
        yp.__dashjs_factory_name = "XlinkController";
        var aS = Bt.A.getClassFactory(yp);
        function Ap(A) {
          function f(v, M) {
            for (let Y in v) M.hasOwnProperty(Y) || (M[Y] = v[Y]);
          }
          function C(v, M, Y) {
            for (let H = 0, L = v.length; H < L; ++H) {
              const W = v[H];
              if (M[W.name]) if (Y[W.name]) {
                if (W.merge) {
                  const K = M[W.name], R = Y[W.name];
                  typeof K == "object" && typeof R == "object" ? f(K, R) : Y[W.name] = K + R;
                }
              } else Y[W.name] = M[W.name];
            }
          }
          function _(v, M) {
            for (let Y = 0, H = v.children.length; Y < H; ++Y) {
              const L = v.children[Y], W = M[L.name];
              if (W) for (let K = 0, R = W.length; K < R; ++K) {
                const G = W[K];
                C(v.properties, M, G), _(L, G);
              }
            }
          }
          return { run: function(v) {
            if (v === null || typeof v != "object") return v;
            if (v.Period && "period" in A) {
              const M = A.period, Y = v.Period;
              for (let H = 0, L = Y.length; H < L; ++H) {
                const W = Y[H];
                if (_(M, W), "adaptationset" in A) {
                  const K = W.AdaptationSet;
                  if (K) {
                    const R = A.adaptationset;
                    for (let G = 0, F = K.length; G < F; ++G) _(R, K[G]);
                  }
                }
              }
            }
            return v;
          } };
        }
        Ap.__dashjs_factory_name = "ObjectIron";
        var iS = Bt.A.getClassFactory(Ap), vd = class {
          constructor(A, f) {
            this._test = A, this._converter = f;
          }
          get test() {
            return this._test;
          }
          get converter() {
            return this._converter;
          }
        };
        const _p = /^([-])?P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
        var rS = class extends vd {
          constructor() {
            super((A, f, C) => {
              const _ = [D.A.MIN_BUFFER_TIME, D.A.MEDIA_PRESENTATION_DURATION, D.A.MINIMUM_UPDATE_PERIOD, D.A.TIMESHIFT_BUFFER_DEPTH, D.A.MAX_SEGMENT_DURATION, D.A.MAX_SUBSEGMENT_DURATION, D.A.SUGGESTED_PRESENTATION_DELAY, D.A.START, X.A.START_TIME, D.A.DURATION], v = _.length;
              for (let M = 0; M < v; M++) if (f === _[M]) return _p.test(C);
              return !1;
            }, (A) => {
              const f = _p.exec(A);
              let C = 31536e3 * parseFloat(f[3] || 0) + 2592e3 * parseFloat(f[5] || 0) + 86400 * parseFloat(f[7] || 0) + 3600 * parseFloat(f[9] || 0) + 60 * parseFloat(f[11] || 0) + parseFloat(f[13] || 0);
              return f[1] !== void 0 && (C = -C), C;
            });
          }
        };
        const bp = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+-])([0-9]{2})(?::?)([0-9]{2}))?/;
        var sS = class extends vd {
          constructor() {
            super((A, f, C) => bp.test(C), (A) => {
              const f = bp.exec(A);
              let C;
              if (C = Date.UTC(parseInt(f[1], 10), parseInt(f[2], 10) - 1, parseInt(f[3], 10), parseInt(f[4], 10), parseInt(f[5], 10), f[6] && parseInt(f[6], 10) || 0, f[7] && 1e3 * parseFloat(f[7]) || 0), f[9] && f[10]) {
                const _ = 60 * parseInt(f[9], 10) + parseInt(f[10], 10);
                C += (f[8] === "+" ? -1 : 1) * _ * 60 * 1e3;
              }
              return new Date(C);
            });
          }
        };
        const oS = /^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/, lS = [D.A.ID];
        var uS = class extends vd {
          constructor() {
            super((A, f, C) => oS.test(C) && lS.indexOf(f) === -1, (A) => parseFloat(A));
          }
        }, dS = class extends vd {
          constructor() {
            super((A, f) => {
              const C = { [D.A.ADAPTATION_SET]: [D.A.LANG], [D.A.REPRESENTATION]: [D.A.LANG], [D.A.CONTENT_COMPONENT]: [D.A.LANG], [D.A.LABEL]: [D.A.LANG], [D.A.GROUP_LABEL]: [D.A.LANG] };
              if (C.hasOwnProperty(A)) {
                let _ = C[A];
                return _ !== void 0 && _.indexOf(f) >= 0;
              }
              return !1;
            }, (A) => Sd(A) || String(A));
          }
        }, gS = class {
          constructor(A) {
            var f;
            this._name = A, this._merge = (f = A) && f.length && f.charAt(0) === f.charAt(0).toUpperCase();
          }
          get name() {
            return this._name;
          }
          get merge() {
            return this._merge;
          }
        }, Zo = class {
          constructor(A, f, C) {
            this._name = A || "", this._properties = [], this._children = C || [], Array.isArray(f) && f.forEach((_) => {
              this._properties.push(new gS(_));
            });
          }
          get name() {
            return this._name;
          }
          get children() {
            return this._children;
          }
          get properties() {
            return this._properties;
          }
        }, cS = class extends Zo {
          constructor() {
            const A = [D.A.PROFILES, D.A.WIDTH, D.A.HEIGHT, D.A.SAR, D.A.FRAMERATE, D.A.AUDIO_SAMPLING_RATE, D.A.MIME_TYPE, D.A.SEGMENT_PROFILES, D.A.CODECS, D.A.MAXIMUM_SAP_PERIOD, D.A.START_WITH_SAP, D.A.MAX_PLAYOUT_RATE, D.A.CODING_DEPENDENCY, D.A.SCAN_TYPE, D.A.FRAME_PACKING, D.A.AUDIO_CHANNEL_CONFIGURATION, D.A.CONTENT_PROTECTION, D.A.INBAND_EVENT_STREAM];
            super(D.A.ADAPTATION_SET, A, [new Zo(D.A.REPRESENTATION, A, [new Zo(D.A.SUB_REPRESENTATION, A)])]);
          }
        }, mS = class extends Zo {
          constructor() {
            const A = [D.A.SEGMENT_BASE, D.A.SEGMENT_TEMPLATE, D.A.SEGMENT_LIST];
            super(D.A.PERIOD, A, [new Zo(D.A.ADAPTATION_SET, A, [new Zo(D.A.REPRESENTATION, A)])]);
          }
        };
        const Sp = { "&amp;": "&", "&gt;": ">", "&lt;": "<", "&quot;": '"', "&apos;": "'" };
        function wp(A, f) {
          const C = f.split(/(&[#a-zA-Z0-9]+;)/);
          if (C.length <= 1) return f;
          for (let _ = 1; _ < C.length; _ += 2) {
            const v = C[_];
            if (v.charAt(1) === "#") {
              let M;
              M = v.charAt(2) === "x" ? parseInt(v.substring(3, v.length - 1), 16) : parseInt(v.substring(2, v.length - 1), 10), !isNaN(M) && M >= 0 && M <= 1114111 && (C[_] = String.fromCodePoint(M));
            } else A.hasOwnProperty(v) && (C[_] = A[v]);
          }
          return C.join("");
        }
        function fS(A, f) {
          var C = (f = f || {}).pos || 0, _ = !!f.keepComments, v = !!f.keepWhitespace, M = f.attrMatchers || [], Y = f.nodesAsArray || [], H = "<", L = 60, W = ">", K = 62, R = 45, G = 47, F = 33, et = 39, it = 34, st = 91, ot = 93;
          function ut(_t, Ct) {
            for (var bt = []; A[C]; ) if (A.charCodeAt(C) == L) {
              if (A.charCodeAt(C + 1) === G) {
                var Rt = C + 2;
                if (C = A.indexOf(W, C), A.substring(Rt, C).indexOf(_t) == -1) {
                  var xt = A.substring(0, C).split(`
`);
                  throw new Error(`Unexpected close tag
Line: ` + (xt.length - 1) + `
Column: ` + (xt[xt.length - 1].length + 1) + `
Char: ` + A[C]);
                }
                return C + 1 && (C += 1), bt;
              }
              if (A.charCodeAt(C + 1) === F) {
                if (A.charCodeAt(C + 2) == R) {
                  const nt = C;
                  for (; C !== -1 && (A.charCodeAt(C) !== K || A.charCodeAt(C - 1) != R || A.charCodeAt(C - 2) != R || C == -1); ) C = A.indexOf(W, C + 1);
                  C === -1 && (C = A.length), _ && bt.push(A.substring(nt, C + 1));
                } else {
                  if (A.charCodeAt(C + 2) === st && A.charCodeAt(C + 8) === st && A.substr(C + 3, 5).toLowerCase() === "cdata") {
                    var Pt = A.indexOf("]]>", C);
                    Pt == -1 ? (bt.push(A.substr(C + 9)), C = A.length) : (bt.push(A.substring(C + 9, Pt)), C = Pt + 3);
                    continue;
                  }
                  {
                    const nt = C + 1;
                    C += 2;
                    for (var N = !1; (A.charCodeAt(C) !== K || N === !0) && A[C]; ) A.charCodeAt(C) === st ? N = !0 : N === !0 && A.charCodeAt(C) === ot && (N = !1), C++;
                    bt.push(A.substring(nt, C));
                  }
                }
                C++;
                continue;
              }
              var ct = j();
              if (bt.push(ct), ct.tagName[0] === "?" && (bt.push(...ct.children), ct.children = []), Ct) {
                let nt = ct.tagName;
                Y.indexOf(nt) !== -1 ? (Ct[nt] || (Ct[nt] = []), Ct[nt].push(ct)) : Ct[nt] = ct;
              }
            } else {
              var It = (dt = void 0, dt = C, (C = A.indexOf(H, C) - 1) == -2 && (C = A.length), wp(Sp, A.slice(dt, C + 1)));
              v || (It = It.trim()), Ct ? Ct.__text = It : bt.push(It), C++;
            }
            var dt;
            return bt;
          }
          function mt(_t, Ct, bt) {
            if (_t === "S") return parseInt(bt);
            let Rt = wp(Sp, bt);
            return M.forEach((xt) => {
              xt.test(_t, Ct, bt) && (Rt = xt.converter(bt));
            }), Rt;
          }
          var wt = `\r
  >/= `;
          function $() {
            for (var _t = C; wt.indexOf(A[C]) === -1 && A[C]; ) C++;
            return A.slice(_t, C);
          }
          var P = f.noChildNodes || ["img", "br", "input", "meta", "link", "hr"];
          function j() {
            C++;
            const _t = $();
            let Ct = [], bt = { tagName: _t }, Rt = bt.tagName.indexOf(":");
            for (Rt !== -1 && (bt.__prefix = bt.tagName.substr(0, Rt), bt.tagName = bt.tagName.substr(Rt + 1)); A.charCodeAt(C) !== K && A[C]; ) {
              var xt = A.charCodeAt(C);
              if (xt > 64 && xt < 91 || xt > 96 && xt < 123) {
                for (var Pt = $(), N = A.charCodeAt(C); N && N !== et && N !== it && !(N > 64 && N < 91 || N > 96 && N < 123) && N !== K; ) C++, N = A.charCodeAt(C);
                if (N === et || N === it) {
                  var ct = (It = void 0, dt = void 0, It = A[C], dt = C + 1, C = A.indexOf(It, dt), A.slice(dt, C));
                  if (C === -1) return bt;
                } else ct = null, C--;
                ct = mt(bt.tagName, Pt, ct), bt[Pt] = ct;
              }
              C++;
            }
            var It, dt;
            if (A.charCodeAt(C - 1) !== G) if (_t == "script") {
              var nt = C + 1;
              C = A.indexOf("<\/script>", C), Ct = [A.slice(nt, C)], C += 9;
            } else _t == "style" ? (nt = C + 1, C = A.indexOf("</style>", C), Ct = [A.slice(nt, C)], C += 8) : P.indexOf(_t) === -1 ? (C++, Ct = ut(_t, bt)) : C++;
            else C++;
            return bt.__children = Ct, bt;
          }
          var J, ht = null;
          if (f.attrValue !== void 0) for (f.attrName = f.attrName || "id", ht = []; J = new RegExp("\\s" + f.attrName + `\\s*=['"]` + f.attrValue + `['"]`).exec(A), (C = J ? J.index : -1) !== -1; ) (C = A.lastIndexOf("<", C)) !== -1 && ht.push(j()), A = A.substr(C), C = 0;
          else ht = f.parseNode ? j() : ut("");
          return f.filter && (ht = Ep(ht, f.filter)), f.simplify ? vp(Array.isArray(ht) ? ht : [ht]) : (f.setPos && (ht.pos = C), ht);
        }
        function vp(A) {
          var f = {};
          if (!A.length) return "";
          if (A.length === 1 && typeof A[0] == "string") return A[0];
          for (var C in A.forEach(function(_) {
            if (typeof _ == "object") {
              f[_.tagName] || (f[_.tagName] = []);
              var v = vp(_.children);
              f[_.tagName].push(v), Object.keys(_.attributes).length && typeof v != "string" && (v._attributes = _.attributes);
            }
          }), f) f[C].length == 1 && (f[C] = f[C][0]);
          return f;
        }
        function Ep(A, f) {
          let C = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
          var v = [];
          return A.forEach(function(M, Y) {
            if (typeof M == "object" && f(M, Y, C, _) && v.push(M), M.children) {
              var H = Ep(M.children, f, C + 1, (_ ? _ + "." : "") + Y + "." + M.tagName);
              v = v.concat(H);
            }
          }), v;
        }
        const hS = [D.A.PERIOD, D.A.BASE_URL, D.A.ADAPTATION_SET, D.A.REPRESENTATION, D.A.CONTENT_PROTECTION, D.A.ROLE, D.A.ACCESSIBILITY, D.A.AUDIO_CHANNEL_CONFIGURATION, D.A.CONTENT_COMPONENT, D.A.ESSENTIAL_PROPERTY, D.A.LABEL, D.A.S, D.A.SEGMENT_URL, D.A.EVENT, D.A.EVENT_STREAM, D.A.LOCATION, D.A.SERVICE_DESCRIPTION, D.A.SUPPLEMENTAL_PROPERTY, D.A.METRICS, D.A.REPORTING, D.A.PATCH_LOCATION, D.A.REPLACE, D.A.ADD, D.A.REMOVE, D.A.UTC_TIMING, D.A.INBAND_EVENT_STREAM, D.A.PRODUCER_REFERENCE_TIME, D.A.CONTENT_STEERING];
        function Tp(A) {
          A = A || {};
          const f = this.context, C = A.debug;
          let _, v, M, Y;
          function H(L) {
            try {
              let W = fS(L, { parseNode: !0, attrMatchers: M, nodesAsArray: hS }), K = {};
              if (W.tagName.toLowerCase().indexOf("xml") !== -1) for (let R in W) {
                if (Array.isArray(W[R])) {
                  K[R] = W[R][0];
                  break;
                }
                if (typeof W[R] == "object") {
                  K[R] = W[R];
                  break;
                }
              }
              else K[W.tagName] = W, delete W.tagName;
              return K;
            } catch (W) {
              return null;
            }
          }
          return _ = { getIron: function() {
            return Y;
          }, parseXml: H, parse: function(L) {
            let W;
            const K = window.performance.now();
            if (W = H(L), !W) throw new Error("failed to parse the manifest");
            W.Patch ? (W = W.Patch, W.add && W.add.forEach((G) => Y.run(G)), W.replace && W.replace.forEach((G) => Y.run(G))) : (W = W.MPD, Y.run(W));
            const R = window.performance.now();
            return v.info("Parsing complete: " + (R - K).toPrecision(3) + "ms"), W.protocol = "DASH", W;
          } }, v = C.getLogger(_), M = [new rS(), new sS(), new uS(), new dS()], Y = iS(f).create({ adaptationset: new cS(), period: new mS() }), _;
        }
        Tp.__dashjs_factory_name = "DashParser";
        var pS = Bt.A.getClassFactory(Tp);
        function kp(A) {
          A = A || {};
          const f = this.context, C = A.debug, _ = A.settings, v = (0, Mt.A)(f).getInstance(), M = He(f).getInstance();
          let Y, H, L, W, K, R = A.mssHandler, G = A.errHandler;
          function F(et) {
            v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: et.manifest });
          }
          return Y = { load: function(et) {
            let it = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, st = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            const ot = /* @__PURE__ */ new Date(), ut = new Ip(et, Ht.G.MPD_TYPE);
            it && (ut.serviceLocation = it), st && (ut.queryParams = st), ut.startDate || (ut.startDate = ot), v.trigger(at.A.MANIFEST_LOADING_STARTED, { request: ut }), L.load({ request: ut, success: function(mt, wt, $) {
              if (!W) return;
              let P, j, J;
              if ($ && $ !== et ? (j = M.parseBaseUrl($), P = $) : (M.isRelative(et) && (et = M.resolve(et, window.location.href)), j = M.parseBaseUrl(et)), wt != "No Content") if (K === null && (K = function(ht) {
                let _t = null;
                return ht.indexOf("SmoothStreamingMedia") > -1 ? (R && (_t = R.createMssParser(), R.createMssFragmentProcessor(), R.registerEvents()), _t) : ht.indexOf("MPD") > -1 || ht.indexOf("Patch") > -1 ? pS(f).create({ debug: C }) : _t;
              }(mt)), K !== null) {
                W.setParser(K);
                try {
                  J = K.parse(mt);
                } catch (ht) {
                  return void v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Nt.A(q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${et}`) });
                }
                if (J) {
                  if (J.url = P || et, J.originalUrl || (J.originalUrl = J.url), _ && _.get().streaming.enableManifestDurationMismatchFix && J.mediaPresentationDuration && J.Period.length > 1) {
                    const ht = J.Period.reduce((_t, Ct) => _t + Ct.duration, 0);
                    !isNaN(ht) && J.mediaPresentationDuration > ht && (H.warn("Media presentation duration greater than duration of all periods. Setting duration to total period duration"), J.mediaPresentationDuration = ht);
                  }
                  J.baseUri = j, J.loadedTime = /* @__PURE__ */ new Date(), W.resolveManifestOnLoad(J), v.trigger(at.A.ORIGINAL_MANIFEST_LOADED, { originalManifest: mt });
                } else v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Nt.A(q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${et}`) });
              } else v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Nt.A(q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, q.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${et}`) });
              else v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: null });
            }, error: function(mt, wt, $) {
              v.trigger(at.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Nt.A(q.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE, q.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE + `${et}, ${$}`) });
            } });
          }, reset: function() {
            v.off(at.A.XLINK_READY, F, Y), R && R.reset(), W && (W.reset(), W = null), L && (L.abort(), L = null);
          } }, H = C.getLogger(Y), v.on(at.A.XLINK_READY, F, Y), L = ci(f).create({ errHandler: A.errHandler, dashMetrics: A.dashMetrics, mediaPlayerModel: A.mediaPlayerModel, urlUtils: M, constants: X.A, dashConstants: D.A, errors: q, requestTimeout: A.settings.get().streaming.manifestRequestTimeout }), W = aS(f).create({ errHandler: G, dashMetrics: A.dashMetrics, mediaPlayerModel: A.mediaPlayerModel, settings: A.settings }), K = null, Y;
        }
        kp.__dashjs_factory_name = "ManifestLoader";
        var IS = Bt.A.getClassFactory(kp);
        function Lp() {
          let A;
          const f = this.context, C = (0, Mt.A)(f).getInstance();
          return A = { error: function(_) {
            C.trigger(at.A.ERROR, { error: _ });
          } }, A;
        }
        Lp.__dashjs_factory_name = "ErrorHandler";
        var CS = Bt.A.getSingletonFactory(Lp), Mp = w(559);
        function Rp() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v, M, Y, H, L;
          function W(F, et, it) {
            const st = R(F, et, it);
            return v.isCodecSupportedBasedOnTestedConfigurations(st, F);
          }
          function K(F, et, it, st, ot) {
            const ut = R(F, et, it), mt = JSON.stringify(ut);
            st.has(mt) || (st.add(mt), ot.push(ut));
          }
          function R(F, et, it) {
            let st = null;
            switch (F) {
              case X.A.VIDEO:
                st = function(ot, ut) {
                  let mt = { codec: ut, width: ot.width || null, height: ot.height || null, framerate: _.getFramerate(ot) || null, bitrate: ot.bandwidth || null, isSupported: !0 };
                  M.get().streaming.capabilities.filterVideoColorimetryEssentialProperties && Object.assign(mt, function(P) {
                    let j = { colorGamut: null, transferFunction: null, isSupported: !0 };
                    for (const J of P.EssentialProperty || []) J.schemeIdUri === X.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["1", "5", "6", "7"].includes(J.value.toString()) ? j.colorGamut = X.A.MEDIA_CAPABILITIES_API.COLORGAMUT.SRGB : J.schemeIdUri === X.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["11", "12"].includes(J.value.toString()) ? j.colorGamut = X.A.MEDIA_CAPABILITIES_API.COLORGAMUT.P3 : J.schemeIdUri === X.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["9"].includes(J.value.toString()) ? j.colorGamut = X.A.MEDIA_CAPABILITIES_API.COLORGAMUT.REC2020 : J.schemeIdUri === X.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["2"].includes(J.value.toString()) ? j.colorGamut = null : J.schemeIdUri === X.A.COLOUR_PRIMARIES_SCHEME_ID_URI && (j.isSupported = !1), J.schemeIdUri === X.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["1", "6", "13", "14", "15"].includes(J.value.toString()) ? j.transferFunction = X.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.SRGB : J.schemeIdUri === X.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["16"].includes(J.value.toString()) ? j.transferFunction = X.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.PQ : J.schemeIdUri === X.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["18"].includes(J.value.toString()) ? j.transferFunction = X.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.HLG : J.schemeIdUri === X.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["2"].includes(J.value.toString()) ? j.transferFunction = null : J.schemeIdUri === X.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && (j.isSupported = !1);
                    return j;
                  }(ot));
                  let wt = mt.isSupported;
                  M.get().streaming.capabilities.filterHDRMetadataFormatEssentialProperties && Object.assign(mt, function(P) {
                    let j = { isSupported: !0, hdrMetadataType: null };
                    for (const J of P.EssentialProperty || []) J.schemeIdUri === X.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && J.value === X.A.HDR_METADATA_FORMAT_VALUES.ST2094_10 ? j.hdrMetadataType = X.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SMPTE_ST_2094_10 : J.schemeIdUri === X.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && J.value === X.A.HDR_METADATA_FORMAT_VALUES.SL_HDR2 ? j.hdrMetadataType = X.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SLHDR2 : J.schemeIdUri === X.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && J.value === X.A.HDR_METADATA_FORMAT_VALUES.ST2094_40 ? j.hdrMetadataType = X.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SMPTE_ST_2094_40 : J.schemeIdUri === X.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && (j.isSupported = !1);
                    return j;
                  }(ot));
                  let $ = mt.isSupported;
                  return wt && $ || (mt.isSupported = !1), mt;
                }(et, it);
                break;
              case X.A.AUDIO:
                st = function(ot, ut) {
                  const mt = ot.audioSamplingRate || null;
                  return { codec: ut, bitrate: ot.bandwidth || null, samplerate: mt, isSupported: !0 };
                }(et, it);
                break;
              default:
                return st;
            }
            return function(ot, ut) {
              return ot && ot[D.A.CONTENT_PROTECTION] && ot[D.A.CONTENT_PROTECTION].length > 0 && (ut.keySystemsMetadata = H.getSupportedKeySystemMetadataFromContentProtection(ot[D.A.CONTENT_PROTECTION])), ut;
            }(et, st);
          }
          function G(F) {
            if (!F || F.length === 0) return !0;
            let et = 0;
            for (; et < F.length; ) {
              if (!v.supportsEssentialProperty(F[et])) return L.debug("[Stream] EssentialProperty not supported: " + F[et].schemeIdUri), !1;
              et += 1;
            }
            return !0;
          }
          return C = { setConfig: function(F) {
            F && (F.adapter && (_ = F.adapter), F.capabilities && (v = F.capabilities), F.settings && (M = F.settings), F.protectionController && (H = F.protectionController), F.customParametersModel && (Y = F.customParametersModel));
          }, filterUnsupportedFeatures: function(F) {
            return new Promise((et) => {
              const it = [X.A.VIDEO, X.A.AUDIO], st = [];
              it.forEach((ot) => {
                (function(mt, wt) {
                  if (!mt || !mt.Period || mt.Period.length === 0) return [];
                  const $ = /* @__PURE__ */ new Set(), P = [];
                  return mt.Period.forEach((j) => {
                    j.AdaptationSet.forEach((J) => {
                      _.getIsTypeOf(J, wt) && J.Representation.forEach((ht, _t) => {
                        const Ct = _.getCodec(J, _t, !1);
                        K(wt, ht, Ct, $, P);
                        const bt = _.getSupplementalCodecs(ht);
                        bt.length > 0 && K(wt, ht, bt[0], $, P);
                      });
                    });
                  }), P;
                })(F, ot).forEach((mt) => {
                  st.push(v.runCodecSupportCheck(mt, ot));
                });
              }), Promise.allSettled(st).then(() => (it.forEach((ot) => {
                (function(ut, mt) {
                  mt && mt.Period && mt.Period.length !== 0 && mt.Period.forEach((wt) => {
                    (function($, P) {
                      $ && $.AdaptationSet && $.AdaptationSet.length !== 0 && ($.AdaptationSet = $.AdaptationSet.filter((j) => {
                        _.getIsTypeOf(j, P) && function(ht, _t) {
                          ht.Representation && ht.Representation.length !== 0 && (ht.Representation = ht.Representation.filter((Ct, bt) => {
                            const Rt = _.getCodec(ht, bt, !1), xt = W(_t, Ct, Rt);
                            let Pt = function(N, ct) {
                              let It = !1;
                              const dt = _.getSupplementalCodecs(N);
                              return dt.length > 0 && (dt.length > 1 && L.warn("[CapabilitiesFilter] Multiple supplemental codecs not supported; using the first in list"), It = W(ct, N, dt[0])), It;
                            }(Ct, _t);
                            return Pt && (L.debug(`[CapabilitiesFilter] Codec supported. Upgrading codecs string of Representation with ID ${Ct.id}`), Ct.codecs = Ct[D.A.SUPPLEMENTAL_CODECS]), xt || Pt || L.warn(`[CapabilitiesFilter] Codec ${Rt} not supported. Removing Representation with ID ${Ct.id}`), xt || Pt;
                          }));
                        }(j, P);
                        const J = j.Representation && j.Representation.length > 0;
                        return J || (f.trigger(at.A.ADAPTATION_SET_REMOVED_NO_CAPABILITIES, { adaptationSet: j }), L.warn(`[CapabilitiesFilter] AdaptationSet with ID ${j.id ? j.id : "undefined"} and codec ${j.codecs ? j.codecs : "undefined"} has been removed because of no supported Representation`)), J;
                      }));
                    })(wt, ut);
                  });
                })(ot, F);
              }), M.get().streaming.capabilities.filterUnsupportedEssentialProperties && function(ot) {
                ot && ot.Period && ot.Period.length !== 0 && ot.Period.forEach((ut) => {
                  ut.AdaptationSet = ut.AdaptationSet.filter((mt) => !mt.Representation || mt.Representation.length === 0 || !!G(_.getEssentialPropertiesForAdaptationSet(mt)) && (mt.Representation = mt.Representation.filter((wt) => G(_.getEssentialPropertiesForRepresentation(wt))), mt.Representation && mt.Representation.length > 0));
                });
              }(F), function(ot) {
                if (!ot || !ot.Period || ot.Period.length === 0) return Promise.resolve();
                const ut = [];
                return ot.Period.forEach((mt) => {
                  ut.push(function(wt) {
                    return new Promise(($) => {
                      if (!wt || !wt.AdaptationSet || wt.AdaptationSet.length === 0) return void $();
                      const P = [];
                      wt.AdaptationSet.forEach((j) => {
                        P.push(function(J) {
                          return new Promise((ht) => {
                            if (!J.Representation || J.Representation.length === 0) return void ht();
                            const _t = [];
                            J.Representation.forEach((Ct) => {
                              _t.push(function(bt) {
                                const Rt = [], xt = Y.getCustomCapabilitiesFilters();
                                return xt && xt.length !== 0 ? xt.forEach((Pt) => {
                                  Rt.push(new Promise((N) => N(Pt(bt))));
                                }) : Rt.push(Promise.resolve(!0)), Promise.all(Rt);
                              }(Ct));
                            }), Promise.all(_t).then((Ct) => {
                              J.Representation = J.Representation.filter((bt, Rt) => {
                                let xt = Ct[Rt].every((Pt) => Pt);
                                return xt || L.debug("[Stream] Representation " + bt.id + " has been removed because of unsupported CustomFilter"), xt;
                              }), ht();
                            }).catch((Ct) => {
                              L.warn("[Stream] at least one promise rejected in CustomFilter with error: ", Ct), ht();
                            });
                          });
                        }(j));
                      }), Promise.all(P).then(() => {
                        wt.AdaptationSet = wt.AdaptationSet.filter((j) => j.Representation && j.Representation.length > 0), $();
                      }).catch(() => {
                        $();
                      });
                    });
                  }(mt));
                }), Promise.all(ut);
              }(F))).then(() => {
                et();
              }).catch((ot) => {
                L.error(ot), et();
              });
            });
          } }, L = (0, jt.A)(A).getInstance().getLogger(C), C;
        }
        Rp.__dashjs_factory_name = "CapabilitiesFilter";
        var yS = Bt.A.getSingletonFactory(Rp), AS = class {
          constructor() {
            this.t = null, this.xywh = null, this.track = null, this.id = null, this.s = null, this.r = null;
          }
        };
        function Dp() {
          let A, f;
          return A = { initialize: function(C) {
            if (f = new AS(), !C) return null;
            const _ = C.indexOf("#");
            if (_ !== -1) {
              const v = C.substr(_ + 1).split("&");
              for (let M = 0, Y = v.length; M < Y; ++M) {
                const H = v[M], L = H.indexOf("=");
                if (L !== -1) {
                  const W = H.substring(0, L);
                  f.hasOwnProperty(W) && (f[W] = H.substr(L + 1));
                }
              }
            }
          }, getURIFragmentData: function() {
            return f;
          } }, A;
        }
        Dp.__dashjs_factory_name = "URIFragmentModel";
        var _S = Bt.A.getSingletonFactory(Dp);
        function Bp() {
          let A, f, C = this.context, _ = (0, Mt.A)(C).getInstance();
          return A = { getValue: function() {
            return f;
          }, setValue: function(v) {
            f = v, v && _.trigger(at.A.MANIFEST_LOADED, { data: v });
          } }, A;
        }
        Bp.__dashjs_factory_name = "ManifestModel";
        var bS = Bt.A.getSingletonFactory(Bp);
        function xp() {
          let A, f, C, _;
          const v = this.context, M = (0, tt.A)(v).getInstance();
          function Y(R, G) {
            return isNaN(R) ? 0 : R > 0 ? (G && f.warn("Supplied minimum playback rate is a positive value when it should be negative or 0. The supplied rate will not be applied and set to 0: 100% playback speed."), 0) : R < -0.5 ? (G && f.warn("Supplied minimum playback rate is out of range and will be limited to -0.5: -50% playback speed."), -0.5) : R;
          }
          function H(R, G) {
            return isNaN(R) ? 0 : R < 0 ? (G && f.warn("Supplied maximum playback rate is a negative value when it should be negative or 0. The supplied rate will not be applied and set to 0: 100% playback speed."), 0) : R > 1 ? (G && f.warn("Supplied maximum playback rate is out of range and will be limited to 1: 200% playback speed."), 1) : R;
          }
          function L() {
            const R = W(), G = C.getLiveDelay();
            return !isNaN(G) && G > 0 ? Math.min(R, G) : R;
          }
          function W() {
            return M.get().streaming.buffer.bufferTimeDefault > 0 ? M.get().streaming.buffer.bufferTimeDefault : K() ? 20 : 12;
          }
          function K() {
            return M.get().streaming.buffer.fastSwitchEnabled !== null ? M.get().streaming.buffer.fastSwitchEnabled : !C.getLowLatencyModeEnabled();
          }
          return A = { getCatchupMaxDrift: function() {
            if (!isNaN(M.get().streaming.liveCatchup.maxDrift) && M.get().streaming.liveCatchup.maxDrift >= 0) return M.get().streaming.liveCatchup.maxDrift;
            const R = _.getServiceDescriptionSettings();
            return R && R.liveCatchup && !isNaN(R.liveCatchup.maxDrift) && R.liveCatchup.maxDrift >= 0 ? R.liveCatchup.maxDrift : 12;
          }, getCatchupModeEnabled: function() {
            return M.get().streaming.liveCatchup.enabled !== null ? M.get().streaming.liveCatchup.enabled : C.getInitialCatchupModeActivated();
          }, getBufferTimeDefault: L, getBufferTimeDefaultUnadjusted: W, getFastSwitchEnabled: K, getInitialBufferLevel: function() {
            const R = M.get().streaming.buffer.initialBufferLevel;
            return isNaN(R) || R < 0 ? 0 : Math.min(L(), R);
          }, getRetryAttemptsForType: function(R) {
            const G = isNaN(M.get().streaming.retryAttempts.lowLatencyMultiplyFactor) ? 5 : M.get().streaming.retryAttempts.lowLatencyMultiplyFactor;
            return C.getLowLatencyModeEnabled() ? M.get().streaming.retryAttempts[R] * G : M.get().streaming.retryAttempts[R];
          }, getRetryIntervalsForType: function(R) {
            const G = isNaN(M.get().streaming.retryIntervals.lowLatencyReductionFactor) ? 10 : M.get().streaming.retryIntervals.lowLatencyReductionFactor;
            return C.getLowLatencyModeEnabled() ? M.get().streaming.retryIntervals[R] / G : M.get().streaming.retryIntervals[R];
          }, getCatchupPlaybackRates: function(R) {
            const G = M.get().streaming.liveCatchup.playbackRate;
            if (!isNaN(G.min) || !isNaN(G.max)) return { min: Y(G.min, R), max: H(G.max, R) };
            const F = _.getServiceDescriptionSettings();
            if (F && F.liveCatchup && (!isNaN(F.liveCatchup.playbackRate.min) || !isNaN(F.liveCatchup.playbackRate.max))) {
              const et = F.liveCatchup.playbackRate;
              return { min: Y(et.min, R), max: H(et.max, R) };
            }
            return { min: -0.5, max: 0.5 };
          }, getAbrBitrateParameter: function(R, G) {
            try {
              const F = M.get().streaming.abr[R][G];
              if (!isNaN(F) && F !== -1) return F;
              const et = _.getServiceDescriptionSettings();
              return et && et[R] && !isNaN(et[R][G]) ? et[R][G] : -1;
            } catch (F) {
              return -1;
            }
          }, setConfig: function(R) {
            R.playbackController && (C = R.playbackController), R.serviceDescriptionController && (_ = R.serviceDescriptionController);
          }, reset: function() {
          } }, f = (0, jt.A)(v).getInstance().getLogger(A), A;
        }
        xp.__dashjs_factory_name = "MediaPlayerModel";
        var SS = Bt.A.getSingletonFactory(xp);
        const nu = { DEFAULT: 0.5, STRONG: 1, WEAK: 0 };
        function Mc(A, f, C, _) {
          let v, M, Y, H, L;
          return M = A === void 0 ? null : A, Y = function(W) {
            let K = nu.DEFAULT;
            return W !== nu.DEFAULT && W !== nu.STRONG && W !== nu.WEAK || (K = W), K;
          }(C), H = f === void 0 ? null : f, L = _ === void 0 ? null : _, v = { representation: M, reason: H, rule: L, priority: Y }, v;
        }
        Mc.__dashjs_factory_name = "SwitchRequest";
        const Ed = Bt.A.getClassFactory(Mc);
        Ed.NO_CHANGE = null, Ed.PRIORITY = nu, Bt.A.updateClassFactory(Mc.__dashjs_factory_name, Ed);
        var ca = Ed;
        function Np(A) {
          A = A || {};
          const f = this.context, C = A.dashMetrics;
          let _, v;
          return _ = { getSwitchRequest: function(M) {
            try {
              const Y = ca(f).create();
              Y.rule = this.getClassName();
              const H = M.getMediaInfo(), L = M.getMediaType(), W = C.getCurrentBufferState(L), K = M.getScheduleController(), R = M.getAbrController(), G = M.getStreamInfo(), F = G ? G.id : null, et = G && G.manifestInfo ? G.manifestInfo.isDynamic : null, it = M.getThroughputController(), st = it.getSafeAverageThroughput(L), ot = it.getAverageLatency(L);
              return isNaN(st) || !W || R.getAbandonmentStateFor(F, L) === yt.ALLOW_LOAD && (W.state === yt.BUFFER_LOADED || et) && (Y.representation = R.getOptimalRepresentationForBitrate(H, st, !0), Y.reason = { throughput: st, latency: ot, message: `[ThroughputRule]: Switching to Representation with bitrate ${Y.representation ? Y.representation.bitrateInKbit : "n/a"} kbit/s. Throughput: ${st}` }, K.setTimeToLoadDelay(0)), Y;
            } catch (Y) {
              return v.error(Y), ca(f).create();
            }
          }, reset: function() {
          } }, v = (0, jt.A)(f).getInstance().getLogger(_), _;
        }
        Np.__dashjs_factory_name = "ThroughputRule";
        var Gp = Bt.A.getClassFactory(Np);
        function zp(A) {
          A = A || {};
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = A.dashMetrics, v = (0, tt.A)(f).getInstance();
          let M, Y, H;
          function L() {
            const R = v.get().streaming.abr.rules.insufficientBufferRule.parameters.segmentIgnoreCount;
            H = {}, H[X.A.VIDEO] = { ignoreCount: R }, H[X.A.AUDIO] = { ignoreCount: R }, H[X.A.MESH] = { ignoreCount: R };
          }
          function W() {
            L();
          }
          function K(R) {
            isNaN(R.startTime) || R.mediaType !== X.A.AUDIO && R.mediaType !== X.A.VIDEO && R.mediaType !== X.A.MESH || H[R.mediaType].ignoreCount > 0 && H[R.mediaType].ignoreCount--;
          }
          return M = { getSwitchRequest: function(R) {
            const G = ca(f).create();
            if (G.rule = this.getClassName(), !R || !R.hasOwnProperty("getMediaType")) return G;
            const F = R.getMediaType(), et = _.getCurrentBufferState(F), it = R.getRepresentation().fragmentDuration;
            if (!function(ut, mt, wt) {
              return !ut.getLowLatencyModeEnabled() && H[mt].ignoreCount <= 0 && wt;
            }(R.getScheduleController().getPlaybackController(), F, it)) return G;
            const st = R.getMediaInfo(), ot = R.getAbrController();
            if (et && et.state === yt.BUFFER_EMPTY) Y.debug("[" + F + "] Switch to index 0; buffer is empty."), G.representation = ot.getOptimalRepresentationForBitrate(st, 0, !0), G.reason = { message: "[InsufficientBufferRule]: Switching to lowest Representation because buffer is empty" };
            else {
              const ut = R.getThroughputController(), mt = _.getCurrentBufferLevel(F), wt = ut.getAverageThroughput(F, null, NaN) * v.get().streaming.abr.rules.insufficientBufferRule.parameters.throughputSafetyFactor * mt / it;
              if (isNaN(wt) || wt <= 0) return G;
              G.representation = ot.getOptimalRepresentationForBitrate(st, wt, !0), G.reason = { message: "[InsufficientBufferRule]: Limiting maximum bitrate to avoid a buffer underrun.", bitrate: wt };
            }
            return G;
          }, reset: function() {
            L(), C.off(At.A.PLAYBACK_SEEKING, W, M), C.off(at.A.BYTES_APPENDED_END_FRAGMENT, K, M);
          } }, Y = (0, jt.A)(f).getInstance().getLogger(M), L(), C.on(At.A.PLAYBACK_SEEKING, W, M), C.on(at.A.BYTES_APPENDED_END_FRAGMENT, K, M), M;
        }
        zp.__dashjs_factory_name = "InsufficientBufferRule";
        var wS = Bt.A.getClassFactory(zp);
        function Yp(A) {
          const f = (A = A || {}).mediaPlayerModel, C = A.dashMetrics, _ = this.context, v = (0, tt.A)(_).getInstance();
          let M, Y, H;
          function L() {
            H = {};
          }
          return M = { shouldAbandon: function(W) {
            const K = ca(_).create();
            K.rule = this.getClassName();
            try {
              if (!W) return K;
              const R = W.getCurrentRequest();
              if (!isNaN(R.index)) {
                if (R.firstByteDate === null || H.hasOwnProperty(R.index)) return K;
                const G = f.getBufferTimeDefault(), F = W.getMediaType();
                if (C.getCurrentBufferLevel(F) > G) return K;
                const et = Date.now() - R.firstByteDate.getTime();
                if (R.traces.length >= v.get().streaming.abr.rules.abandonRequestsRule.parameters.minThroughputSamplesThreshold && et > v.get().streaming.abr.rules.abandonRequestsRule.parameters.minSegmentDownloadTimeThresholdInMs && R.bytesLoaded < R.bytesTotal) return function(it, st, ot) {
                  const ut = it.getMediaInfo(), mt = it.getMediaType(), wt = st.traces.reduce((_t, Ct) => _t + Ct.b[0], 0) - st.traces[0].b[0], $ = Math.max(st.traces.reduce((_t, Ct) => _t + Ct.d, 0) - st.traces[0].d, 1), P = Math.round(8 * wt / $), j = Number(8 * st.bytesTotal / P / 1e3).toFixed(2), J = it.getRepresentation(), ht = it.getAbrController();
                  if (j < st.duration * v.get().streaming.abr.rules.abandonRequestsRule.parameters.abandonDurationMultiplier || ht.isPlayingAtLowestQuality(J)) return ot;
                  if (!H.hasOwnProperty(st.index)) {
                    const _t = it.getAbrController(), Ct = st.bytesTotal - st.bytesLoaded, bt = _t.getOptimalRepresentationForBitrate(ut, P, !0), Rt = st.representation;
                    Ct > st.bytesTotal * bt.bitrateInKbit / Rt.bitrateInKbit && (ot.representation = bt, ot.reason = { throughputInKbit: P, message: `[AbandonRequestRule][${mt} is asking to abandon and switch to quality to ${bt.absoluteIndex}. The measured bandwidth was ${P} kbit/s` }, H[st.index] = !0);
                  }
                  return ot;
                }(W, R, K);
              }
              return K;
            } catch (R) {
              return Y.error(R), K;
            }
          }, reset: L }, Y = (0, jt.A)(_).getInstance().getLogger(M), L(), M;
        }
        Yp.__dashjs_factory_name = "AbandonRequestsRule";
        var vS = Bt.A.getClassFactory(Yp);
        function Hp() {
          const A = this.context, f = (0, tt.A)(A).getInstance();
          let C;
          return C = { getSwitchRequest: function(_) {
            const v = ca(A).create();
            if (v.rule = this.getClassName(), !_ || !_.hasOwnProperty("getDroppedFramesHistory")) return v;
            const M = _.getDroppedFramesHistory();
            if (!M) return v;
            const Y = _.getStreamInfo().id, H = _.getMediaInfo(), L = _.getAbrController(), W = M.getFrameHistory(Y);
            if (!W || Object.keys(W).length === 0) return v;
            let K = 0, R = 0;
            const G = L.getPossibleVoRepresentationsFilteredBySettings(H, !0);
            let F = null;
            for (let et = 1; et < G.length; et++) {
              const it = G[et];
              if (it && W[it.id] && (K = W[it.id].droppedVideoFrames, R = W[it.id].totalVideoFrames, R > f.get().streaming.abr.rules.droppedFramesRule.parameters.minimumSampleSize && K / R > f.get().streaming.abr.rules.droppedFramesRule.parameters.droppedFramesPercentageThreshold)) {
                F = G[et - 1];
                break;
              }
            }
            return F && (v.representation = F, v.reason = { droppedFrames: K, message: `[DroppedFramesRule]: Switching to index ${F.absoluteIndex}. Dropped Frames: ${K}, Total Frames: ${R}` }), v;
          } }, C;
        }
        Hp.__dashjs_factory_name = "DroppedFramesRule";
        var ES = Bt.A.getClassFactory(Hp);
        function Pp() {
          const A = this.context, f = (0, tt.A)(A).getInstance();
          let C;
          return C = { getSwitchRequest: function(_) {
            const v = ca(A).create();
            if (v.rule = this.getClassName(), !_) return v;
            const M = _.getStreamInfo().id, Y = _.getMediaType(), H = _ ? _.getSwitchRequestHistory() : null, L = H ? H.getSwitchRequests(M, Y) : {}, W = _.getAbrController(), K = _.getMediaInfo(), R = W.getPossibleVoRepresentationsFilteredBySettings(K, !0);
            let G = 0, F = 0;
            for (let et = 0; et < R.length; et++) {
              const it = R[et];
              if (it && L[it.id] && (G += L[it.id].drops, F += L[it.id].noDrops, G + F >= f.get().streaming.abr.rules.switchHistoryRule.parameters.sampleSize && G / F > f.get().streaming.abr.rules.switchHistoryRule.parameters.switchPercentageThreshold)) {
                v.representation = et > 0 && L[it.id].drops > 0 ? R[et - 1] : it, v.reason = { drops: G, noDrops: F, message: `[SwitchHistoryRule]: Switch to index: ${v.representation.absoluteIndex} samples: ${G + F} drops:  ${G}` };
                break;
              }
            }
            return v;
          } }, C;
        }
        Pp.__dashjs_factory_name = "SwitchHistoryRule";
        var TS = Bt.A.getClassFactory(Pp);
        const Ss = "BOLA_STATE_ONE_BITRATE", Td = "BOLA_STATE_STARTUP", Rc = "BOLA_STATE_STEADY", Jo = 10;
        function Fp(A) {
          A = A || {};
          const f = this.context, C = A.dashMetrics, _ = A.mediaPlayerModel, v = (0, Mt.A)(f).getInstance(), M = eI(f).getInstance();
          let Y, H, L;
          function W(j) {
            const J = j.mediaType, ht = j.streamId, _t = J === X.A.AUDIO ? [X.A.AUDIO] : L[ht];
            for (const Ct in _t) L[ht] && L[ht].hasOwnProperty(Ct) && L[ht][Ct].state === Rc && (L[ht][Ct].placeholderBuffer = 0);
          }
          function K(j) {
            const J = j.streamId;
            for (const ht in L[J]) if (L[J].hasOwnProperty(ht)) {
              const _t = L[J][ht];
              _t.state !== Ss && (_t.state = Td, R(_t));
            }
          }
          function R(j) {
            j.placeholderBuffer = 0, j.mostAdvancedSegmentStart = NaN, j.lastSegmentWasReplacement = !1, j.lastSegmentStart = NaN, j.lastSegmentDurationS = NaN, j.lastSegmentRequestTimeMs = NaN, j.lastSegmentFinishTimeMs = NaN;
          }
          function G(j) {
            try {
              if (j && j.metric === yt.HTTP_REQUEST && j.value && j.value.type === Ht.G.MEDIA_SEGMENT_TYPE && j.value.trace && j.value.trace.length) {
                const J = L[j.value._streamId] && L[j.value._streamId][j.mediaType] ? L[j.value._streamId][j.mediaType] : null;
                J && J.state !== Ss && (J.lastSegmentRequestTimeMs = j.value.trequest.getTime(), J.lastSegmentFinishTimeMs = j.value._tfinish.getTime(), F(J, j.mediaType));
              }
            } catch (J) {
              H.error(J);
            }
          }
          function F(j, J) {
            if (!isNaN(j.lastSegmentStart) && !isNaN(j.lastSegmentRequestTimeMs) && !isNaN(j.placeholderBuffer)) {
              if (j.placeholderBuffer *= 0.99, !isNaN(j.lastSegmentFinishTimeMs)) {
                const ht = C.getCurrentBufferLevel(J) + 1e-3 * (j.lastSegmentFinishTimeMs - j.lastSegmentRequestTimeMs), _t = ot(j, j.currentRepresentation), Ct = Math.max(0, _t - ht);
                j.placeholderBuffer = Math.min(Ct, j.placeholderBuffer);
              }
              j.lastSegmentWasReplacement && !isNaN(j.lastSegmentDurationS) && (j.placeholderBuffer += j.lastSegmentDurationS), j.lastSegmentStart = NaN, j.lastSegmentRequestTimeMs = NaN;
            }
          }
          function et(j) {
            if (j && L[j.streamId] && L[j.streamId][j.mediaType]) {
              const J = L[j.streamId][j.mediaType];
              J && J.state !== Ss && (J.currentRepresentation = j.newRepresentation);
            }
          }
          function it(j, J, ht) {
            const _t = ht.reduce((Rt, xt, Pt) => xt > ht[Rt] ? Pt : Rt, 0);
            if (_t === 0) return null;
            const Ct = Math.max(j, Jo + 2 * J.length), bt = (ht[_t] - 1) / (Ct / Jo - 1);
            return { gp: bt, Vp: Jo / bt };
          }
          function st(j, J) {
            const ht = _.getBufferTimeDefault();
            if (j.bufferTimeDefault !== ht) {
              const _t = it(ht, j.representations, j.utilities);
              if (_t.Vp !== j.Vp || _t.gp !== j.gp) {
                const Ct = C.getCurrentBufferLevel(J);
                let bt = Ct + j.placeholderBuffer;
                bt -= Jo, bt *= _t.Vp / j.Vp, bt += Jo, j.bufferTimeDefault = ht, j.Vp = _t.Vp, j.gp = _t.gp, j.placeholderBuffer = Math.max(0, bt - Ct);
              }
            }
          }
          function ot(j, J) {
            return j.Vp * (j.utilities[J.absoluteIndex] + j.gp);
          }
          function ut(j) {
            if (j && j.chunk && j.chunk.representation.mediaInfo && L[j.streamId]) {
              const J = L[j.streamId][j.chunk.representation.mediaInfo.type];
              if (J && J.state !== Ss) {
                const ht = j.chunk.start;
                isNaN(J.mostAdvancedSegmentStart) || ht > J.mostAdvancedSegmentStart ? (J.mostAdvancedSegmentStart = ht, J.lastSegmentWasReplacement = !1) : J.lastSegmentWasReplacement = !0, J.lastSegmentStart = ht, J.lastSegmentDurationS = j.chunk.duration, J.currentRepresentation = j.chunk.representation, F(J, j.chunk.representation.mediaInfo.type);
              }
            }
          }
          function mt() {
            P();
          }
          function wt(j, J) {
            const ht = J.absoluteIndex, _t = J.bandwidth, Ct = j.utilities[ht];
            let bt = 0;
            for (let Rt = ht - 1; Rt >= 0; --Rt) if (j.utilities[Rt] < j.utilities[ht]) {
              const xt = j.representations[Rt].bandwidth, Pt = j.utilities[Rt], N = j.Vp * (j.gp + (_t * Pt - xt * Ct) / (_t - xt));
              bt = Math.max(bt, N);
            }
            return bt;
          }
          function $(j) {
            if (j && L[j.streamId]) {
              const J = L[j.streamId][j.mediaType];
              if (J && J.state !== Ss) {
                const ht = C.getCurrentBufferLevel(j.mediaType);
                let _t;
                _t = J.currentRepresentation.absoluteIndex > 0 ? wt(J, J.currentRepresentation) : Jo;
                const Ct = Math.max(0, _t - ht);
                J.placeholderBuffer = Math.min(J.placeholderBuffer, Ct);
              }
            }
          }
          function P() {
            L = {};
          }
          return Y = { getSwitchRequest: function(j) {
            try {
              const J = ca(f).create();
              j.getScheduleController().setTimeToLoadDelay(0), J.rule = this.getClassName(), J.reason = J.reason || {};
              const ht = function(_t) {
                const Ct = _t.getMediaType(), bt = _t.getStreamInfo().id;
                L[bt] || (L = {}, L[bt] = {});
                let Rt = L[bt][Ct];
                return Rt ? Rt.state !== Ss && st(Rt, Ct) : (Rt = function(xt) {
                  const Pt = {}, N = xt.getMediaInfo(), ct = M.getPossibleVoRepresentationsFilteredBySettings(N, !0);
                  let It = ct.map((ft) => ft.bandwidth).map((ft) => Math.log(ft));
                  It = It.map((ft) => ft - It[0] + 1);
                  const dt = _.getBufferTimeDefault(), nt = it(dt, ct, It);
                  return nt ? (Pt.state = Td, Pt.representations = ct, Pt.utilities = It, Pt.bufferTimeDefault = dt, Pt.Vp = nt.Vp, Pt.gp = nt.gp, Pt.currentRepresentation = null, R(Pt)) : Pt.state = Ss, Pt;
                }(_t), L[bt][Ct] = Rt), Rt;
              }(j);
              switch (J.reason.state = ht.state, ht.state) {
                case Ss:
                  break;
                case Td:
                  (function(_t, Ct, bt) {
                    const Rt = Ct.getMediaType(), xt = Ct.getThroughputController().getSafeAverageThroughput(Rt);
                    if (isNaN(xt)) return;
                    const Pt = Ct.getMediaInfo(), N = M.getOptimalRepresentationForBitrate(Pt, xt, !0), ct = C.getCurrentBufferLevel(Rt);
                    _t.representation = N, _t.reason.throughput = xt, bt.placeholderBuffer = Math.max(0, wt(bt, N) - ct), bt.currentRepresentation = N, !isNaN(bt.lastSegmentDurationS) && ct >= bt.lastSegmentDurationS && (bt.state = Rc);
                  })(J, j, ht);
                  break;
                case Rc:
                  (function(_t, Ct, bt) {
                    const Rt = Ct.getMediaType(), xt = Ct.getThroughputController(), Pt = Ct.getMediaInfo(), N = xt.getSafeAverageThroughput(Rt), ct = Ct.getScheduleController();
                    (function(rt, Et) {
                      const kt = Date.now();
                      if (isNaN(rt.lastSegmentFinishTimeMs)) {
                        if (!isNaN(rt.lastCallTimeMs)) {
                          const Dt = 1e-3 * (kt - rt.lastCallTimeMs);
                          rt.placeholderBuffer += Math.max(0, Dt);
                        }
                      } else {
                        const Dt = 1e-3 * (kt - rt.lastSegmentFinishTimeMs);
                        rt.placeholderBuffer += Math.max(0, Dt);
                      }
                      rt.lastCallTimeMs = kt, rt.lastSegmentStart = NaN, rt.lastSegmentRequestTimeMs = NaN, rt.lastSegmentFinishTimeMs = NaN, st(rt, Et);
                    })(bt, Rt);
                    const It = C.getCurrentBufferLevel(Rt);
                    let dt = function(rt, Et) {
                      const kt = rt.representations.length;
                      let Dt = NaN, Ut = NaN;
                      for (let Wt = 0; Wt < kt; ++Wt) {
                        let ie = (rt.Vp * (rt.utilities[Wt] - 1 + rt.gp) - Et) / rt.representations[Wt].bandwidth;
                        (isNaN(Ut) || ie >= Ut) && (Ut = ie, Dt = Wt);
                      }
                      return rt.representations[Dt];
                    }(bt, It + bt.placeholderBuffer);
                    const nt = M.getOptimalRepresentationForBitrate(Pt, N, !0);
                    dt.absoluteIndex > bt.currentRepresentation.absoluteIndex && dt.absoluteIndex > nt.absoluteIndex && (dt = nt.absoluteIndex > bt.currentRepresentation.absoluteIndex ? nt : bt.currentRepresentation);
                    let ft = Math.max(0, It + bt.placeholderBuffer - ot(bt, dt));
                    ft <= bt.placeholderBuffer ? (bt.placeholderBuffer -= ft, ft = 0) : (ft -= bt.placeholderBuffer, bt.placeholderBuffer = 0, M.isPlayingAtTopQuality(dt) ? ft = 0 : ct.setTimeToLoadDelay(1e3 * ft)), _t.representation = dt, _t.reason.throughput = N, _t.reason.bufferLevel = It, _t.reason.placeholderBuffer = bt.placeholderBuffer, _t.reason.delay = ft, bt.currentRepresentation = dt;
                  })(J, j, ht);
                  break;
                default:
                  (function(_t, Ct, bt) {
                    H.debug("BOLA ABR rule invoked in bad state.");
                    const Rt = Ct.getMediaInfo(), xt = Ct.getMediaType(), Pt = Ct.getThroughputController().getSafeAverageThroughput(xt);
                    _t.representation = M.getOptimalRepresentationForBitrate(Rt, Pt, !0), _t.reason.state = bt.state, _t.reason.throughput = Pt, bt.state = Td, R(bt);
                  })(J, j, ht);
              }
              return J;
            } catch (J) {
              return H.error(J), ca(f).create();
            }
          }, handleNewMediaInfo: function(j) {
            j && j.streamInfo && j.type && L[j.streamInfo.id] && L[j.streamInfo.id][j.type] && delete L[j.streamInfo.id][j.type];
          }, reset: function() {
            P(), v.off(At.A.BUFFER_EMPTY, W, Y), v.off(At.A.PLAYBACK_SEEKING, K, Y), v.off(At.A.METRIC_ADDED, G, Y), v.off(At.A.QUALITY_CHANGE_REQUESTED, et, Y), v.off(At.A.FRAGMENT_LOADING_ABANDONED, $, Y), v.off(at.A.MEDIA_FRAGMENT_LOADED, ut, Y), v.off(at.A.SETTING_UPDATED_MAX_BITRATE, mt, Y), v.off(at.A.SETTING_UPDATED_MIN_BITRATE, mt, Y);
          } }, H = (0, jt.A)(f).getInstance().getLogger(Y), P(), v.on(At.A.BUFFER_EMPTY, W, Y), v.on(At.A.PLAYBACK_SEEKING, K, Y), v.on(At.A.METRIC_ADDED, G, Y), v.on(At.A.QUALITY_CHANGE_REQUESTED, et, Y), v.on(At.A.FRAGMENT_LOADING_ABANDONED, $, Y), v.on(at.A.MEDIA_FRAGMENT_LOADED, ut, Y), v.on(at.A.SETTING_UPDATED_MAX_BITRATE, mt, Y), v.on(at.A.SETTING_UPDATED_MIN_BITRATE, mt, Y), Y;
        }
        Fp.__dashjs_factory_name = "BolaRule";
        var Op = Bt.A.getClassFactory(Fp);
        const kd = "L2A_STATE_ONE_BITRATE", Ld = "L2A_STATE_STARTUP", Up = "L2A_STATE_STEADY", Md = Math.pow(4, 0.99);
        function Kp(A) {
          A = A || {};
          const f = this.context, C = A.dashMetrics, _ = (0, Mt.A)(f).getInstance();
          let v, M, Y, H;
          function L(it) {
            it.placeholderBuffer = 0, it.mostAdvancedSegmentStart = NaN, it.lastSegmentWasReplacement = !1, it.lastSegmentStart = NaN, it.lastSegmentDurationS = NaN, it.lastSegmentRequestTimeMs = NaN, it.lastSegmentFinishTimeMs = NaN, it.lastSegmentUrl = "";
          }
          function W() {
            for (const it in M) if (M.hasOwnProperty(it)) {
              const st = M[it];
              st.state !== kd && (st.state = Ld, L(st));
            }
          }
          function K(it) {
            if (it && it.chunk && it.chunk.representation && it.chunk.representation.mediaInfo) {
              const st = M[it.chunk.representation.mediaInfo.type], ot = Y[it.chunk.representation.mediaInfo.type];
              if (st && st.state !== kd) {
                const ut = it.chunk.start;
                isNaN(st.mostAdvancedSegmentStart) || ut > st.mostAdvancedSegmentStart ? (st.mostAdvancedSegmentStart = ut, st.lastSegmentWasReplacement = !1) : st.lastSegmentWasReplacement = !0, st.lastSegmentStart = ut, st.lastSegmentDurationS = it.chunk.duration, st.currentRepresentation = it.chunk.representation, G(st, ot);
              }
            }
          }
          function R(it) {
            if (it && it.metric === yt.HTTP_REQUEST && it.value && it.value.type === Ht.G.MEDIA_SEGMENT_TYPE && it.value.trace && it.value.trace.length) {
              const st = M[it.mediaType], ot = Y[it.mediaType];
              st && st.state !== kd && (st.lastSegmentRequestTimeMs = it.value.trequest.getTime(), st.lastSegmentFinishTimeMs = it.value._tfinish.getTime(), G(st, ot));
            }
          }
          function G(it, st) {
            isNaN(it.lastSegmentStart) || isNaN(it.lastSegmentRequestTimeMs) || (st.segment_request_start_s = 1e-3 * it.lastSegmentRequestTimeMs, st.segment_download_finish_s = 1e-3 * it.lastSegmentFinishTimeMs, it.lastSegmentStart = NaN, it.lastSegmentRequestTimeMs = NaN);
          }
          function F(it, st) {
            if (it.length !== st.length) return -1;
            let ot = 0;
            for (let ut = 0; ut < it.length; ut++) ot += it[ut] * st[ut];
            return ot;
          }
          function et() {
            M = {}, Y = {};
          }
          return v = { getSwitchRequest: function(it) {
            try {
              const st = ca(f).create();
              st.rule = this.getClassName();
              const ot = it.getMediaType(), ut = it.getScheduleController();
              if (st.reason = st.reason || {}, ot === X.A.AUDIO) return st;
              ut.setTimeToLoadDelay(0);
              const mt = function(wt) {
                const $ = wt.getMediaType();
                let P = M[$];
                return P || (P = function(j) {
                  const J = {}, ht = j.getMediaInfo();
                  return J.state = Ld, J.currentRepresentation = null, function(_t) {
                    _t && _t.type && (Y[_t.type] = {}, Y[_t.type].w = [], Y[_t.type].prev_w = [], Y[_t.type].Q = 0, Y[_t.type].segment_request_start_s = 0, Y[_t.type].segment_download_finish_s = 0, Y[_t.type].B_target = 1.5);
                  }(ht), L(J), J;
                }(wt), M[$] = P), P;
              }(it);
              if (!Y[ot]) return st;
              switch (st.reason.state = mt.state, mt.state) {
                case kd:
                  break;
                case Ld:
                  (function(wt, $, P) {
                    const j = wt.getMediaInfo(), J = wt.getMediaType(), ht = wt.getThroughputController().getSafeAverageThroughput(J);
                    if (isNaN(ht)) return $;
                    const _t = wt.getAbrController(), Ct = _t.getOptimalRepresentationForBitrate(j, ht, !0), bt = C.getCurrentBufferLevel(J, !0), Rt = Y[J], xt = _t.getPossibleVoRepresentationsFilteredBySettings(j, !0);
                    if ($.representation = Ct, $.reason.throughput = ht, P.currentRepresentation = Ct, !isNaN(P.lastSegmentDurationS) && bt >= Rt.B_target) {
                      P.state = Up, Rt.Q = Md;
                      for (let Pt = 0; Pt < xt.length; ++Pt) xt[Pt].id === P.currentRepresentation.id ? Rt.prev_w[Pt] = 1 : Rt.prev_w[Pt] = 0;
                    }
                  })(it, st, mt);
                  break;
                case Up:
                  (function(wt, $, P) {
                    let j = [];
                    const J = wt.getThroughputController(), ht = wt.getMediaType();
                    let _t = J.getAverageThroughput(ht, X.A.THROUGHPUT_CALCULATION_MODES.ARITHMETIC_MEAN, 1), Ct = C.getCurrentHttpRequest(ht), bt = null;
                    const Rt = Y[ht];
                    if (_t < 1 && (_t = 1), Ct.url === P.lastSegmentUrl || Ct.type === Ht.G.INIT_SEGMENT_TYPE) bt = P.currentRepresentation;
                    else {
                      let xt = P.lastSegmentDurationS, Pt = 1;
                      const N = wt.getAbrController(), ct = wt.getMediaInfo(), It = N.getPossibleVoRepresentationsFilteredBySettings(ct, !0);
                      let dt = wt.getVideoModel().getPlaybackRate();
                      const nt = Math.max(Math.pow(4, 1), Md * Math.sqrt(4));
                      for (let kt = 0; kt < It.length; ++kt) {
                        const Dt = It[kt];
                        dt * Dt.bitrateInKbit > _t && (Pt = -1), Rt.w[kt] = Rt.prev_w[kt] + Pt * (xt / (2 * nt)) * ((Rt.Q + Md) * (dt * Dt.bitrateInKbit / _t));
                      }
                      Rt.w = function(kt) {
                        const Dt = kt.length;
                        let Ut = !1, Wt = [];
                        for (let nn = 0; nn < Dt; ++nn) Wt[nn] = kt[nn];
                        let ie = kt.sort(function(nn, _n) {
                          return _n - nn;
                        }), de = 0, Be = 0, Oe = [];
                        for (let nn = 0; nn < Dt - 1; ++nn) if (de += ie[nn], Be = (de - 1) / (nn + 1), Be >= ie[nn + 1]) {
                          Ut = !0;
                          break;
                        }
                        Ut || (Be = (de + ie[Dt - 1] - 1) / Dt);
                        for (let nn = 0; nn < Dt; ++nn) Oe[nn] = Math.max(Wt[nn] - Be, 0);
                        return Oe;
                      }(Rt.w);
                      for (let kt = 0; kt < It.length; ++kt) j[kt] = Rt.w[kt] - Rt.prev_w[kt], Rt.prev_w[kt] = Rt.w[kt];
                      const ft = It.map((kt) => kt.bandwidth);
                      Rt.Q = Math.max(0, Rt.Q - xt + xt * dt * ((F(ft, Rt.prev_w) + F(ft, j)) / _t));
                      let rt = [];
                      for (let kt = 0; kt < ft.length; ++kt) rt[kt] = Math.abs(ft[kt] - F(Rt.w, ft));
                      const Et = rt.indexOf(Math.min(...rt));
                      bt = N.getRepresentationByAbsoluteIndex(Et, ct, !0), bt.absoluteIndex > P.currentRepresentation.absoluteIndex && ft[P.currentRepresentation.absoluteIndex + 1] <= _t && (bt = N.getRepresentationByAbsoluteIndex(P.currentRepresentation.absoluteIndex + 1, ct, !0)), bt.bitrateInKbit >= _t && (Rt.Q = 2 * Math.max(Md, Rt.Q)), P.lastSegmentUrl = Ct.url;
                    }
                    $.representation = bt, P.currentRepresentation = $.representation;
                  })(it, st, mt);
                  break;
                default:
                  (function(wt, $, P) {
                    const j = wt.getAbrController(), J = wt.getMediaInfo(), ht = wt.getMediaType(), _t = wt.getThroughputController().getSafeAverageThroughput(ht);
                    $.representation = j.getOptimalRepresentationForBitrate(J, _t, !0), $.reason.throughput = _t, P.state = Ld, L(P);
                  })(it, st, mt);
              }
              return st;
            } catch (st) {
              return H.error(st), ca(f).create();
            }
          }, reset: function() {
            et(), _.off(at.A.PLAYBACK_SEEKING, W, v), _.off(at.A.MEDIA_FRAGMENT_LOADED, K, v), _.off(at.A.METRIC_ADDED, R, v);
          } }, H = (0, jt.A)(f).getInstance().getLogger(v), et(), _.on(at.A.PLAYBACK_SEEKING, W, v), _.on(at.A.MEDIA_FRAGMENT_LOADED, K, v), _.on(at.A.METRIC_ADDED, R, v), v;
        }
        Kp.__dashjs_factory_name = "L2ARule";
        var kS = Bt.A.getClassFactory(Kp);
        function Vp() {
          const A = this.context;
          let f, C, _, v, M, Y, H, L, W;
          function K() {
            _ = null, v = 1, M = 100, Y = 0, H = null, L = null, W = "dynamic_weight_selection";
          }
          function R() {
            let st = 0;
            if (_) for (let ot = 0; ot < _.length; ot++) {
              let ut = _[ot];
              ut.state.throughput > st && (st = ut.state.throughput);
            }
            return st;
          }
          function G(st, ot, ut) {
            let mt = st.map((wt, $) => ut[$] * Math.pow(wt - ot[$], 2)).reduce((wt, $) => wt + $);
            return (mt < 0 ? -1 : 1) * Math.sqrt(Math.abs(mt));
          }
          function F(st, ot) {
            return G([st.state.throughput, st.state.latency, st.state.rebuffer, st.state.switch], [ot.state.throughput, ot.state.latency, ot.state.rebuffer, ot.state.switch], [1, 1, 1, 1]);
          }
          function et(st, ot) {
            for (let ut = 0; ut < _.length; ut++) {
              let mt = _[ut], wt = 0.1;
              const $ = F(mt, st);
              it(mt, ot, Math.exp(-1 * Math.pow($, 2) / (2 * Math.pow(wt, 2))));
            }
          }
          function it(st, ot, ut) {
            let mt = st.state, wt = [0.01, 0.01, 0.01, 0.01];
            mt.throughput = mt.throughput + (ot[0] - mt.throughput) * wt[0] * ut, mt.latency = mt.latency + (ot[1] - mt.latency) * wt[1] * ut, mt.rebuffer = mt.rebuffer + (ot[2] - mt.rebuffer) * wt[2] * ut, mt.switch = mt.switch + (ot[3] - mt.switch) * wt[3] * ut;
          }
          return f = { getNextQuality: function(st, ot, ut, mt, wt, $, P, j) {
            let J = mt, ht = ut;
            (function(It, dt) {
              if (!_) {
                _ = [];
                const nt = dt.getPossibleVoRepresentationsFilteredBySettings(It, !0), ft = nt.map((rt) => rt.bandwidth);
                Y = Math.min(...ft), v = function(rt) {
                  const Et = rt.map((kt) => Math.pow(kt, 2)).reduce((kt, Dt) => kt + Dt);
                  return Math.sqrt(Et);
                }(ft), nt.forEach((rt) => {
                  let Et = { representation: rt, state: { throughput: rt.bandwidth / v, latency: 0, rebuffer: 0, switch: 0 } };
                  _.push(Et);
                }), L = function(rt) {
                  let Et = [], kt = function(de) {
                    let Be = [];
                    for (let Oe = 0; Oe < de; Oe++) {
                      let nn = [Math.random() * R(), Math.random(), Math.random(), Math.random()];
                      Be.push(nn);
                    }
                    return Be;
                  }(Math.pow(rt.length, 2));
                  Et.push(kt[0]);
                  let Dt = [1, 1, 1, 1];
                  for (let de = 1; de < rt.length; de++) {
                    let Be = null, Oe = null;
                    for (let nn = 0; nn < kt.length; nn++) {
                      let _n = kt[nn], ke = null;
                      for (let rn = 0; rn < Et.length; rn++) {
                        let Cn = G(_n, Et[rn], Dt);
                        (ke === null || Cn < ke) && (ke = Cn);
                      }
                      (Oe === null || ke > Oe) && (Be = _n, Oe = ke);
                    }
                    Et.push(Be);
                  }
                  let Ut = null, Wt = null;
                  for (let de = 0; de < Et.length; de++) {
                    let Be = 0;
                    for (let Oe = 0; Oe < Et.length; Oe++) de !== Oe && (Be += G(Et[de], Et[Oe], Dt));
                    (Ut === null || Be > Ut) && (Ut = Be, Wt = de);
                  }
                  let ie = [];
                  for (ie.push(Et[Wt]), Et.splice(Wt, 1); Et.length > 0; ) {
                    let de = null, Be = null;
                    for (let Oe = 0; Oe < Et.length; Oe++) {
                      let nn = G(ie[0], Et[Oe], Dt);
                      (de === null || nn < de) && (de = nn, Be = Oe);
                    }
                    ie.push(Et[Be]), Et.splice(Be, 1);
                  }
                  return ie;
                }(_);
              }
            })(ot, st);
            let _t = ut / v;
            _t > 1 && (_t = R()), mt /= M;
            let Ct = _.find((It) => It.representation.id === P.id), bt = Ct.representation.bandwidth * j.getSegmentDuration() / ht, Rt = Math.max(0, bt - wt);
            if (wt - bt < j.getMinBuffer()) return C.debug(`Buffer is low for bitrate= ${Ct.representation.bandwidth} downloadTime=${bt} currentBuffer=${wt} rebuffer=${Rt}`), function(It, dt) {
              let nt = 0, ft = It;
              if (_) for (let rt = 0; rt < _.length; rt++) {
                let Et = _[rt];
                Et.representation.bandwidth < It.representation.bandwidth && Et.representation.bandwidth > nt && dt > Et.representation.bandwidth && (nt = Et.representation.bandwidth, ft = Et);
              }
              return ft;
            }(Ct, ht).representation;
            switch (W) {
              case "manual_weight_selection":
                H = [0.4, 0.4, 0.4, 0.4];
                break;
              case "random_weight_selection":
                H = function(It) {
                  let dt = [], nt = Math.sqrt(2 / It);
                  for (let ft = 0; ft < 4; ft++) dt.push(Math.random() * nt);
                  return H = dt, H;
                }(_.length);
                break;
              default:
                (function(It, dt, nt, ft, rt, Et) {
                  H || (H = L[L.length - 1]);
                  let kt = It.findWeightVector(_, dt, nt, ft, rt, Et);
                  kt !== null && kt !== -1 && (H = kt);
                })(j, J, wt, Rt, ht, $);
            }
            let xt = null, Pt = null, N = null;
            for (let It = 0; It < _.length; It++) {
              let dt = _[It], nt = dt.state, ft = [nt.throughput, nt.latency, nt.rebuffer, nt.switch], rt = H.slice(), Et = j.getNextBufferWithBitrate(dt.representation.bandwidth, wt, ht), kt = Et < j.getMinBuffer();
              kt && C.debug(`Buffer is low for bitrate=${dt.representation.bandwidth} downloadTime=${bt} currentBuffer=${wt} nextBuffer=${Et}`), (dt.representation.bandwidth > ut - 1e4 || kt) && dt.representation.bandwidth !== Y && (rt[0] = 100);
              let Dt = G(ft, [_t, 0, 0, 0], rt);
              (xt === null || Dt < xt) && (xt = Dt, Pt = dt.representation, N = dt);
            }
            let ct = Math.abs(Ct.representation.bandwidth - N.representation.bandwidth) / v;
            return et(Ct, [_t, mt, Rt, ct]), et(N, [_t, 0, 0, ct]), Pt;
          }, reset: function() {
            K();
          } }, C = (0, jt.A)(A).getInstance().getLogger(f), K(), f;
        }
        Vp.__dashjs_factory_name = "LearningAbrController";
        var LS = Bt.A.getClassFactory(Vp), MS = class {
          constructor() {
            this.type = null, this.lastBitrate = null, this.weights = {}, this.weights.bitrateReward = null, this.weights.bitrateSwitchPenalty = null, this.weights.rebufferPenalty = null, this.weights.latencyPenalty = null, this.weights.playbackSpeedPenalty = null, this.bitrateWSum = 0, this.bitrateSwitchWSum = 0, this.rebufferWSum = 0, this.latencyWSum = 0, this.playbackSpeedWSum = 0, this.totalQoe = 0;
          }
        };
        function Xp() {
          let A, f, C, _, v;
          function M() {
            f = null, C = null, _ = null, v = null;
          }
          function Y(L, W, K, R) {
            let G = new MS();
            return G.type = L, G.weights.bitrateReward = W || 1, G.weights.bitrateSwitchPenalty = 1, G.weights.rebufferPenalty = K || 1e3, G.weights.latencyPenalty = [], G.weights.latencyPenalty.push({ threshold: 1.1, penalty: 0.05 * R }), G.weights.latencyPenalty.push({ threshold: 1e8, penalty: 0.1 * K }), G.weights.playbackSpeedPenalty = R || 200, G;
          }
          function H(L, W, K, R, G) {
            G.bitrateWSum += G.weights.bitrateReward * L, G.lastBitrate && (G.bitrateSwitchWSum += G.weights.bitrateSwitchPenalty * Math.abs(L - G.lastBitrate)), G.lastBitrate = L, G.rebufferWSum += G.weights.rebufferPenalty * W;
            for (let F = 0; F < G.weights.latencyPenalty.length; F++) {
              let et = G.weights.latencyPenalty[F];
              if (K <= et.threshold) {
                G.latencyWSum += et.penalty * K;
                break;
              }
            }
            G.playbackSpeedWSum += G.weights.playbackSpeedPenalty * Math.abs(1 - R), G.totalQoe = G.bitrateWSum - G.bitrateSwitchWSum - G.rebufferWSum - G.latencyWSum - G.playbackSpeedWSum;
          }
          return A = { setupPerSegmentQoe: function(L, W, K) {
            f = Y("segment", L, W, K), C = L, _ = W, v = K;
          }, logSegmentMetrics: function(L, W, K, R) {
            f && H(L, W, K, R, f);
          }, getPerSegmentQoe: function() {
            return f;
          }, calculateSingleUseQoe: function(L, W, K, R) {
            let G = null;
            return C && _ && v && (G = Y("segment", C, _, v)), G ? (H(L, W, K, R, G), G.totalQoe) : 0;
          }, reset: function() {
            M();
          } }, M(), A;
        }
        Xp.__dashjs_factory_name = "LoLpQoeEvaluator";
        var RS = Bt.A.getClassFactory(Xp);
        function Wp(A) {
          let f, C, _, v, M = A.targetLatency, Y = A.bufferMin, H = A.segmentDuration, L = A.qoeEvaluator;
          function W() {
            return H;
          }
          function K(R, G) {
            const F = W();
            let et;
            return et = G > F ? R - F : R + F - G, et;
          }
          return f = { getMinBuffer: function() {
            return Y;
          }, getSegmentDuration: W, getNextBufferWithBitrate: function(R, G, F) {
            return K(G, R * H / F);
          }, getNextBuffer: K, findWeightVector: function(R, G, F, et, it, st) {
            let ot = null, ut = null, mt = null, wt = Math.abs(G - v);
            return R.forEach(($) => {
              _.forEach((P) => {
                P[0];
                let j, J = P[1], ht = P[2], _t = (P[3], $.representation.bandwidth * H / it), Ct = K(F, _t);
                j = ht === 0 ? 10 : 1 / ht;
                let bt = j * Math.max(1e-5, _t - Ct);
                j = J === 0 ? 10 : 1 / J;
                let Rt = j * $.state.latency, xt = L.calculateSingleUseQoe($.representation.bandwidth, bt, Rt, st);
                (ot === null || xt > ot) && function(Pt, N, ct) {
                  return !(Pt > M + ct) && N >= Y;
                }(G, Ct, wt) && (ot = xt, ut = P, mt = $.representation.bandwidth);
              });
            }), ut === null && mt === null && (ut = -1), v = G, ut;
          } }, C = [0.2, 0.4, 0.6, 0.8, 1], _ = function(R) {
            let G = R.map(function(et) {
              return [et];
            }), F = function(et, it, st) {
              if (st === it) return et;
              let ot = et.length;
              for (let ut = 0; ut < ot; ut++) {
                let mt = et.shift();
                for (let wt = 0; wt < R.length; wt++) et.push(mt.concat(R[wt]));
              }
              return F(et, it, st + 1);
            };
            return F(G, 4, 1);
          }(C), v = 0, f;
        }
        Wp.__dashjs_factory_name = "LoLpWeightSelector";
        var DS = Bt.A.getClassFactory(Wp);
        function jp(A) {
          let f, C, _, v, M = (A = A || {}).dashMetrics, Y = this.context;
          return C = { getSwitchRequest: function(H) {
            try {
              let L = ca(Y).create();
              L.rule = this.getClassName();
              let W = H.getMediaInfo().type, K = H.getAbrController();
              const R = H.getStreamInfo();
              let G = H.getRepresentation();
              const F = H.getMediaInfo(), et = M.getCurrentBufferState(W), it = H.getScheduleController(), st = M.getCurrentBufferLevel(W, !0), ot = it.getPlaybackController();
              let ut = ot.getCurrentLiveLatency();
              if (W === X.A.AUDIO) return L;
              ut || (ut = 0);
              const mt = ot.getPlaybackRate(), wt = H.getThroughputController().getSafeAverageThroughput(W);
              if (f.debug(`Throughput ${Math.round(wt)} kbps`), isNaN(wt) || !et || K.getAbandonmentStateFor(R.id, W) === yt.ABANDON_LOAD) return L;
              let $ = K.getPossibleVoRepresentationsFilteredBySettings(F, !0).map((xt) => xt.bandwidth), P = H.getRepresentation().fragmentDuration, j = Math.min(...$) / 1e3, J = Math.max(...$) / 1e3, ht = G.bandwidth / 1e3, _t = M.getCurrentHttpRequest(W, !0), Ct = (_t.tresponse.getTime() - _t.trequest.getTime()) / 1e3, bt = Ct > P ? Ct - P : 0;
              v.setupPerSegmentQoe(P, J, j), v.logSegmentMetrics(ht, bt, ut, mt);
              let Rt = DS(Y).create({ targetLatency: 1.5, bufferMin: 0.3, segmentDuration: P, qoeEvaluator: v });
              return L.representation = _.getNextQuality(K, F, 1e3 * wt, ut, st, mt, G, Rt), L.reason = { throughput: wt, latency: ut }, L.priority = ca.PRIORITY.STRONG, it.setTimeToLoadDelay(0), L;
            } catch (L) {
              throw L;
            }
          }, reset: function() {
            _.reset(), v.reset();
          } }, f = (0, jt.A)(Y).getInstance().getLogger(C), _ = LS(Y).create(), v = RS(Y).create(), C;
        }
        jp.__dashjs_factory_name = "LoLPRule";
        var BS = Bt.A.getClassFactory(jp);
        function Dc(A) {
          A = A || {};
          const f = this.context, C = A.mediaPlayerModel, _ = A.customParametersModel, v = A.dashMetrics, M = A.settings, Y = (0, Mt.A)(f).getInstance();
          let H, L, W, K;
          function R() {
            Object.values(X.A.QUALITY_SWITCH_RULES).forEach((st) => {
              L = G(st, L);
            }), Object.values(X.A.ABANDON_FRAGMENT_RULES).forEach((st) => {
              W = G(st, W);
            }), _.getAbrCustomRules().forEach(function(st) {
              st.type === X.A.RULES_TYPES.QUALITY_SWITCH_RULES && L.push(st.rule(f).create()), st.type === X.A.RULES_TYPES.ABANDON_FRAGMENT_RULES && W.push(st.rule(f).create());
            }), L.length === 0 && (L.push(Op(f).create({ dashMetrics: v, mediaPlayerModel: C, settings: M })), L.push(Gp(f).create({ dashMetrics: v })));
          }
          function G(st, ot) {
            const ut = st.charAt(0).toLowerCase() + st.slice(1);
            return M.get().streaming.abr.rules[ut].active && !function(mt, wt) {
              return mt.filter(($) => $.getClassName() === wt).length > 0;
            }(ot, st) ? (ot.push(function(mt) {
              switch (mt) {
                case X.A.QUALITY_SWITCH_RULES.BOLA_RULE:
                  return Op(f).create({ dashMetrics: v, mediaPlayerModel: C, settings: M });
                case X.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE:
                  return Gp(f).create({ dashMetrics: v });
                case X.A.QUALITY_SWITCH_RULES.INSUFFICIENT_BUFFER_RULE:
                  return wS(f).create({ dashMetrics: v, settings: M });
                case X.A.QUALITY_SWITCH_RULES.SWITCH_HISTORY_RULE:
                  return TS(f).create();
                case X.A.QUALITY_SWITCH_RULES.DROPPED_FRAMES_RULE:
                  return ES(f).create();
                case X.A.QUALITY_SWITCH_RULES.LEARN_TO_ADAPT_RULE:
                  return kS(f).create({ dashMetrics: v, settings: M });
                case X.A.QUALITY_SWITCH_RULES.LOL_PLUS_RULE:
                  return BS(f).create({ dashMetrics: v });
                case X.A.ABANDON_FRAGMENT_RULES.ABANDON_REQUEST_RULE:
                  return vS(f).create({ dashMetrics: v, mediaPlayerModel: C, settings: M });
              }
            }(st)), ot) : M.get().streaming.abr.rules[ut].active ? ot : function(mt, wt) {
              return mt.filter(($) => $.getClassName() !== wt);
            }(ot, st);
          }
          function F(st) {
            return st.filter((ot) => ot.representation !== ca.NO_CHANGE);
          }
          function et(st) {
            const ot = {};
            let ut, mt, wt, $ = null;
            if (st.length !== 0) {
              for (ot[ca.PRIORITY.STRONG] = null, ot[ca.PRIORITY.WEAK] = null, ot[ca.PRIORITY.DEFAULT] = null, ut = 0, mt = st.length; ut < mt; ut += 1) wt = st[ut], wt.representation !== ca.NO_CHANGE && (ot[wt.priority] === null || ot[wt.priority].representation !== ca.NO_CHANGE && wt.representation.bitrateInKbit < ot[wt.priority].representation.bitrateInKbit) && (ot[wt.priority] = wt);
              return ot[ca.PRIORITY.WEAK] && ot[ca.PRIORITY.WEAK].representation !== ca.NO_CHANGE && ($ = ot[ca.PRIORITY.WEAK]), ot[ca.PRIORITY.DEFAULT] && ot[ca.PRIORITY.DEFAULT].representation !== ca.NO_CHANGE && ($ = ot[ca.PRIORITY.DEFAULT]), ot[ca.PRIORITY.STRONG] && ot[ca.PRIORITY.STRONG].representation !== ca.NO_CHANGE && ($ = ot[ca.PRIORITY.STRONG]), $;
            }
          }
          function it() {
            R();
          }
          return H = { clearDataForStream: function(st) {
            [L, W].forEach((ot) => {
              ot && ot.length && ot.forEach((ut) => ut.clearDataForStream && typeof ut.clearDataForStream == "function" && ut.clearDataForStream(st));
            });
          }, getAbandonFragmentRules: function() {
            return W;
          }, getBestPossibleSwitchRequest: function(st) {
            return st && et(F(L.filter((ot) => {
              const ut = ot.getClassName();
              if (ut !== X.A.QUALITY_SWITCH_RULES.BOLA_RULE && ut !== X.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE) return !0;
              const mt = st.getMediaType();
              return K[mt] && ut === X.A.QUALITY_SWITCH_RULES.BOLA_RULE || !K[mt] && ut === X.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE;
            }).map((ot) => ot.getSwitchRequest(st)))) || ca(f).create();
          }, getBolaState: function(st) {
            return K[st];
          }, getMinSwitchRequest: et, getQualitySwitchRules: function() {
            return L;
          }, handleNewMediaInfo: function(st) {
            L.forEach((ot) => ot.handleNewMediaInfo && ot.handleNewMediaInfo(st)), W.forEach((ot) => ot.handleNewMediaInfo && ot.handleNewMediaInfo(st));
          }, initialize: function() {
            L = [], W = [], K = {}, R(), Y.on(at.A.SETTING_UPDATED_ABR_ACTIVE_RULES, it, H);
          }, reset: function() {
            [L, W].forEach((st) => {
              st && st.length && st.forEach((ot) => ot.reset && ot.reset());
            }), L = [], W = [], K = {}, Y.off(at.A.SETTING_UPDATED_ABR_ACTIVE_RULES, it, H);
          }, setBolaState: function(st, ot) {
            K[st] = ot;
          }, shouldAbandonFragment: function(st) {
            if (!st) return ca(f).create();
            const ot = et(F(W.map((ut) => ut.shouldAbandon(st))));
            return ot && (ot.reason.forceAbandon = !0), ot || ca(f).create();
          } }, H;
        }
        Dc.__dashjs_factory_name = "ABRRulesCollection";
        const Zp = Bt.A.getClassFactory(Dc);
        Bt.A.updateSingletonFactory(Dc.__dashjs_factory_name, Zp);
        var xS = Zp;
        function Jp(A) {
          let f;
          const C = (A = A || {}).abrController, _ = A.throughputController, v = A.switchRequestHistory, M = A.droppedFramesHistory, Y = A.currentRequest, H = A.streamProcessor ? A.streamProcessor.getScheduleController() : null, L = A.streamProcessor ? A.streamProcessor.getRepresentation() : null, W = A.videoModel ? A.videoModel : null;
          function K() {
            return L ? L.mediaInfo : null;
          }
          return f = { getAbrController: function() {
            return C;
          }, getCurrentRequest: function() {
            return Y;
          }, getDroppedFramesHistory: function() {
            return M;
          }, getMediaInfo: K, getMediaType: function() {
            const R = K();
            return R ? R.type : null;
          }, getRepresentation: function() {
            return L;
          }, getScheduleController: function() {
            return H;
          }, getStreamInfo: function() {
            const R = K();
            return R ? R.streamInfo : null;
          }, getSwitchRequestHistory: function() {
            return v;
          }, getThroughputController: function() {
            return _;
          }, getVideoModel: function() {
            return W;
          } }, f;
        }
        Jp.__dashjs_factory_name = "RulesContext";
        var Qp = Bt.A.getClassFactory(Jp);
        function qp() {
          let A = {}, f = {};
          const C = this.context, _ = (0, tt.A)(C).getInstance();
          return { clearForStream: function(v) {
            delete A[v], delete f[v];
          }, getSwitchRequests: function(v, M) {
            return v != null && M != null && A[v] && A[v][M] ? A[v][M] : {};
          }, push: function(v) {
            const M = v.currentRepresentation, Y = v.newRepresentation;
            if (M.mediaInfo.streamInfo.id !== Y.mediaInfo.streamInfo.id || Y.mediaInfo.id !== M.mediaInfo.id) return;
            const H = M.mediaInfo.streamInfo.id;
            A[H] || function(it) {
              A[it] = {}, f[it] = {};
            }(H);
            const L = M.mediaInfo.type;
            A[H][L] || function(it, st) {
              A[it][st] = {}, f[it][st] = [];
            }(H, L);
            const W = v.currentRepresentation.id;
            A[H][L][W] || function(it, st, ot) {
              A[it][st][ot] = { noDrops: 0, drops: 0, dropSize: 0 };
            }(H, L, W);
            let K = v.newRepresentation.absoluteIndex - v.currentRepresentation.absoluteIndex, R = K < 0 ? 1 : 0, G = R ? -K : 0, F = R ? 0 : 1;
            A[H][L][v.currentRepresentation.id].drops += R, A[H][L][v.currentRepresentation.id].dropSize += G, A[H][L][v.currentRepresentation.id].noDrops += F, f[H][L].push({ id: v.currentRepresentation.id, noDrop: F, drop: R, dropSize: G });
            const et = function(it, st) {
              return f[it][st].length > _.get().streaming.abr.rules.switchHistoryRule.parameters.sampleSize ? f[it][st].shift() : null;
            }(H, L);
            et && function(it, st, ot) {
              A[it][st][ot.id].drops -= ot.drop, A[it][st][ot.id].dropSize -= ot.dropSize, A[it][st][ot.id].noDrops -= ot.noDrop;
            }(H, L, et);
          }, reset: function() {
            A = {}, f = {};
          } };
        }
        qp.__dashjs_factory_name = "SwitchRequestHistory";
        var NS = Bt.A.getClassFactory(qp);
        function $p() {
          let A = {}, f = {}, C = {};
          return { clearForStream: function(_) {
            delete A[_], delete f[_], delete C[_];
          }, getFrameHistory: function(_) {
            return A[_];
          }, push: function(_, v, M) {
            if (!v) return;
            A[_] || function(R) {
              A[R] = [], f[R] = 0, C[R] = 0;
            }(_);
            let Y = M && M.droppedVideoFrames ? M.droppedVideoFrames : 0, H = M && M.totalVideoFrames ? M.totalVideoFrames : 0, L = Y - f[_];
            f[_] = Y;
            let W = H - C[_];
            C[_] = H;
            const K = A[_];
            K[v] ? (K[v].droppedVideoFrames += L, K[v].totalVideoFrames += W) : K[v] = { droppedVideoFrames: L, totalVideoFrames: W };
          }, reset: function() {
            A = {}, f = {}, C = {};
          } };
        }
        $p.__dashjs_factory_name = "DroppedFramesHistory";
        var GS = Bt.A.getClassFactory($p);
        function Bc() {
          const A = this.context, f = (0, jt.A)(A).getInstance(), C = (0, Mt.A)(A).getInstance();
          let _, v, M, Y, H, L, W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P;
          function j() {
            W = {}, L = {}, mt && mt.reset(), ut && ut.reset(), ot = void 0, mt = void 0, ut = void 0, clearTimeout(K), K = null;
          }
          function J(N) {
            let ct = ht(N, !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]);
            return ct = function(It) {
              try {
                return function(dt) {
                  try {
                    if (!P.get().streaming.cmsd.enabled || !P.get().streaming.cmsd.abr.applyMb) return dt;
                    const nt = dt.filter((ft) => {
                      const rt = ft.mediaInfo.type;
                      let Et = it.getMaxBitrate(rt);
                      if (rt !== X.A.VIDEO || Et < 0) return !0;
                      const kt = ft.mediaInfo.streamInfo.id;
                      return Et -= L[kt][X.A.AUDIO].getRepresentation().bitrateInKbit || 0, ft.bitrateInKbit <= Et;
                    });
                    return nt.length > 0 ? nt : dt;
                  } catch (nt) {
                    return v.error(nt), dt;
                  }
                }(It = function(dt) {
                  try {
                    if (!P.get().streaming.abr.limitBitrateByPortal) return dt;
                    const { elementWidth: nt } = G.getVideoElementSize(), ft = dt.filter((rt) => rt.mediaInfo.type !== X.A.VIDEO || rt.width <= nt);
                    return ft.length > 0 ? ft : dt;
                  } catch (nt) {
                    return v.error(nt), dt;
                  }
                }(It = function(dt) {
                  try {
                    const nt = dt.filter((ft) => {
                      const rt = ft.mediaInfo.type, Et = ft.bitrateInKbit, kt = F.getAbrBitrateParameter("maxBitrate", rt), Dt = F.getAbrBitrateParameter("minBitrate", rt);
                      return !(kt > -1 && Et > kt || Dt > -1 && Et < Dt);
                    });
                    return nt.length > 0 ? nt : dt;
                  } catch (nt) {
                    return v.error(nt), dt;
                  }
                }(It)));
              } catch (dt) {
                return v.error(dt), It;
              }
            }(ct), ct;
          }
          function ht(N, ct) {
            let It = [];
            return N && (function(nt) {
              try {
                const ft = [];
                if (nt && ft.push(nt), !P.get().streaming.abr.enableSupplementalPropertyAdaptationSetSwitching || !nt.adaptationSetSwitchingCompatibleIds || nt.adaptationSetSwitchingCompatibleIds.length === 0) return ft;
                const rt = L[nt.streamInfo.id][nt.type].getAllMediaInfos().filter((Et) => nt.adaptationSetSwitchingCompatibleIds.includes(Et.id));
                return ft.concat(rt);
              } catch (ft) {
                return [nt];
              }
            }(N).forEach((nt) => {
              let ft = R.getVoRepresentations(nt);
              ft && ft.length > 0 && (It = It.concat(ft));
            }), It = function(nt) {
              return nt = function(ft) {
                let rt = null;
                return ft.filter((Et) => (rt || (rt = Et.mediaInfo), !isNaN(Et.qualityRanking) && R.areMediaInfosEqual(rt, Et.mediaInfo))).length === ft.length;
              }(nt) ? function(ft) {
                return ft.sort((rt, Et) => Et.qualityRanking - rt.qualityRanking), ft;
              }(nt) : function(ft) {
                return ft.sort((rt, Et) => R.areMediaInfosEqual(rt.mediaInfo, Et.mediaInfo) ? isNaN(rt.pixelsPerSecond) || isNaN(Et.pixelsPerSecond) || rt.pixelsPerSecond === Et.pixelsPerSecond ? rt.bandwidth - Et.bandwidth : rt.pixelsPerSecond - Et.pixelsPerSecond : isNaN(rt.pixelsPerSecond) || isNaN(Et.pixelsPerSecond) || rt.pixelsPerSecond === Et.pixelsPerSecond ? isNaN(rt.bitsPerPixel) || isNaN(Et.bitsPerPixel) ? rt.bandwidth - Et.bandwidth : Et.bitsPerPixel - rt.bitsPerPixel : rt.pixelsPerSecond - Et.pixelsPerSecond), ft;
              }(nt);
            }(It), It.forEach((nt, ft) => {
              nt.absoluteIndex = ft;
            }), It = It.filter((nt) => {
              const ft = !!ct || R.areMediaInfosEqual(nt.mediaInfo, N), rt = !nt || !nt.mediaInfo || H.areKeyIdsUsable(nt.mediaInfo);
              return ft && rt;
            })), It;
          }
          function _t(N) {
            const ct = N.request.mediaType, It = N.streamId;
            if (!(ct && It && L[It] && P.get().streaming.abr.autoSwitchBitrate[ct])) return;
            const dt = L[It][ct];
            if (!dt) return;
            const nt = Qp(A).create({ abrController: _, streamProcessor: dt, currentRequest: N.request, throughputController: wt, adapter: R, videoModel: G }), ft = M.shouldAbandonFragment(nt);
            ft && ft.representation !== ca.NO_CHANGE && function(rt, Et, kt, Dt, Ut) {
              if (Dt.getFragmentModel().getRequests({ state: Tn.FRAGMENT_MODEL_LOADING, index: rt.request.index })[0]) {
                const Wt = function(ie, de) {
                  return W[ie] && W[ie][de] ? W[ie][de] : null;
                }(Et, kt);
                Wt && (Wt.state = yt.ABANDON_LOAD), ut.reset(), Rt(kt, Y.getActiveStreamInfo(), Ut.representation, Ut.reason), clearTimeout(K), K = setTimeout(() => {
                  Wt && (W[Et][kt].state = yt.ALLOW_LOAD), K = null;
                }, P.get().streaming.abandonLoadTimeout);
              }
            }(N, It, ct, dt, ft);
          }
          function Ct(N) {
            N.mediaType === X.A.VIDEO && (ot !== void 0 && mt.push(N.streamId, ot, G.getPlaybackQuality()), ot = N.newRepresentation.id);
          }
          function bt(N) {
            !Pt() || N.metric !== yt.BUFFER_LEVEL || N.mediaType !== X.A.AUDIO && N.mediaType !== X.A.VIDEO && N.mediaType !== X.A.MESH || function(ct, It) {
              try {
                const dt = F.getBufferTimeDefault(), nt = dt, ft = 0.5 * dt, rt = M.getBolaState(ct), Et = It >= (rt ? ft : nt);
                M.setBolaState(ct, Et), Et !== rt && (Et ? v.info("[" + ct + "] switching from throughput to buffer occupancy ABR rule (buffer: " + It.toFixed(3) + ").") : v.info("[" + ct + "] switching from buffer occupancy to throughput ABR rule (buffer: " + It.toFixed(3) + ")."));
              } catch (dt) {
                v.error(dt);
              }
            }(N.mediaType, 1e-3 * N.value.level);
          }
          function Rt(N, ct, It) {
            let dt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!(ct && ct.id && N && L && L[ct.id] && L[ct.id][N] && It)) return;
            const nt = L[ct.id][N].getRepresentation();
            nt && It.id === nt.id || xt(nt, It, dt);
          }
          function xt(N, ct, It) {
            const dt = ct.mediaInfo.streamInfo.id, nt = ct.mediaInfo.type;
            if (nt && L[dt] && L[dt][nt]) {
              const ft = L[dt][nt].getStreamInfo(), rt = $.getCurrentBufferLevel(nt), Et = N !== null && !R.areMediaInfosEqual(N.mediaInfo, ct.mediaInfo), kt = N ? N.bitrateInKbit : 0;
              v.info(`[AbrController]: Switching quality in period ${dt} for media type ${nt}. Switch from bitrate ${kt} to bitrate ${ct.bitrateInKbit}. Current buffer level: ${rt}. Reason:` + (It ? JSON.stringify(It) : "/")), C.trigger(at.A.QUALITY_CHANGE_REQUESTED, { oldRepresentation: N, newRepresentation: ct, reason: It, streamInfo: ft, mediaType: nt, isAdaptationSetSwitch: Et }, { streamId: ft.id, mediaType: nt });
              const Dt = wt.getAverageThroughput(nt);
              isNaN(Dt) || st.setSavedBitrateSettings(nt, Dt);
            }
          }
          function Pt() {
            return P.get().streaming.abr.rules.bolaRule.active && P.get().streaming.abr.rules.throughputRule.active;
          }
          return _ = { checkPlaybackQuality: function(N, ct) {
            try {
              if (!(N && L && L[ct] && L[ct][N])) return !1;
              if (mt) {
                const Et = G.getPlaybackQuality();
                Et && mt.push(ct, ot, Et);
              }
              if (!P.get().streaming.abr.autoSwitchBitrate[N]) return !1;
              const It = L[ct][N], dt = It.getRepresentation(), nt = Qp(A).create({ abrController: _, throughputController: wt, switchRequestHistory: ut, droppedFramesHistory: mt, streamProcessor: It, adapter: R, videoModel: G }), ft = M.getBestPossibleSwitchRequest(nt);
              if (!ft || !ft.representation) return !1;
              let rt = ft.representation;
              return ut.push({ currentRepresentation: dt, newRepresentation: rt }), rt.id !== dt.id && (W[ct][N].state === yt.ALLOW_LOAD || rt.absoluteIndex < dt.absoluteIndex) && (xt(dt, rt, ft.reason), !0);
            } catch (It) {
              return v.error(It), !1;
            }
          }, clearDataForStream: function(N) {
            mt && mt.clearForStream(N), L[N] && delete L[N], ut && ut.clearForStream(N), W[N] && delete W[N], M.clearDataForStream(N);
          }, getAbandonmentStateFor: function(N, ct) {
            return W[N] && W[N][ct] ? W[N][ct].state : null;
          }, getInitialBitrateFor: function(N) {
            if (N === X.A.TEXT) return NaN;
            let ct = F.getAbrBitrateParameter("initialBitrate", N);
            if (ct > 0) return ct;
            let It = NaN;
            if (st && st.hasOwnProperty("getSavedBitrateSettings") && (It = st.getSavedBitrateSettings(N)), !isNaN(It)) return It;
            const dt = wt.getAverageThroughput(N);
            return !isNaN(dt) && dt > 0 ? dt : N === X.A.VIDEO ? 1e3 : 100;
          }, getOptimalRepresentationForBitrate: function(N, ct) {
            const It = J(N, !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2]);
            if (!It || It.length === 0) return null;
            const dt = It.reduce((ft, rt) => ft.bandwidth < rt.bandwidth ? ft : rt);
            if (ct <= 0) return dt;
            const nt = It.filter((ft) => ft.bitrateInKbit <= ct);
            return nt && nt.length !== 0 ? nt.reduce((ft, rt) => rt.absoluteIndex > ft.absoluteIndex ? rt : ft) : dt;
          }, getPossibleVoRepresentations: function(N) {
            return ht(N, !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]);
          }, getPossibleVoRepresentationsFilteredBySettings: J, getRepresentationByAbsoluteIndex: function(N, ct) {
            let It = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
            return isNaN(N) || N < 0 ? null : J(ct, It).find((dt) => dt.absoluteIndex === N);
          }, handleNewMediaInfo: function(N) {
            M.handleNewMediaInfo(N);
          }, initialize: function() {
            mt = GS(A).create(), ut = NS(A).create(), M = xS(A).create({ dashMetrics: $, customParametersModel: et, mediaPlayerModel: F, settings: P }), M.initialize(), C.on(At.A.QUALITY_CHANGE_RENDERED, Ct, _), C.on(At.A.METRIC_ADDED, bt, _), C.on(at.A.LOADING_PROGRESS, _t, _);
          }, isPlayingAtLowestQuality: function(N) {
            return J(N.mediaInfo, !0)[0].id === N.id;
          }, isPlayingAtTopQuality: function(N) {
            if (!N) return !0;
            const ct = J(N.mediaInfo, !0);
            return ct[ct.length - 1].id === N.id;
          }, registerStreamType: function(N, ct) {
            const It = ct.getStreamInfo().id;
            L[It] || (L[It] = {}), L[It][N] = ct, W[It] || (W[It] = {}), W[It][N] = {}, W[It][N].state = yt.ALLOW_LOAD, M.getBolaState(N) === void 0 && M.setBolaState(N, P.get().streaming.abr.rules.bolaRule.active && !Pt());
          }, reset: function() {
            j(), C.off(At.A.QUALITY_CHANGE_RENDERED, Ct, _), C.off(At.A.METRIC_ADDED, bt, _), C.off(at.A.LOADING_PROGRESS, _t, _), M && M.reset();
          }, setConfig: function(N) {
            N && (N.streamController && (Y = N.streamController), N.throughputController && (wt = N.throughputController), N.domStorage && (st = N.domStorage), N.mediaPlayerModel && (F = N.mediaPlayerModel), N.customParametersModel && (et = N.customParametersModel), N.cmsdModel && (it = N.cmsdModel), N.dashMetrics && ($ = N.dashMetrics), N.adapter && (R = N.adapter), N.videoModel && (G = N.videoModel), N.settings && (P = N.settings), N.capabilities && (H = N.capabilities));
          }, setPlaybackQuality: Rt, setWindowResizeEventCalled: function(N) {
          }, unRegisterStreamType: function(N, ct) {
            try {
              L[N] && L[N][ct] && delete L[N][ct], W[N] && W[N][ct] && delete W[N][ct];
            } catch (It) {
            }
          } }, v = f.getLogger(_), j(), _;
        }
        Bc.__dashjs_factory_name = "AbrController";
        const tI = Bt.A.getSingletonFactory(Bc);
        Bt.A.updateSingletonFactory(Bc.__dashjs_factory_name, tI);
        var eI = tI;
        const zS = /* @__PURE__ */ new Map([[X.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, "loadedmetadata"], [X.A.VIDEO_ELEMENT_READY_STATES.HAVE_CURRENT_DATA, "loadeddata"], [X.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, "canplay"], [X.A.VIDEO_ELEMENT_READY_STATES.HAVE_ENOUGH_DATA, "canplaythrough"]]);
        function nI() {
          let A, f, C, _, v, M, Y, H, L, W, K;
          const R = this.context, G = (0, Mt.A)(R).getInstance(), F = [];
          function et(_t) {
            _ && (arguments.length > 1 && arguments[1] !== void 0 && arguments[1] ? _.playbackRate = _t : ht(X.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, () => {
              _.playbackRate = _t;
            }));
          }
          function it() {
            return F.length > 0;
          }
          function st(_t) {
            let Ct = F.indexOf(_t);
            if (_t !== null && (Ct !== -1 && F.splice(Ct, 1), C.get().streaming.buffer.syntheticStallEvents.enabled && _ && !it())) {
              const bt = () => {
                if (et(W || 1, C.get().streaming.buffer.syntheticStallEvents.ignoreReadyState), !_.paused) {
                  const Rt = document.createEvent("Event");
                  Rt.initEvent("playing", !0, !1), _.dispatchEvent(Rt);
                }
              };
              C.get().streaming.buffer.syntheticStallEvents.ignoreReadyState ? bt() : (Y && Y.func && Y.event && mt(Y.event, Y.func), Y = ht(X.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, bt));
            }
          }
          function ot() {
            if (_ && it() && _.playbackRate === 0) {
              const _t = document.createEvent("Event");
              _t.initEvent("waiting", !0, !1), _.dispatchEvent(_t);
            }
          }
          function ut(_t, Ct) {
            _ && _.addEventListener(_t, Ct);
          }
          function mt(_t, Ct) {
            _ && _.removeEventListener(_t, Ct);
          }
          function wt() {
            return _ ? _.readyState : NaN;
          }
          function $() {
            return _ ? _.buffered : null;
          }
          function P() {
            return _ ? _.clientWidth : NaN;
          }
          function j() {
            return _ ? _.clientHeight : NaN;
          }
          function J(_t, Ct, bt, Rt, xt) {
            if (_) {
              for (let Pt = 0; Pt < _.textTracks.length; Pt++) if (_.textTracks[Pt].kind === _t && (!Ct || _.textTracks[Pt].label == Ct) && _.textTracks[Pt].language === bt && _.textTracks[Pt].isTTML === Rt && _.textTracks[Pt].isEmbedded === xt) return _.textTracks[Pt];
            }
            return null;
          }
          function ht(_t, Ct) {
            return _t === X.A.VIDEO_ELEMENT_READY_STATES.HAVE_NOTHING || wt() >= _t ? (Ct(), null) : function(bt, Rt) {
              const xt = () => {
                mt(bt, xt), Rt(bt);
              };
              return ut(bt, xt), { func: xt, event: bt };
            }(zS.get(_t), Ct);
          }
          return A = { addEventListener: ut, addTextTrack: function(_t, Ct, bt, Rt, xt) {
            if (!_) return null;
            let Pt = J(_t, Ct, bt, Rt, xt);
            return Pt || (Pt = _.addTextTrack(_t, Ct, bt), Pt.isEmbedded = xt, Pt.isTTML = Rt), Pt;
          }, appendChild: function(_t) {
            _ && (_.appendChild(_t), _t.isTTML !== void 0 && (_.textTracks[_.textTracks.length - 1].isTTML = _t.isTTML, _.textTracks[_.textTracks.length - 1].isEmbedded = _t.isEmbedded));
          }, getBufferRange: $, getClientHeight: j, getClientWidth: P, getElement: function() {
            return _;
          }, getEnded: function() {
            return _ ? _.ended : null;
          }, getPlaybackQuality: function() {
            if (!_) return null;
            let _t = "webkitDroppedFrameCount" in _ && "webkitDecodedFrameCount" in _, Ct = null;
            return "getVideoPlaybackQuality" in _ ? Ct = _.getVideoPlaybackQuality() : _t && (Ct = { droppedVideoFrames: _.webkitDroppedFrameCount, totalVideoFrames: _.webkitDroppedFrameCount + _.webkitDecodedFrameCount, creationTime: /* @__PURE__ */ new Date() }), Ct;
          }, getPlaybackRate: function() {
            return _ ? _.playbackRate : null;
          }, getPlayedRanges: function() {
            return _ ? _.played : null;
          }, getReadyState: wt, getSource: function() {
            return _ ? _.src : null;
          }, getTTMLRenderingDiv: function() {
            return H;
          }, getTextTrack: J, getTextTracks: function() {
            return _ ? _.textTracks : [];
          }, getTime: function() {
            return _ ? isNaN(v) ? _.currentTime : v : null;
          }, getVideoElementSize: function() {
            const _t = C.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty("devicePixelRatio") ? window.devicePixelRatio : 1;
            return { elementWidth: P() * _t, elementHeight: j() * _t };
          }, getVideoHeight: function() {
            return _ ? _.videoHeight : NaN;
          }, getVideoRelativeOffsetLeft: function() {
            if (_) {
              const _t = _.parentNode.host || _.parentNode;
              return _t ? _.getBoundingClientRect().left - _t.getBoundingClientRect().left : NaN;
            }
            return NaN;
          }, getVideoRelativeOffsetTop: function() {
            if (_) {
              const _t = _.parentNode.host || _.parentNode;
              return _t ? _.getBoundingClientRect().top - _t.getBoundingClientRect().top : NaN;
            }
            return NaN;
          }, getVideoWidth: function() {
            return _ ? _.videoWidth : NaN;
          }, getVttRenderingDiv: function() {
            return L;
          }, initialize: function() {
            G.on(at.A.PLAYBACK_PLAYING, ot, this);
          }, isPaused: function() {
            return _ ? _.paused : null;
          }, isSeeking: function() {
            return _ ? _.seeking || !isNaN(v) : null;
          }, isStalled: it, pause: function() {
            _ && (_.pause(), _.autoplay = !1);
          }, play: function() {
            if (_) {
              _.autoplay = !0;
              const _t = _.play();
              _t && _t.catch && typeof Promise != "undefined" && _t.catch((Ct) => {
                Ct.name === "NotAllowedError" && G.trigger(at.A.PLAYBACK_NOT_ALLOWED), f.warn(`Caught pending play exception - continuing (${Ct})`);
              });
            }
          }, removeChild: function(_t) {
            _ && _.removeChild(_t);
          }, removeEventListener: mt, reset: function() {
            clearTimeout(K), G.off(at.A.PLAYBACK_PLAYING, ot, this), F.length = 0;
          }, setConfig: function(_t) {
            _t && _t.settings && (C = _t.settings);
          }, setCurrentTime: function(_t, Ct) {
            _ && (M && M.func && M.event && mt(M.event, M.func), v = _t, M = ht(X.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, () => {
              if (_) if (_.currentTime !== v) try {
                v = Ct ? function(bt) {
                  const Rt = $();
                  let xt = bt, Pt = 9999999999;
                  if (Rt) for (let N = 0; N < Rt.length; N++) {
                    const ct = Rt.start(N), It = Rt.end(N), dt = Math.abs(ct - bt), nt = Math.abs(It - bt);
                    if (bt >= ct && bt <= It) return bt;
                    dt < Pt && (Pt = dt, xt = ct), nt < Pt && (Pt = nt, xt = It);
                  }
                  return xt;
                }(v) : v, isNaN(v) || (_.currentTime = v), v = NaN;
              } catch (bt) {
                _.readyState === 0 && bt.code === bt.INVALID_STATE_ERR && (K = setTimeout(function() {
                  _.currentTime = v, v = NaN;
                }, 400));
              }
              else v = NaN;
            }));
          }, setDisableRemotePlayback: function(_t) {
            _ && (_.disableRemotePlayback = _t);
          }, setElement: function(_t) {
            if (!(_t == null || _t && /^(VIDEO|AUDIO)$/i.test(_t.nodeName))) throw "element is not video or audio DOM type!";
            _ = _t, _ && (_.preload = "auto");
          }, setPlaybackRate: et, setSource: function(_t) {
            _ && (_t ? _.src = _t : (_.removeAttribute("src"), _.load()));
          }, setStallState: function(_t, Ct) {
            (function(bt, Rt) {
              Rt ? function(xt) {
                if (xt !== null && _ && !_.seeking && F.indexOf(xt) === -1 && (F.push(xt), C.get().streaming.buffer.syntheticStallEvents.enabled && _ && F.length === 1 && (C.get().streaming.buffer.syntheticStallEvents.ignoreReadyState || wt() >= X.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA))) {
                  W = _.playbackRate, et(0, !0);
                  const Pt = document.createEvent("Event");
                  Pt.initEvent("waiting", !0, !1), _.dispatchEvent(Pt);
                }
              }(bt) : st(bt);
            })(_t, Ct);
          }, setTTMLRenderingDiv: function(_t) {
            H = _t, H.style.position = "absolute", H.style.display = "flex", H.style.overflow = "hidden", H.style.pointerEvents = "none", H.style.top = 0, H.style.left = 0;
          }, setVttRenderingDiv: function(_t) {
            L = _t;
          }, waitForReadyState: ht }, f = (0, jt.A)(R).getInstance().getLogger(A), C = (0, tt.A)(R).getInstance(), v = NaN, A;
        }
        nI.__dashjs_factory_name = "VideoModel";
        var YS = Bt.A.getSingletonFactory(nI);
        const HS = [{ oldKey: "dashjs_vbitrate", newKey: "dashjs_video_bitrate" }, { oldKey: "dashjs_abitrate", newKey: "dashjs_audio_bitrate" }, { oldKey: "dashjs_vsettings", newKey: "dashjs_video_settings" }, { oldKey: "dashjs_asettings", newKey: "dashjs_audio_settings" }], aI = "dashjs_?_bitrate", iI = "dashjs_?_settings", Qo = "localStorage", rI = "lastBitrate", sI = "lastMediaSettings";
        function oI(A) {
          A = A || {};
          const f = this.context, C = A.settings;
          let _, v, M;
          function Y(K) {
            if (M !== void 0) return M;
            let R;
            M = !1;
            try {
              typeof window != "undefined" && (R = window[K]);
            } catch (G) {
              return v.warn("DOMStorage access denied: " + G.message), M;
            }
            if (!R || K !== Qo) return M;
            try {
              R.setItem("1", "1"), R.removeItem("1"), M = !0;
            } catch (G) {
              v.warn("DOMStorage is supported, but cannot be used: " + G.message);
            }
            return M;
          }
          function H() {
            return Math.round((/* @__PURE__ */ new Date()).getTime() / 6e5) * 6e5;
          }
          function L(K, R) {
            return Y(K) && C.get().streaming[R + "CachingInfo"].enabled;
          }
          function W() {
            if (!C) throw new Error(X.A.MISSING_CONFIG_ERROR);
          }
          return _ = { getSavedBitrateSettings: function(K) {
            if (W(), !C.get().streaming.lastBitrateCachingInfo.enabled) return NaN;
            let R = NaN;
            if (L(Qo, rI)) {
              const G = aI.replace(/\?/, K);
              try {
                const F = JSON.parse(localStorage.getItem(G)) || {}, et = (/* @__PURE__ */ new Date()).getTime() - parseInt(F.timestamp, 10) >= C.get().streaming.lastBitrateCachingInfo.ttl || !1, it = parseFloat(F.bitrate);
                isNaN(it) || et ? et && localStorage.removeItem(G) : (R = it, v.debug("Last saved bitrate for " + K + " was " + it));
              } catch (F) {
                return null;
              }
            }
            return R;
          }, setSavedBitrateSettings: function(K, R) {
            if (L(Qo, rI) && R) {
              const G = aI.replace(/\?/, K);
              try {
                localStorage.setItem(G, JSON.stringify({ bitrate: R.toFixed(3), timestamp: H() }));
              } catch (F) {
                v.error(F.message);
              }
            }
          }, getSavedMediaSettings: function(K) {
            if (W(), !C.get().streaming.lastMediaSettingsCachingInfo.enabled) return null;
            let R = null;
            if (L(Qo, sI)) {
              const G = iI.replace(/\?/, K);
              try {
                const F = JSON.parse(localStorage.getItem(G)) || {}, et = (/* @__PURE__ */ new Date()).getTime() - parseInt(F.timestamp, 10) >= C.get().streaming.lastMediaSettingsCachingInfo.ttl || !1;
                R = F.settings, et && (localStorage.removeItem(G), R = null);
              } catch (F) {
                return null;
              }
            }
            return R;
          }, setSavedMediaSettings: function(K, R) {
            if (L(Qo, sI)) {
              const G = iI.replace(/\?/, K);
              try {
                localStorage.setItem(G, JSON.stringify({ settings: R, timestamp: H() }));
              } catch (F) {
                v.error(F.message);
              }
            }
          } }, v = (0, jt.A)(f).getInstance().getLogger(_), Y(Qo) && HS.forEach((K) => {
            const R = localStorage.getItem(K.oldKey);
            if (R) {
              localStorage.removeItem(K.oldKey);
              try {
                localStorage.setItem(K.newKey, R);
              } catch (G) {
                v.error(G.message);
              }
            }
          }), _;
        }
        oI.__dashjs_factory_name = "DOMStorage";
        var PS = Bt.A.getSingletonFactory(oI), FS = w(8986);
        function lI() {
          const A = this.context;
          let f, C, _, v, M, Y, H, L, W, K, R, G;
          function F(ot, ut, mt, wt) {
            let $ = null;
            const P = ot ? G.resolve(ot.path) : null, j = wt || { init: !0, url: P ? P.url : void 0, range: { start: 0, end: 1500 }, searching: !1, bytesLoaded: 0, bytesToLoad: 1500, mediaType: ut, representation: ot };
            C.debug("Start searching for initialization.");
            const J = st(j);
            H.load({ request: J, success: function(ht) {
              if (j.bytesLoaded = j.range.end, $ = v.findInitRange(ht), !$) return j.range.end = j.bytesLoaded + j.bytesToLoad, F(ot, ut, mt, j);
              ot.range = $, mt(ot);
            }, error: function() {
              mt(ot);
            } }), C.debug("Perform init search: " + j.url);
          }
          function et(ot, ut, mt, wt, $, P) {
            if (mt && (mt.start === void 0 || mt.end === void 0)) {
              const Rt = mt ? mt.toString().split("-") : null;
              mt = Rt ? { start: parseFloat(Rt[0]), end: parseFloat(Rt[1]) } : null;
            }
            $ = $ || it;
            let j = null, J = null;
            const ht = !!mt, _t = ot ? G.resolve(ot.path) : null, Ct = { init: !1, url: _t ? _t.url : void 0, range: ht ? mt : { start: 0, end: 1500 }, searching: !ht, bytesLoaded: P ? P.bytesLoaded : 0, bytesToLoad: 1500, mediaType: ut, representation: ot }, bt = st(Ct);
            H.load({ request: bt, success: function(Rt) {
              const xt = Ct.bytesToLoad, Pt = Rt.byteLength;
              if (Ct.bytesLoaded = Ct.range.end - Ct.range.start, j = v.parse(Rt), J = j.getBox("sidx"), J && J.isComplete) {
                const N = J.references;
                let ct, It;
                if (N != null && N.length > 0 && (ct = N[0].reference_type === 1), ct) {
                  let dt, nt, ft, rt, Et;
                  C.debug("Initiate multiple SIDX load."), Ct.range.end = Ct.range.start + J.size;
                  let kt = [], Dt = 0, Ut = (J.offset || Ct.range.start) + J.size;
                  const Wt = function(ie) {
                    ie ? (kt = kt.concat(ie), Dt++, Dt >= nt && (kt.sort(function(de, Be) {
                      return de.startTime - Be.startTime < 0 ? -1 : 0;
                    }), $(kt, ot, wt))) : $(null, ot, wt);
                  };
                  for (dt = 0, nt = N.length; dt < nt; dt++) ft = Ut, rt = Ut + N[dt].referenced_size - 1, Ut += N[dt].referenced_size, Et = { start: ft, end: rt }, et(ot, ut, Et, wt, Wt, Ct);
                } else C.debug("Parsing segments from SIDX. representation " + ut + " - id: " + ot.id + " for range : " + Ct.range.start + " - " + Ct.range.end), It = function(dt, nt) {
                  const ft = dt.references, rt = ft.length, Et = dt.timescale;
                  let kt = dt.earliest_presentation_time, Dt = nt.range.start + dt.offset + dt.first_offset + dt.size;
                  const Ut = [];
                  let Wt, ie, de, Be;
                  for (let Oe = 0; Oe < rt; Oe++) de = ft[Oe].subsegment_duration, Be = ft[Oe].referenced_size, Wt = new ge(), Wt.duration = de, Wt.startTime = kt, Wt.timescale = Et, ie = Dt + Be - 1, Wt.mediaRange = Dt + "-" + ie, Ut.push(Wt), kt += de, Dt += Be;
                  return Ut;
                }(J, Ct), $(It, ot, wt);
              } else {
                if (J) Ct.range.start = J.offset || Ct.range.start, Ct.range.end = Ct.range.start + (J.size || xt);
                else {
                  if (Pt < Ct.bytesLoaded) return void $(null, ot, wt);
                  {
                    const N = j.getLastBox();
                    N && N.size ? (Ct.range.start = N.offset + N.size, Ct.range.end = Ct.range.start + xt) : Ct.range.end += xt;
                  }
                }
                et(ot, ut, Ct.range, wt, null, Ct);
              }
            }, error: function() {
              $(null, ot, wt);
            } }), C.debug(`Perform SIDX load for type ${ut} : ${Ct.url} with range ${Ct.range.start} - ${Ct.range.end}`);
          }
          function it(ot, ut, mt) {
            mt({ segments: ot, representation: ut, error: ot ? void 0 : new Nt.A(L.SEGMENT_BASE_LOADER_ERROR_CODE, L.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
          }
          function st(ot) {
            if (!ot.url) return;
            const ut = new sn();
            return ut.setInfo(ot), ut;
          }
          return f = { setConfig: function(ot) {
            ot.baseURLController && (G = ot.baseURLController), ot.dashMetrics && (M = ot.dashMetrics), ot.mediaPlayerModel && (Y = ot.mediaPlayerModel), ot.errHandler && (_ = ot.errHandler), ot.boxParser && (v = ot.boxParser), ot.debug && (C = ot.debug.getLogger(f)), ot.errors && (L = ot.errors), ot.urlUtils && (R = ot.urlUtils), ot.constants && (W = ot.constants), ot.dashConstants && (K = ot.dashConstants);
          }, initialize: function() {
            H = ci(A).create({ errHandler: _, dashMetrics: M, mediaPlayerModel: Y, boxParser: v, errors: L, urlUtils: R, constants: W, dashConstants: K });
          }, loadInitialization: function(ot, ut) {
            return new Promise((mt) => {
              F(ot, ut, mt);
            });
          }, loadSegments: function(ot, ut, mt) {
            return new Promise((wt) => {
              et(ot, ut, mt, wt);
            });
          }, reset: function() {
            H && (H.abort(), H = null);
          } }, f;
        }
        lI.__dashjs_factory_name = "SegmentBaseLoader";
        var OS = Bt.A.getSingletonFactory(lI);
        function uI(A) {
          let f;
          A = A || {};
          let C = new DataView(A.data), _ = 0;
          function v(Y, H) {
            let L, W, K = !0, R = 0;
            if (H === void 0 && (H = !1), Y.tag > 16777215 ? (C.getUint32(_) !== Y.tag && (K = !1), R = 4) : Y.tag > 65535 ? (L = C.getUint16(_), W = C.getUint8(_ + 2), 256 * L + W !== Y.tag && (K = !1), R = 3) : Y.tag > 255 ? (C.getUint16(_) !== Y.tag && (K = !1), R = 2) : (C.getUint8(_) !== Y.tag && (K = !1), R = 1), !K && Y.required && !H) throw new Error("required tag not found");
            return K && (_ += R), K;
          }
          function M(Y) {
            let H = 1, L = 128, W = -1, K = 0, R = C.getUint8(_), G = 0;
            for (G = 0; G < 8; G += 1) {
              if ((R & L) === L) {
                K = Y === void 0 ? R & ~L : R, W = G;
                break;
              }
              L >>= 1;
            }
            for (G = 0; G < W; G += 1, H += 1) K = K << 8 | 255 & C.getUint8(_ + H);
            return _ += H, K;
          }
          return f = { getPos: function() {
            return _;
          }, setPos: function(Y) {
            _ = Y;
          }, consumeTag: v, consumeTagAndSize: function(Y, H) {
            let L = v(Y, H);
            return L && M(), L;
          }, parseTag: function(Y) {
            let H;
            return v(Y), H = M(), f[Y.parse](H);
          }, skipOverElement: function(Y, H) {
            let L, W = v(Y, H);
            return W && (L = M(), _ += L), W;
          }, getMatroskaCodedNum: M, getMatroskaFloat: function(Y) {
            let H;
            switch (Y) {
              case 4:
                H = C.getFloat32(_), _ += 4;
                break;
              case 8:
                H = C.getFloat64(_), _ += 8;
            }
            return H;
          }, getMatroskaUint: function(Y) {
            if (Y > 4) return function(L) {
              const W = Math.floor(Number.MAX_SAFE_INTEGER / 256);
              let K = 0;
              for (let R = 0; R < L; R += 1) {
                if (K > W) throw new Error("Value exceeds safe integer limit");
                K *= 256;
                const G = C.getUint8(_ + R);
                if (K > Number.MAX_SAFE_INTEGER - G) throw new Error("Value exceeds safe integer limit");
                K += G;
              }
              return _ += L, K;
            }(Y);
            let H = 0;
            for (let L = 0; L < Y; L += 1) H <<= 8, H |= 255 & C.getUint8(_ + L);
            return _ += Y, H >>> 0;
          }, moreData: function() {
            return _ < C.byteLength;
          } }, f;
        }
        uI.__dashjs_factory_name = "EBMLParser";
        var dI = Bt.A.getClassFactory(uI);
        function gI() {
          const A = this.context;
          let f, C, _, v, M, Y, H, L, W;
          function K(R) {
            const G = new sn();
            return G.setInfo(R), G;
          }
          return f = { setConfig: function(R) {
            if (!(R.baseURLController && R.dashMetrics && R.mediaPlayerModel && R.errHandler)) throw new Error(X.A.MISSING_CONFIG_ERROR);
            W = R.baseURLController, M = R.dashMetrics, Y = R.mediaPlayerModel, v = R.errHandler, L = R.errors, C = R.debug.getLogger(f);
          }, initialize: function() {
            H = ci(A).create({ errHandler: v, dashMetrics: M, mediaPlayerModel: Y, errors: L });
          }, loadInitialization: function(R, G) {
            return new Promise((F) => {
              let et = null, it = R ? W.resolve(R.path) : null, st = R ? R.range.split("-") : null, ot = { range: { start: st ? parseFloat(st[0]) : null, end: st ? parseFloat(st[1]) : null }, request: et, url: it ? it.url : void 0, init: !0, mediaType: G };
              C.info("Start loading initialization."), et = K(ot), H.load({ request: et, success: function() {
                F(R);
              }, error: function() {
                F(R);
              } }), C.debug("Perform init load: " + ot.url);
            });
          }, loadSegments: function(R, G, F) {
            return new Promise((et) => {
              let it = null, st = R ? W.resolve(R.path) : null, ot = st ? st.url : void 0;
              it = K({ bytesLoaded: 0, bytesToLoad: 8192, range: { start: 0, end: 8192 }, request: it, url: ot, init: !1, mediaType: G, representation: R }), C.debug("Parsing ebml header"), H.load({ request: it, success: function(ut) {
                (function(mt, wt, $, P) {
                  if (!mt || mt.byteLength === 0) return void P(null);
                  let j, J, ht, _t, Ct = dI(A).create({ data: mt }), bt = $ ? $.split("-") : null, Rt = null, xt = { url: wt, range: { start: bt ? parseFloat(bt[0]) : null, end: bt ? parseFloat(bt[1]) : null }, request: Rt };
                  for (C.debug("Parse EBML header: " + xt.url), Ct.skipOverElement(_.EBML), Ct.consumeTag(_.Segment), ht = Ct.getMatroskaCodedNum(), ht += Ct.getPos(), _t = Ct.getPos(); Ct.moreData() && !Ct.consumeTagAndSize(_.Segment.Info, !0); ) if (!(Ct.skipOverElement(_.Segment.SeekHead, !0) || Ct.skipOverElement(_.Segment.Tracks, !0) || Ct.skipOverElement(_.Segment.Cues, !0) || Ct.skipOverElement(_.Void, !0))) throw new Error("no valid top level element found");
                  for (; j === void 0; ) {
                    let Pt = Ct.getMatroskaCodedNum(!0), N = Ct.getMatroskaCodedNum();
                    Pt === _.Segment.Info.Duration.tag ? j = Ct[_.Segment.Info.Duration.parse](N) : Ct.setPos(Ct.getPos() + N);
                  }
                  Rt = K(xt), H.load({ request: Rt, success: function(Pt) {
                    J = function(N, ct, It, dt) {
                      let nt, ft, rt, Et, kt, Dt, Ut, Wt;
                      for (ft = function(ie) {
                        let de, Be, Oe = [], nn = dI(A).create({ data: ie });
                        for (nn.consumeTagAndSize(_.Segment.Cues); nn.moreData() && nn.consumeTagAndSize(_.Segment.Cues.CuePoint, !0); ) {
                          for (de = {}, de.CueTime = nn.parseTag(_.Segment.Cues.CuePoint.CueTime), de.CueTracks = []; nn.moreData() && nn.consumeTag(_.Segment.Cues.CuePoint.CueTrackPositions, !0); ) {
                            const _n = nn.getMatroskaCodedNum(), ke = nn.getPos();
                            if (Be = {}, Be.Track = nn.parseTag(_.Segment.Cues.CuePoint.CueTrackPositions.CueTrack), Be.Track === 0) throw new Error("Cue track cannot be 0");
                            Be.ClusterPosition = nn.parseTag(_.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition), de.CueTracks.push(Be), nn.setPos(ke + _n);
                          }
                          if (de.CueTracks.length === 0) throw new Error("Mandatory cuetrack not found");
                          Oe.push(de);
                        }
                        if (Oe.length === 0) throw new Error("mandatory cuepoint not found");
                        return Oe;
                      }(N), rt = [], kt = 0, Dt = ft.length; kt < Dt; kt += 1) Et = new ge(), nt = 0, nt = kt < ft.length - 1 ? ft[kt + 1].CueTime - ft[kt].CueTime : dt - ft[kt].CueTime, Et.duration = nt, Et.startTime = ft[kt].CueTime, Et.timescale = 1e3, Ut = ft[kt].CueTracks[0].ClusterPosition + ct, Wt = kt < ft.length - 1 ? ft[kt + 1].CueTracks[0].ClusterPosition + ct - 1 : It - 1, Et.mediaRange = Ut + "-" + Wt, rt.push(Et);
                      return C.debug("Parsed cues: " + rt.length + " cues."), rt;
                    }(Pt, _t, ht, j), P(J);
                  }, error: function() {
                    C.error("Download Error: Cues " + xt.url), P(null);
                  } }), C.debug("Perform cues load: " + xt.url + " bytes=" + xt.range.start + "-" + xt.range.end);
                })(ut, ot, F, function(mt) {
                  et({ segments: mt, representation: R, error: mt ? void 0 : new Nt.A(L.SEGMENT_BASE_LOADER_ERROR_CODE, L.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
                });
              }, error: function() {
                et({ representation: R, error: new Nt.A(L.SEGMENT_BASE_LOADER_ERROR_CODE, L.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
              } });
            });
          }, reset: function() {
            H && (H.abort(), H = null);
          } }, _ = { EBML: { tag: 440786851, required: !0 }, Segment: { tag: 408125543, required: !0, SeekHead: { tag: 290298740, required: !0 }, Info: { tag: 357149030, required: !0, TimecodeScale: { tag: 2807729, required: !0, parse: "getMatroskaUint" }, Duration: { tag: 17545, required: !0, parse: "getMatroskaFloat" } }, Tracks: { tag: 374648427, required: !0 }, Cues: { tag: 475249515, required: !0, CuePoint: { tag: 187, required: !0, CueTime: { tag: 179, required: !0, parse: "getMatroskaUint" }, CueTrackPositions: { tag: 183, required: !0, CueTrack: { tag: 247, required: !0, parse: "getMatroskaUint" }, CueClusterPosition: { tag: 241, required: !0, parse: "getMatroskaUint" } } } } }, Void: { tag: 236, required: !0 } }, f;
        }
        gI.__dashjs_factory_name = "WebmSegmentBaseLoader";
        var US = Bt.A.getSingletonFactory(gI);
        function cI(A) {
          A = A || {};
          const f = this.context, C = A.eventBus, _ = A.events, v = A.dashMetrics, M = A.mediaPlayerModel, Y = A.errHandler, H = A.baseURLController, L = A.debug, W = A.boxParser, K = A.errors;
          let R, G, F;
          function et(it) {
            return (it ? it.split("/")[1] : "").toLowerCase() === "webm";
          }
          return R = { initialize: function() {
            G.initialize(), F.initialize();
          }, getSegmentBaseInitSegment: function(it) {
            return et(it.representation.mimeType) ? F.loadInitialization(it.representation, it.mediaType) : G.loadInitialization(it.representation, it.mediaType);
          }, getSegmentList: function(it) {
            return et(it.mimeType) ? F.loadSegments(it.representation, it.mediaType, it.representation ? it.representation.indexRange : null) : G.loadSegments(it.representation, it.mediaType, it.representation ? it.representation.indexRange : null);
          }, reset: function() {
            G.reset(), F.reset();
          } }, G = OS(f).getInstance(), F = US(f).getInstance(), G.setConfig({ baseURLController: H, dashMetrics: v, mediaPlayerModel: M, errHandler: Y, eventBus: C, events: _, errors: K, debug: L, boxParser: W }), F.setConfig({ baseURLController: H, dashMetrics: v, mediaPlayerModel: M, errHandler: Y, eventBus: C, events: _, errors: K, debug: L }), R;
        }
        cI.__dashjs_factory_name = "SegmentBaseController";
        var KS = Bt.A.getSingletonFactory(cI), xc = class {
          constructor() {
            this.accessibility = null, this.adaptationSetSwitchingCompatibleIds = [], this.audioChannelConfiguration = null, this.bitrateList = null, this.codec = null, this.contentProtection = null, this.essentialProperties = [], this.id = null, this.index = null, this.isEmbedded = null, this.isFragmented = null, this.isText = !1, this.labels = null, this.lang = null, this.mimeType = null, this.normalizedKeyIds = /* @__PURE__ */ new Set(), this.representationCount = 0, this.roles = null, this.segmentAlignment = !1, this.selectionPriority = 1, this.streamInfo = null, this.subSegmentAlignment = !1, this.supplementalProperties = [], this.type = null, this.viewpoint = null;
          }
        }, mI = class {
          constructor() {
            this.id = null, this.index = null, this.start = NaN, this.duration = NaN, this.manifestInfo = null, this.isLast = !0, this.isEncrypted = !1;
          }
        }, VS = class {
          constructor() {
            this.dvrWindowSize = NaN, this.loadedTime = null, this.availableFrom = null, this.minBufferTime = NaN, this.duration = NaN, this.isDynamic = !1, this.maxFragmentDuration = null, this.serviceDescriptions = [], this.protocol = null;
          }
        }, XS = class {
          constructor(A) {
            this.valid = A[0] == "/", this.path = A.split("/").filter((f) => f.length !== 0).map((f) => {
              let C = { name: f }, _ = f.indexOf("[");
              if (_ != -1) {
                C.name = f.substring(0, _);
                let v = f.substring(_ + 1, f.length - 1);
                this.valid = this.valid && v.indexOf("[") == -1;
                let M = v.indexOf("=");
                M != -1 ? (C.attribute = { name: v.substring(1, M), value: v.substring(M + 1) }, ["'", '"'].indexOf(C.attribute.value[0]) != -1 && (C.attribute.value = C.attribute.value.substring(1, C.attribute.value.length - 1))) : C.position = parseInt(v, 10) - 1;
              }
              return C;
            });
          }
          isValid() {
            return this.valid;
          }
          findsElement() {
            return !this.findsAttribute();
          }
          findsAttribute() {
            return this.path[this.path.length - 1].name.startsWith("@");
          }
          findsTextReplace() {
            return this.path[this.path.length - 1].name === "text()";
          }
          getMpdTarget(A, f) {
            let C = null, _ = A, v = 1, M = "MPD";
            for (; v < this.path.length && _ !== null; ) {
              C = _;
              let Y = this.path[v];
              if (M = Y.name, v !== this.path.length - 1 || !M.startsWith("@") && M !== "text()") {
                let H = C[M] || [];
                if (H.length === 0 && C[M] && H.push(C[M]), Y.position) _ = H[Y.position] || null;
                else if (Y.attribute) {
                  let L = Y.attribute;
                  _ = H.filter((W) => W[L.name] == L.value)[0] || null;
                } else _ = Array.isArray(H) ? H[0] : H;
              }
              v++;
            }
            return _ === null ? null : M.startsWith("@") ? { name: M.substring(1), leaf: _, target: _ } : M === "text()" ? { name: "__text", leaf: _, target: _ } : { name: M, leaf: _, target: f ? C : _ };
          }
        }, WS = class {
          constructor(A, f, C) {
            this.action = A, this.xpath = f, this.value = C, this.position = null;
          }
          getMpdTarget(A) {
            let f = this.action === "remove" || this.action === "replace" || this.position === "before" || this.position === "after";
            return this.xpath.getMpdTarget(A, f);
          }
        };
        function fI() {
          let A, f;
          const C = this.context;
          return A = { getIsPatch: function(_) {
            return _ && _.hasOwnProperty(D.A.ORIGINAL_MPD_ID) || !1;
          }, getMpdId: function(_) {
            return _ && _[D.A.ORIGINAL_MPD_ID] || null;
          }, getOriginalPublishTime: function(_) {
            return _ && _.hasOwnProperty(D.A.ORIGINAL_PUBLISH_TIME) ? new Date(_[D.A.ORIGINAL_PUBLISH_TIME]) : null;
          }, getPatchOperations: function(_) {
            return _ ? (_.__children || []).map((v) => {
              const M = v.tagName;
              if (M !== "add" && M !== "remove" && M !== "replace") return f.warn(`Ignoring node of invalid action: ${M}`), null;
              let Y = v.sel;
              if (M === "add" && v.type) {
                if (!v.type.startsWith("@")) return f.warn(`Ignoring add action for prefixed namespace declaration: ${v.type}=${v.__text}`), null;
                Y = `${Y}/${v.type}`;
              }
              let H = new XS(Y);
              if (!H.isValid()) return f.warn(`Ignoring action with invalid selector: ${M} - ${Y}`), null;
              let L = null;
              H.findsAttribute() || H.findsTextReplace() ? L = v.__text || "" : M !== "remove" && (L = v.__children.reduce((K, R) => {
                let G = R.tagName;
                return G !== "#text" && (K[G] = K[G] || [], K[G].push(R)), K;
              }, {}));
              let W = new WS(M, H, L);
              return M === "add" && (W.position = v.pos), W;
            }).filter((v) => !!v) : [];
          }, getPublishTime: function(_) {
            return _ && _.hasOwnProperty(D.A.PUBLISH_TIME) ? new Date(_[D.A.PUBLISH_TIME]) : null;
          } }, f = (0, jt.A)(C).getInstance().getLogger(A), A;
        }
        fI.__dashjs_factory_name = "PatchManifestModel";
        var jS = Bt.A.getSingletonFactory(fI);
        function Gr(A) {
          let f = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          if (typeof TextDecoder != "undefined") {
            const L = new TextDecoder("utf-8").decode(A);
            if (f) {
              const W = L.indexOf("\0");
              return W !== -1 ? L.substring(0, W) : L;
            }
            return L.replace(/\0/g, "");
          }
          const C = A.length;
          let _, v, M, Y = "", H = 0;
          for (; H < C; ) {
            if (_ = A[H++], _ === 0 && f) return Y;
            if (_ !== 0 && _ !== 3) switch (_ >> 4) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
                Y += String.fromCharCode(_);
                break;
              case 12:
              case 13:
                v = A[H++], Y += String.fromCharCode((31 & _) << 6 | 63 & v);
                break;
              case 14:
                v = A[H++], M = A[H++], Y += String.fromCharCode((15 & _) << 12 | (63 & v) << 6 | 63 & M);
            }
          }
          return Y;
        }
        function Nc(A) {
          return function(f, C, _, v) {
            const M = (Y = f) instanceof ArrayBuffer ? Y : Y.buffer;
            var Y;
            let H = 1;
            "BYTES_PER_ELEMENT" in v && (H = v.BYTES_PER_ELEMENT);
            const L = (G = f) && G.buffer instanceof ArrayBuffer && G.byteLength !== void 0 && G.byteOffset !== void 0 ? f.byteOffset : 0, W = (L + f.byteLength) / H, K = (L + C) / H, R = Math.floor(Math.max(0, Math.min(K, W)));
            var G;
            return new v(M, R, Math.floor(Math.min(R + Math.max(_, 0), W)) - R);
          }(A, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, Uint8Array);
        }
        function ZS(A) {
          return A.type === "PRIV" ? function(f) {
            if (f.size < 2) return;
            const C = Gr(f.data, !0), _ = new Uint8Array(f.data.subarray(C.length + 1));
            return { key: f.type, info: C, data: _.buffer };
          }(A) : A.type[0] === "W" ? function(f) {
            if (f.type === "WXXX") {
              if (f.size < 2) return;
              let _ = 1;
              const v = Gr(f.data.subarray(_), !0);
              _ += v.length + 1;
              const M = Gr(f.data.subarray(_));
              return { key: f.type, info: v, data: M };
            }
            const C = Gr(f.data);
            return { key: f.type, info: "", data: C };
          }(A) : A.type === "APIC" ? function(f) {
            const C = { key: f.type, description: "", data: "", mimeType: null, pictureType: null };
            if (f.size < 2) return;
            if (f.data[0] !== 3) return void console.log("Ignore frame with unrecognized character encoding");
            const _ = f.data.subarray(1).indexOf(0);
            if (_ === -1) return;
            const v = Gr(Nc(f.data, 1, _)), M = f.data[2 + _], Y = f.data.subarray(3 + _).indexOf(0);
            if (Y === -1) return;
            const H = Gr(Nc(f.data, 3 + _, Y));
            let L;
            return L = v === "-->" ? Gr(Nc(f.data, 4 + _ + Y)) : (W = f.data.subarray(4 + _ + Y)) instanceof ArrayBuffer ? W : W.byteOffset == 0 && W.byteLength == W.buffer.byteLength ? W.buffer : new Uint8Array(W).buffer, C.mimeType = v, C.pictureType = M, C.description = H, C.data = L, C;
            var W;
          }(A) : function(f) {
            if (f.size < 2) return;
            if (f.type === "TXXX") {
              let _ = 1;
              const v = Gr(f.data.subarray(_), !0);
              _ += v.length + 1;
              const M = Gr(f.data.subarray(_));
              return { key: f.type, info: v, data: M };
            }
            const C = Gr(f.data.subarray(1));
            return { key: f.type, info: "", data: C };
          }(A);
        }
        function hI(A, f) {
          let C = 0;
          return C = (127 & A[f]) << 21, C |= (127 & A[f + 1]) << 14, C |= (127 & A[f + 2]) << 7, C |= 127 & A[f + 3], C;
        }
        function JS(A) {
          const f = String.fromCharCode(A[0], A[1], A[2], A[3]), C = hI(A, 4);
          return { type: f, size: C, data: A.subarray(10, 10 + C) };
        }
        function QS(A, f) {
          return f + 10 <= A.length && A[f] === 51 && A[f + 1] === 68 && A[f + 2] === 73 && A[f + 3] < 255 && A[f + 4] < 255 && A[f + 6] < 128 && A[f + 7] < 128 && A[f + 8] < 128 && A[f + 9] < 128;
        }
        function qS(A, f) {
          return f + 10 <= A.length && A[f] === 73 && A[f + 1] === 68 && A[f + 2] === 51 && A[f + 3] < 255 && A[f + 4] < 255 && A[f + 6] < 128 && A[f + 7] < 128 && A[f + 8] < 128 && A[f + 9] < 128;
        }
        function pI() {
          let A, f, C, _, v, M;
          const Y = this.context;
          function H($, P) {
            const j = P ? P.index : 0, J = f.getAdaptationsForType(_[j].mpd.manifest, j, $);
            if (!J || J.length === 0) return null;
            if (J.length > 1 && P) {
              for (let _t = 0, Ct = J.length; _t < Ct; _t++) if (ht = J[_t], f.getRolesForAdaptation(ht).filter(function(bt) {
                return bt.schemeIdUri === X.A.DASH_ROLE_SCHEME_ID && bt.value === D.A.MAIN;
              })[0]) return J[_t];
            }
            var ht;
            return J[0];
          }
          function L($, P, j, J, ht, _t) {
            let Ct, bt, Rt, xt, Pt, N, ct = [];
            if (!J || J.length === 0) return [];
            const It = f.getAdaptationsForPeriod(P);
            for (xt = 0, N = J.length; xt < N; xt++) if (Ct = J[xt], Rt = f.getIndexForAdaptation(Ct, $, j.index), bt = it(It[Rt]), _t) {
              let dt = bt.accessibility.length;
              for (Pt = 0; Pt < dt; Pt++) {
                if (!bt) continue;
                let nt = bt.accessibility[Pt];
                if (nt.schemeIdUri === v.ACCESSIBILITY_CEA608_SCHEME) if (nt.value && nt.value !== "") {
                  let ft = nt.value.split(";");
                  if (ft[0].substring(0, 2) === "CC") for (Pt = 0; Pt < ft.length; Pt++) bt || (bt = it.call(this, It[Rt])), st(bt, ft[Pt].substring(0, 3), ft[Pt].substring(4)), ct.push(bt), bt = null;
                  else for (Pt = 0; Pt < ft.length; Pt++) bt || (bt = it.call(this, It[Rt])), st(bt, "CC" + (Pt + 1), ft[Pt]), ct.push(bt), bt = null;
                } else st(bt, v.CC1, "eng"), ct.push(bt), bt = null;
              }
            } else ht === v.IMAGE ? (bt.type = v.IMAGE, ct.push(bt), bt = null) : bt && ct.push(bt);
            return ct;
          }
          function W($) {
            const P = K($);
            return f.getRegularPeriods(P);
          }
          function K($) {
            const P = G($);
            return f.getMpd(P);
          }
          function R() {
            _ = [];
          }
          function G($) {
            return $ || (_.length > 0 ? _[0].mpd.manifest : null);
          }
          function F($) {
            try {
              const P = et($.streamInfo, _), j = f.getAdaptationsForPeriod(P);
              return $ && $.streamInfo && $.streamInfo.id !== void 0 && j ? j[$.index] : null;
            } catch (P) {
              return null;
            }
          }
          function et($, P) {
            const j = P.length;
            for (let J = 0; J < j; J++) {
              let ht = P[J];
              if ($ && $.id === ht.id) return ht;
            }
            return null;
          }
          function it($) {
            if (!$) return null;
            let P = new xc();
            const j = $.period.mpd.manifest.Period[$.period.index].AdaptationSet[$.index];
            return P.id = $.id, P.index = $.index, P.type = $.type, P.streamInfo = ot($.period), P.representationCount = f.getRepresentationCount(j), P.labels = f.getLabelsForAdaptation(j), P.lang = f.getLanguageForAdaptation(j), P.segmentAlignment = f.getSegmentAlignment(j), P.subSegmentAlignment = f.getSubSegmentAlignment(j), P.viewpoint = f.getViewpointForAdaptation(j), P.accessibility = f.getAccessibilityForAdaptation(j), P.accessibility.filter(function(J) {
              if (J.schemeIdUri && J.schemeIdUri.search("cea-608") >= 0 && M !== void 0) return !0;
            })[0] && (P.embeddedCaptions = !0), P.audioChannelConfiguration = f.getAudioChannelConfigurationForAdaptation(j), P.audioChannelConfiguration.length === 0 && j.Representation && j.Representation.length > 0 && (P.audioChannelConfiguration = f.getAudioChannelConfigurationForRepresentation(j.Representation[0])), P.roles = f.getRolesForAdaptation(j), P.codec = f.getCodec(j), P.mimeType = f.getMimeType(j), P.contentProtection = f.getContentProtectionByAdaptation(j), P.bitrateList = f.getBitrateListForAdaptation(j), P.selectionPriority = f.getSelectionPriority(j), P.contentProtection && P.contentProtection.length > 0 && (P.contentProtection = function(J, ht) {
              if (!J || !J.length || !ht) return J;
              const _t = f.getContentProtectionByManifest(ht);
              if (!_t || !_t.length) return J;
              const Ct = _t.reduce((bt, Rt) => (Rt.refId && bt.set(Rt.refId, Rt), bt), /* @__PURE__ */ new Map());
              return J.map((bt) => {
                if (bt.ref) {
                  const Rt = Ct.get(bt.ref);
                  Rt && bt.mergeAttributesFromReference(Rt);
                }
                return bt;
              });
            }(P.contentProtection, $.period.mpd.manifest), P.contentProtection = function(J) {
              const ht = J.map((_t) => _t.cencDefaultKid).filter((_t) => _t !== null);
              if (ht.length) {
                const _t = ht[0];
                J.forEach((Ct) => {
                  Ct.keyId = _t;
                });
              }
              return J;
            }(P.contentProtection), P.normalizedKeyIds = function(J) {
              const ht = /* @__PURE__ */ new Set();
              return J.forEach((_t) => {
                _t.cencDefaultKid && typeof _t.cencDefaultKid == "string" && ht.add(_t.cencDefaultKid.replace(/-/g, "").toLowerCase());
              }), ht;
            }(P.contentProtection)), P.isText = f.getIsText(j), P.essentialProperties = f.getCombinedEssentialPropertiesForAdaptationSet(j), P.supplementalProperties = f.getCombinedSupplementalPropertiesForAdaptationSet(j), P.isFragmented = f.getIsFragmented(j), P.isEmbedded = !1, P.adaptationSetSwitchingCompatibleIds = function(J) {
              if (!J || !J.supplementalProperties) return [];
              let ht = [];
              const _t = J.supplementalProperties.filter((Ct) => Ct.schemeIdUri === D.A.ADAPTATION_SET_SWITCHING_SCHEME_ID_URI);
              return _t && _t.length > 0 && (ht = _t[0].value.toString().split(",").map((Ct) => Ct)), ht;
            }(P), P;
          }
          function st($, P, j) {
            $.id = P, $.index = 100 + parseInt(P.substring(2, 3)), $.type = v.TEXT, $.codec = "cea-608-in-SEI", $.isEmbedded = !0, $.isFragmented = !1, $.lang = Sd(j), $.roles = [{ schemeIdUri: "urn:mpeg:dash:role:2011", value: "caption" }];
          }
          function ot($) {
            let P = new mI();
            return P.id = $.id, P.index = $.index, P.start = $.start, P.duration = $.duration, P.manifestInfo = function(j) {
              let J = new VS();
              return J.dvrWindowSize = j.timeShiftBufferDepth, J.loadedTime = j.manifest.loadedTime, J.availableFrom = j.availabilityStartTime, J.minBufferTime = j.manifest.minBufferTime, J.maxFragmentDuration = j.maxSegmentDuration, J.duration = f.getDuration(j.manifest), J.isDynamic = f.getIsDynamic(j.manifest), J.serviceDescriptions = f.getServiceDescriptions(j.manifest), J.protocol = j.manifest.protocol, J;
            }($.mpd), P.isLast = $.mpd.manifest.Period.length === 1 || Math.abs(P.start + P.duration - P.manifestInfo.duration) < 1, P.isEncrypted = $.isEncrypted, P;
          }
          function ut() {
            if (!v) throw new Error("setConfig function has to be called previously");
          }
          function mt($) {
            return _.length > 0 ? _[0].mpd.manifest.Period[$] : null;
          }
          function wt($, P, j) {
            let J, ht, _t, Ct, bt, Rt;
            if ($) {
              for (ht = $.AdaptationSet, bt = 0; bt < ht.length; bt += 1) for (J = ht[bt], Ct = J.Representation, Rt = 0; Rt < Ct.length; Rt += 1) if (_t = Ct[Rt], P === _t.id) return j ? Rt : _t;
            }
            return null;
          }
          return A = { applyPatchToManifest: function($, P) {
            C.getPatchOperations(P).forEach((j) => {
              let J = j.getMpdTarget($);
              if (J === null) return;
              let { name: ht, target: _t, leaf: Ct } = J;
              if (j.xpath.findsAttribute() || ht === "__text") {
                switch (j.action) {
                  case "add":
                  case "replace":
                    _t[ht] = j.value;
                    break;
                  case "remove":
                    delete _t[ht];
                }
                return;
              }
              let bt = (_t[ht] || []).indexOf(Ct), Rt = j.position === "prepend" || j.position === "before";
              if (j.action === "remove" || j.action === "replace") if (Array.isArray(_t[ht])) {
                if (bt != -1) {
                  let xt = _t[ht];
                  xt.splice(bt, 1), xt.length > 0 ? _t[ht] = xt : delete _t[ht];
                }
              } else delete _t[ht];
              j.action !== "add" && j.action !== "replace" || Object.keys(j.value).forEach((xt) => {
                let Pt = j.value[xt], N = _t[xt] || [];
                if (N.length === 0 && _t[xt] && N.push(_t[xt]), N.length === 0) N = Pt;
                else {
                  let ct = N.length;
                  ct = xt == ht && bt != -1 ? bt + (Rt ? 0 : 1) + (j.action === "replace" ? -1 : 0) : Rt ? 0 : N.length, N.splice.apply(N, [ct, 0].concat(Pt));
                }
                _t[xt] = N;
              });
            });
          }, areMediaInfosEqual: function($, P) {
            if (!$ || !P) return !1;
            const j = $.id === P.id, J = $.codec === P.codec, ht = JSON.stringify($.viewpoint) === JSON.stringify(P.viewpoint), _t = $.lang === P.lang, Ct = JSON.stringify($.roles) === JSON.stringify(P.roles), bt = JSON.stringify($.accessibility) === JSON.stringify(P.accessibility), Rt = JSON.stringify($.audioChannelConfiguration) === JSON.stringify(P.audioChannelConfiguration);
            return j && J && ht && _t && Ct && bt && Rt;
          }, getAllMediaInfoForType: function($, P, j) {
            let J = _, ht = j, _t = [];
            if (ht) ut(), J = W(ht);
            else {
              if (!(_.length > 0)) return _t;
              ht = _[0].mpd.manifest;
            }
            const Ct = et($, J);
            let bt = f.getAdaptationsForType(ht, $ ? $.index : null, P);
            return _t = L(ht, Ct, $, bt, P), P === v.TEXT && (bt = f.getAdaptationsForType(ht, $ ? $.index : null, v.VIDEO), _t = _t.concat(L(ht, Ct, $, bt, P, !0))), _t;
          }, getAvailabilityStartTime: function($) {
            const P = K($);
            return f.getAvailabilityStartTime(P);
          }, getBandwidthForRepresentation: function($, P) {
            let j;
            return j = wt(mt(P), $), j ? j.bandwidth : null;
          }, getBaseURLsFromElement: function($) {
            return f.getBaseURLsFromElement($);
          }, getCodec: function($, P, j) {
            return f.getCodec($, P, j);
          }, getContentSteering: function($) {
            return f.getContentSteering($);
          }, getDuration: function($) {
            const P = G($);
            return f.getDuration(P);
          }, getEssentialPropertiesForAdaptationSet: function($) {
            try {
              return f.getEssentialPropertiesForRepresentation($);
            } catch (P) {
              return [];
            }
          }, getEssentialPropertiesForRepresentation: function($) {
            try {
              return f.getEssentialPropertiesForRepresentation($);
            } catch (P) {
              return [];
            }
          }, getEvent: function($, P, j, J) {
            try {
              if (!$ || !P || isNaN(j) || !J) return null;
              const ht = $.scheme_id_uri, _t = $.value;
              if (!P[ht + "/" + _t]) return null;
              const Ct = new cs(), bt = $.timescale || 1, Rt = J.adaptation.period.start, xt = P[ht + "/" + _t], Pt = isNaN(J.presentationTimeOffset) ? isNaN(xt.presentationTimeOffset) ? 0 : xt.presentationTimeOffset : J.presentationTimeOffset;
              let N, ct = $.presentation_time_delta / bt;
              N = $.version === 0 ? Rt + j - Pt + ct : Rt - Pt + ct;
              const It = $.event_duration / bt, dt = $.id, nt = $.message_data;
              return Ct.eventStream = xt, Ct.eventStream.value = _t, Ct.eventStream.timescale = bt, Ct.duration = It, Ct.id = dt, Ct.calculatedPresentationTime = N, Ct.messageData = nt, Ct.presentationTimeDelta = ct, Ct.parsedMessageData = ht === X.A.ID3_SCHEME_ID_URI ? function(ft) {
                let rt = 0;
                const Et = [];
                for (; qS(ft, rt); ) {
                  const kt = hI(ft, rt + 6);
                  ft[rt + 5] >> 6 & 1 && (rt += 10), rt += 10;
                  const Dt = rt + kt;
                  for (; rt + 10 < Dt; ) {
                    const Ut = JS(ft.subarray(rt)), Wt = ZS(Ut);
                    Wt && Et.push(Wt), rt += Ut.size + 10;
                  }
                  QS(ft, rt) && (rt += 10);
                }
                return Et;
              }(nt) : null, Ct;
            } catch (ht) {
              return null;
            }
          }, getEventsFor: function($, P, j) {
            let J = [];
            if (_.length > 0) {
              const ht = _[0].mpd.manifest;
              if ($ instanceof mI) {
                const _t = et($, _);
                J = f.getEventsForPeriod(_t);
              } else if ($ instanceof xc) {
                const _t = et(j, _);
                J = f.getEventStreamForAdaptationSet(ht, F($), _t);
              } else if ($ instanceof $n) {
                const _t = et(j, _);
                J = f.getEventStreamForRepresentation(ht, P, _t);
              }
            }
            return J;
          }, getFramerate: function($) {
            return f.getFramerate($);
          }, getIndexForRepresentation: function($, P) {
            return function(j, J) {
              const ht = wt(j, J, !0);
              return ht !== null ? ht : -1;
            }(mt(P), $);
          }, getIsDVB: function($) {
            return f.hasProfile($, "urn:dvb:dash:profile:dvb-dash:2014");
          }, getIsDynamic: function($) {
            const P = G($);
            return f.getIsDynamic(P);
          }, getIsPatch: function($) {
            return C.getIsPatch($);
          }, getIsTextTrack: function($) {
            return f.getIsText($);
          }, getIsTypeOf: function($, P) {
            return f.getIsTypeOf($, P);
          }, getLocation: function($) {
            return f.getLocation($);
          }, getMainAdaptationForType: H, getManifestUpdatePeriod: function($) {
            let P = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return f.getManifestUpdatePeriod($, P);
          }, getMediaInfoForType: function($, P) {
            if (_.length === 0 || !$) return null;
            let j = et($, _);
            if (!j) return null;
            const J = f.getAdaptationsForPeriod(j);
            let ht = H(P, $);
            return ht ? it(J[f.getIndexForAdaptation(ht, _[0].mpd.manifest, $.index)]) : null;
          }, getMpd: K, getPatchLocation: function($) {
            const P = f.getPatchLocation($), j = f.getPublishTime($);
            return P && P.length !== 0 && j ? P.filter((J) => isNaN(J.ttl) || j.getTime() + J.ttl > (/* @__PURE__ */ new Date()).getTime()) : [];
          }, getPeriodById: function($) {
            if (!$ || _.length === 0) return null;
            const P = _.filter((j) => j.id === $);
            return P && P.length > 0 ? P[0] : null;
          }, getProducerReferenceTimes: function($, P) {
            let j, J;
            const ht = et($, _);
            return j = P ? P.id : null, _.length > 0 && ht && (J = j ? f.getAdaptationForId(j, _[0].mpd.manifest, ht.index) : f.getAdaptationForIndex(P ? P.index : null, _[0].mpd.manifest, ht.index)), J ? f.getProducerReferenceTimesForAdaptation(J) : [];
          }, getPublishTime: function($) {
            return f.getPublishTime($);
          }, getRealAdaptation: function($, P) {
            let j, J;
            const ht = et($, _);
            return j = P ? P.id : null, _.length > 0 && ht && (J = j ? f.getAdaptationForId(j, _[0].mpd.manifest, ht.index) : f.getAdaptationForIndex(P ? P.index : null, _[0].mpd.manifest, ht.index)), J;
          }, getRealPeriodByIndex: function($) {
            return f.getRealPeriodForIndex($, _[0].mpd.manifest);
          }, getRegularPeriods: W, getRepresentationSortFunction: function() {
            return f.getRepresentationSortFunction();
          }, getStreamsInfo: function($, P) {
            const j = [];
            let J = _;
            if ($ && (ut(), J = W($)), J.length > 0) {
              (!P || P > J.length) && (P = J.length);
              for (let ht = 0; ht < P; ht++) j.push(ot(J[ht]));
            }
            return j;
          }, getSuggestedPresentationDelay: function() {
            const $ = _.length > 0 ? _[0].mpd : null;
            return f.getSuggestedPresentationDelay($);
          }, getSupplementalCodecs: function($) {
            const P = $[D.A.SUPPLEMENTAL_CODECS];
            return P ? P.split(" ").map((j) => $.mimeType + ';codecs="' + j + '"') : [];
          }, getUTCTimingSources: function() {
            const $ = G();
            return f.getUTCTimingSources($);
          }, getVoRepresentations: function($) {
            let P;
            const j = F($);
            return P = f.getRepresentationsForAdaptation(j, $), P;
          }, isPatchValid: function($, P) {
            let j = f.getId($), J = C.getMpdId(P), ht = f.getPublishTime($), _t = C.getPublishTime(P), Ct = C.getOriginalPublishTime(P);
            return !!(j && J && j == J && ht && Ct && ht.getTime() == Ct.getTime() && _t && ht.getTime() < _t.getTime());
          }, reset: R, setConfig: function($) {
            $ && ($.constants && (v = $.constants), $.cea608parser && (M = $.cea608parser), $.errHandler && f.setConfig({ errHandler: $.errHandler }), $.BASE64 && f.setConfig({ BASE64: $.BASE64 }));
          }, updatePeriods: function($) {
            if (!$) return null;
            ut(), _ = W($);
          } }, f = si(Y).getInstance(), C = jS(Y).getInstance(), R(), A;
        }
        pI.__dashjs_factory_name = "DashAdapter";
        var $S = Bt.A.getSingletonFactory(pI);
        class tw {
          static round10(f, C) {
            return function(_, v, M) {
              return M === void 0 || +M == 0 ? Math[_](v) : (M = +M, (v = +v) === null || isNaN(v) || typeof M != "number" || M % 1 != 0 ? NaN : (v = v.toString().split("e"), +((v = (v = Math[_](+(v[0] + "e" + (v[1] ? +v[1] - M : -M)))).toString().split("e"))[0] + "e" + (v[1] ? +v[1] + M : M))));
            }("round", f, C);
          }
        }
        var ew = class {
          constructor() {
            this.TcpList = [], this.HttpList = [], this.RepSwitchList = [], this.BufferLevel = [], this.BufferState = [], this.PlayList = [], this.DroppedFrames = [], this.SchedulingInfo = [], this.DVRInfo = [], this.ManifestUpdate = [], this.RequestsQueue = null, this.DVBErrors = [];
          }
        }, aw = class {
          constructor() {
            this.t = null, this.mt = null, this.to = null, this.lto = null;
          }
        }, iw = class {
          constructor() {
            this.t = null, this.level = null;
          }
        }, rw = class {
          constructor() {
            this.target = null, this.state = yt.BUFFER_EMPTY;
          }
        }, sw = class {
          constructor() {
            this.time = null, this.range = null, this.manifestInfo = null;
          }
        }, ow = class {
          constructor() {
            this.time = null, this.droppedFrames = null;
          }
        };
        class lw {
          constructor() {
            this.mediaType = null, this.type = null, this.requestTime = null, this.fetchTime = null, this.availabilityStartTime = null, this.presentationStartTime = 0, this.clientTimeOffset = 0, this.currentTime = null, this.buffered = null, this.latency = 0, this.streamInfo = [], this.representationInfo = [];
          }
        }
        class uw {
          constructor() {
            this.id = null, this.index = null, this.start = null, this.duration = null;
          }
        }
        class dw {
          constructor() {
            this.id = null, this.index = null, this.mediaType = null, this.presentationTimeOffset = null, this.startNumber = null;
          }
        }
        var gw = class {
          constructor() {
            this.mediaType = null, this.t = null, this.type = null, this.startTime = null, this.availabilityStartTime = null, this.duration = null, this.bandwidth = null, this.range = null, this.state = null;
          }
        }, cw = class {
          constructor() {
            this.loadingRequests = [], this.executedRequests = [];
          }
        };
        function II(A) {
          const f = (A = A || {}).settings;
          let C, _, v = this.context, M = (0, Mt.A)(v).getInstance();
          function Y() {
            M.trigger(at.A.METRICS_CHANGED);
          }
          function H(F) {
            M.trigger(at.A.METRIC_CHANGED, { mediaType: F }), Y();
          }
          function L(F, et, it) {
            M.trigger(at.A.METRIC_UPDATED, { mediaType: F, metric: et, value: it }), H(F);
          }
          function W(F, et, it) {
            M.trigger(at.A.METRIC_ADDED, { mediaType: F, metric: et, value: it }), H(F);
          }
          function K(F, et) {
            let it = null;
            return F && (_.hasOwnProperty(F) ? it = _[F] : et || (it = new ew(), _[F] = it)), it;
          }
          function R(F, et, it) {
            let st = K(F);
            st !== null && (st[et].push(it), st[et].length > f.get().streaming.metrics.maxListDepth && st[et].shift());
          }
          function G(F, et, it) {
            R(F, et, it), W(F, et, it);
          }
          return C = { addBufferLevel: function(F, et, it) {
            let st = new iw();
            st.t = et, st.level = it, G(F, yt.BUFFER_LEVEL, st);
          }, addBufferState: function(F, et, it) {
            let st = new rw();
            st.target = it, st.state = et, G(F, yt.BUFFER_STATE, st);
          }, addDVBErrors: function(F) {
            G(X.A.STREAM, yt.DVB_ERRORS, F);
          }, addDVRInfo: function(F, et, it, st) {
            let ot = new sw();
            ot.time = et, ot.range = st, ot.manifestInfo = it, G(F, yt.DVR_INFO, ot);
          }, addDroppedFrames: function(F, et) {
            let it = new ow(), st = K(F).DroppedFrames;
            et && (it.time = et.creationTime, it.droppedFrames = et.droppedVideoFrames, st.length > 0 && st[st.length - 1] == it || G(F, yt.DROPPED_FRAMES, it));
          }, addHttpRequest: function F(et, it, st, ot) {
            let ut = new Ht.G();
            it.url && it.url !== et.url && (F({ mediaType: et.mediaType, type: et.type, url: et.url, serviceLocation: null, range: et.range, startDate: et.startDate, firstByteDate: null, endDate: null, duration: et.duration, fileLoaderType: et.fileLoaderType, resourceTimingValues: et.resourceTimingValues }, { url: null, status: null, headers: null }, null, ot), ut.actualurl = it.url), ut.tcpid = null, ut.type = et.type, ut.url = et.url, ut.range = et.range || null, ut.trequest = et.startDate, ut.tresponse = et.firstByteDate, ut.responsecode = it.status, ut.cmsd = ot, ut._tfinish = et.endDate, ut._stream = et.mediaType, ut._mediaduration = et.duration, ut._responseHeaders = "";
            for (const mt in it.headers) ut._responseHeaders += mt + ": " + it.headers[mt] + `\r
`;
            ut._serviceLocation = et.serviceLocation || null, ut._fileLoaderType = et.fileLoaderType, ut._resourceTimingValues = et.resourceTimingValues, ut._streamId = et && et.representation && et.representation.mediaInfo && et.representation.mediaInfo.streamInfo ? et.representation.mediaInfo.streamInfo.id : null, st ? st.forEach((mt) => {
              (function(wt, $, P, j) {
                let J = new Ht.N();
                J.s = $, J.d = P, J.b = j, wt.trace.push(J), wt.interval || (wt.interval = 0), wt.interval += P;
              })(ut, mt.s, mt.d, mt.b, mt.t);
            }) : (delete ut.interval, delete ut.trace), G(et.mediaType, yt.HTTP_REQUEST, ut);
          }, addManifestUpdate: function(F, et, it, st) {
            let ot = new lw();
            ot.mediaType = F, ot.type = et, ot.requestTime = it, ot.fetchTime = st, R(X.A.STREAM, yt.MANIFEST_UPDATE, ot), W(F, yt.MANIFEST_UPDATE, ot);
          }, addManifestUpdateRepresentationInfo: function(F, et, it) {
            if (F && F.representationInfo) {
              const st = new dw();
              st.id = et ? et.id : null, st.index = et ? et.index : null, st.mediaType = it, st.startNumber = et ? et.startNumber : null, st.presentationTimeOffset = et ? et.presentationTimeOffset : null, F.representationInfo.push(st), L(F.mediaType, yt.MANIFEST_UPDATE_TRACK_INFO, F);
            }
          }, addManifestUpdateStreamInfo: function(F, et, it, st, ot) {
            if (F) {
              let ut = new uw();
              ut.id = et, ut.index = it, ut.start = st, ut.duration = ot, F.streamInfo.push(ut), L(F.mediaType, yt.MANIFEST_UPDATE_STREAM_INFO, F);
            }
          }, addPlayList: function(F) {
            F.trace && Array.isArray(F.trace) ? F.trace.forEach((et) => {
              et.hasOwnProperty("subreplevel") && !et.subreplevel && delete et.subreplevel;
            }) : delete F.trace, G(X.A.STREAM, yt.PLAY_LIST, F);
          }, addRepresentationSwitch: function(F, et, it, st, ot) {
            let ut = new aw();
            ut.t = et, ut.mt = it, ut.to = st, ot ? ut.lto = ot : delete ut.lto, G(F, yt.TRACK_SWITCH, ut);
          }, addRequestsQueue: function(F, et, it) {
            let st = new cw();
            st.loadingRequests = et, st.executedRequests = it, K(F).RequestsQueue = st, W(F, yt.REQUESTS_QUEUE, st);
          }, addSchedulingInfo: function(F, et, it, st, ot, ut, mt, wt, $) {
            let P = new gw();
            P.mediaType = F, P.t = et, P.type = it, P.startTime = st, P.availabilityStartTime = ot, P.duration = ut, P.bandwidth = mt, P.range = wt, P.state = $, G(F, yt.SCHEDULING_INFO, P);
          }, clearAllCurrentMetrics: function() {
            _ = {}, Y();
          }, clearCurrentMetricsForType: function(F) {
            delete _[F], H(F);
          }, getMetricsFor: K, updateManifestUpdateInfo: function(F, et) {
            if (F) {
              for (let it in et) F[it] = et[it];
              L(F.mediaType, yt.MANIFEST_UPDATE, F);
            }
          } }, _ = {}, C;
        }
        II.__dashjs_factory_name = "MetricsModel";
        var mw = Bt.A.getSingletonFactory(II);
        function CI(A) {
          A = A || {};
          const f = this.context;
          let C, _, v, M, Y = A.metricsModel;
          function H(K) {
            const R = Y.getMetricsFor(K, !0);
            if (!R) return null;
            const G = R.HttpList;
            let F, et = null;
            if (!G || G.length <= 0) return null;
            for (F = G.length - 1; F >= 0; ) {
              if (G[F].responsecode) {
                et = G[F];
                break;
              }
              F--;
            }
            return et;
          }
          function L(K) {
            const R = Y.getMetricsFor(K, !0);
            return R && R.HttpList ? R.HttpList : [];
          }
          function W(K, R) {
            if (!K) return null;
            const G = K[R];
            return G && G.length !== 0 ? G[G.length - 1] : null;
          }
          return C = { getCurrentRepresentationSwitch: function(K) {
            return W(Y.getMetricsFor(K, !0), yt.TRACK_SWITCH);
          }, getCurrentBufferState: function(K) {
            return W(Y.getMetricsFor(K, !0), yt.BUFFER_STATE);
          }, getCurrentBufferLevel: function(K) {
            const R = W(Y.getMetricsFor(K, !0), yt.BUFFER_LEVEL);
            return R ? tw.round10(R.level / 1e3, -3) : 0;
          }, getCurrentHttpRequest: H, getHttpRequests: L, getCurrentDroppedFrames: function() {
            return W(Y.getMetricsFor(X.A.VIDEO, !0), yt.DROPPED_FRAMES);
          }, getCurrentSchedulingInfo: function(K) {
            return W(Y.getMetricsFor(K, !0), yt.SCHEDULING_INFO);
          }, getCurrentDVRInfo: function(K) {
            return W(K ? Y.getMetricsFor(K, !0) : Y.getMetricsFor(X.A.VIDEO, !0) || Y.getMetricsFor(X.A.AUDIO, !0) || Y.getMetricsFor(X.A.MESH, !0), yt.DVR_INFO);
          }, getCurrentManifestUpdate: function() {
            return W(Y.getMetricsFor(X.A.STREAM), yt.MANIFEST_UPDATE);
          }, getLatestFragmentRequestHeaderValueByID: function(K, R) {
            if (!R) return null;
            let G = {}, F = H(K);
            F && (G = jn.A.parseHttpHeaders(F._responseHeaders));
            const et = G[R.toLowerCase()];
            return et === void 0 ? null : et;
          }, getLatestMPDRequestHeaderValueByID: function(K) {
            if (!K) return null;
            let R, G, F, et = {};
            for (R = L(X.A.STREAM), F = R.length - 1; F >= 0; F--) if (G = R[F], G.type === Ht.G.MPD_TYPE) {
              et = jn.A.parseHttpHeaders(G._responseHeaders);
              break;
            }
            const it = et[K.toLowerCase()];
            return it === void 0 ? null : it;
          }, addRepresentationSwitch: function(K, R, G, F, et) {
            Y.addRepresentationSwitch(K, R, G, F, et);
          }, addDVRInfo: function(K, R, G, F) {
            Y.addDVRInfo(K, R, G, F);
          }, updateManifestUpdateInfo: function(K) {
            const R = this.getCurrentManifestUpdate();
            Y.updateManifestUpdateInfo(R, K);
          }, addManifestUpdateStreamInfo: function(K) {
            if (K) {
              const R = this.getCurrentManifestUpdate();
              Y.addManifestUpdateStreamInfo(R, K.id, K.index, K.start, K.duration);
            }
          }, addManifestUpdateRepresentationInfo: function(K, R) {
            if (K) {
              const G = this.getCurrentManifestUpdate();
              Y.addManifestUpdateRepresentationInfo(G, K, R);
            }
          }, addManifestUpdate: function(K) {
            Y.addManifestUpdate(X.A.STREAM, K.type, K.startDate, K.endDate);
          }, addHttpRequest: function(K, R, G, F, et, it) {
            const st = { status: G, headers: F, url: R };
            Y.addHttpRequest(K, st, et, it);
          }, addSchedulingInfo: function(K, R) {
            Y.addSchedulingInfo(K.mediaType, /* @__PURE__ */ new Date(), K.type, K.startTime, K.availabilityStartTime, K.duration, K.bandwidth, K.range, R);
          }, addRequestsQueue: function(K, R, G) {
            Y.addRequestsQueue(K, R, G);
          }, addBufferLevel: function(K, R, G) {
            Y.addBufferLevel(K, R, G);
          }, addBufferState: function(K, R, G) {
            Y.addBufferState(K, R, G);
          }, addDroppedFrames: function(K) {
            Y.addDroppedFrames(X.A.VIDEO, K);
          }, addPlayList: function() {
            M && (Y.addPlayList(M), M = null);
          }, addDVBErrors: function(K) {
            Y.addDVBErrors(K);
          }, createPlaylistMetrics: function(K, R) {
            M = new Ae(), M.start = /* @__PURE__ */ new Date(), M.mstart = K, M.starttype = R;
          }, createPlaylistTraceMetrics: function(K, R, G) {
            _ === !0 && (_ = !1, v = new be(), v.representationid = K, v.start = /* @__PURE__ */ new Date(), v.mstart = R, v.playbackspeed = G !== null ? G.toString() : null);
          }, updatePlayListTraceMetrics: function(K) {
            if (v) for (let R in v) v[R] = K[R];
          }, pushPlayListTraceMetrics: function(K, R) {
            if (_ === !1 && M && v && v.start) {
              const G = v.start;
              v.duration = K.getTime() - G.getTime(), v.stopreason = R, M.trace.push(v), _ = !0;
            }
          }, clearAllCurrentMetrics: function() {
            Y.clearAllCurrentMetrics();
          } }, Y = Y || mw(f).getInstance({ settings: A.settings }), _ = !0, v = null, M = null, C;
        }
        CI.__dashjs_factory_name = "DashMetrics";
        var fw = Bt.A.getSingletonFactory(CI);
        function yI() {
          const A = this.context, f = (0, Mt.A)(A).getInstance(), C = (0, tt.A)(A).getInstance();
          let _, v, M, Y;
          function H(ot) {
            Y = ot;
          }
          function L(ot, ut, mt, wt) {
            let $, P = ut.adaptation.period.mpd;
            const j = P.availabilityStartTime;
            if (wt) $ = mt && P.timeShiftBufferDepth !== Number.POSITIVE_INFINITY ? new Date(j.getTime() + 1e3 * (ot + P.timeShiftBufferDepth)) : P.availabilityEndTime;
            else if (mt) {
              let J = ua(ut.availabilityTimeOffset);
              $ = new Date(j.getTime() + 1e3 * (ot - J));
            } else $ = j;
            return $;
          }
          function W(ot, ut) {
            return (ot.getTime() - ut.mpd.availabilityStartTime.getTime() + 1e3 * Y) / 1e3;
          }
          function K(ot, ut) {
            return ot + (ut.adaptation.period.start - ut.presentationTimeOffset);
          }
          function R(ot) {
            const ut = { start: NaN, end: NaN }, mt = ot[0].getAdapter().getRegularPeriods()[0], wt = W(/* @__PURE__ */ new Date(), mt);
            if (!ot || ot.length === 0) return { range: ut, now: wt };
            ot.forEach((P) => {
              let j = P.getCurrentRepresentationForType(X.A.VIDEO);
              if (j || (j = P.getCurrentRepresentationForType(X.A.AUDIO)), !j) {
                const ht = P.getAdapter(), _t = ht.getMediaInfoForType(P.getStreamInfo(), X.A.VIDEO) || ht.getMediaInfoForType(P.getStreamInfo(), X.A.AUDIO) || ht.getMediaInfoForType(P.getStreamInfo(), X.A.MESH);
                j = ht.getVoRepresentations(_t)[0];
              }
              let J = { start: NaN, end: NaN };
              if (j) if (j.segmentInfoType === D.A.SEGMENT_TIMELINE) J = function(ht) {
                const _t = ht.adaptation.period.mpd.manifest.Period[ht.adaptation.period.index].AdaptationSet[ht.adaptation.index], Ct = v.getRepresentationFor(ht.index, _t), bt = Ct.SegmentTemplate || Ct.SegmentList, Rt = bt.SegmentTimeline, xt = bt.timescale, Pt = Rt.S, N = { start: 0, end: 0 }, ct = Pt[0].t, It = !isNaN(ct), dt = It ? ct : 0;
                let nt, ft, rt, Et, kt = 0;
                for (It && (N.start = K(dt / xt, ht)), rt = 0, Et = Pt.length; rt < Et; rt++) nt = Pt[rt], ft = 0, nt.hasOwnProperty("r") && (ft = nt.r), kt += nt.d * (1 + ft);
                return N.end = K((dt + kt) / xt, ht), N;
              }(j);
              else {
                const ht = j.adaptation.period;
                J.start = ht.start, J.end = Math.max(wt, ht.start + ht.duration);
              }
              !isNaN(J.start) && (isNaN(ut.start) || ut.start > J.start) && (ut.start = J.start), !isNaN(J.end) && (isNaN(ut.end) || ut.end < J.end) && (ut.end = J.end);
            }), ut.end = Math.min(wt, ut.end);
            const $ = F(ot, ut.end, !0);
            return ut.end = isNaN($) ? ut.end : $, ut.start = mt && mt.mpd && mt.mpd.timeShiftBufferDepth && !isNaN(mt.mpd.timeShiftBufferDepth) && !isNaN(ut.end) ? Math.max(ut.end - mt.mpd.timeShiftBufferDepth, ut.start) : ut.start, ut.start = F(ot, ut.start), { range: ut, now: wt };
          }
          function G(ot, ut) {
            M = ot - ut.end;
          }
          function F(ot, ut) {
            let mt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            try {
              let wt = 0, $ = !1, P = NaN;
              for (; !$ && wt < ot.length; ) {
                const j = ot[wt].getStreamInfo();
                j.start <= ut && (!isFinite(j.duration) || j.start + j.duration >= ut) ? (P = ut, $ = !0) : !mt && j.start > ut && (isNaN(P) || j.start < P) ? P = j.start : mt && j.start + j.duration < ut && (isNaN(P) || j.start + j.duration > P) && (P = j.start + j.duration), wt += 1;
              }
              return P;
            } catch (wt) {
              return ut;
            }
          }
          function et(ot) {
            ot.offset === void 0 || isNaN(ot.offset) || H(ot.offset / 1e3);
          }
          function it() {
            Y = 0, M = 0;
          }
          function st() {
            f.off(at.A.UPDATE_TIME_SYNC_OFFSET, et, this), it();
          }
          return _ = { initialize: function() {
            it(), f.on(at.A.UPDATE_TIME_SYNC_OFFSET, et, this);
          }, getClientTimeOffset: function() {
            return Y;
          }, setClientTimeOffset: H, getClientReferenceTime: function() {
            return Date.now() - 1e3 * M + 1e3 * Y;
          }, calcAvailabilityStartTimeFromPresentationTime: function(ot, ut, mt) {
            return L(ot, ut, mt);
          }, calcAvailabilityEndTimeFromPresentationTime: function(ot, ut, mt) {
            return L(ot, ut, mt, !0);
          }, calcPresentationTimeFromWallTime: W, calcPresentationTimeFromMediaTime: K, calcPeriodRelativeTimeFromMpdRelativeTime: function(ot, ut) {
            return ut - ot.adaptation.period.start;
          }, calcMediaTimeFromPresentationTime: function(ot, ut) {
            return ot - ut.adaptation.period.start + ut.presentationTimeOffset;
          }, calcWallTimeForSegment: function(ot, ut) {
            let mt, wt, $;
            return ut && (mt = ot.representation.adaptation.period.mpd.suggestedPresentationDelay, wt = ot.presentationStartTime + mt, $ = new Date(ot.availabilityStartTime.getTime() + 1e3 * wt)), $;
          }, calcTimeShiftBufferWindow: function(ot, ut) {
            if (!ut) return function(mt) {
              const wt = { start: NaN, end: NaN };
              let $ = 0, P = NaN;
              return mt.forEach((j) => {
                const J = j.getStreamInfo();
                $ += J.duration, (isNaN(P) || J.start < P) && (P = J.start);
              }), wt.start = P, wt.end = P + $, wt;
            }(ot);
            if (C.get().streaming.timeShiftBuffer.calcFromSegmentTimeline) {
              const mt = R(ot);
              return G(mt.now, mt.range), mt.range;
            }
            return function(mt) {
              const wt = { start: NaN, end: NaN };
              if (!mt || mt.length === 0) return wt;
              const $ = mt[0].getAdapter().getRegularPeriods()[0], P = W(/* @__PURE__ */ new Date(), $), j = $.mpd.timeShiftBufferDepth, J = isNaN(j) ? 0 : P - j;
              if (wt.start = F(mt, J), wt.end = !isNaN(wt.start) && P < wt.start ? P : F(mt, P, !0), !isNaN(j) && wt.end < P - j && (wt.end = NaN), C.get().streaming.timeShiftBuffer.fallbackToSegmentTimeline) {
                const ht = R(mt);
                if (ht.range.end < wt.start) return f.trigger(At.A.CONFORMANCE_VIOLATION, { level: Na.LEVELS.WARNING, event: Na.EVENTS.INVALID_DVR_WINDOW }), G(ht.now, ht.range), ht.range;
              }
              return wt;
            }(ot);
          }, reset: st }, v = si(A).getInstance(), st(), _;
        }
        yI.__dashjs_factory_name = "TimelineConverter";
        var _r, Gc, au, Rd, zc, hw = Bt.A.getSingletonFactory(yI), pw = function(A) {
          for (var f = [], C = 0; C < A.length; ++C) {
            var _ = A.charCodeAt(C);
            _ < 128 ? f.push(_) : _ < 2048 ? (f.push(192 | _ >> 6), f.push(128 | 63 & _)) : _ < 65536 ? (f.push(224 | _ >> 12), f.push(128 | 63 & _ >> 6), f.push(128 | 63 & _)) : (f.push(240 | _ >> 18), f.push(128 | 63 & _ >> 12), f.push(128 | 63 & _ >> 6), f.push(128 | 63 & _));
          }
          return f;
        }, Iw = function(A) {
          for (var f = [], C = 0; C < A.length; ) {
            var _ = A[C++];
            _ < 128 || (_ < 224 ? (_ = (31 & _) << 6, _ |= 63 & A[C++]) : _ < 240 ? (_ = (15 & _) << 12, _ |= (63 & A[C++]) << 6, _ |= 63 & A[C++]) : (_ = (7 & _) << 18, _ |= (63 & A[C++]) << 12, _ |= (63 & A[C++]) << 6, _ |= 63 & A[C++])), f.push(String.fromCharCode(_));
          }
          return f.join("");
        }, zr = {};
        _r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Gc = function(A) {
          for (var f = 0, C = [], _ = 0 | A.length / 3; 0 < _--; ) {
            var v = (A[f] << 16) + (A[f + 1] << 8) + A[f + 2];
            f += 3, C.push(_r.charAt(63 & v >> 18)), C.push(_r.charAt(63 & v >> 12)), C.push(_r.charAt(63 & v >> 6)), C.push(_r.charAt(63 & v));
          }
          return A.length - f == 2 ? (v = (A[f] << 16) + (A[f + 1] << 8), C.push(_r.charAt(63 & v >> 18)), C.push(_r.charAt(63 & v >> 12)), C.push(_r.charAt(63 & v >> 6)), C.push("=")) : A.length - f == 1 && (v = A[f] << 16, C.push(_r.charAt(63 & v >> 18)), C.push(_r.charAt(63 & v >> 12)), C.push("==")), C.join("");
        }, au = function() {
          for (var A = [], f = 0; f < 64; ++f) A[_r.charCodeAt(f)] = f;
          return A[61] = 0, A;
        }(), Rd = function(A) {
          for (var f = 0, C = [], _ = 0 | A.length / 4; 0 < _--; ) {
            var v = (au[A.charCodeAt(f)] << 18) + (au[A.charCodeAt(f + 1)] << 12) + (au[A.charCodeAt(f + 2)] << 6) + au[A.charCodeAt(f + 3)];
            C.push(255 & v >> 16), C.push(255 & v >> 8), C.push(255 & v), f += 4;
          }
          return C && (A.charAt(f - 2) == "=" ? (C.pop(), C.pop()) : A.charAt(f - 1) == "=" && C.pop()), C;
        }, zc = { encode: function(A) {
          for (var f = [], C = 0; C < A.length; ++C) f.push(A.charCodeAt(C));
          return f;
        }, decode: function(A) {
          for (var f = 0; f < s.length; ++f) a[f] = String.fromCharCode(a[f]);
          return a.join("");
        } }, zr.decodeArray = function(A) {
          var f = Rd(A);
          return new Uint8Array(f);
        }, zr.encodeASCII = function(A) {
          var f = zc.encode(A);
          return Gc(f);
        }, zr.decodeASCII = function(A) {
          var f = Rd(A);
          return zc.decode(f);
        }, zr.encode = function(A) {
          var f = pw(A);
          return Gc(f);
        }, zr.decode = function(A) {
          var f = Rd(A);
          return Iw(f);
        }, e.decode = zr.decode, e.decodeArray = zr.decodeArray, e.encode = zr.encode, e.encodeASCII = zr.encodeASCII;
        var Yc = zr, Cw = class extends xc {
          constructor() {
            super(), this.captionData = null, this.label = null, this.defaultTrack = !1, this.kind = null, this.isFragmented = !1, this.isEmbedded = !1, this.isTTML = null;
          }
        }, yw = w(7377);
        function AI() {
          let A, f = 0;
          function C(L) {
            let W = "";
            for (let K = 0; K < L.length; ++K) W += L[K].uchar;
            return W.length - W.replace(/^\s+/, "").length;
          }
          function _(L) {
            return "left: " + 3.125 * L.x + "%; top: " + 6.66 * L.y1 + "%; width: " + (100 - 3.125 * L.x) + "%; height: " + 6.66 * Math.max(L.y2 - 1 - L.y1, 1) + "%; align-items: flex-start; overflow: visible; -webkit-writing-mode: horizontal-tb;";
          }
          function v(L) {
            return L === "red" ? "rgb(255, 0, 0)" : L === "green" ? "rgb(0, 255, 0)" : L === "blue" ? "rgb(0, 0, 255)" : L === "cyan" ? "rgb(0, 255, 255)" : L === "magenta" ? "rgb(255, 0, 255)" : L === "yellow" ? "rgb(255, 255, 0)" : L === "white" ? "rgb(255, 255, 255)" : L === "black" ? "rgb(0, 0, 0)" : L;
          }
          function M(L, W) {
            const K = L.videoHeight / 15;
            return W ? "font-size: " + K + "px; font-family: Menlo, Consolas, 'Cutive Mono', monospace; color: " + (W.foreground ? v(W.foreground) : "rgb(255, 255, 255)") + "; font-style: " + (W.italics ? "italic" : "normal") + "; text-decoration: " + (W.underline ? "underline" : "none") + "; white-space: pre; background-color: " + (W.background ? v(W.background) : "transparent") + ";" : "font-size: " + K + "px; font-family: Menlo, Consolas, 'Cutive Mono', monospace; justify-content: flex-start; text-align: left; color: rgb(255, 255, 255); font-style: normal; white-space: pre; line-height: normal; font-weight: normal; text-decoration: none; width: 100%; display: flex;";
          }
          function Y(L) {
            return L.replace(/^\s+/g, "");
          }
          function H(L) {
            return L.replace(/\s+$/g, "");
          }
          return A = { createHTMLCaptionsFromScreen: function(L, W, K, R) {
            let G = null, F = null, et = !1, it = -1, st = { start: W, end: K, spans: [] }, ot = "style_cea608_white_black";
            const ut = {}, mt = {}, wt = [];
            let $, P;
            for ($ = 0; $ < 15; ++$) {
              const J = R.rows[$];
              let ht = "", _t = null;
              if (J.isEmpty() === !1) {
                const Ct = C(J.chars);
                G === null && (G = { x: Ct, y1: $, y2: $ + 1, p: [] }), Ct !== it && et && (G.p.push(st), st = { start: W, end: K, spans: [] }, G.y2 = $, G.name = "region_" + G.x + "_" + G.y1 + "_" + G.y2, ut.hasOwnProperty(G.name) === !1 ? (wt.push(G), ut[G.name] = G) : (F = ut[G.name], F.p.contat(G.p)), G = { x: Ct, y1: $, y2: $ + 1, p: [] });
                for (let bt = 0; bt < J.chars.length; ++bt) {
                  const Rt = J.chars[bt], xt = Rt.penState;
                  if (_t === null || !xt.equals(_t)) {
                    ht.trim().length > 0 && (st.spans.push({ name: ot, line: ht, row: $ }), ht = "");
                    let Pt = "style_cea608_" + xt.foreground + "_" + xt.background;
                    xt.underline && (Pt += "_underline"), xt.italics && (Pt += "_italics"), mt.hasOwnProperty(Pt) || (mt[Pt] = JSON.parse(JSON.stringify(xt))), _t = xt, ot = Pt;
                  }
                  ht += Rt.uchar;
                }
                ht.trim().length > 0 && st.spans.push({ name: ot, line: ht, row: $ }), et = !0, it = Ct;
              } else et = !1, it = -1, G && (G.p.push(st), st = { start: W, end: K, spans: [] }, G.y2 = $, G.name = "region_" + G.x + "_" + G.y1 + "_" + G.y2, ut.hasOwnProperty(G.name) === !1 ? (wt.push(G), ut[G.name] = G) : (F = ut[G.name], F.p.contat(G.p)), G = null);
            }
            G && (G.p.push(st), G.y2 = $ + 1, G.name = "region_" + G.x + "_" + G.y1 + "_" + G.y2, ut.hasOwnProperty(G.name) === !1 ? (wt.push(G), ut[G.name] = G) : (F = ut[G.name], F.p.contat(G.p)), G = null);
            const j = [];
            for ($ = 0; $ < wt.length; ++$) {
              const J = wt[$], ht = "sub_cea608_" + f++, _t = document.createElement("div");
              _t.id = ht;
              const Ct = _(J);
              _t.style.cssText = "position: absolute; margin: 0; display: flex; box-sizing: border-box; pointer-events: none;" + Ct;
              const bt = document.createElement("div");
              bt.className = "paragraph bodyStyle", bt.style.cssText = M(L);
              const Rt = document.createElement("div");
              Rt.className = "cueUniWrapper", Rt.style.cssText = "unicode-bidi: normal; direction: ltr;";
              for (let Pt = 0; Pt < J.p.length; ++Pt) {
                const N = J.p[Pt];
                let ct = 0;
                for (P = 0; P < N.spans.length; ++P) {
                  let It = N.spans[P];
                  if (It.line.length > 0) {
                    if (P !== 0 && ct != It.row) {
                      const rt = document.createElement("br");
                      rt.className = "lineBreak", Rt.appendChild(rt);
                    }
                    let dt = !1;
                    ct === It.row && (dt = !0), ct = It.row;
                    const nt = mt[It.name], ft = document.createElement("span");
                    ft.className = "spanPadding " + It.name + " customSpanColor", ft.style.cssText = M(L, nt), P !== 0 && dt ? P === N.spans.length - 1 ? ft.textContent = H(It.line) : ft.textContent = It.line : N.spans.length > 1 && P < N.spans.length - 1 && It.row === N.spans[P + 1].row ? ft.textContent = Y(It.line) : ft.textContent = It.line.trim(), Rt.appendChild(ft);
                  }
                }
              }
              bt.appendChild(Rt), _t.appendChild(bt);
              const xt = { bodyStyle: ["%", 90] };
              for (const Pt in mt) mt.hasOwnProperty(Pt) && (xt[Pt] = ["%", 90]);
              j.push({ type: "html", start: W, end: K, cueHTMLElement: _t, cueID: ht, cellResolution: [32, 15], isFromCEA608: !0, fontSize: xt, lineHeight: {}, linePadding: {} });
            }
            return j;
          } }, A;
        }
        AI.__dashjs_factory_name = "EmbeddedTextHtmlRender";
        var Aw = Bt.A.getSingletonFactory(AI);
        function _w(A, f, C) {
          const _ = [];
          for (let v = f; v < C; v++) v + 2 < C && A.getUint8(v) === 0 && A.getUint8(v + 1) === 0 && A.getUint8(v + 2) === 3 ? (_.push(0), _.push(0), v += 2) : _.push(A.getUint8(v));
          return new DataView(new Uint8Array(_).buffer);
        }
        function bw(A, f, C, _) {
          return !(A !== 4 || f < 8) && C.getUint8(_) === 181 && C.getUint16(_ + 1) === 49 && C.getUint32(_ + 3) === 1195456820 && C.getUint8(_ + 7) === 3;
        }
        function Sw(A, f) {
          return (127 & A) > 0 || (127 & f) > 0;
        }
        function ww(A, f) {
          let C = 0;
          for (; C < A.byteLength; ) {
            let v, M = 0, Y = 0;
            do
              M += v = A.getUint8(C++);
            while (v === 255);
            do
              Y += v = A.getUint8(C++);
            while (v === 255);
            if (bw(M, Y, A, C)) {
              const H = C + 10, L = H + 3 * (31 & A.getUint8(H - 2));
              for (let W = H; W < L; W += 3) {
                const K = A.getUint8(W);
                if (4 & K) {
                  const R = 3 & K;
                  if ((_ = R) === 0 || _ === 1) {
                    const G = A.getUint8(W + 1), F = A.getUint8(W + 2);
                    Sw(G, F) && f[R].push(G, F);
                  }
                }
              }
            }
            C += Y;
          }
          var _;
        }
        function vw(A, f, C) {
          let _ = 0, v = 0;
          const M = [[], []];
          for (let Y = f; Y < f + C - 5 && (_ = A.getUint32(Y), v = 31 & A.getUint8(Y + 4), !(Y + 5 + _ > f + C)); Y++) v === 6 && Y + 5 + _ <= A.byteLength && ww(_w(A, Y + 5, Y + 5 + _), M), Y += _ + 3;
          return M;
        }
        function _I(A) {
          const f = A.errHandler, C = A.manifestModel, _ = A.mediaController, v = A.videoModel, M = A.textTracks, Y = A.vttParser, H = A.vttCustomRenderingParser, L = A.ttmlParser, W = A.streamInfo, K = A.settings, R = this.context, G = (0, Mt.A)(R).getInstance();
          let F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht, _t, Ct, bt, Rt, xt = !1;
          function Pt() {
            ut = null, wt = NaN, $ = [], P = null, mt = !1, ot = [], st = null;
          }
          function N(Dt) {
            const Ut = {};
            Ut[D.A.SUBTITLE] = "subtitles", Ut[D.A.CAPTION] = "captions", Ut[D.A.FORCED_SUBTITLE] = "subtitles";
            const Wt = new Cw();
            for (let ie in Dt) Wt[ie] = Dt[ie];
            Wt.defaultTrack = function(ie) {
              let de = !1;
              return J.length > 1 && ie.isEmbedded ? de = ie.id && ie.id === X.A.CC1 : J.length === 1 ? ie.id && typeof ie.id == "string" && ie.id.substring(0, 2) === "CC" && (de = !0) : J.length === 0 && (de = ie.index === ot[0].index), de;
            }(Dt), Wt.isTTML = function(ie) {
              return ie.codec && ie.codec.search(X.A.STPP) >= 0 || ie.mimeType && ie.mimeType.search(X.A.TTML) >= 0;
            }(Dt), Wt.kind = function(ie, de) {
              let Be = ie.roles && ie.roles.length > 0 ? de[ie.roles[0].value] : de.caption;
              return Be = Object.values(de).includes(Be) ? Be : de.caption, Be;
            }(Dt, Ut), M.addTextTrackInfo(Wt);
          }
          function ct(Dt) {
            const Ut = Dt.chunk;
            Ut.representation.mediaInfo.embeddedCaptions && dt(Ut.bytes, Ut);
          }
          function It(Dt) {
            j = Dt;
          }
          function dt(Dt, Ut) {
            const Wt = Ut.representation.mediaInfo, ie = Wt.type, de = Wt.mimeType, Be = Wt.codec || de;
            Be ? Wt.codec.indexOf("application/mp4") !== -1 ? function(Oe, nn, _n) {
              let ke, rn;
              if (nn.segmentType === "InitializationSegment") mt = !0, wt = it.getMediaTimescaleFromMoov(Oe);
              else {
                if (!mt) return;
                rn = it.getSamplesInfo(Oe), ke = rn.sampleList, ke.length > 0 && (P = ke[0].cts - nn.start * wt), _n.search(X.A.STPP) >= 0 ? function(Cn, Nn, Gn) {
                  let Xt, ce;
                  for (st = st !== null ? st : rt(Gn), Xt = 0; Xt < Nn.length; Xt++) {
                    const oe = Nn[Xt], pe = oe.cts, en = ft(), mn = en + pe / wt, se = mn + oe.duration / wt;
                    F.buffered.add(mn, se);
                    const Ke = new DataView(Cn, oe.offset, oe.subSizes[0]);
                    let qe = go.Utils.dataViewToString(Ke, X.A.UTF8);
                    const Ze = [];
                    let tn = oe.offset + oe.subSizes[0];
                    for (ce = 1; ce < oe.subSizes.length; ce++) {
                      const $t = new Uint8Array(Cn, tn, oe.subSizes[ce]), Se = String.fromCharCode.apply(null, $t);
                      Ze.push(Se), tn += oe.subSizes[ce];
                    }
                    try {
                      const $t = C.getValue().ttmlTimeIsRelative ? pe / wt : 0, Se = st.parse(qe, $t, pe / wt, (pe + oe.duration) / wt, Ze);
                      M.addCaptions(j, en, Se);
                    } catch ($t) {
                      ut.removeExecutedRequestsBeforeTime(), Et(), et.error("TTML parser error: " + $t);
                    }
                  }
                }(Oe, ke, _n) : function(Cn, Nn) {
                  let Gn, Xt, ce;
                  const oe = [];
                  for (Gn = 0; Gn < Nn.length; Gn++) {
                    const pe = Nn[Gn];
                    pe.cts -= P;
                    const en = ft() + pe.cts / wt, mn = en + pe.duration / wt;
                    F.buffered.add(en, mn);
                    const se = Cn.slice(pe.offset, pe.offset + pe.size), Ke = go.parseBuffer(se);
                    for (Xt = 0; Xt < Ke.boxes.length; Xt++) {
                      const qe = Ke.boxes[Xt];
                      if (et.debug("VTT box1: " + qe.type), qe.type !== "vtte" && qe.type === "vttc") {
                        et.debug("VTT vttc boxes.length = " + qe.boxes.length);
                        let Ze = { styles: {} };
                        for (ce = 0; ce < qe.boxes.length; ce++) {
                          const tn = qe.boxes[ce];
                          if (et.debug("VTT box2: " + tn.type), tn.type === "payl") Ze.start = pe.cts / wt, Ze.end = (pe.cts + pe.duration) / wt, Ze.data = tn.cue_text;
                          else if (tn.type === "sttg" && tn.settings && tn.settings !== "") try {
                            const $t = tn.settings.split(" ");
                            Ze.styles = Y.getCaptionStyles($t);
                          } catch ($t) {
                          }
                        }
                        Ze && Ze.data && (oe.push(Ze), et.debug(`VTT  ${Ze.start} - ${Ze.end} :  ${Ze.data}`));
                      }
                    }
                  }
                  oe.length > 0 && M.addCaptions(j, 0, oe);
                }(Oe, ke);
              }
            }(Dt, Ut, Be) : ie === X.A.VIDEO ? function(Oe, nn) {
              let _n, ke;
              if (nn.segmentType === Ht.G.INIT_SEGMENT_TYPE) ht === 0 && (ht = it.getMediaTimescaleFromMoov(Oe));
              else if (nn.segmentType === Ht.G.MEDIA_SEGMENT_TYPE) {
                if (ht === 0) return void et.warn("CEA-608: No timescale for embeddedTextTrack yet");
                ke = it.getSamplesInfo(Oe);
                const rn = ke.lastSequenceNumber, Cn = Math.trunc(nn.start), Nn = Math.trunc(nn.end);
                if (bt[0] || bt[1] || function() {
                  let Gn;
                  for (let Xt = 0; Xt < J.length; Xt++) {
                    if (Gn = M.getTrackIdxForId(J[Xt].id), Gn === -1) return void et.warn("CEA-608: data before track is ready.");
                    const ce = nt(Gn);
                    bt[Xt] = new zt(Xt + 1, { newCue: ce }, null);
                  }
                }(), ht) {
                  if (function(Xt, ce, oe, pe, en) {
                    return Xt !== null && ce !== null && pe !== null && en !== null && (ce === Xt ? pe !== en : ce !== Xt + oe);
                  }(_t, rn, ke.numSequences, Ct, Cn)) for (_n = 0; _n < bt.length; _n++) bt[_n] && bt[_n].reset();
                  const Gn = function(Xt, ce) {
                    if (ce.length === 0) return null;
                    const oe = { splits: [], fields: [[], []] }, pe = new DataView(Xt);
                    for (let en = 0; en < ce.length; en++) {
                      const mn = ce[en], se = vw(pe, mn.offset, mn.size);
                      let Ke = null, qe = 0;
                      for (let Ze = 0; Ze < 2; Ze++) if (se[Ze].length > 0) {
                        mn.cts !== Ke ? qe = 0 : qe += 1;
                        const tn = ft();
                        oe.fields[Ze].push([mn.cts + tn * ht, se[Ze], qe]), Ke = mn.cts;
                      }
                    }
                    return oe.fields.forEach(function(en) {
                      en.sort(function(mn, se) {
                        return mn[0] === se[0] ? mn[2] - se[2] : mn[0] - se[0];
                      });
                    }), oe;
                  }(Oe, ke.sampleList);
                  for (let Xt = 0; Xt < bt.length; Xt++) {
                    const ce = Gn.fields[Xt], oe = bt[Xt];
                    if (oe) for (_n = 0; _n < ce.length; _n++) oe.addData(ce[_n][0] / ht, ce[_n][1]);
                  }
                  _t = rn, Ct = Nn;
                }
              }
            }(Dt, Ut) : function(Oe, nn, _n) {
              let ke, rn;
              const Cn = new DataView(Oe, 0, Oe.byteLength);
              rn = go.Utils.dataViewToString(Cn, X.A.UTF8);
              try {
                ke = rt(_n).parse(rn, 0), M.addCaptions(M.getCurrentTrackIdx(), 0, ke), F.buffered && F.buffered.add(nn.start, nn.end);
              } catch (Nn) {
                f.error(new Nt.A(q.TIMED_TEXT_ERROR_ID_PARSE_CODE, q.TIMED_TEXT_ERROR_MESSAGE_PARSE + Nn.message, rn));
              }
            }(Dt, Ut, Be) : et.error("No text type defined");
          }
          function nt(Dt) {
            return function(Ut, Wt, ie) {
              let de;
              de = v.getTTMLRenderingDiv() ? Rt.createHTMLCaptionsFromScreen(v.getElement(), Ut, Wt, ie) : [{ start: Ut, end: Wt, data: ie.getDisplayText(), styles: {} }], de && M.addCaptions(Dt, 0, de);
            };
          }
          function ft() {
            return isNaN(F.timestampOffset) ? 0 : F.timestampOffset;
          }
          function rt(Dt) {
            let Ut;
            return Dt.search(X.A.VTT) >= 0 ? Ut = K.get().streaming.text.webvtt.customRenderingEnabled && H ? H : Y : (Dt.search(X.A.TTML) >= 0 || Dt.search(X.A.STPP) >= 0) && (Ut = L), Ut;
          }
          function Et(Dt, Ut) {
            Dt === void 0 && Dt === Ut && (Dt = F.buffered.start(0), Ut = F.buffered.end(F.buffered.length - 1)), F.buffered.remove(Dt, Ut), M.deleteCuesFromTrackIdx(j, Dt, Ut);
          }
          function kt(Dt) {
            J.forEach(function(Ut) {
              const Wt = M.getTrackIdxForId(Ut.id);
              Wt >= 0 && M.deleteCuesFromTrackIdx(Wt, Dt.from, Dt.to);
            });
          }
          return F = { initialize: function() {
            xt || (J = [], j = null, ht = 0, bt = [], _t = null, Ct = null, xt = !0, Rt = Aw(R).getInstance(), G.on(at.A.VIDEO_CHUNK_RECEIVED, ct, F), G.on(at.A.BUFFER_CLEARED, kt, F));
          }, addMediaInfos: function(Dt, Ut, Wt) {
            if (ot = ot.concat(Ut), Dt === X.A.TEXT && Ut[0].isFragmented && !Ut[0].isEmbedded) {
              ut = Wt, F.buffered = (0, yw.A)(R).create(), $ = _.getTracksFor(X.A.TEXT, W.id).filter((de) => de.isFragmented);
              const ie = _.getCurrentTrackFor(X.A.TEXT, W.id);
              for (let de = 0; de < $.length; de++) if ($[de] === ie) {
                It(de);
                break;
              }
            }
            for (let ie = 0; ie < Ut.length; ie++) N(Ut[ie]);
          }, resetMediaInfos: function() {
            ot = [];
          }, getStreamId: function() {
            return W.id;
          }, append: dt, abort: function() {
          }, addEmbeddedTrack: function(Dt) {
            if (xt && Dt) if (Dt.id === X.A.CC1 || Dt.id === X.A.CC3) {
              for (let Ut = 0; Ut < J.length; Ut++) if (J[Ut].id === Dt.id) return;
              J.push(Dt);
            } else et.warn("Embedded track " + Dt.id + " not supported!");
          }, resetEmbedded: function() {
            G.off(at.A.VIDEO_CHUNK_RECEIVED, ct, F), G.off(at.A.BUFFER_CLEARED, kt, F), M && M.deleteAllTextTracks(), xt = !1, J = [], bt = [null, null], _t = null, Ct = null;
          }, getConfig: function() {
            return { fragmentModel: ut, fragmentedTracks: $, videoModel: v };
          }, setCurrentFragmentedTrackIdx: It, remove: Et, reset: function() {
            Pt(), ot = [], it = null;
          } }, et = (0, jt.A)(R).getInstance().getLogger(F), it = Vo(R).getInstance(), Pt(), F;
        }
        _I.__dashjs_factory_name = "TextSourceBuffer";
        var Ew = Bt.A.getClassFactory(_I);
        class Tw {
          constructor(f) {
            if (this.cues = /* @__PURE__ */ new Map(), f) for (const C of f) this.addCue(C);
          }
          hasCue(f) {
            const C = this.cues.get(f.startTime);
            return C && C.some((_) => {
              return M = f, (v = _).startTime === M.startTime && v.endTime === M.endTime && v instanceof VTTCue && M instanceof VTTCue && v.text === M.text;
              var v, M;
            });
          }
          addCue(f) {
            const C = this.cues.get(f.startTime);
            C ? this.hasCue(f) || C.push(f) : this.cues.set(f.startTime, [f]);
          }
        }
        var Hc = w(7640);
        const kw = ["text", "align", "fontSize", "id", "isd", "line", "lineAlign", "lineHeight", "linePadding", "position", "positionAlign", "region", "size", "snapToLines", "vertical"];
        function bI(A) {
          const f = this.context, C = (0, Mt.A)(f).getInstance(), _ = A.videoModel, v = A.streamInfo, M = A.settings;
          let Y, H, L, W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht;
          function _t(Xt) {
            const ce = Xt.kind, oe = Xt.id !== void 0 ? Xt.id : Xt.lang, pe = Xt.lang, en = Xt.isTTML, mn = Xt.isEmbedded;
            return _.addTextTrack(ce, oe, pe, en, mn);
          }
          function Ct(Xt, ce, oe, pe, en, mn) {
            let se = 0, Ke = 0;
            Xt / ce > oe / pe ? (Ke = ce, se = Ke / pe * oe) : (se = Xt, Ke = se / oe * pe);
            let qe = 0, Ze = 0, tn = 0, $t = 0;
            return se / Ke > en ? ($t = Ke, tn = Ke * en) : (tn = se, $t = se / en), qe = (Xt - tn) / 2, Ze = (ce - $t) / 2, mn ? { x: qe + 0.1 * tn, y: Ze + 0.1 * $t, w: 0.8 * tn, h: 0.8 * $t } : { x: qe, y: Ze, w: tn, h: $t };
          }
          function bt(Xt, ce) {
            const oe = _.getClientWidth(), pe = _.getClientHeight(), en = _.getVideoWidth(), mn = _.getVideoHeight(), se = _.getVideoRelativeOffsetTop(), Ke = _.getVideoRelativeOffsetLeft();
            if (en !== 0 && mn !== 0) {
              let qe = en / mn, Ze = !1;
              Xt.isFromCEA608 && (qe = 1.1666666666666667, Ze = !0);
              const tn = Ct.call(this, oe, pe, en, mn, qe, Ze), $t = tn.w, Se = tn.h, Je = tn.x, $e = tn.y;
              if ($t != et || Se != it || Je != G || $e != F || ce) {
                if (G = Je + Ke, F = $e + se, et = $t, it = Se, st) {
                  const Tt = st.style;
                  Tt && (Tt.left = G + "px", Tt.top = F + "px", Tt.width = et + "px", Tt.height = it + "px", Tt.zIndex = mt && document[mt] || wt ? P : null, C.trigger(At.A.CAPTION_CONTAINER_RESIZE));
                }
                const ue = Xt.activeCues;
                if (ue) {
                  const Tt = ue.length;
                  for (let Zt = 0; Zt < Tt; ++Zt) {
                    const he = ue[Zt];
                    he.scaleCue(he);
                  }
                }
              }
            }
          }
          function Rt(Xt) {
            const ce = et, oe = it;
            let pe, en, mn, se, Ke;
            if (Xt.cellResolution) {
              const qe = [ce / Xt.cellResolution[0], oe / Xt.cellResolution[1]];
              if (Xt.linePadding) {
                for (pe in Xt.linePadding) if (Xt.linePadding.hasOwnProperty(pe)) {
                  en = (Xt.linePadding[pe] * qe[0]).toString();
                  const Ze = document.getElementsByClassName("spanPadding");
                  for (let tn = 0; tn < Ze.length; tn++) Ze[tn].style.cssText = Ze[tn].style.cssText.replace(/(padding-left\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + en), Ze[tn].style.cssText = Ze[tn].style.cssText.replace(/(padding-right\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + en);
                }
              }
              if (Xt.fontSize) {
                for (pe in Xt.fontSize) if (Xt.fontSize.hasOwnProperty(pe)) {
                  Xt.fontSize[pe][0] === "%" ? mn = Xt.fontSize[pe][1] / 100 : Xt.fontSize[pe][0] === "c" && (mn = Xt.fontSize[pe][1]), en = (mn * qe[1]).toString(), Ke = pe !== "defaultFontSize" ? document.getElementsByClassName(pe) : document.getElementsByClassName("paragraph");
                  for (let Ze = 0; Ze < Ke.length; Ze++) Ke[Ze].style.cssText = Ke[Ze].style.cssText.replace(/(font-size\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + en);
                }
                if (Xt.lineHeight) {
                  for (pe in Xt.lineHeight) if (Xt.lineHeight.hasOwnProperty(pe)) {
                    Xt.lineHeight[pe][0] === "%" ? se = Xt.lineHeight[pe][1] / 100 : Xt.fontSize[pe][0] === "c" && (se = Xt.lineHeight[pe][1]), en = (se * qe[1]).toString(), Ke = document.getElementsByClassName(pe);
                    for (let Ze = 0; Ze < Ke.length; Ze++) Ke[Ze].style.cssText = Ke[Ze].style.cssText.replace(/(line-height\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + en);
                  }
                }
              }
            }
            if (Xt.isd) {
              let qe = document.getElementById(Xt.cueID);
              qe && st.removeChild(qe), Pt(Xt);
            }
          }
          function xt(Xt, ce) {
            const oe = /^(urn:)(mpeg:[a-z0-9][a-z0-9-]{0,31}:)(subs:)([0-9]+)$/, pe = /^#(.*)$/;
            if (oe.test(ce)) {
              const en = oe.exec(ce), mn = parseInt(en[4], 10) - 1;
              return "data:image/png;base64," + btoa(Xt.images[mn]);
            }
            if (pe.test(ce)) {
              const en = pe.exec(ce)[1];
              return "data:image/png;base64," + Xt.embeddedImages[en];
            }
            return ce;
          }
          function Pt(Xt) {
            if (st) {
              Gn.call(this);
              const ce = document.createElement("div");
              st.appendChild(ce), $ = (0, Hc.renderHTML)(Xt.isd, ce, function(oe) {
                return xt(Xt, oe);
              }, st.clientHeight, st.clientWidth, M.get().streaming.text.imsc.displayForcedOnlyMode, function(oe) {
                H.info("renderCaption :", oe);
              }, $, M.get().streaming.text.imsc.enableRollUp), ce.id = Xt.cueID, C.trigger(At.A.CAPTION_RENDERED, { captionDiv: ce, currentTrackIdx: R });
            }
          }
          function N(Xt, ce) {
            return !!ce && ce.endTime >= Xt.startTime;
          }
          function ct(Xt, ce) {
            return !!M.get().streaming.text.extendSegmentedCues && !!function(oe, pe, en) {
              for (let mn = 0; mn < en.length; mn++) {
                const se = en[mn];
                if (JSON.stringify(oe[se]) !== JSON.stringify(pe[se])) return !1;
              }
              return !0;
            }(ce, Xt, kw) && (ce.endTime = Math.max(ce.endTime, Xt.endTime), !0);
          }
          function It(Xt, ce) {
            ce && ce.forEach((oe) => {
              oe.kind && oe.kind === "image" && (oe.src = xt(Xt, oe.src)), It(Xt, oe.contents);
            });
          }
          function dt(Xt, ce, oe) {
            const pe = de(Xt), en = M.get().streaming.text.dispatchForManualRendering;
            if (!pe || !Array.isArray(oe) || oe.length === 0) return;
            const mn = new Tw(pe.cues);
            for (let se = 0; se < oe.length; se++) {
              let Ke = null;
              const qe = oe[se];
              pe.cellResolution = qe.cellResolution, pe.isFromCEA608 = qe.isFromCEA608, isNaN(qe.start) || isNaN(qe.end) || (en ? Ke = nt(qe, ce) : Dt(qe) && st ? Ke = Et(qe, ce, pe) : qe.data && (Ke = kt(qe, ce, pe)));
              try {
                if (Ke) {
                  if (!mn.hasCue(Ke)) if (mn.addCue(Ke), M.get().streaming.text.webvtt.customRenderingEnabled) pe.manualCueList || (pe.manualCueList = []), pe.manualCueList.push(Ke);
                  else {
                    let tn;
                    pe.cues && pe.cues.length !== 0 && (tn = pe.cues[pe.cues.length - 1]), N(Ke, tn) ? ct(Ke, tn) || (tn.isd && (tn.onexit = function() {
                    }), pe.mode !== X.A.TEXT_DISABLED && pe.addCue(Ke)) : pe.mode !== X.A.TEXT_DISABLED && pe.addCue(Ke);
                  }
                  const Ze = M.get().streaming.buffer.bufferToKeep;
                  _n(pe, 0, _.getTime() - Ze);
                } else H.error("Impossible to display subtitles. You might have missed setting a TTML rendering div via player.attachTTMLRenderingDiv(TTMLRenderingDiv)");
              } catch (Ze) {
                throw ke(pe), pe.addCue(Ke), Ze;
              }
            }
          }
          function nt(Xt, ce) {
            let oe = Ut(Xt, ce);
            return oe.onenter = function() {
              Dt(Xt) && ht && ht.cueID !== oe.cueID && rt(ht), delete oe.type, ht = oe, ft(oe);
            }, oe.onexit = function() {
              rt(oe), ht = null;
            }, oe;
          }
          function ft(Xt) {
            C.trigger(At.A.CUE_ENTER, Xt);
          }
          function rt(Xt) {
            C.trigger(At.A.CUE_EXIT, { cueID: Xt.cueID });
          }
          function Et(Xt, ce, oe) {
            const pe = this;
            let en = Ut(Xt, ce);
            return st.style.left = G + "px", st.style.top = F + "px", st.style.width = et + "px", st.style.height = it + "px", en.onenter = function() {
              oe.mode === X.A.TEXT_SHOWING && (this.isd ? (J ? requestAnimationFrame(() => Pt(this)) : Pt(this), H.debug("Cue enter id:" + this.cueID)) : (st.appendChild(this.cueHTMLElement), Rt.call(pe, this), C.trigger(At.A.CAPTION_RENDERED, { captionDiv: this.cueHTMLElement, currentTrackIdx: R })));
            }, en.onexit = function() {
              if (st) {
                const mn = st.childNodes;
                for (let se = 0; se < mn.length; ++se) mn[se].id === this.cueID && (H.debug("Cue exit id:" + mn[se].id), st.removeChild(mn[se]), --se);
              }
            }, en;
          }
          function kt(Xt, ce, oe) {
            let pe = Ut(Xt, ce);
            if (pe.isActive = !1, Xt.styles) try {
              Xt.styles.align !== void 0 && "align" in pe && (pe.align = Xt.styles.align), Xt.styles.line !== void 0 && "line" in pe && (pe.line = Xt.styles.line), Xt.styles.lineAlign !== void 0 && (pe.lineAlign = Xt.styles.lineAlign), Xt.styles.snapToLines !== void 0 && "snapToLines" in pe && (pe.snapToLines = Xt.styles.snapToLines), Xt.styles.position !== void 0 && "position" in pe && (pe.position = Xt.styles.position), Xt.styles.positionAlign !== void 0 && (pe.positionAlign = Xt.styles.positionAlign), Xt.styles.size !== void 0 && "size" in pe && (pe.size = Xt.styles.size);
            } catch (en) {
              H.error(en);
            }
            return pe.onenter = function() {
              oe.mode === X.A.TEXT_SHOWING && C.trigger(At.A.CAPTION_RENDERED, { currentTrackIdx: R });
            }, pe;
          }
          function Dt(Xt) {
            return Xt.type === "html";
          }
          function Ut(Xt, ce) {
            return Dt(Xt) ? function(oe, pe) {
              let en = new L(oe.start + pe, oe.end + pe, "");
              return en.cueHTMLElement = oe.cueHTMLElement, en.isd = oe.isd, en.images = oe.images, en.embeddedImages = oe.embeddedImages, en.cueID = oe.cueID, en.scaleCue = Rt.bind(self), en.cellResolution = oe.cellResolution, en.lineHeight = oe.lineHeight, en.linePadding = oe.linePadding, en.fontSize = oe.fontSize, en.isd && It(en, en.isd.contents), en;
            }(Xt, ce) : function(oe, pe) {
              let en = new L(oe.start - pe, oe.end - pe, oe.data);
              return en.cueID = jn.A.generateUuid(), en;
            }(Xt, ce);
          }
          function Wt(Xt) {
            if (ot) {
              const ce = ot.childNodes;
              for (let oe = 0; oe < ce.length; ++oe) ce[oe].id === Xt.cueID && (ot.removeChild(ce[oe]), --oe);
            }
          }
          function ie() {
            const Xt = _.getTextTracks(), ce = [];
            for (const oe of Xt) oe.manualMode === X.A.TEXT_SHOWING && ce.push(oe);
            return ce;
          }
          function de(Xt) {
            return Xt >= 0 && W[Xt] ? _.getTextTrack(W[Xt].kind, W[Xt].id, W[Xt].lang, W[Xt].isTTML, W[Xt].isEmbedded) : null;
          }
          function Be(Xt) {
            if (Xt === R) return;
            R = Xt;
            const ce = de(R);
            Oe.call(this, ce), ut && (clearInterval(ut), ut = null), ce && ce.renderingType === "html" && (bt.call(this, ce, !0), window.ResizeObserver ? (j = new window.ResizeObserver(() => {
              bt.call(this, ce, !0);
            }), j.observe(_.getElement())) : ut = setInterval(bt.bind(this, ce), 500));
          }
          function Oe(Xt) {
            Gn.call(this), Xt && Xt.renderingType === "html" ? Cn.call(this) : Nn.call(this);
          }
          function nn(Xt, ce, oe) {
            let pe = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            return !!Xt && (isNaN(ce) || (pe ? Xt.startTime : Xt.endTime) >= ce) && (isNaN(oe) || (pe ? Xt.endTime : Xt.startTime) <= oe);
          }
          function _n(Xt, ce, oe) {
            if (!(oe < ce) && Xt && (Xt.cues || Xt.manualCueList)) {
              const pe = Xt.cues && Xt.cues.length > 0 ? "native" : "custom", en = pe === "native" ? Xt.cues : Xt.manualCueList;
              if (!en || en.length === 0) return;
              for (let mn = en.length - 1; mn >= 0; mn--) nn(en[mn], ce, oe, !0) && !rn(en[mn]) && (pe === "native" ? Xt.removeCue(en[mn]) : (Wt(en[mn]), delete Xt.manualCueList[mn]));
            }
          }
          function ke(Xt, ce, oe) {
            let pe = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            if (Xt && (Xt.cues || Xt.manualCueList)) {
              const en = Xt.cues && Xt.cues.length > 0 ? "native" : "custom", mn = en === "native" ? Xt.cues : Xt.manualCueList;
              if (!mn || mn.length === 0) return;
              for (let se = mn.length - 1; se >= 0; se--) nn(mn[se], ce, oe, pe) && (en === "native" ? (mn[se].onexit && mn[se].onexit(), Xt.removeCue(mn[se])) : (Wt(mn[se]), delete Xt.manualCueList[se]));
            }
          }
          function rn(Xt) {
            const ce = _.getTime();
            return ce >= Xt.startTime && ce <= Xt.endTime;
          }
          function Cn() {
            let Xt = document.getElementById("native-cue-style");
            if (Xt) return;
            Xt = document.createElement("style"), Xt.id = "native-cue-style", document.head.appendChild(Xt);
            const ce = Xt.sheet, oe = _.getElement();
            try {
              oe && (oe.id ? ce.insertRule("#" + oe.id + "::cue {background: transparent}", 0) : oe.classList.length !== 0 ? ce.insertRule("." + oe.className + "::cue {background: transparent}", 0) : ce.insertRule("video::cue {background: transparent}", 0));
            } catch (pe) {
              H.info("" + pe.message);
            }
          }
          function Nn() {
            const Xt = document.getElementById("native-cue-style");
            Xt && document.head.removeChild(Xt);
          }
          function Gn() {
            if (st) for (; st.firstChild; ) st.removeChild(st.firstChild);
          }
          return Y = { addCaptions: dt, addTextTrackInfo: function(Xt) {
            W.push(Xt);
          }, createTracks: function() {
            W.sort(function(ce, oe) {
              return ce.index - oe.index;
            }), st = _.getTTMLRenderingDiv(), ot = _.getVttRenderingDiv();
            let Xt = -1;
            for (let ce = 0; ce < W.length; ce++) {
              const oe = _t(W[ce]);
              K.push(oe), W[ce].defaultTrack && (oe.default = !0, Xt = ce);
              const pe = de(ce);
              pe && (pe.mode = X.A.TEXT_SHOWING, st && (W[ce].isTTML || W[ce].isEmbedded) ? pe.renderingType = "html" : pe.renderingType = "default"), dt(ce, 0, W[ce].captionData), C.trigger(At.A.TEXT_TRACK_ADDED);
            }
            if (Be.call(this, Xt), Xt >= 0) {
              let ce = function() {
                const oe = de(Xt);
                oe && oe.renderingType === "html" && bt.call(this, oe, !0), C.off(At.A.PLAYBACK_METADATA_LOADED, ce, this);
              };
              C.on(At.A.PLAYBACK_METADATA_LOADED, ce, this);
              for (let oe = 0; oe < W.length; oe++) {
                const pe = de(oe);
                if (pe) {
                  const en = M.get().streaming.text.dispatchForManualRendering;
                  pe.mode = oe !== Xt || en ? X.A.TEXT_HIDDEN : X.A.TEXT_SHOWING, pe.manualMode = oe === Xt ? X.A.TEXT_SHOWING : X.A.TEXT_HIDDEN;
                }
              }
            }
            C.trigger(at.A.TEXT_TRACKS_QUEUE_INITIALIZED, { index: R, tracks: W, streamId: v.id });
          }, deleteAllTextTracks: function() {
            const Xt = K ? K.length : 0;
            for (let ce = 0; ce < Xt; ce++) {
              const oe = de(ce);
              oe && ke.call(this, oe, v.start, v.start + v.duration, !1);
            }
            K = [], W = [], ut && (clearInterval(ut), ut = null), j && _ && (j.unobserve(_.getElement()), j = null), R = -1, Gn.call(this);
          }, deleteCuesFromTrackIdx: function(Xt, ce, oe) {
            const pe = de(Xt);
            pe && ke(pe, ce, oe);
          }, disableManualTracks: function() {
            const Xt = ie();
            if (Xt && Xt.length > 0) {
              const ce = Xt[0].manualCueList;
              ce && ce.length > 0 && ce.forEach((oe) => {
                if (oe.isActive) {
                  if (oe.isActive = !1, M.get().streaming.text.dispatchForManualRendering) rt(oe);
                  else if (ot) {
                    const pe = ot.childNodes;
                    for (let en = 0; en < pe.length; ++en) pe[en].id === oe.cueID && (ot.removeChild(pe[en]), --en);
                  }
                }
              });
            }
          }, getCurrentTrackIdx: function() {
            return R;
          }, getCurrentTextTrackInfo: function() {
            return W[R];
          }, getStreamId: function() {
            return v.id;
          }, getTextTrackInfos: function() {
            return W;
          }, getTrackIdxForId: function(Xt) {
            let ce = -1;
            for (let oe = 0; oe < W.length; oe++) if (W[oe].id === Xt) {
              ce = oe;
              break;
            }
            return ce;
          }, initialize: function() {
            typeof window != "undefined" && typeof navigator != "undefined" && (L = window.VTTCue || window.TextTrackCue, W = [], K = [], R = -1, G = 0, F = 0, et = 0, it = 0, st = null, ot = null, ut = null, wt = !1, P = 2147483647, $ = null, J = "requestAnimationFrame" in window, document.fullscreenElement !== void 0 ? mt = "fullscreenElement" : document.webkitIsFullScreen !== void 0 ? mt = "webkitIsFullScreen" : document.msFullscreenElement ? mt = "msFullscreenElement" : document.mozFullScreen && (mt = "mozFullScreen"));
          }, manualCueProcessing: function(Xt) {
            const ce = ie();
            if (ce && ce.length > 0) {
              const oe = ce[0].manualCueList;
              oe && oe.length > 0 && oe.forEach((pe) => {
                pe.startTime <= Xt && pe.endTime >= Xt && !pe.isActive ? (pe.isActive = !0, M.get().streaming.text.dispatchForManualRendering ? ft(pe) : WebVTT.processCues(window, [pe], ot, pe.cueID)) : pe.isActive && (pe.startTime > Xt || pe.endTime < Xt) && (pe.isActive = !1, M.get().streaming.text.dispatchForManualRendering ? rt(pe) : Wt(pe));
              });
            }
          }, setCurrentTrackIdx: Be, setModeForTrackIdx: function(Xt, ce) {
            const oe = de(Xt);
            oe && oe.mode !== ce && (oe.mode = ce), oe && oe.manualMode !== ce && (oe.manualMode = ce);
          } }, H = (0, jt.A)(f).getInstance().getLogger(Y), Y;
        }
        bI.__dashjs_factory_name = "TextTracks";
        var Lw = Bt.A.getClassFactory(bI);
        function SI() {
          const A = this.context;
          let f, C, _, v, M, Y;
          function H(R) {
            const G = R.split(":"), F = G.length - 1;
            return R = 60 * parseInt(G[F - 1], 10) + parseFloat(G[F]), F === 2 && (R += 3600 * parseInt(G[0], 10)), R;
          }
          function L(R) {
            const G = R.split(v), F = G[1].split(Y);
            return F.shift(), G[1] = F[0], F.shift(), { cuePoints: G, styles: W(F) };
          }
          function W(R) {
            const G = {};
            return R.forEach(function(F) {
              const et = F.split(":");
              if (et.length > 1) {
                const [it, st] = et;
                switch (it) {
                  case "align":
                  case "A":
                    G.align = st;
                    break;
                  case "line":
                  case "L":
                    const [ot, ut] = st.split(","), mt = ot.endsWith("%");
                    G.line = ot === "auto" ? ot : parseInt(ot, 10), mt && (G.snapToLines = !1), ut && (G.lineAlign = ut);
                    break;
                  case "position":
                  case "P":
                    const [wt, $] = st.split(",");
                    G.position = parseInt(wt, 10), $ && (G.positionAlign = $);
                    break;
                  case "size":
                  case "S":
                    G.size = parseInt(st, 10);
                }
              }
            }), G;
          }
          function K(R, G) {
            let F, et = G, it = "", st = "";
            for (; R[et] !== "" && et < R.length; ) et++;
            if (F = et - G, F > 1) for (let ot = 0; ot < F; ot++) {
              if (st = R[G + ot], st.match(v)) {
                it = "";
                break;
              }
              it += st, ot !== F - 1 && (it += `
`);
            }
            else st = R[G], st.match(v) || (it = st);
            return it;
          }
          return f = { parse: function(R) {
            const G = [];
            let F, et;
            if (!R) return G;
            F = (R = R.split(_)).length, et = -1;
            for (let it = 0; it < F; it++) {
              let st = R[it];
              if (st.length > 0 && st !== "WEBVTT" && st.match(v)) {
                const ot = L(st), ut = ot.cuePoints, mt = ot.styles, wt = K(R, it + 1), $ = H(ut[0].replace(M, "")), P = H(ut[1].replace(M, ""));
                !isNaN($) && !isNaN(P) && $ >= et && P > $ ? wt !== "" ? (et = $, G.push({ start: $, end: P, data: wt, styles: mt })) : C.error("Skipping cue due to empty/malformed cue text") : C.error("Skipping cue due to incorrect cue timing");
              }
            }
            return G;
          }, getCaptionStyles: W }, C = (0, jt.A)(A).getInstance().getLogger(f), _ = /(?:\r\n|\r|\n)/gm, v = /-->/, M = /(^[\s]+|[\s]+$)/g, Y = /\s\b/g, f;
        }
        SI.__dashjs_factory_name = "VTTParser";
        var Mw = Bt.A.getSingletonFactory(SI);
        function wI() {
          let A, f;
          return A = { parse: function(C) {
            let _ = [];
            return f.oncue = function(v) {
              v.start = v.startTime, v.end = v.endTime, v.data = v.text, v.styles = { align: v.align, line: v.line, position: v.position, size: v.size }, _.push(v);
            }, f.parse(C), _;
          } }, function() {
            try {
              window && window.WebVTT && window.WebVTT.Parser && (f = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder()));
            } catch (C) {
            }
          }(), A;
        }
        wI.__dashjs_factory_name = "VttCustomRenderingParser";
        var Rw = Bt.A.getSingletonFactory(wI);
        function vI() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v = 0;
          function M() {
            const Y = "cue_TTML_" + v;
            return v++, Y;
          }
          return C = { parse: function(Y, H, L, W, K) {
            let R = "";
            const G = [];
            let F, et, it;
            const st = {}, ot = {};
            let ut = "", mt = "", wt = { onOpenTag: function(j, J, ht) {
              if (ht[" imagetype"] && !ht[" imageType"] && (f.trigger(At.A.CONFORMANCE_VIOLATION, { level: Na.LEVELS.ERROR, event: Na.EVENTS.NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE }), ht[" imageType"] = ht[" imagetype"]), J === "image" && (j === "http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" || j === "http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt")) {
                if (!ht[" imageType"] || ht[" imageType"].value !== "PNG") return void _.warn("smpte-tt imageType != PNG. Discarded");
                ut = ht["http://www.w3.org/XML/1998/namespace id"].value;
              }
            }, onCloseTag: function() {
              ut && (ot[ut] = mt.trim()), mt = "", ut = "";
            }, onText: function(j) {
              ut && (mt += j);
            } };
            if (!Y) throw R = "no ttml data to parse", new Error(R);
            st.data = Y, f.trigger(at.A.TTML_TO_PARSE, st);
            let $ = (0, Hc.fromXML)(st.data, function(j) {
              R = j;
            }, wt);
            f.trigger(at.A.TTML_PARSED, { ttmlString: st.data, ttmlDoc: $ });
            const P = $.getMediaTimeEvents();
            for (it = 0; it < P.length; it++) {
              let j = (0, Hc.generateISD)($, P[it], function(J) {
                R = J;
              });
              j.contents.some((J) => J.contents.length) && (F = P[it] + H, et = P[it + 1] + H, F < et && G.push({ start: F, end: et, type: "html", cueID: M(), isd: j, images: K, embeddedImages: ot }));
            }
            if (R !== "") throw _.error(R), new Error(R);
            return G;
          } }, _ = (0, jt.A)(A).getInstance().getLogger(C), C;
        }
        vI.__dashjs_factory_name = "TTMLParser";
        var Dw = Bt.A.getSingletonFactory(vI);
        function EI(A) {
          let f = this.context;
          const C = (0, Mt.A)(f).getInstance(), _ = He(f).getInstance(), v = A.adapter, M = A.baseURLController, Y = "error", H = "loaded", L = "unloaded";
          let W, K, R;
          function G(it, st) {
            let ot, ut, mt = !1;
            if (M.resolve()) {
              const P = v.getVoRepresentations(it);
              P && P.length > 0 && (ot = M.resolve(P[0].path).url);
            }
            const wt = it.essentialProperties.filter((P) => P.schemeIdUri && P.schemeIdUri === X.A.FONT_DOWNLOAD_DVB_SCHEME), $ = it.supplementalProperties.filter((P) => P.schemeIdUri && P.schemeIdUri === X.A.FONT_DOWNLOAD_DVB_SCHEME);
            wt.length > 0 ? (mt = !0, ut = wt) : ut = $, ut.forEach((P) => {
              if (function(ht) {
                return !(!(ht.value && parseInt(ht.value) === 1 && ht.dvbUrl && ht.dvbUrl.length > 0 && ht.dvbFontFamily && ht.dvbFontFamily.length > 0 && ht.dvbMimeType) || ht.dvbMimeType !== X.A.OFF_MIMETYPE && ht.dvbMimeType !== X.A.WOFF_MIMETYPE);
              }(P)) {
                let ht = (j = P.dvbUrl, J = ot, _.isPathAbsolute(j) ? j : _.isRelative(j) ? J ? _.resolve(j, J) : _.resolve(j) : j);
                R.push({ fontFamily: P.dvbFontFamily, url: ht, mimeType: P.dvbMimeType, trackId: it.id, streamId: st, isEssential: mt, status: L, fontFace: new FontFace(P.dvbFontFamily, `url(${ht})`, { display: "swap" }) });
              }
              var j, J;
            });
          }
          function F(it, st) {
            const ot = R[it];
            R[it] = Yr(Da({}, ot), { status: st });
          }
          function et() {
            R = [];
          }
          return W = { addFontsFromTracks: function(it, st) {
            if (it && Array.isArray(it) && st) for (let ot = 0; ot < it.length; ot++) G(it[ot], st);
          }, downloadFonts: function() {
            for (let it = 0; it < R.length; it++) {
              let st = R[it];
              document.fonts.add(st.fontFace), C.trigger(At.A.DVB_FONT_DOWNLOAD_ADDED, st), st.fontFace.load().then(() => {
                F(it, H), C.trigger(At.A.DVB_FONT_DOWNLOAD_COMPLETE, st);
              }, (ot) => {
                F(it, Y), K.debug("Font download error: ", ot), C.trigger(At.A.DVB_FONT_DOWNLOAD_FAILED, st);
              });
            }
          }, getFonts: function() {
            return R;
          }, getFontsForTrackId: function(it) {
            return R.filter((st) => st.trackId && st.trackId === it);
          }, reset: function() {
            (function() {
              for (const it of R) {
                let st = document.fonts.delete(it.fontFace);
                K.debug(`Removal of fontFamily: ${it.fontFamily} was ${st ? "successful" : "unsuccessful"}`);
              }
            })(), et();
          } }, K = (0, jt.A)(f).getInstance().getLogger(W), et(), W;
        }
        EI.__dashjs_factory_name = "DVBFonts";
        var Bw = Bt.A.getClassFactory(EI);
        function TI(A) {
          let f = this.context;
          const C = A.adapter, _ = A.errHandler, v = A.manifestModel, M = A.mediaController, Y = A.baseURLController, H = A.videoModel, L = A.settings;
          let W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P;
          function j(dt) {
            if (P.error(`Could not download ${dt.isEssential ? "an essential" : "a"} font - fontFamily: ${dt.fontFamily}, url: ${dt.url}`), dt.isEssential) {
              let nt = G[dt.streamId].getTrackIdxForId(dt.trackId);
              G[dt.streamId].setModeForTrackIdx(nt, X.A.TEXT_DISABLED);
            }
          }
          function J(dt) {
            if (P.debug(`Successfully downloaded ${dt.isEssential ? "an essential" : "a"} font - fontFamily: ${dt.fontFamily}, url: ${dt.url}`), dt.isEssential) {
              let nt = G[dt.streamId].getTrackIdxForId(dt.trackId);
              nt === G[dt.streamId].getCurrentTrackIdx() ? G[dt.streamId].setModeForTrackIdx(nt, X.A.TEXT_SHOWING) : G[dt.streamId].setModeForTrackIdx(nt, X.A.TEXT_HIDDEN);
            }
          }
          function ht(dt) {
            let nt = dt.tracks, ft = dt.index;
            const rt = dt.streamId;
            if (L.get().streaming.text.defaultEnabled === !1 && !Rt() || wt) xt(rt, -1);
            else {
              const Et = M.getCurrentTrackFor(X.A.TEXT, rt);
              if (Et) {
                const kt = { lang: Et.lang, role: Et.roles[0], index: Et.index, codec: Et.codec, accessibility: Et.accessibility[0] };
                nt.some((Dt, Ut) => {
                  if (M.matchSettings(kt, Dt)) return xt(rt, Ut), ft = Ut, !0;
                });
              }
              ot = !1;
            }
            K[rt].lastEnabledIndex = ft, st.trigger(At.A.TEXT_TRACKS_ADDED, { enabled: Rt(), index: ft, tracks: nt, streamId: rt }), mt = !0, $.addFontsFromTracks(nt, rt), $.getFonts().forEach((Et) => {
              if (Et.isEssential) {
                let kt = G[Et.streamId].getTrackIdxForId(Et.trackId);
                G[Et.streamId].setModeForTrackIdx(kt, X.A.TEXT_DISABLED);
              }
            }), $.downloadFonts();
          }
          function _t(dt) {
            try {
              const nt = dt.streamId;
              if (!G[nt] || isNaN(dt.time)) return;
              G[nt].manualCueProcessing(dt.time);
            } catch (nt) {
            }
          }
          function Ct(dt) {
            try {
              const nt = dt.streamId;
              if (!G[nt]) return;
              G[nt].disableManualTracks();
            } catch (nt) {
            }
          }
          function bt(dt) {
            try {
              if (!dt || !dt.mediaType || dt.mediaType !== X.A.AUDIO || !dt.currentMediaInfo) return;
              const nt = G[dt.streamId].getCurrentTextTrackInfo();
              let ft = NaN;
              ot ? ft = Pt(dt.streamId) : N(nt) && dt.currentMediaInfo.lang && dt.currentMediaInfo.lang !== nt.lang && (ft = Pt(dt.streamId), isNaN(ft) && (ft = -1)), isNaN(ft) || xt(dt.streamId, ft);
            } catch (nt) {
              P.error(nt);
            }
          }
          function Rt() {
            let dt = !0;
            return ot && !ut && (dt = !1), dt;
          }
          function xt(dt, nt) {
            ot = nt === -1, ot && M && M.saveTextSettingsDisabled();
            let ft = ct(dt);
            if (ft === nt || !G[dt]) return;
            G[dt].disableManualTracks();
            let rt = G[dt].getCurrentTextTrackInfo(), Et = rt ? H.getTextTrack(rt.kind, rt.id, rt.lang, rt.isTTML, rt.isEmbedded) : null;
            Et && Et.mode !== X.A.TEXT_DISABLED && G[dt].setModeForTrackIdx(ft, X.A.TEXT_HIDDEN), G[dt].setCurrentTrackIdx(nt), rt = G[dt].getCurrentTextTrackInfo();
            const kt = L.get().streaming.text.dispatchForManualRendering;
            if (rt && !kt && rt.mode !== X.A.TEXT_DISABLED && G[dt].setModeForTrackIdx(nt, X.A.TEXT_SHOWING), rt && rt.isFragmented && !rt.isEmbedded) (function(Dt, Ut, Wt) {
              if (!R[Dt]) return;
              let ie = R[Dt].getConfig().fragmentedTracks;
              for (let de = 0; de < ie.length; de++) {
                let Be = ie[de];
                if (Ut.lang === Be.lang && (Be.id ? Ut.id === Be.id : Ut.index === Be.index)) {
                  let Oe = M.getCurrentTrackFor(X.A.TEXT, Dt);
                  (Be.id ? Oe.id !== Be.id : Oe.index !== Be.index) ? (G[Dt].deleteCuesFromTrackIdx(Wt), R[Dt].setCurrentFragmentedTrackIdx(de)) : Wt === -1 && st.trigger(at.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, {}, { streamId: Dt, mediaType: X.A.TEXT });
                }
              }
            })(dt, rt, ft);
            else if (rt && !rt.isFragmented) (function(Dt, Ut) {
              st.trigger(at.A.SET_NON_FRAGMENTED_TEXT, { currentTrackInfo: Ut }, { streamId: Dt, mediaType: X.A.TEXT });
            })(dt, rt);
            else if (!rt && ot) {
              const Dt = Pt(dt);
              return void (isNaN(Dt) || xt(dt, Dt));
            }
            M.setTrack(rt);
          }
          function Pt(dt) {
            const nt = function(Et) {
              return G[Et].getTextTrackInfos().filter((kt, Dt) => (kt._indexToSelect = Dt, !!(kt && kt.roles && kt.roles.length > 0) && N(kt)));
            }(dt);
            if (!nt || nt.length <= 0) return NaN;
            const ft = M.getCurrentTrackFor(X.A.AUDIO, dt);
            if (!ft) return NaN;
            const rt = nt.find((Et) => ft.lang === Et.lang);
            return rt ? rt._indexToSelect : NaN;
          }
          function N(dt) {
            return !(!dt || !dt.roles || dt.roles.length === 0) && dt.roles.some((nt) => nt.schemeIdUri === X.A.DASH_ROLE_SCHEME_ID && nt.value === D.A.FORCED_SUBTITLE);
          }
          function ct(dt) {
            return G[dt].getCurrentTrackIdx();
          }
          function It() {
            R = {}, G = {}, K = {}, ot = !0, mt = !1, wt = !1;
          }
          return W = { addEmbeddedTrack: function(dt, nt) {
            const ft = dt.id;
            R[ft] && R[ft].addEmbeddedTrack(nt);
          }, addMediaInfosToBuffer: function(dt, nt, ft) {
            let rt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            const Et = dt.id;
            R[Et] && R[Et].addMediaInfos(nt, ft, rt);
          }, createTracks: function(dt) {
            const nt = dt.id;
            G[nt] && G[nt].createTracks();
          }, deactivateStream: function(dt) {
            if (!dt) return;
            const nt = dt.id;
            R[nt] && R[nt].resetMediaInfos(), G[nt] && G[nt].deleteAllTextTracks();
          }, enableForcedTextStreaming: function(dt) {
            return (0, xe.sq)(dt, "boolean"), ut = dt, !0;
          }, enableText: function(dt, nt) {
            return (0, xe.sq)(nt, "boolean"), Rt() !== nt && (nt && xt(dt, K[dt].lastEnabledIndex), nt || (K[dt].lastEnabledIndex = ct(dt), mt ? xt(dt, -1) : wt = !0)), !0;
          }, getAllTracksAreDisabled: function() {
            return ot;
          }, getCurrentTrackIdx: ct, getTextSourceBuffer: function(dt) {
            const nt = dt.id;
            if (R && R[nt]) return R[nt];
          }, initialize: function() {
            $ = Bw(f).create({ adapter: C, baseURLController: Y }), st.on(at.A.TEXT_TRACKS_QUEUE_INITIALIZED, ht, W), st.on(at.A.DVB_FONT_DOWNLOAD_FAILED, j, W), st.on(at.A.DVB_FONT_DOWNLOAD_COMPLETE, J, W), st.on(at.A.MEDIAINFO_UPDATED, bt, W), L.get().streaming.text.webvtt.customRenderingEnabled && (st.on(at.A.PLAYBACK_TIME_UPDATED, _t, W), st.on(at.A.PLAYBACK_SEEKING, Ct, W));
          }, initializeForStream: function(dt) {
            const nt = dt.id, ft = Lw(f).create({ videoModel: H, settings: L, streamInfo: dt });
            ft.initialize(), G[nt] = ft;
            const rt = Ew(f).create({ errHandler: _, adapter: C, dvbFonts: $, manifestModel: v, mediaController: M, videoModel: H, textTracks: ft, vttParser: F, vttCustomRenderingParser: et, ttmlParser: it, streamInfo: dt, settings: L });
            rt.initialize(), R[nt] = rt, K[nt] = {}, K[nt].lastEnabledIndex = -1;
          }, isTextEnabled: Rt, reset: function() {
            Object.keys(R).forEach((dt) => {
              R[dt].resetEmbedded(), R[dt].reset();
            }), $.reset(), It(), st.off(at.A.TEXT_TRACKS_QUEUE_INITIALIZED, ht, W), st.off(at.A.DVB_FONT_DOWNLOAD_FAILED, j, W), st.off(at.A.DVB_FONT_DOWNLOAD_COMPLETE, J, W), st.off(at.A.MEDIAINFO_UPDATED, bt, W), L.get().streaming.text.webvtt.customRenderingEnabled && (st.off(at.A.PLAYBACK_TIME_UPDATED, _t, W), st.off(at.A.PLAYBACK_SEEKING, Ct, W));
          }, setTextTrack: xt, clearDataForStream: function(dt) {
            R[dt] && (R[dt].resetEmbedded(), R[dt].reset(), delete R[dt]), G[dt] && (G[dt].deleteAllTextTracks(), delete G[dt]), K[dt] && delete K[dt];
          } }, ut = !1, mt = !1, wt = !1, F = Mw(f).getInstance(), et = Rw(f).getInstance(), it = Dw(f).getInstance(), st = (0, Mt.A)(f).getInstance(), P = (0, jt.A)(f).getInstance().getLogger(W), It(), W;
        }
        TI.__dashjs_factory_name = "TextController";
        var xw = Bt.A.getClassFactory(TI);
        function kI(A) {
          A = A || {};
          const f = this.context, C = (0, jt.A)(f).getInstance(), _ = A.settings, v = (0, Mt.A)(f).getInstance();
          let M, Y, H, L, W, K;
          function R() {
            return navigator && navigator.connection && !isNaN(navigator.connection.downlink) && navigator.connection.downlink > 0 ? 1e3 * navigator.connection.downlink : NaN;
          }
          function G(it, st, ot, ut) {
            const mt = Math.pow(0.5, ot / ut.fast);
            it.fastEstimate = (1 - mt) * st + mt * it.fastEstimate;
            const wt = Math.pow(0.5, ot / ut.slow);
            it.slowEstimate = (1 - wt) * st + wt * it.slowEstimate, it.totalWeight += ot;
          }
          function F() {
            M = {}, Y = {}, H = {}, L = {};
          }
          const et = { addEntry: function(it, st) {
            try {
              if (!(it && st && st.trace && st.trace.length)) return;
              (function(mt) {
                M[mt] = M[mt] || [], Y[mt] = Y[mt] || [], H[mt] = H[mt] || { fastEstimate: 0, slowEstimate: 0, totalWeight: 0 }, L[mt] = L[mt] || { fastEstimate: 0, slowEstimate: 0, totalWeight: 0 };
              })(it);
              const ot = st.tresponse.getTime() - st.trequest.getTime() || 1;
              let ut = function(mt, wt) {
                return mt._fileLoaderType && mt._fileLoaderType === X.A.FILE_LOADER_TYPES.FETCH ? function($) {
                  const P = $.trace.reduce((ht, _t) => ht + _t.b[0], 0), j = $.trace.reduce((ht, _t) => ht + _t.d, 0);
                  let J = NaN;
                  return _.get().streaming.abr.throughput.useNetworkInformationApi.fetch && (J = R()), isNaN(J) && (J = Math.round(8 * P / j)), { downloadedBytes: P, value: J, downloadTimeInMs: j };
                }(mt) : function($, P) {
                  let j = NaN, J = NaN, ht = !1;
                  if (_.get().streaming.abr.throughput.useResourceTimingApi && $._resourceTimingValues) j = $._resourceTimingValues.transferSize, J = $._resourceTimingValues.responseEnd - $._resourceTimingValues.responseStart, ht = !0;
                  else {
                    if ($.trace.length <= 1) return { throughput: NaN, downloadTimeInMs: NaN };
                    j = $.trace.reduce((Ct, bt) => Ct + bt.b[0], 0) - $.trace[0].b[0], J = Math.max($.trace.reduce((Ct, bt) => Ct + bt.d, 0) - $.trace[0].d, 1);
                  }
                  let _t = NaN;
                  if (!ht && _.get().streaming.abr.throughput.useNetworkInformationApi.xhr && (_t = R()), isNaN(_t)) {
                    const Ct = _.get().streaming.abr.throughput.useDeadTimeLatency ? J : J + P;
                    _t = Math.round(8 * j / Ct);
                  }
                  return { downloadedBytes: j, value: _t, downloadTimeInMs: J };
                }(mt, wt);
              }(st, ot);
              if (ut.latencyInMs = ot, isNaN(ut.value) || !isFinite(ut.value)) return;
              if (st.cmsd) {
                const mt = st.cmsd.dynamic && st.cmsd.dynamic.etp ? st.cmsd.dynamic.etp : null;
                if (mt) {
                  const wt = _.get().streaming.cmsd.abr.etpWeightRatio;
                  wt > 0 && wt <= 1 && (ut.value = ut.value * (1 - wt) + mt * wt);
                }
              }
              if (function(mt, wt, $) {
                return _.get().streaming.abr.throughput.useResourceTimingApi && $._resourceTimingValues ? $._resourceTimingValues.transferSize === 0 && $._resourceTimingValues.decodedBodySize > 0 : !isNaN(wt) && (mt === X.A.VIDEO ? wt < _.get().streaming.cacheLoadThresholds[X.A.VIDEO] : mt === X.A.AUDIO ? wt < _.get().streaming.cacheLoadThresholds[X.A.AUDIO] : mt === X.A.MESH ? wt < _.get().streaming.cacheLoadThresholds[X.A.MESH] : void 0);
              }(it, st._tfinish.getTime() - st.trequest.getTime(), st)) return void K.debug(`${it} Assuming segment ${st.url} came from cache, ignoring it for throughput calculation`);
              K.debug(`Added throughput entry for ${it}: ${ut.value} kbit/s`), ut.serviceLocation = st._serviceLocation, M[it].push(ut), Y[it].push({ value: ot }), function(mt) {
                M[mt].length > _.get().streaming.abr.throughput.sampleSettings.maxMeasurementsToKeep && M[mt].shift(), Y[mt].length > _.get().streaming.abr.throughput.sampleSettings.maxMeasurementsToKeep && Y[mt].shift();
              }(it), v.trigger(At.A.THROUGHPUT_MEASUREMENT_STORED, { throughputValues: ut }), st.type !== Ht.G.MPD_TYPE && (G(H[it], ut.value, _.get().streaming.abr.throughput.ewma.weightDownloadTimeMultiplicationFactor * ut.downloadTimeInMs, W.bandwidthHalfLife), G(L[it], ot, 1, W.latencyHalfLife));
            } catch (ot) {
              K.error(ot);
            }
          }, getThroughputDict: function(it) {
            return it ? M[it] : M;
          }, getEwmaThroughputDict: function(it) {
            return it ? H[it] : H;
          }, getEwmaLatencyDict: function(it) {
            return it ? L[it] : L;
          }, getEwmaHalfLife: function() {
            return W;
          }, getLatencyDict: function(it) {
            return it ? Y[it] : Y;
          }, reset: F };
          return K = C.getLogger(et), W = { bandwidthHalfLife: { fast: _.get().streaming.abr.throughput.ewma.throughputFastHalfLifeSeconds, slow: _.get().streaming.abr.throughput.ewma.throughputSlowHalfLifeSeconds }, latencyHalfLife: { fast: _.get().streaming.abr.throughput.ewma.latencyFastHalfLifeCount, slow: _.get().streaming.abr.throughput.ewma.latencySlowHalfLifeCount } }, F(), et;
        }
        kI.__dashjs_factory_name = "ThroughputModel";
        var Nw = Bt.A.getClassFactory(kI);
        function LI() {
          const A = this.context, f = (0, Mt.A)(A).getInstance();
          let C, _, v;
          function M() {
            performance.clearResourceTimings();
          }
          function Y(mt) {
            mt.metric !== yt.HTTP_REQUEST || !mt.value || mt.value.type !== Ht.G.MPD_TYPE && (mt.value.type !== Ht.G.MEDIA_SEGMENT_TYPE || mt.mediaType !== X.A.AUDIO && mt.mediaType !== X.A.VIDEO && mt.mediaType !== X.A.MESH) || C.addEntry(mt.mediaType, mt.value);
          }
          function H(mt, wt) {
            let $, P = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, j = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : NaN, J = null, ht = C.getEwmaHalfLife(), _t = null, Ct = !0;
            switch (P || (P = v.get().streaming.abr.throughput.averageCalculationMode), mt) {
              case X.A.THROUGHPUT_TYPES.BANDWIDTH:
                J = P === X.A.THROUGHPUT_CALCULATION_MODES.EWMA ? C.getEwmaThroughputDict(wt) : C.getThroughputDict(wt), _t = ht.bandwidthHalfLife, Ct = !0, j = isNaN(j) ? _.getIsDynamic() ? v.get().streaming.abr.throughput.sampleSettings.live : v.get().streaming.abr.throughput.sampleSettings.vod : j;
                break;
              case X.A.THROUGHPUT_TYPES.LATENCY:
                J = P === X.A.THROUGHPUT_CALCULATION_MODES.EWMA ? C.getEwmaLatencyDict(wt) : C.getLatencyDict(wt), _t = ht.latencyHalfLife, Ct = !1, j = isNaN(j) ? v.get().streaming.abr.throughput.sampleSettings.averageLatencySampleAmount : j;
            }
            if (!J || J.length === 0) return NaN;
            switch (P) {
              case X.A.THROUGHPUT_CALCULATION_MODES.ARITHMETIC_MEAN:
                return $ = L(J, j, mt), W(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.BYTE_SIZE_WEIGHTED_ARITHMETIC_MEAN:
                return $ = L(J, j, mt), K(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.DATE_WEIGHTED_ARITHMETIC_MEAN:
                return $ = L(J, j, mt), R(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.HARMONIC_MEAN:
                return $ = L(J, j, mt), G(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.BYTE_SIZE_WEIGHTED_HARMONIC_MEAN:
                return $ = L(J, j, mt), F(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.DATE_WEIGHTED_HARMONIC_MEAN:
                return $ = L(J, j, mt), et(J, $);
              case X.A.THROUGHPUT_CALCULATION_MODES.EWMA:
                return it(J, _t, Ct);
              case X.A.THROUGHPUT_CALCULATION_MODES.ZLEMA:
                return $ = L(J, j, mt), st(J, $);
            }
          }
          function L(mt, wt, $) {
            if (mt) {
              if (wt >= mt.length) wt = mt.length;
              else if ($ === X.A.THROUGHPUT_TYPES.BANDWIDTH && v.get().streaming.abr.throughput.sampleSettings.enableSampleSizeAdjustment) for (let P = 1; P < wt; ++P) {
                const j = mt[mt.length - P].value / mt[mt.length - P - 1].value;
                if ((j >= v.get().streaming.abr.throughput.sampleSettings.increaseScale || j <= v.get().streaming.abr.throughput.sampleSettings.decreaseScale) && (wt += 1) === mt.length) break;
              }
            } else wt = 0;
            return wt;
          }
          function W(mt, wt) {
            let $ = mt;
            return wt !== 0 && $ && $.length !== 0 ? ($ = $.slice(-wt), $.reduce((P, j) => P + j.value, 0) / $.length) : NaN;
          }
          function K(mt, wt) {
            let $ = mt;
            if (wt === 0 || !$ || $.length === 0) return NaN;
            $ = $.slice(-wt);
            let P = 0;
            return $.reduce((j, J) => {
              let ht = Math.sqrt(J.downloadedBytes);
              return P += ht, j + J.value * ht;
            }, 0) / P;
          }
          function R(mt, wt) {
            let $ = mt;
            if (wt === 0 || !$ || $.length === 0) return NaN;
            $ = $.slice(-wt);
            let P = 0;
            return $.reduce((j, J, ht) => {
              let _t = ht + 1;
              return P += _t, j + J.value * _t;
            }, 0) / P;
          }
          function G(mt, wt) {
            let $ = mt;
            if (wt === 0 || !$ || $.length === 0) return NaN;
            $ = $.slice(-wt);
            const P = $.reduce((j, J) => j + 1 / J.value, 0);
            return $.length / P;
          }
          function F(mt, wt) {
            let $ = mt;
            if (wt === 0 || !$ || $.length === 0) return NaN;
            $ = $.slice(-wt);
            let P = 0;
            const j = $.reduce((J, ht) => {
              let _t = Math.sqrt(ht.downloadedBytes);
              return P += _t, J + 1 / ht.value * _t;
            }, 0);
            return P / j;
          }
          function et(mt, wt) {
            let $ = mt;
            if (wt === 0 || !$ || $.length === 0) return NaN;
            $ = $.slice(-wt);
            let P = 0;
            const j = $.reduce((J, ht, _t) => {
              let Ct = _t + 1;
              return P += Ct, J + 1 / ht.value * Ct;
            }, 0);
            return P / j;
          }
          function it(mt, wt) {
            let $ = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
            if (!mt || mt.totalWeight <= 0) return NaN;
            const P = mt.fastEstimate / (1 - Math.pow(0.5, mt.totalWeight / wt.fast)), j = mt.slowEstimate / (1 - Math.pow(0.5, mt.totalWeight / wt.slow));
            return $ ? Math.min(P, j) : Math.max(P, j);
          }
          function st(mt, wt) {
            if (wt === 0 || !mt || mt.length === 0) return NaN;
            let $ = mt.slice(-wt).map((ht) => ht.value), P = 2 / ($.length + 1), j = $[$.length - 1], J = $[$.length - 1];
            for (let ht = 0; ht < $.length; ht++) j = P * $[ht] + (1 - P) * j, J = P * j + (1 - P) * J;
            return J;
          }
          function ot(mt) {
            let wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            const P = H(X.A.THROUGHPUT_TYPES.BANDWIDTH, mt, wt, $);
            return Math.round(P);
          }
          const ut = { getArithmeticMean: W, getAverageLatency: function(mt) {
            let wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            const P = H(X.A.THROUGHPUT_TYPES.LATENCY, mt, wt, $);
            return Math.round(P);
          }, getAverageThroughput: ot, getByteSizeWeightedArithmeticMean: K, getByteSizeWeightedHarmonicMean: F, getDateWeightedArithmeticMean: R, getDateWeightedHarmonicMean: et, getEwma: it, getHarmonicMean: G, getRawThroughputData: function(mt) {
            return mt ? C.getThroughputDict(mt) : [];
          }, getSafeAverageThroughput: function(mt) {
            let wt = ot(mt, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN);
            return isNaN(wt) || (wt *= v.get().streaming.abr.throughput.bandwidthSafetyFactor), wt;
          }, getZlema: st, initialize: function() {
            C = Nw(A).create({ settings: v }), f.on(At.A.METRIC_ADDED, Y, ut), performance && performance.addEventListener("resourcetimingbufferfull", M);
          }, reset: function() {
            C.reset(), f.off(At.A.METRIC_ADDED, Y, ut), performance && performance.removeEventListener("resourcetimingbufferfull", M);
          }, setConfig: function(mt) {
            mt.settings && (v = mt.settings), mt.playbackController && (_ = mt.playbackController);
          } };
          return ut;
        }
        LI.__dashjs_factory_name = "ThroughputController";
        var Gw = Bt.A.getSingletonFactory(LI);
        function Pc() {
          const A = "You must first call initialize() and set a source before calling this method", f = "You must first call initialize() and set a valid source and view before calling this method", C = "You must first call attachView() to set the video element before calling this method", _ = "You must first call attachSource() with a valid source before calling this method", v = "MediaPlayer not initialized!", M = this.context, Y = (0, Mt.A)(M).getInstance();
          let H = (0, tt.A)(M).getInstance();
          const L = (0, jt.A)(M).getInstance({ settings: H });
          let W, K, R, G, F, et, it, st, ot, ut, mt, wt, $, P, j, J, ht, _t, Ct, bt, Rt, xt, Pt, N, ct, It, dt, nt, ft, rt, Et, kt, Dt, Ut, Wt, ie, de, Be, Oe, nn, _n;
          function ke() {
            Ze(null), Ke(null), G = null, j && (j.reset(), j = null), J && (J.reset(), J = null), Rt && Rt.reset(), H.reset(), _t && (_t.reset(), _t = null);
          }
          function rn() {
            return !!R && !!de.getElement();
          }
          function Cn() {
            return (0, FS.i)();
          }
          function Nn() {
            if (!it) throw f;
            return ft.isPaused();
          }
          function Gn() {
            if (!it) throw f;
            return ft.getIsDynamic();
          }
          function Xt(Tt) {
            const Zt = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
            let he = Dt.getCurrentDVRInfo(Zt);
            return he ? ce(he.range.start + Tt, he) : 0;
          }
          function ce(Tt, Zt) {
            let he = ft.getOriginalLiveDelay();
            return Tt > Zt.range.end - he && (Tt = Zt.range.end - he), Tt;
          }
          function oe() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            if (!it) throw f;
            let Zt = se().currentTime;
            return Tt !== "" && (Zt = It.getTimeRelativeToStreamId(Zt, Tt)), Zt;
          }
          function pe(Tt) {
            (0, xe.sq)(Tt, "boolean"), st = Tt;
          }
          function en() {
            Rt.restoreDefaultUTCTimingSources();
          }
          function mn() {
            return Dt;
          }
          function se() {
            if (!de.getElement()) throw C;
            return de.getElement();
          }
          function Ke(Tt) {
            if (!F) throw v;
            de.setElement(Tt), Tt && (Je(), function() {
              if (J || typeof dashjs == "undefined") return;
              let Zt = dashjs.MetricsReporting;
              typeof Zt == "function" && (J = Zt(M).create().createMetricsReporting({ debug: L, eventBus: Y, mediaElement: se(), adapter: Ct, dashMetrics: Dt, mediaPlayerModel: bt, events: at.A, constants: X.A, metricsConstants: yt }));
            }(), function() {
              if (ht || typeof dashjs == "undefined") return;
              let Zt = dashjs.MssHandler;
              typeof Zt == "function" && (q.extend(Zt.errors), ht = Zt(M).create({ eventBus: Y, mediaPlayerModel: bt, dashMetrics: Dt, manifestModel: Ut, playbackController: ft, streamController: It, protectionController: j, baseURLController: Pt, errHandler: xt, events: at.A, constants: X.A, debug: L, initSegmentType: Ht.G.INIT_SEGMENT_TYPE, BASE64: Yc, ISOBoxer: go, settings: H }));
            }(), It && It.switchToVideoElement(ot)), it && $t(), ue(ot);
          }
          function qe(Tt) {
            if (!et) throw A;
            let Zt = It.getActiveStreamInfo();
            return Zt ? P.getTracksFor(Tt, Zt.id).filter((he) => !j || j.areKeyIdsUsable(he.normalizedKeyIds)) : [];
          }
          function Ze(Tt) {
            let Zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            if (!F) throw v;
            typeof Tt == "string" && Be.initialize(Tt), Zt == null && (Zt = NaN), isNaN(Zt) || (Zt = Math.max(0, Zt)), ot = Zt, R = Tt, (et || it) && $t(), rn() && ue(ot);
          }
          function tn() {
            if (!et) throw A;
            let Tt = It.getActiveStreamInfo();
            return Tt ? It.getStreamById(Tt.id) : null;
          }
          function $t() {
            it = !1, et = !1, Ct.reset(), It.reset(), nt.reset(), kt.reset(), ft.reset(), rt.reset(), Et.reset(), ut.reset(), mt.reset(), P.reset(), nn.reset(), j && (H.get().streaming.protection.keepProtectionMediaKeys ? j.stop() : (j.reset(), j = null, Je())), dt.reset(), Wt.reset(), ie.reset();
          }
          function Se() {
            return IS(M).create({ debug: L, errHandler: xt, dashMetrics: Dt, mediaPlayerModel: bt, mssHandler: ht, settings: H });
          }
          function Je() {
            if (j) return j;
            if (typeof dashjs == "undefined") return null;
            let Tt = dashjs.Protection;
            if (typeof Tt == "function") {
              let Zt = Tt(M).create();
              return at.A.extend(Tt.events), At.A.extend(Tt.events, { publicOnly: !0 }), q.extend(Tt.errors), j = Zt.createProtectionSystem({ debug: L, errHandler: xt, videoModel: de, customParametersModel: Rt, capabilities: N, eventBus: Y, events: at.A, BASE64: Yc, constants: X.A, cmcdModel: Wt, settings: H }), N || (N = (0, Mp.A)(M).getInstance()), N.setProtectionController(j), j;
            }
            return null;
          }
          function $e() {
            if (!F) throw v;
            if (_t) return _t;
            if (typeof dashjs == "undefined") return null;
            let Tt = dashjs.OfflineController;
            if (typeof Tt == "function") {
              at.A.extend(Tt.events), At.A.extend(Tt.events, { publicOnly: !0 }), q.extend(Tt.errors);
              const Zt = Se(), he = fe(M).create();
              return he.setConfig({ manifestModel: Ut, adapter: Ct, manifestLoader: Zt, errHandler: xt, contentSteeringController: Et }), _t = Tt(M).create({ debug: L, manifestUpdater: he, baseURLController: Pt, manifestLoader: Zt, manifestModel: Ut, mediaPlayerModel: bt, abrController: ut, playbackController: ft, adapter: Ct, errHandler: xt, dashMetrics: Dt, timelineConverter: $, segmentBaseController: nn, schemeLoaderFactory: wt, eventBus: Y, events: at.A, errors: q, constants: X.A, settings: H, dashConstants: D.A, urlUtils: He(M).getInstance() }), _t;
            }
            return null;
          }
          function ue() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN;
            _t && _t.resetRecords(), !et && R && (et = !0, K.info("Streaming Initialized"), function() {
              const Zt = Se();
              It || (It = Nr(M).getInstance()), dt || (dt = xw(M).create({ errHandler: xt, manifestModel: Ut, adapter: Ct, mediaController: P, baseURLController: Pt, videoModel: de, settings: H })), ct.setConfig({ capabilities: N, customParametersModel: Rt, adapter: Ct, settings: H, protectionController: j, manifestModel: Ut, errHandler: xt }), It.setConfig({ capabilities: N, capabilitiesFilter: ct, manifestLoader: Zt, manifestModel: Ut, mediaPlayerModel: bt, customParametersModel: Rt, protectionController: j, textController: dt, adapter: Ct, dashMetrics: Dt, errHandler: xt, timelineConverter: $, videoModel: de, playbackController: ft, serviceDescriptionController: rt, contentSteeringController: Et, abrController: ut, throughputController: mt, mediaController: P, settings: H, baseURLController: Pt, uriFragmentModel: Be, segmentBaseController: nn }), nt.setConfig({ settings: H, playbackController: ft, streamController: It, videoModel: de, timelineConverter: $, adapter: Ct }), ft.setConfig({ streamController: It, serviceDescriptionController: rt, dashMetrics: Dt, adapter: Ct, videoModel: de, timelineConverter: $, settings: H }), kt.setConfig({ streamController: It, playbackController: ft, mediaPlayerModel: bt, videoModel: de, settings: H }), mt.setConfig({ settings: H, playbackController: ft }), ut.setConfig({ streamController: It, capabilities: N, domStorage: Oe, mediaPlayerModel: bt, customParametersModel: Rt, throughputController: mt, cmsdModel: ie, dashMetrics: Dt, adapter: Ct, videoModel: de, settings: H }), Wt.setConfig({ abrController: ut, dashMetrics: Dt, playbackController: ft, serviceDescriptionController: rt, throughputController: mt }), _n.setConfig({ serviceDescriptionController: rt }), ie.setConfig({}), P.initialize(), mt.initialize(), ut.initialize(), It.initialize(st, G), dt.initialize(), nt.initialize(), kt.initialize(), Wt.initialize(st), ie.initialize(), Et.initialize(), nn.initialize();
            }(), typeof R == "string" ? It.load(R, Tt) : It.loadWithManifest(R, Tt)), !it && rn() && (it = !0, Y.trigger(At.A.PLAYBACK_INITIALIZED), K.info("Playback Initialized"));
          }
          return W = { addABRCustomRule: function(Tt, Zt, he) {
            Rt.addAbrCustomRule(Tt, Zt, he);
          }, addRequestInterceptor: function(Tt) {
            Rt.addRequestInterceptor(Tt);
          }, addResponseInterceptor: function(Tt) {
            Rt.addResponseInterceptor(Tt);
          }, addUTCTimingSource: function(Tt, Zt) {
            Rt.addUTCTimingSource(Tt, Zt);
          }, attachProtectionController: function(Tt) {
            j = Tt;
          }, attachSource: Ze, attachTTMLRenderingDiv: function(Tt) {
            if (!de.getElement()) throw C;
            de.setTTMLRenderingDiv(Tt);
          }, attachView: Ke, attachVttRenderingDiv: function(Tt) {
            if (!de.getElement()) throw C;
            de.setVttRenderingDiv(Tt);
          }, clearDefaultUTCTimingSources: function() {
            Rt.clearDefaultUTCTimingSources();
          }, convertToTimeCode: function(Tt) {
            Tt = Math.max(Tt, 0);
            let Zt = Math.floor(Tt / 3600), he = Math.floor(Tt % 3600 / 60), qt = Math.floor(Tt % 3600 % 60);
            return (Zt === 0 ? "" : Zt < 10 ? "0" + Zt.toString() + ":" : Zt.toString() + ":") + (he < 10 ? "0" + he.toString() : he.toString()) + ":" + (qt < 10 ? "0" + qt.toString() : qt.toString());
          }, destroy: function() {
            ke(), Bt.A.deleteSingletonInstances(M);
          }, duration: function() {
            if (!it) throw f;
            let Tt = se().duration;
            if (ft.getIsDynamic()) {
              const Zt = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
              let he = Dt.getCurrentDVRInfo(Zt);
              Tt = he ? he.range.end - he.range.start : 0;
            }
            return Tt;
          }, enableForcedTextStreaming: function(Tt) {
            return !(!It.getActiveStreamInfo() || !dt) && dt.enableForcedTextStreaming(Tt);
          }, enableText: function(Tt) {
            const Zt = It.getActiveStreamInfo();
            return !(!Zt || !dt) && dt.enableText(Zt.id, Tt);
          }, extend: function(Tt, Zt, he) {
            Bt.A.extend(Tt, Zt, he, M);
          }, formatUTC: function(Tt, Zt, he) {
            let qt = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
            const Me = new Date(1e3 * Tt), Ve = Me.toLocaleDateString(Zt), fn = Me.toLocaleTimeString(Zt, { hour12: he });
            return qt ? fn + " " + Ve : fn;
          }, getABRCustomRules: function() {
            return Rt.getAbrCustomRules();
          }, getActiveStream: tn, getAutoPlay: function() {
            return st;
          }, getAvailableBaseUrls: function() {
            const Tt = Ut.getValue();
            return Tt ? Pt.getBaseUrls(Tt) : [];
          }, getAvailableLocations: function() {
            const Tt = Ut.getValue();
            if (!Tt) return [];
            const Zt = Ct.getLocation(Tt), he = Et.getSynthesizedLocationElements(Zt);
            return Zt.concat(he);
          }, getAverageLatency: function() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : X.A.VIDEO, Zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return mt ? mt.getAverageLatency(Tt, Zt, he) : 0;
          }, getAverageThroughput: function() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : X.A.VIDEO, Zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return mt ? mt.getAverageThroughput(Tt, Zt, he) : 0;
          }, getBufferLength: function(Tt) {
            const Zt = [X.A.VIDEO, X.A.AUDIO, X.A.TEXT, X.A.MESH];
            if (Tt)
              return Zt.indexOf(Tt) !== -1 ? mn().getCurrentBufferLevel(Tt) || NaN : (K.warn("getBufferLength requested for invalid type"), NaN);
            {
              const he = Zt.map((qt) => qe(qt).length > 0 ? mn().getCurrentBufferLevel(qt) : Number.MAX_VALUE).reduce((qt, Me) => Math.min(qt, Me));
              return he === Number.MAX_VALUE ? NaN : he;
            }
          }, getCurrentLiveLatency: function() {
            if (!F) throw v;
            return it ? ft.getCurrentLiveLatency() : NaN;
          }, getCurrentRepresentationForType: function(Tt) {
            if (!et) throw A;
            if (Tt !== X.A.IMAGE && Tt !== X.A.VIDEO && Tt !== X.A.AUDIO && Tt !== X.A.MESH) return null;
            const Zt = tn();
            if (!Zt) return null;
            if (Tt === X.A.IMAGE) {
              const he = Zt.getThumbnailController();
              return he ? he.getCurrentTrack() : -1;
            }
            return Zt.getCurrentRepresentationForType(Tt);
          }, getCurrentSteeringResponseData: function() {
            if (Et) return Et.getCurrentSteeringResponseData();
          }, getCurrentTextTrackIndex: function() {
            let Tt = NaN;
            const Zt = It.getActiveStreamInfo();
            if (Zt && dt) return Tt = dt.getCurrentTrackIdx(Zt.id), Tt;
          }, getCurrentTrackFor: function(Tt) {
            if (!et) throw A;
            let Zt = It.getActiveStreamInfo();
            return Zt ? P.getCurrentTrackFor(Tt, Zt.id) : null;
          }, getDashAdapter: function() {
            return Ct;
          }, getDashMetrics: mn, getDebug: function() {
            return L;
          }, getDvrSeekOffset: Xt, getDvrWindow: function() {
            if (!it) throw f;
            const Tt = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
            let Zt = Dt.getCurrentDVRInfo(Tt);
            if (!Zt) return {};
            let he = 0;
            const qt = ft.getIsDynamic();
            return qt && (he = Zt.manifestInfo.availableFrom.getTime() / 1e3), { start: Zt.range.start, end: Zt.range.end, startAsUtc: qt ? he + Zt.range.start : NaN, endAsUtc: qt ? he + Zt.range.end : NaN, size: Zt.range.end - Zt.range.start };
          }, getInitialMediaSettingsFor: function(Tt) {
            if (!F) throw v;
            return P.getInitialSettings(Tt);
          }, getLowLatencyModeEnabled: function() {
            if (!it) throw f;
            return ft.getLowLatencyModeEnabled();
          }, getManifest: function() {
            return Ut.getValue();
          }, getOfflineController: function() {
            return $e();
          }, getPlaybackRate: function() {
            return se().playbackRate;
          }, getProtectionController: function() {
            return Je();
          }, getRawThroughputData: function() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : X.A.VIDEO;
            return mt ? mt.getRawThroughputData(Tt) : [];
          }, getRepresentationsByType: function(Tt) {
            let Zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (!et) throw A;
            let he = Zt ? It.getStreamById(Zt) : tn();
            return he ? he.getRepresentationsByType(Tt) : [];
          }, getSafeAverageThroughput: function() {
            let Tt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : X.A.VIDEO, Zt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, he = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return mt ? mt.getSafeAverageThroughput(Tt, Zt, he) : 0;
          }, getSettings: function() {
            return H.get();
          }, getSource: function() {
            if (!R) throw _;
            return R;
          }, getStreamsFromManifest: function(Tt) {
            if (!et) throw A;
            return Ct.getStreamsInfo(Tt);
          }, getTTMLRenderingDiv: function() {
            return de ? de.getTTMLRenderingDiv() : null;
          }, getTargetLiveDelay: function() {
            if (!it) throw f;
            return ft.getOriginalLiveDelay();
          }, getTracksFor: qe, getTracksForTypeFromManifest: function(Tt, Zt, he) {
            if (!et) throw A;
            return (he = he || Ct.getStreamsInfo(Zt, 1)[0]) ? Ct.getAllMediaInfoForType(he, Tt, Zt) : [];
          }, getVersion: Cn, getVideoElement: se, getVolume: function() {
            return se().volume;
          }, getXHRWithCredentialsForType: function(Tt) {
            return Rt.getXHRWithCredentialsForType(Tt);
          }, initialize: function(Tt, Zt, he) {
            let qt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : NaN;
            N || (N = (0, Mp.A)(M).getInstance(), N.setConfig({ settings: H, protectionController: j })), xt || (xt = CS(M).getInstance()), N.supportsMediaSource() ? (F || (F = !0, $ = hw(M).getInstance(), mt || (mt = Gw(M).getInstance()), ut || (ut = eI(M).getInstance()), wt || (wt = Zl(M).getInstance()), ft || (ft = ne(M).getInstance()), P || (P = Z0(M).getInstance()), It || (It = Nr(M).getInstance()), nt || (nt = H0(M).getInstance()), kt || (kt = P0(M).getInstance()), rt || (rt = O0(M).getInstance()), Et || (Et = gt(M).getInstance()), ct || (ct = yS(M).getInstance()), Ct = $S(M).getInstance(), Ut = bS(M).getInstance(), Wt = od(M).getInstance(), ie = yr(M).getInstance(), _n = Wl(M).getInstance(), Dt = fw(M).getInstance({ settings: H }), Oe = PS(M).getInstance({ settings: H }), Ct.setConfig({ constants: X.A, cea608parser: new zt(), errHandler: xt, BASE64: Yc }), Pt || (Pt = eS(M).create()), Pt.setConfig({ adapter: Ct, contentSteeringController: Et }), rt.setConfig({ adapter: Ct }), nn || (nn = KS(M).getInstance({ dashMetrics: Dt, mediaPlayerModel: bt, errHandler: xt, baseURLController: Pt, events: at.A, eventBus: Y, debug: L, boxParser: Vo(M).getInstance(), errors: q })), P.setConfig({ domStorage: Oe, settings: H, mediaPlayerModel: bt, customParametersModel: Rt, videoModel: de }), bt.setConfig({ playbackController: ft, serviceDescriptionController: rt }), Et.setConfig({ adapter: Ct, errHandler: xt, dashMetrics: Dt, mediaPlayerModel: bt, manifestModel: Ut, serviceDescriptionController: rt, throughputController: mt, eventBus: Y }), en(), pe(he === void 0 || he), $e()), Tt && Ke(Tt), Zt && Ze(Zt, qt), K.info("[dash.js " + Cn() + "] MediaPlayer has been initialized")) : xt.error(new Nt.A(q.CAPABILITY_MEDIASOURCE_ERROR_CODE, q.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE));
          }, isDynamic: Gn, isMuted: function() {
            return se().muted;
          }, isPaused: Nn, isReady: rn, isSeeking: function() {
            if (!it) throw f;
            return ft.isSeeking();
          }, isTextEnabled: function() {
            const Tt = It.getActiveStreamInfo();
            return !(!Tt || !dt) && dt.isTextEnabled(Tt);
          }, off: function(Tt, Zt, he) {
            Y.off(Tt, Zt, he);
          }, on: function(Tt, Zt, he, qt) {
            Y.on(Tt, Zt, he, qt);
          }, pause: function() {
            if (!it) throw f;
            ft.pause();
          }, play: function() {
            if (!it) throw f;
            (!st || Nn() && it) && ft.play(!0);
          }, preload: function() {
            if (!de.getElement() && !et) {
              if (!R) throw _;
              ue(ot);
            }
          }, provideThumbnail: function(Tt, Zt) {
            if (typeof Zt != "function") return;
            if (Tt < 0) return void Zt(null);
            const he = ft.getIsDynamic() ? Xt(Tt) : Tt, qt = It.getStreamForTime(he);
            if (qt === null) return void Zt(null);
            const Me = qt.getThumbnailController();
            if (Me) return Me.provide(he, Zt);
            Zt(null);
          }, refreshManifest: function(Tt) {
            if (!F) throw v;
            if (!rn()) return Tt(null, _);
            let Zt = this;
            if (typeof Tt == "function") {
              const he = function(qt) {
                Y.off(at.A.INTERNAL_MANIFEST_LOADED, he, Zt), qt.error ? Tt(null, qt.error) : Tt(qt.manifest);
              };
              Y.on(at.A.INTERNAL_MANIFEST_LOADED, he, Zt);
            }
            It.refreshManifest();
          }, registerCustomCapabilitiesFilter: function(Tt) {
            Rt.registerCustomCapabilitiesFilter(Tt);
          }, registerLicenseRequestFilter: function(Tt) {
            Rt.registerLicenseRequestFilter(Tt);
          }, registerLicenseResponseFilter: function(Tt) {
            Rt.registerLicenseResponseFilter(Tt);
          }, removeABRCustomRule: function(Tt) {
            Rt.removeAbrCustomRule(Tt);
          }, removeAllABRCustomRule: function() {
            Rt.removeAllAbrCustomRule();
          }, removeRequestInterceptor: function(Tt) {
            Rt.removeRequestInterceptor(Tt);
          }, removeResponseInterceptor: function(Tt) {
            Rt.removeResponseInterceptor(Tt);
          }, removeUTCTimingSource: function(Tt, Zt) {
            Rt.removeUTCTimingSource(Tt, Zt);
          }, reset: ke, resetCustomInitialTrackSelectionFunction: function() {
            Rt.resetCustomInitialTrackSelectionFunction(null);
          }, resetSettings: function() {
            H.reset();
          }, restoreDefaultUTCTimingSources: en, retrieveManifest: function(Tt, Zt) {
            let he = Se(), qt = this;
            const Me = function(Ve) {
              Ve.error ? Zt(null, Ve.error) : Zt(Ve.manifest), Y.off(at.A.INTERNAL_MANIFEST_LOADED, Me, qt), he.reset();
            };
            Y.on(at.A.INTERNAL_MANIFEST_LOADED, Me, qt), Be.initialize(Tt), he.load(Tt);
          }, seek: function(Tt) {
            if (!it) throw f;
            if ((0, xe.sq)(Tt, "number"), isNaN(Tt)) throw X.A.BAD_ARGUMENT_ERROR;
            Tt < 0 && (Tt = 0);
            let Zt = ft.getIsDynamic() ? Xt(Tt) : Tt;
            const he = se();
            !ft.getIsDynamic() && he.duration && (Zt = Math.min(he.duration, Zt)), ft.seek(Zt, !1, !1, !0);
          }, seekToOriginalLive: function() {
            it && Gn() && ft.seekToOriginalLive();
          }, seekToPresentationTime: function(Tt) {
            if (!it) throw f;
            if ((0, xe.sq)(Tt, "number"), isNaN(Tt)) throw X.A.BAD_ARGUMENT_ERROR;
            Tt < 0 && (Tt = 0);
            const Zt = se();
            if (!ft.getIsDynamic() && Zt.duration && (Tt = Math.min(Zt.duration, Tt)), ft.getIsDynamic()) {
              const he = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
              let qt = Dt.getCurrentDVRInfo(he);
              if (!qt) return;
              (Tt = ce(Tt, qt)) < qt.range.start && (Tt = qt.range.start);
            }
            ft.seek(Tt, !1, !1, !0);
          }, setAutoPlay: pe, setConfig: function(Tt) {
            Tt && (Tt.capabilities && (N = Tt.capabilities), Tt.capabilitiesFilter && (ct = Tt.capabilitiesFilter), Tt.streamController && (It = Tt.streamController), Tt.textController && (dt = Tt.textController), Tt.gapController && (nt = Tt.gapController), Tt.throughputController && (mt = Tt.throughputController), Tt.playbackController && (ft = Tt.playbackController), Tt.serviceDescriptionController && (rt = Tt.serviceDescriptionController), Tt.contentSteeringController && (Et = Tt.contentSteeringController), Tt.clientDataReportingController && (_n = Tt.clientDataReportingController), Tt.catchupController && (kt = Tt.catchupController), Tt.mediaPlayerModel && (bt = Tt.mediaPlayerModel), Tt.customParametersModel && (Rt = Tt.customParametersModel), Tt.abrController && (ut = Tt.abrController), Tt.schemeLoaderFactory && (wt = Tt.schemeLoaderFactory), Tt.mediaController && (P = Tt.mediaController), Tt.settings && (H = Tt.settings), Tt.dashMetrics && (Dt = Tt.dashMetrics));
          }, setCurrentTrack: function(Tt) {
            let Zt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            if (!et) throw A;
            !j || j.areKeyIdsUsable(Tt.normalizedKeyIds) ? P.setTrack(Tt, { noSettingsSave: Zt }) : K.error(`Can not switch to track with index ${Tt.index} because key is not usable`);
          }, setCustomInitialTrackSelectionFunction: function(Tt) {
            Rt.setCustomInitialTrackSelectionFunction(Tt);
          }, setInitialMediaSettingsFor: function(Tt, Zt) {
            if (!F) throw v;
            let he = function(qt) {
              const Me = H.get().streaming.defaultSchemeIdUri;
              let Ve = {};
              function fn(Bn, Sn, Ia) {
                let Pa = {};
                if (Sn) {
                  if (Sn instanceof Array) throw "Array type not supported for settings!";
                  return Sn instanceof Object ? (Pa.schemeIdUri = Sn.schemeIdUri ? Sn.schemeIdUri : "", Pa.value = Sn.value ? Sn.value : "") : (Pa.schemeIdUri = Ia, Pa.value = Sn, K.warn("No schemeIdUri provided for " + Bn + ', using default "' + Ia + '"')), Pa;
                }
                return null;
              }
              return qt.id !== void 0 && (Ve.id = qt.id), qt.lang !== void 0 && (Ve.lang = qt.lang), isNaN(qt.index) || (Ve.index = qt.index), qt.viewpoint !== void 0 && (Ve.viewpoint = fn("viewpoint", qt.viewpoint, Me.viewpoint)), qt.audioChannelConfiguration !== void 0 && (Ve.audioChannelConfiguration = fn("audioChannelConfiguration", qt.audioChannelConfiguration, Me.audioChannelConfiguration)), qt.role !== void 0 && (Ve.role = fn("role", qt.role, Me.role), Ve.role.schemeIdUri === X.A.DASH_ROLE_SCHEME_ID && Ve.role.value === "Main" && (Ve.role.value = D.A.MAIN)), qt.accessibility !== void 0 && (Ve.accessibility = fn("accessibility", qt.accessibility, Me.accessibility)), Ve;
            }(Zt);
            P.setInitialSettings(Tt, he);
          }, setMute: function(Tt) {
            (0, xe.sq)(Tt, "boolean"), se().muted = Tt;
          }, setPlaybackRate: function(Tt) {
            se().playbackRate = Tt;
          }, setProtectionData: function(Tt) {
            G = Tt, It && It.setProtectionData(G);
          }, setRepresentationForTypeById: function(Tt, Zt) {
            let he = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            if (Tt !== X.A.IMAGE && Tt !== X.A.VIDEO && Tt !== X.A.AUDIO && Tt !== X.A.MESH) return;
            if (!et) throw A;
            const qt = tn();
            if (qt) if (Tt === X.A.IMAGE) {
              const Me = qt.getThumbnailController();
              Me && Me.setTrackById(Zt);
            } else {
              const Me = qt.getRepresentationForTypeById(Tt, Zt);
              Me && ut.setPlaybackQuality(Tt, It.getActiveStreamInfo(), Me, { forceReplace: he });
            }
          }, setRepresentationForTypeByIndex: function(Tt, Zt) {
            let he = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            if (Tt !== X.A.IMAGE && Tt !== X.A.VIDEO && Tt !== X.A.AUDIO && Tt !== X.A.MESH) return;
            if (!et) throw A;
            const qt = tn();
            if (qt) if (Tt === X.A.IMAGE) {
              const Me = qt.getThumbnailController();
              Me && Me.setTrackByIndex(Zt);
            } else {
              const Me = qt.getRepresentationForTypeByIndex(Tt, Zt);
              Me && ut.setPlaybackQuality(Tt, It.getActiveStreamInfo(), Me, { forceReplace: he });
            }
          }, setTextTrack: function(Tt) {
            if (!it) throw f;
            const Zt = It.getActiveStreamInfo();
            Zt && dt && dt.setTextTrack(Zt.id, Tt);
          }, setVolume: function(Tt) {
            if (typeof Tt != "number" || isNaN(Tt) || Tt < 0 || Tt > 1) throw X.A.BAD_ARGUMENT_ERROR;
            se().volume = Tt;
          }, setXHRWithCredentialsForType: function(Tt, Zt) {
            Rt.setXHRWithCredentialsForType(Tt, Zt);
          }, time: oe, timeAsUTC: function() {
            if (!it) throw f;
            if (!ft.getIsDynamic() || oe() < 0) return NaN;
            const Tt = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
            let Zt, he, qt = Dt.getCurrentDVRInfo(Tt);
            return qt ? (Zt = qt.manifestInfo.availableFrom.getTime() / 1e3, he = Zt + oe(), he) : 0;
          }, timeInDvrWindow: function() {
            if (!it) throw f;
            if (!ft.getIsDynamic()) return oe();
            let Tt = se().currentTime;
            const Zt = It && It.hasVideoTrack() ? X.A.VIDEO : X.A.AUDIO;
            let he = Dt.getCurrentDVRInfo(Zt);
            return Tt = he === null || Tt === 0 ? 0 : Math.max(0, Tt - he.range.start), Tt;
          }, trigger: function(Tt, Zt, he) {
            Y.trigger(Tt, Zt, he);
          }, triggerSteeringRequest: function() {
            if (Et) return Et.loadSteeringData();
          }, unregisterCustomCapabilitiesFilter: function(Tt) {
            Rt.unregisterCustomCapabilitiesFilter(Tt);
          }, unregisterLicenseRequestFilter: function(Tt) {
            Rt.unregisterLicenseRequestFilter(Tt);
          }, unregisterLicenseResponseFilter: function(Tt) {
            Rt.unregisterLicenseResponseFilter(Tt);
          }, updateSettings: function(Tt) {
            H.update(Tt);
          }, updateSource: function(Tt) {
            R = Tt, It.load(R);
          } }, K = L.getLogger(W), F = !1, it = !1, et = !1, st = !0, ot = NaN, j = null, _t = null, G = null, Ct = null, nn = null, at.A.extend(At.A), bt = SS(M).getInstance(), Rt = (0, Xl.A)(M).getInstance(), de = YS(M).getInstance(), Be = _S(M).getInstance(), W;
        }
        Pc.__dashjs_factory_name = "MediaPlayer";
        const Dd = Bt.A.getClassFactory(Pc);
        Dd.events = At.A, Dd.errors = q, Bt.A.updateClassFactory(Pc.__dashjs_factory_name, Dd);
        var zw = Dd;
      }, 1191: function(k, g, w) {
        var B = w(7252);
        class c extends B.A {
          constructor() {
            super(), this.AST_IN_FUTURE = "astInFuture", this.BASE_URLS_UPDATED = "baseUrlsUpdated", this.BUFFER_EMPTY = "bufferStalled", this.BUFFER_LOADED = "bufferLoaded", this.BUFFER_LEVEL_STATE_CHANGED = "bufferStateChanged", this.BUFFER_LEVEL_UPDATED = "bufferLevelUpdated", this.DVB_FONT_DOWNLOAD_ADDED = "dvbFontDownloadAdded", this.DVB_FONT_DOWNLOAD_COMPLETE = "dvbFontDownloadComplete", this.DVB_FONT_DOWNLOAD_FAILED = "dvbFontDownloadFailed", this.DYNAMIC_TO_STATIC = "dynamicToStatic", this.ERROR = "error", this.FRAGMENT_LOADING_COMPLETED = "fragmentLoadingCompleted", this.FRAGMENT_LOADING_PROGRESS = "fragmentLoadingProgress", this.FRAGMENT_LOADING_STARTED = "fragmentLoadingStarted", this.FRAGMENT_LOADING_ABANDONED = "fragmentLoadingAbandoned", this.LOG = "log", this.MANIFEST_LOADING_STARTED = "manifestLoadingStarted", this.MANIFEST_LOADING_FINISHED = "manifestLoadingFinished", this.MANIFEST_LOADED = "manifestLoaded", this.METRICS_CHANGED = "metricsChanged", this.METRIC_CHANGED = "metricChanged", this.METRIC_ADDED = "metricAdded", this.METRIC_UPDATED = "metricUpdated", this.PERIOD_SWITCH_STARTED = "periodSwitchStarted", this.PERIOD_SWITCH_COMPLETED = "periodSwitchCompleted", this.QUALITY_CHANGE_REQUESTED = "qualityChangeRequested", this.QUALITY_CHANGE_RENDERED = "qualityChangeRendered", this.NEW_TRACK_SELECTED = "newTrackSelected", this.TRACK_CHANGE_RENDERED = "trackChangeRendered", this.STREAM_INITIALIZING = "streamInitializing", this.STREAM_UPDATED = "streamUpdated", this.STREAM_ACTIVATED = "streamActivated", this.STREAM_DEACTIVATED = "streamDeactivated", this.STREAM_INITIALIZED = "streamInitialized", this.STREAM_TEARDOWN_COMPLETE = "streamTeardownComplete", this.TEXT_TRACKS_ADDED = "allTextTracksAdded", this.TEXT_TRACK_ADDED = "textTrackAdded", this.CUE_ENTER = "cueEnter", this.CUE_EXIT = "cueExit", this.THROUGHPUT_MEASUREMENT_STORED = "throughputMeasurementStored", this.TTML_PARSED = "ttmlParsed", this.TTML_TO_PARSE = "ttmlToParse", this.CAPTION_RENDERED = "captionRendered", this.CAPTION_CONTAINER_RESIZE = "captionContainerResize", this.CAN_PLAY = "canPlay", this.CAN_PLAY_THROUGH = "canPlayThrough", this.PLAYBACK_ENDED = "playbackEnded", this.PLAYBACK_ERROR = "playbackError", this.PLAYBACK_INITIALIZED = "playbackInitialized", this.PLAYBACK_NOT_ALLOWED = "playbackNotAllowed", this.PLAYBACK_METADATA_LOADED = "playbackMetaDataLoaded", this.PLAYBACK_LOADED_DATA = "playbackLoadedData", this.PLAYBACK_PAUSED = "playbackPaused", this.PLAYBACK_PLAYING = "playbackPlaying", this.PLAYBACK_PROGRESS = "playbackProgress", this.PLAYBACK_RATE_CHANGED = "playbackRateChanged", this.PLAYBACK_SEEKED = "playbackSeeked", this.PLAYBACK_SEEKING = "playbackSeeking", this.PLAYBACK_STALLED = "playbackStalled", this.PLAYBACK_STARTED = "playbackStarted", this.PLAYBACK_TIME_UPDATED = "playbackTimeUpdated", this.PLAYBACK_VOLUME_CHANGED = "playbackVolumeChanged", this.PLAYBACK_WAITING = "playbackWaiting", this.MANIFEST_VALIDITY_CHANGED = "manifestValidityChanged", this.EVENT_MODE_ON_START = "eventModeOnStart", this.EVENT_MODE_ON_RECEIVE = "eventModeOnReceive", this.CONFORMANCE_VIOLATION = "conformanceViolation", this.REPRESENTATION_SWITCH = "representationSwitch", this.ADAPTATION_SET_REMOVED_NO_CAPABILITIES = "adaptationSetRemovedNoCapabilities", this.CONTENT_STEERING_REQUEST_COMPLETED = "contentSteeringRequestCompleted", this.INBAND_PRFT = "inbandPrft", this.MANAGED_MEDIA_SOURCE_START_STREAMING = "managedMediaSourceStartStreaming", this.MANAGED_MEDIA_SOURCE_END_STREAMING = "managedMediaSourceEndStreaming";
          }
        }
        let d = new c();
        g.A = d;
      }, 5212: function(k, g) {
        g.A = { MESH: "mesh", STREAM: "stream", VIDEO: "video", AUDIO: "audio", TEXT: "text", MUXED: "muxed", IMAGE: "image", STPP: "stpp", TTML: "ttml", VTT: "vtt", WVTT: "wvtt", CONTENT_STEERING: "contentSteering", LIVE_CATCHUP_MODE_DEFAULT: "liveCatchupModeDefault", LIVE_CATCHUP_MODE_LOLP: "liveCatchupModeLoLP", MOVING_AVERAGE_SLIDING_WINDOW: "slidingWindow", MOVING_AVERAGE_EWMA: "ewma", BAD_ARGUMENT_ERROR: "Invalid Arguments", MISSING_CONFIG_ERROR: "Missing config parameter(s)", TRACK_SWITCH_MODE_ALWAYS_REPLACE: "alwaysReplace", TRACK_SWITCH_MODE_NEVER_REPLACE: "neverReplace", TRACK_SELECTION_MODE_FIRST_TRACK: "firstTrack", TRACK_SELECTION_MODE_HIGHEST_BITRATE: "highestBitrate", TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY: "highestEfficiency", TRACK_SELECTION_MODE_WIDEST_RANGE: "widestRange", CMCD_QUERY_KEY: "CMCD", CMCD_MODE_QUERY: "query", CMCD_MODE_HEADER: "header", CMCD_AVAILABLE_KEYS: ["br", "d", "ot", "tb", "bl", "dl", "mtp", "nor", "nrr", "su", "bs", "rtp", "cid", "pr", "sf", "sid", "st", "v"], CMCD_V2_AVAILABLE_KEYS: ["msd", "ltc"], CMCD_AVAILABLE_REQUESTS: ["segment", "mpd", "xlink", "steering", "other"], INITIALIZE: "initialize", TEXT_SHOWING: "showing", TEXT_HIDDEN: "hidden", TEXT_DISABLED: "disabled", ACCESSIBILITY_CEA608_SCHEME: "urn:scte:dash:cc:cea-608:2015", CC1: "CC1", CC3: "CC3", UTF8: "utf-8", SCHEME_ID_URI: "schemeIdUri", START_TIME: "starttime", SERVICE_DESCRIPTION_DVB_LL_SCHEME: "urn:dvb:dash:lowlatency:scope:2019", SUPPLEMENTAL_PROPERTY_DVB_LL_SCHEME: "urn:dvb:dash:lowlatency:critical:2019", CTA_5004_2023_SCHEME: "urn:mpeg:dash:cta-5004:2023", THUMBNAILS_SCHEME_ID_URIS: ["http://dashif.org/thumbnail_tile", "http://dashif.org/guidelines/thumbnail_tile"], FONT_DOWNLOAD_DVB_SCHEME: "urn:dvb:dash:fontdownload:2014", COLOUR_PRIMARIES_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:ColourPrimaries", URL_QUERY_INFO_SCHEME: "urn:mpeg:dash:urlparam:2014", EXT_URL_QUERY_INFO_SCHEME: "urn:mpeg:dash:urlparam:2016", MATRIX_COEFFICIENTS_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:MatrixCoefficients", TRANSFER_CHARACTERISTICS_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:TransferCharacteristics", HDR_METADATA_FORMAT_SCHEME_ID_URI: "urn:dvb:dash:hdr-dmi", HDR_METADATA_FORMAT_VALUES: { ST2094_10: "ST2094-10", SL_HDR2: "SL-HDR2", ST2094_40: "ST2094-40" }, MEDIA_CAPABILITIES_API: { COLORGAMUT: { SRGB: "srgb", P3: "p3", REC2020: "rec2020" }, TRANSFERFUNCTION: { SRGB: "srgb", PQ: "pq", HLG: "hlg" }, HDR_METADATATYPE: { SMPTE_ST_2094_10: "smpteSt2094-10", SLHDR2: "slhdr2", SMPTE_ST_2094_40: "smpteSt2094-40" } }, XML: "XML", ARRAY_BUFFER: "ArrayBuffer", DVB_REPORTING_URL: "dvb:reportingUrl", DVB_PROBABILITY: "dvb:probability", OFF_MIMETYPE: "application/font-sfnt", WOFF_MIMETYPE: "application/font-woff", VIDEO_ELEMENT_READY_STATES: { HAVE_NOTHING: 0, HAVE_METADATA: 1, HAVE_CURRENT_DATA: 2, HAVE_FUTURE_DATA: 3, HAVE_ENOUGH_DATA: 4 }, FILE_LOADER_TYPES: { FETCH: "fetch_loader", XHR: "xhr_loader" }, THROUGHPUT_TYPES: { LATENCY: "throughput_type_latency", BANDWIDTH: "throughput_type_bandwidth" }, THROUGHPUT_CALCULATION_MODES: { EWMA: "throughputCalculationModeEwma", ZLEMA: "throughputCalculationModeZlema", ARITHMETIC_MEAN: "throughputCalculationModeArithmeticMean", BYTE_SIZE_WEIGHTED_ARITHMETIC_MEAN: "throughputCalculationModeByteSizeWeightedArithmeticMean", DATE_WEIGHTED_ARITHMETIC_MEAN: "throughputCalculationModeDateWeightedArithmeticMean", HARMONIC_MEAN: "throughputCalculationModeHarmonicMean", BYTE_SIZE_WEIGHTED_HARMONIC_MEAN: "throughputCalculationModeByteSizeWeightedHarmonicMean", DATE_WEIGHTED_HARMONIC_MEAN: "throughputCalculationModeDateWeightedHarmonicMean" }, LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE: { MOOF_PARSING: "lowLatencyDownloadTimeCalculationModeMoofParsing", DOWNLOADED_DATA: "lowLatencyDownloadTimeCalculationModeDownloadedData", AAST: "lowLatencyDownloadTimeCalculationModeAast" }, RULES_TYPES: { QUALITY_SWITCH_RULES: "qualitySwitchRules", ABANDON_FRAGMENT_RULES: "abandonFragmentRules" }, QUALITY_SWITCH_RULES: { BOLA_RULE: "BolaRule", THROUGHPUT_RULE: "ThroughputRule", INSUFFICIENT_BUFFER_RULE: "InsufficientBufferRule", SWITCH_HISTORY_RULE: "SwitchHistoryRule", DROPPED_FRAMES_RULE: "DroppedFramesRule", LEARN_TO_ADAPT_RULE: "L2ARule", LOL_PLUS_RULE: "LoLPRule" }, ABANDON_FRAGMENT_RULES: { ABANDON_REQUEST_RULE: "AbandonRequestsRule" }, ID3_SCHEME_ID_URI: "https://aomedia.org/emsg/ID3", COMMON_ACCESS_TOKEN_HEADER: "common-access-token", DASH_ROLE_SCHEME_ID: "urn:mpeg:dash:role:2011", CODEC_FAMILIES: { MP3: "mp3", AAC: "aac", AC3: "ac3", EC3: "ec3", DTSX: "dtsx", DTSC: "dtsc", AVC: "avc", HEVC: "hevc" } };
      }, 2861: function(k, g) {
        g.A = { CLEARKEY_KEYSTEM_STRING: "org.w3.clearkey", WIDEVINE_KEYSTEM_STRING: "com.widevine.alpha", PLAYREADY_KEYSTEM_STRING: "com.microsoft.playready", PLAYREADY_RECOMMENDATION_KEYSTEM_STRING: "com.microsoft.playready.recommendation", WIDEVINE_UUID: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", PLAYREADY_UUID: "9a04f079-9840-4286-ab92-e65be0885f95", CLEARKEY_UUID: "e2719d58-a985-b3c9-781a-b030af78d30e", W3C_CLEARKEY_UUID: "1077efec-c0b2-4d02-ace3-3c1e52e2fb4b", INITIALIZATION_DATA_TYPE_CENC: "cenc", INITIALIZATION_DATA_TYPE_KEYIDS: "keyids", INITIALIZATION_DATA_TYPE_WEBM: "webm", ENCRYPTION_SCHEME_CENC: "cenc", ENCRYPTION_SCHEME_CBCS: "cbcs", MEDIA_KEY_MESSAGE_TYPES: { LICENSE_REQUEST: "license-request", LICENSE_RENEWAL: "license-renewal", LICENSE_RELEASE: "license-release", INDIVIDUALIZATION_REQUEST: "individualization-request" }, ROBUSTNESS_STRINGS: { WIDEVINE: { SW_SECURE_CRYPTO: "SW_SECURE_CRYPTO", SW_SECURE_DECODE: "SW_SECURE_DECODE", HW_SECURE_CRYPTO: "HW_SECURE_CRYPTO", HW_SECURE_DECODE: "HW_SECURE_DECODE", HW_SECURE_ALL: "HW_SECURE_ALL" } }, MEDIA_KEY_STATUSES: { USABLE: "usable", EXPIRED: "expired", RELEASED: "released", OUTPUT_RESTRICTED: "output-restricted", OUTPUT_DOWNSCALED: "output-downscaled", STATUS_PENDING: "status-pending", INTERNAL_ERROR: "internal-error" } };
      }, 4469: function(k, g, w) {
        w.d(g, { default: function() {
          return U;
        } });
        class B {
          constructor() {
            this.mpdurl = null, this.errorcode = null, this.terror = null, this.url = null, this.ipaddress = null, this.servicelocation = null;
          }
        }
        B.SSL_CONNECTION_FAILED_PREFIX = "SSL", B.DNS_RESOLUTION_FAILED = "C00", B.HOST_UNREACHABLE = "C01", B.CONNECTION_REFUSED = "C02", B.CONNECTION_ERROR = "C03", B.CORRUPT_MEDIA_ISOBMFF = "M00", B.CORRUPT_MEDIA_OTHER = "M01", B.BASE_URL_CHANGED = "F00", B.BECAME_REPORTER = "S00";
        var c = B, d = w(913), m = w(138);
        function b(pt) {
          let lt, Gt;
          const ee = (pt = pt || {}).eventBus, Vt = pt.dashMetrics, Jt = pt.metricsConstants, Ot = pt.events;
          function Kt(Te) {
            let ge = new c();
            if (Gt) {
              for (const ze in Te) Te.hasOwnProperty(ze) && (ge[ze] = Te[ze]);
              ge.mpdurl || (ge.mpdurl = Gt.originalUrl || Gt.url), ge.terror || (ge.terror = /* @__PURE__ */ new Date()), Vt.addDVBErrors(ge);
            }
          }
          function ae(Te) {
            Te.error || (Gt = Te.manifest);
          }
          function Qt(Te) {
            Kt({ errorcode: c.BASE_URL_CHANGED, servicelocation: Te.entry });
          }
          function me() {
            Kt({ errorcode: c.BECAME_REPORTER });
          }
          function an(Te) {
            var ge;
            Te.metric === Jt.HTTP_REQUEST && ((ge = Te.value).responsecode === 0 || ge.responsecode == null || ge.responsecode >= 400 || ge.responsecode < 100 || ge.responsecode >= 600) && Kt({ errorcode: ge.responsecode || c.CONNECTION_ERROR, url: ge.url, terror: ge.tresponse, servicelocation: ge._serviceLocation });
          }
          function Ge(Te) {
            let ge;
            switch (Te.error ? Te.error.code : 0) {
              case MediaError.MEDIA_ERR_NETWORK:
                ge = c.CONNECTION_ERROR;
                break;
              case MediaError.MEDIA_ERR_DECODE:
                ge = c.CORRUPT_MEDIA_OTHER;
                break;
              default:
                return;
            }
            Kt({ errorcode: ge });
          }
          return lt = { initialize: function() {
            ee.on(Ot.MANIFEST_UPDATED, ae, lt), ee.on(Ot.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, Qt, lt), ee.on(Ot.METRIC_ADDED, an, lt), ee.on(Ot.METRIC_UPDATED, an, lt), ee.on(Ot.PLAYBACK_ERROR, Ge, lt), ee.on(d.A.BECAME_REPORTING_PLAYER, me, lt);
          }, reset: function() {
            ee.off(Ot.MANIFEST_UPDATED, ae, lt), ee.off(Ot.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, Qt, lt), ee.off(Ot.METRIC_ADDED, an, lt), ee.off(Ot.METRIC_UPDATED, an, lt), ee.off(Ot.PLAYBACK_ERROR, Ge, lt), ee.off(d.A.BECAME_REPORTING_PLAYER, me, lt);
          } }, lt;
        }
        b.__dashjs_factory_name = "DVBErrorsTranslator";
        var y = m.A.getSingletonFactory(b), T = w(7377);
        function n(pt) {
          pt = pt || {};
          let lt, Gt, ee = !1, Vt = this.context, Jt = pt.mediaElement;
          return lt = { initialize: function(Ot) {
            Ot && Ot.length && (Ot.forEach((Kt) => {
              let ae = Kt.starttime, Qt = ae + Kt.duration;
              Gt.add(ae, Qt);
            }), ee = !!Ot[0]._useWallClockTime);
          }, reset: function() {
            Gt.clear();
          }, isEnabled: function() {
            let Ot, Kt = Gt.length;
            if (!Kt) return !0;
            Ot = ee ? (/* @__PURE__ */ new Date()).getTime() / 1e3 : Jt.currentTime;
            for (let ae = 0; ae < Kt; ae += 1) {
              let Qt = Gt.start(ae), me = Gt.end(ae);
              if (Qt <= Ot && Ot < me) return !0;
            }
            return !1;
          } }, Gt = (0, T.A)(Vt).create(), lt;
        }
        n.__dashjs_factory_name = "RangeController";
        var o = m.A.getClassFactory(n);
        function l() {
          return { serialise: function pt(lt) {
            let Gt, ee, Vt = [], Jt = [];
            for (Gt in lt) if (lt.hasOwnProperty(Gt) && Gt.indexOf("_") !== 0) {
              if (ee = lt[Gt], ee == null && (ee = ""), Array.isArray(ee)) {
                if (!ee.length) continue;
                Jt = [], ee.forEach(function(Ot) {
                  let Kt = Object.prototype.toString.call(Ot).slice(8, -1) !== "Object";
                  Jt.push(Kt ? Ot : pt(Ot));
                }), ee = Jt.map(encodeURIComponent).join(",");
              } else typeof ee == "string" ? ee = encodeURIComponent(ee) : ee instanceof Date ? ee = ee.toISOString() : typeof ee == "number" && (ee = Math.round(ee));
              Vt.push(Gt + "=" + ee);
            }
            return Vt.join("&");
          } };
        }
        l.__dashjs_factory_name = "MetricSerialiser";
        var h = m.A.getSingletonFactory(l);
        function p() {
          let pt, lt, Gt, ee = window.crypto || window.msCrypto, Vt = Uint32Array, Jt = Math.pow(2, 8 * Vt.BYTES_PER_ELEMENT) - 1;
          function Ot() {
            ee && (pt || (pt = new Vt(10)), ee.getRandomValues(pt), lt = 0);
          }
          return Gt = { random: function(Kt, ae) {
            let Qt;
            return Kt || (Kt = 0), ae || (ae = 1), ee ? (lt === pt.length && Ot(), Qt = pt[lt] / Jt, lt += 1) : Qt = Math.random(), Qt * (ae - Kt) + Kt;
          } }, Ot(), Gt;
        }
        p.__dashjs_factory_name = "RNG";
        var z = m.A.getSingletonFactory(p), Z = w(1926);
        function V(pt) {
          let lt;
          pt = pt || {};
          let Gt, ee, Vt, Jt, Ot, Kt, ae, Qt = this.context, me = [];
          const an = pt.metricsConstants;
          function Ge() {
            Jt = !1, Ot = !1, Kt = null, ae = null;
          }
          return lt = { report: function(Te, ge) {
            Array.isArray(ge) || (ge = [ge]), Ot && ae.isEnabled() && ge.forEach(function(ze) {
              let Zn = Gt.serialise(ze);
              Te !== an.DVB_ERRORS && (Zn = `metricname=${Te}&${Zn}`), Zn = `${Kt}?${Zn}`, function(qn, Aa, Hn) {
                let xa = new XMLHttpRequest();
                xa.withCredentials = ee.getXHRWithCredentialsForType(an.HTTP_REQUEST_DVB_REPORTING_TYPE);
                const Ee = function() {
                  let xe = me.indexOf(xa);
                  xe !== -1 && (me.splice(xe, 1), !(xa.status >= 200 && xa.status < 300) && Hn && Hn());
                };
                me.push(xa);
                try {
                  xa.open("GET", qn), xa.onloadend = Ee, xa.onerror = Ee, xa.send();
                } catch (xe) {
                  xa.onerror();
                }
              }(Zn, 0, function() {
                Ot = !1;
              });
            });
          }, initialize: function(Te, ge) {
            let ze;
            if (ae = ge, Kt = Te.dvbReportingUrl, !Kt) throw new Error("required parameter missing (dvb:reportingUrl)");
            Jt || (ze = Te.dvbProbability, ze && (ze === 1e3 || ze / 1e3 >= Vt.random()) && (Ot = !0), Jt = !0);
          }, reset: function() {
            Ge();
          } }, Gt = h(Qt).getInstance(), Vt = z(Qt).getInstance(), ee = (0, Z.A)(Qt).getInstance(), Ge(), lt;
        }
        V.__dashjs_factory_name = "DVBReporting";
        var Q = m.A.getClassFactory(V);
        function vt(pt) {
          pt = pt || {};
          const lt = { "urn:dvb:dash:reporting:2014": Q }, Gt = this.context;
          let ee;
          const Vt = pt.debug ? pt.debug.getLogger(ee) : {}, Jt = pt.metricsConstants, Ot = pt.mediaPlayerModel || {};
          return ee = { create: function(Kt, ae) {
            let Qt;
            try {
              Qt = lt[Kt.schemeIdUri](Gt).create({ metricsConstants: Jt, mediaPlayerModel: Ot }), Qt.initialize(Kt, ae);
            } catch (me) {
              Qt = null, Vt.error(`ReportingFactory: could not create Reporting with schemeIdUri ${Kt.schemeIdUri} (${me.message})`);
            }
            return Qt;
          }, register: function(Kt, ae) {
            lt[Kt] = ae;
          }, unregister: function(Kt) {
            delete lt[Kt];
          } }, ee;
        }
        vt.__dashjs_factory_name = "ReportingFactory";
        var Lt = m.A.getSingletonFactory(vt);
        function zt(pt) {
          let lt, Gt = [];
          const ee = Lt(this.context).getInstance(pt);
          return lt = { initialize: function(Vt, Jt) {
            Vt.some((Ot) => {
              let Kt = ee.create(Ot, Jt);
              if (Kt) return Gt.push(Kt), !0;
            });
          }, reset: function() {
            Gt.forEach((Vt) => Vt.reset()), Gt = [];
          }, report: function(Vt, Jt) {
            Gt.forEach((Ot) => Ot.report(Vt, Jt));
          } }, lt;
        }
        zt.__dashjs_factory_name = "ReportingController";
        var X = m.A.getClassFactory(zt);
        function D() {
          return { reconstructFullMetricName: function(pt, lt, Gt) {
            let ee = pt;
            return lt && (ee += "(" + lt, Gt && Gt.length && (ee += "," + Gt), ee += ")"), ee;
          }, validateN: function(pt) {
            if (!pt) throw new Error("missing n");
            if (isNaN(pt)) throw new Error("n is NaN");
            if (pt < 0) throw new Error("n must be positive");
            return pt;
          } };
        }
        D.__dashjs_factory_name = "HandlerHelpers";
        var yt = m.A.getSingletonFactory(D);
        function Mt(pt) {
          let lt, Gt, ee, Vt, Jt, Ot;
          pt = pt || {};
          let Kt = this.context, ae = yt(Kt).getInstance(), Qt = [];
          const me = pt.metricsConstants;
          function an() {
            let Ge = function() {
              try {
                return Object.keys(Qt).map((Te) => Qt[Te]).reduce((Te, ge) => Te.level < ge.level ? Te : ge);
              } catch (Te) {
                return;
              }
            }();
            Ge && Ot !== Ge.t && (Ot = Ge.t, Gt.report(Vt, Ge));
          }
          return lt = { initialize: function(Ge, Te, ge) {
            Te && (ee = ae.validateN(ge), Gt = Te, Vt = ae.reconstructFullMetricName(Ge, ge), Jt = setInterval(an, ee));
          }, reset: function() {
            clearInterval(Jt), Jt = null, ee = 0, Gt = null, Ot = null;
          }, handleNewMetric: function(Ge, Te, ge) {
            Ge === me.BUFFER_LEVEL && (Qt[ge] = Te);
          } }, lt;
        }
        Mt.__dashjs_factory_name = "BufferLevelHandler";
        var at = m.A.getClassFactory(Mt), Bt = m.A.getClassFactory(function(pt) {
          let lt, Gt, ee = (pt = pt || {}).eventBus;
          const Vt = pt.metricsConstants;
          function Jt() {
            ee.off(d.A.METRICS_INITIALISATION_COMPLETE, Jt, this), ee.trigger(d.A.BECAME_REPORTING_PLAYER);
          }
          return lt = { initialize: function(Ot, Kt) {
            Kt && (Gt = Kt, ee.on(d.A.METRICS_INITIALISATION_COMPLETE, Jt, this));
          }, reset: function() {
            Gt = null;
          }, handleNewMetric: function(Ot, Kt) {
            Ot === Vt.DVB_ERRORS && Gt && Gt.report(Ot, Kt);
          } }, lt;
        });
        function jt(pt) {
          let lt, Gt, ee, Vt, Jt, Ot;
          pt = pt || {};
          let Kt = [], ae = yt(this.context).getInstance();
          const Qt = pt.metricsConstants;
          function me() {
            var an = Kt;
            an.length && Gt && Gt.report(Jt, an), Kt = [];
          }
          return lt = { initialize: function(an, Ge, Te, ge) {
            Ge && (ee = ae.validateN(Te), Gt = Ge, ge && ge.length && (Vt = ge), Jt = ae.reconstructFullMetricName(an, Te, ge), Ot = setInterval(me, ee));
          }, reset: function() {
            clearInterval(Ot), Ot = null, ee = null, Vt = null, Kt = [], Gt = null;
          }, handleNewMetric: function(an, Ge) {
            an === Qt.HTTP_REQUEST && (Vt && Vt !== Ge.type || Kt.push(Ge));
          } }, lt;
        }
        jt.__dashjs_factory_name = "HttpListHandler";
        var At = m.A.getClassFactory(jt);
        function Ce() {
          let pt, lt, Gt;
          return pt = { initialize: function(ee, Vt) {
            lt = ee, Gt = Vt;
          }, reset: function() {
            Gt = null, lt = void 0;
          }, handleNewMetric: function(ee, Vt) {
            ee === lt && Gt && Gt.report(lt, Vt);
          } }, pt;
        }
        Ce.__dashjs_factory_name = "GenericMetricHandler";
        var ne = m.A.getClassFactory(Ce);
        function Ht(pt) {
          let lt;
          const Gt = (pt = pt || {}).debug ? pt.debug.getLogger(lt) : {};
          let ee = /([a-zA-Z]*)(\(([0-9]*)(\,\s*([a-zA-Z]*))?\))?/;
          const Vt = this.context;
          let Jt = { BufferLevel: at, DVBErrors: Bt, HttpList: At, PlayList: ne, RepSwitchList: ne, TcpList: ne };
          return lt = { create: function(Ot, Kt) {
            var ae, Qt = Ot.match(ee);
            if (Qt) {
              try {
                (ae = Jt[Qt[1]](Vt).create({ eventBus: pt.eventBus, metricsConstants: pt.metricsConstants })).initialize(Qt[1], Kt, Qt[3], Qt[5]);
              } catch (me) {
                ae = null, Gt.error(`MetricsHandlerFactory: Could not create handler for type ${Qt[1]} with args ${Qt[3]}, ${Qt[5]} (${me.message})`);
              }
              return ae;
            }
          }, register: function(Ot, Kt) {
            Jt[Ot] = Kt;
          }, unregister: function(Ot) {
            delete Jt[Ot];
          } }, lt;
        }
        Ht.__dashjs_factory_name = "MetricsHandlerFactory";
        var Le = m.A.getSingletonFactory(Ht);
        function sn(pt) {
          pt = pt || {};
          let lt, Gt = [];
          const ee = this.context, Vt = pt.eventBus, Jt = pt.events;
          let Ot = Le(ee).getInstance({ debug: pt.debug, eventBus: pt.eventBus, metricsConstants: pt.metricsConstants });
          function Kt(ae) {
            Gt.forEach((Qt) => {
              Qt.handleNewMetric(ae.metric, ae.value, ae.mediaType);
            });
          }
          return lt = { initialize: function(ae, Qt) {
            ae.split(",").forEach((me, an, Ge) => {
              let Te;
              if (me.indexOf("(") !== -1 && me.indexOf(")") === -1) {
                let ge = Ge[an + 1];
                ge && ge.indexOf("(") === -1 && ge.indexOf(")") !== -1 && (me += "," + ge, delete Ge[an + 1]);
              }
              Te = Ot.create(me, Qt), Te && Gt.push(Te);
            }), Vt.on(Jt.METRIC_ADDED, Kt, lt), Vt.on(Jt.METRIC_UPDATED, Kt, lt);
          }, reset: function() {
            Vt.off(Jt.METRIC_ADDED, Kt, lt), Vt.off(Jt.METRIC_UPDATED, Kt, lt), Gt.forEach((ae) => ae.reset()), Gt = [];
          } }, lt;
        }
        sn.__dashjs_factory_name = "MetricsHandlersController";
        var we = m.A.getClassFactory(sn);
        function ln(pt) {
          let lt, Gt, ee, Vt;
          pt = pt || {};
          let Jt = this.context;
          function Ot() {
            lt && lt.reset(), Gt && Gt.reset(), ee && ee.reset();
          }
          return Vt = { initialize: function(Kt) {
            try {
              ee = o(Jt).create({ mediaElement: pt.mediaElement }), ee.initialize(Kt.Range), Gt = X(Jt).create({ debug: pt.debug, metricsConstants: pt.metricsConstants, mediaPlayerModel: pt.mediaPlayerModel }), Gt.initialize(Kt.Reporting, ee), lt = we(Jt).create({ debug: pt.debug, eventBus: pt.eventBus, metricsConstants: pt.metricsConstants, events: pt.events }), lt.initialize(Kt.metrics, Gt);
            } catch (ae) {
              throw Ot(), ae;
            }
          }, reset: Ot }, Vt;
        }
        ln.__dashjs_factory_name = "MetricsController";
        var _e = m.A.getClassFactory(ln), Rn = class {
          constructor() {
            this.metrics = "", this.Range = [], this.Reporting = [];
          }
        }, En = class {
          constructor() {
            this.starttime = 0, this.duration = 1 / 0, this._useWallClockTime = !1;
          }
        }, Tn = class {
          constructor() {
            this.schemeIdUri = "", this.value = "", this.dvbReportingUrl = "", this.dvbProbability = 1e3;
          }
        };
        function Nt(pt) {
          let lt, Gt = (pt = pt || {}).adapter;
          const ee = pt.constants;
          return lt = { getMetrics: function(Vt) {
            let Jt = [];
            return Vt && Vt.Metrics && Vt.Metrics.forEach((Ot) => {
              var Kt = new Rn(), ae = Gt.getIsDynamic(Vt);
              Ot.hasOwnProperty("metrics") && (Kt.metrics = Ot.metrics, Ot.Range && Ot.Range.forEach((Qt) => {
                var me = new En();
                me.starttime = function(an, Ge, Te) {
                  let ge, ze, Zn = 0;
                  return Ge ? Zn = Gt.getAvailabilityStartTime(an) / 1e3 : (ge = Gt.getRegularPeriods(an), ge.length && (Zn = ge[0].start)), ze = Zn, Te && Te.hasOwnProperty(ee.START_TIME) && (ze += Te.starttime), ze;
                }(Vt, ae, Qt), Qt.hasOwnProperty("duration") ? me.duration = Qt.duration : me.duration = Gt.getDuration(Vt), me._useWallClockTime = ae, Kt.Range.push(me);
              }), Ot.Reporting && (Ot.Reporting.forEach((Qt) => {
                var me = new Tn();
                Qt.hasOwnProperty(ee.SCHEME_ID_URI) && (me.schemeIdUri = Qt.schemeIdUri, Qt.hasOwnProperty("value") && (me.value = Qt.value), Qt.hasOwnProperty(ee.DVB_REPORTING_URL) && (me.dvbReportingUrl = Qt[ee.DVB_REPORTING_URL]), Qt.hasOwnProperty(ee.DVB_PROBABILITY) && (me.dvbProbability = Qt[ee.DVB_PROBABILITY]), Kt.Reporting.push(me));
              }), Jt.push(Kt)));
            }), Jt;
          } }, lt;
        }
        Nt.__dashjs_factory_name = "ManifestParsing";
        var Ft = m.A.getSingletonFactory(Nt);
        function ve(pt) {
          let lt;
          pt = pt || {};
          let Gt = {}, ee = this.context, Vt = pt.eventBus;
          const Jt = pt.events;
          function Ot(ae) {
            if (ae.error) return;
            let Qt = Object.keys(Gt);
            Ft(ee).getInstance({ adapter: pt.adapter, constants: pt.constants }).getMetrics(ae.manifest).forEach((me) => {
              const an = JSON.stringify(me);
              if (Gt.hasOwnProperty(an)) Qt.splice(an, 1);
              else try {
                let Ge = _e(ee).create(pt);
                Ge.initialize(me), Gt[an] = Ge;
              } catch (Ge) {
              }
            }), Qt.forEach((me) => {
              Gt[me].reset(), delete Gt[me];
            }), Vt.trigger(d.A.METRICS_INITIALISATION_COMPLETE);
          }
          function Kt() {
            Object.keys(Gt).forEach((ae) => {
              Gt[ae].reset();
            }), Gt = {};
          }
          return lt = { reset: function() {
            Vt.off(Jt.MANIFEST_UPDATED, Ot, lt), Vt.off(Jt.STREAM_TEARDOWN_COMPLETE, Kt, lt);
          } }, Vt.on(Jt.MANIFEST_UPDATED, Ot, lt), Vt.on(Jt.STREAM_TEARDOWN_COMPLETE, Kt, lt), lt;
        }
        ve.__dashjs_factory_name = "MetricsCollectionController";
        var q = m.A.getClassFactory(ve);
        function tt() {
          let pt, lt, Gt = this.context;
          return pt = { createMetricsReporting: function(ee) {
            return lt = y(Gt).getInstance({ eventBus: ee.eventBus, dashMetrics: ee.dashMetrics, metricsConstants: ee.metricsConstants, events: ee.events }), lt.initialize(), q(Gt).create(ee);
          }, getReportingFactory: function() {
            return Lt(Gt).getInstance();
          }, getMetricsHandlerFactory: function() {
            return Le(Gt).getInstance();
          } }, pt;
        }
        tt.__dashjs_factory_name = "MetricsReporting";
        const x = dashjs.FactoryMaker.getClassFactory(tt);
        x.events = d.A, dashjs.FactoryMaker.updateClassFactory(tt.__dashjs_factory_name, x);
        var U = x;
      }, 913: function(k, g, w) {
        var B = w(7252);
        class c extends B.A {
          constructor() {
            super(), this.METRICS_INITIALISATION_COMPLETE = "internal_metricsReportingInitialized", this.BECAME_REPORTING_PLAYER = "internal_becameReportingPlayer", this.CMCD_DATA_GENERATED = "cmcdDataGenerated";
          }
        }
        let d = new c();
        g.A = d;
      }, 1926: function(k, g, w) {
        var B = w(5717), c = w(138), d = w(8261), m = w(656), b = w(5212);
        function y() {
          let T, n, o, l, h, p, z, Z, V, Q;
          const vt = this.context, Lt = (0, d.A)(vt).getInstance();
          function zt() {
            l = [], h = [], p = [], z = [], Z = [], Q = [], V = null, n = [];
          }
          function X(at, Bt) {
            let jt = -1;
            at.some((At, Ce) => {
              if (At === Bt) return jt = Ce, !0;
            }), jt < 0 || at.splice(jt, 1);
          }
          function D(at) {
            let Bt;
            for (Bt = 0; Bt < Q.length; Bt++) if (Q[Bt].rulename === at) return Bt;
            return -1;
          }
          function yt(at, Bt) {
            Mt(at, Bt);
            let jt = new B.A();
            jt.schemeIdUri = at, jt.value = Bt, n.push(jt);
          }
          function Mt(at, Bt) {
            (0, m.sq)(at, "string"), (0, m.sq)(Bt, "string"), n.forEach(function(jt, At) {
              jt.schemeIdUri === at && jt.value === Bt && n.splice(At, 1);
            });
          }
          return T = { addAbrCustomRule: function(at, Bt, jt) {
            if (typeof at != "string" || at !== b.A.RULES_TYPES.ABANDON_FRAGMENT_RULES && at !== b.A.RULES_TYPES.QUALITY_SWITCH_RULES || typeof Bt != "string") throw b.A.BAD_ARGUMENT_ERROR;
            let At = D(Bt);
            At === -1 ? Q.push({ type: at, rulename: Bt, rule: jt }) : (Q[At].type = at, Q[At].rule = jt);
          }, addRequestInterceptor: function(at) {
            l.push(at);
          }, addResponseInterceptor: function(at) {
            h.push(at);
          }, addUTCTimingSource: yt, clearDefaultUTCTimingSources: function() {
            n = [];
          }, getAbrCustomRules: function() {
            return Q;
          }, getCustomCapabilitiesFilters: function() {
            return Z;
          }, getCustomInitialTrackSelectionFunction: function() {
            return V;
          }, getLicenseRequestFilters: function() {
            return p;
          }, getLicenseResponseFilters: function() {
            return z;
          }, getRequestInterceptors: function() {
            return l;
          }, getResponseInterceptors: function() {
            return h;
          }, getUTCTimingSources: function() {
            return n;
          }, getXHRWithCredentialsForType: function(at) {
            const Bt = o[at];
            return Bt === void 0 ? o.default : Bt;
          }, registerCustomCapabilitiesFilter: function(at) {
            Z.push(at);
          }, registerLicenseRequestFilter: function(at) {
            p.push(at);
          }, registerLicenseResponseFilter: function(at) {
            z.push(at);
          }, removeAbrCustomRule: function(at) {
            if (at) {
              let Bt = D(at);
              Bt !== -1 && Q.splice(Bt, 1);
            } else Q = [];
          }, removeAllAbrCustomRule: function() {
            Q = [];
          }, removeRequestInterceptor: function(at) {
            X(l, at);
          }, removeResponseInterceptor: function(at) {
            X(h, at);
          }, removeUTCTimingSource: Mt, reset: function() {
            zt();
          }, resetCustomInitialTrackSelectionFunction: function() {
            V = null;
          }, restoreDefaultUTCTimingSources: function() {
            let at = Lt.get().streaming.utcSynchronization.defaultTimingSource;
            yt(at.scheme, at.value);
          }, setConfig: function() {
          }, setCustomInitialTrackSelectionFunction: function(at) {
            V = at;
          }, setXHRWithCredentialsForType: function at(Bt, jt) {
            Bt ? o[Bt] = !!jt : Object.keys(o).forEach((At) => {
              at(At, jt);
            });
          }, unregisterCustomCapabilitiesFilter: function(at) {
            X(Z, at);
          }, unregisterLicenseRequestFilter: function(at) {
            X(p, at);
          }, unregisterLicenseResponseFilter: function(at) {
            X(z, at);
          } }, o = { default: !1 }, zt(), T;
        }
        y.__dashjs_factory_name = "CustomParametersModel", g.A = c.A.getSingletonFactory(y);
      }, 3888: function(k, g, w) {
        w.d(g, { default: function() {
          return xa;
        } });
        var B = w(8854), c = w(2861);
        const d = { prefixes: ["clearkey", "dashif", "ck"] };
        class m {
          static findMp4ProtectionElement(xe) {
            let Re = null;
            for (let Ie = 0; Ie < xe.length; ++Ie) {
              let Ne = xe[Ie];
              Ne.schemeIdUri && Ne.schemeIdUri.toLowerCase() === B.A.MP4_PROTECTION_SCHEME && Ne.value && (Ne.value.toLowerCase() === c.A.ENCRYPTION_SCHEME_CENC || Ne.value.toLowerCase() === c.A.ENCRYPTION_SCHEME_CBCS) && (Re = Ne);
            }
            return Re;
          }
          static getPSSHData(xe) {
            let Re = 8, Ie = new DataView(xe), Ne = Ie.getUint8(Re);
            return Re += 20, Ne > 0 && (Re += 4 + 16 * Ie.getUint32(Re)), Re += 4, xe.slice(Re);
          }
          static getPSSHForKeySystem(xe, Re) {
            let Ie = m.parsePSSHList(Re);
            return xe && Ie.hasOwnProperty(xe.uuid.toLowerCase()) ? Ie[xe.uuid.toLowerCase()] : null;
          }
          static parseInitDataFromContentProtection(xe, Re) {
            return "pssh" in xe && xe.pssh ? (xe.pssh.__text = xe.pssh.__text.replace(/\r?\n|\r/g, "").replace(/\s+/g, ""), Re.decodeArray(xe.pssh.__text).buffer) : null;
          }
          static parsePSSHList(xe) {
            if (xe == null) return [];
            let Re = new DataView(xe.buffer || xe), Ie = {}, Ne = 0;
            for (; ; ) {
              let Ue, Xe, He, Ae, be, We, zn = Ne;
              if (Ne >= Re.buffer.byteLength) break;
              if (Ue = Re.getUint32(Ne), Xe = Ne + Ue, Ne += 4, Re.getUint32(Ne) === 1886614376) if (Ne += 4, He = Re.getUint8(Ne), He === 0 || He === 1) {
                for (Ne++, Ne += 3, Ae = "", be = 0; be < 4; be++) We = Re.getUint8(Ne + be).toString(16), Ae += We.length === 1 ? "0" + We : We;
                for (Ne += 4, Ae += "-", be = 0; be < 2; be++) We = Re.getUint8(Ne + be).toString(16), Ae += We.length === 1 ? "0" + We : We;
                for (Ne += 2, Ae += "-", be = 0; be < 2; be++) We = Re.getUint8(Ne + be).toString(16), Ae += We.length === 1 ? "0" + We : We;
                for (Ne += 2, Ae += "-", be = 0; be < 2; be++) We = Re.getUint8(Ne + be).toString(16), Ae += We.length === 1 ? "0" + We : We;
                for (Ne += 2, Ae += "-", be = 0; be < 6; be++) We = Re.getUint8(Ne + be).toString(16), Ae += We.length === 1 ? "0" + We : We;
                Ne += 6, Ae = Ae.toLowerCase(), Ne += 4, Ie[Ae] = Re.buffer.slice(zn, Xe), Ne = Xe;
              } else Ne = Xe;
              else Ne = Xe;
            }
            return Ie;
          }
          static getLicenseServerUrlFromMediaInfo(xe, Re) {
            try {
              if (!xe || xe.length === 0) return null;
              let Ie = 0, Ne = null;
              for (; Ie < xe.length && !Ne; ) {
                const Ue = xe[Ie];
                if (Ue && Ue.contentProtection && Ue.contentProtection.length > 0) {
                  const Xe = Ue.contentProtection.filter((He) => He.schemeIdUri && He.schemeIdUri === Re);
                  if (Xe && Xe.length > 0) {
                    let He = 0;
                    for (; He < Xe.length && !Ne; ) {
                      const Ae = Xe[He];
                      Ae.laUrl && Ae.laUrl.__prefix && d.prefixes.includes(Ae.laUrl.__prefix) && Ae.laUrl.__text && (Ne = Ae.laUrl.__text), He += 1;
                    }
                  }
                }
                Ie += 1;
              }
              return Ne;
            } catch (Ie) {
              return null;
            }
          }
          static hexKidToBufferSource(xe) {
            const Re = xe.replace(/-/g, "");
            return new Uint8Array(Re.match(/[\da-f]{2}/gi).map(function(Ie) {
              return parseInt(Ie, 16);
            })).buffer;
          }
        }
        var b = m, y = class {
          constructor(Ee, xe) {
            this.contentType = Ee, this.robustness = xe;
          }
        }, T = class {
          constructor(Ee, xe, Re, Ie, Ne, Ue) {
            this.initDataTypes = Ue && Ue.length > 0 ? Ue : [c.A.INITIALIZATION_DATA_TYPE_CENC], Ee && Ee.length && (this.audioCapabilities = Ee), xe && xe.length && (this.videoCapabilities = xe), this.distinctiveIdentifier = Re, this.persistentState = Ie, this.sessionTypes = Ne;
          }
        }, n = w(1923), o = w(1944), l = class {
          constructor(Ee, xe, Re, Ie, Ne, Ue, Xe, He) {
            this.url = Ee, this.method = xe, this.responseType = Re, this.headers = Ie, this.withCredentials = Ne, this.messageType = Ue, this.sessionId = Xe, this.data = He;
          }
        }, h = class {
          constructor(Ee, xe, Re) {
            this.url = Ee, this.headers = xe, this.data = Re;
          }
        }, p = w(7568), z = w(7263), Z = w(5212), V = w(138);
        function Q(Ee) {
          const xe = (Ee = Ee || {}).BASE64, Re = Ee.cmcdModel, Ie = Ee.constants, Ne = Ee.customParametersModel, Ue = Ee.debug, Xe = Ee.eventBus, He = Ee.events, Ae = Ee.protectionKeyController, be = Ee.settings;
          let We, zn, Pe, pn, yn, wn, vn, Pn, In, ye, le, Qe, on = Ee.protectionModel, Dn = [];
          function Wn() {
            if (!(Xe && Xe.hasOwnProperty("on") && Ae && Ae.hasOwnProperty("getSupportedKeySystemMetadataFromContentProtection"))) throw new Error("Missing config parameter(s)");
          }
          function oa(Fe, dn) {
            le || pn ? le && jn() : function(kn, Jn) {
              if (pn) return;
              var On;
              pn = !0;
              const Ra = function($n) {
                const xn = [];
                for (let Vn = 0; Vn < $n.length; Vn++) {
                  const ua = ha($n[Vn]);
                  xn.push({ ks: $n[Vn].ks, configs: [ua], protData: $n[Vn].protData });
                }
                return xn;
              }(kn = (On = kn).sort(($n, xn) => (We && We[$n.ks.systemString] && We[$n.ks.systemString].priority >= 0 ? We[$n.ks.systemString].priority : On.length) - (We && We[xn.ks.systemString] && We[xn.ks.systemString].priority >= 0 ? We[xn.ks.systemString].priority : On.length)));
              let la;
              on.requestKeySystemAccess(Ra).then(($n) => (la = $n.data, function(xn) {
                let Vn = xn && xn.selectedSystemString ? xn.selectedSystemString : xn.keySystem.systemString;
                return vn.info("DRM: KeySystem Access Granted for system string (" + Vn + ")!  Selecting key system..."), on.selectKeySystem(xn);
              }(la))).then(($n) => {
                (function(xn, Vn) {
                  le = xn, pn = !1, Xe.trigger(He.KEY_SYSTEM_SELECTED, { data: Vn });
                  const ua = ei(le);
                  ua && ua.serverCertificate && ua.serverCertificate.length > 0 && on.setServerCertificate(xe.decodeArray(ua.serverCertificate).buffer), jn();
                })($n, la);
              }).catch(($n) => {
                (function(xn, Vn) {
                  le = null, pn = !1, Vn || Xe.trigger(He.KEY_SYSTEM_SELECTED, { data: null, error: new o.A(n.A.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, n.A.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + "Error selecting key system! -- " + xn.error) });
                })($n, Jn);
              });
            }(Fe, dn);
          }
          function jn() {
            let Fe;
            for (let kn = 0; kn < In.length; kn++) for (Fe = 0; Fe < In[kn].length; Fe++) if (le === In[kn][Fe].ks) {
              dn = In[kn][Fe], Ae.isClearKey(le) && function(Jn) {
                if (Jn.protData && Jn.protData.hasOwnProperty("clearkeys") && Object.keys(Jn.protData.clearkeys).length !== 0) {
                  const On = { kids: Object.keys(Jn.protData.clearkeys) };
                  Jn.initData = new TextEncoder().encode(JSON.stringify(On));
                }
              }(dn), dn.sessionId ? va(dn) : dn.initData !== null && _a(dn);
              break;
            }
            var dn;
            In = [];
          }
          function ha(Fe) {
            const dn = Fe.protData, kn = [], Jn = [], On = dn && dn.initDataTypes && dn.initDataTypes.length > 0 ? dn.initDataTypes : [c.A.INITIALIZATION_DATA_TYPE_CENC], Ra = dn && dn.audioRobustness && dn.audioRobustness.length > 0 ? dn.audioRobustness : ye, la = dn && dn.videoRobustness && dn.videoRobustness.length > 0 ? dn.videoRobustness : ye, $n = Fe.sessionType, xn = dn && dn.distinctiveIdentifier ? dn.distinctiveIdentifier : "optional", Vn = dn && dn.persistentState ? dn.persistentState : $n === "temporary" ? "optional" : "required";
            return Pn.forEach((ua) => {
              ua.type === Ie.AUDIO ? kn.push(new y(ua.codec, Ra)) : ua.type === Ie.VIDEO && Jn.push(new y(ua.codec, la));
            }), new T(kn, Jn, xn, Vn, [$n], On);
          }
          function va(Fe) {
            Wn(), on.loadKeySession(Fe);
          }
          function _a(Fe) {
            if (Fe && function(kn) {
              if (!kn) return !1;
              try {
                const Jn = on.getSessionTokens();
                for (let On = 0; On < Jn.length; On++) if (Jn[On].getKeyId() === kn) return !0;
                return !1;
              } catch (Jn) {
                return !1;
              }
            }(Fe.keyId)) return;
            const dn = b.getPSSHForKeySystem(le, Fe ? Fe.initData : null);
            if (dn) {
              if (ni(dn)) return;
              try {
                Fe.initData = dn, on.createKeySession(Fe);
              } catch (kn) {
                Xe.trigger(He.KEY_SESSION_CREATED, { data: null, error: new o.A(n.A.KEY_SESSION_CREATED_ERROR_CODE, n.A.KEY_SESSION_CREATED_ERROR_MESSAGE + kn.message) });
              }
            } else Fe && Fe.initData ? on.createKeySession(Fe) : Xe.trigger(He.KEY_SESSION_CREATED, { data: null, error: new o.A(n.A.KEY_SESSION_CREATED_ERROR_CODE, n.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Selected key system is " + (le ? le.systemString : null) + ".  needkey/encrypted event contains no initData corresponding to that key system!") });
          }
          function ei(Fe) {
            if (Fe) {
              const dn = Fe.systemString;
              if (We) return dn in We ? We[dn] : null;
            }
            return null;
          }
          function ni(Fe) {
            if (!Fe) return !1;
            try {
              const dn = on.getAllInitData();
              for (let kn = 0; kn < dn.length; kn++) if (Ae.initDataEquals(Fe, dn[kn])) return vn.debug("DRM: Ignoring initData because we have already seen it!"), !0;
              return !1;
            } catch (dn) {
              return !1;
            }
          }
          function nr(Fe) {
            Wn(), Fe ? (on.setMediaElement(Fe), Xe.on(He.NEED_KEY, cs, zn)) : Fe === null && (on.setMediaElement(Fe), Xe.off(He.NEED_KEY, cs, zn));
          }
          function Ma(Fe) {
            vn.debug("DRM: onKeyMessage");
            const dn = Fe.data;
            Xe.trigger(He.KEY_MESSAGE, { data: dn });
            const kn = dn.messageType ? dn.messageType : c.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST, Jn = dn.message, On = dn.sessionToken, Ra = ei(le), la = Ae.getLicenseServerModelInstance(le, Ra, kn), $n = { sessionToken: On, messageType: kn };
            if (Jn && Jn.byteLength !== 0) {
              if (!la) return vn.debug("DRM: License server request not required for this message (type = " + Fe.data.messageType + ").  Session ID = " + On.getSessionId()), void ba($n);
              if (Ae.isClearKey(le)) {
                const xn = Ae.processClearKeyLicenseRequest(le, Ra, Jn);
                if (xn && xn.keyPairs && xn.keyPairs.length > 0) return vn.debug("DRM: ClearKey license request handled by application!"), ba($n), void on.updateKeySession(On, xn);
              }
              (function(xn, Vn, ua) {
                const Ui = xn.sessionToken, si = xn.messageType ? xn.messageType : c.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST, ai = { sessionToken: Ui, messageType: si }, Va = le ? le.systemString : null;
                let Ei = function(ma, ir, Dr, Br, da) {
                  let gi = null;
                  const xo = Br.message;
                  if (ma && ma.serverURL) {
                    const ki = ma.serverURL;
                    typeof ki == "string" && ki !== "" ? gi = ki : typeof ki == "object" && ki.hasOwnProperty(ir) && (gi = ki[ir]);
                  } else if (ma && ma.laURL && ma.laURL !== "") gi = ma.laURL;
                  else if (gi = b.getLicenseServerUrlFromMediaInfo(Pn, le.schemeIdURI), !gi && !Ae.isClearKey(le)) {
                    const ki = b.getPSSHData(Dr.initData);
                    gi = le.getLicenseServerURLFromInitData(ki), gi || (gi = Br.laURL);
                  }
                  return gi = da.getServerURLFromMessage(gi, xo, ir), gi;
                }(ua, si, Ui, xn, Vn);
                if (!Ei) return void ba(ai, new o.A(n.A.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));
                const Rr = {};
                let eo = !1;
                ua && $s(Rr, ua.httpRequestHeaders);
                const Do = xn.message;
                $s(Rr, le.getRequestHeadersFromMessage(Do)), Object.keys(Rr).forEach((ma) => {
                  ma.toLowerCase() === "authorization" && (eo = !0);
                }), ua && typeof ua.withCredentials == "boolean" && (eo = ua.withCredentials);
                const Ki = function(ma) {
                  if (on) if (ma.status >= 200 && ma.status <= 299) {
                    const ir = z.A.parseHttpHeaders(ma.getAllResponseHeaders ? ma.getAllResponseHeaders() : null);
                    let Dr = new h(ma.responseURL, ir, ma.response);
                    Ro(Ne.getLicenseResponseFilters(), Dr).then(() => {
                      const Br = Vn.getLicenseMessage(Dr.data, Va, si);
                      Br !== null ? (ba(ai), on.updateKeySession(Ui, Br)) : Mo(ma, ai, Va, si, Vn);
                    });
                  } else Mo(ma, ai, Va, si, Vn);
                }, ar = function(ma) {
                  ba(ai, new o.A(n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + Va + ' update, XHR aborted. status is "' + ma.statusText + '" (' + ma.status + "), readyState is " + ma.readyState));
                }, ms = function(ma) {
                  ba(ai, new o.A(n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + Va + ' update, XHR error. status is "' + ma.statusText + '" (' + ma.status + "), readyState is " + ma.readyState));
                }, Ti = le.getLicenseRequestFromMessage(Do), Bo = Vn.getHTTPMethod(si), no = Vn.getResponseType(Va, si), fs = ua && !isNaN(ua.httpTimeout) ? ua.httpTimeout : 8e3, ao = Ui.getSessionId() || null;
                let hs = new l(Ei, Bo, no, Rr, eo, si, ao, Ti);
                const Cr = isNaN(be.get().streaming.retryAttempts[p.G.LICENSE]) ? 3 : be.get().streaming.retryAttempts[p.G.LICENSE];
                Ro(Ne.getLicenseRequestFilters(), hs).then(() => {
                  Ka(hs, Cr, fs, Ki, ar, ms);
                });
              })(dn, la, Ra);
            } else ba($n, new o.A(n.A.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));
          }
          function ba(Fe) {
            let dn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            Xe.trigger(He.LICENSE_REQUEST_COMPLETE, { data: Fe, error: dn });
          }
          function Ka(Fe, dn, kn, Jn, On, Ra) {
            const la = new XMLHttpRequest(), $n = Re.getCmcdParametersFromManifest();
            if (Re.isCmcdEnabled() && ($n.mode ? $n.mode : be.get().streaming.cmcd.mode) === Z.A.CMCD_MODE_QUERY) {
              const Vn = Re.getQueryParameter({ url: Fe.url, type: p.G.LICENSE });
              Vn && (Fe.url = z.A.addAdditionalQueryParameterToUrl(Fe.url, [Vn]));
            }
            la.open(Fe.method, Fe.url, !0), la.responseType = Fe.responseType, la.withCredentials = Fe.withCredentials, kn > 0 && (la.timeout = kn);
            for (const Vn in Fe.headers) la.setRequestHeader(Vn, Fe.headers[Vn]);
            if (Re.isCmcdEnabled() && ($n.mode ? $n.mode : be.get().streaming.cmcd.mode) === Z.A.CMCD_MODE_HEADER) {
              const Vn = Re.getHeaderParameters({ url: Fe.url, type: p.G.LICENSE });
              if (Vn) for (const ua in Vn) {
                let Ui = Vn[ua];
                Ui && la.setRequestHeader(ua, Ui);
              }
            }
            const xn = function() {
              dn--;
              const Vn = isNaN(be.get().streaming.retryIntervals[p.G.LICENSE]) ? 1e3 : be.get().streaming.retryIntervals[p.G.LICENSE];
              yn = setTimeout(function() {
                Ka(Fe, dn, kn, Jn, On, Ra);
              }, Vn);
            };
            la.onload = function() {
              wn = null, this.status >= 200 && this.status <= 299 || dn <= 0 ? Jn(this) : (vn.warn("License request failed (" + this.status + "). Retrying it... Pending retries: " + dn), xn());
            }, la.ontimeout = la.onerror = function() {
              wn = null, dn <= 0 ? Ra(this) : (vn.warn("License request network request failed . Retrying it... Pending retries: " + dn), xn());
            }, la.onabort = function() {
              On(this);
            }, Xe.trigger(He.LICENSE_REQUEST_SENDING, { url: Fe.url, headers: Fe.headers, payload: Fe.data, sessionId: Fe.sessionId }), wn = la, la.send(Fe.data);
          }
          function Lo() {
            wn && (wn.onloadend = wn.onerror = wn.onprogress = void 0, wn.abort(), wn = null), yn && (clearTimeout(yn), yn = null);
          }
          function $s(Fe, dn) {
            if (dn) for (const kn in dn) Fe[kn] = dn[kn];
          }
          function Mo(Fe, dn, kn, Jn, On) {
            let Ra = "NONE", la = null;
            Fe.response && (Ra = On.getErrorResponse(Fe.response, kn, Jn), la = { serverResponse: Fe.response || null, responseCode: Fe.status || null, responseText: Fe.statusText || null }), ba(dn, new o.A(n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + kn + ' update, XHR complete. status is "' + Fe.statusText + '" (' + Fe.status + "), readyState is " + Fe.readyState + ".  Response is " + Ra, la));
          }
          function Ro(Fe, dn) {
            return Fe ? Fe.reduce((kn, Jn) => kn.then(() => Jn(dn)), Promise.resolve()) : Promise.resolve();
          }
          function cs(Fe, dn) {
            if (be.get().streaming.protection.ignoreEmeEncryptedEvent) return;
            if (vn.debug("DRM: onNeedKey"), Fe.key.initDataType !== c.A.INITIALIZATION_DATA_TYPE_CENC) return void vn.warn("DRM:  Only 'cenc' initData is supported!  Ignoring initData of type: " + Fe.key.initDataType);
            if (Pn.length === 0 && (vn.warn("DRM: onNeedKey called before initializeForMedia, wait until initialized"), (dn = dn === void 0 ? 1 : dn + 1) < 5)) return void Dn.push(setTimeout(() => {
              cs(Fe, dn);
            }, 500));
            let kn = Fe.key.initData;
            if (ArrayBuffer.isView(kn) && (kn = kn.buffer), le) {
              const On = b.getPSSHForKeySystem(le, kn);
              if (On && ni(On)) return;
            }
            vn.debug("DRM: initData:", String.fromCharCode.apply(null, new Uint8Array(kn)));
            const Jn = Ae.getSupportedKeySystemMetadataFromSegmentPssh(kn, We, Qe);
            Jn.length !== 0 ? function(On) {
              In.push(On), oa(On, !1);
            }(Jn) : vn.debug("DRM: Received needkey event with initData, but we don't support any of the key systems!");
          }
          function to(Fe, dn) {
            if (Fe.size <= 0) return !1;
            if (dn.size > 0 && [...Fe].every((Jn) => {
              const On = dn.get(Jn);
              return On !== void 0 && On !== "";
            })) return !0;
            const kn = on.getSessionTokens();
            if (kn && kn.length > 0) {
              const Jn = kn.filter((On) => [...Fe].includes(On.normalizedKeyId));
              if (Jn.some((On) => !On.hasTriggeredKeyStatusMapUpdate) || Jn.length === 0) return !1;
            }
            return !be.get().streaming.protection.ignoreKeyStatuses && Fe && Fe.size > 0 && dn && dn.size > 0;
          }
          return zn = { areKeyIdsExpired: function(Fe) {
            try {
              return !!to(Fe, Pe) && [...Fe].every((dn) => Pe.get(dn) === c.A.MEDIA_KEY_STATUSES.EXPIRED);
            } catch (dn) {
              return vn.error(dn), !1;
            }
          }, areKeyIdsUsable: function(Fe) {
            try {
              return !to(Fe, Pe) || [...Fe].some((dn) => {
                const kn = Pe.get(dn);
                return kn && kn !== c.A.MEDIA_KEY_STATUSES.INTERNAL_ERROR && kn !== c.A.MEDIA_KEY_STATUSES.OUTPUT_RESTRICTED;
              });
            } catch (dn) {
              return vn.error(dn), !0;
            }
          }, clearMediaInfoArray: function() {
            Pn = [];
          }, closeKeySession: function(Fe) {
            Wn(), on.closeKeySession(Fe);
          }, createKeySession: _a, getKeySystems: function() {
            return Ae ? Ae.getKeySystems() : [];
          }, getSupportedKeySystemMetadataFromContentProtection: function(Fe) {
            return Wn(), Ae.getSupportedKeySystemMetadataFromContentProtection(Fe, We, Qe);
          }, handleKeySystemFromManifest: function() {
            if (!Pn || Pn.length === 0) return;
            let Fe = [];
            Pn.forEach((dn) => {
              const kn = Ae.getSupportedKeySystemMetadataFromContentProtection(dn.contentProtection, We, Qe);
              kn.length > 0 && (Fe.length === 0 && (Fe = kn), In.push(kn));
            }), Fe && Fe.length > 0 && oa(Fe, !0);
          }, initializeForMedia: function(Fe) {
            if (!Fe) throw new Error("mediaInfo can not be null or undefined");
            Wn(), Pn.push(Fe);
          }, loadKeySession: va, removeKeySession: function(Fe) {
            Wn(), on.removeKeySession(Fe);
          }, reset: function() {
            Xe.off(He.INTERNAL_KEY_MESSAGE, Ma, zn), Wn(), Lo(), nr(null), le = null, pn = !1, Pe = /* @__PURE__ */ new Map(), on && (on.reset(), on = null), Dn.forEach((Fe) => clearTimeout(Fe)), Dn = [], Pn = [], In = [];
          }, setKeySystems: function(Fe) {
            Ae && Ae.setKeySystems(Fe);
          }, setMediaElement: nr, setProtectionData: function(Fe) {
            We = Fe, Ae.setProtectionData(Fe);
          }, setRobustnessLevel: function(Fe) {
            ye = Fe;
          }, setServerCertificate: function(Fe) {
            Wn(), on.setServerCertificate(Fe);
          }, setSessionType: function(Fe) {
            Qe = Fe;
          }, stop: function() {
            Lo(), on && on.stop();
          }, updateKeyStatusesMap: function(Fe) {
            try {
              if (!Fe || !Fe.sessionToken || !Fe.parsedKeyStatuses) return;
              Fe.sessionToken.hasTriggeredKeyStatusMapUpdate = !0;
              const dn = Fe.parsedKeyStatuses, kn = z.A.parseUserAgent(), Jn = kn && kn.browser && kn.browser.name && kn.browser.name.toLowerCase() === "edge";
              dn.forEach((On) => {
                Jn && le.uuid === c.A.PLAYREADY_UUID && On.keyId && On.keyId.byteLength === 16 && function(la) {
                  const $n = z.A.bufferSourceToDataView(la), xn = $n.getUint32(0, !0), Vn = $n.getUint16(4, !0), ua = $n.getUint16(6, !0);
                  $n.setUint32(0, xn, !1), $n.setUint16(4, Vn, !1), $n.setUint16(6, ua, !1);
                }(On.keyId);
                const Ra = z.A.bufferSourceToHex(On.keyId).slice(0, 32);
                Ra && Ra !== "" && Pe.set(Ra, On.status);
              }), Xe.trigger(He.KEY_STATUSES_MAP_UPDATED, { keyStatusMap: Pe });
            } catch (dn) {
              vn.error(dn);
            }
          } }, vn = Ue.getLogger(zn), In = [], Pn = [], Qe = "temporary", ye = "", wn = null, yn = null, Pe = /* @__PURE__ */ new Map(), Xe.on(He.INTERNAL_KEY_MESSAGE, Ma, zn), zn;
        }
        Q.__dashjs_factory_name = "ProtectionController";
        var vt = V.A.getClassFactory(Q), Lt = class {
          constructor(Ee, xe) {
            this.keyID = Ee, this.key = xe;
          }
        }, zt = class {
          constructor(Ee, xe) {
            if (xe && xe !== "persistent" && xe !== "temporary") throw new Error("Invalid ClearKey key set type!  Must be one of 'persistent' or 'temporary'");
            this.keyPairs = Ee, this.type = xe;
          }
          toJWK() {
            let Ee, xe = this.keyPairs.length, Re = { keys: [] };
            for (Ee = 0; Ee < xe; Ee++) {
              let He = { kty: "oct", alg: "A128KW", kid: this.keyPairs[Ee].keyID, k: this.keyPairs[Ee].key };
              Re.keys.push(He);
            }
            this.type && (Re.type = this.type);
            let Ie = JSON.stringify(Re);
            const Ne = Ie.length;
            let Ue = new ArrayBuffer(Ne), Xe = new Uint8Array(Ue);
            for (Ee = 0; Ee < Ne; Ee++) Xe[Ee] = Ie.charCodeAt(Ee);
            return Ue;
          }
        };
        const X = c.A.CLEARKEY_UUID, D = c.A.CLEARKEY_KEYSTEM_STRING, yt = "urn:uuid:" + X;
        function Mt(Ee) {
          let xe;
          const Re = (Ee = Ee || {}).BASE64;
          return xe = { uuid: X, schemeIdURI: yt, systemString: D, getInitData: function(Ie, Ne) {
            try {
              let Ue = b.parseInitDataFromContentProtection(Ie, Re);
              if (!Ue && Ne) {
                const Xe = { kids: [function(He) {
                  try {
                    let Ae = He.replace(/-/g, "");
                    return Ae = btoa(Ae.match(/\w{2}/g).map((be) => String.fromCharCode(parseInt(be, 16))).join("")), Ae.replace(/=/g, "").replace(/\//g, "_").replace(/\+/g, "-");
                  } catch (Ae) {
                    return null;
                  }
                }(Ne.cencDefaultKid)] };
                Ue = new TextEncoder().encode(JSON.stringify(Xe));
              }
              return Ue;
            } catch (Ue) {
              return null;
            }
          }, getRequestHeadersFromMessage: function() {
            return { "Content-Type": "application/json" };
          }, getLicenseRequestFromMessage: function(Ie) {
            return JSON.stringify(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(Ie))));
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          }, getClearKeysFromProtectionData: function(Ie, Ne) {
            let Ue = null;
            if (Ie) {
              const Xe = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(Ne))), He = [];
              for (let Ae = 0; Ae < Xe.kids.length; Ae++) {
                const be = Xe.kids[Ae], We = Ie.clearkeys && Ie.clearkeys.hasOwnProperty(be) ? Ie.clearkeys[be] : null;
                if (!We) throw new Error("DRM: ClearKey keyID (" + be + ") is not known!");
                He.push(new Lt(be, We));
              }
              Ue = new zt(He);
            }
            return Ue;
          } }, xe;
        }
        Mt.__dashjs_factory_name = "KeySystemClearKey";
        var at = V.A.getSingletonFactory(Mt);
        const Bt = c.A.W3C_CLEARKEY_UUID, jt = c.A.CLEARKEY_KEYSTEM_STRING, At = "urn:uuid:" + Bt;
        function Ce(Ee) {
          let xe;
          const Re = Ee.BASE64, Ie = Ee.debug.getLogger(xe);
          return xe = { uuid: Bt, schemeIdURI: At, systemString: jt, getInitData: function(Ne) {
            return b.parseInitDataFromContentProtection(Ne, Re);
          }, getRequestHeadersFromMessage: function() {
            return null;
          }, getLicenseRequestFromMessage: function(Ne) {
            return new Uint8Array(Ne);
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          }, getClearKeysFromProtectionData: function(Ne, Ue) {
            let Xe = null;
            if (Ne) {
              const He = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(Ue))), Ae = [];
              for (let be = 0; be < He.kids.length; be++) {
                const We = He.kids[be], zn = Ne.clearkeys && Ne.clearkeys.hasOwnProperty(We) ? Ne.clearkeys[We] : null;
                if (!zn) throw new Error("DRM: ClearKey keyID (" + We + ") is not known!");
                Ae.push(new Lt(We, zn));
              }
              Xe = new zt(Ae), Ie.warn("ClearKey schemeIdURI is using W3C Common PSSH systemID (1077efec-c0b2-4d02-ace3-3c1e52e2fb4b) in Content Protection. See DASH-IF IOP v4.1 section 7.6.2.4");
            }
            return Xe;
          } }, xe;
        }
        Ce.__dashjs_factory_name = "KeySystemW3CClearKey";
        var ne = V.A.getSingletonFactory(Ce);
        const Ht = c.A.WIDEVINE_UUID, Le = c.A.WIDEVINE_KEYSTEM_STRING, sn = "urn:uuid:" + Ht;
        function we(Ee) {
          let xe;
          const Re = (Ee = Ee || {}).BASE64;
          return xe = { uuid: Ht, schemeIdURI: sn, systemString: Le, getInitData: function(Ie) {
            return b.parseInitDataFromContentProtection(Ie, Re);
          }, getRequestHeadersFromMessage: function() {
            return null;
          }, getLicenseRequestFromMessage: function(Ie) {
            return new Uint8Array(Ie);
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          } }, xe;
        }
        we.__dashjs_factory_name = "KeySystemWidevine";
        var ln = V.A.getSingletonFactory(we);
        const _e = c.A.PLAYREADY_UUID, Rn = c.A.PLAYREADY_KEYSTEM_STRING, En = "urn:uuid:" + _e;
        function Tn(Ee) {
          let xe, Re = "utf-16";
          const Ie = (Ee = Ee || {}).BASE64, Ne = Ee.settings;
          function Ue() {
            if (!Ie || !Ie.hasOwnProperty("decodeArray") || !Ie.hasOwnProperty("decodeArray")) throw new Error("Missing config parameter(s)");
          }
          return xe = { uuid: _e, schemeIdURI: En, systemString: Rn, getInitData: function(Xe) {
            const He = new Uint8Array([112, 115, 115, 104, 0, 0, 0, 0]), Ae = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
            let be, We, zn, Pe, pn, yn = 0, wn = null;
            if (Ue(), !Xe) return null;
            if ("pssh" in Xe && Xe.pssh) return b.parseInitDataFromContentProtection(Xe, Ie);
            if ("pro" in Xe && Xe.pro) wn = Ie.decodeArray(Xe.pro.__text);
            else {
              if (!("prheader" in Xe) || !Xe.prheader) return null;
              wn = Ie.decodeArray(Xe.prheader.__text);
            }
            return be = wn.length, We = 4 + He.length + Ae.length + 4 + be, zn = new ArrayBuffer(We), Pe = new Uint8Array(zn), pn = new DataView(zn), pn.setUint32(yn, We), yn += 4, Pe.set(He, yn), yn += He.length, Pe.set(Ae, yn), yn += Ae.length, pn.setUint32(yn, be), yn += 4, Pe.set(wn, yn), yn += be, Pe.buffer;
          }, getRequestHeadersFromMessage: function(Xe) {
            let He, Ae;
            const be = {}, We = new DOMParser();
            if (Ne && Ne.get().streaming.protection.detectPlayreadyMessageFormat && Re === "utf-16" && Xe && Xe.byteLength % 2 == 1) return be["Content-Type"] = "text/xml; charset=utf-8", be;
            const zn = Re === "utf-16" ? new Uint16Array(Xe) : new Uint8Array(Xe);
            He = String.fromCharCode.apply(null, zn), Ae = We.parseFromString(He, "application/xml");
            const Pe = Ae.getElementsByTagName("name"), pn = Ae.getElementsByTagName("value");
            for (let yn = 0; yn < Pe.length; yn++) be[Pe[yn].childNodes[0].nodeValue] = pn[yn].childNodes[0].nodeValue;
            return be.hasOwnProperty("Content") && (be["Content-Type"] = be.Content, delete be.Content), be.hasOwnProperty("Content-Type") || (be["Content-Type"] = "text/xml; charset=utf-8"), be;
          }, getLicenseRequestFromMessage: function(Xe) {
            let He = null;
            const Ae = new DOMParser();
            if (Ne && Ne.get().streaming.protection.detectPlayreadyMessageFormat && Re === "utf-16" && Xe && Xe.byteLength % 2 == 1) return Xe;
            const be = Re === "utf-16" ? new Uint16Array(Xe) : new Uint8Array(Xe);
            Ue();
            const We = String.fromCharCode.apply(null, be), zn = Ae.parseFromString(We, "application/xml");
            if (!zn.getElementsByTagName("PlayReadyKeyMessage")[0]) return Xe;
            {
              const Pe = zn.getElementsByTagName("Challenge")[0].childNodes[0].nodeValue;
              Pe && (He = Ie.decode(Pe));
            }
            return He;
          }, getLicenseServerURLFromInitData: function(Xe) {
            if (Xe) {
              const He = new DataView(Xe), Ae = He.getUint16(4, !0);
              let be = 6;
              const We = new DOMParser();
              for (let zn = 0; zn < Ae; zn++) {
                const Pe = He.getUint16(be, !0);
                be += 2;
                const pn = He.getUint16(be, !0);
                if (be += 2, Pe !== 1) {
                  be += pn;
                  continue;
                }
                const yn = Xe.slice(be, be + pn), wn = String.fromCharCode.apply(null, new Uint16Array(yn)), vn = We.parseFromString(wn, "application/xml");
                if (vn.getElementsByTagName("LA_URL")[0]) {
                  const Pn = vn.getElementsByTagName("LA_URL")[0].childNodes[0].nodeValue;
                  if (Pn) return Pn;
                }
                if (vn.getElementsByTagName("LUI_URL")[0]) {
                  const Pn = vn.getElementsByTagName("LUI_URL")[0].childNodes[0].nodeValue;
                  if (Pn) return Pn;
                }
              }
            }
            return null;
          }, getCDMData: function(Xe) {
            let He, Ae, be, We;
            if (Ue(), !Xe) return null;
            for (He = [], We = 0; We < Xe.length; ++We) He.push(Xe.charCodeAt(We)), He.push(0);
            for (He = String.fromCharCode.apply(null, He), He = Ie.encode(He), Ae = '<PlayReadyCDMData type="LicenseAcquisition"><LicenseAcquisition version="1.0" Proactive="false"><CustomData encoding="base64encoded">%CUSTOMDATA%</CustomData></LicenseAcquisition></PlayReadyCDMData>'.replace("%CUSTOMDATA%", He), be = [], We = 0; We < Ae.length; ++We) be.push(Ae.charCodeAt(We)), be.push(0);
            return new Uint8Array(be).buffer;
          }, setPlayReadyMessageFormat: function(Xe) {
            if (Xe !== "utf-8" && Xe !== "utf-16") throw new Error('Specified message format is not one of "utf-8" or "utf-16"');
            Re = Xe;
          } }, xe;
        }
        Tn.__dashjs_factory_name = "KeySystemPlayReady";
        var Nt = V.A.getSingletonFactory(Tn);
        function Ft(Ee) {
          const xe = (Ee = Ee || {}).BASE64, Re = {};
          let Ie;
          return Re[c.A.WIDEVINE_KEYSTEM_STRING] = { responseType: "json", getLicenseMessage: function(Ne) {
            return xe.decodeArray(Ne.license);
          }, getErrorResponse: function(Ne) {
            return Ne;
          } }, Re[c.A.PLAYREADY_KEYSTEM_STRING] = { responseType: "arraybuffer", getLicenseMessage: function(Ne) {
            return Ne;
          }, getErrorResponse: function(Ne) {
            return String.fromCharCode.apply(null, new Uint8Array(Ne));
          } }, Ie = { getServerURLFromMessage: function(Ne) {
            return Ne;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function(Ne) {
            return Re[Ne].responseType;
          }, getLicenseMessage: function(Ne, Ue) {
            return function() {
              if (!xe || !xe.hasOwnProperty("decodeArray")) throw new Error("Missing config parameter(s)");
            }(), Re[Ue].getLicenseMessage(Ne);
          }, getErrorResponse: function(Ne, Ue) {
            return Re[Ue].getErrorResponse(Ne);
          } }, Ie;
        }
        Ft.__dashjs_factory_name = "DRMToday";
        var ve = V.A.getSingletonFactory(Ft);
        function q() {
          let Ee;
          const xe = "http://schemas.xmlsoap.org/soap/envelope/";
          function Re(Ue) {
            const Xe = String.fromCharCode.apply(null, new Uint8Array(Ue));
            return decodeURIComponent(escape(Xe));
          }
          function Ie(Ue) {
            if (window.DOMParser) {
              const Xe = Re(Ue), He = new window.DOMParser().parseFromString(Xe, "text/xml"), Ae = He ? He.getElementsByTagNameNS(xe, "Envelope")[0] : null, be = Ae ? Ae.getElementsByTagNameNS(xe, "Body")[0] : null;
              if (be && be.getElementsByTagNameNS(xe, "Fault")[0]) return null;
            }
            return Ue;
          }
          function Ne(Ue) {
            let Xe = "", He = "", Ae = "", be = -1, We = -1;
            if (window.DOMParser) {
              const Pe = Re(Ue), pn = new window.DOMParser().parseFromString(Pe, "text/xml"), yn = pn ? pn.getElementsByTagNameNS(xe, "Envelope")[0] : null, wn = yn ? yn.getElementsByTagNameNS(xe, "Body")[0] : null, vn = wn ? wn.getElementsByTagNameNS(xe, "Fault")[0] : null, Pn = vn ? vn.getElementsByTagName("detail")[0] : null, In = Pn ? Pn.getElementsByTagName("Exception")[0] : null;
              let ye = null;
              if (vn === null) return Pe;
              ye = vn.getElementsByTagName("faultstring")[0].firstChild, Xe = ye ? ye.nodeValue : null, In !== null && (ye = In.getElementsByTagName("StatusCode")[0], He = ye ? ye.firstChild.nodeValue : null, ye = In.getElementsByTagName("Message")[0], Ae = ye ? ye.firstChild.nodeValue : null, be = Ae ? Ae.lastIndexOf("[") + 1 : -1, We = Ae ? Ae.indexOf("]") : -1, Ae = Ae ? Ae.substring(be, We) : "");
            }
            let zn = `code: ${He}, name: ${Xe}`;
            return Ae && (zn += `, message: ${Ae}`), zn;
          }
          return Ee = { getServerURLFromMessage: function(Ue) {
            return Ue;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "arraybuffer";
          }, getLicenseMessage: function(Ue) {
            return Ie.call(this, Ue);
          }, getErrorResponse: function(Ue) {
            return Ne.call(this, Ue);
          } }, Ee;
        }
        q.__dashjs_factory_name = "PlayReady";
        var tt = V.A.getSingletonFactory(q);
        function x() {
          let Ee;
          return Ee = { getServerURLFromMessage: function(xe) {
            return xe;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "arraybuffer";
          }, getLicenseMessage: function(xe) {
            return xe;
          }, getErrorResponse: function(xe) {
            return String.fromCharCode.apply(null, new Uint8Array(xe));
          } }, Ee;
        }
        x.__dashjs_factory_name = "Widevine";
        var U = V.A.getSingletonFactory(x);
        function pt() {
          let Ee;
          return Ee = { getServerURLFromMessage: function(xe) {
            return xe;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "json";
          }, getLicenseMessage: function(xe) {
            if (!xe.hasOwnProperty("keys")) return null;
            let Re = [];
            for (let Ie = 0; Ie < xe.keys.length; Ie++) {
              let Ne = xe.keys[Ie], Ue = Ne.kid.replace(/=/g, ""), Xe = Ne.k.replace(/=/g, "");
              Re.push(new Lt(Ue, Xe));
            }
            return new zt(Re);
          }, getErrorResponse: function(xe) {
            return String.fromCharCode.apply(null, new Uint8Array(xe));
          } }, Ee;
        }
        pt.__dashjs_factory_name = "ClearKey";
        var lt = V.A.getSingletonFactory(pt), Gt = class {
          constructor(Ee) {
            this.ks = Ee.ks, this.keyId = Ee.keyId, this.initData = Ee.initData, this.protData = Ee.protData, this.cdmData = Ee.cdmData, this.sessionId = Ee.sessionId, this.sessionType = Ee.sessionType;
          }
        };
        function ee() {
          let Ee, xe, Re, Ie, Ne, Ue, Xe, He, Ae = this.context;
          function be(Pe, pn) {
            return pn && Pe in pn ? pn[Pe] : null;
          }
          function We(Pe, pn) {
            return Pe && Pe.sessionId ? Pe.sessionId : pn && pn.sessionId ? pn.sessionId : null;
          }
          function zn(Pe, pn) {
            return Pe && Pe.sessionType ? Pe.sessionType : pn;
          }
          return Ee = { getKeySystemBySystemString: function(Pe) {
            for (let pn = 0; pn < Ie.length; pn++) if (Ie[pn].systemString === Pe) return Ie[pn];
            return null;
          }, getKeySystems: function() {
            return Ie;
          }, getLicenseServerModelInstance: function(Pe, pn, yn) {
            if (yn === c.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_RELEASE || yn === c.A.MEDIA_KEY_MESSAGE_TYPES.INDIVIDUALIZATION_REQUEST) return null;
            let wn = null;
            return pn && pn.hasOwnProperty("drmtoday") ? wn = ve(Ae).getInstance({ BASE64: Ne }) : Pe.systemString === c.A.WIDEVINE_KEYSTEM_STRING ? wn = U(Ae).getInstance() : Pe.systemString === c.A.PLAYREADY_KEYSTEM_STRING ? wn = tt(Ae).getInstance() : Pe.systemString === c.A.CLEARKEY_KEYSTEM_STRING && (wn = lt(Ae).getInstance()), wn;
          }, getSupportedKeySystemMetadataFromContentProtection: function(Pe, pn, yn) {
            let wn, vn, Pn, In, ye = [];
            if (!Pe || !Pe.length) return ye;
            const le = b.findMp4ProtectionElement(Pe);
            for (Pn = 0; Pn < Ie.length; Pn++) {
              vn = Ie[Pn];
              const Qe = be(vn.systemString, pn);
              for (In = 0; In < Pe.length; In++) if (wn = Pe[In], wn.schemeIdUri.toLowerCase() === vn.schemeIdURI) {
                let on = vn.getInitData(wn, le);
                const Dn = new Gt({ ks: Ie[Pn], keyId: wn.keyId, initData: on, protData: Qe, cdmData: vn.getCDMData(Qe ? Qe.cdmData : null), sessionId: We(Qe, wn), sessionType: zn(Qe, yn) });
                Qe ? ye.unshift(Dn) : ye.push(Dn);
              }
            }
            return ye;
          }, getSupportedKeySystemMetadataFromSegmentPssh: function(Pe, pn, yn) {
            let wn, vn, Pn = [], In = b.parsePSSHList(Pe);
            for (let ye = 0; ye < Ie.length; ++ye) {
              wn = Ie[ye], vn = wn.systemString;
              const le = be(vn, pn);
              wn.uuid in In && Pn.push({ ks: wn, initData: In[wn.uuid], protData: le, cdmData: wn.getCDMData(le ? le.cdmData : null), sessionId: We(le), sessionType: zn(le, yn) });
            }
            return Pn;
          }, initDataEquals: function(Pe, pn) {
            if (Pe.byteLength === pn.byteLength) {
              let yn = new Uint8Array(Pe), wn = new Uint8Array(pn);
              for (let vn = 0; vn < yn.length; vn++) if (yn[vn] !== wn[vn]) return !1;
              return !0;
            }
            return !1;
          }, initialize: function() {
            let Pe;
            Ie = [], Pe = Nt(Ae).getInstance({ BASE64: Ne, settings: Ue }), Ie.push(Pe), Pe = ln(Ae).getInstance({ BASE64: Ne }), Ie.push(Pe), Pe = at(Ae).getInstance({ BASE64: Ne }), Ie.push(Pe), Xe = Pe, Pe = ne(Ae).getInstance({ BASE64: Ne, debug: xe }), Ie.push(Pe), He = Pe;
          }, isClearKey: function(Pe) {
            return Pe === Xe || Pe === He;
          }, processClearKeyLicenseRequest: function(Pe, pn, yn) {
            try {
              return Pe.getClearKeysFromProtectionData(pn, yn);
            } catch (wn) {
              return Re.error("Failed to retrieve clearkeys from ProtectionData"), null;
            }
          }, setConfig: function(Pe) {
            Pe && (Pe.debug && (xe = Pe.debug, Re = xe.getLogger(Ee)), Pe.BASE64 && (Ne = Pe.BASE64), Pe.settings && (Ue = Pe.settings));
          }, setKeySystems: function(Pe) {
            Ie = Pe;
          }, setProtectionData: function(Pe) {
            for (var pn, yn, wn = 0; wn < Ie.length; wn++) {
              var vn = Ie[wn];
              vn.hasOwnProperty("init") && vn.init((pn = vn.systemString, yn = void 0, yn = null, Pe && (yn = pn in Pe ? Pe[pn] : null), yn));
            }
          } }, Ee;
        }
        ee.__dashjs_factory_name = "ProtectionKeyController";
        var Vt = V.A.getSingletonFactory(ee), Jt = w(445), Ot = class {
          constructor(Ee, xe) {
            this.initData = Ee, this.initDataType = xe;
          }
        }, Kt = class {
          constructor(Ee, xe, Re, Ie) {
            this.sessionToken = Ee, this.message = xe, this.defaultURL = Re, this.messageType = Ie || c.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST;
          }
        }, ae = class {
          constructor(Ee, xe) {
            this.keySystem = Ee, this.ksConfiguration = xe, this.nativeMediaKeySystemAccessObject = null, this.selectedSystemString = null;
          }
        };
        const Qt = {};
        function me(Ee) {
          Ee = Ee || {};
          const xe = this.context, Re = Ee.eventBus, Ie = Ee.events, Ne = Ee.debug;
          let Ue, Xe, He, Ae, be, We, zn, Pe;
          function pn(ye, le, Qe, on) {
            if (navigator.requestMediaKeySystemAccess === void 0 || typeof navigator.requestMediaKeySystemAccess != "function") {
              const ha = "Insecure origins are not allowed";
              return Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { error: ha }), void on({ error: ha });
            }
            const Dn = ye[le].protData && ye[le].protData.systemStringPriority ? ye[le].protData.systemStringPriority : null, Wn = ye[le].configs, oa = ye[le].ks;
            let jn = oa.systemString;
            (function(ha, va) {
              return new Promise((_a, ei) => {
                yn(ha, va, 0, _a, ei);
              });
            })(Dn || (Qt[jn] ? Qt[jn] : [jn]), Wn).then((ha) => {
              const va = ha && ha.nativeMediaKeySystemAccessObject && typeof ha.nativeMediaKeySystemAccessObject.getConfiguration == "function" ? ha.nativeMediaKeySystemAccessObject.getConfiguration() : null, _a = new ae(oa, va);
              _a.selectedSystemString = ha.selectedSystemString, _a.nativeMediaKeySystemAccessObject = ha.nativeMediaKeySystemAccessObject, Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { data: _a }), Qe({ data: _a });
            }).catch((ha) => {
              if (le + 1 < ye.length) pn(ye, le + 1, Qe, on);
              else {
                const va = "Key system access denied! ";
                Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { error: va + ha.message }), on({ error: va + ha.message });
              }
            });
          }
          function yn(ye, le, Qe, on, Dn) {
            const Wn = ye[Qe];
            Xe.debug(`Requesting key system access for system string ${Wn}`), navigator.requestMediaKeySystemAccess(Wn, le).then((oa) => {
              on({ nativeMediaKeySystemAccessObject: oa, selectedSystemString: Wn });
            }).catch((oa) => {
              Qe + 1 < ye.length ? yn(ye, le, Qe + 1, on, Dn) : Dn(oa);
            });
          }
          function wn(ye) {
            if (!ye || !ye.session) return Promise.resolve;
            const le = ye.session;
            return le.removeEventListener("keystatuseschange", ye), le.removeEventListener("message", ye), le.close();
          }
          function vn(ye) {
            for (let le = 0; le < We.length; le++) if (We[le] === ye) {
              We.splice(le, 1);
              break;
            }
          }
          function Pn(ye, le) {
            const Qe = { session: ye, keyId: le.keyId, normalizedKeyId: le && le.keyId && typeof le.keyId == "string" ? le.keyId.replace(/-/g, "").toLowerCase() : "", initData: le.initData, sessionId: le.sessionId, sessionType: le.sessionType, hasTriggeredKeyStatusMapUpdate: !1, handleEvent: function(on) {
              switch (on.type) {
                case "keystatuseschange":
                  this._onKeyStatusesChange(on);
                  break;
                case "message":
                  this._onKeyMessage(on);
              }
            }, _onKeyStatusesChange: function(on) {
              Re.trigger(Ie.KEY_STATUSES_CHANGED, { data: this });
              const Dn = [];
              on.target.keyStatuses.forEach(function() {
                Dn.push(In(arguments));
              }), Re.trigger(Ie.INTERNAL_KEY_STATUSES_CHANGED, { parsedKeyStatuses: Dn, sessionToken: Qe });
            }, _onKeyMessage: function(on) {
              let Dn = ArrayBuffer.isView(on.message) ? on.message.buffer : on.message;
              Re.trigger(Ie.INTERNAL_KEY_MESSAGE, { data: new Kt(this, Dn, void 0, on.messageType) });
            }, getKeyId: function() {
              return this.keyId;
            }, getSessionId: function() {
              return ye.sessionId;
            }, getSessionType: function() {
              return this.sessionType;
            }, getExpirationTime: function() {
              return ye.expiration;
            }, getKeyStatuses: function() {
              return ye.keyStatuses;
            }, getUsable: function() {
              let on = !1;
              return ye.keyStatuses.forEach(function() {
                In(arguments).status === c.A.MEDIA_KEY_STATUSES.USABLE && (on = !0);
              }), on;
            } };
            return ye.addEventListener("keystatuseschange", Qe), ye.addEventListener("message", Qe), ye.closed.then(() => {
              vn(Qe), Xe.debug("DRM: Session closed.  SessionID = " + Qe.getSessionId()), Re.trigger(Ie.KEY_SESSION_CLOSED, { data: Qe.getSessionId() });
            }), We.push(Qe), Qe;
          }
          function In(ye) {
            let le, Qe;
            return ye && ye.length > 0 && (ye[0] && (typeof ye[0] == "string" ? le = ye[0] : Qe = ye[0]), ye[1] && (typeof ye[1] == "string" ? le = ye[1] : Qe = ye[1])), { status: le, keyId: Qe };
          }
          return Ue = { closeKeySession: function(ye) {
            wn(ye).catch(function(le) {
              vn(ye), Re.trigger(Ie.KEY_SESSION_CLOSED, { data: null, error: "Error closing session (" + ye.getSessionId() + ") " + le.name });
            });
          }, createKeySession: function(ye) {
            if (!He || !be) throw new Error("Can not create sessions until you have selected a key system");
            const le = be.createSession(ye.sessionType), Qe = Pn(le, ye), on = He.systemString === c.A.CLEARKEY_KEYSTEM_STRING && (ye.initData || ye.protData && ye.protData.clearkeys) ? c.A.INITIALIZATION_DATA_TYPE_KEYIDS : c.A.INITIALIZATION_DATA_TYPE_CENC;
            le.generateRequest(on, ye.initData).then(function() {
              Xe.debug("DRM: Session created.  SessionID = " + Qe.getSessionId()), Re.trigger(Ie.KEY_SESSION_CREATED, { data: Qe });
            }).catch(function(Dn) {
              vn(Qe), Re.trigger(Ie.KEY_SESSION_CREATED, { data: null, error: new o.A(n.A.KEY_SESSION_CREATED_ERROR_CODE, n.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Error generating key request -- " + Dn.name) });
            });
          }, getAllInitData: function() {
            const ye = [];
            for (let le = 0; le < We.length; le++) We[le].initData && ye.push(We[le].initData);
            return ye;
          }, getSessionTokens: function() {
            return We;
          }, loadKeySession: function(ye) {
            if (!He || !be) throw new Error("Can not load sessions until you have selected a key system");
            const le = ye.sessionId;
            for (let Dn = 0; Dn < We.length; Dn++) if (le === We[Dn].sessionId) return void Xe.warn("DRM: Ignoring session ID because we have already seen it!");
            const Qe = be.createSession(ye.sessionType), on = Pn(Qe, ye);
            on.hasTriggeredKeyStatusMapUpdate = !0, Qe.load(le).then(function(Dn) {
              Dn ? (Xe.debug("DRM: Session loaded.  SessionID = " + on.getSessionId()), Re.trigger(Ie.KEY_SESSION_CREATED, { data: on })) : (vn(on), Re.trigger(Ie.KEY_SESSION_CREATED, { data: null, error: new o.A(n.A.KEY_SESSION_CREATED_ERROR_CODE, n.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Could not load session! Invalid Session ID (" + le + ")") }));
            }).catch(function(Dn) {
              vn(on), Re.trigger(Ie.KEY_SESSION_CREATED, { data: null, error: new o.A(n.A.KEY_SESSION_CREATED_ERROR_CODE, n.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Could not load session (" + le + ")! " + Dn.name) });
            });
          }, removeKeySession: function(ye) {
            ye.session.remove().then(function() {
              Xe.debug("DRM: Session removed.  SessionID = " + ye.getSessionId()), Re.trigger(Ie.KEY_SESSION_REMOVED, { data: ye.getSessionId() });
            }, function(le) {
              Re.trigger(Ie.KEY_SESSION_REMOVED, { data: null, error: "Error removing session (" + ye.getSessionId() + "). " + le.name });
            });
          }, requestKeySystemAccess: function(ye) {
            return new Promise((le, Qe) => {
              pn(ye, 0, le, Qe);
            });
          }, reset: function() {
            const ye = We.length;
            let le;
            if (ye !== 0) {
              const Qe = function(on) {
                vn(on), We.length === 0 && (Ae ? (Ae.removeEventListener("encrypted", zn), Ae.setMediaKeys(null).then(function() {
                  Re.trigger(Ie.TEARDOWN_COMPLETE);
                })) : Re.trigger(Ie.TEARDOWN_COMPLETE));
              };
              for (let on = 0; on < ye; on++) le = We[on], function(Dn) {
                wn(le), Qe(Dn);
              }(le);
            } else Re.trigger(Ie.TEARDOWN_COMPLETE);
          }, selectKeySystem: function(ye) {
            return new Promise((le, Qe) => {
              ye.nativeMediaKeySystemAccessObject.createMediaKeys().then((on) => (He = ye.keySystem, be = on, Ae ? Ae.setMediaKeys(be) : Promise.resolve())).then(() => {
                le(He);
              }).catch(function() {
                Qe({ error: "Error selecting keys system (" + ye.keySystem.systemString + ")! Could not create MediaKeys -- TODO" });
              });
            });
          }, setMediaElement: function(ye) {
            Ae !== ye && (Ae && (Ae.removeEventListener("encrypted", zn), Ae.setMediaKeys && Ae.setMediaKeys(null)), Ae = ye, Ae && (Ae.addEventListener("encrypted", zn), Ae.setMediaKeys && be && Ae.setMediaKeys(be)));
          }, setServerCertificate: function(ye) {
            return new Promise((le, Qe) => {
              be.setServerCertificate(ye).then(function() {
                Xe.info("DRM: License server certificate successfully updated."), Re.trigger(Ie.SERVER_CERTIFICATE_UPDATED), le();
              }).catch((on) => {
                Qe(on), Re.trigger(Ie.SERVER_CERTIFICATE_UPDATED, { error: new o.A(n.A.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, n.A.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + on.name) });
              });
            });
          }, stop: function() {
            let ye;
            for (let le = 0; le < We.length; le++) ye = We[le], ye.getUsable() || (wn(ye), vn(ye));
          }, updateKeySession: function(ye, le) {
            const Qe = ye.session;
            Pe.isClearKey(He) && (le = le.toJWK()), Qe.update(le).then(() => {
              Re.trigger(Ie.KEY_SESSION_UPDATED);
            }).catch(function(on) {
              Re.trigger(Ie.KEY_ERROR, { error: new o.A(n.A.MEDIA_KEYERR_CODE, "Error sending update() message! " + on.name, ye) });
            });
          } }, Xe = Ne.getLogger(Ue), He = null, Ae = null, be = null, We = [], Pe = Vt(xe).getInstance(), zn = { handleEvent: function(ye) {
            if (ye.type === "encrypted" && ye.initData) {
              let le = ArrayBuffer.isView(ye.initData) ? ye.initData.buffer : ye.initData;
              Re.trigger(Ie.NEED_KEY, { key: new Ot(le, ye.initDataType) });
            }
          } }, Ue;
        }
        Qt[c.A.PLAYREADY_KEYSTEM_STRING] = [c.A.PLAYREADY_KEYSTEM_STRING, c.A.PLAYREADY_RECOMMENDATION_KEYSTEM_STRING], Qt[c.A.WIDEVINE_KEYSTEM_STRING] = [c.A.WIDEVINE_KEYSTEM_STRING], Qt[c.A.CLEARKEY_KEYSTEM_STRING] = [c.A.CLEARKEY_KEYSTEM_STRING], me.__dashjs_factory_name = "DefaultProtectionModel";
        var an = V.A.getClassFactory(me);
        function Ge(Ee) {
          Ee = Ee || {};
          const xe = this.context, Re = Ee.eventBus, Ie = Ee.events, Ne = Ee.debug, Ue = Ee.api;
          let Xe, He, Ae, be, We, zn, Pe, pn, yn;
          function wn() {
            try {
              for (let In = 0; In < Pe.length; In++) vn(Pe[In]);
              Ae && Ae.removeEventListener(Ue.needkey, pn), Re.trigger(Ie.TEARDOWN_COMPLETE);
            } catch (In) {
              Re.trigger(Ie.TEARDOWN_COMPLETE, { error: "Error tearing down key sessions and MediaKeys! -- " + In.message });
            }
          }
          function vn(In) {
            const ye = In.session;
            ye.removeEventListener(Ue.error, In), ye.removeEventListener(Ue.message, In), ye.removeEventListener(Ue.ready, In), ye.removeEventListener(Ue.close, In);
            for (let le = 0; le < Pe.length; le++) if (Pe[le] === In) {
              Pe.splice(le, 1);
              break;
            }
            ye[Ue.release]();
          }
          function Pn() {
            let In = null;
            const ye = function() {
              Ae.removeEventListener("loadedmetadata", In), Ae[Ue.setMediaKeys](We), Re.trigger(Ie.VIDEO_ELEMENT_SELECTED);
            };
            Ae.readyState >= 1 ? ye() : (In = ye.bind(this), Ae.addEventListener("loadedmetadata", In));
          }
          return Xe = { getAllInitData: function() {
            const In = [];
            for (let ye = 0; ye < Pe.length; ye++) In.push(Pe[ye].initData);
            return In;
          }, getSessionTokens: function() {
            return Pe;
          }, requestKeySystemAccess: function(In) {
            return new Promise((ye, le) => {
              let Qe = !1;
              for (let on = 0; on < In.length; on++) {
                const Dn = In[on].ks.systemString, Wn = In[on].configs;
                let oa = null, jn = null;
                for (let ha = 0; ha < Wn.length; ha++) {
                  const va = Wn[ha].audioCapabilities, _a = Wn[ha].videoCapabilities;
                  if (va && va.length !== 0) {
                    oa = [];
                    for (let Ma = 0; Ma < va.length; Ma++) window[Ue.MediaKeys].isTypeSupported(Dn, va[Ma].contentType) && oa.push(va[Ma]);
                  }
                  if (_a && _a.length !== 0) {
                    jn = [];
                    for (let Ma = 0; Ma < _a.length; Ma++) window[Ue.MediaKeys].isTypeSupported(Dn, _a[Ma].contentType) && jn.push(_a[Ma]);
                  }
                  if (!oa && !jn || oa && oa.length === 0 || jn && jn.length === 0) continue;
                  Qe = !0;
                  const ei = new T(oa, jn), ni = yn.getKeySystemBySystemString(Dn), nr = new ae(ni, ei);
                  Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { data: nr }), ye({ data: nr });
                  break;
                }
              }
              if (!Qe) {
                const on = "Key system access denied! -- No valid audio/video content configurations detected!";
                Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { error: on }), le({ error: on });
              }
            });
          }, selectKeySystem: function(In) {
            return new Promise((ye, le) => {
              try {
                We = In.mediaKeys = new window[Ue.MediaKeys](In.keySystem.systemString), be = In.keySystem, zn = In, Ae && Pn(), ye(be);
              } catch (Qe) {
                le({ error: "Error selecting keys system (" + be.systemString + ")! Could not create MediaKeys -- TODO" });
              }
            });
          }, setMediaElement: function(In) {
            Ae !== In && (Ae && Ae.removeEventListener(Ue.needkey, pn), Ae = In, Ae && (Ae.addEventListener(Ue.needkey, pn), We && Pn()));
          }, createKeySession: function(In) {
            if (!be || !We || !zn) throw new Error("Can not create sessions until you have selected a key system");
            let ye = null;
            if (zn.ksConfiguration.videoCapabilities && zn.ksConfiguration.videoCapabilities.length > 0 && (ye = zn.ksConfiguration.videoCapabilities[0]), ye === null && zn.ksConfiguration.audioCapabilities && zn.ksConfiguration.audioCapabilities.length > 0 && (ye = zn.ksConfiguration.audioCapabilities[0]), ye === null) throw new Error("Can not create sessions for unknown content types.");
            const le = ye.contentType, Qe = We.createSession(le, new Uint8Array(In.initData), In.cdmData ? new Uint8Array(In.cdmData) : null), on = function(Dn, Wn) {
              return { session: Dn, keyId: Wn.keyId, normalizedKeyId: Wn && Wn.keyId && typeof Wn.keyId == "string" ? Wn.keyId.replace(/-/g, "").toLowerCase() : "", initData: Wn.initData, hasTriggeredKeyStatusMapUpdate: !1, getKeyId: function() {
                return this.keyId;
              }, getSessionId: function() {
                return this.session.sessionId;
              }, getExpirationTime: function() {
                return NaN;
              }, getSessionType: function() {
                return "temporary";
              }, getKeyStatuses: function() {
                return { size: 0, has: () => !1, get: () => {
                } };
              }, handleEvent: function(oa) {
                switch (oa.type) {
                  case Ue.error:
                    let jn = "KeyError";
                    Re.trigger(Ie.KEY_ERROR, { error: new o.A(n.A.MEDIA_KEYERR_CODE, jn, this) });
                    break;
                  case Ue.message:
                    let ha = ArrayBuffer.isView(oa.message) ? oa.message.buffer : oa.message;
                    Re.trigger(Ie.INTERNAL_KEY_MESSAGE, { data: new Kt(this, ha, oa.destinationURL) });
                    break;
                  case Ue.ready:
                    He.debug("DRM: Key added."), Re.trigger(Ie.KEY_ADDED);
                    break;
                  case Ue.close:
                    He.debug("DRM: Session closed.  SessionID = " + this.getSessionId()), Re.trigger(Ie.KEY_SESSION_CLOSED, { data: this.getSessionId() });
                }
              } };
            }(Qe, In);
            Qe.addEventListener(Ue.error, on), Qe.addEventListener(Ue.message, on), Qe.addEventListener(Ue.ready, on), Qe.addEventListener(Ue.close, on), Pe.push(on), He.debug("DRM: Session created.  SessionID = " + on.getSessionId()), Re.trigger(Ie.KEY_SESSION_CREATED, { data: on });
          }, updateKeySession: function(In, ye) {
            const le = In.session;
            yn.isClearKey(be) ? le.update(new Uint8Array(ye.toJWK())) : le.update(new Uint8Array(ye)), Re.trigger(Ie.KEY_SESSION_UPDATED);
          }, closeKeySession: vn, setServerCertificate: function() {
          }, loadKeySession: function() {
          }, removeKeySession: function() {
          }, stop: wn, reset: wn }, He = Ne.getLogger(Xe), Ae = null, be = null, We = null, zn = null, Pe = [], yn = Vt(xe).getInstance(), pn = { handleEvent: function(In) {
            if (In.type === Ue.needkey && In.initData) {
              const ye = ArrayBuffer.isView(In.initData) ? In.initData.buffer : In.initData;
              Re.trigger(Ie.NEED_KEY, { key: new Ot(ye, c.A.INITIALIZATION_DATA_TYPE_CENC) });
            }
          } }, Xe;
        }
        Ge.__dashjs_factory_name = "ProtectionModel_3Feb2014";
        var Te = V.A.getClassFactory(Ge);
        function ge(Ee) {
          Ee = Ee || {};
          const xe = this.context, Re = Ee.eventBus, Ie = Ee.events, Ne = Ee.debug, Ue = Ee.api, Xe = Ee.errHandler;
          let He, Ae, be, We, zn, Pe, pn, yn, wn;
          function vn() {
            be && ye();
            for (let le = 0; le < pn.length; le++) Pn(pn[le]);
            Re.trigger(Ie.TEARDOWN_COMPLETE);
          }
          function Pn(le) {
            try {
              be[Ue.cancelKeyRequest](We.systemString, le.sessionId);
            } catch (Qe) {
              Re.trigger(Ie.KEY_SESSION_CLOSED, { data: null, error: "Error closing session (" + le.sessionId + ") " + Qe.message });
            }
          }
          function In(le, Qe) {
            if (Qe && le) {
              const on = le.length;
              for (let Dn = 0; Dn < on; Dn++) if (le[Dn].sessionId == Qe) return le[Dn];
              return null;
            }
            return null;
          }
          function ye() {
            be.removeEventListener(Ue.keyerror, wn), be.removeEventListener(Ue.needkey, wn), be.removeEventListener(Ue.keymessage, wn), be.removeEventListener(Ue.keyadded, wn);
          }
          return He = { getAllInitData: function() {
            const le = [];
            for (let Qe = 0; Qe < Pe.length; Qe++) le.push(Pe[Qe].initData);
            for (let Qe = 0; Qe < pn.length; Qe++) le.push(pn[Qe].initData);
            return le;
          }, getSessionTokens: function() {
            return pn.concat(Pe);
          }, requestKeySystemAccess: function(le) {
            return new Promise((Qe, on) => {
              let Dn = be;
              Dn || (Dn = document.createElement("video"));
              let Wn = !1;
              for (let oa = 0; oa < le.length; oa++) {
                const jn = le[oa].ks.systemString, ha = le[oa].configs;
                let va = null, _a = null;
                for (let ei = 0; ei < ha.length; ei++) {
                  const ni = ha[ei].videoCapabilities;
                  if (ni && ni.length !== 0) {
                    _a = [];
                    for (let Ka = 0; Ka < ni.length; Ka++) Dn.canPlayType(ni[Ka].contentType, jn) !== "" && _a.push(ni[Ka]);
                  }
                  if (!_a || va || _a && _a.length === 0) continue;
                  Wn = !0;
                  const nr = new T(va, _a), Ma = zn.getKeySystemBySystemString(jn), ba = new ae(Ma, nr);
                  Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { data: ba }), Qe({ data: ba });
                  break;
                }
              }
              if (!Wn) {
                const oa = "Key system access denied! -- No valid audio/video content configurations detected!";
                Re.trigger(Ie.KEY_SYSTEM_ACCESS_COMPLETE, { error: oa }), on({ error: oa });
              }
            });
          }, selectKeySystem: function(le) {
            return We = le.keySystem, Promise.resolve(We);
          }, setMediaElement: function(le) {
            if (be !== le) {
              if (be) {
                ye();
                for (var Qe = 0; Qe < pn.length; Qe++) Pn(pn[Qe]);
                pn = [];
              }
              be = le, be && (be.addEventListener(Ue.keyerror, wn), be.addEventListener(Ue.needkey, wn), be.addEventListener(Ue.keymessage, wn), be.addEventListener(Ue.keyadded, wn), Re.trigger(Ie.VIDEO_ELEMENT_SELECTED));
            }
          }, createKeySession: function(le) {
            if (!We) throw new Error("Can not create sessions until you have selected a key system");
            if (yn || pn.length === 0) {
              const Qe = { sessionId: null, keyId: le.keyId, normalizedKeyId: le && le.keyId && typeof le.keyId == "string" ? le.keyId.replace(/-/g, "").toLowerCase() : "", initData: le.initData, hasTriggeredKeyStatusMapUpdate: !1, getKeyId: function() {
                return this.keyId;
              }, getSessionId: function() {
                return this.sessionId;
              }, getExpirationTime: function() {
                return NaN;
              }, getSessionType: function() {
                return "temporary";
              }, getKeyStatuses: function() {
                return { size: 0, has: () => !1, get: () => {
                } };
              } };
              return Pe.push(Qe), be[Ue.generateKeyRequest](We.systemString, new Uint8Array(le.initData)), Qe;
            }
            throw new Error("Multiple sessions not allowed!");
          }, updateKeySession: function(le, Qe) {
            const on = le.sessionId;
            if (zn.isClearKey(We)) for (let Dn = 0; Dn < Qe.keyPairs.length; Dn++) be[Ue.addKey](We.systemString, Qe.keyPairs[Dn].key, Qe.keyPairs[Dn].keyID, on);
            else be[Ue.addKey](We.systemString, new Uint8Array(Qe), new Uint8Array(le.initData), on);
            Re.trigger(Ie.KEY_SESSION_UPDATED);
          }, closeKeySession: Pn, setServerCertificate: function() {
          }, loadKeySession: function() {
          }, removeKeySession: function() {
          }, stop: vn, reset: vn }, Ae = Ne.getLogger(He), be = null, We = null, Pe = [], pn = [], zn = Vt(xe).getInstance(), wn = { handleEvent: function(le) {
            let Qe = null;
            switch (le.type) {
              case Ue.needkey:
                let on = ArrayBuffer.isView(le.initData) ? le.initData.buffer : le.initData;
                Re.trigger(Ie.NEED_KEY, { key: new Ot(on, c.A.INITIALIZATION_DATA_TYPE_CENC) });
                break;
              case Ue.keyerror:
                if (Qe = In(pn, le.sessionId), Qe || (Qe = In(Pe, le.sessionId)), Qe) {
                  let Dn = n.A.MEDIA_KEYERR_CODE, Wn = "";
                  switch (le.errorCode.code) {
                    case 1:
                      Dn = n.A.MEDIA_KEYERR_UNKNOWN_CODE, Wn += "MEDIA_KEYERR_UNKNOWN - " + n.A.MEDIA_KEYERR_UNKNOWN_MESSAGE;
                      break;
                    case 2:
                      Dn = n.A.MEDIA_KEYERR_CLIENT_CODE, Wn += "MEDIA_KEYERR_CLIENT - " + n.A.MEDIA_KEYERR_CLIENT_MESSAGE;
                      break;
                    case 3:
                      Dn = n.A.MEDIA_KEYERR_SERVICE_CODE, Wn += "MEDIA_KEYERR_SERVICE - " + n.A.MEDIA_KEYERR_SERVICE_MESSAGE;
                      break;
                    case 4:
                      Dn = n.A.MEDIA_KEYERR_OUTPUT_CODE, Wn += "MEDIA_KEYERR_OUTPUT - " + n.A.MEDIA_KEYERR_OUTPUT_MESSAGE;
                      break;
                    case 5:
                      Dn = n.A.MEDIA_KEYERR_HARDWARECHANGE_CODE, Wn += "MEDIA_KEYERR_HARDWARECHANGE - " + n.A.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;
                      break;
                    case 6:
                      Dn = n.A.MEDIA_KEYERR_DOMAIN_CODE, Wn += "MEDIA_KEYERR_DOMAIN - " + n.A.MEDIA_KEYERR_DOMAIN_MESSAGE;
                  }
                  Wn += "  System Code = " + le.systemCode, Re.trigger(Ie.KEY_ERROR, { error: new o.A(Dn, Wn, Qe) });
                } else Ae.error("No session token found for key error");
                break;
              case Ue.keyadded:
                Qe = In(pn, le.sessionId), Qe || (Qe = In(Pe, le.sessionId)), Qe ? (Ae.debug("DRM: Key added."), Re.trigger(Ie.KEY_ADDED, { data: Qe })) : Ae.debug("No session token found for key added");
                break;
              case Ue.keymessage:
                if (yn = le.sessionId !== null && le.sessionId !== void 0, yn ? (Qe = In(pn, le.sessionId), !Qe && Pe.length > 0 && (Qe = Pe.shift(), pn.push(Qe), Qe.sessionId = le.sessionId, Re.trigger(Ie.KEY_SESSION_CREATED, { data: Qe }))) : Pe.length > 0 && (Qe = Pe.shift(), pn.push(Qe), Pe.length !== 0 && Xe.error(new o.A(n.A.MEDIA_KEY_MESSAGE_ERROR_CODE, n.A.MEDIA_KEY_MESSAGE_ERROR_MESSAGE))), Qe) {
                  let Dn = ArrayBuffer.isView(le.message) ? le.message.buffer : le.message;
                  Qe.keyMessage = Dn, Re.trigger(Ie.INTERNAL_KEY_MESSAGE, { data: new Kt(Qe, Dn, le.defaultURL) });
                } else Ae.warn("No session token found for key message");
            }
          } }, He;
        }
        ge.__dashjs_factory_name = "ProtectionModel_01b";
        var ze = V.A.getClassFactory(ge);
        const Zn = [{ generateKeyRequest: "generateKeyRequest", addKey: "addKey", cancelKeyRequest: "cancelKeyRequest", needkey: "needkey", keyerror: "keyerror", keyadded: "keyadded", keymessage: "keymessage" }, { generateKeyRequest: "webkitGenerateKeyRequest", addKey: "webkitAddKey", cancelKeyRequest: "webkitCancelKeyRequest", needkey: "webkitneedkey", keyerror: "webkitkeyerror", keyadded: "webkitkeyadded", keymessage: "webkitkeymessage" }], qn = [{ setMediaKeys: "setMediaKeys", MediaKeys: "MediaKeys", release: "close", needkey: "needkey", error: "keyerror", message: "keymessage", ready: "keyadded", close: "keyclose" }, { setMediaKeys: "msSetMediaKeys", MediaKeys: "MSMediaKeys", release: "close", needkey: "msneedkey", error: "mskeyerror", message: "mskeymessage", ready: "mskeyadded", close: "mskeyclose" }];
        function Aa() {
          let Ee;
          const xe = this.context;
          function Re(Ie, Ne) {
            for (let Ue = 0; Ue < Ne.length; Ue++) {
              const Xe = Ne[Ue];
              if (typeof Ie[Xe[Object.keys(Xe)[0]]] == "function") return Xe;
            }
            return null;
          }
          return Ee = { createProtectionSystem: function(Ie) {
            let Ne = null;
            const Ue = Vt(xe).getInstance();
            Ue.setConfig({ debug: Ie.debug, BASE64: Ie.BASE64, settings: Ie.settings }), Ue.initialize();
            let Xe = function(He) {
              const Ae = He.debug, be = Ae.getLogger(Ee), We = He.eventBus, zn = He.errHandler, Pe = He.videoModel ? He.videoModel.getElement() : null;
              return Pe && Pe.onencrypted === void 0 || Pe && Pe.mediaKeys === void 0 ? Re(Pe, qn) ? (be.info("EME detected on this user agent! (ProtectionModel_3Feb2014)"), Te(xe).create({ debug: Ae, eventBus: We, events: He.events, api: Re(Pe, qn) })) : Re(Pe, Zn) ? (be.info("EME detected on this user agent! (ProtectionModel_01b)"), ze(xe).create({ debug: Ae, eventBus: We, errHandler: zn, events: He.events, api: Re(Pe, Zn) })) : (be.warn("No supported version of EME detected on this user agent! - Attempts to play encrypted content will fail!"), null) : (be.info("EME detected on this user agent! (DefaultProtectionModel"), an(xe).create({ debug: Ae, eventBus: We, events: He.events }));
            }(Ie);
            return Xe && (Ne = vt(xe).create({ BASE64: Ie.BASE64, cmcdModel: Ie.cmcdModel, constants: Ie.constants, customParametersModel: Ie.customParametersModel, debug: Ie.debug, eventBus: Ie.eventBus, events: Ie.events, protectionKeyController: Ue, protectionModel: Xe, settings: Ie.settings }), Ie.capabilities.setEncryptedMediaSupported(!0)), Ne;
          } }, Ee;
        }
        Aa.__dashjs_factory_name = "Protection";
        const Hn = dashjs.FactoryMaker.getClassFactory(Aa);
        Hn.events = Jt.A, Hn.errors = n.A, dashjs.FactoryMaker.updateClassFactory(Aa.__dashjs_factory_name, Hn);
        var xa = Hn;
      }, 445: function(k, g, w) {
        var B = w(7252);
        class c extends B.A {
          constructor() {
            super(), this.INTERNAL_KEY_MESSAGE = "internalKeyMessage", this.INTERNAL_KEY_STATUSES_CHANGED = "internalkeyStatusesChanged", this.KEY_ADDED = "public_keyAdded", this.KEY_ERROR = "public_keyError", this.KEY_MESSAGE = "public_keyMessage", this.KEY_SESSION_CLOSED = "public_keySessionClosed", this.KEY_SESSION_CREATED = "public_keySessionCreated", this.KEY_SESSION_REMOVED = "public_keySessionRemoved", this.KEY_STATUSES_CHANGED = "public_keyStatusesChanged", this.KEY_STATUSES_MAP_UPDATED = "keyStatusesMapUpdated", this.KEY_SYSTEM_ACCESS_COMPLETE = "public_keySystemAccessComplete", this.KEY_SYSTEM_SELECTED = "public_keySystemSelected", this.LICENSE_REQUEST_COMPLETE = "public_licenseRequestComplete", this.LICENSE_REQUEST_SENDING = "public_licenseRequestSending", this.NEED_KEY = "needkey", this.PROTECTION_CREATED = "public_protectioncreated", this.PROTECTION_DESTROYED = "public_protectiondestroyed", this.SERVER_CERTIFICATE_UPDATED = "serverCertificateUpdated", this.TEARDOWN_COMPLETE = "protectionTeardownComplete", this.VIDEO_ELEMENT_SELECTED = "videoElementSelected", this.KEY_SESSION_UPDATED = "public_keySessionUpdated";
          }
        }
        let d = new c();
        g.A = d;
      }, 1923: function(k, g, w) {
        var B = w(8748);
        class c extends B.A {
          constructor() {
            super(), this.MEDIA_KEYERR_CODE = 100, this.MEDIA_KEYERR_UNKNOWN_CODE = 101, this.MEDIA_KEYERR_CLIENT_CODE = 102, this.MEDIA_KEYERR_SERVICE_CODE = 103, this.MEDIA_KEYERR_OUTPUT_CODE = 104, this.MEDIA_KEYERR_HARDWARECHANGE_CODE = 105, this.MEDIA_KEYERR_DOMAIN_CODE = 106, this.MEDIA_KEY_MESSAGE_ERROR_CODE = 107, this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE = 108, this.SERVER_CERTIFICATE_UPDATED_ERROR_CODE = 109, this.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE = 110, this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE = 111, this.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE = 112, this.KEY_SESSION_CREATED_ERROR_CODE = 113, this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE = 114, this.MEDIA_KEYERR_UNKNOWN_MESSAGE = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.", this.MEDIA_KEYERR_CLIENT_MESSAGE = "The Key System could not be installed or updated.", this.MEDIA_KEYERR_SERVICE_MESSAGE = "The message passed into update indicated an error from the license service.", this.MEDIA_KEYERR_OUTPUT_MESSAGE = "There is no available output device with the required characteristics for the content protection system.", this.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE = "A hardware configuration change caused a content protection error.", this.MEDIA_KEYERR_DOMAIN_MESSAGE = "An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.", this.MEDIA_KEY_MESSAGE_ERROR_MESSAGE = "Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!", this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE = "DRM: Empty key message from CDM", this.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE = "Error updating server certificate -- ", this.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE = "DRM: KeyStatusChange error! -- License has expired", this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE = "DRM: No license server URL specified!", this.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE = "DRM: KeySystem Access Denied! -- ", this.KEY_SESSION_CREATED_ERROR_MESSAGE = "DRM: unable to create session! --", this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE = "DRM: licenser error! --";
          }
        }
        let d = new c();
        g.A = d;
      }, 559: function(k, g, w) {
        w.d(g, { a: function() {
          return y;
        } });
        var B = w(138), c = w(5212), d = w(2861), m = w(7393), b = w(649);
        function y() {
          let n = "ManagedMediaSource" in window, o = "WebKitMediaSource" in window, l = "MediaSource" in window;
          return n || o || l;
        }
        function T() {
          let n, o, l, h, p, z;
          const Z = this.context, V = (0, m.A)(Z).getInstance();
          function Q(X, D) {
            let yt;
            D === c.A.VIDEO ? yt = function(at) {
              const Bt = { video: {} };
              return at && (at.width && (Bt.video.width = at.width), at.height && (Bt.video.height = at.height), at.framerate && (Bt.video.framerate = parseFloat(at.framerate)), at.hdrMetadataType && (Bt.video.hdrMetadataType = at.hdrMetadataType), at.colorGamut && (Bt.video.colorGamut = at.colorGamut), at.transferFunction && (Bt.video.transferFunction = at.transferFunction)), Bt;
            }(X) : D === c.A.AUDIO && (yt = function(at) {
              const Bt = { audio: {} };
              return at.samplerate && (Bt.audio.samplerate = at.samplerate), Bt;
            }(X)), yt[D].contentType = X.codec, yt[D].bitrate = parseInt(X.bitrate), yt.type = "media-source";
            let Mt = X.codec;
            return X.width && X.height && (Mt += ';width="' + X.width + '";height="' + X.height + '"'), yt.mediaSourceCodecString = Mt, function(at, Bt, jt) {
              return Bt && Bt.keySystemsMetadata && Bt.keySystemsMetadata.length !== 0 ? Bt.keySystemsMetadata.map((At) => {
                const Ce = Da({}, at);
                if (At.ks) {
                  Ce.keySystemConfiguration = {}, At.ks.systemString && (Ce.keySystemConfiguration.keySystem = At.ks.systemString);
                  let ne = "";
                  At.ks.systemString === d.A.WIDEVINE_KEYSTEM_STRING && (ne = d.A.ROBUSTNESS_STRINGS.WIDEVINE.SW_SECURE_CRYPTO);
                  const Ht = At.protData, Le = Ht && Ht.audioRobustness && Ht.audioRobustness.length > 0 ? Ht.audioRobustness : ne, sn = Ht && Ht.videoRobustness && Ht.videoRobustness.length > 0 ? Ht.videoRobustness : ne;
                  jt === c.A.AUDIO ? Ce.keySystemConfiguration[jt] = { robustness: Le } : jt === c.A.VIDEO && (Ce.keySystemConfiguration[jt] = { robustness: sn });
                }
                return Ce;
              }) : [at];
            }(yt, X, D);
          }
          function vt(X) {
            if (h && h.length !== 0 && X) return h.find((D) => {
              const yt = Lt(X, D, c.A.AUDIO), Mt = Lt(X, D, c.A.VIDEO), at = Lt(X, D, "keySystemConfiguration");
              return yt && Mt && at;
            });
          }
          function Lt(X, D, yt) {
            return !X[yt] && !D[yt] || !(!X[yt] || !D[yt]) && V.areEqual(X[yt], D[yt]);
          }
          function zt(X, D) {
            return (X = X.filter((yt) => !(yt.schemeIdUri && D.some((Mt) => Mt.schemeIdUri === yt.schemeIdUri)))).push(...D), X;
          }
          return n = { areKeyIdsExpired: function(X) {
            return !!(l && X && X.normalizedKeyIds && X.normalizedKeyIds.size !== 0) && l.areKeyIdsExpired(X.normalizedKeyIds);
          }, areKeyIdsUsable: function(X) {
            return !(l && X && X.normalizedKeyIds && X.normalizedKeyIds.size !== 0) || l.areKeyIdsUsable(X.normalizedKeyIds);
          }, isCodecSupportedBasedOnTestedConfigurations: function(X, D) {
            if (!X || !X.codec || X.isSupported === !1) return !1;
            const yt = Q(X, D).map((Mt) => vt(Mt)).filter((Mt) => Mt != null);
            return !(yt && yt.length > 0) || function(Mt) {
              return Mt.some((at) => at && at.decodingInfo && at.decodingInfo.supported);
            }(yt);
          }, isProtectionCompatible: function(X, D) {
            return !D || !(!X.isEncrypted && D.isEncrypted);
          }, runCodecSupportCheck: function(X, D) {
            if (D !== c.A.AUDIO && D !== c.A.VIDEO && D !== c.A.MESH) return Promise.resolve();
            const yt = Q(X, D);
            return function(Mt, at) {
              return o.get().streaming.capabilities.useMediaCapabilitiesApi && navigator.mediaCapabilities && navigator.mediaCapabilities.decodingInfo && (Mt.codec && at === c.A.AUDIO || at === c.A.VIDEO && Mt.codec && Mt.width && Mt.height && Mt.bitrate && Mt.framerate);
            }(X, D) ? function(Mt) {
              return new Promise((at) => {
                if (!Mt || Mt.length === 0) return void at();
                const Bt = Mt.map((jt) => function(At) {
                  return new Promise((Ce) => {
                    vt(At) ? Ce() : navigator.mediaCapabilities.decodingInfo(At).then((ne) => {
                      At.decodingInfo = ne, h.push(At), Ce();
                    }).catch((ne) => {
                      At.decodingInfo = { supported: !1 }, h.push(At), z.error(ne), Ce();
                    });
                  });
                }(jt));
                Promise.allSettled(Bt).then(() => {
                  at();
                }).catch((jt) => {
                  z.error(jt), at();
                });
              });
            }(yt) : (function(Mt) {
              if (!Mt || !Mt.length) return;
              const at = Mt[0];
              if (vt(at)) return;
              let Bt = { supported: !1 };
              ("ManagedMediaSource" in window && ManagedMediaSource.isTypeSupported(at.mediaSourceCodecString) || "MediaSource" in window && MediaSource.isTypeSupported(at.mediaSourceCodecString) || "WebKitMediaSource" in window && WebKitMediaSource.isTypeSupported(at.mediaSourceCodecString)) && (Bt.supported = !0), at.decodingInfo = Bt, h.push(at);
            }(yt), Promise.resolve());
          }, setConfig: function(X) {
            X && (X.settings && (o = X.settings), X.protectionController && (l = X.protectionController));
          }, setEncryptedMediaSupported: function(X) {
            p = X;
          }, setProtectionController: function(X) {
            l = X;
          }, supportsChangeType: function() {
            return !!window.SourceBuffer && !!SourceBuffer.prototype && !!SourceBuffer.prototype.changeType;
          }, supportsEncryptedMedia: function() {
            return p;
          }, supportsEssentialProperty: function(X) {
            let D = o.get().streaming.capabilities.supportedEssentialProperties;
            o.get().streaming.capabilities.useMediaCapabilitiesApi && o.get().streaming.capabilities.filterVideoColorimetryEssentialProperties && (D = zt(D, [{ schemeIdUri: c.A.COLOUR_PRIMARIES_SCHEME_ID_URI }, { schemeIdUri: c.A.MATRIX_COEFFICIENTS_SCHEME_ID_URI }, { schemeIdUri: c.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI }])), o.get().streaming.capabilities.useMediaCapabilitiesApi && o.get().streaming.capabilities.filterHDRMetadataFormatEssentialProperties && (D = zt(D, [{ schemeIdUri: c.A.HDR_METADATA_FORMAT_SCHEME_ID_URI }]));
            try {
              return X.inArray(D);
            } catch (yt) {
              return !0;
            }
          }, supportsMediaSource: y }, p = !1, h = [], z = (0, b.A)(Z).getInstance().getLogger(n), n;
        }
        T.__dashjs_factory_name = "Capabilities", g.A = B.A.getSingletonFactory(T);
      }, 7377: function(k, g, w) {
        var B = w(138), c = w(656);
        function d() {
          return { customTimeRangeArray: [], length: 0, add: function(m, b) {
            let y;
            for (y = 0; y < this.customTimeRangeArray.length && m > this.customTimeRangeArray[y].start; y++) ;
            for (this.customTimeRangeArray.splice(y, 0, { start: m, end: b }), y = 0; y < this.customTimeRangeArray.length - 1; y++) this.mergeRanges(y, y + 1) && y--;
            this.length = this.customTimeRangeArray.length;
          }, clear: function() {
            this.customTimeRangeArray = [], this.length = 0;
          }, remove: function(m, b) {
            for (let y = 0; y < this.customTimeRangeArray.length; y++) if (m <= this.customTimeRangeArray[y].start && b >= this.customTimeRangeArray[y].end) this.customTimeRangeArray.splice(y, 1), y--;
            else {
              if (m > this.customTimeRangeArray[y].start && b < this.customTimeRangeArray[y].end) {
                this.customTimeRangeArray.splice(y + 1, 0, { start: b, end: this.customTimeRangeArray[y].end }), this.customTimeRangeArray[y].end = m;
                break;
              }
              m > this.customTimeRangeArray[y].start && m < this.customTimeRangeArray[y].end ? this.customTimeRangeArray[y].end = m : b > this.customTimeRangeArray[y].start && b < this.customTimeRangeArray[y].end && (this.customTimeRangeArray[y].start = b);
            }
            this.length = this.customTimeRangeArray.length;
          }, mergeRanges: function(m, b) {
            let y = this.customTimeRangeArray[m], T = this.customTimeRangeArray[b];
            return y.start <= T.start && T.start <= y.end && y.end <= T.end ? (y.end = T.end, this.customTimeRangeArray.splice(b, 1), !0) : T.start <= y.start && y.start <= T.end && T.end <= y.end ? (y.start = T.start, this.customTimeRangeArray.splice(b, 1), !0) : T.start <= y.start && y.start <= T.end && y.end <= T.end ? (this.customTimeRangeArray.splice(m, 1), !0) : y.start <= T.start && T.start <= y.end && T.end <= y.end && (this.customTimeRangeArray.splice(b, 1), !0);
          }, start: function(m) {
            return (0, c.zQ)(m), m >= this.customTimeRangeArray.length || m < 0 ? NaN : this.customTimeRangeArray[m].start;
          }, end: function(m) {
            return (0, c.zQ)(m), m >= this.customTimeRangeArray.length || m < 0 ? NaN : this.customTimeRangeArray[m].end;
          } };
        }
        d.__dashjs_factory_name = "CustomTimeRanges", g.A = B.A.getClassFactory(d);
      }, 7393: function(k, g, w) {
        var B = w(138), c = w(7316);
        function d() {
          let m;
          return m = { areEqual: function(b, y) {
            return c(b, y);
          } }, m;
        }
        d.__dashjs_factory_name = "ObjectUtils", g.A = B.A.getSingletonFactory(d);
      }, 656: function(k, g, w) {
        w.d(g, { sq: function() {
          return c;
        }, zQ: function() {
          return d;
        } });
        var B = w(5212);
        function c(m, b) {
          if (typeof m !== b) throw B.A.BAD_ARGUMENT_ERROR;
        }
        function d(m) {
          if (m === null || isNaN(m) || m % 1 != 0) throw B.A.BAD_ARGUMENT_ERROR + " : argument is not an integer";
        }
      }, 1944: function(k, g) {
        g.A = class {
          constructor(w, B, c) {
            this.code = w || null, this.message = B || null, this.data = c || null;
          }
        };
      }, 7568: function(k, g, w) {
        w.d(g, { G: function() {
          return B;
        }, N: function() {
          return c;
        } });
        class B {
          constructor() {
            this.tcpid = null, this.type = null, this.url = null, this.actualurl = null, this.range = null, this.trequest = null, this.tresponse = null, this.responsecode = null, this.interval = null, this.trace = [], this.cmsd = null, this._stream = null, this._tfinish = null, this._mediaduration = null, this._responseHeaders = null, this._serviceLocation = null, this._fileLoaderType = null, this._resourceTimingValues = null;
          }
        }
        class c {
          constructor() {
            this.s = null, this.d = null, this.b = [];
          }
        }
        B.GET = "GET", B.HEAD = "HEAD", B.MPD_TYPE = "MPD", B.XLINK_EXPANSION_TYPE = "XLinkExpansion", B.INIT_SEGMENT_TYPE = "InitializationSegment", B.INDEX_SEGMENT_TYPE = "IndexSegment", B.MEDIA_SEGMENT_TYPE = "MediaSegment", B.BITSTREAM_SWITCHING_SEGMENT_TYPE = "BitstreamSwitchingSegment", B.MSS_FRAGMENT_INFO_SEGMENT_TYPE = "FragmentInfoSegment", B.DVB_REPORTING_TYPE = "DVBReporting", B.LICENSE = "license", B.CONTENT_STEERING_TYPE = "ContentSteering", B.OTHER_TYPE = "other";
      } }, u = {};
      function I(k) {
        var g = u[k];
        if (g !== void 0) return g.exports;
        var w = u[k] = { id: k, loaded: !1, exports: {} };
        return r[k].call(w.exports, w, w.exports, I), w.loaded = !0, w.exports;
      }
      I.amdO = {}, I.d = function(k, g) {
        for (var w in g) I.o(g, w) && !I.o(k, w) && Object.defineProperty(k, w, { enumerable: !0, get: g[w] });
      }, I.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch (k) {
          if (typeof window == "object") return window;
        }
      }(), I.o = function(k, g) {
        return Object.prototype.hasOwnProperty.call(k, g);
      }, I.nmd = function(k) {
        return k.paths = [], k.children || (k.children = []), k;
      };
      var E = {};
      return function() {
        I.d(E, { default: function() {
          return T;
        } }), I(5393);
        var k = I(4469), g = I(3888), w = I(4952);
        let B, c = /* @__PURE__ */ function() {
          const n = "application/dash+xml";
          let o;
          function l(p, z, Z) {
            if (!p || !/^VIDEO$/i.test(p.nodeName)) return null;
            if (p._dashjs_player) return p._dashjs_player;
            let V, Q = p.id || p.name || "video element";
            if (!(z = z || [].slice.call(p.querySelectorAll("source")).filter(function(vt) {
              return vt.type == n;
            })[0]) && p.src) (z = document.createElement("source")).src = p.src;
            else if (!z && !p.src) return null;
            return Z = Z || {}, V = (0, w.A)(Z).create(), V.initialize(p, z.src, p.autoplay), o || (o = V.getDebug().getLogger()), o.debug("Converted " + Q + " to dash.js player and added content: " + z.src), p._dashjs_player = V, V;
          }
          function h(p) {
            return /^VIDEO$/i.test(p.nodeName) ? p : h(p.parentNode);
          }
          return { create: l, createAll: function(p, z) {
            let Z = [];
            p = p || "[data-dashjs-player]";
            let V = (z = z || document).querySelectorAll(p);
            for (let vt = 0; vt < V.length; vt++) {
              let Lt = l(V[vt], null);
              Z.push(Lt);
            }
            let Q = z.querySelectorAll('source[type="' + n + '"]');
            for (let vt = 0; vt < Q.length; vt++) {
              let Lt = l(h(Q[vt]), null);
              Z.push(Lt);
            }
            return Z;
          } };
        }();
        !(typeof window != "undefined" && window && window.dashjs && window.dashjs.skipAutoCreate) && typeof window != "undefined" && window && window.addEventListener && (window.document.readyState === "complete" ? window.dashjs ? c.createAll() : B = window.setInterval(function() {
          window.dashjs && (window.clearInterval(B), c.createAll());
        }, 500) : window.addEventListener("load", function n() {
          window.removeEventListener("load", n), c.createAll();
        }));
        var d = c, m = I(649), b = I(5212), y = I(559);
        dashjs.Protection = g.default, dashjs.MetricsReporting = k.default, dashjs.MediaPlayerFactory = d, dashjs.Debug = m.A, dashjs.supportsMediaSource = y.a, dashjs.Constants = b.A;
        var T = dashjs;
      }(), E.default;
    }();
  });
})(km, km.exports);
var ra = km.exports, Mn = {}, Ny = { exports: {} }, na = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ju = Symbol.for("react.element"), Fw = Symbol.for("react.portal"), Ow = Symbol.for("react.fragment"), Uw = Symbol.for("react.strict_mode"), Kw = Symbol.for("react.profiler"), Vw = Symbol.for("react.provider"), Xw = Symbol.for("react.context"), Ww = Symbol.for("react.forward_ref"), jw = Symbol.for("react.suspense"), Zw = Symbol.for("react.memo"), Jw = Symbol.for("react.lazy"), zI = Symbol.iterator;
function Qw(t) {
  return t === null || typeof t != "object" ? null : (t = zI && t[zI] || t["@@iterator"], typeof t == "function" ? t : null);
}
var Gy = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, zy = Object.assign, Yy = {};
function Rl(t, e, r) {
  this.props = t, this.context = e, this.refs = Yy, this.updater = r || Gy;
}
Rl.prototype.isReactComponent = {};
Rl.prototype.setState = function(t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, t, e, "setState");
};
Rl.prototype.forceUpdate = function(t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function Hy() {
}
Hy.prototype = Rl.prototype;
function Gf(t, e, r) {
  this.props = t, this.context = e, this.refs = Yy, this.updater = r || Gy;
}
var zf = Gf.prototype = new Hy();
zf.constructor = Gf;
zy(zf, Rl.prototype);
zf.isPureReactComponent = !0;
var YI = Array.isArray, Py = Object.prototype.hasOwnProperty, Yf = { current: null }, Fy = { key: !0, ref: !0, __self: !0, __source: !0 };
function Oy(t, e, r) {
  var u, I = {}, E = null, k = null;
  if (e != null) for (u in e.ref !== void 0 && (k = e.ref), e.key !== void 0 && (E = "" + e.key), e) Py.call(e, u) && !Fy.hasOwnProperty(u) && (I[u] = e[u]);
  var g = arguments.length - 2;
  if (g === 1) I.children = r;
  else if (1 < g) {
    for (var w = Array(g), B = 0; B < g; B++) w[B] = arguments[B + 2];
    I.children = w;
  }
  if (t && t.defaultProps) for (u in g = t.defaultProps, g) I[u] === void 0 && (I[u] = g[u]);
  return { $$typeof: Ju, type: t, key: E, ref: k, props: I, _owner: Yf.current };
}
function qw(t, e) {
  return { $$typeof: Ju, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner };
}
function Hf(t) {
  return typeof t == "object" && t !== null && t.$$typeof === Ju;
}
function $w(t) {
  var e = { "=": "=0", ":": "=2" };
  return "$" + t.replace(/[=:]/g, function(r) {
    return e[r];
  });
}
var HI = /\/+/g;
function Oc(t, e) {
  return typeof t == "object" && t !== null && t.key != null ? $w("" + t.key) : e.toString(36);
}
function rg(t, e, r, u, I) {
  var E = typeof t;
  (E === "undefined" || E === "boolean") && (t = null);
  var k = !1;
  if (t === null) k = !0;
  else switch (E) {
    case "string":
    case "number":
      k = !0;
      break;
    case "object":
      switch (t.$$typeof) {
        case Ju:
        case Fw:
          k = !0;
      }
  }
  if (k) return k = t, I = I(k), t = u === "" ? "." + Oc(k, 0) : u, YI(I) ? (r = "", t != null && (r = t.replace(HI, "$&/") + "/"), rg(I, e, r, "", function(B) {
    return B;
  })) : I != null && (Hf(I) && (I = qw(I, r + (!I.key || k && k.key === I.key ? "" : ("" + I.key).replace(HI, "$&/") + "/") + t)), e.push(I)), 1;
  if (k = 0, u = u === "" ? "." : u + ":", YI(t)) for (var g = 0; g < t.length; g++) {
    E = t[g];
    var w = u + Oc(E, g);
    k += rg(E, e, r, w, I);
  }
  else if (w = Qw(t), typeof w == "function") for (t = w.call(t), g = 0; !(E = t.next()).done; ) E = E.value, w = u + Oc(E, g++), k += rg(E, e, r, w, I);
  else if (E === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
  return k;
}
function Yd(t, e, r) {
  if (t == null) return t;
  var u = [], I = 0;
  return rg(t, u, "", "", function(E) {
    return e.call(r, E, I++);
  }), u;
}
function tv(t) {
  if (t._status === -1) {
    var e = t._result;
    e = e(), e.then(function(r) {
      (t._status === 0 || t._status === -1) && (t._status = 1, t._result = r);
    }, function(r) {
      (t._status === 0 || t._status === -1) && (t._status = 2, t._result = r);
    }), t._status === -1 && (t._status = 0, t._result = e);
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var wi = { current: null }, sg = { transition: null }, ev = { ReactCurrentDispatcher: wi, ReactCurrentBatchConfig: sg, ReactCurrentOwner: Yf };
function Uy() {
  throw Error("act(...) is not supported in production builds of React.");
}
na.Children = { map: Yd, forEach: function(t, e, r) {
  Yd(t, function() {
    e.apply(this, arguments);
  }, r);
}, count: function(t) {
  var e = 0;
  return Yd(t, function() {
    e++;
  }), e;
}, toArray: function(t) {
  return Yd(t, function(e) {
    return e;
  }) || [];
}, only: function(t) {
  if (!Hf(t)) throw Error("React.Children.only expected to receive a single React element child.");
  return t;
} };
na.Component = Rl;
na.Fragment = Ow;
na.Profiler = Kw;
na.PureComponent = Gf;
na.StrictMode = Uw;
na.Suspense = jw;
na.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ev;
na.act = Uy;
na.cloneElement = function(t, e, r) {
  if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
  var u = zy({}, t.props), I = t.key, E = t.ref, k = t._owner;
  if (e != null) {
    if (e.ref !== void 0 && (E = e.ref, k = Yf.current), e.key !== void 0 && (I = "" + e.key), t.type && t.type.defaultProps) var g = t.type.defaultProps;
    for (w in e) Py.call(e, w) && !Fy.hasOwnProperty(w) && (u[w] = e[w] === void 0 && g !== void 0 ? g[w] : e[w]);
  }
  var w = arguments.length - 2;
  if (w === 1) u.children = r;
  else if (1 < w) {
    g = Array(w);
    for (var B = 0; B < w; B++) g[B] = arguments[B + 2];
    u.children = g;
  }
  return { $$typeof: Ju, type: t.type, key: I, ref: E, props: u, _owner: k };
};
na.createContext = function(t) {
  return t = { $$typeof: Xw, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: Vw, _context: t }, t.Consumer = t;
};
na.createElement = Oy;
na.createFactory = function(t) {
  var e = Oy.bind(null, t);
  return e.type = t, e;
};
na.createRef = function() {
  return { current: null };
};
na.forwardRef = function(t) {
  return { $$typeof: Ww, render: t };
};
na.isValidElement = Hf;
na.lazy = function(t) {
  return { $$typeof: Jw, _payload: { _status: -1, _result: t }, _init: tv };
};
na.memo = function(t, e) {
  return { $$typeof: Zw, type: t, compare: e === void 0 ? null : e };
};
na.startTransition = function(t) {
  var e = sg.transition;
  sg.transition = {};
  try {
    t();
  } finally {
    sg.transition = e;
  }
};
na.unstable_act = Uy;
na.useCallback = function(t, e) {
  return wi.current.useCallback(t, e);
};
na.useContext = function(t) {
  return wi.current.useContext(t);
};
na.useDebugValue = function() {
};
na.useDeferredValue = function(t) {
  return wi.current.useDeferredValue(t);
};
na.useEffect = function(t, e) {
  return wi.current.useEffect(t, e);
};
na.useId = function() {
  return wi.current.useId();
};
na.useImperativeHandle = function(t, e, r) {
  return wi.current.useImperativeHandle(t, e, r);
};
na.useInsertionEffect = function(t, e) {
  return wi.current.useInsertionEffect(t, e);
};
na.useLayoutEffect = function(t, e) {
  return wi.current.useLayoutEffect(t, e);
};
na.useMemo = function(t, e) {
  return wi.current.useMemo(t, e);
};
na.useReducer = function(t, e, r) {
  return wi.current.useReducer(t, e, r);
};
na.useRef = function(t) {
  return wi.current.useRef(t);
};
na.useState = function(t) {
  return wi.current.useState(t);
};
na.useSyncExternalStore = function(t, e, r) {
  return wi.current.useSyncExternalStore(t, e, r);
};
na.useTransition = function() {
  return wi.current.useTransition();
};
na.version = "18.3.1";
Ny.exports = na;
var Zg = Ny.exports;
const Qu = /* @__PURE__ */ Nf(Zg);
var Lm = { exports: {} };
(function(t, e) {
  (function(r, u) {
    var I = "1.0.38", E = "", k = "?", g = "function", w = "undefined", B = "object", c = "string", d = "major", m = "model", b = "name", y = "type", T = "vendor", n = "version", o = "architecture", l = "console", h = "mobile", p = "tablet", z = "smarttv", Z = "wearable", V = "embedded", Q = 500, vt = "Amazon", Lt = "Apple", zt = "ASUS", X = "BlackBerry", D = "Browser", yt = "Chrome", Mt = "Edge", at = "Firefox", Bt = "Google", jt = "Huawei", At = "LG", Ce = "Microsoft", ne = "Motorola", Ht = "Opera", Le = "Samsung", sn = "Sharp", we = "Sony", ln = "Xiaomi", _e = "Zebra", Rn = "Facebook", En = "Chromium OS", Tn = "Mac OS", Nt = function(Kt, ae) {
      var Qt = {};
      for (var me in Kt)
        ae[me] && ae[me].length % 2 === 0 ? Qt[me] = ae[me].concat(Kt[me]) : Qt[me] = Kt[me];
      return Qt;
    }, Ft = function(Kt) {
      for (var ae = {}, Qt = 0; Qt < Kt.length; Qt++)
        ae[Kt[Qt].toUpperCase()] = Kt[Qt];
      return ae;
    }, ve = function(Kt, ae) {
      return typeof Kt === c ? q(ae).indexOf(q(Kt)) !== -1 : !1;
    }, q = function(Kt) {
      return Kt.toLowerCase();
    }, tt = function(Kt) {
      return typeof Kt === c ? Kt.replace(/[^\d\.]/g, E).split(".")[0] : u;
    }, x = function(Kt, ae) {
      if (typeof Kt === c)
        return Kt = Kt.replace(/^\s\s*/, E), typeof ae === w ? Kt : Kt.substring(0, Q);
    }, U = function(Kt, ae) {
      for (var Qt = 0, me, an, Ge, Te, ge, ze; Qt < ae.length && !ge; ) {
        var Zn = ae[Qt], qn = ae[Qt + 1];
        for (me = an = 0; me < Zn.length && !ge && Zn[me]; )
          if (ge = Zn[me++].exec(Kt), ge)
            for (Ge = 0; Ge < qn.length; Ge++)
              ze = ge[++an], Te = qn[Ge], typeof Te === B && Te.length > 0 ? Te.length === 2 ? typeof Te[1] == g ? this[Te[0]] = Te[1].call(this, ze) : this[Te[0]] = Te[1] : Te.length === 3 ? typeof Te[1] === g && !(Te[1].exec && Te[1].test) ? this[Te[0]] = ze ? Te[1].call(this, ze, Te[2]) : u : this[Te[0]] = ze ? ze.replace(Te[1], Te[2]) : u : Te.length === 4 && (this[Te[0]] = ze ? Te[3].call(this, ze.replace(Te[1], Te[2])) : u) : this[Te] = ze || u;
        Qt += 2;
      }
    }, pt = function(Kt, ae) {
      for (var Qt in ae)
        if (typeof ae[Qt] === B && ae[Qt].length > 0) {
          for (var me = 0; me < ae[Qt].length; me++)
            if (ve(ae[Qt][me], Kt))
              return Qt === k ? u : Qt;
        } else if (ve(ae[Qt], Kt))
          return Qt === k ? u : Qt;
      return Kt;
    }, lt = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, Gt = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ee = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [n, [b, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [n, [b, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [b, n], [/opios[\/ ]+([\w\.]+)/i], [n, [b, Ht + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [n, [b, Ht + " GX"]], [/\bopr\/([\w\.]+)/i], [n, [b, Ht]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [n, [b, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [b, n], [/\bddg\/([\w\.]+)/i], [n, [b, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [n, [b, "UC" + D]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [n, [b, "WeChat"]], [/konqueror\/([\w\.]+)/i], [n, [b, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [n, [b, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [n, [b, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [n, [b, "Smart Lenovo " + D]], [/(avast|avg)\/([\w\.]+)/i], [[b, /(.+)/, "$1 Secure " + D], n], [/\bfocus\/([\w\.]+)/i], [n, [b, at + " Focus"]], [/\bopt\/([\w\.]+)/i], [n, [b, Ht + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [n, [b, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [n, [b, "Dolphin"]], [/coast\/([\w\.]+)/i], [n, [b, Ht + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [n, [b, "MIUI " + D]], [/fxios\/([-\w\.]+)/i], [n, [b, at]], [/\bqihu|(qi?ho?o?|360)browser/i], [[b, "360 " + D]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[b, /(.+)/, "$1 " + D], n], [/samsungbrowser\/([\w\.]+)/i], [n, [b, Le + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[b, /_/g, " "], n], [/metasr[\/ ]?([\d\.]+)/i], [n, [b, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[b, "Sogou Mobile"], n], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [b, n], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [b], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[b, Rn], n], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [b, n], [/\bgsa\/([\w\.]+) .*safari\//i], [n, [b, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [n, [b, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [n, [b, yt + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[b, yt + " WebView"], n], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [n, [b, "Android " + D]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [b, n], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [n, [b, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [n, b], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [b, [n, pt, lt]], [/(webkit|khtml)\/([\w\.]+)/i], [b, n], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[b, "Netscape"], n], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [n, [b, at + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [b, n], [/(cobalt)\/([\w\.]+)/i], [b, [n, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[o, "amd64"]], [/(ia32(?=;))/i], [[o, q]], [/((?:i[346]|x)86)[;\)]/i], [[o, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[o, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[o, "armhf"]], [/windows (ce|mobile); ppc;/i], [[o, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[o, /ower/, E, q]], [/(sun4\w)[;\)]/i], [[o, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[o, q]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [m, [T, Le], [y, p]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [m, [T, Le], [y, h]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [m, [T, Lt], [y, h]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [m, [T, Lt], [y, p]], [/(macintosh);/i], [m, [T, Lt]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [m, [T, sn], [y, h]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [m, [T, jt], [y, p]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [m, [T, jt], [y, h]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[m, /_/g, " "], [T, ln], [y, h]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[m, /_/g, " "], [T, ln], [y, p]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [m, [T, "OPPO"], [y, h]], [/\b(opd2\d{3}a?) bui/i], [m, [T, "OPPO"], [y, p]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [m, [T, "Vivo"], [y, h]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [m, [T, "Realme"], [y, h]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [m, [T, ne], [y, h]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [m, [T, ne], [y, p]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [m, [T, At], [y, p]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [m, [T, At], [y, h]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [m, [T, "Lenovo"], [y, p]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[m, /_/g, " "], [T, "Nokia"], [y, h]], [/(pixel c)\b/i], [m, [T, Bt], [y, p]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [m, [T, Bt], [y, h]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [m, [T, we], [y, h]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[m, "Xperia Tablet"], [T, we], [y, p]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [m, [T, "OnePlus"], [y, h]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [m, [T, vt], [y, p]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[m, /(.+)/g, "Fire Phone $1"], [T, vt], [y, h]], [/(playbook);[-\w\),; ]+(rim)/i], [m, T, [y, p]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [m, [T, X], [y, h]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [m, [T, zt], [y, p]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [m, [T, zt], [y, h]], [/(nexus 9)/i], [m, [T, "HTC"], [y, p]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [T, [m, /_/g, " "], [y, h]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [m, [T, "Acer"], [y, p]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [m, [T, "Meizu"], [y, h]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [m, [T, "Ulefone"], [y, h]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [T, m, [y, h]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [T, m, [y, p]], [/(surface duo)/i], [m, [T, Ce], [y, p]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [m, [T, "Fairphone"], [y, h]], [/(u304aa)/i], [m, [T, "AT&T"], [y, h]], [/\bsie-(\w*)/i], [m, [T, "Siemens"], [y, h]], [/\b(rct\w+) b/i], [m, [T, "RCA"], [y, p]], [/\b(venue[\d ]{2,7}) b/i], [m, [T, "Dell"], [y, p]], [/\b(q(?:mv|ta)\w+) b/i], [m, [T, "Verizon"], [y, p]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [m, [T, "Barnes & Noble"], [y, p]], [/\b(tm\d{3}\w+) b/i], [m, [T, "NuVision"], [y, p]], [/\b(k88) b/i], [m, [T, "ZTE"], [y, p]], [/\b(nx\d{3}j) b/i], [m, [T, "ZTE"], [y, h]], [/\b(gen\d{3}) b.+49h/i], [m, [T, "Swiss"], [y, h]], [/\b(zur\d{3}) b/i], [m, [T, "Swiss"], [y, p]], [/\b((zeki)?tb.*\b) b/i], [m, [T, "Zeki"], [y, p]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[T, "Dragon Touch"], m, [y, p]], [/\b(ns-?\w{0,9}) b/i], [m, [T, "Insignia"], [y, p]], [/\b((nxa|next)-?\w{0,9}) b/i], [m, [T, "NextBook"], [y, p]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[T, "Voice"], m, [y, h]], [/\b(lvtel\-)?(v1[12]) b/i], [[T, "LvTel"], m, [y, h]], [/\b(ph-1) /i], [m, [T, "Essential"], [y, h]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [m, [T, "Envizen"], [y, p]], [/\b(trio[-\w\. ]+) b/i], [m, [T, "MachSpeed"], [y, p]], [/\btu_(1491) b/i], [m, [T, "Rotor"], [y, p]], [/(shield[\w ]+) b/i], [m, [T, "Nvidia"], [y, p]], [/(sprint) (\w+)/i], [T, m, [y, h]], [/(kin\.[onetw]{3})/i], [[m, /\./g, " "], [T, Ce], [y, h]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [m, [T, _e], [y, p]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [m, [T, _e], [y, h]], [/smart-tv.+(samsung)/i], [T, [y, z]], [/hbbtv.+maple;(\d+)/i], [[m, /^/, "SmartTV"], [T, Le], [y, z]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[T, At], [y, z]], [/(apple) ?tv/i], [T, [m, Lt + " TV"], [y, z]], [/crkey/i], [[m, yt + "cast"], [T, Bt], [y, z]], [/droid.+aft(\w+)( bui|\))/i], [m, [T, vt], [y, z]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [m, [T, sn], [y, z]], [/(bravia[\w ]+)( bui|\))/i], [m, [T, we], [y, z]], [/(mitv-\w{5}) bui/i], [m, [T, ln], [y, z]], [/Hbbtv.*(technisat) (.*);/i], [T, m, [y, z]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[T, x], [m, x], [y, z]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[y, z]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [T, m, [y, l]], [/droid.+; (shield) bui/i], [m, [T, "Nvidia"], [y, l]], [/(playstation [345portablevi]+)/i], [m, [T, we], [y, l]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [m, [T, Ce], [y, l]], [/((pebble))app/i], [T, m, [y, Z]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [m, [T, Lt], [y, Z]], [/droid.+; (glass) \d/i], [m, [T, Bt], [y, Z]], [/droid.+; (wt63?0{2,3})\)/i], [m, [T, _e], [y, Z]], [/(quest( \d| pro)?)/i], [m, [T, Rn], [y, Z]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [T, [y, V]], [/(aeobc)\b/i], [m, [T, vt], [y, V]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [m, [y, h]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [m, [y, p]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[y, p]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[y, h]], [/(android[-\w\. ]{0,9});.+buil/i], [m, [T, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [n, [b, Mt + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [n, [b, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [b, n], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [n, b]], os: [[/microsoft (windows) (vista|xp)/i], [b, n], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [b, [n, pt, Gt]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[n, pt, Gt], [b, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[n, /_/g, "."], [b, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[b, Tn], [n, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [n, b], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [b, n], [/\(bb(10);/i], [n, [b, X]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [n, [b, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [n, [b, at + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [n, [b, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [n, [b, "watchOS"]], [/crkey\/([\d\.]+)/i], [n, [b, yt + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[b, En], n], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [b, n], [/(sunos) ?([\w\.\d]*)/i], [[b, "Solaris"], n], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [b, n]] }, Vt = function(Kt, ae) {
      if (typeof Kt === B && (ae = Kt, Kt = u), !(this instanceof Vt))
        return new Vt(Kt, ae).getResult();
      var Qt = typeof r !== w && r.navigator ? r.navigator : u, me = Kt || (Qt && Qt.userAgent ? Qt.userAgent : E), an = Qt && Qt.userAgentData ? Qt.userAgentData : u, Ge = ae ? Nt(ee, ae) : ee, Te = Qt && Qt.userAgent == me;
      return this.getBrowser = function() {
        var ge = {};
        return ge[b] = u, ge[n] = u, U.call(ge, me, Ge.browser), ge[d] = tt(ge[n]), Te && Qt && Qt.brave && typeof Qt.brave.isBrave == g && (ge[b] = "Brave"), ge;
      }, this.getCPU = function() {
        var ge = {};
        return ge[o] = u, U.call(ge, me, Ge.cpu), ge;
      }, this.getDevice = function() {
        var ge = {};
        return ge[T] = u, ge[m] = u, ge[y] = u, U.call(ge, me, Ge.device), Te && !ge[y] && an && an.mobile && (ge[y] = h), Te && ge[m] == "Macintosh" && Qt && typeof Qt.standalone !== w && Qt.maxTouchPoints && Qt.maxTouchPoints > 2 && (ge[m] = "iPad", ge[y] = p), ge;
      }, this.getEngine = function() {
        var ge = {};
        return ge[b] = u, ge[n] = u, U.call(ge, me, Ge.engine), ge;
      }, this.getOS = function() {
        var ge = {};
        return ge[b] = u, ge[n] = u, U.call(ge, me, Ge.os), Te && !ge[b] && an && an.platform && an.platform != "Unknown" && (ge[b] = an.platform.replace(/chrome os/i, En).replace(/macos/i, Tn)), ge;
      }, this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      }, this.getUA = function() {
        return me;
      }, this.setUA = function(ge) {
        return me = typeof ge === c && ge.length > Q ? x(ge, Q) : ge, this;
      }, this.setUA(me), this;
    };
    Vt.VERSION = I, Vt.BROWSER = Ft([b, n, d]), Vt.CPU = Ft([o]), Vt.DEVICE = Ft([m, T, y, l, h, z, p, Z, V]), Vt.ENGINE = Vt.OS = Ft([b, n]), t.exports && (e = t.exports = Vt), e.UAParser = Vt;
    var Jt = typeof r !== w && (r.jQuery || r.Zepto);
    if (Jt && !Jt.ua) {
      var Ot = new Vt();
      Jt.ua = Ot.getResult(), Jt.ua.get = function() {
        return Ot.getUA();
      }, Jt.ua.set = function(Kt) {
        Ot.setUA(Kt);
        var ae = Ot.getResult();
        for (var Qt in ae)
          Jt.ua[Qt] = ae[Qt];
      };
    }
  })(typeof window == "object" ? window : xy);
})(Lm, Lm.exports);
var nv = Lm.exports;
Object.defineProperty(Mn, "__esModule", { value: !0 });
function av(t) {
  return t && typeof t == "object" && "default" in t ? t.default : t;
}
var Ci = Zg, wa = av(Ci), Ky = nv, js = new Ky(), Ai = js.getBrowser(), iv = js.getCPU(), $i = js.getDevice(), Pf = js.getEngine(), Zs = js.getOS(), qu = js.getUA(), Vy = function(e) {
  return js.setUA(e);
}, $u = function(e) {
  if (!e) {
    console.error("No userAgent string was provided");
    return;
  }
  var r = new Ky(e);
  return {
    UA: r,
    browser: r.getBrowser(),
    cpu: r.getCPU(),
    device: r.getDevice(),
    engine: r.getEngine(),
    os: r.getOS(),
    ua: r.getUA(),
    setUserAgent: function(I) {
      return r.setUA(I);
    }
  };
}, Xy = /* @__PURE__ */ Object.freeze({
  ClientUAInstance: js,
  browser: Ai,
  cpu: iv,
  device: $i,
  engine: Pf,
  os: Zs,
  ua: qu,
  setUa: Vy,
  parseUserAgent: $u
});
function PI(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var u = Object.getOwnPropertySymbols(t);
    e && (u = u.filter(function(I) {
      return Object.getOwnPropertyDescriptor(t, I).enumerable;
    })), r.push.apply(r, u);
  }
  return r;
}
function rv(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? PI(Object(r), !0).forEach(function(u) {
      uv(t, u, r[u]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : PI(Object(r)).forEach(function(u) {
      Object.defineProperty(t, u, Object.getOwnPropertyDescriptor(r, u));
    });
  }
  return t;
}
function bu(t) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? bu = function(e) {
    return typeof e;
  } : bu = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, bu(t);
}
function sv(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function ov(t, e) {
  for (var r = 0; r < e.length; r++) {
    var u = e[r];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(t, u.key, u);
  }
}
function lv(t, e, r) {
  return e && ov(t.prototype, e), t;
}
function uv(t, e, r) {
  return e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function Mm() {
  return Mm = Object.assign || function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var r = arguments[e];
      for (var u in r)
        Object.prototype.hasOwnProperty.call(r, u) && (t[u] = r[u]);
    }
    return t;
  }, Mm.apply(this, arguments);
}
function dv(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), e && Dm(t, e);
}
function Rm(t) {
  return Rm = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Rm(t);
}
function Dm(t, e) {
  return Dm = Object.setPrototypeOf || function(u, I) {
    return u.__proto__ = I, u;
  }, Dm(t, e);
}
function gv(t, e) {
  if (t == null) return {};
  var r = {}, u = Object.keys(t), I, E;
  for (E = 0; E < u.length; E++)
    I = u[E], !(e.indexOf(I) >= 0) && (r[I] = t[I]);
  return r;
}
function Ir(t, e) {
  if (t == null) return {};
  var r = gv(t, e), u, I;
  if (Object.getOwnPropertySymbols) {
    var E = Object.getOwnPropertySymbols(t);
    for (I = 0; I < E.length; I++)
      u = E[I], !(e.indexOf(u) >= 0) && Object.prototype.propertyIsEnumerable.call(t, u) && (r[u] = t[u]);
  }
  return r;
}
function og(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function cv(t, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return og(t);
}
function mv(t, e) {
  return fv(t) || hv(t, e) || pv(t, e) || Iv();
}
function fv(t) {
  if (Array.isArray(t)) return t;
}
function hv(t, e) {
  var r = t == null ? null : typeof Symbol != "undefined" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var u = [], I = !0, E = !1, k, g;
    try {
      for (r = r.call(t); !(I = (k = r.next()).done) && (u.push(k.value), !(e && u.length === e)); I = !0)
        ;
    } catch (w) {
      E = !0, g = w;
    } finally {
      try {
        !I && r.return != null && r.return();
      } finally {
        if (E) throw g;
      }
    }
    return u;
  }
}
function pv(t, e) {
  if (t) {
    if (typeof t == "string") return FI(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set") return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return FI(t, e);
  }
}
function FI(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, u = new Array(e); r < e; r++) u[r] = t[r];
  return u;
}
function Iv() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var pi = {
  Mobile: "mobile",
  Tablet: "tablet",
  SmartTv: "smarttv",
  Console: "console",
  Wearable: "wearable",
  Embedded: "embedded",
  Browser: void 0
}, Pi = {
  Chrome: "Chrome",
  Firefox: "Firefox",
  Opera: "Opera",
  Yandex: "Yandex",
  Safari: "Safari",
  InternetExplorer: "Internet Explorer",
  Edge: "Edge",
  Chromium: "Chromium",
  Ie: "IE",
  MobileSafari: "Mobile Safari",
  EdgeChromium: "Edge Chromium",
  MIUI: "MIUI Browser",
  SamsungBrowser: "Samsung Browser"
}, Dl = {
  IOS: "iOS",
  Android: "Android",
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MAC_OS: "Mac OS"
}, Cv = {
  isMobile: !1,
  isTablet: !1,
  isBrowser: !1,
  isSmartTV: !1,
  isConsole: !1,
  isWearable: !1
}, yv = function(e) {
  switch (e) {
    case pi.Mobile:
      return {
        isMobile: !0
      };
    case pi.Tablet:
      return {
        isTablet: !0
      };
    case pi.SmartTv:
      return {
        isSmartTV: !0
      };
    case pi.Console:
      return {
        isConsole: !0
      };
    case pi.Wearable:
      return {
        isWearable: !0
      };
    case pi.Browser:
      return {
        isBrowser: !0
      };
    case pi.Embedded:
      return {
        isEmbedded: !0
      };
    default:
      return Cv;
  }
}, Av = function(e) {
  return Vy(e);
}, Fn = function(e) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  return e || r;
}, Ff = function() {
  return typeof window != "undefined" && (window.navigator || navigator) ? window.navigator || navigator : !1;
}, Of = function(e) {
  var r = Ff();
  return r && r.platform && (r.platform.indexOf(e) !== -1 || r.platform === "MacIntel" && r.maxTouchPoints > 1 && !window.MSStream);
}, _v = function(e, r, u, I, E) {
  return {
    isBrowser: e,
    browserMajorVersion: Fn(r.major),
    browserFullVersion: Fn(r.version),
    browserName: Fn(r.name),
    engineName: Fn(u.name),
    engineVersion: Fn(u.version),
    osName: Fn(I.name),
    osVersion: Fn(I.version),
    userAgent: Fn(E)
  };
}, OI = function(e, r, u, I) {
  return rv({}, e, {
    vendor: Fn(r.vendor),
    model: Fn(r.model),
    os: Fn(u.name),
    osVersion: Fn(u.version),
    ua: Fn(I)
  });
}, bv = function(e, r, u, I) {
  return {
    isSmartTV: e,
    engineName: Fn(r.name),
    engineVersion: Fn(r.version),
    osName: Fn(u.name),
    osVersion: Fn(u.version),
    userAgent: Fn(I)
  };
}, Sv = function(e, r, u, I) {
  return {
    isConsole: e,
    engineName: Fn(r.name),
    engineVersion: Fn(r.version),
    osName: Fn(u.name),
    osVersion: Fn(u.version),
    userAgent: Fn(I)
  };
}, wv = function(e, r, u, I) {
  return {
    isWearable: e,
    engineName: Fn(r.name),
    engineVersion: Fn(r.version),
    osName: Fn(u.name),
    osVersion: Fn(u.version),
    userAgent: Fn(I)
  };
}, vv = function(e, r, u, I, E) {
  return {
    isEmbedded: e,
    vendor: Fn(r.vendor),
    model: Fn(r.model),
    engineName: Fn(u.name),
    engineVersion: Fn(u.version),
    osName: Fn(I.name),
    osVersion: Fn(I.version),
    userAgent: Fn(E)
  };
};
function Ev(t) {
  var e = t ? $u(t) : Xy, r = e.device, u = e.browser, I = e.engine, E = e.os, k = e.ua, g = yv(r.type), w = g.isBrowser, B = g.isMobile, c = g.isTablet, d = g.isSmartTV, m = g.isConsole, b = g.isWearable, y = g.isEmbedded;
  if (w)
    return _v(w, u, I, E, k);
  if (d)
    return bv(d, I, E, k);
  if (m)
    return Sv(m, I, E, k);
  if (B || c)
    return OI(g, r, E, k);
  if (b)
    return wv(b, I, E, k);
  if (y)
    return vv(y, r, I, E, k);
}
var Wy = function(e) {
  var r = e.type;
  return r === pi.Mobile;
}, jy = function(e) {
  var r = e.type;
  return r === pi.Tablet;
}, Zy = function(e) {
  var r = e.type;
  return r === pi.Mobile || r === pi.Tablet;
}, Jy = function(e) {
  var r = e.type;
  return r === pi.SmartTv;
}, yg = function(e) {
  var r = e.type;
  return r === pi.Browser;
}, Qy = function(e) {
  var r = e.type;
  return r === pi.Wearable;
}, qy = function(e) {
  var r = e.type;
  return r === pi.Console;
}, $y = function(e) {
  var r = e.type;
  return r === pi.Embedded;
}, tA = function(e) {
  var r = e.vendor;
  return Fn(r);
}, eA = function(e) {
  var r = e.model;
  return Fn(r);
}, nA = function(e) {
  var r = e.type;
  return Fn(r, "browser");
}, aA = function(e) {
  var r = e.name;
  return r === Dl.Android;
}, iA = function(e) {
  var r = e.name;
  return r === Dl.Windows;
}, rA = function(e) {
  var r = e.name;
  return r === Dl.MAC_OS;
}, sA = function(e) {
  var r = e.name;
  return r === Dl.WindowsPhone;
}, oA = function(e) {
  var r = e.name;
  return r === Dl.IOS;
}, lA = function(e) {
  var r = e.version;
  return Fn(r);
}, uA = function(e) {
  var r = e.name;
  return Fn(r);
}, dA = function(e) {
  var r = e.name;
  return r === Pi.Chrome;
}, gA = function(e) {
  var r = e.name;
  return r === Pi.Firefox;
}, cA = function(e) {
  var r = e.name;
  return r === Pi.Chromium;
}, Ag = function(e) {
  var r = e.name;
  return r === Pi.Edge;
}, mA = function(e) {
  var r = e.name;
  return r === Pi.Yandex;
}, fA = function(e) {
  var r = e.name;
  return r === Pi.Safari || r === Pi.MobileSafari;
}, hA = function(e) {
  var r = e.name;
  return r === Pi.MobileSafari;
}, pA = function(e) {
  var r = e.name;
  return r === Pi.Opera;
}, IA = function(e) {
  var r = e.name;
  return r === Pi.InternetExplorer || r === Pi.Ie;
}, CA = function(e) {
  var r = e.name;
  return r === Pi.MIUI;
}, yA = function(e) {
  var r = e.name;
  return r === Pi.SamsungBrowser;
}, AA = function(e) {
  var r = e.version;
  return Fn(r);
}, _A = function(e) {
  var r = e.major;
  return Fn(r);
}, bA = function(e) {
  var r = e.name;
  return Fn(r);
}, SA = function(e) {
  var r = e.name;
  return Fn(r);
}, wA = function(e) {
  var r = e.version;
  return Fn(r);
}, vA = function() {
  var e = Ff(), r = e && e.userAgent && e.userAgent.toLowerCase();
  return typeof r == "string" ? /electron/.test(r) : !1;
}, hl = function(e) {
  return typeof e == "string" && e.indexOf("Edg/") !== -1;
}, EA = function() {
  var e = Ff();
  return e && (/iPad|iPhone|iPod/.test(e.platform) || e.platform === "MacIntel" && e.maxTouchPoints > 1) && !window.MSStream;
}, Fr = function() {
  return Of("iPad");
}, TA = function() {
  return Of("iPhone");
}, kA = function() {
  return Of("iPod");
}, LA = function(e) {
  return Fn(e);
};
function MA(t) {
  var e = t || Xy, r = e.device, u = e.browser, I = e.os, E = e.engine, k = e.ua;
  return {
    isSmartTV: Jy(r),
    isConsole: qy(r),
    isWearable: Qy(r),
    isEmbedded: $y(r),
    isMobileSafari: hA(u) || Fr(),
    isChromium: cA(u),
    isMobile: Zy(r) || Fr(),
    isMobileOnly: Wy(r),
    isTablet: jy(r) || Fr(),
    isBrowser: yg(r),
    isDesktop: yg(r),
    isAndroid: aA(I),
    isWinPhone: sA(I),
    isIOS: oA(I) || Fr(),
    isChrome: dA(u),
    isFirefox: gA(u),
    isSafari: fA(u),
    isOpera: pA(u),
    isIE: IA(u),
    osVersion: lA(I),
    osName: uA(I),
    fullBrowserVersion: AA(u),
    browserVersion: _A(u),
    browserName: bA(u),
    mobileVendor: tA(r),
    mobileModel: eA(r),
    engineName: SA(E),
    engineVersion: wA(E),
    getUA: LA(k),
    isEdge: Ag(u) || hl(k),
    isYandex: mA(u),
    deviceType: nA(r),
    isIOS13: EA(),
    isIPad13: Fr(),
    isIPhone13: TA(),
    isIPod13: kA(),
    isElectron: vA(),
    isEdgeChromium: hl(k),
    isLegacyEdge: Ag(u) && !hl(k),
    isWindows: iA(I),
    isMacOs: rA(I),
    isMIUI: CA(u),
    isSamsungBrowser: yA(u)
  };
}
var RA = Jy($i), DA = qy($i), BA = Qy($i), Tv = $y($i), kv = hA(Ai) || Fr(), Lv = cA(Ai), Jg = Zy($i) || Fr(), xA = Wy($i), NA = jy($i) || Fr(), GA = yg($i), Mv = yg($i), zA = aA(Zs), YA = sA(Zs), HA = oA(Zs) || Fr(), Rv = dA(Ai), Dv = gA(Ai), Bv = fA(Ai), xv = pA(Ai), PA = IA(Ai), Nv = lA(Zs), Gv = uA(Zs), zv = AA(Ai), Yv = _A(Ai), Hv = bA(Ai), Pv = tA($i), Fv = eA($i), Ov = SA(Pf), Uv = wA(Pf), Kv = LA(qu), Vv = Ag(Ai) || hl(qu), Xv = mA(Ai), Wv = nA($i), jv = EA(), Zv = Fr(), Jv = TA(), Qv = kA(), qv = vA(), $v = hl(qu), tE = Ag(Ai) && !hl(qu), eE = iA(Zs), nE = rA(Zs), aE = CA(Ai), iE = yA(Ai), rE = function(e) {
  if (!e || typeof e != "string") {
    console.error("No valid user agent string was provided");
    return;
  }
  var r = $u(e), u = r.device, I = r.browser, E = r.os, k = r.engine, g = r.ua;
  return MA({
    device: u,
    browser: I,
    os: E,
    engine: k,
    ua: g
  });
}, sE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return zA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, oE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return GA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, lE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return PA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, uE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return HA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, dE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return Jg ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, gE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return NA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, cE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return YA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, mE = function(e) {
  var r = e.renderWithFragment, u = e.children;
  e.viewClassName, e.style;
  var I = Ir(e, ["renderWithFragment", "children", "viewClassName", "style"]);
  return xA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, fE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return RA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, hE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return DA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, pE = function(e) {
  var r = e.renderWithFragment, u = e.children, I = Ir(e, ["renderWithFragment", "children"]);
  return BA ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", I, u) : null;
}, IE = function(e) {
  var r = e.renderWithFragment, u = e.children;
  e.viewClassName, e.style;
  var I = e.condition, E = Ir(e, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
  return I ? r ? wa.createElement(Ci.Fragment, null, u) : wa.createElement("div", E, u) : null;
};
function CE(t) {
  return /* @__PURE__ */ function(e) {
    dv(r, e);
    function r(u) {
      var I;
      return sv(this, r), I = cv(this, Rm(r).call(this, u)), I.isEventListenerAdded = !1, I.handleOrientationChange = I.handleOrientationChange.bind(og(I)), I.onOrientationChange = I.onOrientationChange.bind(og(I)), I.onPageLoad = I.onPageLoad.bind(og(I)), I.state = {
        isLandscape: !1,
        isPortrait: !1
      }, I;
    }
    return lv(r, [{
      key: "handleOrientationChange",
      value: function() {
        this.isEventListenerAdded || (this.isEventListenerAdded = !0);
        var I = window.innerWidth > window.innerHeight ? 90 : 0;
        this.setState({
          isPortrait: I === 0,
          isLandscape: I === 90
        });
      }
    }, {
      key: "onOrientationChange",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "onPageLoad",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "componentDidMount",
      value: function() {
        (typeof window == "undefined" ? "undefined" : bu(window)) !== void 0 && Jg && (this.isEventListenerAdded ? window.removeEventListener("load", this.onPageLoad, !1) : (this.handleOrientationChange(), window.addEventListener("load", this.onPageLoad, !1)), window.addEventListener("resize", this.onOrientationChange, !1));
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        window.removeEventListener("resize", this.onOrientationChange, !1);
      }
    }, {
      key: "render",
      value: function() {
        return wa.createElement(t, Mm({}, this.props, {
          isLandscape: this.state.isLandscape,
          isPortrait: this.state.isPortrait
        }));
      }
    }]), r;
  }(wa.Component);
}
function yE() {
  var t = Ci.useState(function() {
    var E = window.innerWidth > window.innerHeight ? 90 : 0;
    return {
      isPortrait: E === 0,
      isLandscape: E === 90,
      orientation: E === 0 ? "portrait" : "landscape"
    };
  }), e = mv(t, 2), r = e[0], u = e[1], I = Ci.useCallback(function() {
    var E = window.innerWidth > window.innerHeight ? 90 : 0, k = {
      isPortrait: E === 0,
      isLandscape: E === 90,
      orientation: E === 0 ? "portrait" : "landscape"
    };
    r.orientation !== k.orientation && u(k);
  }, [r.orientation]);
  return Ci.useEffect(function() {
    return (typeof window == "undefined" ? "undefined" : bu(window)) !== void 0 && Jg && (I(), window.addEventListener("load", I, !1), window.addEventListener("resize", I, !1)), function() {
      window.removeEventListener("resize", I, !1), window.removeEventListener("load", I, !1);
    };
  }, [I]), r;
}
function FA(t) {
  var e = t || window.navigator.userAgent;
  return $u(e);
}
function AE(t) {
  var e = t || window.navigator.userAgent, r = FA(e), u = MA(r);
  return [u, r];
}
Mn.AndroidView = sE;
Mn.BrowserTypes = Pi;
Mn.BrowserView = oE;
Mn.ConsoleView = hE;
Mn.CustomView = IE;
Mn.IEView = lE;
Mn.IOSView = uE;
Mn.MobileOnlyView = mE;
Mn.MobileView = dE;
Mn.OsTypes = Dl;
Mn.SmartTVView = fE;
Mn.TabletView = gE;
Mn.WearableView = pE;
Mn.WinPhoneView = cE;
Mn.browserName = Hv;
Mn.browserVersion = Yv;
Mn.deviceDetect = Ev;
Mn.deviceType = Wv;
Mn.engineName = Ov;
Mn.engineVersion = Uv;
Mn.fullBrowserVersion = zv;
Mn.getSelectorsByUserAgent = rE;
Mn.getUA = Kv;
Mn.isAndroid = zA;
Mn.isBrowser = GA;
Mn.isChrome = Rv;
Mn.isChromium = Lv;
Mn.isConsole = DA;
var _E = Mn.isDesktop = Mv;
Mn.isEdge = Vv;
Mn.isEdgeChromium = $v;
Mn.isElectron = qv;
Mn.isEmbedded = Tv;
Mn.isFirefox = Dv;
Mn.isIE = PA;
var Uc = Mn.isIOS = HA;
Mn.isIOS13 = jv;
Mn.isIPad13 = Zv;
Mn.isIPhone13 = Jv;
Mn.isIPod13 = Qv;
Mn.isLegacyEdge = tE;
Mn.isMIUI = aE;
Mn.isMacOs = nE;
var _g = Mn.isMobile = Jg;
Mn.isMobileOnly = xA;
Mn.isMobileSafari = kv;
Mn.isOpera = xv;
var OA = Mn.isSafari = Bv;
Mn.isSamsungBrowser = iE;
Mn.isSmartTV = RA;
var bE = Mn.isTablet = NA;
Mn.isWearable = BA;
Mn.isWinPhone = YA;
Mn.isWindows = eE;
Mn.isYandex = Xv;
Mn.mobileModel = Fv;
Mn.mobileVendor = Pv;
Mn.osName = Gv;
Mn.osVersion = Nv;
Mn.parseUserAgent = $u;
Mn.setUserAgent = Av;
Mn.useDeviceData = FA;
Mn.useDeviceSelectors = AE;
Mn.useMobileOrientation = yE;
Mn.withOrientationChange = CE;
const lr = "Not implemented", Bm = 0, xm = 1, Nm = 2, lg = 3, Gm = 4, zm = 5, Ym = 6, bg = "initialized", SE = "error", wE = "updatestart", vE = "update", UI = "updateend", EE = "abort", TE = 2048, kE = 2048, LE = 2080, ME = 25, KI = 740, RE = 0.85, DE = 1, VI = 'mesh/fb;codecs="draco.514"', XI = 'mesh/mp4;codecs="draco.514"', BE = "image/jpeg", UA = "audio", ur = "video", ks = "mesh", WI = 4, Uf = 16, Or = 16, Sg = 4, pl = 10, xE = 1, NE = 4, GE = "manifestloading", zE = "manifestloaded", Kf = "qualitychange", KA = "frameratechange", YE = "destroy", HE = "keyreceived", PE = "immersive-vr", FE = "immersive-ar", OE = "A128CTR", UE = "decrypt", KE = "jwk", VE = "AES-CTR", pu = 1 << pl, jI = pu >> 1, XE = /* @__PURE__ */ new Map([
  [Bm, "SILLY"],
  [xm, "TRACE"],
  [Nm, "DEBUG"],
  [lg, "INFO "],
  [Gm, "WARN "],
  [zm, "ERROR"],
  [Ym, "FATAL"]
]);
class Qg {
  constructor(e = "Triangular", r = {}) {
    this.prettyLogTemplate = [], this.name = e;
    const { prettyLogTemplate: u } = this, I = lg;
    this.logLevel = I, u.push("{{logLevelName}}", "{{nameWithDelimiterSuffix}}"), u.unshift("{{dateIsoStr}}");
  }
  formatLog(e, ...r) {
    const { prettyLogTemplate: u, name: I } = this, E = (/* @__PURE__ */ new Date()).toISOString(), k = I ? `${I}:` : "", g = XE.get(e);
    let w = u.join(" ");
    return w = w.replace("{{logLevelName}}", g).replace("{{dateIsoStr}}", E).replace("{{nameWithDelimiterSuffix}}", k), [w, ...r];
  }
  setLogLevel(e) {
    this.logLevel = e;
  }
  silly(...e) {
    const { logLevel: r } = this;
    r > Bm || console.debug(...this.formatLog(Bm, ...e));
  }
  trace(...e) {
    const { logLevel: r } = this;
    r > xm || console.trace(...this.formatLog(xm, ...e));
  }
  debug(...e) {
    const { logLevel: r } = this;
    r > Nm || console.debug(...this.formatLog(Nm, ...e));
  }
  info(...e) {
    const { logLevel: r } = this;
    r > lg || console.info(...this.formatLog(lg, ...e));
  }
  warn(...e) {
    const { logLevel: r } = this;
    r > Gm || console.warn(...this.formatLog(Gm, ...e));
  }
  error(...e) {
    const { logLevel: r } = this;
    r > zm || console.error(...this.formatLog(zm, ...e));
  }
  fatal(...e) {
    const { logLevel: r } = this;
    r > Ym || console.error(...this.formatLog(Ym, "FATAL:", ...e));
  }
}
/**
 * filesize
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.1.6
 */
const WE = "array", jE = "bit", ZI = "bits", ZE = "byte", JI = "bytes", es = "", JE = "exponent", QE = "function", QI = "iec", qE = "Invalid number", $E = "Invalid rounding method", Kc = "jedec", tT = "object", qI = ".", VA = "round", eT = "s", nT = "si", aT = "kbit", iT = "kB", XA = " ", WA = "string", rT = "0", Vc = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function sT(t, {
  bits: e = !1,
  pad: r = !1,
  base: u = -1,
  round: I = 2,
  locale: E = es,
  localeOptions: k = {},
  separator: g = es,
  spacer: w = XA,
  symbols: B = {},
  standard: c = es,
  output: d = WA,
  fullform: m = !1,
  fullforms: b = [],
  exponent: y = -1,
  roundingMethod: T = VA,
  precision: n = 0
} = {}) {
  let o = y, l = Number(t), h = [], p = 0, z = es;
  c === nT ? (u = 10, c = Kc) : c === QI || c === Kc ? u = 2 : u === 2 ? c = QI : (u = 10, c = Kc);
  const Z = u === 10 ? 1e3 : 1024, V = m === !0, Q = l < 0, vt = Math[T];
  if (typeof t != "bigint" && isNaN(t))
    throw new TypeError(qE);
  if (typeof vt !== QE)
    throw new TypeError($E);
  if (Q && (l = -l), (o === -1 || isNaN(o)) && (o = Math.floor(Math.log(l) / Math.log(Z)), o < 0 && (o = 0)), o > 8 && (n > 0 && (n += 8 - o), o = 8), d === JE)
    return o;
  if (l === 0)
    h[0] = 0, z = h[1] = Vc.symbol[c][e ? ZI : JI][o];
  else {
    p = l / (u === 2 ? Math.pow(2, o * 10) : Math.pow(1e3, o)), e && (p = p * 8, p >= Z && o < 8 && (p = p / Z, o++));
    const Lt = Math.pow(10, o > 0 ? I : 0);
    h[0] = vt(p * Lt) / Lt, h[0] === Z && o < 8 && y === -1 && (h[0] = 1, o++), z = h[1] = u === 10 && o === 1 ? e ? aT : iT : Vc.symbol[c][e ? ZI : JI][o];
  }
  if (Q && (h[0] = -h[0]), n > 0 && (h[0] = h[0].toPrecision(n)), h[1] = B[h[1]] || h[1], E === !0 ? h[0] = h[0].toLocaleString() : E.length > 0 ? h[0] = h[0].toLocaleString(E, k) : g.length > 0 && (h[0] = h[0].toString().replace(qI, g)), r && I > 0) {
    const Lt = h[0].toString(), zt = g || (Lt.match(/(\D)/g) || []).pop() || qI, X = Lt.toString().split(zt), D = X[1] || es, yt = D.length, Mt = I - yt;
    h[0] = `${X[0]}${zt}${D.padEnd(yt + Mt, rT)}`;
  }
  return V && (h[1] = b[o] ? b[o] : Vc.fullform[c][o] + (e ? jE : ZE) + (h[0] === 1 ? es : eT)), d === WE ? h : d === tT ? {
    value: h[0],
    symbol: h[1],
    exponent: o,
    unit: z
  } : h.join(w);
}
function oT({
  bits: t = !1,
  pad: e = !1,
  base: r = -1,
  round: u = 2,
  locale: I = es,
  localeOptions: E = {},
  separator: k = es,
  spacer: g = XA,
  symbols: w = {},
  standard: B = es,
  output: c = WA,
  fullform: d = !1,
  fullforms: m = [],
  exponent: b = -1,
  roundingMethod: y = VA,
  precision: T = 0
} = {}) {
  return (n) => sT(n, {
    bits: t,
    pad: e,
    base: r,
    round: u,
    locale: I,
    localeOptions: E,
    separator: k,
    spacer: g,
    symbols: w,
    standard: B,
    output: c,
    fullform: d,
    fullforms: m,
    exponent: b,
    roundingMethod: y,
    precision: T
  });
}
const el = () => {
}, $r = {
  Android: function() {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function() {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function() {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Safari: function() {
    return $r.iOS();
  },
  PureSafari: function() {
    return $r.iOS() && navigator.userAgent.indexOf("CriOS") == -1 && navigator.userAgent.indexOf("FxiOS") == -1;
  },
  Opera: function() {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function() {
    return navigator.userAgent.match(/IEMobile/i);
  },
  mobile: function() {
    return $r.Android() || $r.BlackBerry() || $r.iOS() || $r.Opera() || $r.Windows();
  },
  notMobile: function() {
    return !$r.mobile();
  },
  eighthWall: function() {
    return window.XRExtras !== void 0;
  }
}, lT = () => !!document.createElement("canvas").getContext("webgl2"), $I = (t = 0) => new Promise((e) => setTimeout(e, t)), uT = oT({
  base: 10,
  locale: "en",
  symbols: { kB: "KB" }
}), Vf = (t) => {
  const e = t > 0 ? t / TE : 1, r = Or * pl, u = Math.ceil(Uf * e);
  return [e, r, u];
}, jA = "dmFyIExlID0gKGYsIHQpID0+ICgpID0+ICh0IHx8IGYoKHQgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIHQpLCB0LmV4cG9ydHMpOwp2YXIgUXQgPSAoZiwgdCwgZSkgPT4gbmV3IFByb21pc2UoKGksIHMpID0+IHsKICB2YXIgciA9IChvKSA9PiB7CiAgICB0cnkgewogICAgICBhKGUubmV4dChvKSk7CiAgICB9IGNhdGNoIChoKSB7CiAgICAgIHMoaCk7CiAgICB9CiAgfSwgbiA9IChvKSA9PiB7CiAgICB0cnkgewogICAgICBhKGUudGhyb3cobykpOwogICAgfSBjYXRjaCAoaCkgewogICAgICBzKGgpOwogICAgfQogIH0sIGEgPSAobykgPT4gby5kb25lID8gaShvLnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZShvLnZhbHVlKS50aGVuKHIsIG4pOwogIGEoKGUgPSBlLmFwcGx5KGYsIHQpKS5uZXh0KCkpOwp9KTsKdmFyIGNpID0gTGUoKHllKSA9PiB7CiAgLyoqCiAgICogQGxpY2Vuc2UKICAgKiBDb3B5cmlnaHQgMjAxMC0yMDI1IFRocmVlLmpzIEF1dGhvcnMKICAgKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlUCiAgICovCiAgY29uc3QgQmUgPSAiMTczIiwgUmUgPSAiIiwgWCA9ICJzcmdiIiwgR3QgPSAic3JnYi1saW5lYXIiLCBmZSA9ICJsaW5lYXIiLCBLdCA9ICJzcmdiIjsKICBjbGFzcyBjZSB7CiAgICBhZGRFdmVudExpc3RlbmVyKHQsIGUpIHsKICAgICAgdGhpcy5fbGlzdGVuZXJzID09PSB2b2lkIDAgJiYgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTsKICAgICAgY29uc3QgaSA9IHRoaXMuX2xpc3RlbmVyczsKICAgICAgaVt0XSA9PT0gdm9pZCAwICYmIChpW3RdID0gW10pLCBpW3RdLmluZGV4T2YoZSkgPT09IC0xICYmIGlbdF0ucHVzaChlKTsKICAgIH0KICAgIGhhc0V2ZW50TGlzdGVuZXIodCwgZSkgewogICAgICBjb25zdCBpID0gdGhpcy5fbGlzdGVuZXJzOwogICAgICByZXR1cm4gaSA9PT0gdm9pZCAwID8gITEgOiBpW3RdICE9PSB2b2lkIDAgJiYgaVt0XS5pbmRleE9mKGUpICE9PSAtMTsKICAgIH0KICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSkgewogICAgICBjb25zdCBpID0gdGhpcy5fbGlzdGVuZXJzOwogICAgICBpZiAoaSA9PT0gdm9pZCAwKSByZXR1cm47CiAgICAgIGNvbnN0IHMgPSBpW3RdOwogICAgICBpZiAocyAhPT0gdm9pZCAwKSB7CiAgICAgICAgY29uc3QgciA9IHMuaW5kZXhPZihlKTsKICAgICAgICByICE9PSAtMSAmJiBzLnNwbGljZShyLCAxKTsKICAgICAgfQogICAgfQogICAgZGlzcGF0Y2hFdmVudCh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLl9saXN0ZW5lcnM7CiAgICAgIGlmIChlID09PSB2b2lkIDApIHJldHVybjsKICAgICAgY29uc3QgaSA9IGVbdC50eXBlXTsKICAgICAgaWYgKGkgIT09IHZvaWQgMCkgewogICAgICAgIHQudGFyZ2V0ID0gdGhpczsKICAgICAgICBjb25zdCBzID0gaS5zbGljZSgwKTsKICAgICAgICBmb3IgKGxldCByID0gMCwgbiA9IHMubGVuZ3RoOyByIDwgbjsgcisrKQogICAgICAgICAgc1tyXS5jYWxsKHRoaXMsIHQpOwogICAgICAgIHQudGFyZ2V0ID0gbnVsbDsKICAgICAgfQogICAgfQogIH0KICBjb25zdCBOID0gWyIwMCIsICIwMSIsICIwMiIsICIwMyIsICIwNCIsICIwNSIsICIwNiIsICIwNyIsICIwOCIsICIwOSIsICIwYSIsICIwYiIsICIwYyIsICIwZCIsICIwZSIsICIwZiIsICIxMCIsICIxMSIsICIxMiIsICIxMyIsICIxNCIsICIxNSIsICIxNiIsICIxNyIsICIxOCIsICIxOSIsICIxYSIsICIxYiIsICIxYyIsICIxZCIsICIxZSIsICIxZiIsICIyMCIsICIyMSIsICIyMiIsICIyMyIsICIyNCIsICIyNSIsICIyNiIsICIyNyIsICIyOCIsICIyOSIsICIyYSIsICIyYiIsICIyYyIsICIyZCIsICIyZSIsICIyZiIsICIzMCIsICIzMSIsICIzMiIsICIzMyIsICIzNCIsICIzNSIsICIzNiIsICIzNyIsICIzOCIsICIzOSIsICIzYSIsICIzYiIsICIzYyIsICIzZCIsICIzZSIsICIzZiIsICI0MCIsICI0MSIsICI0MiIsICI0MyIsICI0NCIsICI0NSIsICI0NiIsICI0NyIsICI0OCIsICI0OSIsICI0YSIsICI0YiIsICI0YyIsICI0ZCIsICI0ZSIsICI0ZiIsICI1MCIsICI1MSIsICI1MiIsICI1MyIsICI1NCIsICI1NSIsICI1NiIsICI1NyIsICI1OCIsICI1OSIsICI1YSIsICI1YiIsICI1YyIsICI1ZCIsICI1ZSIsICI1ZiIsICI2MCIsICI2MSIsICI2MiIsICI2MyIsICI2NCIsICI2NSIsICI2NiIsICI2NyIsICI2OCIsICI2OSIsICI2YSIsICI2YiIsICI2YyIsICI2ZCIsICI2ZSIsICI2ZiIsICI3MCIsICI3MSIsICI3MiIsICI3MyIsICI3NCIsICI3NSIsICI3NiIsICI3NyIsICI3OCIsICI3OSIsICI3YSIsICI3YiIsICI3YyIsICI3ZCIsICI3ZSIsICI3ZiIsICI4MCIsICI4MSIsICI4MiIsICI4MyIsICI4NCIsICI4NSIsICI4NiIsICI4NyIsICI4OCIsICI4OSIsICI4YSIsICI4YiIsICI4YyIsICI4ZCIsICI4ZSIsICI4ZiIsICI5MCIsICI5MSIsICI5MiIsICI5MyIsICI5NCIsICI5NSIsICI5NiIsICI5NyIsICI5OCIsICI5OSIsICI5YSIsICI5YiIsICI5YyIsICI5ZCIsICI5ZSIsICI5ZiIsICJhMCIsICJhMSIsICJhMiIsICJhMyIsICJhNCIsICJhNSIsICJhNiIsICJhNyIsICJhOCIsICJhOSIsICJhYSIsICJhYiIsICJhYyIsICJhZCIsICJhZSIsICJhZiIsICJiMCIsICJiMSIsICJiMiIsICJiMyIsICJiNCIsICJiNSIsICJiNiIsICJiNyIsICJiOCIsICJiOSIsICJiYSIsICJiYiIsICJiYyIsICJiZCIsICJiZSIsICJiZiIsICJjMCIsICJjMSIsICJjMiIsICJjMyIsICJjNCIsICJjNSIsICJjNiIsICJjNyIsICJjOCIsICJjOSIsICJjYSIsICJjYiIsICJjYyIsICJjZCIsICJjZSIsICJjZiIsICJkMCIsICJkMSIsICJkMiIsICJkMyIsICJkNCIsICJkNSIsICJkNiIsICJkNyIsICJkOCIsICJkOSIsICJkYSIsICJkYiIsICJkYyIsICJkZCIsICJkZSIsICJkZiIsICJlMCIsICJlMSIsICJlMiIsICJlMyIsICJlNCIsICJlNSIsICJlNiIsICJlNyIsICJlOCIsICJlOSIsICJlYSIsICJlYiIsICJlYyIsICJlZCIsICJlZSIsICJlZiIsICJmMCIsICJmMSIsICJmMiIsICJmMyIsICJmNCIsICJmNSIsICJmNiIsICJmNyIsICJmOCIsICJmOSIsICJmYSIsICJmYiIsICJmYyIsICJmZCIsICJmZSIsICJmZiJdOwogIGZ1bmN0aW9uIFh0KCkgewogICAgY29uc3QgZiA9IE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1IHwgMCwgdCA9IE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1IHwgMCwgZSA9IE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1IHwgMCwgaSA9IE1hdGgucmFuZG9tKCkgKiA0Mjk0OTY3Mjk1IHwgMDsKICAgIHJldHVybiAoTltmICYgMjU1XSArIE5bZiA+PiA4ICYgMjU1XSArIE5bZiA+PiAxNiAmIDI1NV0gKyBOW2YgPj4gMjQgJiAyNTVdICsgIi0iICsgTlt0ICYgMjU1XSArIE5bdCA+PiA4ICYgMjU1XSArICItIiArIE5bdCA+PiAxNiAmIDE1IHwgNjRdICsgTlt0ID4+IDI0ICYgMjU1XSArICItIiArIE5bZSAmIDYzIHwgMTI4XSArIE5bZSA+PiA4ICYgMjU1XSArICItIiArIE5bZSA+PiAxNiAmIDI1NV0gKyBOW2UgPj4gMjQgJiAyNTVdICsgTltpICYgMjU1XSArIE5baSA+PiA4ICYgMjU1XSArIE5baSA+PiAxNiAmIDI1NV0gKyBOW2kgPj4gMjQgJiAyNTVdKS50b0xvd2VyQ2FzZSgpOwogIH0KICBmdW5jdGlvbiBUKGYsIHQsIGUpIHsKICAgIHJldHVybiBNYXRoLm1heCh0LCBNYXRoLm1pbihlLCBmKSk7CiAgfQogIGZ1bmN0aW9uIFBlKGYsIHQpIHsKICAgIHJldHVybiAoZiAlIHQgKyB0KSAlIHQ7CiAgfQogIGZ1bmN0aW9uIHRlKGYsIHQsIGUpIHsKICAgIHJldHVybiAoMSAtIGUpICogZiArIGUgKiB0OwogIH0KICBmdW5jdGlvbiBDdChmLCB0KSB7CiAgICBzd2l0Y2ggKHQuY29uc3RydWN0b3IpIHsKICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6CiAgICAgICAgcmV0dXJuIGY7CiAgICAgIGNhc2UgVWludDMyQXJyYXk6CiAgICAgICAgcmV0dXJuIGYgLyA0Mjk0OTY3Mjk1OwogICAgICBjYXNlIFVpbnQxNkFycmF5OgogICAgICAgIHJldHVybiBmIC8gNjU1MzU7CiAgICAgIGNhc2UgVWludDhBcnJheToKICAgICAgICByZXR1cm4gZiAvIDI1NTsKICAgICAgY2FzZSBJbnQzMkFycmF5OgogICAgICAgIHJldHVybiBNYXRoLm1heChmIC8gMjE0NzQ4MzY0NywgLTEpOwogICAgICBjYXNlIEludDE2QXJyYXk6CiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGYgLyAzMjc2NywgLTEpOwogICAgICBjYXNlIEludDhBcnJheToKICAgICAgICByZXR1cm4gTWF0aC5tYXgoZiAvIDEyNywgLTEpOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gdihmLCB0KSB7CiAgICBzd2l0Y2ggKHQuY29uc3RydWN0b3IpIHsKICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6CiAgICAgICAgcmV0dXJuIGY7CiAgICAgIGNhc2UgVWludDMyQXJyYXk6CiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZiAqIDQyOTQ5NjcyOTUpOwogICAgICBjYXNlIFVpbnQxNkFycmF5OgogICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGYgKiA2NTUzNSk7CiAgICAgIGNhc2UgVWludDhBcnJheToKICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChmICogMjU1KTsKICAgICAgY2FzZSBJbnQzMkFycmF5OgogICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGYgKiAyMTQ3NDgzNjQ3KTsKICAgICAgY2FzZSBJbnQxNkFycmF5OgogICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGYgKiAzMjc2Nyk7CiAgICAgIGNhc2UgSW50OEFycmF5OgogICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGYgKiAxMjcpOwogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb21wb25lbnQgdHlwZS4iKTsKICAgIH0KICB9CiAgY2xhc3MgcnQgewogICAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwKSB7CiAgICAgIHJ0LnByb3RvdHlwZS5pc1ZlY3RvcjIgPSAhMCwgdGhpcy54ID0gdCwgdGhpcy55ID0gZTsKICAgIH0KICAgIGdldCB3aWR0aCgpIHsKICAgICAgcmV0dXJuIHRoaXMueDsKICAgIH0KICAgIHNldCB3aWR0aCh0KSB7CiAgICAgIHRoaXMueCA9IHQ7CiAgICB9CiAgICBnZXQgaGVpZ2h0KCkgewogICAgICByZXR1cm4gdGhpcy55OwogICAgfQogICAgc2V0IGhlaWdodCh0KSB7CiAgICAgIHRoaXMueSA9IHQ7CiAgICB9CiAgICBzZXQodCwgZSkgewogICAgICByZXR1cm4gdGhpcy54ID0gdCwgdGhpcy55ID0gZSwgdGhpczsKICAgIH0KICAgIHNldFNjYWxhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSB0LCB0aGlzOwogICAgfQogICAgc2V0WCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzOwogICAgfQogICAgc2V0WSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnkgPSB0LCB0aGlzOwogICAgfQogICAgc2V0Q29tcG9uZW50KHQsIGUpIHsKICAgICAgc3dpdGNoICh0KSB7CiAgICAgICAgY2FzZSAwOgogICAgICAgICAgdGhpcy54ID0gZTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgMToKICAgICAgICAgIHRoaXMueSA9IGU7CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgICAgfQogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIGdldENvbXBvbmVudCh0KSB7CiAgICAgIHN3aXRjaCAodCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIHJldHVybiB0aGlzLng7CiAgICAgICAgY2FzZSAxOgogICAgICAgICAgcmV0dXJuIHRoaXMueTsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgICAgfQogICAgfQogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSk7CiAgICB9CiAgICBjb3B5KHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IHQueCwgdGhpcy55ID0gdC55LCB0aGlzOwogICAgfQogICAgYWRkKHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCArPSB0LngsIHRoaXMueSArPSB0LnksIHRoaXM7CiAgICB9CiAgICBhZGRTY2FsYXIodCkgewogICAgICByZXR1cm4gdGhpcy54ICs9IHQsIHRoaXMueSArPSB0LCB0aGlzOwogICAgfQogICAgYWRkVmVjdG9ycyh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LnggKyBlLngsIHRoaXMueSA9IHQueSArIGUueSwgdGhpczsKICAgIH0KICAgIGFkZFNjYWxlZFZlY3Rvcih0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggKz0gdC54ICogZSwgdGhpcy55ICs9IHQueSAqIGUsIHRoaXM7CiAgICB9CiAgICBzdWIodCkgewogICAgICByZXR1cm4gdGhpcy54IC09IHQueCwgdGhpcy55IC09IHQueSwgdGhpczsKICAgIH0KICAgIHN1YlNjYWxhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggLT0gdCwgdGhpcy55IC09IHQsIHRoaXM7CiAgICB9CiAgICBzdWJWZWN0b3JzKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IHQueCAtIGUueCwgdGhpcy55ID0gdC55IC0gZS55LCB0aGlzOwogICAgfQogICAgbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy54ICo9IHQueCwgdGhpcy55ICo9IHQueSwgdGhpczsKICAgIH0KICAgIG11bHRpcGx5U2NhbGFyKHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCAqPSB0LCB0aGlzLnkgKj0gdCwgdGhpczsKICAgIH0KICAgIGRpdmlkZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnggLz0gdC54LCB0aGlzLnkgLz0gdC55LCB0aGlzOwogICAgfQogICAgZGl2aWRlU2NhbGFyKHQpIHsKICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoMSAvIHQpOwogICAgfQogICAgYXBwbHlNYXRyaXgzKHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMueCwgaSA9IHRoaXMueSwgcyA9IHQuZWxlbWVudHM7CiAgICAgIHJldHVybiB0aGlzLnggPSBzWzBdICogZSArIHNbM10gKiBpICsgc1s2XSwgdGhpcy55ID0gc1sxXSAqIGUgKyBzWzRdICogaSArIHNbN10sIHRoaXM7CiAgICB9CiAgICBtaW4odCkgewogICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5taW4odGhpcy54LCB0LngpLCB0aGlzLnkgPSBNYXRoLm1pbih0aGlzLnksIHQueSksIHRoaXM7CiAgICB9CiAgICBtYXgodCkgewogICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5tYXgodGhpcy54LCB0LngpLCB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnksIHQueSksIHRoaXM7CiAgICB9CiAgICBjbGFtcCh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSBUKHRoaXMueCwgdC54LCBlLngpLCB0aGlzLnkgPSBUKHRoaXMueSwgdC55LCBlLnkpLCB0aGlzOwogICAgfQogICAgY2xhbXBTY2FsYXIodCwgZSkgewogICAgICByZXR1cm4gdGhpcy54ID0gVCh0aGlzLngsIHQsIGUpLCB0aGlzLnkgPSBUKHRoaXMueSwgdCwgZSksIHRoaXM7CiAgICB9CiAgICBjbGFtcExlbmd0aCh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSB0aGlzLmxlbmd0aCgpOwogICAgICByZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoaSB8fCAxKS5tdWx0aXBseVNjYWxhcihUKGksIHQsIGUpKTsKICAgIH0KICAgIGZsb29yKCkgewogICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5mbG9vcih0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSksIHRoaXM7CiAgICB9CiAgICBjZWlsKCkgewogICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC5jZWlsKHRoaXMueCksIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpLCB0aGlzOwogICAgfQogICAgcm91bmQoKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCksIHRoaXMueSA9IE1hdGgucm91bmQodGhpcy55KSwgdGhpczsKICAgIH0KICAgIHJvdW5kVG9aZXJvKCkgewogICAgICByZXR1cm4gdGhpcy54ID0gTWF0aC50cnVuYyh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLnRydW5jKHRoaXMueSksIHRoaXM7CiAgICB9CiAgICBuZWdhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSAtdGhpcy54LCB0aGlzLnkgPSAtdGhpcy55LCB0aGlzOwogICAgfQogICAgZG90KHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCAqIHQueCArIHRoaXMueSAqIHQueTsKICAgIH0KICAgIGNyb3NzKHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCAqIHQueSAtIHRoaXMueSAqIHQueDsKICAgIH0KICAgIGxlbmd0aFNxKCkgewogICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55OwogICAgfQogICAgbGVuZ3RoKCkgewogICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7CiAgICB9CiAgICBtYW5oYXR0YW5MZW5ndGgoKSB7CiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KTsKICAgIH0KICAgIG5vcm1hbGl6ZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkgfHwgMSk7CiAgICB9CiAgICBhbmdsZSgpIHsKICAgICAgcmV0dXJuIE1hdGguYXRhbjIoLXRoaXMueSwgLXRoaXMueCkgKyBNYXRoLlBJOwogICAgfQogICAgYW5nbGVUbyh0KSB7CiAgICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogdC5sZW5ndGhTcSgpKTsKICAgICAgaWYgKGUgPT09IDApIHJldHVybiBNYXRoLlBJIC8gMjsKICAgICAgY29uc3QgaSA9IHRoaXMuZG90KHQpIC8gZTsKICAgICAgcmV0dXJuIE1hdGguYWNvcyhUKGksIC0xLCAxKSk7CiAgICB9CiAgICBkaXN0YW5jZVRvKHQpIHsKICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQpKTsKICAgIH0KICAgIGRpc3RhbmNlVG9TcXVhcmVkKHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMueCAtIHQueCwgaSA9IHRoaXMueSAtIHQueTsKICAgICAgcmV0dXJuIGUgKiBlICsgaSAqIGk7CiAgICB9CiAgICBtYW5oYXR0YW5EaXN0YW5jZVRvKHQpIHsKICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHQueCkgKyBNYXRoLmFicyh0aGlzLnkgLSB0LnkpOwogICAgfQogICAgc2V0TGVuZ3RoKHQpIHsKICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCk7CiAgICB9CiAgICBsZXJwKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMueCArPSAodC54IC0gdGhpcy54KSAqIGUsIHRoaXMueSArPSAodC55IC0gdGhpcy55KSAqIGUsIHRoaXM7CiAgICB9CiAgICBsZXJwVmVjdG9ycyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LnggKyAoZS54IC0gdC54KSAqIGksIHRoaXMueSA9IHQueSArIChlLnkgLSB0LnkpICogaSwgdGhpczsKICAgIH0KICAgIGVxdWFscyh0KSB7CiAgICAgIHJldHVybiB0LnggPT09IHRoaXMueCAmJiB0LnkgPT09IHRoaXMueTsKICAgIH0KICAgIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgICByZXR1cm4gdGhpcy54ID0gdFtlXSwgdGhpcy55ID0gdFtlICsgMV0sIHRoaXM7CiAgICB9CiAgICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRbZV0gPSB0aGlzLngsIHRbZSArIDFdID0gdGhpcy55LCB0OwogICAgfQogICAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LmdldFgoZSksIHRoaXMueSA9IHQuZ2V0WShlKSwgdGhpczsKICAgIH0KICAgIHJvdGF0ZUFyb3VuZCh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSBNYXRoLmNvcyhlKSwgcyA9IE1hdGguc2luKGUpLCByID0gdGhpcy54IC0gdC54LCBuID0gdGhpcy55IC0gdC55OwogICAgICByZXR1cm4gdGhpcy54ID0gciAqIGkgLSBuICogcyArIHQueCwgdGhpcy55ID0gciAqIHMgKyBuICogaSArIHQueSwgdGhpczsKICAgIH0KICAgIHJhbmRvbSgpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucmFuZG9tKCksIHRoaXMueSA9IE1hdGgucmFuZG9tKCksIHRoaXM7CiAgICB9CiAgICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7CiAgICAgIHlpZWxkIHRoaXMueCwgeWllbGQgdGhpcy55OwogICAgfQogIH0KICBjbGFzcyBkdCB7CiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBpLCBzLCByLCBuLCBhLCBvLCBoKSB7CiAgICAgIGR0LnByb3RvdHlwZS5pc01hdHJpeDMgPSAhMCwgdGhpcy5lbGVtZW50cyA9IFsKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICBdLCB0ICE9PSB2b2lkIDAgJiYgdGhpcy5zZXQodCwgZSwgaSwgcywgciwgbiwgYSwgbywgaCk7CiAgICB9CiAgICBzZXQodCwgZSwgaSwgcywgciwgbiwgYSwgbywgaCkgewogICAgICBjb25zdCB1ID0gdGhpcy5lbGVtZW50czsKICAgICAgcmV0dXJuIHVbMF0gPSB0LCB1WzFdID0gcywgdVsyXSA9IGEsIHVbM10gPSBlLCB1WzRdID0gciwgdVs1XSA9IG8sIHVbNl0gPSBpLCB1WzddID0gbiwgdVs4XSA9IGgsIHRoaXM7CiAgICB9CiAgICBpZGVudGl0eSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICAgIDEsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICksIHRoaXM7CiAgICB9CiAgICBjb3B5KHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHMsIGkgPSB0LmVsZW1lbnRzOwogICAgICByZXR1cm4gZVswXSA9IGlbMF0sIGVbMV0gPSBpWzFdLCBlWzJdID0gaVsyXSwgZVszXSA9IGlbM10sIGVbNF0gPSBpWzRdLCBlWzVdID0gaVs1XSwgZVs2XSA9IGlbNl0sIGVbN10gPSBpWzddLCBlWzhdID0gaVs4XSwgdGhpczsKICAgIH0KICAgIGV4dHJhY3RCYXNpcyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0LnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDApLCBlLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDEpLCBpLnNldEZyb21NYXRyaXgzQ29sdW1uKHRoaXMsIDIpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbU1hdHJpeDQodCkgewogICAgICBjb25zdCBlID0gdC5lbGVtZW50czsKICAgICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICAgIGVbMF0sCiAgICAgICAgZVs0XSwKICAgICAgICBlWzhdLAogICAgICAgIGVbMV0sCiAgICAgICAgZVs1XSwKICAgICAgICBlWzldLAogICAgICAgIGVbMl0sCiAgICAgICAgZVs2XSwKICAgICAgICBlWzEwXQogICAgICApLCB0aGlzOwogICAgfQogICAgbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIHQpOwogICAgfQogICAgcHJlbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsIHRoaXMpOwogICAgfQogICAgbXVsdGlwbHlNYXRyaWNlcyh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSB0LmVsZW1lbnRzLCBzID0gZS5lbGVtZW50cywgciA9IHRoaXMuZWxlbWVudHMsIG4gPSBpWzBdLCBhID0gaVszXSwgbyA9IGlbNl0sIGggPSBpWzFdLCB1ID0gaVs0XSwgbCA9IGlbN10sIGQgPSBpWzJdLCBjID0gaVs1XSwgbSA9IGlbOF0sIHkgPSBzWzBdLCB4ID0gc1szXSwgcCA9IHNbNl0sIHogPSBzWzFdLCBGID0gc1s0XSwgQSA9IHNbN10sIGIgPSBzWzJdLCBNID0gc1s1XSwgXyA9IHNbOF07CiAgICAgIHJldHVybiByWzBdID0gbiAqIHkgKyBhICogeiArIG8gKiBiLCByWzNdID0gbiAqIHggKyBhICogRiArIG8gKiBNLCByWzZdID0gbiAqIHAgKyBhICogQSArIG8gKiBfLCByWzFdID0gaCAqIHkgKyB1ICogeiArIGwgKiBiLCByWzRdID0gaCAqIHggKyB1ICogRiArIGwgKiBNLCByWzddID0gaCAqIHAgKyB1ICogQSArIGwgKiBfLCByWzJdID0gZCAqIHkgKyBjICogeiArIG0gKiBiLCByWzVdID0gZCAqIHggKyBjICogRiArIG0gKiBNLCByWzhdID0gZCAqIHAgKyBjICogQSArIG0gKiBfLCB0aGlzOwogICAgfQogICAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgcmV0dXJuIGVbMF0gKj0gdCwgZVszXSAqPSB0LCBlWzZdICo9IHQsIGVbMV0gKj0gdCwgZVs0XSAqPSB0LCBlWzddICo9IHQsIGVbMl0gKj0gdCwgZVs1XSAqPSB0LCBlWzhdICo9IHQsIHRoaXM7CiAgICB9CiAgICBkZXRlcm1pbmFudCgpIHsKICAgICAgY29uc3QgdCA9IHRoaXMuZWxlbWVudHMsIGUgPSB0WzBdLCBpID0gdFsxXSwgcyA9IHRbMl0sIHIgPSB0WzNdLCBuID0gdFs0XSwgYSA9IHRbNV0sIG8gPSB0WzZdLCBoID0gdFs3XSwgdSA9IHRbOF07CiAgICAgIHJldHVybiBlICogbiAqIHUgLSBlICogYSAqIGggLSBpICogciAqIHUgKyBpICogYSAqIG8gKyBzICogciAqIGggLSBzICogbiAqIG87CiAgICB9CiAgICBpbnZlcnQoKSB7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLCBlID0gdFswXSwgaSA9IHRbMV0sIHMgPSB0WzJdLCByID0gdFszXSwgbiA9IHRbNF0sIGEgPSB0WzVdLCBvID0gdFs2XSwgaCA9IHRbN10sIHUgPSB0WzhdLCBsID0gdSAqIG4gLSBhICogaCwgZCA9IGEgKiBvIC0gdSAqIHIsIGMgPSBoICogciAtIG4gKiBvLCBtID0gZSAqIGwgKyBpICogZCArIHMgKiBjOwogICAgICBpZiAobSA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApOwogICAgICBjb25zdCB5ID0gMSAvIG07CiAgICAgIHJldHVybiB0WzBdID0gbCAqIHksIHRbMV0gPSAocyAqIGggLSB1ICogaSkgKiB5LCB0WzJdID0gKGEgKiBpIC0gcyAqIG4pICogeSwgdFszXSA9IGQgKiB5LCB0WzRdID0gKHUgKiBlIC0gcyAqIG8pICogeSwgdFs1XSA9IChzICogciAtIGEgKiBlKSAqIHksIHRbNl0gPSBjICogeSwgdFs3XSA9IChpICogbyAtIGggKiBlKSAqIHksIHRbOF0gPSAobiAqIGUgLSBpICogcikgKiB5LCB0aGlzOwogICAgfQogICAgdHJhbnNwb3NlKCkgewogICAgICBsZXQgdDsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIHJldHVybiB0ID0gZVsxXSwgZVsxXSA9IGVbM10sIGVbM10gPSB0LCB0ID0gZVsyXSwgZVsyXSA9IGVbNl0sIGVbNl0gPSB0LCB0ID0gZVs1XSwgZVs1XSA9IGVbN10sIGVbN10gPSB0LCB0aGlzOwogICAgfQogICAgZ2V0Tm9ybWFsTWF0cml4KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQodCkuaW52ZXJ0KCkudHJhbnNwb3NlKCk7CiAgICB9CiAgICB0cmFuc3Bvc2VJbnRvQXJyYXkodCkgewogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgcmV0dXJuIHRbMF0gPSBlWzBdLCB0WzFdID0gZVszXSwgdFsyXSA9IGVbNl0sIHRbM10gPSBlWzFdLCB0WzRdID0gZVs0XSwgdFs1XSA9IGVbN10sIHRbNl0gPSBlWzJdLCB0WzddID0gZVs1XSwgdFs4XSA9IGVbOF0sIHRoaXM7CiAgICB9CiAgICBzZXRVdlRyYW5zZm9ybSh0LCBlLCBpLCBzLCByLCBuLCBhKSB7CiAgICAgIGNvbnN0IG8gPSBNYXRoLmNvcyhyKSwgaCA9IE1hdGguc2luKHIpOwogICAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgICAgaSAqIG8sCiAgICAgICAgaSAqIGgsCiAgICAgICAgLWkgKiAobyAqIG4gKyBoICogYSkgKyBuICsgdCwKICAgICAgICAtcyAqIGgsCiAgICAgICAgcyAqIG8sCiAgICAgICAgLXMgKiAoLWggKiBuICsgbyAqIGEpICsgYSArIGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKSwgdGhpczsKICAgIH0KICAgIC8vCiAgICBzY2FsZSh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5KGVlLm1ha2VTY2FsZSh0LCBlKSksIHRoaXM7CiAgICB9CiAgICByb3RhdGUodCkgewogICAgICByZXR1cm4gdGhpcy5wcmVtdWx0aXBseShlZS5tYWtlUm90YXRpb24oLXQpKSwgdGhpczsKICAgIH0KICAgIHRyYW5zbGF0ZSh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnByZW11bHRpcGx5KGVlLm1ha2VUcmFuc2xhdGlvbih0LCBlKSksIHRoaXM7CiAgICB9CiAgICAvLyBmb3IgMkQgVHJhbnNmb3JtcwogICAgbWFrZVRyYW5zbGF0aW9uKHQsIGUpIHsKICAgICAgcmV0dXJuIHQuaXNWZWN0b3IyID8gdGhpcy5zZXQoCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIHQueCwKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgdC55LAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICkgOiB0aGlzLnNldCgKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgdCwKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgZSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApLCB0aGlzOwogICAgfQogICAgbWFrZVJvdGF0aW9uKHQpIHsKICAgICAgY29uc3QgZSA9IE1hdGguY29zKHQpLCBpID0gTWF0aC5zaW4odCk7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICBlLAogICAgICAgIC1pLAogICAgICAgIDAsCiAgICAgICAgaSwKICAgICAgICBlLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKSwgdGhpczsKICAgIH0KICAgIG1ha2VTY2FsZSh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICB0LAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApLCB0aGlzOwogICAgfQogICAgLy8KICAgIGVxdWFscyh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBpID0gdC5lbGVtZW50czsKICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCA5OyBzKyspCiAgICAgICAgaWYgKGVbc10gIT09IGlbc10pIHJldHVybiAhMTsKICAgICAgcmV0dXJuICEwOwogICAgfQogICAgZnJvbUFycmF5KHQsIGUgPSAwKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKQogICAgICAgIHRoaXMuZWxlbWVudHNbaV0gPSB0W2kgKyBlXTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgICAgY29uc3QgaSA9IHRoaXMuZWxlbWVudHM7CiAgICAgIHJldHVybiB0W2VdID0gaVswXSwgdFtlICsgMV0gPSBpWzFdLCB0W2UgKyAyXSA9IGlbMl0sIHRbZSArIDNdID0gaVszXSwgdFtlICsgNF0gPSBpWzRdLCB0W2UgKyA1XSA9IGlbNV0sIHRbZSArIDZdID0gaVs2XSwgdFtlICsgN10gPSBpWzddLCB0W2UgKyA4XSA9IGlbOF0sIHQ7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpOwogICAgfQogIH0KICBjb25zdCBlZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZHQoKTsKICBmdW5jdGlvbiBVZShmKSB7CiAgICBmb3IgKGxldCB0ID0gZi5sZW5ndGggLSAxOyB0ID49IDA7IC0tdCkKICAgICAgaWYgKGZbdF0gPj0gNjU1MzUpIHJldHVybiAhMDsKICAgIHJldHVybiAhMTsKICB9CiAgZnVuY3Rpb24gcGUoZikgewogICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCIsIGYpOwogIH0KICBjb25zdCB4ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZHQoKS5zZXQoCiAgICAwLjQxMjM5MDgsCiAgICAwLjM1NzU4NDMsCiAgICAwLjE4MDQ4MDgsCiAgICAwLjIxMjYzOSwKICAgIDAuNzE1MTY4NywKICAgIDAuMDcyMTkyMywKICAgIDAuMDE5MzMwOCwKICAgIDAuMTE5MTk0OCwKICAgIDAuOTUwNTMyMgogICksIGdlID0gLyogQF9fUFVSRV9fICovIG5ldyBkdCgpLnNldCgKICAgIDMuMjQwOTY5OSwKICAgIC0xLjUzNzM4MzIsCiAgICAtMC40OTg2MTA4LAogICAgLTAuOTY5MjQzNiwKICAgIDEuODc1OTY3NSwKICAgIDAuMDQxNTU1MSwKICAgIDAuMDU1NjMwMSwKICAgIC0wLjIwMzk3NywKICAgIDEuMDU2OTcxNQogICk7CiAgZnVuY3Rpb24gTmUoKSB7CiAgICBjb25zdCBmID0gewogICAgICBlbmFibGVkOiAhMCwKICAgICAgd29ya2luZ0NvbG9yU3BhY2U6IEd0LAogICAgICAvKioKICAgICAgICogSW1wbGVtZW50YXRpb25zIG9mIHN1cHBvcnRlZCBjb2xvciBzcGFjZXMuCiAgICAgICAqCiAgICAgICAqIFJlcXVpcmVkOgogICAgICAgKgktIHByaW1hcmllczogY2hyb21hdGljaXR5IGNvb3JkaW5hdGVzIFsgcnggcnkgZ3ggZ3kgYnggYnkgXQogICAgICAgKgktIHdoaXRlUG9pbnQ6IHJlZmVyZW5jZSB3aGl0ZSBbIHggeSBdCiAgICAgICAqCS0gdHJhbnNmZXI6IHRyYW5zZmVyIGZ1bmN0aW9uIChwcmUtZGVmaW5lZCkKICAgICAgICoJLSB0b1hZWjogTWF0cml4MyBSR0IgdG8gWFlaIHRyYW5zZm9ybQogICAgICAgKgktIGZyb21YWVo6IE1hdHJpeDMgWFlaIHRvIFJHQiB0cmFuc2Zvcm0KICAgICAgICoJLSBsdW1pbmFuY2VDb2VmZmljaWVudHM6IFJHQiBsdW1pbmFuY2UgY29lZmZpY2llbnRzCiAgICAgICAqCiAgICAgICAqIE9wdGlvbmFsOgogICAgICAgKiAgLSBvdXRwdXRDb2xvclNwYWNlQ29uZmlnOiB7IGRyYXdpbmdCdWZmZXJDb2xvclNwYWNlOiBDb2xvclNwYWNlIH0KICAgICAgICogIC0gd29ya2luZ0NvbG9yU3BhY2VDb25maWc6IHsgdW5wYWNrQ29sb3JTcGFjZTogQ29sb3JTcGFjZSB9CiAgICAgICAqCiAgICAgICAqIFJlZmVyZW5jZToKICAgICAgICogLSBodHRwczovL3d3dy5ydXNzZWxsY290dHJlbGwuY29tL3Bob3RvL21hdHJpeENhbGN1bGF0b3IuaHRtCiAgICAgICAqLwogICAgICBzcGFjZXM6IHt9LAogICAgICBjb252ZXJ0OiBmdW5jdGlvbihzLCByLCBuKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZCA9PT0gITEgfHwgciA9PT0gbiB8fCAhciB8fCAhbiB8fCAodGhpcy5zcGFjZXNbcl0udHJhbnNmZXIgPT09IEt0ICYmIChzLnIgPSBudChzLnIpLCBzLmcgPSBudChzLmcpLCBzLmIgPSBudChzLmIpKSwgdGhpcy5zcGFjZXNbcl0ucHJpbWFyaWVzICE9PSB0aGlzLnNwYWNlc1tuXS5wcmltYXJpZXMgJiYgKHMuYXBwbHlNYXRyaXgzKHRoaXMuc3BhY2VzW3JdLnRvWFlaKSwgcy5hcHBseU1hdHJpeDModGhpcy5zcGFjZXNbbl0uZnJvbVhZWikpLCB0aGlzLnNwYWNlc1tuXS50cmFuc2ZlciA9PT0gS3QgJiYgKHMuciA9IFN0KHMuciksIHMuZyA9IFN0KHMuZyksIHMuYiA9IFN0KHMuYikpKSwgczsKICAgICAgfSwKICAgICAgZnJvbVdvcmtpbmdDb2xvclNwYWNlOiBmdW5jdGlvbihzLCByKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuY29udmVydChzLCB0aGlzLndvcmtpbmdDb2xvclNwYWNlLCByKTsKICAgICAgfSwKICAgICAgdG9Xb3JraW5nQ29sb3JTcGFjZTogZnVuY3Rpb24ocywgcikgewogICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnQocywgciwgdGhpcy53b3JraW5nQ29sb3JTcGFjZSk7CiAgICAgIH0sCiAgICAgIGdldFByaW1hcmllczogZnVuY3Rpb24ocykgewogICAgICAgIHJldHVybiB0aGlzLnNwYWNlc1tzXS5wcmltYXJpZXM7CiAgICAgIH0sCiAgICAgIGdldFRyYW5zZmVyOiBmdW5jdGlvbihzKSB7CiAgICAgICAgcmV0dXJuIHMgPT09IFJlID8gZmUgOiB0aGlzLnNwYWNlc1tzXS50cmFuc2ZlcjsKICAgICAgfSwKICAgICAgZ2V0THVtaW5hbmNlQ29lZmZpY2llbnRzOiBmdW5jdGlvbihzLCByID0gdGhpcy53b3JraW5nQ29sb3JTcGFjZSkgewogICAgICAgIHJldHVybiBzLmZyb21BcnJheSh0aGlzLnNwYWNlc1tyXS5sdW1pbmFuY2VDb2VmZmljaWVudHMpOwogICAgICB9LAogICAgICBkZWZpbmU6IGZ1bmN0aW9uKHMpIHsKICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuc3BhY2VzLCBzKTsKICAgICAgfSwKICAgICAgLy8gSW50ZXJuYWwgQVBJcwogICAgICBfZ2V0TWF0cml4OiBmdW5jdGlvbihzLCByLCBuKSB7CiAgICAgICAgcmV0dXJuIHMuY29weSh0aGlzLnNwYWNlc1tyXS50b1hZWikubXVsdGlwbHkodGhpcy5zcGFjZXNbbl0uZnJvbVhZWik7CiAgICAgIH0sCiAgICAgIF9nZXREcmF3aW5nQnVmZmVyQ29sb3JTcGFjZTogZnVuY3Rpb24ocykgewogICAgICAgIHJldHVybiB0aGlzLnNwYWNlc1tzXS5vdXRwdXRDb2xvclNwYWNlQ29uZmlnLmRyYXdpbmdCdWZmZXJDb2xvclNwYWNlOwogICAgICB9LAogICAgICBfZ2V0VW5wYWNrQ29sb3JTcGFjZTogZnVuY3Rpb24ocyA9IHRoaXMud29ya2luZ0NvbG9yU3BhY2UpIHsKICAgICAgICByZXR1cm4gdGhpcy5zcGFjZXNbc10ud29ya2luZ0NvbG9yU3BhY2VDb25maWcudW5wYWNrQ29sb3JTcGFjZTsKICAgICAgfQogICAgfSwgdCA9IFswLjY0LCAwLjMzLCAwLjMsIDAuNiwgMC4xNSwgMC4wNl0sIGUgPSBbMC4yMTI2LCAwLjcxNTIsIDAuMDcyMl0sIGkgPSBbMC4zMTI3LCAwLjMyOV07CiAgICByZXR1cm4gZi5kZWZpbmUoewogICAgICBbR3RdOiB7CiAgICAgICAgcHJpbWFyaWVzOiB0LAogICAgICAgIHdoaXRlUG9pbnQ6IGksCiAgICAgICAgdHJhbnNmZXI6IGZlLAogICAgICAgIHRvWFlaOiB4ZSwKICAgICAgICBmcm9tWFlaOiBnZSwKICAgICAgICBsdW1pbmFuY2VDb2VmZmljaWVudHM6IGUsCiAgICAgICAgd29ya2luZ0NvbG9yU3BhY2VDb25maWc6IHsgdW5wYWNrQ29sb3JTcGFjZTogWCB9LAogICAgICAgIG91dHB1dENvbG9yU3BhY2VDb25maWc6IHsgZHJhd2luZ0J1ZmZlckNvbG9yU3BhY2U6IFggfQogICAgICB9LAogICAgICBbWF06IHsKICAgICAgICBwcmltYXJpZXM6IHQsCiAgICAgICAgd2hpdGVQb2ludDogaSwKICAgICAgICB0cmFuc2ZlcjogS3QsCiAgICAgICAgdG9YWVo6IHhlLAogICAgICAgIGZyb21YWVo6IGdlLAogICAgICAgIGx1bWluYW5jZUNvZWZmaWNpZW50czogZSwKICAgICAgICBvdXRwdXRDb2xvclNwYWNlQ29uZmlnOiB7IGRyYXdpbmdCdWZmZXJDb2xvclNwYWNlOiBYIH0KICAgICAgfQogICAgfSksIGY7CiAgfQogIGNvbnN0IGogPSAvKiBAX19QVVJFX18gKi8gTmUoKTsKICBmdW5jdGlvbiBudChmKSB7CiAgICByZXR1cm4gZiA8IDAuMDQwNDUgPyBmICogMC4wNzczOTkzODA4IDogTWF0aC5wb3coZiAqIDAuOTQ3ODY3Mjk4NiArIDAuMDUyMTMyNzAxNCwgMi40KTsKICB9CiAgZnVuY3Rpb24gU3QoZikgewogICAgcmV0dXJuIGYgPCAzMTMwOGUtNyA/IGYgKiAxMi45MiA6IDEuMDU1ICogTWF0aC5wb3coZiwgMC40MTY2NikgLSAwLjA1NTsKICB9CiAgbGV0IGd0OwogIGNsYXNzIE9lIHsKICAgIHN0YXRpYyBnZXREYXRhVVJMKHQpIHsKICAgICAgaWYgKC9eZGF0YTovaS50ZXN0KHQuc3JjKSB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgPT0gInVuZGVmaW5lZCIpCiAgICAgICAgcmV0dXJuIHQuc3JjOwogICAgICBsZXQgZTsKICAgICAgaWYgKHQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkKICAgICAgICBlID0gdDsKICAgICAgZWxzZSB7CiAgICAgICAgZ3QgPT09IHZvaWQgMCAmJiAoZ3QgPSBwZSgiY2FudmFzIikpLCBndC53aWR0aCA9IHQud2lkdGgsIGd0LmhlaWdodCA9IHQuaGVpZ2h0OwogICAgICAgIGNvbnN0IGkgPSBndC5nZXRDb250ZXh0KCIyZCIpOwogICAgICAgIHQgaW5zdGFuY2VvZiBJbWFnZURhdGEgPyBpLnB1dEltYWdlRGF0YSh0LCAwLCAwKSA6IGkuZHJhd0ltYWdlKHQsIDAsIDAsIHQud2lkdGgsIHQuaGVpZ2h0KSwgZSA9IGd0OwogICAgICB9CiAgICAgIHJldHVybiBlLnRvRGF0YVVSTCgiaW1hZ2UvcG5nIik7CiAgICB9CiAgICBzdGF0aWMgc1JHQlRvTGluZWFyKHQpIHsKICAgICAgaWYgKHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICE9ICJ1bmRlZmluZWQiICYmIHQgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAhPSAidW5kZWZpbmVkIiAmJiB0IGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQgfHwgdHlwZW9mIEltYWdlQml0bWFwICE9ICJ1bmRlZmluZWQiICYmIHQgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkgewogICAgICAgIGNvbnN0IGUgPSBwZSgiY2FudmFzIik7CiAgICAgICAgZS53aWR0aCA9IHQud2lkdGgsIGUuaGVpZ2h0ID0gdC5oZWlnaHQ7CiAgICAgICAgY29uc3QgaSA9IGUuZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgICBpLmRyYXdJbWFnZSh0LCAwLCAwLCB0LndpZHRoLCB0LmhlaWdodCk7CiAgICAgICAgY29uc3QgcyA9IGkuZ2V0SW1hZ2VEYXRhKDAsIDAsIHQud2lkdGgsIHQuaGVpZ2h0KSwgciA9IHMuZGF0YTsKICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspCiAgICAgICAgICByW25dID0gbnQocltuXSAvIDI1NSkgKiAyNTU7CiAgICAgICAgcmV0dXJuIGkucHV0SW1hZ2VEYXRhKHMsIDAsIDApLCBlOwogICAgICB9IGVsc2UgaWYgKHQuZGF0YSkgewogICAgICAgIGNvbnN0IGUgPSB0LmRhdGEuc2xpY2UoMCk7CiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKQogICAgICAgICAgZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID8gZVtpXSA9IE1hdGguZmxvb3IobnQoZVtpXSAvIDI1NSkgKiAyNTUpIDogZVtpXSA9IG50KGVbaV0pOwogICAgICAgIHJldHVybiB7CiAgICAgICAgICBkYXRhOiBlLAogICAgICAgICAgd2lkdGg6IHQud2lkdGgsCiAgICAgICAgICBoZWlnaHQ6IHQuaGVpZ2h0CiAgICAgICAgfTsKICAgICAgfSBlbHNlCiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybigiVEhSRUUuSW1hZ2VVdGlscy5zUkdCVG9MaW5lYXIoKTogVW5zdXBwb3J0ZWQgaW1hZ2UgdHlwZS4gTm8gY29sb3Igc3BhY2UgY29udmVyc2lvbiBhcHBsaWVkLiIpLCB0OwogICAgfQogIH0KICBsZXQgV2UgPSAwOwogIGNsYXNzIHFlIHsKICAgIGNvbnN0cnVjdG9yKHQgPSBudWxsKSB7CiAgICAgIHRoaXMuaXNTb3VyY2UgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJpZCIsIHsgdmFsdWU6IFdlKysgfSksIHRoaXMudXVpZCA9IFh0KCksIHRoaXMuZGF0YSA9IHQsIHRoaXMuZGF0YVJlYWR5ID0gITAsIHRoaXMudmVyc2lvbiA9IDA7CiAgICB9CiAgICBzZXQgbmVlZHNVcGRhdGUodCkgewogICAgICB0ID09PSAhMCAmJiB0aGlzLnZlcnNpb24rKzsKICAgIH0KICAgIHRvSlNPTih0KSB7CiAgICAgIGNvbnN0IGUgPSB0ID09PSB2b2lkIDAgfHwgdHlwZW9mIHQgPT0gInN0cmluZyI7CiAgICAgIGlmICghZSAmJiB0LmltYWdlc1t0aGlzLnV1aWRdICE9PSB2b2lkIDApCiAgICAgICAgcmV0dXJuIHQuaW1hZ2VzW3RoaXMudXVpZF07CiAgICAgIGNvbnN0IGkgPSB7CiAgICAgICAgdXVpZDogdGhpcy51dWlkLAogICAgICAgIHVybDogIiIKICAgICAgfSwgcyA9IHRoaXMuZGF0YTsKICAgICAgaWYgKHMgIT09IG51bGwpIHsKICAgICAgICBsZXQgcjsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzKSkgewogICAgICAgICAgciA9IFtdOwogICAgICAgICAgZm9yIChsZXQgbiA9IDAsIGEgPSBzLmxlbmd0aDsgbiA8IGE7IG4rKykKICAgICAgICAgICAgc1tuXS5pc0RhdGFUZXh0dXJlID8gci5wdXNoKGllKHNbbl0uaW1hZ2UpKSA6IHIucHVzaChpZShzW25dKSk7CiAgICAgICAgfSBlbHNlCiAgICAgICAgICByID0gaWUocyk7CiAgICAgICAgaS51cmwgPSByOwogICAgICB9CiAgICAgIHJldHVybiBlIHx8ICh0LmltYWdlc1t0aGlzLnV1aWRdID0gaSksIGk7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGllKGYpIHsKICAgIHJldHVybiB0eXBlb2YgSFRNTEltYWdlRWxlbWVudCAhPSAidW5kZWZpbmVkIiAmJiBmIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCB8fCB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT0gInVuZGVmaW5lZCIgJiYgZiBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50IHx8IHR5cGVvZiBJbWFnZUJpdG1hcCAhPSAidW5kZWZpbmVkIiAmJiBmIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAgPyBPZS5nZXREYXRhVVJMKGYpIDogZi5kYXRhID8gewogICAgICBkYXRhOiBBcnJheS5mcm9tKGYuZGF0YSksCiAgICAgIHdpZHRoOiBmLndpZHRoLAogICAgICBoZWlnaHQ6IGYuaGVpZ2h0LAogICAgICB0eXBlOiBmLmRhdGEuY29uc3RydWN0b3IubmFtZQogICAgfSA6IChjb25zb2xlLndhcm4oIlRIUkVFLlRleHR1cmU6IFVuYWJsZSB0byBzZXJpYWxpemUgVGV4dHVyZS4iKSwge30pOwogIH0KICBsZXQgdmUgPSAwOwogIGNsYXNzIHh0IGV4dGVuZHMgY2UgewogICAgY29uc3RydWN0b3IodCA9IHh0LkRFRkFVTFRfSU1BR0UsIGUgPSB4dC5ERUZBVUxUX01BUFBJTkcsIGkgPSAxMDAxLCBzID0gMTAwMSwgciA9IDEwMDYsIG4gPSAxMDA4LCBhID0gMTAyMywgbyA9IDEwMDksIGggPSB4dC5ERUZBVUxUX0FOSVNPVFJPUFksIHUgPSBSZSkgewogICAgICBzdXBlcigpLCB0aGlzLmlzVGV4dHVyZSA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgImlkIiwgeyB2YWx1ZTogdmUrKyB9KSwgdGhpcy51dWlkID0gWHQoKSwgdGhpcy5uYW1lID0gIiIsIHRoaXMuc291cmNlID0gbmV3IHFlKHQpLCB0aGlzLm1pcG1hcHMgPSBbXSwgdGhpcy5tYXBwaW5nID0gZSwgdGhpcy5jaGFubmVsID0gMCwgdGhpcy53cmFwUyA9IGksIHRoaXMud3JhcFQgPSBzLCB0aGlzLm1hZ0ZpbHRlciA9IHIsIHRoaXMubWluRmlsdGVyID0gbiwgdGhpcy5hbmlzb3Ryb3B5ID0gaCwgdGhpcy5mb3JtYXQgPSBhLCB0aGlzLmludGVybmFsRm9ybWF0ID0gbnVsbCwgdGhpcy50eXBlID0gbywgdGhpcy5vZmZzZXQgPSBuZXcgcnQoMCwgMCksIHRoaXMucmVwZWF0ID0gbmV3IHJ0KDEsIDEpLCB0aGlzLmNlbnRlciA9IG5ldyBydCgwLCAwKSwgdGhpcy5yb3RhdGlvbiA9IDAsIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9ICEwLCB0aGlzLm1hdHJpeCA9IG5ldyBkdCgpLCB0aGlzLmdlbmVyYXRlTWlwbWFwcyA9ICEwLCB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSAhMSwgdGhpcy5mbGlwWSA9ICEwLCB0aGlzLnVucGFja0FsaWdubWVudCA9IDQsIHRoaXMuY29sb3JTcGFjZSA9IHUsIHRoaXMudXNlckRhdGEgPSB7fSwgdGhpcy52ZXJzaW9uID0gMCwgdGhpcy5vblVwZGF0ZSA9IG51bGwsIHRoaXMucmVuZGVyVGFyZ2V0ID0gbnVsbCwgdGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSAhMSwgdGhpcy5wbXJlbVZlcnNpb24gPSAwOwogICAgfQogICAgZ2V0IGltYWdlKCkgewogICAgICByZXR1cm4gdGhpcy5zb3VyY2UuZGF0YTsKICAgIH0KICAgIHNldCBpbWFnZSh0ID0gbnVsbCkgewogICAgICB0aGlzLnNvdXJjZS5kYXRhID0gdDsKICAgIH0KICAgIHVwZGF0ZU1hdHJpeCgpIHsKICAgICAgdGhpcy5tYXRyaXguc2V0VXZUcmFuc2Zvcm0odGhpcy5vZmZzZXQueCwgdGhpcy5vZmZzZXQueSwgdGhpcy5yZXBlYXQueCwgdGhpcy5yZXBlYXQueSwgdGhpcy5yb3RhdGlvbiwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTsKICAgIH0KICAgIGNvcHkodCkgewogICAgICByZXR1cm4gdGhpcy5uYW1lID0gdC5uYW1lLCB0aGlzLnNvdXJjZSA9IHQuc291cmNlLCB0aGlzLm1pcG1hcHMgPSB0Lm1pcG1hcHMuc2xpY2UoMCksIHRoaXMubWFwcGluZyA9IHQubWFwcGluZywgdGhpcy5jaGFubmVsID0gdC5jaGFubmVsLCB0aGlzLndyYXBTID0gdC53cmFwUywgdGhpcy53cmFwVCA9IHQud3JhcFQsIHRoaXMubWFnRmlsdGVyID0gdC5tYWdGaWx0ZXIsIHRoaXMubWluRmlsdGVyID0gdC5taW5GaWx0ZXIsIHRoaXMuYW5pc290cm9weSA9IHQuYW5pc290cm9weSwgdGhpcy5mb3JtYXQgPSB0LmZvcm1hdCwgdGhpcy5pbnRlcm5hbEZvcm1hdCA9IHQuaW50ZXJuYWxGb3JtYXQsIHRoaXMudHlwZSA9IHQudHlwZSwgdGhpcy5vZmZzZXQuY29weSh0Lm9mZnNldCksIHRoaXMucmVwZWF0LmNvcHkodC5yZXBlYXQpLCB0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSwgdGhpcy5yb3RhdGlvbiA9IHQucm90YXRpb24sIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHQubWF0cml4QXV0b1VwZGF0ZSwgdGhpcy5tYXRyaXguY29weSh0Lm1hdHJpeCksIHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdC5nZW5lcmF0ZU1pcG1hcHMsIHRoaXMucHJlbXVsdGlwbHlBbHBoYSA9IHQucHJlbXVsdGlwbHlBbHBoYSwgdGhpcy5mbGlwWSA9IHQuZmxpcFksIHRoaXMudW5wYWNrQWxpZ25tZW50ID0gdC51bnBhY2tBbGlnbm1lbnQsIHRoaXMuY29sb3JTcGFjZSA9IHQuY29sb3JTcGFjZSwgdGhpcy5yZW5kZXJUYXJnZXQgPSB0LnJlbmRlclRhcmdldCwgdGhpcy5pc1JlbmRlclRhcmdldFRleHR1cmUgPSB0LmlzUmVuZGVyVGFyZ2V0VGV4dHVyZSwgdGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodC51c2VyRGF0YSkpLCB0aGlzLm5lZWRzVXBkYXRlID0gITAsIHRoaXM7CiAgICB9CiAgICB0b0pTT04odCkgewogICAgICBjb25zdCBlID0gdCA9PT0gdm9pZCAwIHx8IHR5cGVvZiB0ID09ICJzdHJpbmciOwogICAgICBpZiAoIWUgJiYgdC50ZXh0dXJlc1t0aGlzLnV1aWRdICE9PSB2b2lkIDApCiAgICAgICAgcmV0dXJuIHQudGV4dHVyZXNbdGhpcy51dWlkXTsKICAgICAgY29uc3QgaSA9IHsKICAgICAgICBtZXRhZGF0YTogewogICAgICAgICAgdmVyc2lvbjogNC42LAogICAgICAgICAgdHlwZTogIlRleHR1cmUiLAogICAgICAgICAgZ2VuZXJhdG9yOiAiVGV4dHVyZS50b0pTT04iCiAgICAgICAgfSwKICAgICAgICB1dWlkOiB0aGlzLnV1aWQsCiAgICAgICAgbmFtZTogdGhpcy5uYW1lLAogICAgICAgIGltYWdlOiB0aGlzLnNvdXJjZS50b0pTT04odCkudXVpZCwKICAgICAgICBtYXBwaW5nOiB0aGlzLm1hcHBpbmcsCiAgICAgICAgY2hhbm5lbDogdGhpcy5jaGFubmVsLAogICAgICAgIHJlcGVhdDogW3RoaXMucmVwZWF0LngsIHRoaXMucmVwZWF0LnldLAogICAgICAgIG9mZnNldDogW3RoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnldLAogICAgICAgIGNlbnRlcjogW3RoaXMuY2VudGVyLngsIHRoaXMuY2VudGVyLnldLAogICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLAogICAgICAgIHdyYXA6IFt0aGlzLndyYXBTLCB0aGlzLndyYXBUXSwKICAgICAgICBmb3JtYXQ6IHRoaXMuZm9ybWF0LAogICAgICAgIGludGVybmFsRm9ybWF0OiB0aGlzLmludGVybmFsRm9ybWF0LAogICAgICAgIHR5cGU6IHRoaXMudHlwZSwKICAgICAgICBjb2xvclNwYWNlOiB0aGlzLmNvbG9yU3BhY2UsCiAgICAgICAgbWluRmlsdGVyOiB0aGlzLm1pbkZpbHRlciwKICAgICAgICBtYWdGaWx0ZXI6IHRoaXMubWFnRmlsdGVyLAogICAgICAgIGFuaXNvdHJvcHk6IHRoaXMuYW5pc290cm9weSwKICAgICAgICBmbGlwWTogdGhpcy5mbGlwWSwKICAgICAgICBnZW5lcmF0ZU1pcG1hcHM6IHRoaXMuZ2VuZXJhdGVNaXBtYXBzLAogICAgICAgIHByZW11bHRpcGx5QWxwaGE6IHRoaXMucHJlbXVsdGlwbHlBbHBoYSwKICAgICAgICB1bnBhY2tBbGlnbm1lbnQ6IHRoaXMudW5wYWNrQWxpZ25tZW50CiAgICAgIH07CiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGggPiAwICYmIChpLnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YSksIGUgfHwgKHQudGV4dHVyZXNbdGhpcy51dWlkXSA9IGkpLCBpOwogICAgfQogICAgZGlzcG9zZSgpIHsKICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogImRpc3Bvc2UiIH0pOwogICAgfQogICAgdHJhbnNmb3JtVXYodCkgewogICAgICBpZiAodGhpcy5tYXBwaW5nICE9PSAzMDApIHJldHVybiB0OwogICAgICBpZiAodC5hcHBseU1hdHJpeDModGhpcy5tYXRyaXgpLCB0LnggPCAwIHx8IHQueCA+IDEpCiAgICAgICAgc3dpdGNoICh0aGlzLndyYXBTKSB7CiAgICAgICAgICBjYXNlIDFlMzoKICAgICAgICAgICAgdC54ID0gdC54IC0gTWF0aC5mbG9vcih0LngpOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgMTAwMToKICAgICAgICAgICAgdC54ID0gdC54IDwgMCA/IDAgOiAxOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgMTAwMjoKICAgICAgICAgICAgTWF0aC5hYnMoTWF0aC5mbG9vcih0LngpICUgMikgPT09IDEgPyB0LnggPSBNYXRoLmNlaWwodC54KSAtIHQueCA6IHQueCA9IHQueCAtIE1hdGguZmxvb3IodC54KTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICBpZiAodC55IDwgMCB8fCB0LnkgPiAxKQogICAgICAgIHN3aXRjaCAodGhpcy53cmFwVCkgewogICAgICAgICAgY2FzZSAxZTM6CiAgICAgICAgICAgIHQueSA9IHQueSAtIE1hdGguZmxvb3IodC55KTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDEwMDE6CiAgICAgICAgICAgIHQueSA9IHQueSA8IDAgPyAwIDogMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBjYXNlIDEwMDI6CiAgICAgICAgICAgIE1hdGguYWJzKE1hdGguZmxvb3IodC55KSAlIDIpID09PSAxID8gdC55ID0gTWF0aC5jZWlsKHQueSkgLSB0LnkgOiB0LnkgPSB0LnkgLSBNYXRoLmZsb29yKHQueSk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgcmV0dXJuIHRoaXMuZmxpcFkgJiYgKHQueSA9IDEgLSB0LnkpLCB0OwogICAgfQogICAgc2V0IG5lZWRzVXBkYXRlKHQpIHsKICAgICAgdCA9PT0gITAgJiYgKHRoaXMudmVyc2lvbisrLCB0aGlzLnNvdXJjZS5uZWVkc1VwZGF0ZSA9ICEwKTsKICAgIH0KICAgIHNldCBuZWVkc1BNUkVNVXBkYXRlKHQpIHsKICAgICAgdCA9PT0gITAgJiYgdGhpcy5wbXJlbVZlcnNpb24rKzsKICAgIH0KICB9CiAgeHQuREVGQVVMVF9JTUFHRSA9IG51bGw7CiAgeHQuREVGQVVMVF9NQVBQSU5HID0gMzAwOwogIHh0LkRFRkFVTFRfQU5JU09UUk9QWSA9IDE7CiAgY2xhc3MgTHQgewogICAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwLCBpID0gMCwgcyA9IDEpIHsKICAgICAgdGhpcy5pc1F1YXRlcm5pb24gPSAhMCwgdGhpcy5feCA9IHQsIHRoaXMuX3kgPSBlLCB0aGlzLl96ID0gaSwgdGhpcy5fdyA9IHM7CiAgICB9CiAgICBzdGF0aWMgc2xlcnBGbGF0KHQsIGUsIGksIHMsIHIsIG4sIGEpIHsKICAgICAgbGV0IG8gPSBpW3MgKyAwXSwgaCA9IGlbcyArIDFdLCB1ID0gaVtzICsgMl0sIGwgPSBpW3MgKyAzXTsKICAgICAgY29uc3QgZCA9IHJbbiArIDBdLCBjID0gcltuICsgMV0sIG0gPSByW24gKyAyXSwgeSA9IHJbbiArIDNdOwogICAgICBpZiAoYSA9PT0gMCkgewogICAgICAgIHRbZSArIDBdID0gbywgdFtlICsgMV0gPSBoLCB0W2UgKyAyXSA9IHUsIHRbZSArIDNdID0gbDsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKGEgPT09IDEpIHsKICAgICAgICB0W2UgKyAwXSA9IGQsIHRbZSArIDFdID0gYywgdFtlICsgMl0gPSBtLCB0W2UgKyAzXSA9IHk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmIChsICE9PSB5IHx8IG8gIT09IGQgfHwgaCAhPT0gYyB8fCB1ICE9PSBtKSB7CiAgICAgICAgbGV0IHggPSAxIC0gYTsKICAgICAgICBjb25zdCBwID0gbyAqIGQgKyBoICogYyArIHUgKiBtICsgbCAqIHksIHogPSBwID49IDAgPyAxIDogLTEsIEYgPSAxIC0gcCAqIHA7CiAgICAgICAgaWYgKEYgPiBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgY29uc3QgYiA9IE1hdGguc3FydChGKSwgTSA9IE1hdGguYXRhbjIoYiwgcCAqIHopOwogICAgICAgICAgeCA9IE1hdGguc2luKHggKiBNKSAvIGIsIGEgPSBNYXRoLnNpbihhICogTSkgLyBiOwogICAgICAgIH0KICAgICAgICBjb25zdCBBID0gYSAqIHo7CiAgICAgICAgaWYgKG8gPSBvICogeCArIGQgKiBBLCBoID0gaCAqIHggKyBjICogQSwgdSA9IHUgKiB4ICsgbSAqIEEsIGwgPSBsICogeCArIHkgKiBBLCB4ID09PSAxIC0gYSkgewogICAgICAgICAgY29uc3QgYiA9IDEgLyBNYXRoLnNxcnQobyAqIG8gKyBoICogaCArIHUgKiB1ICsgbCAqIGwpOwogICAgICAgICAgbyAqPSBiLCBoICo9IGIsIHUgKj0gYiwgbCAqPSBiOwogICAgICAgIH0KICAgICAgfQogICAgICB0W2VdID0gbywgdFtlICsgMV0gPSBoLCB0W2UgKyAyXSA9IHUsIHRbZSArIDNdID0gbDsKICAgIH0KICAgIHN0YXRpYyBtdWx0aXBseVF1YXRlcm5pb25zRmxhdCh0LCBlLCBpLCBzLCByLCBuKSB7CiAgICAgIGNvbnN0IGEgPSBpW3NdLCBvID0gaVtzICsgMV0sIGggPSBpW3MgKyAyXSwgdSA9IGlbcyArIDNdLCBsID0gcltuXSwgZCA9IHJbbiArIDFdLCBjID0gcltuICsgMl0sIG0gPSByW24gKyAzXTsKICAgICAgcmV0dXJuIHRbZV0gPSBhICogbSArIHUgKiBsICsgbyAqIGMgLSBoICogZCwgdFtlICsgMV0gPSBvICogbSArIHUgKiBkICsgaCAqIGwgLSBhICogYywgdFtlICsgMl0gPSBoICogbSArIHUgKiBjICsgYSAqIGQgLSBvICogbCwgdFtlICsgM10gPSB1ICogbSAtIGEgKiBsIC0gbyAqIGQgLSBoICogYywgdDsKICAgIH0KICAgIGdldCB4KCkgewogICAgICByZXR1cm4gdGhpcy5feDsKICAgIH0KICAgIHNldCB4KHQpIHsKICAgICAgdGhpcy5feCA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCB5KCkgewogICAgICByZXR1cm4gdGhpcy5feTsKICAgIH0KICAgIHNldCB5KHQpIHsKICAgICAgdGhpcy5feSA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCB6KCkgewogICAgICByZXR1cm4gdGhpcy5fejsKICAgIH0KICAgIHNldCB6KHQpIHsKICAgICAgdGhpcy5feiA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCB3KCkgewogICAgICByZXR1cm4gdGhpcy5fdzsKICAgIH0KICAgIHNldCB3KHQpIHsKICAgICAgdGhpcy5fdyA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIHNldCh0LCBlLCBpLCBzKSB7CiAgICAgIHJldHVybiB0aGlzLl94ID0gdCwgdGhpcy5feSA9IGUsIHRoaXMuX3ogPSBpLCB0aGlzLl93ID0gcywgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl93KTsKICAgIH0KICAgIGNvcHkodCkgewogICAgICByZXR1cm4gdGhpcy5feCA9IHQueCwgdGhpcy5feSA9IHQueSwgdGhpcy5feiA9IHQueiwgdGhpcy5fdyA9IHQudywgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbUV1bGVyKHQsIGUgPSAhMCkgewogICAgICBjb25zdCBpID0gdC5feCwgcyA9IHQuX3ksIHIgPSB0Ll96LCBuID0gdC5fb3JkZXIsIGEgPSBNYXRoLmNvcywgbyA9IE1hdGguc2luLCBoID0gYShpIC8gMiksIHUgPSBhKHMgLyAyKSwgbCA9IGEociAvIDIpLCBkID0gbyhpIC8gMiksIGMgPSBvKHMgLyAyKSwgbSA9IG8ociAvIDIpOwogICAgICBzd2l0Y2ggKG4pIHsKICAgICAgICBjYXNlICJYWVoiOgogICAgICAgICAgdGhpcy5feCA9IGQgKiB1ICogbCArIGggKiBjICogbSwgdGhpcy5feSA9IGggKiBjICogbCAtIGQgKiB1ICogbSwgdGhpcy5feiA9IGggKiB1ICogbSArIGQgKiBjICogbCwgdGhpcy5fdyA9IGggKiB1ICogbCAtIGQgKiBjICogbTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIllYWiI6CiAgICAgICAgICB0aGlzLl94ID0gZCAqIHUgKiBsICsgaCAqIGMgKiBtLCB0aGlzLl95ID0gaCAqIGMgKiBsIC0gZCAqIHUgKiBtLCB0aGlzLl96ID0gaCAqIHUgKiBtIC0gZCAqIGMgKiBsLCB0aGlzLl93ID0gaCAqIHUgKiBsICsgZCAqIGMgKiBtOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiWlhZIjoKICAgICAgICAgIHRoaXMuX3ggPSBkICogdSAqIGwgLSBoICogYyAqIG0sIHRoaXMuX3kgPSBoICogYyAqIGwgKyBkICogdSAqIG0sIHRoaXMuX3ogPSBoICogdSAqIG0gKyBkICogYyAqIGwsIHRoaXMuX3cgPSBoICogdSAqIGwgLSBkICogYyAqIG07CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJaWVgiOgogICAgICAgICAgdGhpcy5feCA9IGQgKiB1ICogbCAtIGggKiBjICogbSwgdGhpcy5feSA9IGggKiBjICogbCArIGQgKiB1ICogbSwgdGhpcy5feiA9IGggKiB1ICogbSAtIGQgKiBjICogbCwgdGhpcy5fdyA9IGggKiB1ICogbCArIGQgKiBjICogbTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIllaWCI6CiAgICAgICAgICB0aGlzLl94ID0gZCAqIHUgKiBsICsgaCAqIGMgKiBtLCB0aGlzLl95ID0gaCAqIGMgKiBsICsgZCAqIHUgKiBtLCB0aGlzLl96ID0gaCAqIHUgKiBtIC0gZCAqIGMgKiBsLCB0aGlzLl93ID0gaCAqIHUgKiBsIC0gZCAqIGMgKiBtOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiWFpZIjoKICAgICAgICAgIHRoaXMuX3ggPSBkICogdSAqIGwgLSBoICogYyAqIG0sIHRoaXMuX3kgPSBoICogYyAqIGwgLSBkICogdSAqIG0sIHRoaXMuX3ogPSBoICogdSAqIG0gKyBkICogYyAqIGwsIHRoaXMuX3cgPSBoICogdSAqIGwgKyBkICogYyAqIG07CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgY29uc29sZS53YXJuKCJUSFJFRS5RdWF0ZXJuaW9uOiAuc2V0RnJvbUV1bGVyKCkgZW5jb3VudGVyZWQgYW4gdW5rbm93biBvcmRlcjogIiArIG4pOwogICAgICB9CiAgICAgIHJldHVybiBlID09PSAhMCAmJiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICBzZXRGcm9tQXhpc0FuZ2xlKHQsIGUpIHsKICAgICAgY29uc3QgaSA9IGUgLyAyLCBzID0gTWF0aC5zaW4oaSk7CiAgICAgIHJldHVybiB0aGlzLl94ID0gdC54ICogcywgdGhpcy5feSA9IHQueSAqIHMsIHRoaXMuX3ogPSB0LnogKiBzLCB0aGlzLl93ID0gTWF0aC5jb3MoaSksIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICAgIH0KICAgIHNldEZyb21Sb3RhdGlvbk1hdHJpeCh0KSB7CiAgICAgIGNvbnN0IGUgPSB0LmVsZW1lbnRzLCBpID0gZVswXSwgcyA9IGVbNF0sIHIgPSBlWzhdLCBuID0gZVsxXSwgYSA9IGVbNV0sIG8gPSBlWzldLCBoID0gZVsyXSwgdSA9IGVbNl0sIGwgPSBlWzEwXSwgZCA9IGkgKyBhICsgbDsKICAgICAgaWYgKGQgPiAwKSB7CiAgICAgICAgY29uc3QgYyA9IDAuNSAvIE1hdGguc3FydChkICsgMSk7CiAgICAgICAgdGhpcy5fdyA9IDAuMjUgLyBjLCB0aGlzLl94ID0gKHUgLSBvKSAqIGMsIHRoaXMuX3kgPSAociAtIGgpICogYywgdGhpcy5feiA9IChuIC0gcykgKiBjOwogICAgICB9IGVsc2UgaWYgKGkgPiBhICYmIGkgPiBsKSB7CiAgICAgICAgY29uc3QgYyA9IDIgKiBNYXRoLnNxcnQoMSArIGkgLSBhIC0gbCk7CiAgICAgICAgdGhpcy5fdyA9ICh1IC0gbykgLyBjLCB0aGlzLl94ID0gMC4yNSAqIGMsIHRoaXMuX3kgPSAocyArIG4pIC8gYywgdGhpcy5feiA9IChyICsgaCkgLyBjOwogICAgICB9IGVsc2UgaWYgKGEgPiBsKSB7CiAgICAgICAgY29uc3QgYyA9IDIgKiBNYXRoLnNxcnQoMSArIGEgLSBpIC0gbCk7CiAgICAgICAgdGhpcy5fdyA9IChyIC0gaCkgLyBjLCB0aGlzLl94ID0gKHMgKyBuKSAvIGMsIHRoaXMuX3kgPSAwLjI1ICogYywgdGhpcy5feiA9IChvICsgdSkgLyBjOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGMgPSAyICogTWF0aC5zcXJ0KDEgKyBsIC0gaSAtIGEpOwogICAgICAgIHRoaXMuX3cgPSAobiAtIHMpIC8gYywgdGhpcy5feCA9IChyICsgaCkgLyBjLCB0aGlzLl95ID0gKG8gKyB1KSAvIGMsIHRoaXMuX3ogPSAwLjI1ICogYzsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbVVuaXRWZWN0b3JzKHQsIGUpIHsKICAgICAgbGV0IGkgPSB0LmRvdChlKSArIDE7CiAgICAgIHJldHVybiBpIDwgTnVtYmVyLkVQU0lMT04gPyAoaSA9IDAsIE1hdGguYWJzKHQueCkgPiBNYXRoLmFicyh0LnopID8gKHRoaXMuX3ggPSAtdC55LCB0aGlzLl95ID0gdC54LCB0aGlzLl96ID0gMCwgdGhpcy5fdyA9IGkpIDogKHRoaXMuX3ggPSAwLCB0aGlzLl95ID0gLXQueiwgdGhpcy5feiA9IHQueSwgdGhpcy5fdyA9IGkpKSA6ICh0aGlzLl94ID0gdC55ICogZS56IC0gdC56ICogZS55LCB0aGlzLl95ID0gdC56ICogZS54IC0gdC54ICogZS56LCB0aGlzLl96ID0gdC54ICogZS55IC0gdC55ICogZS54LCB0aGlzLl93ID0gaSksIHRoaXMubm9ybWFsaXplKCk7CiAgICB9CiAgICBhbmdsZVRvKHQpIHsKICAgICAgcmV0dXJuIDIgKiBNYXRoLmFjb3MoTWF0aC5hYnMoVCh0aGlzLmRvdCh0KSwgLTEsIDEpKSk7CiAgICB9CiAgICByb3RhdGVUb3dhcmRzKHQsIGUpIHsKICAgICAgY29uc3QgaSA9IHRoaXMuYW5nbGVUbyh0KTsKICAgICAgaWYgKGkgPT09IDApIHJldHVybiB0aGlzOwogICAgICBjb25zdCBzID0gTWF0aC5taW4oMSwgZSAvIGkpOwogICAgICByZXR1cm4gdGhpcy5zbGVycCh0LCBzKSwgdGhpczsKICAgIH0KICAgIGlkZW50aXR5KCkgewogICAgICByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCwgMSk7CiAgICB9CiAgICBpbnZlcnQoKSB7CiAgICAgIHJldHVybiB0aGlzLmNvbmp1Z2F0ZSgpOwogICAgfQogICAgY29uanVnYXRlKCkgewogICAgICByZXR1cm4gdGhpcy5feCAqPSAtMSwgdGhpcy5feSAqPSAtMSwgdGhpcy5feiAqPSAtMSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgZG90KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0Ll94ICsgdGhpcy5feSAqIHQuX3kgKyB0aGlzLl96ICogdC5feiArIHRoaXMuX3cgKiB0Ll93OwogICAgfQogICAgbGVuZ3RoU3EoKSB7CiAgICAgIHJldHVybiB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdzsKICAgIH0KICAgIGxlbmd0aCgpIHsKICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyk7CiAgICB9CiAgICBub3JtYWxpemUoKSB7CiAgICAgIGxldCB0ID0gdGhpcy5sZW5ndGgoKTsKICAgICAgcmV0dXJuIHQgPT09IDAgPyAodGhpcy5feCA9IDAsIHRoaXMuX3kgPSAwLCB0aGlzLl96ID0gMCwgdGhpcy5fdyA9IDEpIDogKHQgPSAxIC8gdCwgdGhpcy5feCA9IHRoaXMuX3ggKiB0LCB0aGlzLl95ID0gdGhpcy5feSAqIHQsIHRoaXMuX3ogPSB0aGlzLl96ICogdCwgdGhpcy5fdyA9IHRoaXMuX3cgKiB0KSwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHRoaXMsIHQpOwogICAgfQogICAgcHJlbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKHQsIHRoaXMpOwogICAgfQogICAgbXVsdGlwbHlRdWF0ZXJuaW9ucyh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSB0Ll94LCBzID0gdC5feSwgciA9IHQuX3osIG4gPSB0Ll93LCBhID0gZS5feCwgbyA9IGUuX3ksIGggPSBlLl96LCB1ID0gZS5fdzsKICAgICAgcmV0dXJuIHRoaXMuX3ggPSBpICogdSArIG4gKiBhICsgcyAqIGggLSByICogbywgdGhpcy5feSA9IHMgKiB1ICsgbiAqIG8gKyByICogYSAtIGkgKiBoLCB0aGlzLl96ID0gciAqIHUgKyBuICogaCArIGkgKiBvIC0gcyAqIGEsIHRoaXMuX3cgPSBuICogdSAtIGkgKiBhIC0gcyAqIG8gLSByICogaCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgc2xlcnAodCwgZSkgewogICAgICBpZiAoZSA9PT0gMCkgcmV0dXJuIHRoaXM7CiAgICAgIGlmIChlID09PSAxKSByZXR1cm4gdGhpcy5jb3B5KHQpOwogICAgICBjb25zdCBpID0gdGhpcy5feCwgcyA9IHRoaXMuX3ksIHIgPSB0aGlzLl96LCBuID0gdGhpcy5fdzsKICAgICAgbGV0IGEgPSBuICogdC5fdyArIGkgKiB0Ll94ICsgcyAqIHQuX3kgKyByICogdC5fejsKICAgICAgaWYgKGEgPCAwID8gKHRoaXMuX3cgPSAtdC5fdywgdGhpcy5feCA9IC10Ll94LCB0aGlzLl95ID0gLXQuX3ksIHRoaXMuX3ogPSAtdC5feiwgYSA9IC1hKSA6IHRoaXMuY29weSh0KSwgYSA+PSAxKQogICAgICAgIHJldHVybiB0aGlzLl93ID0gbiwgdGhpcy5feCA9IGksIHRoaXMuX3kgPSBzLCB0aGlzLl96ID0gciwgdGhpczsKICAgICAgY29uc3QgbyA9IDEgLSBhICogYTsKICAgICAgaWYgKG8gPD0gTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICBjb25zdCBjID0gMSAtIGU7CiAgICAgICAgcmV0dXJuIHRoaXMuX3cgPSBjICogbiArIGUgKiB0aGlzLl93LCB0aGlzLl94ID0gYyAqIGkgKyBlICogdGhpcy5feCwgdGhpcy5feSA9IGMgKiBzICsgZSAqIHRoaXMuX3ksIHRoaXMuX3ogPSBjICogciArIGUgKiB0aGlzLl96LCB0aGlzLm5vcm1hbGl6ZSgpLCB0aGlzOwogICAgICB9CiAgICAgIGNvbnN0IGggPSBNYXRoLnNxcnQobyksIHUgPSBNYXRoLmF0YW4yKGgsIGEpLCBsID0gTWF0aC5zaW4oKDEgLSBlKSAqIHUpIC8gaCwgZCA9IE1hdGguc2luKGUgKiB1KSAvIGg7CiAgICAgIHJldHVybiB0aGlzLl93ID0gbiAqIGwgKyB0aGlzLl93ICogZCwgdGhpcy5feCA9IGkgKiBsICsgdGhpcy5feCAqIGQsIHRoaXMuX3kgPSBzICogbCArIHRoaXMuX3kgKiBkLCB0aGlzLl96ID0gciAqIGwgKyB0aGlzLl96ICogZCwgdGhpcy5fb25DaGFuZ2VDYWxsYmFjaygpLCB0aGlzOwogICAgfQogICAgc2xlcnBRdWF0ZXJuaW9ucyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLmNvcHkodCkuc2xlcnAoZSwgaSk7CiAgICB9CiAgICByYW5kb20oKSB7CiAgICAgIGNvbnN0IHQgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCksIGUgPSAyICogTWF0aC5QSSAqIE1hdGgucmFuZG9tKCksIGkgPSBNYXRoLnJhbmRvbSgpLCBzID0gTWF0aC5zcXJ0KDEgLSBpKSwgciA9IE1hdGguc3FydChpKTsKICAgICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICAgIHMgKiBNYXRoLnNpbih0KSwKICAgICAgICBzICogTWF0aC5jb3ModCksCiAgICAgICAgciAqIE1hdGguc2luKGUpLAogICAgICAgIHIgKiBNYXRoLmNvcyhlKQogICAgICApOwogICAgfQogICAgZXF1YWxzKHQpIHsKICAgICAgcmV0dXJuIHQuX3ggPT09IHRoaXMuX3ggJiYgdC5feSA9PT0gdGhpcy5feSAmJiB0Ll96ID09PSB0aGlzLl96ICYmIHQuX3cgPT09IHRoaXMuX3c7CiAgICB9CiAgICBmcm9tQXJyYXkodCwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRoaXMuX3ggPSB0W2VdLCB0aGlzLl95ID0gdFtlICsgMV0sIHRoaXMuX3ogPSB0W2UgKyAyXSwgdGhpcy5fdyA9IHRbZSArIDNdLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRbZV0gPSB0aGlzLl94LCB0W2UgKyAxXSA9IHRoaXMuX3ksIHRbZSArIDJdID0gdGhpcy5feiwgdFtlICsgM10gPSB0aGlzLl93LCB0OwogICAgfQogICAgZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLl94ID0gdC5nZXRYKGUpLCB0aGlzLl95ID0gdC5nZXRZKGUpLCB0aGlzLl96ID0gdC5nZXRaKGUpLCB0aGlzLl93ID0gdC5nZXRXKGUpLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICB0b0pTT04oKSB7CiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXkoKTsKICAgIH0KICAgIF9vbkNoYW5nZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gdCwgdGhpczsKICAgIH0KICAgIF9vbkNoYW5nZUNhbGxiYWNrKCkgewogICAgfQogICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICB5aWVsZCB0aGlzLl94LCB5aWVsZCB0aGlzLl95LCB5aWVsZCB0aGlzLl96LCB5aWVsZCB0aGlzLl93OwogICAgfQogIH0KICBjbGFzcyBnIHsKICAgIGNvbnN0cnVjdG9yKHQgPSAwLCBlID0gMCwgaSA9IDApIHsKICAgICAgZy5wcm90b3R5cGUuaXNWZWN0b3IzID0gITAsIHRoaXMueCA9IHQsIHRoaXMueSA9IGUsIHRoaXMueiA9IGk7CiAgICB9CiAgICBzZXQodCwgZSwgaSkgewogICAgICByZXR1cm4gaSA9PT0gdm9pZCAwICYmIChpID0gdGhpcy56KSwgdGhpcy54ID0gdCwgdGhpcy55ID0gZSwgdGhpcy56ID0gaSwgdGhpczsKICAgIH0KICAgIHNldFNjYWxhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzLnkgPSB0LCB0aGlzLnogPSB0LCB0aGlzOwogICAgfQogICAgc2V0WCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LCB0aGlzOwogICAgfQogICAgc2V0WSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnkgPSB0LCB0aGlzOwogICAgfQogICAgc2V0Wih0KSB7CiAgICAgIHJldHVybiB0aGlzLnogPSB0LCB0aGlzOwogICAgfQogICAgc2V0Q29tcG9uZW50KHQsIGUpIHsKICAgICAgc3dpdGNoICh0KSB7CiAgICAgICAgY2FzZSAwOgogICAgICAgICAgdGhpcy54ID0gZTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgMToKICAgICAgICAgIHRoaXMueSA9IGU7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICB0aGlzLnogPSBlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAiICsgdCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBnZXRDb21wb25lbnQodCkgewogICAgICBzd2l0Y2ggKHQpIHsKICAgICAgICBjYXNlIDA6CiAgICAgICAgICByZXR1cm4gdGhpcy54OwogICAgICAgIGNhc2UgMToKICAgICAgICAgIHJldHVybiB0aGlzLnk7CiAgICAgICAgY2FzZSAyOgogICAgICAgICAgcmV0dXJuIHRoaXMuejsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICIgKyB0KTsKICAgICAgfQogICAgfQogICAgY2xvbmUoKSB7CiAgICAgIHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzLngsIHRoaXMueSwgdGhpcy56KTsKICAgIH0KICAgIGNvcHkodCkgewogICAgICByZXR1cm4gdGhpcy54ID0gdC54LCB0aGlzLnkgPSB0LnksIHRoaXMueiA9IHQueiwgdGhpczsKICAgIH0KICAgIGFkZCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnggKz0gdC54LCB0aGlzLnkgKz0gdC55LCB0aGlzLnogKz0gdC56LCB0aGlzOwogICAgfQogICAgYWRkU2NhbGFyKHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCArPSB0LCB0aGlzLnkgKz0gdCwgdGhpcy56ICs9IHQsIHRoaXM7CiAgICB9CiAgICBhZGRWZWN0b3JzKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IHQueCArIGUueCwgdGhpcy55ID0gdC55ICsgZS55LCB0aGlzLnogPSB0LnogKyBlLnosIHRoaXM7CiAgICB9CiAgICBhZGRTY2FsZWRWZWN0b3IodCwgZSkgewogICAgICByZXR1cm4gdGhpcy54ICs9IHQueCAqIGUsIHRoaXMueSArPSB0LnkgKiBlLCB0aGlzLnogKz0gdC56ICogZSwgdGhpczsKICAgIH0KICAgIHN1Yih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggLT0gdC54LCB0aGlzLnkgLT0gdC55LCB0aGlzLnogLT0gdC56LCB0aGlzOwogICAgfQogICAgc3ViU2NhbGFyKHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCAtPSB0LCB0aGlzLnkgLT0gdCwgdGhpcy56IC09IHQsIHRoaXM7CiAgICB9CiAgICBzdWJWZWN0b3JzKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IHQueCAtIGUueCwgdGhpcy55ID0gdC55IC0gZS55LCB0aGlzLnogPSB0LnogLSBlLnosIHRoaXM7CiAgICB9CiAgICBtdWx0aXBseSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnggKj0gdC54LCB0aGlzLnkgKj0gdC55LCB0aGlzLnogKj0gdC56LCB0aGlzOwogICAgfQogICAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgICByZXR1cm4gdGhpcy54ICo9IHQsIHRoaXMueSAqPSB0LCB0aGlzLnogKj0gdCwgdGhpczsKICAgIH0KICAgIG11bHRpcGx5VmVjdG9ycyh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LnggKiBlLngsIHRoaXMueSA9IHQueSAqIGUueSwgdGhpcy56ID0gdC56ICogZS56LCB0aGlzOwogICAgfQogICAgYXBwbHlFdWxlcih0KSB7CiAgICAgIHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbihiZS5zZXRGcm9tRXVsZXIodCkpOwogICAgfQogICAgYXBwbHlBeGlzQW5nbGUodCwgZSkgewogICAgICByZXR1cm4gdGhpcy5hcHBseVF1YXRlcm5pb24oYmUuc2V0RnJvbUF4aXNBbmdsZSh0LCBlKSk7CiAgICB9CiAgICBhcHBseU1hdHJpeDModCkgewogICAgICBjb25zdCBlID0gdGhpcy54LCBpID0gdGhpcy55LCBzID0gdGhpcy56LCByID0gdC5lbGVtZW50czsKICAgICAgcmV0dXJuIHRoaXMueCA9IHJbMF0gKiBlICsgclszXSAqIGkgKyByWzZdICogcywgdGhpcy55ID0gclsxXSAqIGUgKyByWzRdICogaSArIHJbN10gKiBzLCB0aGlzLnogPSByWzJdICogZSArIHJbNV0gKiBpICsgcls4XSAqIHMsIHRoaXM7CiAgICB9CiAgICBhcHBseU5vcm1hbE1hdHJpeCh0KSB7CiAgICAgIHJldHVybiB0aGlzLmFwcGx5TWF0cml4Myh0KS5ub3JtYWxpemUoKTsKICAgIH0KICAgIGFwcGx5TWF0cml4NCh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLngsIGkgPSB0aGlzLnksIHMgPSB0aGlzLnosIHIgPSB0LmVsZW1lbnRzLCBuID0gMSAvIChyWzNdICogZSArIHJbN10gKiBpICsgclsxMV0gKiBzICsgclsxNV0pOwogICAgICByZXR1cm4gdGhpcy54ID0gKHJbMF0gKiBlICsgcls0XSAqIGkgKyByWzhdICogcyArIHJbMTJdKSAqIG4sIHRoaXMueSA9IChyWzFdICogZSArIHJbNV0gKiBpICsgcls5XSAqIHMgKyByWzEzXSkgKiBuLCB0aGlzLnogPSAoclsyXSAqIGUgKyByWzZdICogaSArIHJbMTBdICogcyArIHJbMTRdKSAqIG4sIHRoaXM7CiAgICB9CiAgICBhcHBseVF1YXRlcm5pb24odCkgewogICAgICBjb25zdCBlID0gdGhpcy54LCBpID0gdGhpcy55LCBzID0gdGhpcy56LCByID0gdC54LCBuID0gdC55LCBhID0gdC56LCBvID0gdC53LCBoID0gMiAqIChuICogcyAtIGEgKiBpKSwgdSA9IDIgKiAoYSAqIGUgLSByICogcyksIGwgPSAyICogKHIgKiBpIC0gbiAqIGUpOwogICAgICByZXR1cm4gdGhpcy54ID0gZSArIG8gKiBoICsgbiAqIGwgLSBhICogdSwgdGhpcy55ID0gaSArIG8gKiB1ICsgYSAqIGggLSByICogbCwgdGhpcy56ID0gcyArIG8gKiBsICsgciAqIHUgLSBuICogaCwgdGhpczsKICAgIH0KICAgIHByb2plY3QodCkgewogICAgICByZXR1cm4gdGhpcy5hcHBseU1hdHJpeDQodC5tYXRyaXhXb3JsZEludmVyc2UpLmFwcGx5TWF0cml4NCh0LnByb2plY3Rpb25NYXRyaXgpOwogICAgfQogICAgdW5wcm9qZWN0KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KHQucHJvamVjdGlvbk1hdHJpeEludmVyc2UpLmFwcGx5TWF0cml4NCh0Lm1hdHJpeFdvcmxkKTsKICAgIH0KICAgIHRyYW5zZm9ybURpcmVjdGlvbih0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLngsIGkgPSB0aGlzLnksIHMgPSB0aGlzLnosIHIgPSB0LmVsZW1lbnRzOwogICAgICByZXR1cm4gdGhpcy54ID0gclswXSAqIGUgKyByWzRdICogaSArIHJbOF0gKiBzLCB0aGlzLnkgPSByWzFdICogZSArIHJbNV0gKiBpICsgcls5XSAqIHMsIHRoaXMueiA9IHJbMl0gKiBlICsgcls2XSAqIGkgKyByWzEwXSAqIHMsIHRoaXMubm9ybWFsaXplKCk7CiAgICB9CiAgICBkaXZpZGUodCkgewogICAgICByZXR1cm4gdGhpcy54IC89IHQueCwgdGhpcy55IC89IHQueSwgdGhpcy56IC89IHQueiwgdGhpczsKICAgIH0KICAgIGRpdmlkZVNjYWxhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKDEgLyB0KTsKICAgIH0KICAgIG1pbih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSBNYXRoLm1pbih0aGlzLngsIHQueCksIHRoaXMueSA9IE1hdGgubWluKHRoaXMueSwgdC55KSwgdGhpcy56ID0gTWF0aC5taW4odGhpcy56LCB0LnopLCB0aGlzOwogICAgfQogICAgbWF4KHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgubWF4KHRoaXMueCwgdC54KSwgdGhpcy55ID0gTWF0aC5tYXgodGhpcy55LCB0LnkpLCB0aGlzLnogPSBNYXRoLm1heCh0aGlzLnosIHQueiksIHRoaXM7CiAgICB9CiAgICBjbGFtcCh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSBUKHRoaXMueCwgdC54LCBlLngpLCB0aGlzLnkgPSBUKHRoaXMueSwgdC55LCBlLnkpLCB0aGlzLnogPSBUKHRoaXMueiwgdC56LCBlLnopLCB0aGlzOwogICAgfQogICAgY2xhbXBTY2FsYXIodCwgZSkgewogICAgICByZXR1cm4gdGhpcy54ID0gVCh0aGlzLngsIHQsIGUpLCB0aGlzLnkgPSBUKHRoaXMueSwgdCwgZSksIHRoaXMueiA9IFQodGhpcy56LCB0LCBlKSwgdGhpczsKICAgIH0KICAgIGNsYW1wTGVuZ3RoKHQsIGUpIHsKICAgICAgY29uc3QgaSA9IHRoaXMubGVuZ3RoKCk7CiAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcihpIHx8IDEpLm11bHRpcGx5U2NhbGFyKFQoaSwgdCwgZSkpOwogICAgfQogICAgZmxvb3IoKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCksIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KSwgdGhpcy56ID0gTWF0aC5mbG9vcih0aGlzLnopLCB0aGlzOwogICAgfQogICAgY2VpbCgpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGguY2VpbCh0aGlzLngpLCB0aGlzLnkgPSBNYXRoLmNlaWwodGhpcy55KSwgdGhpcy56ID0gTWF0aC5jZWlsKHRoaXMueiksIHRoaXM7CiAgICB9CiAgICByb3VuZCgpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucm91bmQodGhpcy54KSwgdGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnJvdW5kKHRoaXMueiksIHRoaXM7CiAgICB9CiAgICByb3VuZFRvWmVybygpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgudHJ1bmModGhpcy54KSwgdGhpcy55ID0gTWF0aC50cnVuYyh0aGlzLnkpLCB0aGlzLnogPSBNYXRoLnRydW5jKHRoaXMueiksIHRoaXM7CiAgICB9CiAgICBuZWdhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSAtdGhpcy54LCB0aGlzLnkgPSAtdGhpcy55LCB0aGlzLnogPSAtdGhpcy56LCB0aGlzOwogICAgfQogICAgZG90KHQpIHsKICAgICAgcmV0dXJuIHRoaXMueCAqIHQueCArIHRoaXMueSAqIHQueSArIHRoaXMueiAqIHQuejsKICAgIH0KICAgIC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD8KICAgIGxlbmd0aFNxKCkgewogICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56OwogICAgfQogICAgbGVuZ3RoKCkgewogICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueik7CiAgICB9CiAgICBtYW5oYXR0YW5MZW5ndGgoKSB7CiAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLngpICsgTWF0aC5hYnModGhpcy55KSArIE1hdGguYWJzKHRoaXMueik7CiAgICB9CiAgICBub3JtYWxpemUoKSB7CiAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpIHx8IDEpOwogICAgfQogICAgc2V0TGVuZ3RoKHQpIHsKICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIodCk7CiAgICB9CiAgICBsZXJwKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMueCArPSAodC54IC0gdGhpcy54KSAqIGUsIHRoaXMueSArPSAodC55IC0gdGhpcy55KSAqIGUsIHRoaXMueiArPSAodC56IC0gdGhpcy56KSAqIGUsIHRoaXM7CiAgICB9CiAgICBsZXJwVmVjdG9ycyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LnggKyAoZS54IC0gdC54KSAqIGksIHRoaXMueSA9IHQueSArIChlLnkgLSB0LnkpICogaSwgdGhpcy56ID0gdC56ICsgKGUueiAtIHQueikgKiBpLCB0aGlzOwogICAgfQogICAgY3Jvc3ModCkgewogICAgICByZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnModGhpcywgdCk7CiAgICB9CiAgICBjcm9zc1ZlY3RvcnModCwgZSkgewogICAgICBjb25zdCBpID0gdC54LCBzID0gdC55LCByID0gdC56LCBuID0gZS54LCBhID0gZS55LCBvID0gZS56OwogICAgICByZXR1cm4gdGhpcy54ID0gcyAqIG8gLSByICogYSwgdGhpcy55ID0gciAqIG4gLSBpICogbywgdGhpcy56ID0gaSAqIGEgLSBzICogbiwgdGhpczsKICAgIH0KICAgIHByb2plY3RPblZlY3Rvcih0KSB7CiAgICAgIGNvbnN0IGUgPSB0Lmxlbmd0aFNxKCk7CiAgICAgIGlmIChlID09PSAwKSByZXR1cm4gdGhpcy5zZXQoMCwgMCwgMCk7CiAgICAgIGNvbnN0IGkgPSB0LmRvdCh0aGlzKSAvIGU7CiAgICAgIHJldHVybiB0aGlzLmNvcHkodCkubXVsdGlwbHlTY2FsYXIoaSk7CiAgICB9CiAgICBwcm9qZWN0T25QbGFuZSh0KSB7CiAgICAgIHJldHVybiBzZS5jb3B5KHRoaXMpLnByb2plY3RPblZlY3Rvcih0KSwgdGhpcy5zdWIoc2UpOwogICAgfQogICAgcmVmbGVjdCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnN1YihzZS5jb3B5KHQpLm11bHRpcGx5U2NhbGFyKDIgKiB0aGlzLmRvdCh0KSkpOwogICAgfQogICAgYW5nbGVUbyh0KSB7CiAgICAgIGNvbnN0IGUgPSBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcSgpICogdC5sZW5ndGhTcSgpKTsKICAgICAgaWYgKGUgPT09IDApIHJldHVybiBNYXRoLlBJIC8gMjsKICAgICAgY29uc3QgaSA9IHRoaXMuZG90KHQpIC8gZTsKICAgICAgcmV0dXJuIE1hdGguYWNvcyhUKGksIC0xLCAxKSk7CiAgICB9CiAgICBkaXN0YW5jZVRvKHQpIHsKICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHQpKTsKICAgIH0KICAgIGRpc3RhbmNlVG9TcXVhcmVkKHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMueCAtIHQueCwgaSA9IHRoaXMueSAtIHQueSwgcyA9IHRoaXMueiAtIHQuejsKICAgICAgcmV0dXJuIGUgKiBlICsgaSAqIGkgKyBzICogczsKICAgIH0KICAgIG1hbmhhdHRhbkRpc3RhbmNlVG8odCkgewogICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdC54KSArIE1hdGguYWJzKHRoaXMueSAtIHQueSkgKyBNYXRoLmFicyh0aGlzLnogLSB0LnopOwogICAgfQogICAgc2V0RnJvbVNwaGVyaWNhbCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnNldEZyb21TcGhlcmljYWxDb29yZHModC5yYWRpdXMsIHQucGhpLCB0LnRoZXRhKTsKICAgIH0KICAgIHNldEZyb21TcGhlcmljYWxDb29yZHModCwgZSwgaSkgewogICAgICBjb25zdCBzID0gTWF0aC5zaW4oZSkgKiB0OwogICAgICByZXR1cm4gdGhpcy54ID0gcyAqIE1hdGguc2luKGkpLCB0aGlzLnkgPSBNYXRoLmNvcyhlKSAqIHQsIHRoaXMueiA9IHMgKiBNYXRoLmNvcyhpKSwgdGhpczsKICAgIH0KICAgIHNldEZyb21DeWxpbmRyaWNhbCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LnJhZGl1cywgdC50aGV0YSwgdC55KTsKICAgIH0KICAgIHNldEZyb21DeWxpbmRyaWNhbENvb3Jkcyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0ICogTWF0aC5zaW4oZSksIHRoaXMueSA9IGksIHRoaXMueiA9IHQgKiBNYXRoLmNvcyhlKSwgdGhpczsKICAgIH0KICAgIHNldEZyb21NYXRyaXhQb3NpdGlvbih0KSB7CiAgICAgIGNvbnN0IGUgPSB0LmVsZW1lbnRzOwogICAgICByZXR1cm4gdGhpcy54ID0gZVsxMl0sIHRoaXMueSA9IGVbMTNdLCB0aGlzLnogPSBlWzE0XSwgdGhpczsKICAgIH0KICAgIHNldEZyb21NYXRyaXhTY2FsZSh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwgMCkubGVuZ3RoKCksIGkgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwgMSkubGVuZ3RoKCksIHMgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4odCwgMikubGVuZ3RoKCk7CiAgICAgIHJldHVybiB0aGlzLnggPSBlLCB0aGlzLnkgPSBpLCB0aGlzLnogPSBzLCB0aGlzOwogICAgfQogICAgc2V0RnJvbU1hdHJpeENvbHVtbih0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBlICogNCk7CiAgICB9CiAgICBzZXRGcm9tTWF0cml4M0NvbHVtbih0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheSh0LmVsZW1lbnRzLCBlICogMyk7CiAgICB9CiAgICBzZXRGcm9tRXVsZXIodCkgewogICAgICByZXR1cm4gdGhpcy54ID0gdC5feCwgdGhpcy55ID0gdC5feSwgdGhpcy56ID0gdC5feiwgdGhpczsKICAgIH0KICAgIHNldEZyb21Db2xvcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0LnIsIHRoaXMueSA9IHQuZywgdGhpcy56ID0gdC5iLCB0aGlzOwogICAgfQogICAgZXF1YWxzKHQpIHsKICAgICAgcmV0dXJuIHQueCA9PT0gdGhpcy54ICYmIHQueSA9PT0gdGhpcy55ICYmIHQueiA9PT0gdGhpcy56OwogICAgfQogICAgZnJvbUFycmF5KHQsIGUgPSAwKSB7CiAgICAgIHJldHVybiB0aGlzLnggPSB0W2VdLCB0aGlzLnkgPSB0W2UgKyAxXSwgdGhpcy56ID0gdFtlICsgMl0sIHRoaXM7CiAgICB9CiAgICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRbZV0gPSB0aGlzLngsIHRbZSArIDFdID0gdGhpcy55LCB0W2UgKyAyXSA9IHRoaXMueiwgdDsKICAgIH0KICAgIGZyb21CdWZmZXJBdHRyaWJ1dGUodCwgZSkgewogICAgICByZXR1cm4gdGhpcy54ID0gdC5nZXRYKGUpLCB0aGlzLnkgPSB0LmdldFkoZSksIHRoaXMueiA9IHQuZ2V0WihlKSwgdGhpczsKICAgIH0KICAgIHJhbmRvbSgpIHsKICAgICAgcmV0dXJuIHRoaXMueCA9IE1hdGgucmFuZG9tKCksIHRoaXMueSA9IE1hdGgucmFuZG9tKCksIHRoaXMueiA9IE1hdGgucmFuZG9tKCksIHRoaXM7CiAgICB9CiAgICByYW5kb21EaXJlY3Rpb24oKSB7CiAgICAgIGNvbnN0IHQgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDIsIGUgPSBNYXRoLnJhbmRvbSgpICogMiAtIDEsIGkgPSBNYXRoLnNxcnQoMSAtIGUgKiBlKTsKICAgICAgcmV0dXJuIHRoaXMueCA9IGkgKiBNYXRoLmNvcyh0KSwgdGhpcy55ID0gZSwgdGhpcy56ID0gaSAqIE1hdGguc2luKHQpLCB0aGlzOwogICAgfQogICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICB5aWVsZCB0aGlzLngsIHlpZWxkIHRoaXMueSwgeWllbGQgdGhpcy56OwogICAgfQogIH0KICBjb25zdCBzZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLCBiZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTHQoKTsKICBjbGFzcyBQdCB7CiAgICBjb25zdHJ1Y3Rvcih0ID0gbmV3IGcoMSAvIDAsIDEgLyAwLCAxIC8gMCksIGUgPSBuZXcgZygtMSAvIDAsIC0xIC8gMCwgLTEgLyAwKSkgewogICAgICB0aGlzLmlzQm94MyA9ICEwLCB0aGlzLm1pbiA9IHQsIHRoaXMubWF4ID0gZTsKICAgIH0KICAgIHNldCh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLm1pbi5jb3B5KHQpLCB0aGlzLm1heC5jb3B5KGUpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbUFycmF5KHQpIHsKICAgICAgdGhpcy5tYWtlRW1wdHkoKTsKICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0Lmxlbmd0aDsgZSA8IGk7IGUgKz0gMykKICAgICAgICB0aGlzLmV4cGFuZEJ5UG9pbnQoJC5mcm9tQXJyYXkodCwgZSkpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIHNldEZyb21CdWZmZXJBdHRyaWJ1dGUodCkgewogICAgICB0aGlzLm1ha2VFbXB0eSgpOwogICAgICBmb3IgKGxldCBlID0gMCwgaSA9IHQuY291bnQ7IGUgPCBpOyBlKyspCiAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KCQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBlKSk7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgc2V0RnJvbVBvaW50cyh0KSB7CiAgICAgIHRoaXMubWFrZUVtcHR5KCk7CiAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdC5sZW5ndGg7IGUgPCBpOyBlKyspCiAgICAgICAgdGhpcy5leHBhbmRCeVBvaW50KHRbZV0pOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIHNldEZyb21DZW50ZXJBbmRTaXplKHQsIGUpIHsKICAgICAgY29uc3QgaSA9ICQuY29weShlKS5tdWx0aXBseVNjYWxhcigwLjUpOwogICAgICByZXR1cm4gdGhpcy5taW4uY29weSh0KS5zdWIoaSksIHRoaXMubWF4LmNvcHkodCkuYWRkKGkpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbU9iamVjdCh0LCBlID0gITEpIHsKICAgICAgcmV0dXJuIHRoaXMubWFrZUVtcHR5KCksIHRoaXMuZXhwYW5kQnlPYmplY3QodCwgZSk7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTsKICAgIH0KICAgIGNvcHkodCkgewogICAgICByZXR1cm4gdGhpcy5taW4uY29weSh0Lm1pbiksIHRoaXMubWF4LmNvcHkodC5tYXgpLCB0aGlzOwogICAgfQogICAgbWFrZUVtcHR5KCkgewogICAgICByZXR1cm4gdGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gMSAvIDAsIHRoaXMubWF4LnggPSB0aGlzLm1heC55ID0gdGhpcy5tYXgueiA9IC0xIC8gMCwgdGhpczsKICAgIH0KICAgIGlzRW1wdHkoKSB7CiAgICAgIHJldHVybiB0aGlzLm1heC54IDwgdGhpcy5taW4ueCB8fCB0aGlzLm1heC55IDwgdGhpcy5taW4ueSB8fCB0aGlzLm1heC56IDwgdGhpcy5taW4uejsKICAgIH0KICAgIGdldENlbnRlcih0KSB7CiAgICAgIHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHQuc2V0KDAsIDAsIDApIDogdC5hZGRWZWN0b3JzKHRoaXMubWluLCB0aGlzLm1heCkubXVsdGlwbHlTY2FsYXIoMC41KTsKICAgIH0KICAgIGdldFNpemUodCkgewogICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0LnNldCgwLCAwLCAwKSA6IHQuc3ViVmVjdG9ycyh0aGlzLm1heCwgdGhpcy5taW4pOwogICAgfQogICAgZXhwYW5kQnlQb2ludCh0KSB7CiAgICAgIHJldHVybiB0aGlzLm1pbi5taW4odCksIHRoaXMubWF4Lm1heCh0KSwgdGhpczsKICAgIH0KICAgIGV4cGFuZEJ5VmVjdG9yKHQpIHsKICAgICAgcmV0dXJuIHRoaXMubWluLnN1Yih0KSwgdGhpcy5tYXguYWRkKHQpLCB0aGlzOwogICAgfQogICAgZXhwYW5kQnlTY2FsYXIodCkgewogICAgICByZXR1cm4gdGhpcy5taW4uYWRkU2NhbGFyKC10KSwgdGhpcy5tYXguYWRkU2NhbGFyKHQpLCB0aGlzOwogICAgfQogICAgZXhwYW5kQnlPYmplY3QodCwgZSA9ICExKSB7CiAgICAgIHQudXBkYXRlV29ybGRNYXRyaXgoITEsICExKTsKICAgICAgY29uc3QgaSA9IHQuZ2VvbWV0cnk7CiAgICAgIGlmIChpICE9PSB2b2lkIDApIHsKICAgICAgICBjb25zdCByID0gaS5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7CiAgICAgICAgaWYgKGUgPT09ICEwICYmIHIgIT09IHZvaWQgMCAmJiB0LmlzSW5zdGFuY2VkTWVzaCAhPT0gITApCiAgICAgICAgICBmb3IgKGxldCBuID0gMCwgYSA9IHIuY291bnQ7IG4gPCBhOyBuKyspCiAgICAgICAgICAgIHQuaXNNZXNoID09PSAhMCA/IHQuZ2V0VmVydGV4UG9zaXRpb24obiwgJCkgOiAkLmZyb21CdWZmZXJBdHRyaWJ1dGUociwgbiksICQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLCB0aGlzLmV4cGFuZEJ5UG9pbnQoJCk7CiAgICAgICAgZWxzZQogICAgICAgICAgdC5ib3VuZGluZ0JveCAhPT0gdm9pZCAwID8gKHQuYm91bmRpbmdCb3ggPT09IG51bGwgJiYgdC5jb21wdXRlQm91bmRpbmdCb3goKSwgVXQuY29weSh0LmJvdW5kaW5nQm94KSkgOiAoaS5ib3VuZGluZ0JveCA9PT0gbnVsbCAmJiBpLmNvbXB1dGVCb3VuZGluZ0JveCgpLCBVdC5jb3B5KGkuYm91bmRpbmdCb3gpKSwgVXQuYXBwbHlNYXRyaXg0KHQubWF0cml4V29ybGQpLCB0aGlzLnVuaW9uKFV0KTsKICAgICAgfQogICAgICBjb25zdCBzID0gdC5jaGlsZHJlbjsKICAgICAgZm9yIChsZXQgciA9IDAsIG4gPSBzLmxlbmd0aDsgciA8IG47IHIrKykKICAgICAgICB0aGlzLmV4cGFuZEJ5T2JqZWN0KHNbcl0sIGUpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIGNvbnRhaW5zUG9pbnQodCkgewogICAgICByZXR1cm4gdC54ID49IHRoaXMubWluLnggJiYgdC54IDw9IHRoaXMubWF4LnggJiYgdC55ID49IHRoaXMubWluLnkgJiYgdC55IDw9IHRoaXMubWF4LnkgJiYgdC56ID49IHRoaXMubWluLnogJiYgdC56IDw9IHRoaXMubWF4Lno7CiAgICB9CiAgICBjb250YWluc0JveCh0KSB7CiAgICAgIHJldHVybiB0aGlzLm1pbi54IDw9IHQubWluLnggJiYgdC5tYXgueCA8PSB0aGlzLm1heC54ICYmIHRoaXMubWluLnkgPD0gdC5taW4ueSAmJiB0Lm1heC55IDw9IHRoaXMubWF4LnkgJiYgdGhpcy5taW4ueiA8PSB0Lm1pbi56ICYmIHQubWF4LnogPD0gdGhpcy5tYXguejsKICAgIH0KICAgIGdldFBhcmFtZXRlcih0LCBlKSB7CiAgICAgIHJldHVybiBlLnNldCgKICAgICAgICAodC54IC0gdGhpcy5taW4ueCkgLyAodGhpcy5tYXgueCAtIHRoaXMubWluLngpLAogICAgICAgICh0LnkgLSB0aGlzLm1pbi55KSAvICh0aGlzLm1heC55IC0gdGhpcy5taW4ueSksCiAgICAgICAgKHQueiAtIHRoaXMubWluLnopIC8gKHRoaXMubWF4LnogLSB0aGlzLm1pbi56KQogICAgICApOwogICAgfQogICAgaW50ZXJzZWN0c0JveCh0KSB7CiAgICAgIHJldHVybiB0Lm1heC54ID49IHRoaXMubWluLnggJiYgdC5taW4ueCA8PSB0aGlzLm1heC54ICYmIHQubWF4LnkgPj0gdGhpcy5taW4ueSAmJiB0Lm1pbi55IDw9IHRoaXMubWF4LnkgJiYgdC5tYXgueiA+PSB0aGlzLm1pbi56ICYmIHQubWluLnogPD0gdGhpcy5tYXguejsKICAgIH0KICAgIGludGVyc2VjdHNTcGhlcmUodCkgewogICAgICByZXR1cm4gdGhpcy5jbGFtcFBvaW50KHQuY2VudGVyLCAkKSwgJC5kaXN0YW5jZVRvU3F1YXJlZCh0LmNlbnRlcikgPD0gdC5yYWRpdXMgKiB0LnJhZGl1czsKICAgIH0KICAgIGludGVyc2VjdHNQbGFuZSh0KSB7CiAgICAgIGxldCBlLCBpOwogICAgICByZXR1cm4gdC5ub3JtYWwueCA+IDAgPyAoZSA9IHQubm9ybWFsLnggKiB0aGlzLm1pbi54LCBpID0gdC5ub3JtYWwueCAqIHRoaXMubWF4LngpIDogKGUgPSB0Lm5vcm1hbC54ICogdGhpcy5tYXgueCwgaSA9IHQubm9ybWFsLnggKiB0aGlzLm1pbi54KSwgdC5ub3JtYWwueSA+IDAgPyAoZSArPSB0Lm5vcm1hbC55ICogdGhpcy5taW4ueSwgaSArPSB0Lm5vcm1hbC55ICogdGhpcy5tYXgueSkgOiAoZSArPSB0Lm5vcm1hbC55ICogdGhpcy5tYXgueSwgaSArPSB0Lm5vcm1hbC55ICogdGhpcy5taW4ueSksIHQubm9ybWFsLnogPiAwID8gKGUgKz0gdC5ub3JtYWwueiAqIHRoaXMubWluLnosIGkgKz0gdC5ub3JtYWwueiAqIHRoaXMubWF4LnopIDogKGUgKz0gdC5ub3JtYWwueiAqIHRoaXMubWF4LnosIGkgKz0gdC5ub3JtYWwueiAqIHRoaXMubWluLnopLCBlIDw9IC10LmNvbnN0YW50ICYmIGkgPj0gLXQuY29uc3RhbnQ7CiAgICB9CiAgICBpbnRlcnNlY3RzVHJpYW5nbGUodCkgewogICAgICBpZiAodGhpcy5pc0VtcHR5KCkpCiAgICAgICAgcmV0dXJuICExOwogICAgICB0aGlzLmdldENlbnRlcihFdCksIE50LnN1YlZlY3RvcnModGhpcy5tYXgsIEV0KSwgYnQuc3ViVmVjdG9ycyh0LmEsIEV0KSwgX3Quc3ViVmVjdG9ycyh0LmIsIEV0KSwgd3Quc3ViVmVjdG9ycyh0LmMsIEV0KSwgb3Quc3ViVmVjdG9ycyhfdCwgYnQpLCBodC5zdWJWZWN0b3JzKHd0LCBfdCksIGZ0LnN1YlZlY3RvcnMoYnQsIHd0KTsKICAgICAgbGV0IGUgPSBbCiAgICAgICAgMCwKICAgICAgICAtb3QueiwKICAgICAgICBvdC55LAogICAgICAgIDAsCiAgICAgICAgLWh0LnosCiAgICAgICAgaHQueSwKICAgICAgICAwLAogICAgICAgIC1mdC56LAogICAgICAgIGZ0LnksCiAgICAgICAgb3QueiwKICAgICAgICAwLAogICAgICAgIC1vdC54LAogICAgICAgIGh0LnosCiAgICAgICAgMCwKICAgICAgICAtaHQueCwKICAgICAgICBmdC56LAogICAgICAgIDAsCiAgICAgICAgLWZ0LngsCiAgICAgICAgLW90LnksCiAgICAgICAgb3QueCwKICAgICAgICAwLAogICAgICAgIC1odC55LAogICAgICAgIGh0LngsCiAgICAgICAgMCwKICAgICAgICAtZnQueSwKICAgICAgICBmdC54LAogICAgICAgIDAKICAgICAgXTsKICAgICAgcmV0dXJuICFyZShlLCBidCwgX3QsIHd0LCBOdCkgfHwgKGUgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0sICFyZShlLCBidCwgX3QsIHd0LCBOdCkpID8gITEgOiAoT3QuY3Jvc3NWZWN0b3JzKG90LCBodCksIGUgPSBbT3QueCwgT3QueSwgT3Quel0sIHJlKGUsIGJ0LCBfdCwgd3QsIE50KSk7CiAgICB9CiAgICBjbGFtcFBvaW50KHQsIGUpIHsKICAgICAgcmV0dXJuIGUuY29weSh0KS5jbGFtcCh0aGlzLm1pbiwgdGhpcy5tYXgpOwogICAgfQogICAgZGlzdGFuY2VUb1BvaW50KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuY2xhbXBQb2ludCh0LCAkKS5kaXN0YW5jZVRvKHQpOwogICAgfQogICAgZ2V0Qm91bmRpbmdTcGhlcmUodCkgewogICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyB0Lm1ha2VFbXB0eSgpIDogKHRoaXMuZ2V0Q2VudGVyKHQuY2VudGVyKSwgdC5yYWRpdXMgPSB0aGlzLmdldFNpemUoJCkubGVuZ3RoKCkgKiAwLjUpLCB0OwogICAgfQogICAgaW50ZXJzZWN0KHQpIHsKICAgICAgcmV0dXJuIHRoaXMubWluLm1heCh0Lm1pbiksIHRoaXMubWF4Lm1pbih0Lm1heCksIHRoaXMuaXNFbXB0eSgpICYmIHRoaXMubWFrZUVtcHR5KCksIHRoaXM7CiAgICB9CiAgICB1bmlvbih0KSB7CiAgICAgIHJldHVybiB0aGlzLm1pbi5taW4odC5taW4pLCB0aGlzLm1heC5tYXgodC5tYXgpLCB0aGlzOwogICAgfQogICAgYXBwbHlNYXRyaXg0KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gdGhpcyA6IChldFswXS5zZXQodGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLCBldFsxXS5zZXQodGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLCBldFsyXS5zZXQodGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLCBldFszXS5zZXQodGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLCBldFs0XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLCBldFs1XS5zZXQodGhpcy5tYXgueCwgdGhpcy5taW4ueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLCBldFs2XS5zZXQodGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueikuYXBwbHlNYXRyaXg0KHQpLCBldFs3XS5zZXQodGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueikuYXBwbHlNYXRyaXg0KHQpLCB0aGlzLnNldEZyb21Qb2ludHMoZXQpLCB0aGlzKTsKICAgIH0KICAgIHRyYW5zbGF0ZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLm1pbi5hZGQodCksIHRoaXMubWF4LmFkZCh0KSwgdGhpczsKICAgIH0KICAgIGVxdWFscyh0KSB7CiAgICAgIHJldHVybiB0Lm1pbi5lcXVhbHModGhpcy5taW4pICYmIHQubWF4LmVxdWFscyh0aGlzLm1heCk7CiAgICB9CiAgfQogIGNvbnN0IGV0ID0gWwogICAgLyogQF9fUFVSRV9fICovIG5ldyBnKCksCiAgICAvKiBAX19QVVJFX18gKi8gbmV3IGcoKSwKICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLAogICAgLyogQF9fUFVSRV9fICovIG5ldyBnKCksCiAgICAvKiBAX19QVVJFX18gKi8gbmV3IGcoKSwKICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLAogICAgLyogQF9fUFVSRV9fICovIG5ldyBnKCksCiAgICAvKiBAX19QVVJFX18gKi8gbmV3IGcoKQogIF0sICQgPSAvKiBAX19QVVJFX18gKi8gbmV3IGcoKSwgVXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFB0KCksIGJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIF90ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIHd0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIG90ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIGh0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIGZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIEV0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIE50ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIE90ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIHB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCk7CiAgZnVuY3Rpb24gcmUoZiwgdCwgZSwgaSwgcykgewogICAgZm9yIChsZXQgciA9IDAsIG4gPSBmLmxlbmd0aCAtIDM7IHIgPD0gbjsgciArPSAzKSB7CiAgICAgIHB0LmZyb21BcnJheShmLCByKTsKICAgICAgY29uc3QgYSA9IHMueCAqIE1hdGguYWJzKHB0LngpICsgcy55ICogTWF0aC5hYnMocHQueSkgKyBzLnogKiBNYXRoLmFicyhwdC56KSwgbyA9IHQuZG90KHB0KSwgaCA9IGUuZG90KHB0KSwgdSA9IGkuZG90KHB0KTsKICAgICAgaWYgKE1hdGgubWF4KC1NYXRoLm1heChvLCBoLCB1KSwgTWF0aC5taW4obywgaCwgdSkpID4gYSkKICAgICAgICByZXR1cm4gITE7CiAgICB9CiAgICByZXR1cm4gITA7CiAgfQogIGNvbnN0IFllID0gLyogQF9fUFVSRV9fICovIG5ldyBQdCgpLCBrdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLCBuZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpOwogIGNsYXNzIEhlIHsKICAgIGNvbnN0cnVjdG9yKHQgPSBuZXcgZygpLCBlID0gLTEpIHsKICAgICAgdGhpcy5pc1NwaGVyZSA9ICEwLCB0aGlzLmNlbnRlciA9IHQsIHRoaXMucmFkaXVzID0gZTsKICAgIH0KICAgIHNldCh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLmNlbnRlci5jb3B5KHQpLCB0aGlzLnJhZGl1cyA9IGUsIHRoaXM7CiAgICB9CiAgICBzZXRGcm9tUG9pbnRzKHQsIGUpIHsKICAgICAgY29uc3QgaSA9IHRoaXMuY2VudGVyOwogICAgICBlICE9PSB2b2lkIDAgPyBpLmNvcHkoZSkgOiBZZS5zZXRGcm9tUG9pbnRzKHQpLmdldENlbnRlcihpKTsKICAgICAgbGV0IHMgPSAwOwogICAgICBmb3IgKGxldCByID0gMCwgbiA9IHQubGVuZ3RoOyByIDwgbjsgcisrKQogICAgICAgIHMgPSBNYXRoLm1heChzLCBpLmRpc3RhbmNlVG9TcXVhcmVkKHRbcl0pKTsKICAgICAgcmV0dXJuIHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KHMpLCB0aGlzOwogICAgfQogICAgY29weSh0KSB7CiAgICAgIHJldHVybiB0aGlzLmNlbnRlci5jb3B5KHQuY2VudGVyKSwgdGhpcy5yYWRpdXMgPSB0LnJhZGl1cywgdGhpczsKICAgIH0KICAgIGlzRW1wdHkoKSB7CiAgICAgIHJldHVybiB0aGlzLnJhZGl1cyA8IDA7CiAgICB9CiAgICBtYWtlRW1wdHkoKSB7CiAgICAgIHJldHVybiB0aGlzLmNlbnRlci5zZXQoMCwgMCwgMCksIHRoaXMucmFkaXVzID0gLTEsIHRoaXM7CiAgICB9CiAgICBjb250YWluc1BvaW50KHQpIHsKICAgICAgcmV0dXJuIHQuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpIDw9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7CiAgICB9CiAgICBkaXN0YW5jZVRvUG9pbnQodCkgewogICAgICByZXR1cm4gdC5kaXN0YW5jZVRvKHRoaXMuY2VudGVyKSAtIHRoaXMucmFkaXVzOwogICAgfQogICAgaW50ZXJzZWN0c1NwaGVyZSh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLnJhZGl1cyArIHQucmFkaXVzOwogICAgICByZXR1cm4gdC5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodGhpcy5jZW50ZXIpIDw9IGUgKiBlOwogICAgfQogICAgaW50ZXJzZWN0c0JveCh0KSB7CiAgICAgIHJldHVybiB0LmludGVyc2VjdHNTcGhlcmUodGhpcyk7CiAgICB9CiAgICBpbnRlcnNlY3RzUGxhbmUodCkgewogICAgICByZXR1cm4gTWF0aC5hYnModC5kaXN0YW5jZVRvUG9pbnQodGhpcy5jZW50ZXIpKSA8PSB0aGlzLnJhZGl1czsKICAgIH0KICAgIGNsYW1wUG9pbnQodCwgZSkgewogICAgICBjb25zdCBpID0gdGhpcy5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQodCk7CiAgICAgIHJldHVybiBlLmNvcHkodCksIGkgPiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICYmIChlLnN1Yih0aGlzLmNlbnRlcikubm9ybWFsaXplKCksIGUubXVsdGlwbHlTY2FsYXIodGhpcy5yYWRpdXMpLmFkZCh0aGlzLmNlbnRlcikpLCBlOwogICAgfQogICAgZ2V0Qm91bmRpbmdCb3godCkgewogICAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyAodC5tYWtlRW1wdHkoKSwgdCkgOiAodC5zZXQodGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyKSwgdC5leHBhbmRCeVNjYWxhcih0aGlzLnJhZGl1cyksIHQpOwogICAgfQogICAgYXBwbHlNYXRyaXg0KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuY2VudGVyLmFwcGx5TWF0cml4NCh0KSwgdGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIHQuZ2V0TWF4U2NhbGVPbkF4aXMoKSwgdGhpczsKICAgIH0KICAgIHRyYW5zbGF0ZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLmNlbnRlci5hZGQodCksIHRoaXM7CiAgICB9CiAgICBleHBhbmRCeVBvaW50KHQpIHsKICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKQogICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5jb3B5KHQpLCB0aGlzLnJhZGl1cyA9IDAsIHRoaXM7CiAgICAgIGt0LnN1YlZlY3RvcnModCwgdGhpcy5jZW50ZXIpOwogICAgICBjb25zdCBlID0ga3QubGVuZ3RoU3EoKTsKICAgICAgaWYgKGUgPiB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzKSB7CiAgICAgICAgY29uc3QgaSA9IE1hdGguc3FydChlKSwgcyA9IChpIC0gdGhpcy5yYWRpdXMpICogMC41OwogICAgICAgIHRoaXMuY2VudGVyLmFkZFNjYWxlZFZlY3RvcihrdCwgcyAvIGkpLCB0aGlzLnJhZGl1cyArPSBzOwogICAgICB9CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgdW5pb24odCkgewogICAgICByZXR1cm4gdC5pc0VtcHR5KCkgPyB0aGlzIDogdGhpcy5pc0VtcHR5KCkgPyAodGhpcy5jb3B5KHQpLCB0aGlzKSA6ICh0aGlzLmNlbnRlci5lcXVhbHModC5jZW50ZXIpID09PSAhMCA/IHRoaXMucmFkaXVzID0gTWF0aC5tYXgodGhpcy5yYWRpdXMsIHQucmFkaXVzKSA6IChuZS5zdWJWZWN0b3JzKHQuY2VudGVyLCB0aGlzLmNlbnRlcikuc2V0TGVuZ3RoKHQucmFkaXVzKSwgdGhpcy5leHBhbmRCeVBvaW50KGt0LmNvcHkodC5jZW50ZXIpLmFkZChuZSkpLCB0aGlzLmV4cGFuZEJ5UG9pbnQoa3QuY29weSh0LmNlbnRlcikuc3ViKG5lKSkpLCB0aGlzKTsKICAgIH0KICAgIGVxdWFscyh0KSB7CiAgICAgIHJldHVybiB0LmNlbnRlci5lcXVhbHModGhpcy5jZW50ZXIpICYmIHQucmFkaXVzID09PSB0aGlzLnJhZGl1czsKICAgIH0KICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpOwogICAgfQogIH0KICBjbGFzcyB0dCB7CiAgICBjb25zdHJ1Y3Rvcih0LCBlLCBpLCBzLCByLCBuLCBhLCBvLCBoLCB1LCBsLCBkLCBjLCBtLCB5LCB4KSB7CiAgICAgIHR0LnByb3RvdHlwZS5pc01hdHJpeDQgPSAhMCwgdGhpcy5lbGVtZW50cyA9IFsKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgIF0sIHQgIT09IHZvaWQgMCAmJiB0aGlzLnNldCh0LCBlLCBpLCBzLCByLCBuLCBhLCBvLCBoLCB1LCBsLCBkLCBjLCBtLCB5LCB4KTsKICAgIH0KICAgIHNldCh0LCBlLCBpLCBzLCByLCBuLCBhLCBvLCBoLCB1LCBsLCBkLCBjLCBtLCB5LCB4KSB7CiAgICAgIGNvbnN0IHAgPSB0aGlzLmVsZW1lbnRzOwogICAgICByZXR1cm4gcFswXSA9IHQsIHBbNF0gPSBlLCBwWzhdID0gaSwgcFsxMl0gPSBzLCBwWzFdID0gciwgcFs1XSA9IG4sIHBbOV0gPSBhLCBwWzEzXSA9IG8sIHBbMl0gPSBoLCBwWzZdID0gdSwgcFsxMF0gPSBsLCBwWzE0XSA9IGQsIHBbM10gPSBjLCBwWzddID0gbSwgcFsxMV0gPSB5LCBwWzE1XSA9IHgsIHRoaXM7CiAgICB9CiAgICBpZGVudGl0eSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICAgIDEsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKSwgdGhpczsKICAgIH0KICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IHR0KCkuZnJvbUFycmF5KHRoaXMuZWxlbWVudHMpOwogICAgfQogICAgY29weSh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBpID0gdC5lbGVtZW50czsKICAgICAgcmV0dXJuIGVbMF0gPSBpWzBdLCBlWzFdID0gaVsxXSwgZVsyXSA9IGlbMl0sIGVbM10gPSBpWzNdLCBlWzRdID0gaVs0XSwgZVs1XSA9IGlbNV0sIGVbNl0gPSBpWzZdLCBlWzddID0gaVs3XSwgZVs4XSA9IGlbOF0sIGVbOV0gPSBpWzldLCBlWzEwXSA9IGlbMTBdLCBlWzExXSA9IGlbMTFdLCBlWzEyXSA9IGlbMTJdLCBlWzEzXSA9IGlbMTNdLCBlWzE0XSA9IGlbMTRdLCBlWzE1XSA9IGlbMTVdLCB0aGlzOwogICAgfQogICAgY29weVBvc2l0aW9uKHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHMsIGkgPSB0LmVsZW1lbnRzOwogICAgICByZXR1cm4gZVsxMl0gPSBpWzEyXSwgZVsxM10gPSBpWzEzXSwgZVsxNF0gPSBpWzE0XSwgdGhpczsKICAgIH0KICAgIHNldEZyb21NYXRyaXgzKHQpIHsKICAgICAgY29uc3QgZSA9IHQuZWxlbWVudHM7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICBlWzBdLAogICAgICAgIGVbM10sCiAgICAgICAgZVs2XSwKICAgICAgICAwLAogICAgICAgIGVbMV0sCiAgICAgICAgZVs0XSwKICAgICAgICBlWzddLAogICAgICAgIDAsCiAgICAgICAgZVsyXSwKICAgICAgICBlWzVdLAogICAgICAgIGVbOF0sCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICksIHRoaXM7CiAgICB9CiAgICBleHRyYWN0QmFzaXModCwgZSwgaSkgewogICAgICByZXR1cm4gdC5zZXRGcm9tTWF0cml4Q29sdW1uKHRoaXMsIDApLCBlLnNldEZyb21NYXRyaXhDb2x1bW4odGhpcywgMSksIGkuc2V0RnJvbU1hdHJpeENvbHVtbih0aGlzLCAyKSwgdGhpczsKICAgIH0KICAgIG1ha2VCYXNpcyh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICB0LngsCiAgICAgICAgZS54LAogICAgICAgIGkueCwKICAgICAgICAwLAogICAgICAgIHQueSwKICAgICAgICBlLnksCiAgICAgICAgaS55LAogICAgICAgIDAsCiAgICAgICAgdC56LAogICAgICAgIGUueiwKICAgICAgICBpLnosCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICksIHRoaXM7CiAgICB9CiAgICBleHRyYWN0Um90YXRpb24odCkgewogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgaSA9IHQuZWxlbWVudHMsIHMgPSAxIC8gQXQuc2V0RnJvbU1hdHJpeENvbHVtbih0LCAwKS5sZW5ndGgoKSwgciA9IDEgLyBBdC5zZXRGcm9tTWF0cml4Q29sdW1uKHQsIDEpLmxlbmd0aCgpLCBuID0gMSAvIEF0LnNldEZyb21NYXRyaXhDb2x1bW4odCwgMikubGVuZ3RoKCk7CiAgICAgIHJldHVybiBlWzBdID0gaVswXSAqIHMsIGVbMV0gPSBpWzFdICogcywgZVsyXSA9IGlbMl0gKiBzLCBlWzNdID0gMCwgZVs0XSA9IGlbNF0gKiByLCBlWzVdID0gaVs1XSAqIHIsIGVbNl0gPSBpWzZdICogciwgZVs3XSA9IDAsIGVbOF0gPSBpWzhdICogbiwgZVs5XSA9IGlbOV0gKiBuLCBlWzEwXSA9IGlbMTBdICogbiwgZVsxMV0gPSAwLCBlWzEyXSA9IDAsIGVbMTNdID0gMCwgZVsxNF0gPSAwLCBlWzE1XSA9IDEsIHRoaXM7CiAgICB9CiAgICBtYWtlUm90YXRpb25Gcm9tRXVsZXIodCkgewogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cywgaSA9IHQueCwgcyA9IHQueSwgciA9IHQueiwgbiA9IE1hdGguY29zKGkpLCBhID0gTWF0aC5zaW4oaSksIG8gPSBNYXRoLmNvcyhzKSwgaCA9IE1hdGguc2luKHMpLCB1ID0gTWF0aC5jb3MociksIGwgPSBNYXRoLnNpbihyKTsKICAgICAgaWYgKHQub3JkZXIgPT09ICJYWVoiKSB7CiAgICAgICAgY29uc3QgZCA9IG4gKiB1LCBjID0gbiAqIGwsIG0gPSBhICogdSwgeSA9IGEgKiBsOwogICAgICAgIGVbMF0gPSBvICogdSwgZVs0XSA9IC1vICogbCwgZVs4XSA9IGgsIGVbMV0gPSBjICsgbSAqIGgsIGVbNV0gPSBkIC0geSAqIGgsIGVbOV0gPSAtYSAqIG8sIGVbMl0gPSB5IC0gZCAqIGgsIGVbNl0gPSBtICsgYyAqIGgsIGVbMTBdID0gbiAqIG87CiAgICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIllYWiIpIHsKICAgICAgICBjb25zdCBkID0gbyAqIHUsIGMgPSBvICogbCwgbSA9IGggKiB1LCB5ID0gaCAqIGw7CiAgICAgICAgZVswXSA9IGQgKyB5ICogYSwgZVs0XSA9IG0gKiBhIC0gYywgZVs4XSA9IG4gKiBoLCBlWzFdID0gbiAqIGwsIGVbNV0gPSBuICogdSwgZVs5XSA9IC1hLCBlWzJdID0gYyAqIGEgLSBtLCBlWzZdID0geSArIGQgKiBhLCBlWzEwXSA9IG4gKiBvOwogICAgICB9IGVsc2UgaWYgKHQub3JkZXIgPT09ICJaWFkiKSB7CiAgICAgICAgY29uc3QgZCA9IG8gKiB1LCBjID0gbyAqIGwsIG0gPSBoICogdSwgeSA9IGggKiBsOwogICAgICAgIGVbMF0gPSBkIC0geSAqIGEsIGVbNF0gPSAtbiAqIGwsIGVbOF0gPSBtICsgYyAqIGEsIGVbMV0gPSBjICsgbSAqIGEsIGVbNV0gPSBuICogdSwgZVs5XSA9IHkgLSBkICogYSwgZVsyXSA9IC1uICogaCwgZVs2XSA9IGEsIGVbMTBdID0gbiAqIG87CiAgICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIlpZWCIpIHsKICAgICAgICBjb25zdCBkID0gbiAqIHUsIGMgPSBuICogbCwgbSA9IGEgKiB1LCB5ID0gYSAqIGw7CiAgICAgICAgZVswXSA9IG8gKiB1LCBlWzRdID0gbSAqIGggLSBjLCBlWzhdID0gZCAqIGggKyB5LCBlWzFdID0gbyAqIGwsIGVbNV0gPSB5ICogaCArIGQsIGVbOV0gPSBjICogaCAtIG0sIGVbMl0gPSAtaCwgZVs2XSA9IGEgKiBvLCBlWzEwXSA9IG4gKiBvOwogICAgICB9IGVsc2UgaWYgKHQub3JkZXIgPT09ICJZWlgiKSB7CiAgICAgICAgY29uc3QgZCA9IG4gKiBvLCBjID0gbiAqIGgsIG0gPSBhICogbywgeSA9IGEgKiBoOwogICAgICAgIGVbMF0gPSBvICogdSwgZVs0XSA9IHkgLSBkICogbCwgZVs4XSA9IG0gKiBsICsgYywgZVsxXSA9IGwsIGVbNV0gPSBuICogdSwgZVs5XSA9IC1hICogdSwgZVsyXSA9IC1oICogdSwgZVs2XSA9IGMgKiBsICsgbSwgZVsxMF0gPSBkIC0geSAqIGw7CiAgICAgIH0gZWxzZSBpZiAodC5vcmRlciA9PT0gIlhaWSIpIHsKICAgICAgICBjb25zdCBkID0gbiAqIG8sIGMgPSBuICogaCwgbSA9IGEgKiBvLCB5ID0gYSAqIGg7CiAgICAgICAgZVswXSA9IG8gKiB1LCBlWzRdID0gLWwsIGVbOF0gPSBoICogdSwgZVsxXSA9IGQgKiBsICsgeSwgZVs1XSA9IG4gKiB1LCBlWzldID0gYyAqIGwgLSBtLCBlWzJdID0gbSAqIGwgLSBjLCBlWzZdID0gYSAqIHUsIGVbMTBdID0geSAqIGwgKyBkOwogICAgICB9CiAgICAgIHJldHVybiBlWzNdID0gMCwgZVs3XSA9IDAsIGVbMTFdID0gMCwgZVsxMl0gPSAwLCBlWzEzXSA9IDAsIGVbMTRdID0gMCwgZVsxNV0gPSAxLCB0aGlzOwogICAgfQogICAgbWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCkgewogICAgICByZXR1cm4gdGhpcy5jb21wb3NlKEdlLCB0LCBYZSk7CiAgICB9CiAgICBsb29rQXQodCwgZSwgaSkgewogICAgICBjb25zdCBzID0gdGhpcy5lbGVtZW50czsKICAgICAgcmV0dXJuIEguc3ViVmVjdG9ycyh0LCBlKSwgSC5sZW5ndGhTcSgpID09PSAwICYmIChILnogPSAxKSwgSC5ub3JtYWxpemUoKSwgdXQuY3Jvc3NWZWN0b3JzKGksIEgpLCB1dC5sZW5ndGhTcSgpID09PSAwICYmIChNYXRoLmFicyhpLnopID09PSAxID8gSC54ICs9IDFlLTQgOiBILnogKz0gMWUtNCwgSC5ub3JtYWxpemUoKSwgdXQuY3Jvc3NWZWN0b3JzKGksIEgpKSwgdXQubm9ybWFsaXplKCksIFd0LmNyb3NzVmVjdG9ycyhILCB1dCksIHNbMF0gPSB1dC54LCBzWzRdID0gV3QueCwgc1s4XSA9IEgueCwgc1sxXSA9IHV0LnksIHNbNV0gPSBXdC55LCBzWzldID0gSC55LCBzWzJdID0gdXQueiwgc1s2XSA9IFd0LnosIHNbMTBdID0gSC56LCB0aGlzOwogICAgfQogICAgbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHRoaXMsIHQpOwogICAgfQogICAgcHJlbXVsdGlwbHkodCkgewogICAgICByZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKHQsIHRoaXMpOwogICAgfQogICAgbXVsdGlwbHlNYXRyaWNlcyh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSB0LmVsZW1lbnRzLCBzID0gZS5lbGVtZW50cywgciA9IHRoaXMuZWxlbWVudHMsIG4gPSBpWzBdLCBhID0gaVs0XSwgbyA9IGlbOF0sIGggPSBpWzEyXSwgdSA9IGlbMV0sIGwgPSBpWzVdLCBkID0gaVs5XSwgYyA9IGlbMTNdLCBtID0gaVsyXSwgeSA9IGlbNl0sIHggPSBpWzEwXSwgcCA9IGlbMTRdLCB6ID0gaVszXSwgRiA9IGlbN10sIEEgPSBpWzExXSwgYiA9IGlbMTVdLCBNID0gc1swXSwgXyA9IHNbNF0sIHcgPSBzWzhdLCBFID0gc1sxMl0sIEMgPSBzWzFdLCBMID0gc1s1XSwgViA9IHNbOV0sIFMgPSBzWzEzXSwgUiA9IHNbMl0sIFcgPSBzWzZdLCBQID0gc1sxMF0sIEIgPSBzWzE0XSwgcSA9IHNbM10sIGsgPSBzWzddLCBEID0gc1sxMV0sIGF0ID0gc1sxNV07CiAgICAgIHJldHVybiByWzBdID0gbiAqIE0gKyBhICogQyArIG8gKiBSICsgaCAqIHEsIHJbNF0gPSBuICogXyArIGEgKiBMICsgbyAqIFcgKyBoICogaywgcls4XSA9IG4gKiB3ICsgYSAqIFYgKyBvICogUCArIGggKiBELCByWzEyXSA9IG4gKiBFICsgYSAqIFMgKyBvICogQiArIGggKiBhdCwgclsxXSA9IHUgKiBNICsgbCAqIEMgKyBkICogUiArIGMgKiBxLCByWzVdID0gdSAqIF8gKyBsICogTCArIGQgKiBXICsgYyAqIGssIHJbOV0gPSB1ICogdyArIGwgKiBWICsgZCAqIFAgKyBjICogRCwgclsxM10gPSB1ICogRSArIGwgKiBTICsgZCAqIEIgKyBjICogYXQsIHJbMl0gPSBtICogTSArIHkgKiBDICsgeCAqIFIgKyBwICogcSwgcls2XSA9IG0gKiBfICsgeSAqIEwgKyB4ICogVyArIHAgKiBrLCByWzEwXSA9IG0gKiB3ICsgeSAqIFYgKyB4ICogUCArIHAgKiBELCByWzE0XSA9IG0gKiBFICsgeSAqIFMgKyB4ICogQiArIHAgKiBhdCwgclszXSA9IHogKiBNICsgRiAqIEMgKyBBICogUiArIGIgKiBxLCByWzddID0geiAqIF8gKyBGICogTCArIEEgKiBXICsgYiAqIGssIHJbMTFdID0geiAqIHcgKyBGICogViArIEEgKiBQICsgYiAqIEQsIHJbMTVdID0geiAqIEUgKyBGICogUyArIEEgKiBCICsgYiAqIGF0LCB0aGlzOwogICAgfQogICAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50czsKICAgICAgcmV0dXJuIGVbMF0gKj0gdCwgZVs0XSAqPSB0LCBlWzhdICo9IHQsIGVbMTJdICo9IHQsIGVbMV0gKj0gdCwgZVs1XSAqPSB0LCBlWzldICo9IHQsIGVbMTNdICo9IHQsIGVbMl0gKj0gdCwgZVs2XSAqPSB0LCBlWzEwXSAqPSB0LCBlWzE0XSAqPSB0LCBlWzNdICo9IHQsIGVbN10gKj0gdCwgZVsxMV0gKj0gdCwgZVsxNV0gKj0gdCwgdGhpczsKICAgIH0KICAgIGRldGVybWluYW50KCkgewogICAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50cywgZSA9IHRbMF0sIGkgPSB0WzRdLCBzID0gdFs4XSwgciA9IHRbMTJdLCBuID0gdFsxXSwgYSA9IHRbNV0sIG8gPSB0WzldLCBoID0gdFsxM10sIHUgPSB0WzJdLCBsID0gdFs2XSwgZCA9IHRbMTBdLCBjID0gdFsxNF0sIG0gPSB0WzNdLCB5ID0gdFs3XSwgeCA9IHRbMTFdLCBwID0gdFsxNV07CiAgICAgIHJldHVybiBtICogKCtyICogbyAqIGwgLSBzICogaCAqIGwgLSByICogYSAqIGQgKyBpICogaCAqIGQgKyBzICogYSAqIGMgLSBpICogbyAqIGMpICsgeSAqICgrZSAqIG8gKiBjIC0gZSAqIGggKiBkICsgciAqIG4gKiBkIC0gcyAqIG4gKiBjICsgcyAqIGggKiB1IC0gciAqIG8gKiB1KSArIHggKiAoK2UgKiBoICogbCAtIGUgKiBhICogYyAtIHIgKiBuICogbCArIGkgKiBuICogYyArIHIgKiBhICogdSAtIGkgKiBoICogdSkgKyBwICogKC1zICogYSAqIHUgLSBlICogbyAqIGwgKyBlICogYSAqIGQgKyBzICogbiAqIGwgLSBpICogbiAqIGQgKyBpICogbyAqIHUpOwogICAgfQogICAgdHJhbnNwb3NlKCkgewogICAgICBjb25zdCB0ID0gdGhpcy5lbGVtZW50czsKICAgICAgbGV0IGU7CiAgICAgIHJldHVybiBlID0gdFsxXSwgdFsxXSA9IHRbNF0sIHRbNF0gPSBlLCBlID0gdFsyXSwgdFsyXSA9IHRbOF0sIHRbOF0gPSBlLCBlID0gdFs2XSwgdFs2XSA9IHRbOV0sIHRbOV0gPSBlLCBlID0gdFszXSwgdFszXSA9IHRbMTJdLCB0WzEyXSA9IGUsIGUgPSB0WzddLCB0WzddID0gdFsxM10sIHRbMTNdID0gZSwgZSA9IHRbMTFdLCB0WzExXSA9IHRbMTRdLCB0WzE0XSA9IGUsIHRoaXM7CiAgICB9CiAgICBzZXRQb3NpdGlvbih0LCBlLCBpKSB7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnRzOwogICAgICByZXR1cm4gdC5pc1ZlY3RvcjMgPyAoc1sxMl0gPSB0LngsIHNbMTNdID0gdC55LCBzWzE0XSA9IHQueikgOiAoc1sxMl0gPSB0LCBzWzEzXSA9IGUsIHNbMTRdID0gaSksIHRoaXM7CiAgICB9CiAgICBpbnZlcnQoKSB7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLCBlID0gdFswXSwgaSA9IHRbMV0sIHMgPSB0WzJdLCByID0gdFszXSwgbiA9IHRbNF0sIGEgPSB0WzVdLCBvID0gdFs2XSwgaCA9IHRbN10sIHUgPSB0WzhdLCBsID0gdFs5XSwgZCA9IHRbMTBdLCBjID0gdFsxMV0sIG0gPSB0WzEyXSwgeSA9IHRbMTNdLCB4ID0gdFsxNF0sIHAgPSB0WzE1XSwgeiA9IGwgKiB4ICogaCAtIHkgKiBkICogaCArIHkgKiBvICogYyAtIGEgKiB4ICogYyAtIGwgKiBvICogcCArIGEgKiBkICogcCwgRiA9IG0gKiBkICogaCAtIHUgKiB4ICogaCAtIG0gKiBvICogYyArIG4gKiB4ICogYyArIHUgKiBvICogcCAtIG4gKiBkICogcCwgQSA9IHUgKiB5ICogaCAtIG0gKiBsICogaCArIG0gKiBhICogYyAtIG4gKiB5ICogYyAtIHUgKiBhICogcCArIG4gKiBsICogcCwgYiA9IG0gKiBsICogbyAtIHUgKiB5ICogbyAtIG0gKiBhICogZCArIG4gKiB5ICogZCArIHUgKiBhICogeCAtIG4gKiBsICogeCwgTSA9IGUgKiB6ICsgaSAqIEYgKyBzICogQSArIHIgKiBiOwogICAgICBpZiAoTSA9PT0gMCkgcmV0dXJuIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApOwogICAgICBjb25zdCBfID0gMSAvIE07CiAgICAgIHJldHVybiB0WzBdID0geiAqIF8sIHRbMV0gPSAoeSAqIGQgKiByIC0gbCAqIHggKiByIC0geSAqIHMgKiBjICsgaSAqIHggKiBjICsgbCAqIHMgKiBwIC0gaSAqIGQgKiBwKSAqIF8sIHRbMl0gPSAoYSAqIHggKiByIC0geSAqIG8gKiByICsgeSAqIHMgKiBoIC0gaSAqIHggKiBoIC0gYSAqIHMgKiBwICsgaSAqIG8gKiBwKSAqIF8sIHRbM10gPSAobCAqIG8gKiByIC0gYSAqIGQgKiByIC0gbCAqIHMgKiBoICsgaSAqIGQgKiBoICsgYSAqIHMgKiBjIC0gaSAqIG8gKiBjKSAqIF8sIHRbNF0gPSBGICogXywgdFs1XSA9ICh1ICogeCAqIHIgLSBtICogZCAqIHIgKyBtICogcyAqIGMgLSBlICogeCAqIGMgLSB1ICogcyAqIHAgKyBlICogZCAqIHApICogXywgdFs2XSA9IChtICogbyAqIHIgLSBuICogeCAqIHIgLSBtICogcyAqIGggKyBlICogeCAqIGggKyBuICogcyAqIHAgLSBlICogbyAqIHApICogXywgdFs3XSA9IChuICogZCAqIHIgLSB1ICogbyAqIHIgKyB1ICogcyAqIGggLSBlICogZCAqIGggLSBuICogcyAqIGMgKyBlICogbyAqIGMpICogXywgdFs4XSA9IEEgKiBfLCB0WzldID0gKG0gKiBsICogciAtIHUgKiB5ICogciAtIG0gKiBpICogYyArIGUgKiB5ICogYyArIHUgKiBpICogcCAtIGUgKiBsICogcCkgKiBfLCB0WzEwXSA9IChuICogeSAqIHIgLSBtICogYSAqIHIgKyBtICogaSAqIGggLSBlICogeSAqIGggLSBuICogaSAqIHAgKyBlICogYSAqIHApICogXywgdFsxMV0gPSAodSAqIGEgKiByIC0gbiAqIGwgKiByIC0gdSAqIGkgKiBoICsgZSAqIGwgKiBoICsgbiAqIGkgKiBjIC0gZSAqIGEgKiBjKSAqIF8sIHRbMTJdID0gYiAqIF8sIHRbMTNdID0gKHUgKiB5ICogcyAtIG0gKiBsICogcyArIG0gKiBpICogZCAtIGUgKiB5ICogZCAtIHUgKiBpICogeCArIGUgKiBsICogeCkgKiBfLCB0WzE0XSA9IChtICogYSAqIHMgLSBuICogeSAqIHMgLSBtICogaSAqIG8gKyBlICogeSAqIG8gKyBuICogaSAqIHggLSBlICogYSAqIHgpICogXywgdFsxNV0gPSAobiAqIGwgKiBzIC0gdSAqIGEgKiBzICsgdSAqIGkgKiBvIC0gZSAqIGwgKiBvIC0gbiAqIGkgKiBkICsgZSAqIGEgKiBkKSAqIF8sIHRoaXM7CiAgICB9CiAgICBzY2FsZSh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzLCBpID0gdC54LCBzID0gdC55LCByID0gdC56OwogICAgICByZXR1cm4gZVswXSAqPSBpLCBlWzRdICo9IHMsIGVbOF0gKj0gciwgZVsxXSAqPSBpLCBlWzVdICo9IHMsIGVbOV0gKj0gciwgZVsyXSAqPSBpLCBlWzZdICo9IHMsIGVbMTBdICo9IHIsIGVbM10gKj0gaSwgZVs3XSAqPSBzLCBlWzExXSAqPSByLCB0aGlzOwogICAgfQogICAgZ2V0TWF4U2NhbGVPbkF4aXMoKSB7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLCBlID0gdFswXSAqIHRbMF0gKyB0WzFdICogdFsxXSArIHRbMl0gKiB0WzJdLCBpID0gdFs0XSAqIHRbNF0gKyB0WzVdICogdFs1XSArIHRbNl0gKiB0WzZdLCBzID0gdFs4XSAqIHRbOF0gKyB0WzldICogdFs5XSArIHRbMTBdICogdFsxMF07CiAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoZSwgaSwgcykpOwogICAgfQogICAgbWFrZVRyYW5zbGF0aW9uKHQsIGUsIGkpIHsKICAgICAgcmV0dXJuIHQuaXNWZWN0b3IzID8gdGhpcy5zZXQoCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgdC54LAogICAgICAgIDAsCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIHQueSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMSwKICAgICAgICB0LnosCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApIDogdGhpcy5zZXQoCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgdCwKICAgICAgICAwLAogICAgICAgIDEsCiAgICAgICAgMCwKICAgICAgICBlLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxLAogICAgICAgIGksCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApLCB0aGlzOwogICAgfQogICAgbWFrZVJvdGF0aW9uWCh0KSB7CiAgICAgIGNvbnN0IGUgPSBNYXRoLmNvcyh0KSwgaSA9IE1hdGguc2luKHQpOwogICAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgICAgMSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIGUsCiAgICAgICAgLWksCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIGksCiAgICAgICAgZSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKSwgdGhpczsKICAgIH0KICAgIG1ha2VSb3RhdGlvblkodCkgewogICAgICBjb25zdCBlID0gTWF0aC5jb3ModCksIGkgPSBNYXRoLnNpbih0KTsKICAgICAgcmV0dXJuIHRoaXMuc2V0KAogICAgICAgIGUsCiAgICAgICAgMCwKICAgICAgICBpLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAtaSwKICAgICAgICAwLAogICAgICAgIGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICksIHRoaXM7CiAgICB9CiAgICBtYWtlUm90YXRpb25aKHQpIHsKICAgICAgY29uc3QgZSA9IE1hdGguY29zKHQpLCBpID0gTWF0aC5zaW4odCk7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICBlLAogICAgICAgIC1pLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICBpLAogICAgICAgIGUsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApLCB0aGlzOwogICAgfQogICAgbWFrZVJvdGF0aW9uQXhpcyh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSBNYXRoLmNvcyhlKSwgcyA9IE1hdGguc2luKGUpLCByID0gMSAtIGksIG4gPSB0LngsIGEgPSB0LnksIG8gPSB0LnosIGggPSByICogbiwgdSA9IHIgKiBhOwogICAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgICAgaCAqIG4gKyBpLAogICAgICAgIGggKiBhIC0gcyAqIG8sCiAgICAgICAgaCAqIG8gKyBzICogYSwKICAgICAgICAwLAogICAgICAgIGggKiBhICsgcyAqIG8sCiAgICAgICAgdSAqIGEgKyBpLAogICAgICAgIHUgKiBvIC0gcyAqIG4sCiAgICAgICAgMCwKICAgICAgICBoICogbyAtIHMgKiBhLAogICAgICAgIHUgKiBvICsgcyAqIG4sCiAgICAgICAgciAqIG8gKiBvICsgaSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDEKICAgICAgKSwgdGhpczsKICAgIH0KICAgIG1ha2VTY2FsZSh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLnNldCgKICAgICAgICB0LAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgZSwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIGksCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAxCiAgICAgICksIHRoaXM7CiAgICB9CiAgICBtYWtlU2hlYXIodCwgZSwgaSwgcywgciwgbikgewogICAgICByZXR1cm4gdGhpcy5zZXQoCiAgICAgICAgMSwKICAgICAgICBpLAogICAgICAgIHIsCiAgICAgICAgMCwKICAgICAgICB0LAogICAgICAgIDEsCiAgICAgICAgbiwKICAgICAgICAwLAogICAgICAgIGUsCiAgICAgICAgcywKICAgICAgICAxLAogICAgICAgIDAsCiAgICAgICAgMCwKICAgICAgICAwLAogICAgICAgIDAsCiAgICAgICAgMQogICAgICApLCB0aGlzOwogICAgfQogICAgY29tcG9zZSh0LCBlLCBpKSB7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmVsZW1lbnRzLCByID0gZS5feCwgbiA9IGUuX3ksIGEgPSBlLl96LCBvID0gZS5fdywgaCA9IHIgKyByLCB1ID0gbiArIG4sIGwgPSBhICsgYSwgZCA9IHIgKiBoLCBjID0gciAqIHUsIG0gPSByICogbCwgeSA9IG4gKiB1LCB4ID0gbiAqIGwsIHAgPSBhICogbCwgeiA9IG8gKiBoLCBGID0gbyAqIHUsIEEgPSBvICogbCwgYiA9IGkueCwgTSA9IGkueSwgXyA9IGkuejsKICAgICAgcmV0dXJuIHNbMF0gPSAoMSAtICh5ICsgcCkpICogYiwgc1sxXSA9IChjICsgQSkgKiBiLCBzWzJdID0gKG0gLSBGKSAqIGIsIHNbM10gPSAwLCBzWzRdID0gKGMgLSBBKSAqIE0sIHNbNV0gPSAoMSAtIChkICsgcCkpICogTSwgc1s2XSA9ICh4ICsgeikgKiBNLCBzWzddID0gMCwgc1s4XSA9IChtICsgRikgKiBfLCBzWzldID0gKHggLSB6KSAqIF8sIHNbMTBdID0gKDEgLSAoZCArIHkpKSAqIF8sIHNbMTFdID0gMCwgc1sxMl0gPSB0LngsIHNbMTNdID0gdC55LCBzWzE0XSA9IHQueiwgc1sxNV0gPSAxLCB0aGlzOwogICAgfQogICAgZGVjb21wb3NlKHQsIGUsIGkpIHsKICAgICAgY29uc3QgcyA9IHRoaXMuZWxlbWVudHM7CiAgICAgIGxldCByID0gQXQuc2V0KHNbMF0sIHNbMV0sIHNbMl0pLmxlbmd0aCgpOwogICAgICBjb25zdCBuID0gQXQuc2V0KHNbNF0sIHNbNV0sIHNbNl0pLmxlbmd0aCgpLCBhID0gQXQuc2V0KHNbOF0sIHNbOV0sIHNbMTBdKS5sZW5ndGgoKTsKICAgICAgdGhpcy5kZXRlcm1pbmFudCgpIDwgMCAmJiAociA9IC1yKSwgdC54ID0gc1sxMl0sIHQueSA9IHNbMTNdLCB0LnogPSBzWzE0XSwgSi5jb3B5KHRoaXMpOwogICAgICBjb25zdCBoID0gMSAvIHIsIHUgPSAxIC8gbiwgbCA9IDEgLyBhOwogICAgICByZXR1cm4gSi5lbGVtZW50c1swXSAqPSBoLCBKLmVsZW1lbnRzWzFdICo9IGgsIEouZWxlbWVudHNbMl0gKj0gaCwgSi5lbGVtZW50c1s0XSAqPSB1LCBKLmVsZW1lbnRzWzVdICo9IHUsIEouZWxlbWVudHNbNl0gKj0gdSwgSi5lbGVtZW50c1s4XSAqPSBsLCBKLmVsZW1lbnRzWzldICo9IGwsIEouZWxlbWVudHNbMTBdICo9IGwsIGUuc2V0RnJvbVJvdGF0aW9uTWF0cml4KEopLCBpLnggPSByLCBpLnkgPSBuLCBpLnogPSBhLCB0aGlzOwogICAgfQogICAgbWFrZVBlcnNwZWN0aXZlKHQsIGUsIGksIHMsIHIsIG4sIGEgPSAyZTMpIHsKICAgICAgY29uc3QgbyA9IHRoaXMuZWxlbWVudHMsIGggPSAyICogciAvIChlIC0gdCksIHUgPSAyICogciAvIChpIC0gcyksIGwgPSAoZSArIHQpIC8gKGUgLSB0KSwgZCA9IChpICsgcykgLyAoaSAtIHMpOwogICAgICBsZXQgYywgbTsKICAgICAgaWYgKGEgPT09IDJlMykKICAgICAgICBjID0gLShuICsgcikgLyAobiAtIHIpLCBtID0gLTIgKiBuICogciAvIChuIC0gcik7CiAgICAgIGVsc2UgaWYgKGEgPT09IDIwMDEpCiAgICAgICAgYyA9IC1uIC8gKG4gLSByKSwgbSA9IC1uICogciAvIChuIC0gcik7CiAgICAgIGVsc2UKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZVBlcnNwZWN0aXZlKCk6IEludmFsaWQgY29vcmRpbmF0ZSBzeXN0ZW06ICIgKyBhKTsKICAgICAgcmV0dXJuIG9bMF0gPSBoLCBvWzRdID0gMCwgb1s4XSA9IGwsIG9bMTJdID0gMCwgb1sxXSA9IDAsIG9bNV0gPSB1LCBvWzldID0gZCwgb1sxM10gPSAwLCBvWzJdID0gMCwgb1s2XSA9IDAsIG9bMTBdID0gYywgb1sxNF0gPSBtLCBvWzNdID0gMCwgb1s3XSA9IDAsIG9bMTFdID0gLTEsIG9bMTVdID0gMCwgdGhpczsKICAgIH0KICAgIG1ha2VPcnRob2dyYXBoaWModCwgZSwgaSwgcywgciwgbiwgYSA9IDJlMykgewogICAgICBjb25zdCBvID0gdGhpcy5lbGVtZW50cywgaCA9IDEgLyAoZSAtIHQpLCB1ID0gMSAvIChpIC0gcyksIGwgPSAxIC8gKG4gLSByKSwgZCA9IChlICsgdCkgKiBoLCBjID0gKGkgKyBzKSAqIHU7CiAgICAgIGxldCBtLCB5OwogICAgICBpZiAoYSA9PT0gMmUzKQogICAgICAgIG0gPSAobiArIHIpICogbCwgeSA9IC0yICogbDsKICAgICAgZWxzZSBpZiAoYSA9PT0gMjAwMSkKICAgICAgICBtID0gciAqIGwsIHkgPSAtMSAqIGw7CiAgICAgIGVsc2UKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlRIUkVFLk1hdHJpeDQubWFrZU9ydGhvZ3JhcGhpYygpOiBJbnZhbGlkIGNvb3JkaW5hdGUgc3lzdGVtOiAiICsgYSk7CiAgICAgIHJldHVybiBvWzBdID0gMiAqIGgsIG9bNF0gPSAwLCBvWzhdID0gMCwgb1sxMl0gPSAtZCwgb1sxXSA9IDAsIG9bNV0gPSAyICogdSwgb1s5XSA9IDAsIG9bMTNdID0gLWMsIG9bMl0gPSAwLCBvWzZdID0gMCwgb1sxMF0gPSB5LCBvWzE0XSA9IC1tLCBvWzNdID0gMCwgb1s3XSA9IDAsIG9bMTFdID0gMCwgb1sxNV0gPSAxLCB0aGlzOwogICAgfQogICAgZXF1YWxzKHQpIHsKICAgICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHMsIGkgPSB0LmVsZW1lbnRzOwogICAgICBmb3IgKGxldCBzID0gMDsgcyA8IDE2OyBzKyspCiAgICAgICAgaWYgKGVbc10gIT09IGlbc10pIHJldHVybiAhMTsKICAgICAgcmV0dXJuICEwOwogICAgfQogICAgZnJvbUFycmF5KHQsIGUgPSAwKSB7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykKICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gdFtpICsgZV07CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgdG9BcnJheSh0ID0gW10sIGUgPSAwKSB7CiAgICAgIGNvbnN0IGkgPSB0aGlzLmVsZW1lbnRzOwogICAgICByZXR1cm4gdFtlXSA9IGlbMF0sIHRbZSArIDFdID0gaVsxXSwgdFtlICsgMl0gPSBpWzJdLCB0W2UgKyAzXSA9IGlbM10sIHRbZSArIDRdID0gaVs0XSwgdFtlICsgNV0gPSBpWzVdLCB0W2UgKyA2XSA9IGlbNl0sIHRbZSArIDddID0gaVs3XSwgdFtlICsgOF0gPSBpWzhdLCB0W2UgKyA5XSA9IGlbOV0sIHRbZSArIDEwXSA9IGlbMTBdLCB0W2UgKyAxMV0gPSBpWzExXSwgdFtlICsgMTJdID0gaVsxMl0sIHRbZSArIDEzXSA9IGlbMTNdLCB0W2UgKyAxNF0gPSBpWzE0XSwgdFtlICsgMTVdID0gaVsxNV0sIHQ7CiAgICB9CiAgfQogIGNvbnN0IEF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIEogPSAvKiBAX19QVVJFX18gKi8gbmV3IHR0KCksIEdlID0gLyogQF9fUFVSRV9fICovIG5ldyBnKDAsIDAsIDApLCBYZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygxLCAxLCAxKSwgdXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IGcoKSwgV3QgPSAvKiBAX19QVVJFX18gKi8gbmV3IGcoKSwgSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLCBfZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdHQoKSwgd2UgPSAvKiBAX19QVVJFX18gKi8gbmV3IEx0KCk7CiAgY2xhc3MgVnQgewogICAgY29uc3RydWN0b3IodCA9IDAsIGUgPSAwLCBpID0gMCwgcyA9IFZ0LkRFRkFVTFRfT1JERVIpIHsKICAgICAgdGhpcy5pc0V1bGVyID0gITAsIHRoaXMuX3ggPSB0LCB0aGlzLl95ID0gZSwgdGhpcy5feiA9IGksIHRoaXMuX29yZGVyID0gczsKICAgIH0KICAgIGdldCB4KCkgewogICAgICByZXR1cm4gdGhpcy5feDsKICAgIH0KICAgIHNldCB4KHQpIHsKICAgICAgdGhpcy5feCA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCB5KCkgewogICAgICByZXR1cm4gdGhpcy5feTsKICAgIH0KICAgIHNldCB5KHQpIHsKICAgICAgdGhpcy5feSA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCB6KCkgewogICAgICByZXR1cm4gdGhpcy5fejsKICAgIH0KICAgIHNldCB6KHQpIHsKICAgICAgdGhpcy5feiA9IHQsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKTsKICAgIH0KICAgIGdldCBvcmRlcigpIHsKICAgICAgcmV0dXJuIHRoaXMuX29yZGVyOwogICAgfQogICAgc2V0IG9yZGVyKHQpIHsKICAgICAgdGhpcy5fb3JkZXIgPSB0LCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCk7CiAgICB9CiAgICBzZXQodCwgZSwgaSwgcyA9IHRoaXMuX29yZGVyKSB7CiAgICAgIHJldHVybiB0aGlzLl94ID0gdCwgdGhpcy5feSA9IGUsIHRoaXMuX3ogPSBpLCB0aGlzLl9vcmRlciA9IHMsIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2soKSwgdGhpczsKICAgIH0KICAgIGNsb25lKCkgewogICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5fb3JkZXIpOwogICAgfQogICAgY29weSh0KSB7CiAgICAgIHJldHVybiB0aGlzLl94ID0gdC5feCwgdGhpcy5feSA9IHQuX3ksIHRoaXMuX3ogPSB0Ll96LCB0aGlzLl9vcmRlciA9IHQuX29yZGVyLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICBzZXRGcm9tUm90YXRpb25NYXRyaXgodCwgZSA9IHRoaXMuX29yZGVyLCBpID0gITApIHsKICAgICAgY29uc3QgcyA9IHQuZWxlbWVudHMsIHIgPSBzWzBdLCBuID0gc1s0XSwgYSA9IHNbOF0sIG8gPSBzWzFdLCBoID0gc1s1XSwgdSA9IHNbOV0sIGwgPSBzWzJdLCBkID0gc1s2XSwgYyA9IHNbMTBdOwogICAgICBzd2l0Y2ggKGUpIHsKICAgICAgICBjYXNlICJYWVoiOgogICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbihUKGEsIC0xLCAxKSksIE1hdGguYWJzKGEpIDwgMC45OTk5OTk5ID8gKHRoaXMuX3ggPSBNYXRoLmF0YW4yKC11LCBjKSwgdGhpcy5feiA9IE1hdGguYXRhbjIoLW4sIHIpKSA6ICh0aGlzLl94ID0gTWF0aC5hdGFuMihkLCBoKSwgdGhpcy5feiA9IDApOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiWVhaIjoKICAgICAgICAgIHRoaXMuX3ggPSBNYXRoLmFzaW4oLVQodSwgLTEsIDEpKSwgTWF0aC5hYnModSkgPCAwLjk5OTk5OTkgPyAodGhpcy5feSA9IE1hdGguYXRhbjIoYSwgYyksIHRoaXMuX3ogPSBNYXRoLmF0YW4yKG8sIGgpKSA6ICh0aGlzLl95ID0gTWF0aC5hdGFuMigtbCwgciksIHRoaXMuX3ogPSAwKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIlpYWSI6CiAgICAgICAgICB0aGlzLl94ID0gTWF0aC5hc2luKFQoZCwgLTEsIDEpKSwgTWF0aC5hYnMoZCkgPCAwLjk5OTk5OTkgPyAodGhpcy5feSA9IE1hdGguYXRhbjIoLWwsIGMpLCB0aGlzLl96ID0gTWF0aC5hdGFuMigtbiwgaCkpIDogKHRoaXMuX3kgPSAwLCB0aGlzLl96ID0gTWF0aC5hdGFuMihvLCByKSk7CiAgICAgICAgICBicmVhazsKICAgICAgICBjYXNlICJaWVgiOgogICAgICAgICAgdGhpcy5feSA9IE1hdGguYXNpbigtVChsLCAtMSwgMSkpLCBNYXRoLmFicyhsKSA8IDAuOTk5OTk5OSA/ICh0aGlzLl94ID0gTWF0aC5hdGFuMihkLCBjKSwgdGhpcy5feiA9IE1hdGguYXRhbjIobywgcikpIDogKHRoaXMuX3ggPSAwLCB0aGlzLl96ID0gTWF0aC5hdGFuMigtbiwgaCkpOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAiWVpYIjoKICAgICAgICAgIHRoaXMuX3ogPSBNYXRoLmFzaW4oVChvLCAtMSwgMSkpLCBNYXRoLmFicyhvKSA8IDAuOTk5OTk5OSA/ICh0aGlzLl94ID0gTWF0aC5hdGFuMigtdSwgaCksIHRoaXMuX3kgPSBNYXRoLmF0YW4yKC1sLCByKSkgOiAodGhpcy5feCA9IDAsIHRoaXMuX3kgPSBNYXRoLmF0YW4yKGEsIGMpKTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIGNhc2UgIlhaWSI6CiAgICAgICAgICB0aGlzLl96ID0gTWF0aC5hc2luKC1UKG4sIC0xLCAxKSksIE1hdGguYWJzKG4pIDwgMC45OTk5OTk5ID8gKHRoaXMuX3ggPSBNYXRoLmF0YW4yKGQsIGgpLCB0aGlzLl95ID0gTWF0aC5hdGFuMihhLCByKSkgOiAodGhpcy5feCA9IE1hdGguYXRhbjIoLXUsIGMpLCB0aGlzLl95ID0gMCk7CiAgICAgICAgICBicmVhazsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgY29uc29sZS53YXJuKCJUSFJFRS5FdWxlcjogLnNldEZyb21Sb3RhdGlvbk1hdHJpeCgpIGVuY291bnRlcmVkIGFuIHVua25vd24gb3JkZXI6ICIgKyBlKTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5fb3JkZXIgPSBlLCBpID09PSAhMCAmJiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICBzZXRGcm9tUXVhdGVybmlvbih0LCBlLCBpKSB7CiAgICAgIHJldHVybiBfZS5tYWtlUm90YXRpb25Gcm9tUXVhdGVybmlvbih0KSwgdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoX2UsIGUsIGkpOwogICAgfQogICAgc2V0RnJvbVZlY3RvcjModCwgZSA9IHRoaXMuX29yZGVyKSB7CiAgICAgIHJldHVybiB0aGlzLnNldCh0LngsIHQueSwgdC56LCBlKTsKICAgIH0KICAgIHJlb3JkZXIodCkgewogICAgICByZXR1cm4gd2Uuc2V0RnJvbUV1bGVyKHRoaXMpLCB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKHdlLCB0KTsKICAgIH0KICAgIGVxdWFscyh0KSB7CiAgICAgIHJldHVybiB0Ll94ID09PSB0aGlzLl94ICYmIHQuX3kgPT09IHRoaXMuX3kgJiYgdC5feiA9PT0gdGhpcy5feiAmJiB0Ll9vcmRlciA9PT0gdGhpcy5fb3JkZXI7CiAgICB9CiAgICBmcm9tQXJyYXkodCkgewogICAgICByZXR1cm4gdGhpcy5feCA9IHRbMF0sIHRoaXMuX3kgPSB0WzFdLCB0aGlzLl96ID0gdFsyXSwgdFszXSAhPT0gdm9pZCAwICYmICh0aGlzLl9vcmRlciA9IHRbM10pLCB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKCksIHRoaXM7CiAgICB9CiAgICB0b0FycmF5KHQgPSBbXSwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRbZV0gPSB0aGlzLl94LCB0W2UgKyAxXSA9IHRoaXMuX3ksIHRbZSArIDJdID0gdGhpcy5feiwgdFtlICsgM10gPSB0aGlzLl9vcmRlciwgdDsKICAgIH0KICAgIF9vbkNoYW5nZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gdCwgdGhpczsKICAgIH0KICAgIF9vbkNoYW5nZUNhbGxiYWNrKCkgewogICAgfQogICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICB5aWVsZCB0aGlzLl94LCB5aWVsZCB0aGlzLl95LCB5aWVsZCB0aGlzLl96LCB5aWVsZCB0aGlzLl9vcmRlcjsKICAgIH0KICB9CiAgVnQuREVGQVVMVF9PUkRFUiA9ICJYWVoiOwogIGNsYXNzIFZlIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICB0aGlzLm1hc2sgPSAxOwogICAgfQogICAgc2V0KHQpIHsKICAgICAgdGhpcy5tYXNrID0gKDEgPDwgdCB8IDApID4+PiAwOwogICAgfQogICAgZW5hYmxlKHQpIHsKICAgICAgdGhpcy5tYXNrIHw9IDEgPDwgdCB8IDA7CiAgICB9CiAgICBlbmFibGVBbGwoKSB7CiAgICAgIHRoaXMubWFzayA9IC0xOwogICAgfQogICAgdG9nZ2xlKHQpIHsKICAgICAgdGhpcy5tYXNrIF49IDEgPDwgdCB8IDA7CiAgICB9CiAgICBkaXNhYmxlKHQpIHsKICAgICAgdGhpcy5tYXNrICY9IH4oMSA8PCB0IHwgMCk7CiAgICB9CiAgICBkaXNhYmxlQWxsKCkgewogICAgICB0aGlzLm1hc2sgPSAwOwogICAgfQogICAgdGVzdCh0KSB7CiAgICAgIHJldHVybiAodGhpcy5tYXNrICYgdC5tYXNrKSAhPT0gMDsKICAgIH0KICAgIGlzRW5hYmxlZCh0KSB7CiAgICAgIHJldHVybiAodGhpcy5tYXNrICYgKDEgPDwgdCB8IDApKSAhPT0gMDsKICAgIH0KICB9CiAgbGV0IFplID0gMDsKICBjb25zdCBBZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLCBNdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTHQoKSwgaXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IHR0KCksIHF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIFR0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIGplID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksICRlID0gLyogQF9fUFVSRV9fICovIG5ldyBMdCgpLCBNZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygxLCAwLCAwKSwgemUgPSAvKiBAX19QVVJFX18gKi8gbmV3IGcoMCwgMSwgMCksIEZlID0gLyogQF9fUFVSRV9fICovIG5ldyBnKDAsIDAsIDEpLCBTZSA9IHsgdHlwZTogImFkZGVkIiB9LCBKZSA9IHsgdHlwZTogInJlbW92ZWQiIH0sIHp0ID0geyB0eXBlOiAiY2hpbGRhZGRlZCIsIGNoaWxkOiBudWxsIH0sIGFlID0geyB0eXBlOiAiY2hpbGRyZW1vdmVkIiwgY2hpbGQ6IG51bGwgfTsKICBjbGFzcyBjdCBleHRlbmRzIGNlIHsKICAgIGNvbnN0cnVjdG9yKCkgewogICAgICBzdXBlcigpLCB0aGlzLmlzT2JqZWN0M0QgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJpZCIsIHsgdmFsdWU6IFplKysgfSksIHRoaXMudXVpZCA9IFh0KCksIHRoaXMubmFtZSA9ICIiLCB0aGlzLnR5cGUgPSAiT2JqZWN0M0QiLCB0aGlzLnBhcmVudCA9IG51bGwsIHRoaXMuY2hpbGRyZW4gPSBbXSwgdGhpcy51cCA9IGN0LkRFRkFVTFRfVVAuY2xvbmUoKTsKICAgICAgY29uc3QgdCA9IG5ldyBnKCksIGUgPSBuZXcgVnQoKSwgaSA9IG5ldyBMdCgpLCBzID0gbmV3IGcoMSwgMSwgMSk7CiAgICAgIGZ1bmN0aW9uIHIoKSB7CiAgICAgICAgaS5zZXRGcm9tRXVsZXIoZSwgITEpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG4oKSB7CiAgICAgICAgZS5zZXRGcm9tUXVhdGVybmlvbihpLCB2b2lkIDAsICExKTsKICAgICAgfQogICAgICBlLl9vbkNoYW5nZShyKSwgaS5fb25DaGFuZ2UobiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHsKICAgICAgICBwb3NpdGlvbjogewogICAgICAgICAgY29uZmlndXJhYmxlOiAhMCwKICAgICAgICAgIGVudW1lcmFibGU6ICEwLAogICAgICAgICAgdmFsdWU6IHQKICAgICAgICB9LAogICAgICAgIHJvdGF0aW9uOiB7CiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLAogICAgICAgICAgZW51bWVyYWJsZTogITAsCiAgICAgICAgICB2YWx1ZTogZQogICAgICAgIH0sCiAgICAgICAgcXVhdGVybmlvbjogewogICAgICAgICAgY29uZmlndXJhYmxlOiAhMCwKICAgICAgICAgIGVudW1lcmFibGU6ICEwLAogICAgICAgICAgdmFsdWU6IGkKICAgICAgICB9LAogICAgICAgIHNjYWxlOiB7CiAgICAgICAgICBjb25maWd1cmFibGU6ICEwLAogICAgICAgICAgZW51bWVyYWJsZTogITAsCiAgICAgICAgICB2YWx1ZTogcwogICAgICAgIH0sCiAgICAgICAgbW9kZWxWaWV3TWF0cml4OiB7CiAgICAgICAgICB2YWx1ZTogbmV3IHR0KCkKICAgICAgICB9LAogICAgICAgIG5vcm1hbE1hdHJpeDogewogICAgICAgICAgdmFsdWU6IG5ldyBkdCgpCiAgICAgICAgfQogICAgICB9KSwgdGhpcy5tYXRyaXggPSBuZXcgdHQoKSwgdGhpcy5tYXRyaXhXb3JsZCA9IG5ldyB0dCgpLCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBjdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSwgdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSBjdC5ERUZBVUxUX01BVFJJWF9XT1JMRF9BVVRPX1VQREFURSwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gITEsIHRoaXMubGF5ZXJzID0gbmV3IFZlKCksIHRoaXMudmlzaWJsZSA9ICEwLCB0aGlzLmNhc3RTaGFkb3cgPSAhMSwgdGhpcy5yZWNlaXZlU2hhZG93ID0gITEsIHRoaXMuZnJ1c3R1bUN1bGxlZCA9ICEwLCB0aGlzLnJlbmRlck9yZGVyID0gMCwgdGhpcy5hbmltYXRpb25zID0gW10sIHRoaXMudXNlckRhdGEgPSB7fTsKICAgIH0KICAgIG9uQmVmb3JlU2hhZG93KCkgewogICAgfQogICAgb25BZnRlclNoYWRvdygpIHsKICAgIH0KICAgIG9uQmVmb3JlUmVuZGVyKCkgewogICAgfQogICAgb25BZnRlclJlbmRlcigpIHsKICAgIH0KICAgIGFwcGx5TWF0cml4NCh0KSB7CiAgICAgIHRoaXMubWF0cml4QXV0b1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpLCB0aGlzLm1hdHJpeC5wcmVtdWx0aXBseSh0KSwgdGhpcy5tYXRyaXguZGVjb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSk7CiAgICB9CiAgICBhcHBseVF1YXRlcm5pb24odCkgewogICAgICByZXR1cm4gdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KHQpLCB0aGlzOwogICAgfQogICAgc2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlKHQsIGUpIHsKICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUodCwgZSk7CiAgICB9CiAgICBzZXRSb3RhdGlvbkZyb21FdWxlcih0KSB7CiAgICAgIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tRXVsZXIodCwgITApOwogICAgfQogICAgc2V0Um90YXRpb25Gcm9tTWF0cml4KHQpIHsKICAgICAgdGhpcy5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCh0KTsKICAgIH0KICAgIHNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCkgewogICAgICB0aGlzLnF1YXRlcm5pb24uY29weSh0KTsKICAgIH0KICAgIHJvdGF0ZU9uQXhpcyh0LCBlKSB7CiAgICAgIHJldHVybiBNdC5zZXRGcm9tQXhpc0FuZ2xlKHQsIGUpLCB0aGlzLnF1YXRlcm5pb24ubXVsdGlwbHkoTXQpLCB0aGlzOwogICAgfQogICAgcm90YXRlT25Xb3JsZEF4aXModCwgZSkgewogICAgICByZXR1cm4gTXQuc2V0RnJvbUF4aXNBbmdsZSh0LCBlKSwgdGhpcy5xdWF0ZXJuaW9uLnByZW11bHRpcGx5KE10KSwgdGhpczsKICAgIH0KICAgIHJvdGF0ZVgodCkgewogICAgICByZXR1cm4gdGhpcy5yb3RhdGVPbkF4aXMoTWUsIHQpOwogICAgfQogICAgcm90YXRlWSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyh6ZSwgdCk7CiAgICB9CiAgICByb3RhdGVaKHQpIHsKICAgICAgcmV0dXJuIHRoaXMucm90YXRlT25BeGlzKEZlLCB0KTsKICAgIH0KICAgIHRyYW5zbGF0ZU9uQXhpcyh0LCBlKSB7CiAgICAgIHJldHVybiBBZS5jb3B5KHQpLmFwcGx5UXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pLCB0aGlzLnBvc2l0aW9uLmFkZChBZS5tdWx0aXBseVNjYWxhcihlKSksIHRoaXM7CiAgICB9CiAgICB0cmFuc2xhdGVYKHQpIHsKICAgICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKE1lLCB0KTsKICAgIH0KICAgIHRyYW5zbGF0ZVkodCkgewogICAgICByZXR1cm4gdGhpcy50cmFuc2xhdGVPbkF4aXMoemUsIHQpOwogICAgfQogICAgdHJhbnNsYXRlWih0KSB7CiAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyhGZSwgdCk7CiAgICB9CiAgICBsb2NhbFRvV29ybGQodCkgewogICAgICByZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCB0LmFwcGx5TWF0cml4NCh0aGlzLm1hdHJpeFdvcmxkKTsKICAgIH0KICAgIHdvcmxkVG9Mb2NhbCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSksIHQuYXBwbHlNYXRyaXg0KGl0LmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCkpOwogICAgfQogICAgbG9va0F0KHQsIGUsIGkpIHsKICAgICAgdC5pc1ZlY3RvcjMgPyBxdC5jb3B5KHQpIDogcXQuc2V0KHQsIGUsIGkpOwogICAgICBjb25zdCBzID0gdGhpcy5wYXJlbnQ7CiAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsICExKSwgVHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpLCB0aGlzLmlzQ2FtZXJhIHx8IHRoaXMuaXNMaWdodCA/IGl0Lmxvb2tBdChUdCwgcXQsIHRoaXMudXApIDogaXQubG9va0F0KHF0LCBUdCwgdGhpcy51cCksIHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoaXQpLCBzICYmIChpdC5leHRyYWN0Um90YXRpb24ocy5tYXRyaXhXb3JsZCksIE10LnNldEZyb21Sb3RhdGlvbk1hdHJpeChpdCksIHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseShNdC5pbnZlcnQoKSkpOwogICAgfQogICAgYWRkKHQpIHsKICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7CiAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspCiAgICAgICAgICB0aGlzLmFkZChhcmd1bWVudHNbZV0pOwogICAgICAgIHJldHVybiB0aGlzOwogICAgICB9CiAgICAgIHJldHVybiB0ID09PSB0aGlzID8gKGNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IGNhbid0IGJlIGFkZGVkIGFzIGEgY2hpbGQgb2YgaXRzZWxmLiIsIHQpLCB0aGlzKSA6ICh0ICYmIHQuaXNPYmplY3QzRCA/ICh0LnJlbW92ZUZyb21QYXJlbnQoKSwgdC5wYXJlbnQgPSB0aGlzLCB0aGlzLmNoaWxkcmVuLnB1c2godCksIHQuZGlzcGF0Y2hFdmVudChTZSksIHp0LmNoaWxkID0gdCwgdGhpcy5kaXNwYXRjaEV2ZW50KHp0KSwgenQuY2hpbGQgPSBudWxsKSA6IGNvbnNvbGUuZXJyb3IoIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC4iLCB0KSwgdGhpcyk7CiAgICB9CiAgICByZW1vdmUodCkgewogICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykKICAgICAgICAgIHRoaXMucmVtb3ZlKGFyZ3VtZW50c1tpXSk7CiAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgIH0KICAgICAgY29uc3QgZSA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZih0KTsKICAgICAgcmV0dXJuIGUgIT09IC0xICYmICh0LnBhcmVudCA9IG51bGwsIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGUsIDEpLCB0LmRpc3BhdGNoRXZlbnQoSmUpLCBhZS5jaGlsZCA9IHQsIHRoaXMuZGlzcGF0Y2hFdmVudChhZSksIGFlLmNoaWxkID0gbnVsbCksIHRoaXM7CiAgICB9CiAgICByZW1vdmVGcm9tUGFyZW50KCkgewogICAgICBjb25zdCB0ID0gdGhpcy5wYXJlbnQ7CiAgICAgIHJldHVybiB0ICE9PSBudWxsICYmIHQucmVtb3ZlKHRoaXMpLCB0aGlzOwogICAgfQogICAgY2xlYXIoKSB7CiAgICAgIHJldHVybiB0aGlzLnJlbW92ZSguLi50aGlzLmNoaWxkcmVuKTsKICAgIH0KICAgIGF0dGFjaCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSksIGl0LmNvcHkodGhpcy5tYXRyaXhXb3JsZCkuaW52ZXJ0KCksIHQucGFyZW50ICE9PSBudWxsICYmICh0LnBhcmVudC51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCBpdC5tdWx0aXBseSh0LnBhcmVudC5tYXRyaXhXb3JsZCkpLCB0LmFwcGx5TWF0cml4NChpdCksIHQucmVtb3ZlRnJvbVBhcmVudCgpLCB0LnBhcmVudCA9IHRoaXMsIHRoaXMuY2hpbGRyZW4ucHVzaCh0KSwgdC51cGRhdGVXb3JsZE1hdHJpeCghMSwgITApLCB0LmRpc3BhdGNoRXZlbnQoU2UpLCB6dC5jaGlsZCA9IHQsIHRoaXMuZGlzcGF0Y2hFdmVudCh6dCksIHp0LmNoaWxkID0gbnVsbCwgdGhpczsKICAgIH0KICAgIGdldE9iamVjdEJ5SWQodCkgewogICAgICByZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCJpZCIsIHQpOwogICAgfQogICAgZ2V0T2JqZWN0QnlOYW1lKHQpIHsKICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSgibmFtZSIsIHQpOwogICAgfQogICAgZ2V0T2JqZWN0QnlQcm9wZXJ0eSh0LCBlKSB7CiAgICAgIGlmICh0aGlzW3RdID09PSBlKSByZXR1cm4gdGhpczsKICAgICAgZm9yIChsZXQgaSA9IDAsIHMgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IHM7IGkrKykgewogICAgICAgIGNvbnN0IG4gPSB0aGlzLmNoaWxkcmVuW2ldLmdldE9iamVjdEJ5UHJvcGVydHkodCwgZSk7CiAgICAgICAgaWYgKG4gIT09IHZvaWQgMCkKICAgICAgICAgIHJldHVybiBuOwogICAgICB9CiAgICB9CiAgICBnZXRPYmplY3RzQnlQcm9wZXJ0eSh0LCBlLCBpID0gW10pIHsKICAgICAgdGhpc1t0XSA9PT0gZSAmJiBpLnB1c2godGhpcyk7CiAgICAgIGNvbnN0IHMgPSB0aGlzLmNoaWxkcmVuOwogICAgICBmb3IgKGxldCByID0gMCwgbiA9IHMubGVuZ3RoOyByIDwgbjsgcisrKQogICAgICAgIHNbcl0uZ2V0T2JqZWN0c0J5UHJvcGVydHkodCwgZSwgaSk7CiAgICAgIHJldHVybiBpOwogICAgfQogICAgZ2V0V29ybGRQb3NpdGlvbih0KSB7CiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSksIHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKHRoaXMubWF0cml4V29ybGQpOwogICAgfQogICAgZ2V0V29ybGRRdWF0ZXJuaW9uKHQpIHsKICAgICAgcmV0dXJuIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoITAsICExKSwgdGhpcy5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoVHQsIHQsIGplKSwgdDsKICAgIH0KICAgIGdldFdvcmxkU2NhbGUodCkgewogICAgICByZXR1cm4gdGhpcy51cGRhdGVXb3JsZE1hdHJpeCghMCwgITEpLCB0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZShUdCwgJGUsIHQpLCB0OwogICAgfQogICAgZ2V0V29ybGREaXJlY3Rpb24odCkgewogICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCEwLCAhMSk7CiAgICAgIGNvbnN0IGUgPSB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzOwogICAgICByZXR1cm4gdC5zZXQoZVs4XSwgZVs5XSwgZVsxMF0pLm5vcm1hbGl6ZSgpOwogICAgfQogICAgcmF5Y2FzdCgpIHsKICAgIH0KICAgIHRyYXZlcnNlKHQpIHsKICAgICAgdCh0aGlzKTsKICAgICAgY29uc3QgZSA9IHRoaXMuY2hpbGRyZW47CiAgICAgIGZvciAobGV0IGkgPSAwLCBzID0gZS5sZW5ndGg7IGkgPCBzOyBpKyspCiAgICAgICAgZVtpXS50cmF2ZXJzZSh0KTsKICAgIH0KICAgIHRyYXZlcnNlVmlzaWJsZSh0KSB7CiAgICAgIGlmICh0aGlzLnZpc2libGUgPT09ICExKSByZXR1cm47CiAgICAgIHQodGhpcyk7CiAgICAgIGNvbnN0IGUgPSB0aGlzLmNoaWxkcmVuOwogICAgICBmb3IgKGxldCBpID0gMCwgcyA9IGUubGVuZ3RoOyBpIDwgczsgaSsrKQogICAgICAgIGVbaV0udHJhdmVyc2VWaXNpYmxlKHQpOwogICAgfQogICAgdHJhdmVyc2VBbmNlc3RvcnModCkgewogICAgICBjb25zdCBlID0gdGhpcy5wYXJlbnQ7CiAgICAgIGUgIT09IG51bGwgJiYgKHQoZSksIGUudHJhdmVyc2VBbmNlc3RvcnModCkpOwogICAgfQogICAgdXBkYXRlTWF0cml4KCkgewogICAgICB0aGlzLm1hdHJpeC5jb21wb3NlKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSksIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9ICEwOwogICAgfQogICAgdXBkYXRlTWF0cml4V29ybGQodCkgewogICAgICB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKSwgKHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCB0KSAmJiAodGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPT09ICEwICYmICh0aGlzLnBhcmVudCA9PT0gbnVsbCA/IHRoaXMubWF0cml4V29ybGQuY29weSh0aGlzLm1hdHJpeCkgOiB0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXModGhpcy5wYXJlbnQubWF0cml4V29ybGQsIHRoaXMubWF0cml4KSksIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9ICExLCB0ID0gITApOwogICAgICBjb25zdCBlID0gdGhpcy5jaGlsZHJlbjsKICAgICAgZm9yIChsZXQgaSA9IDAsIHMgPSBlLmxlbmd0aDsgaSA8IHM7IGkrKykKICAgICAgICBlW2ldLnVwZGF0ZU1hdHJpeFdvcmxkKHQpOwogICAgfQogICAgdXBkYXRlV29ybGRNYXRyaXgodCwgZSkgewogICAgICBjb25zdCBpID0gdGhpcy5wYXJlbnQ7CiAgICAgIGlmICh0ID09PSAhMCAmJiBpICE9PSBudWxsICYmIGkudXBkYXRlV29ybGRNYXRyaXgoITAsICExKSwgdGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCksIHRoaXMubWF0cml4V29ybGRBdXRvVXBkYXRlID09PSAhMCAmJiAodGhpcy5wYXJlbnQgPT09IG51bGwgPyB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodGhpcy5tYXRyaXgpIDogdGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCkpLCBlID09PSAhMCkgewogICAgICAgIGNvbnN0IHMgPSB0aGlzLmNoaWxkcmVuOwogICAgICAgIGZvciAobGV0IHIgPSAwLCBuID0gcy5sZW5ndGg7IHIgPCBuOyByKyspCiAgICAgICAgICBzW3JdLnVwZGF0ZVdvcmxkTWF0cml4KCExLCAhMCk7CiAgICAgIH0KICAgIH0KICAgIHRvSlNPTih0KSB7CiAgICAgIGNvbnN0IGUgPSB0ID09PSB2b2lkIDAgfHwgdHlwZW9mIHQgPT0gInN0cmluZyIsIGkgPSB7fTsKICAgICAgZSAmJiAodCA9IHsKICAgICAgICBnZW9tZXRyaWVzOiB7fSwKICAgICAgICBtYXRlcmlhbHM6IHt9LAogICAgICAgIHRleHR1cmVzOiB7fSwKICAgICAgICBpbWFnZXM6IHt9LAogICAgICAgIHNoYXBlczoge30sCiAgICAgICAgc2tlbGV0b25zOiB7fSwKICAgICAgICBhbmltYXRpb25zOiB7fSwKICAgICAgICBub2Rlczoge30KICAgICAgfSwgaS5tZXRhZGF0YSA9IHsKICAgICAgICB2ZXJzaW9uOiA0LjYsCiAgICAgICAgdHlwZTogIk9iamVjdCIsCiAgICAgICAgZ2VuZXJhdG9yOiAiT2JqZWN0M0QudG9KU09OIgogICAgICB9KTsKICAgICAgY29uc3QgcyA9IHt9OwogICAgICBzLnV1aWQgPSB0aGlzLnV1aWQsIHMudHlwZSA9IHRoaXMudHlwZSwgdGhpcy5uYW1lICE9PSAiIiAmJiAocy5uYW1lID0gdGhpcy5uYW1lKSwgdGhpcy5jYXN0U2hhZG93ID09PSAhMCAmJiAocy5jYXN0U2hhZG93ID0gITApLCB0aGlzLnJlY2VpdmVTaGFkb3cgPT09ICEwICYmIChzLnJlY2VpdmVTaGFkb3cgPSAhMCksIHRoaXMudmlzaWJsZSA9PT0gITEgJiYgKHMudmlzaWJsZSA9ICExKSwgdGhpcy5mcnVzdHVtQ3VsbGVkID09PSAhMSAmJiAocy5mcnVzdHVtQ3VsbGVkID0gITEpLCB0aGlzLnJlbmRlck9yZGVyICE9PSAwICYmIChzLnJlbmRlck9yZGVyID0gdGhpcy5yZW5kZXJPcmRlciksIE9iamVjdC5rZXlzKHRoaXMudXNlckRhdGEpLmxlbmd0aCA+IDAgJiYgKHMudXNlckRhdGEgPSB0aGlzLnVzZXJEYXRhKSwgcy5sYXllcnMgPSB0aGlzLmxheWVycy5tYXNrLCBzLm1hdHJpeCA9IHRoaXMubWF0cml4LnRvQXJyYXkoKSwgcy51cCA9IHRoaXMudXAudG9BcnJheSgpLCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09ICExICYmIChzLm1hdHJpeEF1dG9VcGRhdGUgPSAhMSksIHRoaXMuaXNJbnN0YW5jZWRNZXNoICYmIChzLnR5cGUgPSAiSW5zdGFuY2VkTWVzaCIsIHMuY291bnQgPSB0aGlzLmNvdW50LCBzLmluc3RhbmNlTWF0cml4ID0gdGhpcy5pbnN0YW5jZU1hdHJpeC50b0pTT04oKSwgdGhpcy5pbnN0YW5jZUNvbG9yICE9PSBudWxsICYmIChzLmluc3RhbmNlQ29sb3IgPSB0aGlzLmluc3RhbmNlQ29sb3IudG9KU09OKCkpKSwgdGhpcy5pc0JhdGNoZWRNZXNoICYmIChzLnR5cGUgPSAiQmF0Y2hlZE1lc2giLCBzLnBlck9iamVjdEZydXN0dW1DdWxsZWQgPSB0aGlzLnBlck9iamVjdEZydXN0dW1DdWxsZWQsIHMuc29ydE9iamVjdHMgPSB0aGlzLnNvcnRPYmplY3RzLCBzLmRyYXdSYW5nZXMgPSB0aGlzLl9kcmF3UmFuZ2VzLCBzLnJlc2VydmVkUmFuZ2VzID0gdGhpcy5fcmVzZXJ2ZWRSYW5nZXMsIHMudmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2liaWxpdHksIHMuYWN0aXZlID0gdGhpcy5fYWN0aXZlLCBzLmJvdW5kcyA9IHRoaXMuX2JvdW5kcy5tYXAoKGEpID0+ICh7CiAgICAgICAgYm94SW5pdGlhbGl6ZWQ6IGEuYm94SW5pdGlhbGl6ZWQsCiAgICAgICAgYm94TWluOiBhLmJveC5taW4udG9BcnJheSgpLAogICAgICAgIGJveE1heDogYS5ib3gubWF4LnRvQXJyYXkoKSwKICAgICAgICBzcGhlcmVJbml0aWFsaXplZDogYS5zcGhlcmVJbml0aWFsaXplZCwKICAgICAgICBzcGhlcmVSYWRpdXM6IGEuc3BoZXJlLnJhZGl1cywKICAgICAgICBzcGhlcmVDZW50ZXI6IGEuc3BoZXJlLmNlbnRlci50b0FycmF5KCkKICAgICAgfSkpLCBzLm1heEluc3RhbmNlQ291bnQgPSB0aGlzLl9tYXhJbnN0YW5jZUNvdW50LCBzLm1heFZlcnRleENvdW50ID0gdGhpcy5fbWF4VmVydGV4Q291bnQsIHMubWF4SW5kZXhDb3VudCA9IHRoaXMuX21heEluZGV4Q291bnQsIHMuZ2VvbWV0cnlJbml0aWFsaXplZCA9IHRoaXMuX2dlb21ldHJ5SW5pdGlhbGl6ZWQsIHMuZ2VvbWV0cnlDb3VudCA9IHRoaXMuX2dlb21ldHJ5Q291bnQsIHMubWF0cmljZXNUZXh0dXJlID0gdGhpcy5fbWF0cmljZXNUZXh0dXJlLnRvSlNPTih0KSwgdGhpcy5fY29sb3JzVGV4dHVyZSAhPT0gbnVsbCAmJiAocy5jb2xvcnNUZXh0dXJlID0gdGhpcy5fY29sb3JzVGV4dHVyZS50b0pTT04odCkpLCB0aGlzLmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICYmIChzLmJvdW5kaW5nU3BoZXJlID0gewogICAgICAgIGNlbnRlcjogcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXIudG9BcnJheSgpLAogICAgICAgIHJhZGl1czogcy5ib3VuZGluZ1NwaGVyZS5yYWRpdXMKICAgICAgfSksIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgJiYgKHMuYm91bmRpbmdCb3ggPSB7CiAgICAgICAgbWluOiBzLmJvdW5kaW5nQm94Lm1pbi50b0FycmF5KCksCiAgICAgICAgbWF4OiBzLmJvdW5kaW5nQm94Lm1heC50b0FycmF5KCkKICAgICAgfSkpOwogICAgICBmdW5jdGlvbiByKGEsIG8pIHsKICAgICAgICByZXR1cm4gYVtvLnV1aWRdID09PSB2b2lkIDAgJiYgKGFbby51dWlkXSA9IG8udG9KU09OKHQpKSwgby51dWlkOwogICAgICB9CiAgICAgIGlmICh0aGlzLmlzU2NlbmUpCiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kICYmICh0aGlzLmJhY2tncm91bmQuaXNDb2xvciA/IHMuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04oKSA6IHRoaXMuYmFja2dyb3VuZC5pc1RleHR1cmUgJiYgKHMuYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZC50b0pTT04odCkudXVpZCkpLCB0aGlzLmVudmlyb25tZW50ICYmIHRoaXMuZW52aXJvbm1lbnQuaXNUZXh0dXJlICYmIHRoaXMuZW52aXJvbm1lbnQuaXNSZW5kZXJUYXJnZXRUZXh0dXJlICE9PSAhMCAmJiAocy5lbnZpcm9ubWVudCA9IHRoaXMuZW52aXJvbm1lbnQudG9KU09OKHQpLnV1aWQpOwogICAgICBlbHNlIGlmICh0aGlzLmlzTWVzaCB8fCB0aGlzLmlzTGluZSB8fCB0aGlzLmlzUG9pbnRzKSB7CiAgICAgICAgcy5nZW9tZXRyeSA9IHIodC5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5KTsKICAgICAgICBjb25zdCBhID0gdGhpcy5nZW9tZXRyeS5wYXJhbWV0ZXJzOwogICAgICAgIGlmIChhICE9PSB2b2lkIDAgJiYgYS5zaGFwZXMgIT09IHZvaWQgMCkgewogICAgICAgICAgY29uc3QgbyA9IGEuc2hhcGVzOwogICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykpCiAgICAgICAgICAgIGZvciAobGV0IGggPSAwLCB1ID0gby5sZW5ndGg7IGggPCB1OyBoKyspIHsKICAgICAgICAgICAgICBjb25zdCBsID0gb1toXTsKICAgICAgICAgICAgICByKHQuc2hhcGVzLCBsKTsKICAgICAgICAgICAgfQogICAgICAgICAgZWxzZQogICAgICAgICAgICByKHQuc2hhcGVzLCBvKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKHRoaXMuaXNTa2lubmVkTWVzaCAmJiAocy5iaW5kTW9kZSA9IHRoaXMuYmluZE1vZGUsIHMuYmluZE1hdHJpeCA9IHRoaXMuYmluZE1hdHJpeC50b0FycmF5KCksIHRoaXMuc2tlbGV0b24gIT09IHZvaWQgMCAmJiAocih0LnNrZWxldG9ucywgdGhpcy5za2VsZXRvbiksIHMuc2tlbGV0b24gPSB0aGlzLnNrZWxldG9uLnV1aWQpKSwgdGhpcy5tYXRlcmlhbCAhPT0gdm9pZCAwKQogICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMubWF0ZXJpYWwpKSB7CiAgICAgICAgICBjb25zdCBhID0gW107CiAgICAgICAgICBmb3IgKGxldCBvID0gMCwgaCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBvIDwgaDsgbysrKQogICAgICAgICAgICBhLnB1c2gocih0Lm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbFtvXSkpOwogICAgICAgICAgcy5tYXRlcmlhbCA9IGE7CiAgICAgICAgfSBlbHNlCiAgICAgICAgICBzLm1hdGVyaWFsID0gcih0Lm1hdGVyaWFscywgdGhpcy5tYXRlcmlhbCk7CiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHsKICAgICAgICBzLmNoaWxkcmVuID0gW107CiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgYSsrKQogICAgICAgICAgcy5jaGlsZHJlbi5wdXNoKHRoaXMuY2hpbGRyZW5bYV0udG9KU09OKHQpLm9iamVjdCk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuYW5pbWF0aW9ucy5sZW5ndGggPiAwKSB7CiAgICAgICAgcy5hbmltYXRpb25zID0gW107CiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBhKyspIHsKICAgICAgICAgIGNvbnN0IG8gPSB0aGlzLmFuaW1hdGlvbnNbYV07CiAgICAgICAgICBzLmFuaW1hdGlvbnMucHVzaChyKHQuYW5pbWF0aW9ucywgbykpOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoZSkgewogICAgICAgIGNvbnN0IGEgPSBuKHQuZ2VvbWV0cmllcyksIG8gPSBuKHQubWF0ZXJpYWxzKSwgaCA9IG4odC50ZXh0dXJlcyksIHUgPSBuKHQuaW1hZ2VzKSwgbCA9IG4odC5zaGFwZXMpLCBkID0gbih0LnNrZWxldG9ucyksIGMgPSBuKHQuYW5pbWF0aW9ucyksIG0gPSBuKHQubm9kZXMpOwogICAgICAgIGEubGVuZ3RoID4gMCAmJiAoaS5nZW9tZXRyaWVzID0gYSksIG8ubGVuZ3RoID4gMCAmJiAoaS5tYXRlcmlhbHMgPSBvKSwgaC5sZW5ndGggPiAwICYmIChpLnRleHR1cmVzID0gaCksIHUubGVuZ3RoID4gMCAmJiAoaS5pbWFnZXMgPSB1KSwgbC5sZW5ndGggPiAwICYmIChpLnNoYXBlcyA9IGwpLCBkLmxlbmd0aCA+IDAgJiYgKGkuc2tlbGV0b25zID0gZCksIGMubGVuZ3RoID4gMCAmJiAoaS5hbmltYXRpb25zID0gYyksIG0ubGVuZ3RoID4gMCAmJiAoaS5ub2RlcyA9IG0pOwogICAgICB9CiAgICAgIHJldHVybiBpLm9iamVjdCA9IHMsIGk7CiAgICAgIGZ1bmN0aW9uIG4oYSkgewogICAgICAgIGNvbnN0IG8gPSBbXTsKICAgICAgICBmb3IgKGNvbnN0IGggaW4gYSkgewogICAgICAgICAgY29uc3QgdSA9IGFbaF07CiAgICAgICAgICBkZWxldGUgdS5tZXRhZGF0YSwgby5wdXNoKHUpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbzsKICAgICAgfQogICAgfQogICAgY2xvbmUodCkgewogICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMsIHQpOwogICAgfQogICAgY29weSh0LCBlID0gITApIHsKICAgICAgaWYgKHRoaXMubmFtZSA9IHQubmFtZSwgdGhpcy51cC5jb3B5KHQudXApLCB0aGlzLnBvc2l0aW9uLmNvcHkodC5wb3NpdGlvbiksIHRoaXMucm90YXRpb24ub3JkZXIgPSB0LnJvdGF0aW9uLm9yZGVyLCB0aGlzLnF1YXRlcm5pb24uY29weSh0LnF1YXRlcm5pb24pLCB0aGlzLnNjYWxlLmNvcHkodC5zY2FsZSksIHRoaXMubWF0cml4LmNvcHkodC5tYXRyaXgpLCB0aGlzLm1hdHJpeFdvcmxkLmNvcHkodC5tYXRyaXhXb3JsZCksIHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHQubWF0cml4QXV0b1VwZGF0ZSwgdGhpcy5tYXRyaXhXb3JsZEF1dG9VcGRhdGUgPSB0Lm1hdHJpeFdvcmxkQXV0b1VwZGF0ZSwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlLCB0aGlzLmxheWVycy5tYXNrID0gdC5sYXllcnMubWFzaywgdGhpcy52aXNpYmxlID0gdC52aXNpYmxlLCB0aGlzLmNhc3RTaGFkb3cgPSB0LmNhc3RTaGFkb3csIHRoaXMucmVjZWl2ZVNoYWRvdyA9IHQucmVjZWl2ZVNoYWRvdywgdGhpcy5mcnVzdHVtQ3VsbGVkID0gdC5mcnVzdHVtQ3VsbGVkLCB0aGlzLnJlbmRlck9yZGVyID0gdC5yZW5kZXJPcmRlciwgdGhpcy5hbmltYXRpb25zID0gdC5hbmltYXRpb25zLnNsaWNlKCksIHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHQudXNlckRhdGEpKSwgZSA9PT0gITApCiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBjb25zdCBzID0gdC5jaGlsZHJlbltpXTsKICAgICAgICAgIHRoaXMuYWRkKHMuY2xvbmUoKSk7CiAgICAgICAgfQogICAgICByZXR1cm4gdGhpczsKICAgIH0KICB9CiAgY3QuREVGQVVMVF9VUCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygwLCAxLCAwKTsKICBjdC5ERUZBVUxUX01BVFJJWF9BVVRPX1VQREFURSA9ICEwOwogIGN0LkRFRkFVTFRfTUFUUklYX1dPUkxEX0FVVE9fVVBEQVRFID0gITA7CiAgY29uc3QgRGUgPSB7CiAgICBhbGljZWJsdWU6IDE1NzkyMzgzLAogICAgYW50aXF1ZXdoaXRlOiAxNjQ0NDM3NSwKICAgIGFxdWE6IDY1NTM1LAogICAgYXF1YW1hcmluZTogODM4ODU2NCwKICAgIGF6dXJlOiAxNTc5NDE3NSwKICAgIGJlaWdlOiAxNjExOTI2MCwKICAgIGJpc3F1ZTogMTY3NzAyNDQsCiAgICBibGFjazogMCwKICAgIGJsYW5jaGVkYWxtb25kOiAxNjc3MjA0NSwKICAgIGJsdWU6IDI1NSwKICAgIGJsdWV2aW9sZXQ6IDkwNTUyMDIsCiAgICBicm93bjogMTA4MjQyMzQsCiAgICBidXJseXdvb2Q6IDE0NTk2MjMxLAogICAgY2FkZXRibHVlOiA2MjY2NTI4LAogICAgY2hhcnRyZXVzZTogODM4ODM1MiwKICAgIGNob2NvbGF0ZTogMTM3ODk0NzAsCiAgICBjb3JhbDogMTY3NDQyNzIsCiAgICBjb3JuZmxvd2VyYmx1ZTogNjU5MTk4MSwKICAgIGNvcm5zaWxrOiAxNjc3NTM4OCwKICAgIGNyaW1zb246IDE0NDIzMTAwLAogICAgY3lhbjogNjU1MzUsCiAgICBkYXJrYmx1ZTogMTM5LAogICAgZGFya2N5YW46IDM1NzIzLAogICAgZGFya2dvbGRlbnJvZDogMTIwOTI5MzksCiAgICBkYXJrZ3JheTogMTExMTkwMTcsCiAgICBkYXJrZ3JlZW46IDI1NjAwLAogICAgZGFya2dyZXk6IDExMTE5MDE3LAogICAgZGFya2toYWtpOiAxMjQzMzI1OSwKICAgIGRhcmttYWdlbnRhOiA5MTA5NjQzLAogICAgZGFya29saXZlZ3JlZW46IDU1OTc5OTksCiAgICBkYXJrb3JhbmdlOiAxNjc0NzUyMCwKICAgIGRhcmtvcmNoaWQ6IDEwMDQwMDEyLAogICAgZGFya3JlZDogOTEwOTUwNCwKICAgIGRhcmtzYWxtb246IDE1MzA4NDEwLAogICAgZGFya3NlYWdyZWVuOiA5NDE5OTE5LAogICAgZGFya3NsYXRlYmx1ZTogNDczNDM0NywKICAgIGRhcmtzbGF0ZWdyYXk6IDMxMDA0OTUsCiAgICBkYXJrc2xhdGVncmV5OiAzMTAwNDk1LAogICAgZGFya3R1cnF1b2lzZTogNTI5NDUsCiAgICBkYXJrdmlvbGV0OiA5Njk5NTM5LAogICAgZGVlcHBpbms6IDE2NzE2OTQ3LAogICAgZGVlcHNreWJsdWU6IDQ5MTUxLAogICAgZGltZ3JheTogNjkwODI2NSwKICAgIGRpbWdyZXk6IDY5MDgyNjUsCiAgICBkb2RnZXJibHVlOiAyMDAzMTk5LAogICAgZmlyZWJyaWNrOiAxMTY3NDE0NiwKICAgIGZsb3JhbHdoaXRlOiAxNjc3NTkyMCwKICAgIGZvcmVzdGdyZWVuOiAyMjYzODQyLAogICAgZnVjaHNpYTogMTY3MTE5MzUsCiAgICBnYWluc2Jvcm86IDE0NDc0NDYwLAogICAgZ2hvc3R3aGl0ZTogMTYzMTY2NzEsCiAgICBnb2xkOiAxNjc2NjcyMCwKICAgIGdvbGRlbnJvZDogMTQzMjkxMjAsCiAgICBncmF5OiA4NDIxNTA0LAogICAgZ3JlZW46IDMyNzY4LAogICAgZ3JlZW55ZWxsb3c6IDExNDAzMDU1LAogICAgZ3JleTogODQyMTUwNCwKICAgIGhvbmV5ZGV3OiAxNTc5NDE2MCwKICAgIGhvdHBpbms6IDE2NzM4NzQwLAogICAgaW5kaWFucmVkOiAxMzQ1ODUyNCwKICAgIGluZGlnbzogNDkxNTMzMCwKICAgIGl2b3J5OiAxNjc3NzIwMCwKICAgIGtoYWtpOiAxNTc4NzY2MCwKICAgIGxhdmVuZGVyOiAxNTEzMjQxMCwKICAgIGxhdmVuZGVyYmx1c2g6IDE2NzczMzY1LAogICAgbGF3bmdyZWVuOiA4MTkwOTc2LAogICAgbGVtb25jaGlmZm9uOiAxNjc3NTg4NSwKICAgIGxpZ2h0Ymx1ZTogMTEzOTMyNTQsCiAgICBsaWdodGNvcmFsOiAxNTc2MTUzNiwKICAgIGxpZ2h0Y3lhbjogMTQ3NDU1OTksCiAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogMTY0NDgyMTAsCiAgICBsaWdodGdyYXk6IDEzODgyMzIzLAogICAgbGlnaHRncmVlbjogOTQ5ODI1NiwKICAgIGxpZ2h0Z3JleTogMTM4ODIzMjMsCiAgICBsaWdodHBpbms6IDE2NzU4NDY1LAogICAgbGlnaHRzYWxtb246IDE2NzUyNzYyLAogICAgbGlnaHRzZWFncmVlbjogMjE0Mjg5MCwKICAgIGxpZ2h0c2t5Ymx1ZTogODkwMDM0NiwKICAgIGxpZ2h0c2xhdGVncmF5OiA3ODMzNzUzLAogICAgbGlnaHRzbGF0ZWdyZXk6IDc4MzM3NTMsCiAgICBsaWdodHN0ZWVsYmx1ZTogMTE1ODQ3MzQsCiAgICBsaWdodHllbGxvdzogMTY3NzcxODQsCiAgICBsaW1lOiA2NTI4MCwKICAgIGxpbWVncmVlbjogMzMyOTMzMCwKICAgIGxpbmVuOiAxNjQ0NTY3MCwKICAgIG1hZ2VudGE6IDE2NzExOTM1LAogICAgbWFyb29uOiA4Mzg4NjA4LAogICAgbWVkaXVtYXF1YW1hcmluZTogNjczNzMyMiwKICAgIG1lZGl1bWJsdWU6IDIwNSwKICAgIG1lZGl1bW9yY2hpZDogMTIyMTE2NjcsCiAgICBtZWRpdW1wdXJwbGU6IDk2NjI2ODMsCiAgICBtZWRpdW1zZWFncmVlbjogMzk3ODA5NywKICAgIG1lZGl1bXNsYXRlYmx1ZTogODA4Nzc5MCwKICAgIG1lZGl1bXNwcmluZ2dyZWVuOiA2NDE1NCwKICAgIG1lZGl1bXR1cnF1b2lzZTogNDc3MjMwMCwKICAgIG1lZGl1bXZpb2xldHJlZDogMTMwNDcxNzMsCiAgICBtaWRuaWdodGJsdWU6IDE2NDQ5MTIsCiAgICBtaW50Y3JlYW06IDE2MTIxODUwLAogICAgbWlzdHlyb3NlOiAxNjc3MDI3MywKICAgIG1vY2Nhc2luOiAxNjc3MDIyOSwKICAgIG5hdmFqb3doaXRlOiAxNjc2ODY4NSwKICAgIG5hdnk6IDEyOCwKICAgIG9sZGxhY2U6IDE2NjQzNTU4LAogICAgb2xpdmU6IDg0MjEzNzYsCiAgICBvbGl2ZWRyYWI6IDcwNDg3MzksCiAgICBvcmFuZ2U6IDE2NzUzOTIwLAogICAgb3JhbmdlcmVkOiAxNjcyOTM0NCwKICAgIG9yY2hpZDogMTQzMTU3MzQsCiAgICBwYWxlZ29sZGVucm9kOiAxNTY1NzEzMCwKICAgIHBhbGVncmVlbjogMTAwMjU4ODAsCiAgICBwYWxldHVycXVvaXNlOiAxMTUyOTk2NiwKICAgIHBhbGV2aW9sZXRyZWQ6IDE0MzgxMjAzLAogICAgcGFwYXlhd2hpcDogMTY3NzMwNzcsCiAgICBwZWFjaHB1ZmY6IDE2NzY3NjczLAogICAgcGVydTogMTM0Njg5OTEsCiAgICBwaW5rOiAxNjc2MTAzNSwKICAgIHBsdW06IDE0NTI0NjM3LAogICAgcG93ZGVyYmx1ZTogMTE1OTE5MTAsCiAgICBwdXJwbGU6IDgzODg3MzYsCiAgICByZWJlY2NhcHVycGxlOiA2Njk3ODgxLAogICAgcmVkOiAxNjcxMTY4MCwKICAgIHJvc3licm93bjogMTIzNTc1MTksCiAgICByb3lhbGJsdWU6IDQyODY5NDUsCiAgICBzYWRkbGVicm93bjogOTEyNzE4NywKICAgIHNhbG1vbjogMTY0MTY4ODIsCiAgICBzYW5keWJyb3duOiAxNjAzMjg2NCwKICAgIHNlYWdyZWVuOiAzMDUwMzI3LAogICAgc2Vhc2hlbGw6IDE2Nzc0NjM4LAogICAgc2llbm5hOiAxMDUwNjc5NywKICAgIHNpbHZlcjogMTI2MzIyNTYsCiAgICBza3libHVlOiA4OTAwMzMxLAogICAgc2xhdGVibHVlOiA2OTcwMDYxLAogICAgc2xhdGVncmF5OiA3MzcyOTQ0LAogICAgc2xhdGVncmV5OiA3MzcyOTQ0LAogICAgc25vdzogMTY3NzU5MzAsCiAgICBzcHJpbmdncmVlbjogNjU0MDcsCiAgICBzdGVlbGJsdWU6IDQ2MjA5ODAsCiAgICB0YW46IDEzODA4NzgwLAogICAgdGVhbDogMzI4OTYsCiAgICB0aGlzdGxlOiAxNDIwNDg4OCwKICAgIHRvbWF0bzogMTY3MzcwOTUsCiAgICB0dXJxdW9pc2U6IDQyNTE4NTYsCiAgICB2aW9sZXQ6IDE1NjMxMDg2LAogICAgd2hlYXQ6IDE2MTEzMzMxLAogICAgd2hpdGU6IDE2Nzc3MjE1LAogICAgd2hpdGVzbW9rZTogMTYxMTkyODUsCiAgICB5ZWxsb3c6IDE2Nzc2OTYwLAogICAgeWVsbG93Z3JlZW46IDEwMTQ1MDc0CiAgfSwgbHQgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfSwgdnQgPSB7IGg6IDAsIHM6IDAsIGw6IDAgfTsKICBmdW5jdGlvbiBvZShmLCB0LCBlKSB7CiAgICByZXR1cm4gZSA8IDAgJiYgKGUgKz0gMSksIGUgPiAxICYmIChlIC09IDEpLCBlIDwgMSAvIDYgPyBmICsgKHQgLSBmKSAqIDYgKiBlIDogZSA8IDEgLyAyID8gdCA6IGUgPCAyIC8gMyA/IGYgKyAodCAtIGYpICogNiAqICgyIC8gMyAtIGUpIDogZjsKICB9CiAgY2xhc3MgZGUgewogICAgY29uc3RydWN0b3IodCwgZSwgaSkgewogICAgICByZXR1cm4gdGhpcy5pc0NvbG9yID0gITAsIHRoaXMuciA9IDEsIHRoaXMuZyA9IDEsIHRoaXMuYiA9IDEsIHRoaXMuc2V0KHQsIGUsIGkpOwogICAgfQogICAgc2V0KHQsIGUsIGkpIHsKICAgICAgaWYgKGUgPT09IHZvaWQgMCAmJiBpID09PSB2b2lkIDApIHsKICAgICAgICBjb25zdCBzID0gdDsKICAgICAgICBzICYmIHMuaXNDb2xvciA/IHRoaXMuY29weShzKSA6IHR5cGVvZiBzID09ICJudW1iZXIiID8gdGhpcy5zZXRIZXgocykgOiB0eXBlb2YgcyA9PSAic3RyaW5nIiAmJiB0aGlzLnNldFN0eWxlKHMpOwogICAgICB9IGVsc2UKICAgICAgICB0aGlzLnNldFJHQih0LCBlLCBpKTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBzZXRTY2FsYXIodCkgewogICAgICByZXR1cm4gdGhpcy5yID0gdCwgdGhpcy5nID0gdCwgdGhpcy5iID0gdCwgdGhpczsKICAgIH0KICAgIHNldEhleCh0LCBlID0gWCkgewogICAgICByZXR1cm4gdCA9IE1hdGguZmxvb3IodCksIHRoaXMuciA9ICh0ID4+IDE2ICYgMjU1KSAvIDI1NSwgdGhpcy5nID0gKHQgPj4gOCAmIDI1NSkgLyAyNTUsIHRoaXMuYiA9ICh0ICYgMjU1KSAvIDI1NSwgai50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIGUpLCB0aGlzOwogICAgfQogICAgc2V0UkdCKHQsIGUsIGksIHMgPSBqLndvcmtpbmdDb2xvclNwYWNlKSB7CiAgICAgIHJldHVybiB0aGlzLnIgPSB0LCB0aGlzLmcgPSBlLCB0aGlzLmIgPSBpLCBqLnRvV29ya2luZ0NvbG9yU3BhY2UodGhpcywgcyksIHRoaXM7CiAgICB9CiAgICBzZXRIU0wodCwgZSwgaSwgcyA9IGoud29ya2luZ0NvbG9yU3BhY2UpIHsKICAgICAgaWYgKHQgPSBQZSh0LCAxKSwgZSA9IFQoZSwgMCwgMSksIGkgPSBUKGksIDAsIDEpLCBlID09PSAwKQogICAgICAgIHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGk7CiAgICAgIGVsc2UgewogICAgICAgIGNvbnN0IHIgPSBpIDw9IDAuNSA/IGkgKiAoMSArIGUpIDogaSArIGUgLSBpICogZSwgbiA9IDIgKiBpIC0gcjsKICAgICAgICB0aGlzLnIgPSBvZShuLCByLCB0ICsgMSAvIDMpLCB0aGlzLmcgPSBvZShuLCByLCB0KSwgdGhpcy5iID0gb2UobiwgciwgdCAtIDEgLyAzKTsKICAgICAgfQogICAgICByZXR1cm4gai50b1dvcmtpbmdDb2xvclNwYWNlKHRoaXMsIHMpLCB0aGlzOwogICAgfQogICAgc2V0U3R5bGUodCwgZSA9IFgpIHsKICAgICAgZnVuY3Rpb24gaShyKSB7CiAgICAgICAgciAhPT0gdm9pZCAwICYmIHBhcnNlRmxvYXQocikgPCAxICYmIGNvbnNvbGUud2FybigiVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAiICsgdCArICIgd2lsbCBiZSBpZ25vcmVkLiIpOwogICAgICB9CiAgICAgIGxldCBzOwogICAgICBpZiAocyA9IC9eKFx3KylcKChbXlwpXSopXCkvLmV4ZWModCkpIHsKICAgICAgICBsZXQgcjsKICAgICAgICBjb25zdCBuID0gc1sxXSwgYSA9IHNbMl07CiAgICAgICAgc3dpdGNoIChuKSB7CiAgICAgICAgICBjYXNlICJyZ2IiOgogICAgICAgICAgY2FzZSAicmdiYSI6CiAgICAgICAgICAgIGlmIChyID0gL15ccyooXGQrKVxzKixccyooXGQrKVxzKixccyooXGQrKVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhhKSkKICAgICAgICAgICAgICByZXR1cm4gaShyWzRdKSwgdGhpcy5zZXRSR0IoCiAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIHBhcnNlSW50KHJbMV0sIDEwKSkgLyAyNTUsCiAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIHBhcnNlSW50KHJbMl0sIDEwKSkgLyAyNTUsCiAgICAgICAgICAgICAgICBNYXRoLm1pbigyNTUsIHBhcnNlSW50KHJbM10sIDEwKSkgLyAyNTUsCiAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgaWYgKHIgPSAvXlxzKihcZCspXCVccyosXHMqKFxkKylcJVxzKixccyooXGQrKVwlXHMqKD86LFxzKihcZCpcLj9cZCspXHMqKT8kLy5leGVjKGEpKQogICAgICAgICAgICAgIHJldHVybiBpKHJbNF0pLCB0aGlzLnNldFJHQigKICAgICAgICAgICAgICAgIE1hdGgubWluKDEwMCwgcGFyc2VJbnQoclsxXSwgMTApKSAvIDEwMCwKICAgICAgICAgICAgICAgIE1hdGgubWluKDEwMCwgcGFyc2VJbnQoclsyXSwgMTApKSAvIDEwMCwKICAgICAgICAgICAgICAgIE1hdGgubWluKDEwMCwgcGFyc2VJbnQoclszXSwgMTApKSAvIDEwMCwKICAgICAgICAgICAgICAgIGUKICAgICAgICAgICAgICApOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgImhzbCI6CiAgICAgICAgICBjYXNlICJoc2xhIjoKICAgICAgICAgICAgaWYgKHIgPSAvXlxzKihcZCpcLj9cZCspXHMqLFxzKihcZCpcLj9cZCspXCVccyosXHMqKFxkKlwuP1xkKylcJVxzKig/OixccyooXGQqXC4/XGQrKVxzKik/JC8uZXhlYyhhKSkKICAgICAgICAgICAgICByZXR1cm4gaShyWzRdKSwgdGhpcy5zZXRIU0woCiAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHJbMV0pIC8gMzYwLAogICAgICAgICAgICAgICAgcGFyc2VGbG9hdChyWzJdKSAvIDEwMCwKICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoclszXSkgLyAxMDAsCiAgICAgICAgICAgICAgICBlCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICBjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBVbmtub3duIGNvbG9yIG1vZGVsICIgKyB0KTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAocyA9IC9eXCMoW0EtRmEtZlxkXSspJC8uZXhlYyh0KSkgewogICAgICAgIGNvbnN0IHIgPSBzWzFdLCBuID0gci5sZW5ndGg7CiAgICAgICAgaWYgKG4gPT09IDMpCiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRSR0IoCiAgICAgICAgICAgIHBhcnNlSW50KHIuY2hhckF0KDApLCAxNikgLyAxNSwKICAgICAgICAgICAgcGFyc2VJbnQoci5jaGFyQXQoMSksIDE2KSAvIDE1LAogICAgICAgICAgICBwYXJzZUludChyLmNoYXJBdCgyKSwgMTYpIC8gMTUsCiAgICAgICAgICAgIGUKICAgICAgICAgICk7CiAgICAgICAgaWYgKG4gPT09IDYpCiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRIZXgocGFyc2VJbnQociwgMTYpLCBlKTsKICAgICAgICBjb25zb2xlLndhcm4oIlRIUkVFLkNvbG9yOiBJbnZhbGlkIGhleCBjb2xvciAiICsgdCk7CiAgICAgIH0gZWxzZSBpZiAodCAmJiB0Lmxlbmd0aCA+IDApCiAgICAgICAgcmV0dXJuIHRoaXMuc2V0Q29sb3JOYW1lKHQsIGUpOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIHNldENvbG9yTmFtZSh0LCBlID0gWCkgewogICAgICBjb25zdCBpID0gRGVbdC50b0xvd2VyQ2FzZSgpXTsKICAgICAgcmV0dXJuIGkgIT09IHZvaWQgMCA/IHRoaXMuc2V0SGV4KGksIGUpIDogY29uc29sZS53YXJuKCJUSFJFRS5Db2xvcjogVW5rbm93biBjb2xvciAiICsgdCksIHRoaXM7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIpOwogICAgfQogICAgY29weSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnIgPSB0LnIsIHRoaXMuZyA9IHQuZywgdGhpcy5iID0gdC5iLCB0aGlzOwogICAgfQogICAgY29weVNSR0JUb0xpbmVhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnIgPSBudCh0LnIpLCB0aGlzLmcgPSBudCh0LmcpLCB0aGlzLmIgPSBudCh0LmIpLCB0aGlzOwogICAgfQogICAgY29weUxpbmVhclRvU1JHQih0KSB7CiAgICAgIHJldHVybiB0aGlzLnIgPSBTdCh0LnIpLCB0aGlzLmcgPSBTdCh0LmcpLCB0aGlzLmIgPSBTdCh0LmIpLCB0aGlzOwogICAgfQogICAgY29udmVydFNSR0JUb0xpbmVhcigpIHsKICAgICAgcmV0dXJuIHRoaXMuY29weVNSR0JUb0xpbmVhcih0aGlzKSwgdGhpczsKICAgIH0KICAgIGNvbnZlcnRMaW5lYXJUb1NSR0IoKSB7CiAgICAgIHJldHVybiB0aGlzLmNvcHlMaW5lYXJUb1NSR0IodGhpcyksIHRoaXM7CiAgICB9CiAgICBnZXRIZXgodCA9IFgpIHsKICAgICAgcmV0dXJuIGouZnJvbVdvcmtpbmdDb2xvclNwYWNlKE8uY29weSh0aGlzKSwgdCksIE1hdGgucm91bmQoVChPLnIgKiAyNTUsIDAsIDI1NSkpICogNjU1MzYgKyBNYXRoLnJvdW5kKFQoTy5nICogMjU1LCAwLCAyNTUpKSAqIDI1NiArIE1hdGgucm91bmQoVChPLmIgKiAyNTUsIDAsIDI1NSkpOwogICAgfQogICAgZ2V0SGV4U3RyaW5nKHQgPSBYKSB7CiAgICAgIHJldHVybiAoIjAwMDAwMCIgKyB0aGlzLmdldEhleCh0KS50b1N0cmluZygxNikpLnNsaWNlKC02KTsKICAgIH0KICAgIGdldEhTTCh0LCBlID0gai53b3JraW5nQ29sb3JTcGFjZSkgewogICAgICBqLmZyb21Xb3JraW5nQ29sb3JTcGFjZShPLmNvcHkodGhpcyksIGUpOwogICAgICBjb25zdCBpID0gTy5yLCBzID0gTy5nLCByID0gTy5iLCBuID0gTWF0aC5tYXgoaSwgcywgciksIGEgPSBNYXRoLm1pbihpLCBzLCByKTsKICAgICAgbGV0IG8sIGg7CiAgICAgIGNvbnN0IHUgPSAoYSArIG4pIC8gMjsKICAgICAgaWYgKGEgPT09IG4pCiAgICAgICAgbyA9IDAsIGggPSAwOwogICAgICBlbHNlIHsKICAgICAgICBjb25zdCBsID0gbiAtIGE7CiAgICAgICAgc3dpdGNoIChoID0gdSA8PSAwLjUgPyBsIC8gKG4gKyBhKSA6IGwgLyAoMiAtIG4gLSBhKSwgbikgewogICAgICAgICAgY2FzZSBpOgogICAgICAgICAgICBvID0gKHMgLSByKSAvIGwgKyAocyA8IHIgPyA2IDogMCk7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgY2FzZSBzOgogICAgICAgICAgICBvID0gKHIgLSBpKSAvIGwgKyAyOwogICAgICAgICAgICBicmVhazsKICAgICAgICAgIGNhc2UgcjoKICAgICAgICAgICAgbyA9IChpIC0gcykgLyBsICsgNDsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIG8gLz0gNjsKICAgICAgfQogICAgICByZXR1cm4gdC5oID0gbywgdC5zID0gaCwgdC5sID0gdSwgdDsKICAgIH0KICAgIGdldFJHQih0LCBlID0gai53b3JraW5nQ29sb3JTcGFjZSkgewogICAgICByZXR1cm4gai5mcm9tV29ya2luZ0NvbG9yU3BhY2UoTy5jb3B5KHRoaXMpLCBlKSwgdC5yID0gTy5yLCB0LmcgPSBPLmcsIHQuYiA9IE8uYiwgdDsKICAgIH0KICAgIGdldFN0eWxlKHQgPSBYKSB7CiAgICAgIGouZnJvbVdvcmtpbmdDb2xvclNwYWNlKE8uY29weSh0aGlzKSwgdCk7CiAgICAgIGNvbnN0IGUgPSBPLnIsIGkgPSBPLmcsIHMgPSBPLmI7CiAgICAgIHJldHVybiB0ICE9PSBYID8gYGNvbG9yKCR7dH0gJHtlLnRvRml4ZWQoMyl9ICR7aS50b0ZpeGVkKDMpfSAke3MudG9GaXhlZCgzKX0pYCA6IGByZ2IoJHtNYXRoLnJvdW5kKGUgKiAyNTUpfSwke01hdGgucm91bmQoaSAqIDI1NSl9LCR7TWF0aC5yb3VuZChzICogMjU1KX0pYDsKICAgIH0KICAgIG9mZnNldEhTTCh0LCBlLCBpKSB7CiAgICAgIHJldHVybiB0aGlzLmdldEhTTChsdCksIHRoaXMuc2V0SFNMKGx0LmggKyB0LCBsdC5zICsgZSwgbHQubCArIGkpOwogICAgfQogICAgYWRkKHQpIHsKICAgICAgcmV0dXJuIHRoaXMuciArPSB0LnIsIHRoaXMuZyArPSB0LmcsIHRoaXMuYiArPSB0LmIsIHRoaXM7CiAgICB9CiAgICBhZGRDb2xvcnModCwgZSkgewogICAgICByZXR1cm4gdGhpcy5yID0gdC5yICsgZS5yLCB0aGlzLmcgPSB0LmcgKyBlLmcsIHRoaXMuYiA9IHQuYiArIGUuYiwgdGhpczsKICAgIH0KICAgIGFkZFNjYWxhcih0KSB7CiAgICAgIHJldHVybiB0aGlzLnIgKz0gdCwgdGhpcy5nICs9IHQsIHRoaXMuYiArPSB0LCB0aGlzOwogICAgfQogICAgc3ViKHQpIHsKICAgICAgcmV0dXJuIHRoaXMuciA9IE1hdGgubWF4KDAsIHRoaXMuciAtIHQuciksIHRoaXMuZyA9IE1hdGgubWF4KDAsIHRoaXMuZyAtIHQuZyksIHRoaXMuYiA9IE1hdGgubWF4KDAsIHRoaXMuYiAtIHQuYiksIHRoaXM7CiAgICB9CiAgICBtdWx0aXBseSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnIgKj0gdC5yLCB0aGlzLmcgKj0gdC5nLCB0aGlzLmIgKj0gdC5iLCB0aGlzOwogICAgfQogICAgbXVsdGlwbHlTY2FsYXIodCkgewogICAgICByZXR1cm4gdGhpcy5yICo9IHQsIHRoaXMuZyAqPSB0LCB0aGlzLmIgKj0gdCwgdGhpczsKICAgIH0KICAgIGxlcnAodCwgZSkgewogICAgICByZXR1cm4gdGhpcy5yICs9ICh0LnIgLSB0aGlzLnIpICogZSwgdGhpcy5nICs9ICh0LmcgLSB0aGlzLmcpICogZSwgdGhpcy5iICs9ICh0LmIgLSB0aGlzLmIpICogZSwgdGhpczsKICAgIH0KICAgIGxlcnBDb2xvcnModCwgZSwgaSkgewogICAgICByZXR1cm4gdGhpcy5yID0gdC5yICsgKGUuciAtIHQucikgKiBpLCB0aGlzLmcgPSB0LmcgKyAoZS5nIC0gdC5nKSAqIGksIHRoaXMuYiA9IHQuYiArIChlLmIgLSB0LmIpICogaSwgdGhpczsKICAgIH0KICAgIGxlcnBIU0wodCwgZSkgewogICAgICB0aGlzLmdldEhTTChsdCksIHQuZ2V0SFNMKHZ0KTsKICAgICAgY29uc3QgaSA9IHRlKGx0LmgsIHZ0LmgsIGUpLCBzID0gdGUobHQucywgdnQucywgZSksIHIgPSB0ZShsdC5sLCB2dC5sLCBlKTsKICAgICAgcmV0dXJuIHRoaXMuc2V0SFNMKGksIHMsIHIpLCB0aGlzOwogICAgfQogICAgc2V0RnJvbVZlY3RvcjModCkgewogICAgICByZXR1cm4gdGhpcy5yID0gdC54LCB0aGlzLmcgPSB0LnksIHRoaXMuYiA9IHQueiwgdGhpczsKICAgIH0KICAgIGFwcGx5TWF0cml4Myh0KSB7CiAgICAgIGNvbnN0IGUgPSB0aGlzLnIsIGkgPSB0aGlzLmcsIHMgPSB0aGlzLmIsIHIgPSB0LmVsZW1lbnRzOwogICAgICByZXR1cm4gdGhpcy5yID0gclswXSAqIGUgKyByWzNdICogaSArIHJbNl0gKiBzLCB0aGlzLmcgPSByWzFdICogZSArIHJbNF0gKiBpICsgcls3XSAqIHMsIHRoaXMuYiA9IHJbMl0gKiBlICsgcls1XSAqIGkgKyByWzhdICogcywgdGhpczsKICAgIH0KICAgIGVxdWFscyh0KSB7CiAgICAgIHJldHVybiB0LnIgPT09IHRoaXMuciAmJiB0LmcgPT09IHRoaXMuZyAmJiB0LmIgPT09IHRoaXMuYjsKICAgIH0KICAgIGZyb21BcnJheSh0LCBlID0gMCkgewogICAgICByZXR1cm4gdGhpcy5yID0gdFtlXSwgdGhpcy5nID0gdFtlICsgMV0sIHRoaXMuYiA9IHRbZSArIDJdLCB0aGlzOwogICAgfQogICAgdG9BcnJheSh0ID0gW10sIGUgPSAwKSB7CiAgICAgIHJldHVybiB0W2VdID0gdGhpcy5yLCB0W2UgKyAxXSA9IHRoaXMuZywgdFtlICsgMl0gPSB0aGlzLmIsIHQ7CiAgICB9CiAgICBmcm9tQnVmZmVyQXR0cmlidXRlKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMuciA9IHQuZ2V0WChlKSwgdGhpcy5nID0gdC5nZXRZKGUpLCB0aGlzLmIgPSB0LmdldFooZSksIHRoaXM7CiAgICB9CiAgICB0b0pTT04oKSB7CiAgICAgIHJldHVybiB0aGlzLmdldEhleCgpOwogICAgfQogICAgKltTeW1ib2wuaXRlcmF0b3JdKCkgewogICAgICB5aWVsZCB0aGlzLnIsIHlpZWxkIHRoaXMuZywgeWllbGQgdGhpcy5iOwogICAgfQogIH0KICBjb25zdCBPID0gLyogQF9fUFVSRV9fICovIG5ldyBkZSgpOwogIGRlLk5BTUVTID0gRGU7CiAgY29uc3QgSSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZygpLCBZdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgcnQoKTsKICBsZXQgUWUgPSAwOwogIGNsYXNzIFEgewogICAgY29uc3RydWN0b3IodCwgZSwgaSA9ICExKSB7CiAgICAgIGlmIChBcnJheS5pc0FycmF5KHQpKQogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIlRIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuIik7CiAgICAgIHRoaXMuaXNCdWZmZXJBdHRyaWJ1dGUgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICJpZCIsIHsgdmFsdWU6IFFlKysgfSksIHRoaXMubmFtZSA9ICIiLCB0aGlzLmFycmF5ID0gdCwgdGhpcy5pdGVtU2l6ZSA9IGUsIHRoaXMuY291bnQgPSB0ICE9PSB2b2lkIDAgPyB0Lmxlbmd0aCAvIGUgOiAwLCB0aGlzLm5vcm1hbGl6ZWQgPSBpLCB0aGlzLnVzYWdlID0gMzUwNDQsIHRoaXMudXBkYXRlUmFuZ2VzID0gW10sIHRoaXMuZ3B1VHlwZSA9IDEwMTUsIHRoaXMudmVyc2lvbiA9IDA7CiAgICB9CiAgICBvblVwbG9hZENhbGxiYWNrKCkgewogICAgfQogICAgc2V0IG5lZWRzVXBkYXRlKHQpIHsKICAgICAgdCA9PT0gITAgJiYgdGhpcy52ZXJzaW9uKys7CiAgICB9CiAgICBzZXRVc2FnZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLnVzYWdlID0gdCwgdGhpczsKICAgIH0KICAgIGFkZFVwZGF0ZVJhbmdlKHQsIGUpIHsKICAgICAgdGhpcy51cGRhdGVSYW5nZXMucHVzaCh7IHN0YXJ0OiB0LCBjb3VudDogZSB9KTsKICAgIH0KICAgIGNsZWFyVXBkYXRlUmFuZ2VzKCkgewogICAgICB0aGlzLnVwZGF0ZVJhbmdlcy5sZW5ndGggPSAwOwogICAgfQogICAgY29weSh0KSB7CiAgICAgIHJldHVybiB0aGlzLm5hbWUgPSB0Lm5hbWUsIHRoaXMuYXJyYXkgPSBuZXcgdC5hcnJheS5jb25zdHJ1Y3Rvcih0LmFycmF5KSwgdGhpcy5pdGVtU2l6ZSA9IHQuaXRlbVNpemUsIHRoaXMuY291bnQgPSB0LmNvdW50LCB0aGlzLm5vcm1hbGl6ZWQgPSB0Lm5vcm1hbGl6ZWQsIHRoaXMudXNhZ2UgPSB0LnVzYWdlLCB0aGlzLmdwdVR5cGUgPSB0LmdwdVR5cGUsIHRoaXM7CiAgICB9CiAgICBjb3B5QXQodCwgZSwgaSkgewogICAgICB0ICo9IHRoaXMuaXRlbVNpemUsIGkgKj0gZS5pdGVtU2l6ZTsKICAgICAgZm9yIChsZXQgcyA9IDAsIHIgPSB0aGlzLml0ZW1TaXplOyBzIDwgcjsgcysrKQogICAgICAgIHRoaXMuYXJyYXlbdCArIHNdID0gZS5hcnJheVtpICsgc107CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgY29weUFycmF5KHQpIHsKICAgICAgcmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQpLCB0aGlzOwogICAgfQogICAgYXBwbHlNYXRyaXgzKHQpIHsKICAgICAgaWYgKHRoaXMuaXRlbVNpemUgPT09IDIpCiAgICAgICAgZm9yIChsZXQgZSA9IDAsIGkgPSB0aGlzLmNvdW50OyBlIDwgaTsgZSsrKQogICAgICAgICAgWXQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBlKSwgWXQuYXBwbHlNYXRyaXgzKHQpLCB0aGlzLnNldFhZKGUsIFl0LngsIFl0LnkpOwogICAgICBlbHNlIGlmICh0aGlzLml0ZW1TaXplID09PSAzKQogICAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdGhpcy5jb3VudDsgZSA8IGk7IGUrKykKICAgICAgICAgIEkuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0aGlzLCBlKSwgSS5hcHBseU1hdHJpeDModCksIHRoaXMuc2V0WFlaKGUsIEkueCwgSS55LCBJLnopOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIGFwcGx5TWF0cml4NCh0KSB7CiAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdGhpcy5jb3VudDsgZSA8IGk7IGUrKykKICAgICAgICBJLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgZSksIEkuYXBwbHlNYXRyaXg0KHQpLCB0aGlzLnNldFhZWihlLCBJLngsIEkueSwgSS56KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBhcHBseU5vcm1hbE1hdHJpeCh0KSB7CiAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdGhpcy5jb3VudDsgZSA8IGk7IGUrKykKICAgICAgICBJLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgZSksIEkuYXBwbHlOb3JtYWxNYXRyaXgodCksIHRoaXMuc2V0WFlaKGUsIEkueCwgSS55LCBJLnopOwogICAgICByZXR1cm4gdGhpczsKICAgIH0KICAgIHRyYW5zZm9ybURpcmVjdGlvbih0KSB7CiAgICAgIGZvciAobGV0IGUgPSAwLCBpID0gdGhpcy5jb3VudDsgZSA8IGk7IGUrKykKICAgICAgICBJLmZyb21CdWZmZXJBdHRyaWJ1dGUodGhpcywgZSksIEkudHJhbnNmb3JtRGlyZWN0aW9uKHQpLCB0aGlzLnNldFhZWihlLCBJLngsIEkueSwgSS56KTsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBzZXQodCwgZSA9IDApIHsKICAgICAgcmV0dXJuIHRoaXMuYXJyYXkuc2V0KHQsIGUpLCB0aGlzOwogICAgfQogICAgZ2V0Q29tcG9uZW50KHQsIGUpIHsKICAgICAgbGV0IGkgPSB0aGlzLmFycmF5W3QgKiB0aGlzLml0ZW1TaXplICsgZV07CiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWQgJiYgKGkgPSBDdChpLCB0aGlzLmFycmF5KSksIGk7CiAgICB9CiAgICBzZXRDb21wb25lbnQodCwgZSwgaSkgewogICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkICYmIChpID0gdihpLCB0aGlzLmFycmF5KSksIHRoaXMuYXJyYXlbdCAqIHRoaXMuaXRlbVNpemUgKyBlXSA9IGksIHRoaXM7CiAgICB9CiAgICBnZXRYKHQpIHsKICAgICAgbGV0IGUgPSB0aGlzLmFycmF5W3QgKiB0aGlzLml0ZW1TaXplXTsKICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZCAmJiAoZSA9IEN0KGUsIHRoaXMuYXJyYXkpKSwgZTsKICAgIH0KICAgIHNldFgodCwgZSkgewogICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkICYmIChlID0gdihlLCB0aGlzLmFycmF5KSksIHRoaXMuYXJyYXlbdCAqIHRoaXMuaXRlbVNpemVdID0gZSwgdGhpczsKICAgIH0KICAgIGdldFkodCkgewogICAgICBsZXQgZSA9IHRoaXMuYXJyYXlbdCAqIHRoaXMuaXRlbVNpemUgKyAxXTsKICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZCAmJiAoZSA9IEN0KGUsIHRoaXMuYXJyYXkpKSwgZTsKICAgIH0KICAgIHNldFkodCwgZSkgewogICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkICYmIChlID0gdihlLCB0aGlzLmFycmF5KSksIHRoaXMuYXJyYXlbdCAqIHRoaXMuaXRlbVNpemUgKyAxXSA9IGUsIHRoaXM7CiAgICB9CiAgICBnZXRaKHQpIHsKICAgICAgbGV0IGUgPSB0aGlzLmFycmF5W3QgKiB0aGlzLml0ZW1TaXplICsgMl07CiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWQgJiYgKGUgPSBDdChlLCB0aGlzLmFycmF5KSksIGU7CiAgICB9CiAgICBzZXRaKHQsIGUpIHsKICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplZCAmJiAoZSA9IHYoZSwgdGhpcy5hcnJheSkpLCB0aGlzLmFycmF5W3QgKiB0aGlzLml0ZW1TaXplICsgMl0gPSBlLCB0aGlzOwogICAgfQogICAgZ2V0Vyh0KSB7CiAgICAgIGxldCBlID0gdGhpcy5hcnJheVt0ICogdGhpcy5pdGVtU2l6ZSArIDNdOwogICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemVkICYmIChlID0gQ3QoZSwgdGhpcy5hcnJheSkpLCBlOwogICAgfQogICAgc2V0Vyh0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZWQgJiYgKGUgPSB2KGUsIHRoaXMuYXJyYXkpKSwgdGhpcy5hcnJheVt0ICogdGhpcy5pdGVtU2l6ZSArIDNdID0gZSwgdGhpczsKICAgIH0KICAgIHNldFhZKHQsIGUsIGkpIHsKICAgICAgcmV0dXJuIHQgKj0gdGhpcy5pdGVtU2l6ZSwgdGhpcy5ub3JtYWxpemVkICYmIChlID0gdihlLCB0aGlzLmFycmF5KSwgaSA9IHYoaSwgdGhpcy5hcnJheSkpLCB0aGlzLmFycmF5W3QgKyAwXSA9IGUsIHRoaXMuYXJyYXlbdCArIDFdID0gaSwgdGhpczsKICAgIH0KICAgIHNldFhZWih0LCBlLCBpLCBzKSB7CiAgICAgIHJldHVybiB0ICo9IHRoaXMuaXRlbVNpemUsIHRoaXMubm9ybWFsaXplZCAmJiAoZSA9IHYoZSwgdGhpcy5hcnJheSksIGkgPSB2KGksIHRoaXMuYXJyYXkpLCBzID0gdihzLCB0aGlzLmFycmF5KSksIHRoaXMuYXJyYXlbdCArIDBdID0gZSwgdGhpcy5hcnJheVt0ICsgMV0gPSBpLCB0aGlzLmFycmF5W3QgKyAyXSA9IHMsIHRoaXM7CiAgICB9CiAgICBzZXRYWVpXKHQsIGUsIGksIHMsIHIpIHsKICAgICAgcmV0dXJuIHQgKj0gdGhpcy5pdGVtU2l6ZSwgdGhpcy5ub3JtYWxpemVkICYmIChlID0gdihlLCB0aGlzLmFycmF5KSwgaSA9IHYoaSwgdGhpcy5hcnJheSksIHMgPSB2KHMsIHRoaXMuYXJyYXkpLCByID0gdihyLCB0aGlzLmFycmF5KSksIHRoaXMuYXJyYXlbdCArIDBdID0gZSwgdGhpcy5hcnJheVt0ICsgMV0gPSBpLCB0aGlzLmFycmF5W3QgKyAyXSA9IHMsIHRoaXMuYXJyYXlbdCArIDNdID0gciwgdGhpczsKICAgIH0KICAgIG9uVXBsb2FkKHQpIHsKICAgICAgcmV0dXJuIHRoaXMub25VcGxvYWRDYWxsYmFjayA9IHQsIHRoaXM7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXJyYXksIHRoaXMuaXRlbVNpemUpLmNvcHkodGhpcyk7CiAgICB9CiAgICB0b0pTT04oKSB7CiAgICAgIGNvbnN0IHQgPSB7CiAgICAgICAgaXRlbVNpemU6IHRoaXMuaXRlbVNpemUsCiAgICAgICAgdHlwZTogdGhpcy5hcnJheS5jb25zdHJ1Y3Rvci5uYW1lLAogICAgICAgIGFycmF5OiBBcnJheS5mcm9tKHRoaXMuYXJyYXkpLAogICAgICAgIG5vcm1hbGl6ZWQ6IHRoaXMubm9ybWFsaXplZAogICAgICB9OwogICAgICByZXR1cm4gdGhpcy5uYW1lICE9PSAiIiAmJiAodC5uYW1lID0gdGhpcy5uYW1lKSwgdGhpcy51c2FnZSAhPT0gMzUwNDQgJiYgKHQudXNhZ2UgPSB0aGlzLnVzYWdlKSwgdDsKICAgIH0KICB9CiAgY2xhc3MgS2UgZXh0ZW5kcyBRIHsKICAgIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHsKICAgICAgc3VwZXIobmV3IFVpbnQxNkFycmF5KHQpLCBlLCBpKTsKICAgIH0KICB9CiAgY2xhc3MgdGkgZXh0ZW5kcyBRIHsKICAgIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHsKICAgICAgc3VwZXIobmV3IFVpbnQzMkFycmF5KHQpLCBlLCBpKTsKICAgIH0KICB9CiAgY2xhc3MgZWkgZXh0ZW5kcyBRIHsKICAgIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHsKICAgICAgc3VwZXIobmV3IEZsb2F0MzJBcnJheSh0KSwgZSwgaSk7CiAgICB9CiAgfQogIGxldCBpaSA9IDA7CiAgY29uc3QgWiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgdHQoKSwgaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IGN0KCksIEZ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCksIEcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFB0KCksIEJ0ID0gLyogQF9fUFVSRV9fICovIG5ldyBQdCgpLCBVID0gLyogQF9fUFVSRV9fICovIG5ldyBnKCk7CiAgY2xhc3MgWnQgZXh0ZW5kcyBjZSB7CiAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgc3VwZXIoKSwgdGhpcy5pc0J1ZmZlckdlb21ldHJ5ID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiaWQiLCB7IHZhbHVlOiBpaSsrIH0pLCB0aGlzLnV1aWQgPSBYdCgpLCB0aGlzLm5hbWUgPSAiIiwgdGhpcy50eXBlID0gIkJ1ZmZlckdlb21ldHJ5IiwgdGhpcy5pbmRleCA9IG51bGwsIHRoaXMuaW5kaXJlY3QgPSBudWxsLCB0aGlzLmF0dHJpYnV0ZXMgPSB7fSwgdGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fSwgdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9ICExLCB0aGlzLmdyb3VwcyA9IFtdLCB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbCwgdGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGwsIHRoaXMuZHJhd1JhbmdlID0geyBzdGFydDogMCwgY291bnQ6IDEgLyAwIH0sIHRoaXMudXNlckRhdGEgPSB7fTsKICAgIH0KICAgIGdldEluZGV4KCkgewogICAgICByZXR1cm4gdGhpcy5pbmRleDsKICAgIH0KICAgIHNldEluZGV4KHQpIHsKICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgPyB0aGlzLmluZGV4ID0gbmV3IChVZSh0KSA/IHRpIDogS2UpKHQsIDEpIDogdGhpcy5pbmRleCA9IHQsIHRoaXM7CiAgICB9CiAgICBzZXRJbmRpcmVjdCh0KSB7CiAgICAgIHJldHVybiB0aGlzLmluZGlyZWN0ID0gdCwgdGhpczsKICAgIH0KICAgIGdldEluZGlyZWN0KCkgewogICAgICByZXR1cm4gdGhpcy5pbmRpcmVjdDsKICAgIH0KICAgIGdldEF0dHJpYnV0ZSh0KSB7CiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbdF07CiAgICB9CiAgICBzZXRBdHRyaWJ1dGUodCwgZSkgewogICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW3RdID0gZSwgdGhpczsKICAgIH0KICAgIGRlbGV0ZUF0dHJpYnV0ZSh0KSB7CiAgICAgIHJldHVybiBkZWxldGUgdGhpcy5hdHRyaWJ1dGVzW3RdLCB0aGlzOwogICAgfQogICAgaGFzQXR0cmlidXRlKHQpIHsKICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1t0XSAhPT0gdm9pZCAwOwogICAgfQogICAgYWRkR3JvdXAodCwgZSwgaSA9IDApIHsKICAgICAgdGhpcy5ncm91cHMucHVzaCh7CiAgICAgICAgc3RhcnQ6IHQsCiAgICAgICAgY291bnQ6IGUsCiAgICAgICAgbWF0ZXJpYWxJbmRleDogaQogICAgICB9KTsKICAgIH0KICAgIGNsZWFyR3JvdXBzKCkgewogICAgICB0aGlzLmdyb3VwcyA9IFtdOwogICAgfQogICAgc2V0RHJhd1JhbmdlKHQsIGUpIHsKICAgICAgdGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSB0LCB0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGU7CiAgICB9CiAgICBhcHBseU1hdHJpeDQodCkgewogICAgICBjb25zdCBlID0gdGhpcy5hdHRyaWJ1dGVzLnBvc2l0aW9uOwogICAgICBlICE9PSB2b2lkIDAgJiYgKGUuYXBwbHlNYXRyaXg0KHQpLCBlLm5lZWRzVXBkYXRlID0gITApOwogICAgICBjb25zdCBpID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDsKICAgICAgaWYgKGkgIT09IHZvaWQgMCkgewogICAgICAgIGNvbnN0IHIgPSBuZXcgZHQoKS5nZXROb3JtYWxNYXRyaXgodCk7CiAgICAgICAgaS5hcHBseU5vcm1hbE1hdHJpeChyKSwgaS5uZWVkc1VwZGF0ZSA9ICEwOwogICAgICB9CiAgICAgIGNvbnN0IHMgPSB0aGlzLmF0dHJpYnV0ZXMudGFuZ2VudDsKICAgICAgcmV0dXJuIHMgIT09IHZvaWQgMCAmJiAocy50cmFuc2Zvcm1EaXJlY3Rpb24odCksIHMubmVlZHNVcGRhdGUgPSAhMCksIHRoaXMuYm91bmRpbmdCb3ggIT09IG51bGwgJiYgdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSwgdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCAmJiB0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpLCB0aGlzOwogICAgfQogICAgYXBwbHlRdWF0ZXJuaW9uKHQpIHsKICAgICAgcmV0dXJuIFoubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24odCksIHRoaXMuYXBwbHlNYXRyaXg0KFopLCB0aGlzOwogICAgfQogICAgcm90YXRlWCh0KSB7CiAgICAgIHJldHVybiBaLm1ha2VSb3RhdGlvblgodCksIHRoaXMuYXBwbHlNYXRyaXg0KFopLCB0aGlzOwogICAgfQogICAgcm90YXRlWSh0KSB7CiAgICAgIHJldHVybiBaLm1ha2VSb3RhdGlvblkodCksIHRoaXMuYXBwbHlNYXRyaXg0KFopLCB0aGlzOwogICAgfQogICAgcm90YXRlWih0KSB7CiAgICAgIHJldHVybiBaLm1ha2VSb3RhdGlvbloodCksIHRoaXMuYXBwbHlNYXRyaXg0KFopLCB0aGlzOwogICAgfQogICAgdHJhbnNsYXRlKHQsIGUsIGkpIHsKICAgICAgcmV0dXJuIFoubWFrZVRyYW5zbGF0aW9uKHQsIGUsIGkpLCB0aGlzLmFwcGx5TWF0cml4NChaKSwgdGhpczsKICAgIH0KICAgIHNjYWxlKHQsIGUsIGkpIHsKICAgICAgcmV0dXJuIFoubWFrZVNjYWxlKHQsIGUsIGkpLCB0aGlzLmFwcGx5TWF0cml4NChaKSwgdGhpczsKICAgIH0KICAgIGxvb2tBdCh0KSB7CiAgICAgIHJldHVybiBoZS5sb29rQXQodCksIGhlLnVwZGF0ZU1hdHJpeCgpLCB0aGlzLmFwcGx5TWF0cml4NChoZS5tYXRyaXgpLCB0aGlzOwogICAgfQogICAgY2VudGVyKCkgewogICAgICByZXR1cm4gdGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSwgdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoRnQpLm5lZ2F0ZSgpLCB0aGlzLnRyYW5zbGF0ZShGdC54LCBGdC55LCBGdC56KSwgdGhpczsKICAgIH0KICAgIHNldEZyb21Qb2ludHModCkgewogICAgICBjb25zdCBlID0gdGhpcy5nZXRBdHRyaWJ1dGUoInBvc2l0aW9uIik7CiAgICAgIGlmIChlID09PSB2b2lkIDApIHsKICAgICAgICBjb25zdCBpID0gW107CiAgICAgICAgZm9yIChsZXQgcyA9IDAsIHIgPSB0Lmxlbmd0aDsgcyA8IHI7IHMrKykgewogICAgICAgICAgY29uc3QgbiA9IHRbc107CiAgICAgICAgICBpLnB1c2gobi54LCBuLnksIG4ueiB8fCAwKTsKICAgICAgICB9CiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIiwgbmV3IGVpKGksIDMpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBpID0gTWF0aC5taW4odC5sZW5ndGgsIGUuY291bnQpOwogICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgaTsgcysrKSB7CiAgICAgICAgICBjb25zdCByID0gdFtzXTsKICAgICAgICAgIGUuc2V0WFlaKHMsIHIueCwgci55LCByLnogfHwgMCk7CiAgICAgICAgfQogICAgICAgIHQubGVuZ3RoID4gZS5jb3VudCAmJiBjb25zb2xlLndhcm4oIlRIUkVFLkJ1ZmZlckdlb21ldHJ5OiBCdWZmZXIgc2l6ZSB0b28gc21hbGwgZm9yIHBvaW50cyBkYXRhLiBVc2UgLmRpc3Bvc2UoKSBhbmQgY3JlYXRlIGEgbmV3IGdlb21ldHJ5LiIpLCBlLm5lZWRzVXBkYXRlID0gITA7CiAgICAgIH0KICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBjb21wdXRlQm91bmRpbmdCb3goKSB7CiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgJiYgKHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgUHQoKSk7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmF0dHJpYnV0ZXMucG9zaXRpb24sIGUgPSB0aGlzLm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjsKICAgICAgaWYgKHQgJiYgdC5pc0dMQnVmZmVyQXR0cmlidXRlKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IEdMQnVmZmVyQXR0cmlidXRlIHJlcXVpcmVzIGEgbWFudWFsIGJvdW5kaW5nIGJveC4iLCB0aGlzKSwgdGhpcy5ib3VuZGluZ0JveC5zZXQoCiAgICAgICAgICBuZXcgZygtMSAvIDAsIC0xIC8gMCwgLTEgLyAwKSwKICAgICAgICAgIG5ldyBnKDEgLyAwLCAxIC8gMCwgMSAvIDApCiAgICAgICAgKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgaWYgKHQgIT09IHZvaWQgMCkgewogICAgICAgIGlmICh0aGlzLmJvdW5kaW5nQm94LnNldEZyb21CdWZmZXJBdHRyaWJ1dGUodCksIGUpCiAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcyA9IGUubGVuZ3RoOyBpIDwgczsgaSsrKSB7CiAgICAgICAgICAgIGNvbnN0IHIgPSBlW2ldOwogICAgICAgICAgICBHLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUociksIHRoaXMubW9ycGhUYXJnZXRzUmVsYXRpdmUgPyAoVS5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWluLCBHLm1pbiksIHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChVKSwgVS5hZGRWZWN0b3JzKHRoaXMuYm91bmRpbmdCb3gubWF4LCBHLm1heCksIHRoaXMuYm91bmRpbmdCb3guZXhwYW5kQnlQb2ludChVKSkgOiAodGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KEcubWluKSwgdGhpcy5ib3VuZGluZ0JveC5leHBhbmRCeVBvaW50KEcubWF4KSk7CiAgICAgICAgICB9CiAgICAgIH0gZWxzZQogICAgICAgIHRoaXMuYm91bmRpbmdCb3gubWFrZUVtcHR5KCk7CiAgICAgIChpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi54KSB8fCBpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi55KSB8fCBpc05hTih0aGlzLmJvdW5kaW5nQm94Lm1pbi56KSkgJiYgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk6IENvbXB1dGVkIG1pbi9tYXggaGF2ZSBOYU4gdmFsdWVzLiBUaGUgInBvc2l0aW9uIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzKTsKICAgIH0KICAgIGNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpIHsKICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCAmJiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBIZSgpKTsKICAgICAgY29uc3QgdCA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbiwgZSA9IHRoaXMubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uOwogICAgICBpZiAodCAmJiB0LmlzR0xCdWZmZXJBdHRyaWJ1dGUpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTogR0xCdWZmZXJBdHRyaWJ1dGUgcmVxdWlyZXMgYSBtYW51YWwgYm91bmRpbmcgc3BoZXJlLiIsIHRoaXMpLCB0aGlzLmJvdW5kaW5nU3BoZXJlLnNldChuZXcgZygpLCAxIC8gMCk7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGlmICh0KSB7CiAgICAgICAgY29uc3QgaSA9IHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyOwogICAgICAgIGlmIChHLnNldEZyb21CdWZmZXJBdHRyaWJ1dGUodCksIGUpCiAgICAgICAgICBmb3IgKGxldCByID0gMCwgbiA9IGUubGVuZ3RoOyByIDwgbjsgcisrKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSBlW3JdOwogICAgICAgICAgICBCdC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKGEpLCB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID8gKFUuYWRkVmVjdG9ycyhHLm1pbiwgQnQubWluKSwgRy5leHBhbmRCeVBvaW50KFUpLCBVLmFkZFZlY3RvcnMoRy5tYXgsIEJ0Lm1heCksIEcuZXhwYW5kQnlQb2ludChVKSkgOiAoRy5leHBhbmRCeVBvaW50KEJ0Lm1pbiksIEcuZXhwYW5kQnlQb2ludChCdC5tYXgpKTsKICAgICAgICAgIH0KICAgICAgICBHLmdldENlbnRlcihpKTsKICAgICAgICBsZXQgcyA9IDA7CiAgICAgICAgZm9yIChsZXQgciA9IDAsIG4gPSB0LmNvdW50OyByIDwgbjsgcisrKQogICAgICAgICAgVS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsIHIpLCBzID0gTWF0aC5tYXgocywgaS5kaXN0YW5jZVRvU3F1YXJlZChVKSk7CiAgICAgICAgaWYgKGUpCiAgICAgICAgICBmb3IgKGxldCByID0gMCwgbiA9IGUubGVuZ3RoOyByIDwgbjsgcisrKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSBlW3JdLCBvID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTsKICAgICAgICAgICAgZm9yIChsZXQgaCA9IDAsIHUgPSBhLmNvdW50OyBoIDwgdTsgaCsrKQogICAgICAgICAgICAgIFUuZnJvbUJ1ZmZlckF0dHJpYnV0ZShhLCBoKSwgbyAmJiAoRnQuZnJvbUJ1ZmZlckF0dHJpYnV0ZSh0LCBoKSwgVS5hZGQoRnQpKSwgcyA9IE1hdGgubWF4KHMsIGkuZGlzdGFuY2VUb1NxdWFyZWQoVSkpOwogICAgICAgICAgfQogICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KHMpLCBpc05hTih0aGlzLmJvdW5kaW5nU3BoZXJlLnJhZGl1cykgJiYgY29uc29sZS5lcnJvcignVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk6IENvbXB1dGVkIHJhZGl1cyBpcyBOYU4uIFRoZSAicG9zaXRpb24iIGF0dHJpYnV0ZSBpcyBsaWtlbHkgdG8gaGF2ZSBOYU4gdmFsdWVzLicsIHRoaXMpOwogICAgICB9CiAgICB9CiAgICBjb21wdXRlVGFuZ2VudHMoKSB7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmluZGV4LCBlID0gdGhpcy5hdHRyaWJ1dGVzOwogICAgICBpZiAodCA9PT0gbnVsbCB8fCBlLnBvc2l0aW9uID09PSB2b2lkIDAgfHwgZS5ub3JtYWwgPT09IHZvaWQgMCB8fCBlLnV2ID09PSB2b2lkIDApIHsKICAgICAgICBjb25zb2xlLmVycm9yKCJUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmNvbXB1dGVUYW5nZW50cygpIGZhaWxlZC4gTWlzc2luZyByZXF1aXJlZCBhdHRyaWJ1dGVzIChpbmRleCwgcG9zaXRpb24sIG5vcm1hbCBvciB1dikiKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgY29uc3QgaSA9IGUucG9zaXRpb24sIHMgPSBlLm5vcm1hbCwgciA9IGUudXY7CiAgICAgIHRoaXMuaGFzQXR0cmlidXRlKCJ0YW5nZW50IikgPT09ICExICYmIHRoaXMuc2V0QXR0cmlidXRlKCJ0YW5nZW50IiwgbmV3IFEobmV3IEZsb2F0MzJBcnJheSg0ICogaS5jb3VudCksIDQpKTsKICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0QXR0cmlidXRlKCJ0YW5nZW50IiksIGEgPSBbXSwgbyA9IFtdOwogICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IGkuY291bnQ7IHcrKykKICAgICAgICBhW3ddID0gbmV3IGcoKSwgb1t3XSA9IG5ldyBnKCk7CiAgICAgIGNvbnN0IGggPSBuZXcgZygpLCB1ID0gbmV3IGcoKSwgbCA9IG5ldyBnKCksIGQgPSBuZXcgcnQoKSwgYyA9IG5ldyBydCgpLCBtID0gbmV3IHJ0KCksIHkgPSBuZXcgZygpLCB4ID0gbmV3IGcoKTsKICAgICAgZnVuY3Rpb24gcCh3LCBFLCBDKSB7CiAgICAgICAgaC5mcm9tQnVmZmVyQXR0cmlidXRlKGksIHcpLCB1LmZyb21CdWZmZXJBdHRyaWJ1dGUoaSwgRSksIGwuZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLCBDKSwgZC5mcm9tQnVmZmVyQXR0cmlidXRlKHIsIHcpLCBjLmZyb21CdWZmZXJBdHRyaWJ1dGUociwgRSksIG0uZnJvbUJ1ZmZlckF0dHJpYnV0ZShyLCBDKSwgdS5zdWIoaCksIGwuc3ViKGgpLCBjLnN1YihkKSwgbS5zdWIoZCk7CiAgICAgICAgY29uc3QgTCA9IDEgLyAoYy54ICogbS55IC0gbS54ICogYy55KTsKICAgICAgICBpc0Zpbml0ZShMKSAmJiAoeS5jb3B5KHUpLm11bHRpcGx5U2NhbGFyKG0ueSkuYWRkU2NhbGVkVmVjdG9yKGwsIC1jLnkpLm11bHRpcGx5U2NhbGFyKEwpLCB4LmNvcHkobCkubXVsdGlwbHlTY2FsYXIoYy54KS5hZGRTY2FsZWRWZWN0b3IodSwgLW0ueCkubXVsdGlwbHlTY2FsYXIoTCksIGFbd10uYWRkKHkpLCBhW0VdLmFkZCh5KSwgYVtDXS5hZGQoeSksIG9bd10uYWRkKHgpLCBvW0VdLmFkZCh4KSwgb1tDXS5hZGQoeCkpOwogICAgICB9CiAgICAgIGxldCB6ID0gdGhpcy5ncm91cHM7CiAgICAgIHoubGVuZ3RoID09PSAwICYmICh6ID0gW3sKICAgICAgICBzdGFydDogMCwKICAgICAgICBjb3VudDogdC5jb3VudAogICAgICB9XSk7CiAgICAgIGZvciAobGV0IHcgPSAwLCBFID0gei5sZW5ndGg7IHcgPCBFOyArK3cpIHsKICAgICAgICBjb25zdCBDID0gelt3XSwgTCA9IEMuc3RhcnQsIFYgPSBDLmNvdW50OwogICAgICAgIGZvciAobGV0IFMgPSBMLCBSID0gTCArIFY7IFMgPCBSOyBTICs9IDMpCiAgICAgICAgICBwKAogICAgICAgICAgICB0LmdldFgoUyArIDApLAogICAgICAgICAgICB0LmdldFgoUyArIDEpLAogICAgICAgICAgICB0LmdldFgoUyArIDIpCiAgICAgICAgICApOwogICAgICB9CiAgICAgIGNvbnN0IEYgPSBuZXcgZygpLCBBID0gbmV3IGcoKSwgYiA9IG5ldyBnKCksIE0gPSBuZXcgZygpOwogICAgICBmdW5jdGlvbiBfKHcpIHsKICAgICAgICBiLmZyb21CdWZmZXJBdHRyaWJ1dGUocywgdyksIE0uY29weShiKTsKICAgICAgICBjb25zdCBFID0gYVt3XTsKICAgICAgICBGLmNvcHkoRSksIEYuc3ViKGIubXVsdGlwbHlTY2FsYXIoYi5kb3QoRSkpKS5ub3JtYWxpemUoKSwgQS5jcm9zc1ZlY3RvcnMoTSwgRSk7CiAgICAgICAgY29uc3QgTCA9IEEuZG90KG9bd10pIDwgMCA/IC0xIDogMTsKICAgICAgICBuLnNldFhZWlcodywgRi54LCBGLnksIEYueiwgTCk7CiAgICAgIH0KICAgICAgZm9yIChsZXQgdyA9IDAsIEUgPSB6Lmxlbmd0aDsgdyA8IEU7ICsrdykgewogICAgICAgIGNvbnN0IEMgPSB6W3ddLCBMID0gQy5zdGFydCwgViA9IEMuY291bnQ7CiAgICAgICAgZm9yIChsZXQgUyA9IEwsIFIgPSBMICsgVjsgUyA8IFI7IFMgKz0gMykKICAgICAgICAgIF8odC5nZXRYKFMgKyAwKSksIF8odC5nZXRYKFMgKyAxKSksIF8odC5nZXRYKFMgKyAyKSk7CiAgICAgIH0KICAgIH0KICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCkgewogICAgICBjb25zdCB0ID0gdGhpcy5pbmRleCwgZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCJwb3NpdGlvbiIpOwogICAgICBpZiAoZSAhPT0gdm9pZCAwKSB7CiAgICAgICAgbGV0IGkgPSB0aGlzLmdldEF0dHJpYnV0ZSgibm9ybWFsIik7CiAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkKICAgICAgICAgIGkgPSBuZXcgUShuZXcgRmxvYXQzMkFycmF5KGUuY291bnQgKiAzKSwgMyksIHRoaXMuc2V0QXR0cmlidXRlKCJub3JtYWwiLCBpKTsKICAgICAgICBlbHNlCiAgICAgICAgICBmb3IgKGxldCBkID0gMCwgYyA9IGkuY291bnQ7IGQgPCBjOyBkKyspCiAgICAgICAgICAgIGkuc2V0WFlaKGQsIDAsIDAsIDApOwogICAgICAgIGNvbnN0IHMgPSBuZXcgZygpLCByID0gbmV3IGcoKSwgbiA9IG5ldyBnKCksIGEgPSBuZXcgZygpLCBvID0gbmV3IGcoKSwgaCA9IG5ldyBnKCksIHUgPSBuZXcgZygpLCBsID0gbmV3IGcoKTsKICAgICAgICBpZiAodCkKICAgICAgICAgIGZvciAobGV0IGQgPSAwLCBjID0gdC5jb3VudDsgZCA8IGM7IGQgKz0gMykgewogICAgICAgICAgICBjb25zdCBtID0gdC5nZXRYKGQgKyAwKSwgeSA9IHQuZ2V0WChkICsgMSksIHggPSB0LmdldFgoZCArIDIpOwogICAgICAgICAgICBzLmZyb21CdWZmZXJBdHRyaWJ1dGUoZSwgbSksIHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCB5KSwgbi5mcm9tQnVmZmVyQXR0cmlidXRlKGUsIHgpLCB1LnN1YlZlY3RvcnMobiwgciksIGwuc3ViVmVjdG9ycyhzLCByKSwgdS5jcm9zcyhsKSwgYS5mcm9tQnVmZmVyQXR0cmlidXRlKGksIG0pLCBvLmZyb21CdWZmZXJBdHRyaWJ1dGUoaSwgeSksIGguZnJvbUJ1ZmZlckF0dHJpYnV0ZShpLCB4KSwgYS5hZGQodSksIG8uYWRkKHUpLCBoLmFkZCh1KSwgaS5zZXRYWVoobSwgYS54LCBhLnksIGEueiksIGkuc2V0WFlaKHksIG8ueCwgby55LCBvLnopLCBpLnNldFhZWih4LCBoLngsIGgueSwgaC56KTsKICAgICAgICAgIH0KICAgICAgICBlbHNlCiAgICAgICAgICBmb3IgKGxldCBkID0gMCwgYyA9IGUuY291bnQ7IGQgPCBjOyBkICs9IDMpCiAgICAgICAgICAgIHMuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCBkICsgMCksIHIuZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCBkICsgMSksIG4uZnJvbUJ1ZmZlckF0dHJpYnV0ZShlLCBkICsgMiksIHUuc3ViVmVjdG9ycyhuLCByKSwgbC5zdWJWZWN0b3JzKHMsIHIpLCB1LmNyb3NzKGwpLCBpLnNldFhZWihkICsgMCwgdS54LCB1LnksIHUueiksIGkuc2V0WFlaKGQgKyAxLCB1LngsIHUueSwgdS56KSwgaS5zZXRYWVooZCArIDIsIHUueCwgdS55LCB1LnopOwogICAgICAgIHRoaXMubm9ybWFsaXplTm9ybWFscygpLCBpLm5lZWRzVXBkYXRlID0gITA7CiAgICAgIH0KICAgIH0KICAgIG5vcm1hbGl6ZU5vcm1hbHMoKSB7CiAgICAgIGNvbnN0IHQgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsOwogICAgICBmb3IgKGxldCBlID0gMCwgaSA9IHQuY291bnQ7IGUgPCBpOyBlKyspCiAgICAgICAgVS5mcm9tQnVmZmVyQXR0cmlidXRlKHQsIGUpLCBVLm5vcm1hbGl6ZSgpLCB0LnNldFhZWihlLCBVLngsIFUueSwgVS56KTsKICAgIH0KICAgIHRvTm9uSW5kZXhlZCgpIHsKICAgICAgZnVuY3Rpb24gdChhLCBvKSB7CiAgICAgICAgY29uc3QgaCA9IGEuYXJyYXksIHUgPSBhLml0ZW1TaXplLCBsID0gYS5ub3JtYWxpemVkLCBkID0gbmV3IGguY29uc3RydWN0b3Ioby5sZW5ndGggKiB1KTsKICAgICAgICBsZXQgYyA9IDAsIG0gPSAwOwogICAgICAgIGZvciAobGV0IHkgPSAwLCB4ID0gby5sZW5ndGg7IHkgPCB4OyB5KyspIHsKICAgICAgICAgIGEuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSA/IGMgPSBvW3ldICogYS5kYXRhLnN0cmlkZSArIGEub2Zmc2V0IDogYyA9IG9beV0gKiB1OwogICAgICAgICAgZm9yIChsZXQgcCA9IDA7IHAgPCB1OyBwKyspCiAgICAgICAgICAgIGRbbSsrXSA9IGhbYysrXTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyBRKGQsIHUsIGwpOwogICAgICB9CiAgICAgIGlmICh0aGlzLmluZGV4ID09PSBudWxsKQogICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oIlRIUkVFLkJ1ZmZlckdlb21ldHJ5LnRvTm9uSW5kZXhlZCgpOiBCdWZmZXJHZW9tZXRyeSBpcyBhbHJlYWR5IG5vbi1pbmRleGVkLiIpLCB0aGlzOwogICAgICBjb25zdCBlID0gbmV3IFp0KCksIGkgPSB0aGlzLmluZGV4LmFycmF5LCBzID0gdGhpcy5hdHRyaWJ1dGVzOwogICAgICBmb3IgKGNvbnN0IGEgaW4gcykgewogICAgICAgIGNvbnN0IG8gPSBzW2FdLCBoID0gdChvLCBpKTsKICAgICAgICBlLnNldEF0dHJpYnV0ZShhLCBoKTsKICAgICAgfQogICAgICBjb25zdCByID0gdGhpcy5tb3JwaEF0dHJpYnV0ZXM7CiAgICAgIGZvciAoY29uc3QgYSBpbiByKSB7CiAgICAgICAgY29uc3QgbyA9IFtdLCBoID0gclthXTsKICAgICAgICBmb3IgKGxldCB1ID0gMCwgbCA9IGgubGVuZ3RoOyB1IDwgbDsgdSsrKSB7CiAgICAgICAgICBjb25zdCBkID0gaFt1XSwgYyA9IHQoZCwgaSk7CiAgICAgICAgICBvLnB1c2goYyk7CiAgICAgICAgfQogICAgICAgIGUubW9ycGhBdHRyaWJ1dGVzW2FdID0gbzsKICAgICAgfQogICAgICBlLm1vcnBoVGFyZ2V0c1JlbGF0aXZlID0gdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZTsKICAgICAgY29uc3QgbiA9IHRoaXMuZ3JvdXBzOwogICAgICBmb3IgKGxldCBhID0gMCwgbyA9IG4ubGVuZ3RoOyBhIDwgbzsgYSsrKSB7CiAgICAgICAgY29uc3QgaCA9IG5bYV07CiAgICAgICAgZS5hZGRHcm91cChoLnN0YXJ0LCBoLmNvdW50LCBoLm1hdGVyaWFsSW5kZXgpOwogICAgICB9CiAgICAgIHJldHVybiBlOwogICAgfQogICAgdG9KU09OKCkgewogICAgICBjb25zdCB0ID0gewogICAgICAgIG1ldGFkYXRhOiB7CiAgICAgICAgICB2ZXJzaW9uOiA0LjYsCiAgICAgICAgICB0eXBlOiAiQnVmZmVyR2VvbWV0cnkiLAogICAgICAgICAgZ2VuZXJhdG9yOiAiQnVmZmVyR2VvbWV0cnkudG9KU09OIgogICAgICAgIH0KICAgICAgfTsKICAgICAgaWYgKHQudXVpZCA9IHRoaXMudXVpZCwgdC50eXBlID0gdGhpcy50eXBlLCB0aGlzLm5hbWUgIT09ICIiICYmICh0Lm5hbWUgPSB0aGlzLm5hbWUpLCBPYmplY3Qua2V5cyh0aGlzLnVzZXJEYXRhKS5sZW5ndGggPiAwICYmICh0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YSksIHRoaXMucGFyYW1ldGVycyAhPT0gdm9pZCAwKSB7CiAgICAgICAgY29uc3QgbyA9IHRoaXMucGFyYW1ldGVyczsKICAgICAgICBmb3IgKGNvbnN0IGggaW4gbykKICAgICAgICAgIG9baF0gIT09IHZvaWQgMCAmJiAodFtoXSA9IG9baF0pOwogICAgICAgIHJldHVybiB0OwogICAgICB9CiAgICAgIHQuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTsKICAgICAgY29uc3QgZSA9IHRoaXMuaW5kZXg7CiAgICAgIGUgIT09IG51bGwgJiYgKHQuZGF0YS5pbmRleCA9IHsKICAgICAgICB0eXBlOiBlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsCiAgICAgICAgYXJyYXk6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGUuYXJyYXkpCiAgICAgIH0pOwogICAgICBjb25zdCBpID0gdGhpcy5hdHRyaWJ1dGVzOwogICAgICBmb3IgKGNvbnN0IG8gaW4gaSkgewogICAgICAgIGNvbnN0IGggPSBpW29dOwogICAgICAgIHQuZGF0YS5hdHRyaWJ1dGVzW29dID0gaC50b0pTT04odC5kYXRhKTsKICAgICAgfQogICAgICBjb25zdCBzID0ge307CiAgICAgIGxldCByID0gITE7CiAgICAgIGZvciAoY29uc3QgbyBpbiB0aGlzLm1vcnBoQXR0cmlidXRlcykgewogICAgICAgIGNvbnN0IGggPSB0aGlzLm1vcnBoQXR0cmlidXRlc1tvXSwgdSA9IFtdOwogICAgICAgIGZvciAobGV0IGwgPSAwLCBkID0gaC5sZW5ndGg7IGwgPCBkOyBsKyspIHsKICAgICAgICAgIGNvbnN0IGMgPSBoW2xdOwogICAgICAgICAgdS5wdXNoKGMudG9KU09OKHQuZGF0YSkpOwogICAgICAgIH0KICAgICAgICB1Lmxlbmd0aCA+IDAgJiYgKHNbb10gPSB1LCByID0gITApOwogICAgICB9CiAgICAgIHIgJiYgKHQuZGF0YS5tb3JwaEF0dHJpYnV0ZXMgPSBzLCB0LmRhdGEubW9ycGhUYXJnZXRzUmVsYXRpdmUgPSB0aGlzLm1vcnBoVGFyZ2V0c1JlbGF0aXZlKTsKICAgICAgY29uc3QgbiA9IHRoaXMuZ3JvdXBzOwogICAgICBuLmxlbmd0aCA+IDAgJiYgKHQuZGF0YS5ncm91cHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG4pKSk7CiAgICAgIGNvbnN0IGEgPSB0aGlzLmJvdW5kaW5nU3BoZXJlOwogICAgICByZXR1cm4gYSAhPT0gbnVsbCAmJiAodC5kYXRhLmJvdW5kaW5nU3BoZXJlID0gewogICAgICAgIGNlbnRlcjogYS5jZW50ZXIudG9BcnJheSgpLAogICAgICAgIHJhZGl1czogYS5yYWRpdXMKICAgICAgfSksIHQ7CiAgICB9CiAgICBjbG9uZSgpIHsKICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSh0aGlzKTsKICAgIH0KICAgIGNvcHkodCkgewogICAgICB0aGlzLmluZGV4ID0gbnVsbCwgdGhpcy5hdHRyaWJ1dGVzID0ge30sIHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge30sIHRoaXMuZ3JvdXBzID0gW10sIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsLCB0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDsKICAgICAgY29uc3QgZSA9IHt9OwogICAgICB0aGlzLm5hbWUgPSB0Lm5hbWU7CiAgICAgIGNvbnN0IGkgPSB0LmluZGV4OwogICAgICBpICE9PSBudWxsICYmIHRoaXMuc2V0SW5kZXgoaS5jbG9uZShlKSk7CiAgICAgIGNvbnN0IHMgPSB0LmF0dHJpYnV0ZXM7CiAgICAgIGZvciAoY29uc3QgaCBpbiBzKSB7CiAgICAgICAgY29uc3QgdSA9IHNbaF07CiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaCwgdS5jbG9uZShlKSk7CiAgICAgIH0KICAgICAgY29uc3QgciA9IHQubW9ycGhBdHRyaWJ1dGVzOwogICAgICBmb3IgKGNvbnN0IGggaW4gcikgewogICAgICAgIGNvbnN0IHUgPSBbXSwgbCA9IHJbaF07CiAgICAgICAgZm9yIChsZXQgZCA9IDAsIGMgPSBsLmxlbmd0aDsgZCA8IGM7IGQrKykKICAgICAgICAgIHUucHVzaChsW2RdLmNsb25lKGUpKTsKICAgICAgICB0aGlzLm1vcnBoQXR0cmlidXRlc1toXSA9IHU7CiAgICAgIH0KICAgICAgdGhpcy5tb3JwaFRhcmdldHNSZWxhdGl2ZSA9IHQubW9ycGhUYXJnZXRzUmVsYXRpdmU7CiAgICAgIGNvbnN0IG4gPSB0Lmdyb3VwczsKICAgICAgZm9yIChsZXQgaCA9IDAsIHUgPSBuLmxlbmd0aDsgaCA8IHU7IGgrKykgewogICAgICAgIGNvbnN0IGwgPSBuW2hdOwogICAgICAgIHRoaXMuYWRkR3JvdXAobC5zdGFydCwgbC5jb3VudCwgbC5tYXRlcmlhbEluZGV4KTsKICAgICAgfQogICAgICBjb25zdCBhID0gdC5ib3VuZGluZ0JveDsKICAgICAgYSAhPT0gbnVsbCAmJiAodGhpcy5ib3VuZGluZ0JveCA9IGEuY2xvbmUoKSk7CiAgICAgIGNvbnN0IG8gPSB0LmJvdW5kaW5nU3BoZXJlOwogICAgICByZXR1cm4gbyAhPT0gbnVsbCAmJiAodGhpcy5ib3VuZGluZ1NwaGVyZSA9IG8uY2xvbmUoKSksIHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gdC5kcmF3UmFuZ2Uuc3RhcnQsIHRoaXMuZHJhd1JhbmdlLmNvdW50ID0gdC5kcmF3UmFuZ2UuY291bnQsIHRoaXMudXNlckRhdGEgPSB0LnVzZXJEYXRhLCB0aGlzOwogICAgfQogICAgZGlzcG9zZSgpIHsKICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHsgdHlwZTogImRpc3Bvc2UiIH0pOwogICAgfQogIH0KICBjb25zdCBDZSA9IHsKICAgIGVuYWJsZWQ6ICExLAogICAgZmlsZXM6IHt9LAogICAgYWRkOiBmdW5jdGlvbihmLCB0KSB7CiAgICAgIHRoaXMuZW5hYmxlZCAhPT0gITEgJiYgKHRoaXMuZmlsZXNbZl0gPSB0KTsKICAgIH0sCiAgICBnZXQ6IGZ1bmN0aW9uKGYpIHsKICAgICAgaWYgKHRoaXMuZW5hYmxlZCAhPT0gITEpCiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZXNbZl07CiAgICB9LAogICAgcmVtb3ZlOiBmdW5jdGlvbihmKSB7CiAgICAgIGRlbGV0ZSB0aGlzLmZpbGVzW2ZdOwogICAgfSwKICAgIGNsZWFyOiBmdW5jdGlvbigpIHsKICAgICAgdGhpcy5maWxlcyA9IHt9OwogICAgfQogIH07CiAgY2xhc3Mgc2kgewogICAgY29uc3RydWN0b3IodCwgZSwgaSkgewogICAgICBjb25zdCBzID0gdGhpczsKICAgICAgbGV0IHIgPSAhMSwgbiA9IDAsIGEgPSAwLCBvOwogICAgICBjb25zdCBoID0gW107CiAgICAgIHRoaXMub25TdGFydCA9IHZvaWQgMCwgdGhpcy5vbkxvYWQgPSB0LCB0aGlzLm9uUHJvZ3Jlc3MgPSBlLCB0aGlzLm9uRXJyb3IgPSBpLCB0aGlzLml0ZW1TdGFydCA9IGZ1bmN0aW9uKHUpIHsKICAgICAgICBhKyssIHIgPT09ICExICYmIHMub25TdGFydCAhPT0gdm9pZCAwICYmIHMub25TdGFydCh1LCBuLCBhKSwgciA9ICEwOwogICAgICB9LCB0aGlzLml0ZW1FbmQgPSBmdW5jdGlvbih1KSB7CiAgICAgICAgbisrLCBzLm9uUHJvZ3Jlc3MgIT09IHZvaWQgMCAmJiBzLm9uUHJvZ3Jlc3ModSwgbiwgYSksIG4gPT09IGEgJiYgKHIgPSAhMSwgcy5vbkxvYWQgIT09IHZvaWQgMCAmJiBzLm9uTG9hZCgpKTsKICAgICAgfSwgdGhpcy5pdGVtRXJyb3IgPSBmdW5jdGlvbih1KSB7CiAgICAgICAgcy5vbkVycm9yICE9PSB2b2lkIDAgJiYgcy5vbkVycm9yKHUpOwogICAgICB9LCB0aGlzLnJlc29sdmVVUkwgPSBmdW5jdGlvbih1KSB7CiAgICAgICAgcmV0dXJuIG8gPyBvKHUpIDogdTsKICAgICAgfSwgdGhpcy5zZXRVUkxNb2RpZmllciA9IGZ1bmN0aW9uKHUpIHsKICAgICAgICByZXR1cm4gbyA9IHUsIHRoaXM7CiAgICAgIH0sIHRoaXMuYWRkSGFuZGxlciA9IGZ1bmN0aW9uKHUsIGwpIHsKICAgICAgICByZXR1cm4gaC5wdXNoKHUsIGwpLCB0aGlzOwogICAgICB9LCB0aGlzLnJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbih1KSB7CiAgICAgICAgY29uc3QgbCA9IGguaW5kZXhPZih1KTsKICAgICAgICByZXR1cm4gbCAhPT0gLTEgJiYgaC5zcGxpY2UobCwgMiksIHRoaXM7CiAgICAgIH0sIHRoaXMuZ2V0SGFuZGxlciA9IGZ1bmN0aW9uKHUpIHsKICAgICAgICBmb3IgKGxldCBsID0gMCwgZCA9IGgubGVuZ3RoOyBsIDwgZDsgbCArPSAyKSB7CiAgICAgICAgICBjb25zdCBjID0gaFtsXSwgbSA9IGhbbCArIDFdOwogICAgICAgICAgaWYgKGMuZ2xvYmFsICYmIChjLmxhc3RJbmRleCA9IDApLCBjLnRlc3QodSkpCiAgICAgICAgICAgIHJldHVybiBtOwogICAgICAgIH0KICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgfTsKICAgIH0KICB9CiAgY29uc3QgSWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IHNpKCk7CiAgY2xhc3MgbWUgewogICAgY29uc3RydWN0b3IodCkgewogICAgICB0aGlzLm1hbmFnZXIgPSB0ICE9PSB2b2lkIDAgPyB0IDogSWUsIHRoaXMuY3Jvc3NPcmlnaW4gPSAiYW5vbnltb3VzIiwgdGhpcy53aXRoQ3JlZGVudGlhbHMgPSAhMSwgdGhpcy5wYXRoID0gIiIsIHRoaXMucmVzb3VyY2VQYXRoID0gIiIsIHRoaXMucmVxdWVzdEhlYWRlciA9IHt9OwogICAgfQogICAgbG9hZCgpIHsKICAgIH0KICAgIGxvYWRBc3luYyh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSB0aGlzOwogICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocywgcikgewogICAgICAgIGkubG9hZCh0LCBzLCBlLCByKTsKICAgICAgfSk7CiAgICB9CiAgICBwYXJzZSgpIHsKICAgIH0KICAgIHNldENyb3NzT3JpZ2luKHQpIHsKICAgICAgcmV0dXJuIHRoaXMuY3Jvc3NPcmlnaW4gPSB0LCB0aGlzOwogICAgfQogICAgc2V0V2l0aENyZWRlbnRpYWxzKHQpIHsKICAgICAgcmV0dXJuIHRoaXMud2l0aENyZWRlbnRpYWxzID0gdCwgdGhpczsKICAgIH0KICAgIHNldFBhdGgodCkgewogICAgICByZXR1cm4gdGhpcy5wYXRoID0gdCwgdGhpczsKICAgIH0KICAgIHNldFJlc291cmNlUGF0aCh0KSB7CiAgICAgIHJldHVybiB0aGlzLnJlc291cmNlUGF0aCA9IHQsIHRoaXM7CiAgICB9CiAgICBzZXRSZXF1ZXN0SGVhZGVyKHQpIHsKICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEhlYWRlciA9IHQsIHRoaXM7CiAgICB9CiAgfQogIG1lLkRFRkFVTFRfTUFURVJJQUxfTkFNRSA9ICJfX0RFRkFVTFQiOwogIGNvbnN0IHN0ID0ge307CiAgY2xhc3MgcmkgZXh0ZW5kcyBFcnJvciB7CiAgICBjb25zdHJ1Y3Rvcih0LCBlKSB7CiAgICAgIHN1cGVyKHQpLCB0aGlzLnJlc3BvbnNlID0gZTsKICAgIH0KICB9CiAgY2xhc3MgRWUgZXh0ZW5kcyBtZSB7CiAgICBjb25zdHJ1Y3Rvcih0KSB7CiAgICAgIHN1cGVyKHQpOwogICAgfQogICAgbG9hZCh0LCBlLCBpLCBzKSB7CiAgICAgIHQgPT09IHZvaWQgMCAmJiAodCA9ICIiKSwgdGhpcy5wYXRoICE9PSB2b2lkIDAgJiYgKHQgPSB0aGlzLnBhdGggKyB0KSwgdCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKHQpOwogICAgICBjb25zdCByID0gQ2UuZ2V0KHQpOwogICAgICBpZiAociAhPT0gdm9pZCAwKQogICAgICAgIHJldHVybiB0aGlzLm1hbmFnZXIuaXRlbVN0YXJ0KHQpLCBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgIGUgJiYgZShyKSwgdGhpcy5tYW5hZ2VyLml0ZW1FbmQodCk7CiAgICAgICAgfSwgMCksIHI7CiAgICAgIGlmIChzdFt0XSAhPT0gdm9pZCAwKSB7CiAgICAgICAgc3RbdF0ucHVzaCh7CiAgICAgICAgICBvbkxvYWQ6IGUsCiAgICAgICAgICBvblByb2dyZXNzOiBpLAogICAgICAgICAgb25FcnJvcjogcwogICAgICAgIH0pOwogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBzdFt0XSA9IFtdLCBzdFt0XS5wdXNoKHsKICAgICAgICBvbkxvYWQ6IGUsCiAgICAgICAgb25Qcm9ncmVzczogaSwKICAgICAgICBvbkVycm9yOiBzCiAgICAgIH0pOwogICAgICBjb25zdCBuID0gbmV3IFJlcXVlc3QodCwgewogICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKHRoaXMucmVxdWVzdEhlYWRlciksCiAgICAgICAgY3JlZGVudGlhbHM6IHRoaXMud2l0aENyZWRlbnRpYWxzID8gImluY2x1ZGUiIDogInNhbWUtb3JpZ2luIgogICAgICAgIC8vIEFuIGFib3J0IGNvbnRyb2xsZXIgY291bGQgYmUgYWRkZWQgd2l0aGluIGEgZnV0dXJlIFBSCiAgICAgIH0pLCBhID0gdGhpcy5taW1lVHlwZSwgbyA9IHRoaXMucmVzcG9uc2VUeXBlOwogICAgICBmZXRjaChuKS50aGVuKChoKSA9PiB7CiAgICAgICAgaWYgKGguc3RhdHVzID09PSAyMDAgfHwgaC5zdGF0dXMgPT09IDApIHsKICAgICAgICAgIGlmIChoLnN0YXR1cyA9PT0gMCAmJiBjb25zb2xlLndhcm4oIlRIUkVFLkZpbGVMb2FkZXI6IEhUVFAgU3RhdHVzIDAgcmVjZWl2ZWQuIiksIHR5cGVvZiBSZWFkYWJsZVN0cmVhbSA9PSAidW5kZWZpbmVkIiB8fCBoLmJvZHkgPT09IHZvaWQgMCB8fCBoLmJvZHkuZ2V0UmVhZGVyID09PSB2b2lkIDApCiAgICAgICAgICAgIHJldHVybiBoOwogICAgICAgICAgY29uc3QgdSA9IHN0W3RdLCBsID0gaC5ib2R5LmdldFJlYWRlcigpLCBkID0gaC5oZWFkZXJzLmdldCgiWC1GaWxlLVNpemUiKSB8fCBoLmhlYWRlcnMuZ2V0KCJDb250ZW50LUxlbmd0aCIpLCBjID0gZCA/IHBhcnNlSW50KGQpIDogMCwgbSA9IGMgIT09IDA7CiAgICAgICAgICBsZXQgeSA9IDA7CiAgICAgICAgICBjb25zdCB4ID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsKICAgICAgICAgICAgc3RhcnQocCkgewogICAgICAgICAgICAgIHooKTsKICAgICAgICAgICAgICBmdW5jdGlvbiB6KCkgewogICAgICAgICAgICAgICAgbC5yZWFkKCkudGhlbigoeyBkb25lOiBGLCB2YWx1ZTogQSB9KSA9PiB7CiAgICAgICAgICAgICAgICAgIGlmIChGKQogICAgICAgICAgICAgICAgICAgIHAuY2xvc2UoKTsKICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgeSArPSBBLmJ5dGVMZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBQcm9ncmVzc0V2ZW50KCJwcm9ncmVzcyIsIHsgbGVuZ3RoQ29tcHV0YWJsZTogbSwgbG9hZGVkOiB5LCB0b3RhbDogYyB9KTsKICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBNID0gMCwgXyA9IHUubGVuZ3RoOyBNIDwgXzsgTSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gdVtNXTsKICAgICAgICAgICAgICAgICAgICAgIHcub25Qcm9ncmVzcyAmJiB3Lm9uUHJvZ3Jlc3MoYik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHAuZW5xdWV1ZShBKSwgeigpOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9LCAoRikgPT4gewogICAgICAgICAgICAgICAgICBwLmVycm9yKEYpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoeCk7CiAgICAgICAgfSBlbHNlCiAgICAgICAgICB0aHJvdyBuZXcgcmkoYGZldGNoIGZvciAiJHtoLnVybH0iIHJlc3BvbmRlZCB3aXRoICR7aC5zdGF0dXN9OiAke2guc3RhdHVzVGV4dH1gLCBoKTsKICAgICAgfSkudGhlbigoaCkgPT4gewogICAgICAgIHN3aXRjaCAobykgewogICAgICAgICAgY2FzZSAiYXJyYXlidWZmZXIiOgogICAgICAgICAgICByZXR1cm4gaC5hcnJheUJ1ZmZlcigpOwogICAgICAgICAgY2FzZSAiYmxvYiI6CiAgICAgICAgICAgIHJldHVybiBoLmJsb2IoKTsKICAgICAgICAgIGNhc2UgImRvY3VtZW50IjoKICAgICAgICAgICAgcmV0dXJuIGgudGV4dCgpLnRoZW4oKHUpID0+IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcodSwgYSkpOwogICAgICAgICAgY2FzZSAianNvbiI6CiAgICAgICAgICAgIHJldHVybiBoLmpzb24oKTsKICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgIGlmIChhID09PSB2b2lkIDApCiAgICAgICAgICAgICAgcmV0dXJuIGgudGV4dCgpOwogICAgICAgICAgICB7CiAgICAgICAgICAgICAgY29uc3QgbCA9IC9jaGFyc2V0PSI/KFteOyJcc10qKSI/L2kuZXhlYyhhKSwgZCA9IGwgJiYgbFsxXSA/IGxbMV0udG9Mb3dlckNhc2UoKSA6IHZvaWQgMCwgYyA9IG5ldyBUZXh0RGVjb2RlcihkKTsKICAgICAgICAgICAgICByZXR1cm4gaC5hcnJheUJ1ZmZlcigpLnRoZW4oKG0pID0+IGMuZGVjb2RlKG0pKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgfSkudGhlbigoaCkgPT4gewogICAgICAgIENlLmFkZCh0LCBoKTsKICAgICAgICBjb25zdCB1ID0gc3RbdF07CiAgICAgICAgZGVsZXRlIHN0W3RdOwogICAgICAgIGZvciAobGV0IGwgPSAwLCBkID0gdS5sZW5ndGg7IGwgPCBkOyBsKyspIHsKICAgICAgICAgIGNvbnN0IGMgPSB1W2xdOwogICAgICAgICAgYy5vbkxvYWQgJiYgYy5vbkxvYWQoaCk7CiAgICAgICAgfQogICAgICB9KS5jYXRjaCgoaCkgPT4gewogICAgICAgIGNvbnN0IHUgPSBzdFt0XTsKICAgICAgICBpZiAodSA9PT0gdm9pZCAwKQogICAgICAgICAgdGhyb3cgdGhpcy5tYW5hZ2VyLml0ZW1FcnJvcih0KSwgaDsKICAgICAgICBkZWxldGUgc3RbdF07CiAgICAgICAgZm9yIChsZXQgbCA9IDAsIGQgPSB1Lmxlbmd0aDsgbCA8IGQ7IGwrKykgewogICAgICAgICAgY29uc3QgYyA9IHVbbF07CiAgICAgICAgICBjLm9uRXJyb3IgJiYgYy5vbkVycm9yKGgpOwogICAgICAgIH0KICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVycm9yKHQpOwogICAgICB9KS5maW5hbGx5KCgpID0+IHsKICAgICAgICB0aGlzLm1hbmFnZXIuaXRlbUVuZCh0KTsKICAgICAgfSksIHRoaXMubWFuYWdlci5pdGVtU3RhcnQodCk7CiAgICB9CiAgICBzZXRSZXNwb25zZVR5cGUodCkgewogICAgICByZXR1cm4gdGhpcy5yZXNwb25zZVR5cGUgPSB0LCB0aGlzOwogICAgfQogICAgc2V0TWltZVR5cGUodCkgewogICAgICByZXR1cm4gdGhpcy5taW1lVHlwZSA9IHQsIHRoaXM7CiAgICB9CiAgfQogIHR5cGVvZiBfX1RIUkVFX0RFVlRPT0xTX18gIT0gInVuZGVmaW5lZCIgJiYgX19USFJFRV9ERVZUT09MU19fLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCJyZWdpc3RlciIsIHsgZGV0YWlsOiB7CiAgICByZXZpc2lvbjogQmUKICB9IH0pKTsKICB0eXBlb2Ygd2luZG93ICE9ICJ1bmRlZmluZWQiICYmICh3aW5kb3cuX19USFJFRV9fID8gY29uc29sZS53YXJuKCJXQVJOSU5HOiBNdWx0aXBsZSBpbnN0YW5jZXMgb2YgVGhyZWUuanMgYmVpbmcgaW1wb3J0ZWQuIikgOiB3aW5kb3cuX19USFJFRV9fID0gQmUpOwogIGNvbnN0IG5pID0gImh0dHBzOi8vcGxheWVyNC1kZXYuOGkuY29tL2RyYWNvLyIsIGFpID0gMSwgdWUgPSAiZnVsbCIsIFJ0ID0gImRlbHRhIiwga2UgPSAiaW50ZXJwb2xhdGVkIiwgb2kgPSAiU3RyaW5nRW50cnkiLCBEdCA9ICJJbnRFbnRyeUFycmF5IiwgVGUgPSAiSW50RW50cnkiLCBsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpOwogIGNsYXNzIGhpIGV4dGVuZHMgbWUgewogICAgY29uc3RydWN0b3IodCkgewogICAgICBzdXBlcih0KSwgdGhpcy5kZWNvZGVyUGF0aCA9ICIiLCB0aGlzLmRlY29kZXJDb25maWcgPSB7fSwgdGhpcy5kZWNvZGVyQmluYXJ5ID0gbnVsbCwgdGhpcy5kZWNvZGVyUGVuZGluZyA9IG51bGwsIHRoaXMud29ya2VyTGltaXQgPSBhaSwgdGhpcy53b3JrZXJQb29sID0gW10sIHRoaXMud29ya2VyTmV4dFRhc2tJRCA9IDEsIHRoaXMud29ya2VyU291cmNlVVJMID0gIiIsIHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcyA9IHsKICAgICAgICBwb3NpdGlvbjogIlBPU0lUSU9OIiwKICAgICAgICBub3JtYWw6ICJOT1JNQUwiLAogICAgICAgIGNvbG9yOiAiQ09MT1IiLAogICAgICAgIHV2OiAiVEVYX0NPT1JEIgogICAgICB9LCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcyA9IHsKICAgICAgICBwb3NpdGlvbjogIkZsb2F0MzJBcnJheSIsCiAgICAgICAgbm9ybWFsOiAiRmxvYXQzMkFycmF5IiwKICAgICAgICBjb2xvcjogIkZsb2F0MzJBcnJheSIsCiAgICAgICAgdXY6ICJGbG9hdDMyQXJyYXkiCiAgICAgIH07CiAgICB9CiAgICBzZXREZWNvZGVyUGF0aCh0KSB7CiAgICAgIHJldHVybiB0aGlzLmRlY29kZXJQYXRoID0gdCwgdGhpczsKICAgIH0KICAgIHNldERlY29kZXJDb25maWcodCkgewogICAgICByZXR1cm4gdGhpcy5kZWNvZGVyQ29uZmlnID0gdCwgdGhpczsKICAgIH0KICAgIHNldFdvcmtlckxpbWl0KHQpIHsKICAgICAgcmV0dXJuIHRoaXMud29ya2VyTGltaXQgPSB0LCB0aGlzOwogICAgfQogICAgbG9hZCh0LCBlLCBpLCBzKSB7CiAgICAgIGNvbnN0IHIgPSBuZXcgRWUodGhpcy5tYW5hZ2VyKTsKICAgICAgci5zZXRQYXRoKHRoaXMucGF0aCksIHIuc2V0UmVzcG9uc2VUeXBlKCJhcnJheWJ1ZmZlciIpLCByLnNldFJlcXVlc3RIZWFkZXIodGhpcy5yZXF1ZXN0SGVhZGVyKSwgci5zZXRXaXRoQ3JlZGVudGlhbHModGhpcy53aXRoQ3JlZGVudGlhbHMpLCByLmxvYWQoCiAgICAgICAgdCwKICAgICAgICAobikgPT4gewogICAgICAgICAgdGhpcy5wYXJzZShuLCBlLCBzKTsKICAgICAgICB9LAogICAgICAgIGksCiAgICAgICAgcwogICAgICApOwogICAgfQogICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvbgogICAgcGFyc2UodCwgZSwgaSA9ICgpID0+IHsKICAgIH0pIHsKICAgICAgdGhpcy5kZWNvZGVEcmFjb0ZpbGUoCiAgICAgICAgdCwKICAgICAgICBlLAogICAgICAgIG51bGwsCiAgICAgICAgbnVsbCwKICAgICAgICBYLAogICAgICAgIGkKICAgICAgKS5jYXRjaChpKTsKICAgIH0KICAgIGRlY29kZURyYWNvRmlsZSh0LCBlLCBpLCBzLCByID0gR3QsIG4gPSAoKSA9PiB7CiAgICB9KSB7CiAgICAgIGNvbnN0IGEgPSB7CiAgICAgICAgYXR0cmlidXRlSURzOiBpIHx8IHRoaXMuZGVmYXVsdEF0dHJpYnV0ZUlEcywKICAgICAgICBhdHRyaWJ1dGVUeXBlczogcyB8fCB0aGlzLmRlZmF1bHRBdHRyaWJ1dGVUeXBlcywKICAgICAgICB1c2VVbmlxdWVJRHM6ICEhaSwKICAgICAgICB2ZXJ0ZXhDb2xvclNwYWNlOiByCiAgICAgIH07CiAgICAgIHJldHVybiB0aGlzLmRlY29kZUdlb21ldHJ5KHQsIGEpLnRoZW4oZSkuY2F0Y2gobik7CiAgICB9CiAgICBkZWNvZGVHZW9tZXRyeSh0LCBlKSB7CiAgICAgIGZvciAoY29uc3QgbyBpbiBlLmF0dHJpYnV0ZVR5cGVzKSB7CiAgICAgICAgY29uc3QgaCA9IGUuYXR0cmlidXRlVHlwZXNbb107CiAgICAgICAgaC5CWVRFU19QRVJfRUxFTUVOVCAhPT0gdm9pZCAwICYmIChlLmF0dHJpYnV0ZVR5cGVzW29dID0gaC5uYW1lKTsKICAgICAgfQogICAgICBjb25zdCBpID0gSlNPTi5zdHJpbmdpZnkoZSk7CiAgICAgIGlmIChsZS5oYXModCkpIHsKICAgICAgICBjb25zdCBvID0gbGUuZ2V0KHQpOwogICAgICAgIGlmIChvLmtleSA9PT0gaSkKICAgICAgICAgIHJldHVybiBvLnByb21pc2U7CiAgICAgICAgaWYgKHQuYnl0ZUxlbmd0aCA9PT0gMCkKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICAgICAgIlRIUkVFLkRSQUNPTG9hZGVyOiBVbmFibGUgdG8gcmUtZGVjb2RlIGEgYnVmZmVyIHdpdGggZGlmZmVyZW50IHNldHRpbmdzLiBCdWZmZXIgaGFzIGFscmVhZHkgYmVlbiB0cmFuc2ZlcnJlZC4iCiAgICAgICAgICApOwogICAgICB9CiAgICAgIGxldCBzOwogICAgICBjb25zdCByID0gdGhpcy53b3JrZXJOZXh0VGFza0lEKyssIG4gPSB0LmJ5dGVMZW5ndGgsIGEgPSB0aGlzLl9nZXRXb3JrZXIociwgbikudGhlbigobykgPT4gKHMgPSBvLCBuZXcgUHJvbWlzZSgoaCwgdSkgPT4gewogICAgICAgIHMuX2NhbGxiYWNrc1tyXSA9IHsgcmVzb2x2ZTogaCwgcmVqZWN0OiB1IH0sIHMucG9zdE1lc3NhZ2UoCiAgICAgICAgICB7IHR5cGU6ICJkZWNvZGUiLCBpZDogciwgdGFza0NvbmZpZzogZSwgYnVmZmVyOiB0IH0sCiAgICAgICAgICBbdF0KICAgICAgICApOwogICAgICB9KSkpLnRoZW4oKG8pID0+IHRoaXMuX2NyZWF0ZUdlb21ldHJ5KG8uZ2VvbWV0cnkpKTsKICAgICAgcmV0dXJuIGEuY2F0Y2goKCkgPT4gITApLnRoZW4oKCkgPT4gewogICAgICAgIHMgJiYgciAmJiB0aGlzLl9yZWxlYXNlVGFzayhzLCByKTsKICAgICAgfSksIGxlLnNldCh0LCB7CiAgICAgICAga2V5OiBpLAogICAgICAgIHByb21pc2U6IGEKICAgICAgfSksIGE7CiAgICB9CiAgICBfY3JlYXRlR2VvbWV0cnkodCkgewogICAgICBjb25zdCBlID0gbmV3IFp0KCk7CiAgICAgIHQuaW5kZXggJiYgZS5zZXRJbmRleChuZXcgUSh0LmluZGV4LmFycmF5LCAxKSk7CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgcyA9IHQuYXR0cmlidXRlc1tpXSwgciA9IHMubmFtZSwgbiA9IHMuYXJyYXksIGEgPSBzLml0ZW1TaXplLCBvID0gbmV3IFEobiwgYSk7CiAgICAgICAgciA9PT0gImNvbG9yIiAmJiAodGhpcy5fYXNzaWduVmVydGV4Q29sb3JTcGFjZShvLCBzLnZlcnRleENvbG9yU3BhY2UpLCBvLm5vcm1hbGl6ZWQgPSAhKG4gaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpKSwgZS5zZXRBdHRyaWJ1dGUociwgbyk7CiAgICAgIH0KICAgICAgcmV0dXJuIGUubWV0YWRhdGEgPSB0Lm1ldGFkYXRhLCBlOwogICAgfQogICAgX2Fzc2lnblZlcnRleENvbG9yU3BhY2UodCwgZSkgewogICAgICBpZiAoZSAhPT0gWCkgcmV0dXJuOwogICAgICBjb25zdCBpID0gbmV3IGRlKCk7CiAgICAgIGZvciAobGV0IHMgPSAwLCByID0gdC5jb3VudDsgcyA8IHI7IHMrKykKICAgICAgICBpLmZyb21CdWZmZXJBdHRyaWJ1dGUodCwgcykuY29udmVydFNSR0JUb0xpbmVhcigpLCB0LnNldFhZWihzLCBpLnIsIGkuZywgaS5iKTsKICAgIH0KICAgIF9sb2FkTGlicmFyeSh0LCBlKSB7CiAgICAgIGNvbnN0IGkgPSBuZXcgRWUodGhpcy5tYW5hZ2VyKTsKICAgICAgcmV0dXJuIGkuc2V0UGF0aCh0aGlzLmRlY29kZXJQYXRoKSwgaS5zZXRSZXNwb25zZVR5cGUoZSksIGkuc2V0V2l0aENyZWRlbnRpYWxzKHRoaXMud2l0aENyZWRlbnRpYWxzKSwgbmV3IFByb21pc2UoKHMsIHIpID0+IHsKICAgICAgICBpLmxvYWQodCwgcywgdm9pZCAwLCByKTsKICAgICAgfSk7CiAgICB9CiAgICBwcmVsb2FkKCkgewogICAgICByZXR1cm4gdGhpcy5faW5pdERlY29kZXIoKSwgdGhpczsKICAgIH0KICAgIF9pbml0RGVjb2RlcigpIHsKICAgICAgaWYgKHRoaXMuZGVjb2RlclBlbmRpbmcpIHJldHVybiB0aGlzLmRlY29kZXJQZW5kaW5nOwogICAgICBjb25zdCB0ID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9ICJvYmplY3QiIHx8IHRoaXMuZGVjb2RlckNvbmZpZy50eXBlID09PSAianMiLCBlID0gW107CiAgICAgIHJldHVybiB0ID8gZS5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KCJkcmFjb19kZWNvZGVyLmpzIiwgInRleHQiKSkgOiAoZS5wdXNoKHRoaXMuX2xvYWRMaWJyYXJ5KCJkcmFjb193YXNtX3dyYXBwZXIuanMiLCAidGV4dCIpKSwgZS5wdXNoKAogICAgICAgIHRoaXMuX2xvYWRMaWJyYXJ5KCJkcmFjb19kZWNvZGVyLndhc20iLCAiYXJyYXlidWZmZXIiKQogICAgICApKSwgdGhpcy5kZWNvZGVyUGVuZGluZyA9IFByb21pc2UuYWxsKGUpLnRoZW4oKGkpID0+IHsKICAgICAgICBjb25zdCBzID0gaVswXTsKICAgICAgICB0IHx8ICh0aGlzLmRlY29kZXJDb25maWcud2FzbUJpbmFyeSA9IGlbMV0pOwogICAgICAgIGNvbnN0IHIgPSB1aS50b1N0cmluZygpLCBuID0gWwogICAgICAgICAgIi8qIGRyYWNvIGRlY29kZXIgKi8iLAogICAgICAgICAgcywKICAgICAgICAgICIiLAogICAgICAgICAgIi8qIHdvcmtlciAqLyIsCiAgICAgICAgICByLnN1YnN0cmluZyhyLmluZGV4T2YoInsiKSArIDEsIHIubGFzdEluZGV4T2YoIn0iKSkKICAgICAgICBdLmpvaW4oYApgKTsKICAgICAgICB0aGlzLndvcmtlclNvdXJjZVVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW25dKSk7CiAgICAgIH0pLCB0aGlzLmRlY29kZXJQZW5kaW5nOwogICAgfQogICAgX2dldFdvcmtlcih0LCBlKSB7CiAgICAgIHJldHVybiB0aGlzLl9pbml0RGVjb2RlcigpLnRoZW4oKCkgPT4gewogICAgICAgIGlmICh0aGlzLndvcmtlclBvb2wubGVuZ3RoIDwgdGhpcy53b3JrZXJMaW1pdCkgewogICAgICAgICAgY29uc3QgcyA9IG5ldyBXb3JrZXIodGhpcy53b3JrZXJTb3VyY2VVUkwpOwogICAgICAgICAgcy5fY2FsbGJhY2tzID0ge30sIHMuX3Rhc2tDb3N0cyA9IHt9LCBzLl90YXNrTG9hZCA9IDAsIHMucG9zdE1lc3NhZ2UoeyB0eXBlOiAiaW5pdCIsIGRlY29kZXJDb25maWc6IHRoaXMuZGVjb2RlckNvbmZpZyB9KSwgcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihyKSB7CiAgICAgICAgICAgIGNvbnN0IG4gPSByLmRhdGE7CiAgICAgICAgICAgIHN3aXRjaCAobi50eXBlKSB7CiAgICAgICAgICAgICAgY2FzZSAiZGVjb2RlIjoKICAgICAgICAgICAgICAgIHMuX2NhbGxiYWNrc1tuLmlkXS5yZXNvbHZlKG4pOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAiZXJyb3IiOgogICAgICAgICAgICAgICAgcy5fY2FsbGJhY2tzW24uaWRdLnJlamVjdChuKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKAogICAgICAgICAgICAgICAgICAnVEhSRUUuRFJBQ09Mb2FkZXI6IFVuZXhwZWN0ZWQgbWVzc2FnZSwgIicgKyBuLnR5cGUgKyAnIicKICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0sIHRoaXMud29ya2VyUG9vbC5wdXNoKHMpOwogICAgICAgIH0gZWxzZQogICAgICAgICAgdGhpcy53b3JrZXJQb29sLnNvcnQoZnVuY3Rpb24ocywgcikgewogICAgICAgICAgICByZXR1cm4gcy5fdGFza0xvYWQgPiByLl90YXNrTG9hZCA/IC0xIDogMTsKICAgICAgICAgIH0pOwogICAgICAgIGNvbnN0IGkgPSB0aGlzLndvcmtlclBvb2xbdGhpcy53b3JrZXJQb29sLmxlbmd0aCAtIDFdOwogICAgICAgIHJldHVybiBpLl90YXNrQ29zdHNbdF0gPSBlLCBpLl90YXNrTG9hZCArPSBlLCBpOwogICAgICB9KTsKICAgIH0KICAgIF9yZWxlYXNlVGFzayh0LCBlKSB7CiAgICAgIHQuX3Rhc2tMb2FkIC09IHQuX3Rhc2tDb3N0c1tlXSwgZGVsZXRlIHQuX2NhbGxiYWNrc1tlXSwgZGVsZXRlIHQuX3Rhc2tDb3N0c1tlXTsKICAgIH0KICAgIGRlYnVnKCkgewogICAgICBjb25zb2xlLmxvZygKICAgICAgICAiVGFzayBsb2FkOiAiLAogICAgICAgIHRoaXMud29ya2VyUG9vbC5tYXAoKHQpID0+IHQuX3Rhc2tMb2FkKQogICAgICApOwogICAgfQogICAgZGlzcG9zZSgpIHsKICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCB0aGlzLndvcmtlclBvb2wubGVuZ3RoOyArK3QpCiAgICAgICAgdGhpcy53b3JrZXJQb29sW3RdLnRlcm1pbmF0ZSgpOwogICAgICByZXR1cm4gdGhpcy53b3JrZXJQb29sLmxlbmd0aCA9IDAsIHRoaXMud29ya2VyU291cmNlVVJMICE9PSAiIiAmJiBVUkwucmV2b2tlT2JqZWN0VVJMKHRoaXMud29ya2VyU291cmNlVVJMKSwgdGhpczsKICAgIH0KICB9CiAgZnVuY3Rpb24gdWkoKSB7CiAgICBsZXQgZiwgdDsKICAgIG9ubWVzc2FnZSA9IGZ1bmN0aW9uKG4pIHsKICAgICAgY29uc3QgYSA9IG4uZGF0YTsKICAgICAgc3dpdGNoIChhLnR5cGUpIHsKICAgICAgICBjYXNlICJpbml0IjogewogICAgICAgICAgZiA9IGEuZGVjb2RlckNvbmZpZywgdCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKG8pIHsKICAgICAgICAgICAgZi5vbk1vZHVsZUxvYWRlZCA9IGZ1bmN0aW9uKGgpIHsKICAgICAgICAgICAgICBvKHsgZHJhY286IGggfSk7CiAgICAgICAgICAgIH0sIERyYWNvRGVjb2Rlck1vZHVsZShmKTsKICAgICAgICAgIH0pOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGNhc2UgImRlY29kZSI6IHsKICAgICAgICAgIGNvbnN0IG8gPSBhLmJ1ZmZlciwgaCA9IGEudGFza0NvbmZpZzsKICAgICAgICAgIHQudGhlbigodSkgPT4gewogICAgICAgICAgICBjb25zdCBsID0gdS5kcmFjbywgZCA9IG5ldyBsLkRlY29kZXIoKTsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBjb25zdCBjID0gZSgKICAgICAgICAgICAgICAgIGwsCiAgICAgICAgICAgICAgICBkLAogICAgICAgICAgICAgICAgbmV3IEludDhBcnJheShvKSwKICAgICAgICAgICAgICAgIGgKICAgICAgICAgICAgICApLCBtID0gYy5hdHRyaWJ1dGVzLm1hcCgKICAgICAgICAgICAgICAgICh5KSA9PiB5LmFycmF5LmJ1ZmZlcgogICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhjLm1ldGFkYXRhKS5mb3JFYWNoKCh5KSA9PiB7CiAgICAgICAgICAgICAgICB5ICYmIHkuYnVmZmVyICYmIG0ucHVzaCh5LmJ1ZmZlcik7CiAgICAgICAgICAgICAgfSksIGMuaW5kZXggJiYgbS5wdXNoKGMuaW5kZXguYXJyYXkuYnVmZmVyKSwgc2VsZi5wb3N0TWVzc2FnZSgKICAgICAgICAgICAgICAgIHsgdHlwZTogImRlY29kZSIsIGlkOiBhLmlkLCBnZW9tZXRyeTogYyB9LAogICAgICAgICAgICAgICAgbQogICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0gY2F0Y2ggKGMpIHsKICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGMpLCBzZWxmLnBvc3RNZXNzYWdlKHsKICAgICAgICAgICAgICAgIHR5cGU6ICJlcnJvciIsCiAgICAgICAgICAgICAgICBpZDogYS5pZCwKICAgICAgICAgICAgICAgIGVycm9yOiBjLm1lc3NhZ2UKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBmaW5hbGx5IHsKICAgICAgICAgICAgICBsLmRlc3Ryb3koZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICB9OwogICAgZnVuY3Rpb24gZShuLCBhLCBvLCBoKSB7CiAgICAgIGNvbnN0IHUgPSBoLmF0dHJpYnV0ZUlEcywgbCA9IGguYXR0cmlidXRlVHlwZXMsIGQgPSBoLm1ldGFkYXRhRmllbGRzLCBjID0gISFoLmlzRW5jcnlwdGVkOwogICAgICBsZXQgbSwgeTsKICAgICAgY29uc3QgeCA9IGEuR2V0RW5jb2RlZEdlb21ldHJ5VHlwZShvKTsKICAgICAgaWYgKHggPT09IG4uVFJJQU5HVUxBUl9NRVNIKQogICAgICAgIG0gPSBuZXcgbi5NZXNoKCksIHkgPSBhLkRlY29kZUFycmF5VG9NZXNoKAogICAgICAgICAgbywKICAgICAgICAgIG8uYnl0ZUxlbmd0aCwKICAgICAgICAgIG0KICAgICAgICApOwogICAgICBlbHNlIGlmICh4ID09PSBuLlBPSU5UX0NMT1VEKQogICAgICAgIG0gPSBuZXcgbi5Qb2ludENsb3VkKCksIHkgPSBhLkRlY29kZUFycmF5VG9Qb2ludENsb3VkKAogICAgICAgICAgbywKICAgICAgICAgIG8uYnl0ZUxlbmd0aCwKICAgICAgICAgIG0KICAgICAgICApOwogICAgICBlbHNlCiAgICAgICAgdGhyb3cgYyA/IG5ldyBFcnJvcignIlRIUkVFLkRSQUNPTG9hZGVyOiBDb3VsZCBub3QgZGVjb2RlIG1lc2guIicpIDogbmV3IEVycm9yKAogICAgICAgICAgYCJUSFJFRS5EUkFDT0xvYWRlcjogVW5leHBlY3RlZCBnZW9tZXRyeSB0eXBlICR7eH0uImAKICAgICAgICApOwogICAgICBpZiAoIXkub2soKSB8fCBtLnB0ciA9PT0gMCkKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAiVEhSRUUuRFJBQ09Mb2FkZXI6IERlY29kaW5nIGZhaWxlZDogIiArIHkuZXJyb3JfbXNnKCkKICAgICAgICApOwogICAgICBjb25zdCBwID0geyBpbmRleDogbnVsbCwgYXR0cmlidXRlczogW10gfTsKICAgICAgZm9yIChjb25zdCBiIGluIHUpIHsKICAgICAgICBjb25zdCBNID0gc2VsZltsW2JdXTsKICAgICAgICBsZXQgXywgdzsKICAgICAgICBpZiAoaC51c2VVbmlxdWVJRHMpCiAgICAgICAgICB3ID0gdVtiXSwgXyA9IGEuR2V0QXR0cmlidXRlQnlVbmlxdWVJZChtLCB3KTsKICAgICAgICBlbHNlIHsKICAgICAgICAgIGlmICh3ID0gYS5HZXRBdHRyaWJ1dGVJZCgKICAgICAgICAgICAgbSwKICAgICAgICAgICAgblt1W2JdXQogICAgICAgICAgKSwgdyA9PT0gLTEpIGNvbnRpbnVlOwogICAgICAgICAgXyA9IGEuR2V0QXR0cmlidXRlKG0sIHcpOwogICAgICAgIH0KICAgICAgICBjb25zdCBFID0gcygKICAgICAgICAgIG4sCiAgICAgICAgICBhLAogICAgICAgICAgbSwKICAgICAgICAgIGIsCiAgICAgICAgICBNLAogICAgICAgICAgXwogICAgICAgICk7CiAgICAgICAgYiA9PT0gImNvbG9yIiAmJiAoRS52ZXJ0ZXhDb2xvclNwYWNlID0gaC52ZXJ0ZXhDb2xvclNwYWNlKSwgcC5hdHRyaWJ1dGVzLnB1c2goRSk7CiAgICAgIH0KICAgICAgcC5tZXRhZGF0YSA9IHAubWV0YWRhdGEgfHwge307CiAgICAgIGNvbnN0IHogPSBhLkdldE1ldGFkYXRhKG0pLCBGID0gbmV3IG4uTWV0YWRhdGFRdWVyaWVyKCk7CiAgICAgIGZvciAoY29uc3QgYiBpbiBkKQogICAgICAgIGlmIChGLkhhc0VudHJ5KHosIGIpKSB7CiAgICAgICAgICBjb25zdCBNID0gZFtiXTsKICAgICAgICAgIGxldCBfOwogICAgICAgICAgaWYgKE0gPT09ICJJbnRFbnRyeUFycmF5IikgewogICAgICAgICAgICBjb25zdCB3ID0gbmV3IG4uRHJhY29JbnQzMkFycmF5KCk7CiAgICAgICAgICAgIEZbYEdldCR7TX1gXSh6LCBiLCB3KTsKICAgICAgICAgICAgY29uc3QgRSA9IHcuc2l6ZSgpOwogICAgICAgICAgICBfID0gbmV3IEludDMyQXJyYXkoRSk7CiAgICAgICAgICAgIGZvciAobGV0IEMgPSAwOyBDIDwgRTsgQysrKQogICAgICAgICAgICAgIF9bQ10gPSB3LkdldFZhbHVlKEMpOwogICAgICAgICAgICBuLl9mcmVlKHcpOwogICAgICAgICAgfSBlbHNlIGlmIChNID09PSAiRW50cnlEb3VibGVBcnJheSIgfHwgTSA9PT0gIkRvdWJsZUVudHJ5QXJyYXkiKSB7CiAgICAgICAgICAgIGNvbnN0IHcgPSBuZXcgbi5EcmFjb0RvdWJsZUFycmF5KCk7CiAgICAgICAgICAgIEZbYEdldCR7TX1gXSh6LCBiLCB3KTsKICAgICAgICAgICAgY29uc3QgRSA9IHcuc2l6ZSgpOwogICAgICAgICAgICBfID0gbmV3IEZsb2F0NjRBcnJheShFKTsKICAgICAgICAgICAgZm9yIChsZXQgQyA9IDA7IEMgPCBFOyBDKyspCiAgICAgICAgICAgICAgX1tDXSA9IHcuR2V0VmFsdWUoQyk7CiAgICAgICAgICAgIG4uX2ZyZWUodyk7CiAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgXyA9IEZbYEdldCR7TX1gXSh6LCBiKTsKICAgICAgICAgIHAubWV0YWRhdGFbYl0gPSBfOwogICAgICAgIH0KICAgICAgZm9yIChjb25zdCBiIG9mIHAubWV0YWRhdGEuZGVsdGFJZHMgfHwgW10pCiAgICAgICAgYXR0cmlidXRlID0gYS5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKG0sIGIpLCBwLmF0dHJpYnV0ZXMucHVzaCgKICAgICAgICAgIHMoCiAgICAgICAgICAgIG4sCiAgICAgICAgICAgIGEsCiAgICAgICAgICAgIG0sCiAgICAgICAgICAgIGIsCiAgICAgICAgICAgIEZsb2F0MzJBcnJheSwKICAgICAgICAgICAgYXR0cmlidXRlCiAgICAgICAgICApCiAgICAgICAgKTsKICAgICAgZm9yIChjb25zdCBiIG9mIHAubWV0YWRhdGEuZGVsdGFOb3JtYWxJZHMgfHwgW10pIHsKICAgICAgICBjb25zdCBNID0gYS5HZXRBdHRyaWJ1dGVCeVVuaXF1ZUlkKAogICAgICAgICAgbSwKICAgICAgICAgIGIKICAgICAgICApOwogICAgICAgIHAuYXR0cmlidXRlcy5wdXNoKAogICAgICAgICAgcygKICAgICAgICAgICAgbiwKICAgICAgICAgICAgYSwKICAgICAgICAgICAgbSwKICAgICAgICAgICAgYiwKICAgICAgICAgICAgRmxvYXQzMkFycmF5LAogICAgICAgICAgICBNCiAgICAgICAgICApCiAgICAgICAgKTsKICAgICAgfQogICAgICBjb25zdCBBID0gewogICAgICAgIHdlaWdodHNBdHQ6IEZsb2F0MzJBcnJheSwKICAgICAgICBiaW5kaW5nc0F0dDogSW50MzJBcnJheQogICAgICB9OwogICAgICBmb3IgKGNvbnN0IFtiLCBNXSBvZiBPYmplY3QuZW50cmllcyhBKSkKICAgICAgICBpZiAocC5tZXRhZGF0YVtiXSkgewogICAgICAgICAgY29uc3QgXyA9IGEuR2V0QXR0cmlidXRlQnlVbmlxdWVJZCgKICAgICAgICAgICAgbSwKICAgICAgICAgICAgcC5tZXRhZGF0YVtiXQogICAgICAgICAgKTsKICAgICAgICAgIHAuYXR0cmlidXRlcy5wdXNoKAogICAgICAgICAgICBzKG4sIGEsIG0sIGIsIE0sIF8pCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgcmV0dXJuIHggPT09IG4uVFJJQU5HVUxBUl9NRVNIICYmIChwLmluZGV4ID0gaShuLCBhLCBtKSksIG4uZGVzdHJveShtKSwgcDsKICAgIH0KICAgIGZ1bmN0aW9uIGkobiwgYSwgbykgewogICAgICBjb25zdCB1ID0gby5udW1fZmFjZXMoKSAqIDMsIGwgPSB1ICogNCwgZCA9IG4uX21hbGxvYyhsKTsKICAgICAgYS5HZXRUcmlhbmdsZXNVSW50MzJBcnJheShvLCBsLCBkKTsKICAgICAgY29uc3QgYyA9IG5ldyBVaW50MzJBcnJheSgKICAgICAgICBuLkhFQVBGMzIuYnVmZmVyLAogICAgICAgIGQsCiAgICAgICAgdQogICAgICApLnNsaWNlKCk7CiAgICAgIHJldHVybiBuLl9mcmVlKGQpLCB7IGFycmF5OiBjLCBpdGVtU2l6ZTogMSB9OwogICAgfQogICAgZnVuY3Rpb24gcyhuLCBhLCBvLCBoLCB1LCBsKSB7CiAgICAgIGNvbnN0IGQgPSBsLm51bV9jb21wb25lbnRzKCksIG0gPSBvLm51bV9wb2ludHMoKSAqIGQsIHkgPSBtICogdS5CWVRFU19QRVJfRUxFTUVOVCwgeCA9IHIobiwgdSksIHAgPSBuLl9tYWxsb2MoeSk7CiAgICAgIGEuR2V0QXR0cmlidXRlRGF0YUFycmF5Rm9yQWxsUG9pbnRzKAogICAgICAgIG8sCiAgICAgICAgbCwKICAgICAgICB4LAogICAgICAgIHksCiAgICAgICAgcAogICAgICApOwogICAgICBjb25zdCB6ID0gbmV3IHUoCiAgICAgICAgbi5IRUFQRjMyLmJ1ZmZlciwKICAgICAgICBwLAogICAgICAgIG0KICAgICAgKS5zbGljZSgpOwogICAgICByZXR1cm4gbi5fZnJlZShwKSwgewogICAgICAgIG5hbWU6IGgsCiAgICAgICAgYXJyYXk6IHosCiAgICAgICAgaXRlbVNpemU6IGQKICAgICAgfTsKICAgIH0KICAgIGZ1bmN0aW9uIHIobiwgYSkgewogICAgICBzd2l0Y2ggKGEpIHsKICAgICAgICBjYXNlIEZsb2F0MzJBcnJheToKICAgICAgICAgIHJldHVybiBuLkRUX0ZMT0FUMzI7CiAgICAgICAgY2FzZSBJbnQ4QXJyYXk6CiAgICAgICAgICByZXR1cm4gbi5EVF9JTlQ4OwogICAgICAgIGNhc2UgSW50MTZBcnJheToKICAgICAgICAgIHJldHVybiBuLkRUX0lOVDE2OwogICAgICAgIGNhc2UgSW50MzJBcnJheToKICAgICAgICAgIHJldHVybiBuLkRUX0lOVDMyOwogICAgICAgIGNhc2UgVWludDhBcnJheToKICAgICAgICAgIHJldHVybiBuLkRUX1VJTlQ4OwogICAgICAgIGNhc2UgVWludDE2QXJyYXk6CiAgICAgICAgICByZXR1cm4gbi5EVF9VSU5UMTY7CiAgICAgICAgY2FzZSBVaW50MzJBcnJheToKICAgICAgICAgIHJldHVybiBuLkRUX1VJTlQzMjsKICAgICAgfQogICAgfQogIH0KICBsZXQgSXQgPSBudWxsOwogIGNvbnN0IEh0ID0gNCwgbGkgPSAoZSwgLi4uaSkgPT4gUXQoeWUsIFtlLCAuLi5pXSwgZnVuY3Rpb24qIChmLCB0ID0gSWUpIHsKICAgIGNvbnN0IHsgZGF0YTogcywgdGltZXNjYWxlOiByLCBkdHM6IG4gfSA9IGY7CiAgICBJdCB8fCAoSXQgPSBuZXcgaGkodCksIEl0LnNldERlY29kZXJQYXRoKG5pKSk7CiAgICBjb25zdCB7IGRlZmF1bHRBdHRyaWJ1dGVJRHM6IGEsIGRlZmF1bHRBdHRyaWJ1dGVUeXBlczogbyB9ID0gSXQsIGggPSB7CiAgICAgIGF0dHJpYnV0ZUlEczogYSwKICAgICAgYXR0cmlidXRlVHlwZXM6IG8sCiAgICAgIG1ldGFkYXRhRmllbGRzOiB7CiAgICAgICAgdmVyc2lvbjogb2ksCiAgICAgICAgdGltZXN0YW1wOiBEdCwKICAgICAgICBpbnRlcnBvbGF0ZWRGcmFtZXM6IER0LAogICAgICAgIGRlbHRhRnJhbWVzOiBEdCwKICAgICAgICBkZWx0YUlkczogRHQsCiAgICAgICAgZGVsdGFOb3JtYWxJZHM6IER0LAogICAgICAgIHdlaWdodHNBdHQ6IFRlLAogICAgICAgIGJpbmRpbmdzQXR0OiBUZQogICAgICAgIC8vIGhlYWRKb2ludDogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIGhlYWRKb2ludEluZGV4OiBFTlRSWV9JTlQsCiAgICAgICAgLy8gbmVja0pvaW50OiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gbmVja0pvaW50SW5kZXg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBOT1NFOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gTk9TRV9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEVZRV9MOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gRVlFX0xfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBFWUVfUjogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIEVZRV9SX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gRUFSX0w6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBFQVJfTF9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEVBUl9SOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gRUFSX1JfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBTSE9fTDogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIFNIT19MX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gU0hPX1I6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBTSE9fUl9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEVMQl9MOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gRUxCX0xfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBFTEJfUjogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIEVMQl9SX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gV1JJX0w6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBXUklfTF9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIFdSSV9SOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gV1JJX1JfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBISVBfTDogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIEhJUF9MX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gSElQX1I6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBISVBfUl9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEtORV9MOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gS05FX0xfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBLTkVfUjogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIEtORV9SX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gQU5LX0w6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBBTktfTF9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEFOS19SOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gQU5LX1JfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBORUNLOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gTkVDS19JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIEhFQUQ6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBIRUFEX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gU1BJTkVfSDogRU5UUllfRE9VQkxFX0FSUkFZLAogICAgICAgIC8vIFNQSU5FX0hfSU5ERVg6IEVOVFJZX0lOVCwKICAgICAgICAvLyBTUElORV9NOiBFTlRSWV9ET1VCTEVfQVJSQVksCiAgICAgICAgLy8gU1BJTkVfTV9JTkRFWDogRU5UUllfSU5ULAogICAgICAgIC8vIFNQSU5FX0w6IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBTUElORV9MX0lOREVYOiBFTlRSWV9JTlQsCiAgICAgICAgLy8gSElQX006IEVOVFJZX0RPVUJMRV9BUlJBWSwKICAgICAgICAvLyBISVBfTV9JTkRFWDogRU5UUllfSU5ULAogICAgICB9LAogICAgICB1c2VVbmlxdWVJRHM6ICExLAogICAgICB2ZXJ0ZXhDb2xvclNwYWNlOiBHdCwKICAgICAgaXNFbmNyeXB0ZWQ6ICEhZi5lbmNyeXB0ZWQKICAgIH0sIHUgPSB5aWVsZCBJdC5kZWNvZGVHZW9tZXRyeShzLmJ1ZmZlciwgaCksIHsKICAgICAgbWV0YWRhdGE6IGwsCiAgICAgIG1ldGFkYXRhOiB7IGRlbHRhSWRzOiBkLCBkZWx0YU5vcm1hbElkczogYyB9CiAgICB9ID0gdTsKICAgIGwuZGVsdGFGcmFtZXMgfHwgKGwuZGVsdGFGcmFtZXMgPSBbXSksIGwuaW50ZXJwb2xhdGVkRnJhbWVzIHx8IChsLmludGVycG9sYXRlZEZyYW1lcyA9IFtdKTsKICAgIGNvbnN0IG0gPSBjICE9PSB2b2lkIDAgJiYgdS5hdHRyaWJ1dGVzW2NdICE9PSB2b2lkIDAsIHkgPSBsLnRpbWVzdGFtcCA/IGwudGltZXN0YW1wLmxlbmd0aCA6IDEsIHggPSBuZXcgQXJyYXkoeSksIHAgPSBsLnRpbWVzdGFtcCA/IGYuZHVyYXRpb24gLyBsLnRpbWVzdGFtcC5sZW5ndGggOiBmLmR1cmF0aW9uOwogICAgbGV0IHosIEY7CiAgICBmb3IgKGxldCBTID0gMDsgUyA8IHk7IFMrKykgewogICAgICBjb25zdCBSID0ge30sIFcgPSBsLnRpbWVzdGFtcCAhPT0gdm9pZCAwID8gbC50aW1lc3RhbXBbU10gOiBuOwogICAgICBpZiAoUyA9PT0gMCkgewogICAgICAgIHUudXNlckRhdGEgPSBSOwogICAgICAgIGNvbnN0IEIgPSB1LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKiBIdDsKICAgICAgICB1LmF0dHJpYnV0ZXMud2VpZ2h0c0F0dCA/IHogPSB1LmF0dHJpYnV0ZXMud2VpZ2h0c0F0dC5jbG9uZSgpIDogKHogPSBuZXcgUSgKICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoQiksCiAgICAgICAgICBIdAogICAgICAgICksIHUuc2V0QXR0cmlidXRlKCJ3ZWlnaHRzQXR0IiwgeikpLCB1LmF0dHJpYnV0ZXMuYmluZGluZ3NBdHQgPyAoRiA9IG5ldyBRKAogICAgICAgICAgRmxvYXQzMkFycmF5LmZyb20odS5hdHRyaWJ1dGVzLmJpbmRpbmdzQXR0LmFycmF5KSwKICAgICAgICAgIEh0CiAgICAgICAgKSwgdS5zZXRBdHRyaWJ1dGUoImJpbmRpbmdzQXR0IiwgRikpIDogKEYgPSBuZXcgUSgKICAgICAgICAgIG5ldyBGbG9hdDMyQXJyYXkoQiksCiAgICAgICAgICBIdAogICAgICAgICksIHUuc2V0QXR0cmlidXRlKCJiaW5kaW5nc0F0dCIsIEYpKSwgeFtTXSA9IHsKICAgICAgICAgIHR5cGU6IHVlLAogICAgICAgICAgdGltZXNjYWxlOiByLAogICAgICAgICAgZ2VvbWV0cnk6IHUsCiAgICAgICAgICB0aW1lc3RhbXA6IFcsCiAgICAgICAgICBkdXJhdGlvbjogcAogICAgICAgIH07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgY29uc3QgUCA9IG5ldyBadCgpOwogICAgICAgIFAuc2V0SW5kZXgodS5pbmRleCksIFAuc2V0QXR0cmlidXRlKCJ1diIsIHUuYXR0cmlidXRlcy51di5jbG9uZSgpKSwgUC5zZXRBdHRyaWJ1dGUoInBvc2l0aW9uIiwgdS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNsb25lKCkpLCB1LmF0dHJpYnV0ZXMubm9ybWFsICYmIFAuc2V0QXR0cmlidXRlKCJub3JtYWwiLCB1LmF0dHJpYnV0ZXMubm9ybWFsLmNsb25lKCkpLCBQLnNldEF0dHJpYnV0ZSgid2VpZ2h0c0F0dCIsIHopLCBQLnNldEF0dHJpYnV0ZSgiYmluZGluZ3NBdHQiLCBGKSwgUC51c2VyRGF0YSA9IFIsIHhbU10gPSB7IGdlb21ldHJ5OiBQLCB0aW1lc3RhbXA6IFcsIGR1cmF0aW9uOiBwIH07CiAgICAgIH0KICAgIH0KICAgIGxldCBBID0gbnVsbCwgYiA9IG51bGwsIE0gPSBudWxsOwogICAgY29uc3QgeyBkZWx0YUZyYW1lczogXywgaW50ZXJwb2xhdGVkRnJhbWVzOiB3IH0gPSBsOwogICAgZm9yIChjb25zdCBTIG9mIF8pCiAgICAgIHhbU10udHlwZSA9IFJ0OwogICAgZm9yIChjb25zdCBTIG9mIHcpCiAgICAgIHhbU10udHlwZSA9IGtlOwogICAgbGV0IEUgPSAwLCBDLCBMID0gMCwgViA9IG51bGw7CiAgICBmb3IgKGxldCBTID0gMDsgUyA8IHgubGVuZ3RoOyBTKyspIHsKICAgICAgaWYgKEEgPSB4W1NdLCBBLnR5cGUgIT09IFJ0KQogICAgICAgIGNvbnRpbnVlOwogICAgICBjb25zdCBSID0gdS5hdHRyaWJ1dGVzW2RbRSsrXV07CiAgICAgIGlmIChDKSB7CiAgICAgICAgY29uc3QgeyBjb3VudDogQiwgaXRlbVNpemU6IHEgfSA9IEEuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjsKICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IEIgKiBxOyBrKyspCiAgICAgICAgICBSLmFycmF5W2tdICs9IEMuYXJyYXlba107CiAgICAgIH0KICAgICAgQS5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoUnQsIFIpOwogICAgICBjb25zdCB7IGNvdW50OiBXLCBpdGVtU2l6ZTogUCB9ID0gQS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uOwogICAgICBmb3IgKGxldCBCID0gMDsgQiA8IFcgKiBQOyBCKyspCiAgICAgICAgQS5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uLmFycmF5W0JdICs9IFIuYXJyYXlbQl07CiAgICAgIGlmIChBLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSAhMCwgQyA9IFIsIG0pIHsKICAgICAgICBjb25zdCBCID0gdS5hdHRyaWJ1dGVzW2NbTCsrXV0sIHsgY291bnQ6IHEsIGl0ZW1TaXplOiBrIH0gPSBBLmdlb21ldHJ5LmF0dHJpYnV0ZXMubm9ybWFsOwogICAgICAgIGlmIChWKQogICAgICAgICAgZm9yIChsZXQgRCA9IDA7IEQgPCBxICogazsgRCsrKQogICAgICAgICAgICBCLmFycmF5W0RdICs9IFYuYXJyYXlbRF07CiAgICAgICAgQS5nZW9tZXRyeS5zZXRBdHRyaWJ1dGUoImRlbHRhTm9ybWFsIiwgQik7CiAgICAgICAgZm9yIChsZXQgRCA9IDA7IEQgPCBxICogazsgRCsrKQogICAgICAgICAgQS5nZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheVtEXSArPSBCLmFycmF5W0RdOwogICAgICAgIEEuZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwubmVlZHNVcGRhdGUgPSAhMCwgViA9IEI7CiAgICAgIH0KICAgIH0KICAgIGZvciAobGV0IFMgPSAwOyBTIDwgeC5sZW5ndGg7IFMrKykKICAgICAgaWYgKEEgPSB4W1NdLCBBLnR5cGUgPT09IGtlKSB7CiAgICAgICAgbGV0IFIgPSAtMSwgVyA9IC0xOwogICAgICAgIGZvciAobGV0IGsgPSBTOyBrIDwgeC5sZW5ndGg7IGsrKykKICAgICAgICAgIGlmIChiID0geFtrXSwgYi50eXBlID09PSBSdCkgewogICAgICAgICAgICBSID0gazsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgZm9yIChsZXQgayA9IFM7IGsgPj0gMDsgay0tKQogICAgICAgICAgaWYgKGIgPSB4W2tdLCBiLnR5cGUgPT09IFJ0IHx8IGIudHlwZSA9PT0gdWUpIHsKICAgICAgICAgICAgVyA9IGs7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgIGNvbnN0IFAgPSBTIC0gVywgQiA9IFIgLSBXLCBxID0gUCAvIEI7CiAgICAgICAgaWYgKGIgPSB4W1ddLCBNID0geFtSXSwgYi50eXBlID09PSB1ZSkgewogICAgICAgICAgY29uc3QgayA9IGIuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiwgRCA9IE0uZ2VvbWV0cnkuYXR0cmlidXRlcy5kZWx0YSwgeyBjb3VudDogYXQsIGl0ZW1TaXplOiBqdCB9ID0gazsKICAgICAgICAgIGZvciAobGV0IEsgPSAwOyBLIDwgYXQgKiBqdDsgSysrKQogICAgICAgICAgICBBLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXlbS10gPSBrLmFycmF5W0tdICsgcSAqIEQuYXJyYXlbS107CiAgICAgICAgICBpZiAobSkgewogICAgICAgICAgICBjb25zdCBLID0gYi5nZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbCwgWSA9IE0uZ2VvbWV0cnkuYXR0cmlidXRlcy5kZWx0YU5vcm1hbCwgeyBjb3VudDogJHQsIGl0ZW1TaXplOiBKdCB9ID0gSzsKICAgICAgICAgICAgZm9yIChsZXQgbXQgPSAwOyBtdCA8ICR0ICogSnQ7IG10KyspCiAgICAgICAgICAgICAgQS5nZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5hcnJheVttdF0gPSBLLmFycmF5W210XSArIHEgKiBZLmFycmF5W210XTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgayA9IHhbMF0uZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbiwgRCA9IGIuZ2VvbWV0cnkuYXR0cmlidXRlcy5kZWx0YSwgYXQgPSBNLmdlb21ldHJ5LmF0dHJpYnV0ZXMuZGVsdGEsIHsgY291bnQ6IGp0LCBpdGVtU2l6ZTogSyB9ID0gRDsKICAgICAgICAgIGZvciAobGV0IFkgPSAwOyBZIDwganQgKiBLOyBZKyspCiAgICAgICAgICAgIEEuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheVtZXSA9IGsuYXJyYXlbWV0gKyBELmFycmF5W1ldICsgcSAqIChhdC5hcnJheVtZXSAtIEQuYXJyYXlbWV0pOwogICAgICAgICAgaWYgKG0pIHsKICAgICAgICAgICAgY29uc3QgWSA9IGIuZ2VvbWV0cnkuYXR0cmlidXRlcy5kZWx0YU5vcm1hbCwgJHQgPSBNLmdlb21ldHJ5LmF0dHJpYnV0ZXMuZGVsdGFOb3JtYWwsIHsgY291bnQ6IEp0LCBpdGVtU2l6ZTogbXQgfSA9IFk7CiAgICAgICAgICAgIGZvciAobGV0IHl0ID0gMDsgeXQgPCBKdCAqIG10OyB5dCsrKQogICAgICAgICAgICAgIEEuZ2VvbWV0cnkuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXlbeXRdID0gay5hcnJheVt5dF0gKyBZLmFycmF5W3l0XSArIHEgKiAoJHQuYXJyYXlbeXRdIC0gWS5hcnJheVt5dF0pOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBBLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24ubmVlZHNVcGRhdGUgPSAhMDsKICAgICAgfQogICAgcmV0dXJuIHg7CiAgfSk7CiAgc2VsZi5vbm1lc3NhZ2UgPSAoZikgPT4gUXQoeWUsIG51bGwsIGZ1bmN0aW9uKiAoKSB7CiAgICBjb25zdCB0ID0geWllbGQgbGkoZi5kYXRhKTsKICAgIHNlbGYucG9zdE1lc3NhZ2UodCB8fCBbXSk7CiAgfSk7Cn0pOwpleHBvcnQgZGVmYXVsdCBjaSgpOwo=", dT = (t) => Uint8Array.from(atob(t), (e) => e.charCodeAt(0)), tC = typeof self != "undefined" && self.Blob && new Blob(["URL.revokeObjectURL(import.meta.url);", dT(jA)], { type: "text/javascript;charset=utf-8" });
function gT(t) {
  let e;
  try {
    if (e = tC && (self.URL || self.webkitURL).createObjectURL(tC), !e) throw "";
    const r = new Worker(e, {
      type: "module",
      name: t == null ? void 0 : t.name
    });
    return r.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(e);
    }), r;
  } catch (r) {
    return new Worker(
      "data:text/javascript;base64," + jA,
      {
        type: "module",
        name: t == null ? void 0 : t.name
      }
    );
  }
}
class cT {
  constructor(e) {
    if (this.numWorkers = 1, this.workers = [], this.currentIndex = 0, this.onmessage = el, this.onerror = el, this.onWorkerMessage = (r) => {
      this.onmessage(r);
    }, this.onWorkerError = (r) => {
      this.onerror(r);
    }, typeof e == "number") {
      if (e < 1)
        throw new Error("numWorkers must be greater than 0");
      this.numWorkers = e;
    }
    this.setupWorkers();
  }
  setupWorkers() {
    const { workers: e, numWorkers: r } = this;
    for (let u = 0; u < r; ++u) {
      const I = new gT();
      e.push(I), I.onmessage = this.onWorkerMessage, I.onerror = this.onWorkerError;
    }
  }
  postMessage(e, r) {
    const { currentIndex: u, numWorkers: I, workers: E } = this;
    E[u].postMessage(e, r);
    const g = (u + 1) % I;
    this.currentIndex = g;
  }
  destroy() {
    for (const e of this.workers)
      e.terminate();
    this.onmessage = el, this.onerror = el, this.workers.length = 0;
  }
}
const ZA = (t, e, r = 0) => {
  for (let u = 0, I = 0, E = 0; u < t.length; u++)
    if (I = t.start(u), E = t.end(u), e >= I - r && e <= E + r)
      return !0;
  return !1;
};
class eC {
  constructor() {
    this.samples = [];
  }
  /**
   * Retrieves the length of the samples array.
   * @return {number} The number of elements in the samples array.
   */
  get length() {
    return this.samples.length;
  }
  /**
   * Clears all elements from the samples array.
   * @return {void} This method does not return a value.
   */
  clear() {
    this.samples.length = 0;
  }
  /**
   * Retrieves the element at the specified index in the samples array.
   * @param {number} index - The zero-based index of the element to retrieve.
   * @return {Sample|undefined} The element at the specified index if it exists, otherwise undefined.
   */
  at(e) {
    return this.samples[e];
  }
  /**
   * Adds a new sample object to the samples array, maintaining the array's sorted order by timestamp.
   * @param {Sample} sample - The sample object to be inserted into the sorted samples array.
   * @return {void} Does not return any value.
   */
  add(e) {
    const r = this.findInsertionPoint(e.timestamp);
    this.samples.splice(r, 0, e);
  }
  /**
   * Retrieves a sample at the specified timestamp, or the nearest timestamp available.
   * @param {number} timestamp - The target timestamp for which the sample is sought.
   * @return {Sample|undefined} The sample at the provided timestamp or the nearest one,
   * or undefined if no valid sample exists.
   */
  getAtTimestamp(e) {
    const { samples: r } = this;
    if (r.length === 0)
      return;
    const u = this.findInsertionPoint(e);
    if (u >= r.length)
      return;
    if (r[u].timestamp === e)
      return r[u];
    if (u === 0)
      return r[0];
    const I = r[u - 1], E = r[u], k = Math.abs(e - I.timestamp), g = Math.abs(e - E.timestamp);
    return k <= g ? I : E;
  }
  /**
   * Removes a range of samples from the collection based on the specified start and end timestamps.
   * @param {number} startTimestamp - The starting timestamp of the range to remove (inclusive).
   * @param {number} endTimestamp - The ending timestamp of the range to remove (inclusive).
   * @return {void} Does not return a value.
   */
  remove(e, r) {
    const { samples: u } = this;
    if (u.length === 0 || e > r)
      return;
    const I = this.findInsertionPoint(e), E = this.findRangeEnd(r);
    I < u.length && E >= 0 && I <= E && u.splice(I, E - I + 1);
  }
  /**
   * Finds the insertion point for a given timestamp using binary search.
   * Returns the index where the timestamp should be inserted to maintain sorted order.
   * Finding the start of a removal range (from the `remove` method).
   * @param {number} timestamp - The timestamp to find the insertion point for.
   * @return {number} The index where the timestamp should be inserted.
   */
  findInsertionPoint(e) {
    const { samples: r } = this;
    let u = 0, I = r.length;
    for (; u < I; ) {
      const E = Math.floor((u + I) / 2);
      r[E].timestamp < e ? u = E + 1 : I = E;
    }
    return u;
  }
  /**
   * Finds the end index for removal range (last element <= endTimestamp).
   * @param {number} endTimestamp - The ending timestamp.
   * @return {number} The end index for removal.
   */
  findRangeEnd(e) {
    const { samples: r } = this;
    let u = 0, I = r.length - 1;
    for (; u <= I; ) {
      const E = Math.floor((u + I) / 2);
      r[E].timestamp <= e ? u = E + 1 : I = E - 1;
    }
    return I;
  }
}
var JA = {};
(function(t) {
  var e = /* @__PURE__ */ function() {
    var n = /* @__PURE__ */ new Date(), o = 4, l = 3, h = 2, p = 1, z = o, Z = {
      setLogLevel: function(V) {
        V == this.debug ? z = p : V == this.info ? z = h : V == this.warn ? z = l : (V == this.error, z = o);
      },
      debug: function(V, Q) {
        console.debug === void 0 && (console.debug = console.log), p >= z && console.debug("[" + e.getDurationString(/* @__PURE__ */ new Date() - n, 1e3) + "]", "[" + V + "]", Q);
      },
      log: function(V, Q) {
        this.debug(V.msg);
      },
      info: function(V, Q) {
        h >= z && console.info("[" + e.getDurationString(/* @__PURE__ */ new Date() - n, 1e3) + "]", "[" + V + "]", Q);
      },
      warn: function(V, Q) {
        l >= z && console.warn("[" + e.getDurationString(/* @__PURE__ */ new Date() - n, 1e3) + "]", "[" + V + "]", Q);
      },
      error: function(V, Q) {
        o >= z && console.error("[" + e.getDurationString(/* @__PURE__ */ new Date() - n, 1e3) + "]", "[" + V + "]", Q);
      }
    };
    return Z;
  }();
  e.getDurationString = function(n, o) {
    var l;
    function h(vt, Lt) {
      for (var zt = "" + vt, X = zt.split("."); X[0].length < Lt; )
        X[0] = "0" + X[0];
      return X.join(".");
    }
    n < 0 ? (l = !0, n = -n) : l = !1;
    var p = o || 1, z = n / p, Z = Math.floor(z / 3600);
    z -= Z * 3600;
    var V = Math.floor(z / 60);
    z -= V * 60;
    var Q = z * 1e3;
    return z = Math.floor(z), Q -= z * 1e3, Q = Math.floor(Q), (l ? "-" : "") + Z + ":" + h(V, 2) + ":" + h(z, 2) + "." + h(Q, 3);
  }, e.printRanges = function(n) {
    var o = n.length;
    if (o > 0) {
      for (var l = "", h = 0; h < o; h++)
        h > 0 && (l += ","), l += "[" + e.getDurationString(n.start(h)) + "," + e.getDurationString(n.end(h)) + "]";
      return l;
    } else
      return "(empty)";
  }, t.Log = e;
  var r = function(n) {
    if (n instanceof ArrayBuffer)
      this.buffer = n, this.dataview = new DataView(n);
    else
      throw "Needs an array buffer";
    this.position = 0;
  };
  r.prototype.getPosition = function() {
    return this.position;
  }, r.prototype.getEndPosition = function() {
    return this.buffer.byteLength;
  }, r.prototype.getLength = function() {
    return this.buffer.byteLength;
  }, r.prototype.seek = function(n) {
    var o = Math.max(0, Math.min(this.buffer.byteLength, n));
    return this.position = isNaN(o) || !isFinite(o) ? 0 : o, !0;
  }, r.prototype.isEos = function() {
    return this.getPosition() >= this.getEndPosition();
  }, r.prototype.readAnyInt = function(n, o) {
    var l = 0;
    if (this.position + n <= this.buffer.byteLength) {
      switch (n) {
        case 1:
          o ? l = this.dataview.getInt8(this.position) : l = this.dataview.getUint8(this.position);
          break;
        case 2:
          o ? l = this.dataview.getInt16(this.position) : l = this.dataview.getUint16(this.position);
          break;
        case 3:
          if (o)
            throw "No method for reading signed 24 bits values";
          l = this.dataview.getUint8(this.position) << 16, l |= this.dataview.getUint8(this.position + 1) << 8, l |= this.dataview.getUint8(this.position + 2);
          break;
        case 4:
          o ? l = this.dataview.getInt32(this.position) : l = this.dataview.getUint32(this.position);
          break;
        case 8:
          if (o)
            throw "No method for reading signed 64 bits values";
          l = this.dataview.getUint32(this.position) << 32, l |= this.dataview.getUint32(this.position + 4);
          break;
        default:
          throw "readInt method not implemented for size: " + n;
      }
      return this.position += n, l;
    } else
      throw "Not enough bytes in buffer";
  }, r.prototype.readUint8 = function() {
    return this.readAnyInt(1, !1);
  }, r.prototype.readUint16 = function() {
    return this.readAnyInt(2, !1);
  }, r.prototype.readUint24 = function() {
    return this.readAnyInt(3, !1);
  }, r.prototype.readUint32 = function() {
    return this.readAnyInt(4, !1);
  }, r.prototype.readUint64 = function() {
    return this.readAnyInt(8, !1);
  }, r.prototype.readString = function(n) {
    if (this.position + n <= this.buffer.byteLength) {
      for (var o = "", l = 0; l < n; l++)
        o += String.fromCharCode(this.readUint8());
      return o;
    } else
      throw "Not enough bytes in buffer";
  }, r.prototype.readCString = function() {
    for (var n = []; ; ) {
      var o = this.readUint8();
      if (o !== 0)
        n.push(o);
      else
        break;
    }
    return String.fromCharCode.apply(null, n);
  }, r.prototype.readInt8 = function() {
    return this.readAnyInt(1, !0);
  }, r.prototype.readInt16 = function() {
    return this.readAnyInt(2, !0);
  }, r.prototype.readInt32 = function() {
    return this.readAnyInt(4, !0);
  }, r.prototype.readInt64 = function() {
    return this.readAnyInt(8, !1);
  }, r.prototype.readUint8Array = function(n) {
    for (var o = new Uint8Array(n), l = 0; l < n; l++)
      o[l] = this.readUint8();
    return o;
  }, r.prototype.readInt16Array = function(n) {
    for (var o = new Int16Array(n), l = 0; l < n; l++)
      o[l] = this.readInt16();
    return o;
  }, r.prototype.readUint16Array = function(n) {
    for (var o = new Int16Array(n), l = 0; l < n; l++)
      o[l] = this.readUint16();
    return o;
  }, r.prototype.readUint32Array = function(n) {
    for (var o = new Uint32Array(n), l = 0; l < n; l++)
      o[l] = this.readUint32();
    return o;
  }, r.prototype.readInt32Array = function(n) {
    for (var o = new Int32Array(n), l = 0; l < n; l++)
      o[l] = this.readInt32();
    return o;
  }, t.MP4BoxStream = r;
  var u = function(n, o, l) {
    this._byteOffset = o || 0, n instanceof ArrayBuffer ? this.buffer = n : typeof n == "object" ? (this.dataView = n, o && (this._byteOffset += o)) : this.buffer = new ArrayBuffer(n || 0), this.position = 0, this.endianness = l == null ? u.LITTLE_ENDIAN : l;
  };
  u.prototype = {}, u.prototype.getPosition = function() {
    return this.position;
  }, u.prototype._realloc = function(n) {
    if (this._dynamicSize) {
      var o = this._byteOffset + this.position + n, l = this._buffer.byteLength;
      if (o <= l) {
        o > this._byteLength && (this._byteLength = o);
        return;
      }
      for (l < 1 && (l = 1); o > l; )
        l *= 2;
      var h = new ArrayBuffer(l), p = new Uint8Array(this._buffer), z = new Uint8Array(h, 0, p.length);
      z.set(p), this.buffer = h, this._byteLength = o;
    }
  }, u.prototype._trimAlloc = function() {
    if (this._byteLength != this._buffer.byteLength) {
      var n = new ArrayBuffer(this._byteLength), o = new Uint8Array(n), l = new Uint8Array(this._buffer, 0, o.length);
      o.set(l), this.buffer = n;
    }
  }, u.BIG_ENDIAN = !1, u.LITTLE_ENDIAN = !0, u.prototype._byteLength = 0, Object.defineProperty(
    u.prototype,
    "byteLength",
    { get: function() {
      return this._byteLength - this._byteOffset;
    } }
  ), Object.defineProperty(
    u.prototype,
    "buffer",
    {
      get: function() {
        return this._trimAlloc(), this._buffer;
      },
      set: function(n) {
        this._buffer = n, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;
      }
    }
  ), Object.defineProperty(
    u.prototype,
    "byteOffset",
    {
      get: function() {
        return this._byteOffset;
      },
      set: function(n) {
        this._byteOffset = n, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;
      }
    }
  ), Object.defineProperty(
    u.prototype,
    "dataView",
    {
      get: function() {
        return this._dataView;
      },
      set: function(n) {
        this._byteOffset = n.byteOffset, this._buffer = n.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + n.byteLength;
      }
    }
  ), u.prototype.seek = function(n) {
    var o = Math.max(0, Math.min(this.byteLength, n));
    this.position = isNaN(o) || !isFinite(o) ? 0 : o;
  }, u.prototype.isEof = function() {
    return this.position >= this._byteLength;
  }, u.prototype.mapUint8Array = function(n) {
    this._realloc(n * 1);
    var o = new Uint8Array(this._buffer, this.byteOffset + this.position, n);
    return this.position += n * 1, o;
  }, u.prototype.readInt32Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 4 : n;
    var l = new Int32Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readInt16Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 2 : n;
    var l = new Int16Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readInt8Array = function(n) {
    n = n == null ? this.byteLength - this.position : n;
    var o = new Int8Array(n);
    return u.memcpy(
      o.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * o.BYTES_PER_ELEMENT
    ), this.position += o.byteLength, o;
  }, u.prototype.readUint32Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 4 : n;
    var l = new Uint32Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readUint16Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 2 : n;
    var l = new Uint16Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readUint8Array = function(n) {
    n = n == null ? this.byteLength - this.position : n;
    var o = new Uint8Array(n);
    return u.memcpy(
      o.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * o.BYTES_PER_ELEMENT
    ), this.position += o.byteLength, o;
  }, u.prototype.readFloat64Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 8 : n;
    var l = new Float64Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readFloat32Array = function(n, o) {
    n = n == null ? this.byteLength - this.position / 4 : n;
    var l = new Float32Array(n);
    return u.memcpy(
      l.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      n * l.BYTES_PER_ELEMENT
    ), u.arrayToNative(l, o == null ? this.endianness : o), this.position += l.byteLength, l;
  }, u.prototype.readInt32 = function(n) {
    var o = this._dataView.getInt32(this.position, n == null ? this.endianness : n);
    return this.position += 4, o;
  }, u.prototype.readInt16 = function(n) {
    var o = this._dataView.getInt16(this.position, n == null ? this.endianness : n);
    return this.position += 2, o;
  }, u.prototype.readInt8 = function() {
    var n = this._dataView.getInt8(this.position);
    return this.position += 1, n;
  }, u.prototype.readUint32 = function(n) {
    var o = this._dataView.getUint32(this.position, n == null ? this.endianness : n);
    return this.position += 4, o;
  }, u.prototype.readUint16 = function(n) {
    var o = this._dataView.getUint16(this.position, n == null ? this.endianness : n);
    return this.position += 2, o;
  }, u.prototype.readUint8 = function() {
    var n = this._dataView.getUint8(this.position);
    return this.position += 1, n;
  }, u.prototype.readFloat32 = function(n) {
    var o = this._dataView.getFloat32(this.position, n == null ? this.endianness : n);
    return this.position += 4, o;
  }, u.prototype.readFloat64 = function(n) {
    var o = this._dataView.getFloat64(this.position, n == null ? this.endianness : n);
    return this.position += 8, o;
  }, u.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0, u.memcpy = function(n, o, l, h, p) {
    var z = new Uint8Array(n, o, p), Z = new Uint8Array(l, h, p);
    z.set(Z);
  }, u.arrayToNative = function(n, o) {
    return o == this.endianness ? n : this.flipArrayEndianness(n);
  }, u.nativeToEndian = function(n, o) {
    return this.endianness == o ? n : this.flipArrayEndianness(n);
  }, u.flipArrayEndianness = function(n) {
    for (var o = new Uint8Array(n.buffer, n.byteOffset, n.byteLength), l = 0; l < n.byteLength; l += n.BYTES_PER_ELEMENT)
      for (var h = l + n.BYTES_PER_ELEMENT - 1, p = l; h > p; h--, p++) {
        var z = o[p];
        o[p] = o[h], o[h] = z;
      }
    return n;
  }, u.prototype.failurePosition = 0, String.fromCharCodeUint8 = function(n) {
    for (var o = [], l = 0; l < n.length; l++)
      o[l] = n[l];
    return String.fromCharCode.apply(null, o);
  }, u.prototype.readString = function(n, o) {
    return o == null || o == "ASCII" ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(n == null ? this.byteLength - this.position : n)]) : new TextDecoder(o).decode(this.mapUint8Array(n));
  }, u.prototype.readCString = function(n) {
    var o = this.byteLength - this.position, l = new Uint8Array(this._buffer, this._byteOffset + this.position), h = o;
    n != null && (h = Math.min(n, o));
    for (var p = 0; p < h && l[p] !== 0; p++) ;
    var z = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(p)]);
    return n != null ? this.position += h - p : p != o && (this.position += 1), z;
  };
  var I = Math.pow(2, 32);
  u.prototype.readInt64 = function() {
    return this.readInt32() * I + this.readUint32();
  }, u.prototype.readUint64 = function() {
    return this.readUint32() * I + this.readUint32();
  }, u.prototype.readInt64 = function() {
    return this.readUint32() * I + this.readUint32();
  }, u.prototype.readUint24 = function() {
    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();
  }, t.DataStream = u, u.prototype.save = function(n) {
    var o = new Blob([this.buffer]);
    if (window.URL && URL.createObjectURL) {
      var l = window.URL.createObjectURL(o), h = document.createElement("a");
      document.body.appendChild(h), h.setAttribute("href", l), h.setAttribute("download", n), h.setAttribute("target", "_self"), h.click(), window.URL.revokeObjectURL(l);
    } else
      throw "DataStream.save: Can't create object URL.";
  }, u.prototype._dynamicSize = !0, Object.defineProperty(
    u.prototype,
    "dynamicSize",
    {
      get: function() {
        return this._dynamicSize;
      },
      set: function(n) {
        n || this._trimAlloc(), this._dynamicSize = n;
      }
    }
  ), u.prototype.shift = function(n) {
    var o = new ArrayBuffer(this._byteLength - n), l = new Uint8Array(o), h = new Uint8Array(this._buffer, n, l.length);
    l.set(h), this.buffer = o, this.position -= n;
  }, u.prototype.writeInt32Array = function(n, o) {
    if (this._realloc(n.length * 4), n instanceof Int32Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapInt32Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeInt32(n[l], o);
  }, u.prototype.writeInt16Array = function(n, o) {
    if (this._realloc(n.length * 2), n instanceof Int16Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapInt16Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeInt16(n[l], o);
  }, u.prototype.writeInt8Array = function(n) {
    if (this._realloc(n.length * 1), n instanceof Int8Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapInt8Array(n.length);
    else
      for (var o = 0; o < n.length; o++)
        this.writeInt8(n[o]);
  }, u.prototype.writeUint32Array = function(n, o) {
    if (this._realloc(n.length * 4), n instanceof Uint32Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapUint32Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeUint32(n[l], o);
  }, u.prototype.writeUint16Array = function(n, o) {
    if (this._realloc(n.length * 2), n instanceof Uint16Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapUint16Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeUint16(n[l], o);
  }, u.prototype.writeUint8Array = function(n) {
    if (this._realloc(n.length * 1), n instanceof Uint8Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapUint8Array(n.length);
    else
      for (var o = 0; o < n.length; o++)
        this.writeUint8(n[o]);
  }, u.prototype.writeFloat64Array = function(n, o) {
    if (this._realloc(n.length * 8), n instanceof Float64Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapFloat64Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeFloat64(n[l], o);
  }, u.prototype.writeFloat32Array = function(n, o) {
    if (this._realloc(n.length * 4), n instanceof Float32Array && this.byteOffset + this.position % n.BYTES_PER_ELEMENT === 0)
      u.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        n.buffer,
        0,
        n.byteLength
      ), this.mapFloat32Array(n.length, o);
    else
      for (var l = 0; l < n.length; l++)
        this.writeFloat32(n[l], o);
  }, u.prototype.writeInt32 = function(n, o) {
    this._realloc(4), this._dataView.setInt32(this.position, n, o == null ? this.endianness : o), this.position += 4;
  }, u.prototype.writeInt16 = function(n, o) {
    this._realloc(2), this._dataView.setInt16(this.position, n, o == null ? this.endianness : o), this.position += 2;
  }, u.prototype.writeInt8 = function(n) {
    this._realloc(1), this._dataView.setInt8(this.position, n), this.position += 1;
  }, u.prototype.writeUint32 = function(n, o) {
    this._realloc(4), this._dataView.setUint32(this.position, n, o == null ? this.endianness : o), this.position += 4;
  }, u.prototype.writeUint16 = function(n, o) {
    this._realloc(2), this._dataView.setUint16(this.position, n, o == null ? this.endianness : o), this.position += 2;
  }, u.prototype.writeUint8 = function(n) {
    this._realloc(1), this._dataView.setUint8(this.position, n), this.position += 1;
  }, u.prototype.writeFloat32 = function(n, o) {
    this._realloc(4), this._dataView.setFloat32(this.position, n, o == null ? this.endianness : o), this.position += 4;
  }, u.prototype.writeFloat64 = function(n, o) {
    this._realloc(8), this._dataView.setFloat64(this.position, n, o == null ? this.endianness : o), this.position += 8;
  }, u.prototype.writeUCS2String = function(n, o, l) {
    l == null && (l = n.length);
    for (var h = 0; h < n.length && h < l; h++)
      this.writeUint16(n.charCodeAt(h), o);
    for (; h < l; h++)
      this.writeUint16(0);
  }, u.prototype.writeString = function(n, o, l) {
    var h = 0;
    if (o == null || o == "ASCII")
      if (l != null) {
        var p = Math.min(n.length, l);
        for (h = 0; h < p; h++)
          this.writeUint8(n.charCodeAt(h));
        for (; h < l; h++)
          this.writeUint8(0);
      } else
        for (h = 0; h < n.length; h++)
          this.writeUint8(n.charCodeAt(h));
    else
      this.writeUint8Array(new TextEncoder(o).encode(n.substring(0, l)));
  }, u.prototype.writeCString = function(n, o) {
    var l = 0;
    if (o != null) {
      var h = Math.min(n.length, o);
      for (l = 0; l < h; l++)
        this.writeUint8(n.charCodeAt(l));
      for (; l < o; l++)
        this.writeUint8(0);
    } else {
      for (l = 0; l < n.length; l++)
        this.writeUint8(n.charCodeAt(l));
      this.writeUint8(0);
    }
  }, u.prototype.writeStruct = function(n, o) {
    for (var l = 0; l < n.length; l += 2) {
      var h = n[l + 1];
      this.writeType(h, o[n[l]], o);
    }
  }, u.prototype.writeType = function(n, o, l) {
    var h;
    if (typeof n == "function")
      return n(this, o);
    if (typeof n == "object" && !(n instanceof Array))
      return n.set(this, o, l);
    var p = null, z = "ASCII", Z = this.position;
    switch (typeof n == "string" && /:/.test(n) && (h = n.split(":"), n = h[0], p = parseInt(h[1])), typeof n == "string" && /,/.test(n) && (h = n.split(","), n = h[0], z = parseInt(h[1])), n) {
      case "uint8":
        this.writeUint8(o);
        break;
      case "int8":
        this.writeInt8(o);
        break;
      case "uint16":
        this.writeUint16(o, this.endianness);
        break;
      case "int16":
        this.writeInt16(o, this.endianness);
        break;
      case "uint32":
        this.writeUint32(o, this.endianness);
        break;
      case "int32":
        this.writeInt32(o, this.endianness);
        break;
      case "float32":
        this.writeFloat32(o, this.endianness);
        break;
      case "float64":
        this.writeFloat64(o, this.endianness);
        break;
      case "uint16be":
        this.writeUint16(o, u.BIG_ENDIAN);
        break;
      case "int16be":
        this.writeInt16(o, u.BIG_ENDIAN);
        break;
      case "uint32be":
        this.writeUint32(o, u.BIG_ENDIAN);
        break;
      case "int32be":
        this.writeInt32(o, u.BIG_ENDIAN);
        break;
      case "float32be":
        this.writeFloat32(o, u.BIG_ENDIAN);
        break;
      case "float64be":
        this.writeFloat64(o, u.BIG_ENDIAN);
        break;
      case "uint16le":
        this.writeUint16(o, u.LITTLE_ENDIAN);
        break;
      case "int16le":
        this.writeInt16(o, u.LITTLE_ENDIAN);
        break;
      case "uint32le":
        this.writeUint32(o, u.LITTLE_ENDIAN);
        break;
      case "int32le":
        this.writeInt32(o, u.LITTLE_ENDIAN);
        break;
      case "float32le":
        this.writeFloat32(o, u.LITTLE_ENDIAN);
        break;
      case "float64le":
        this.writeFloat64(o, u.LITTLE_ENDIAN);
        break;
      case "cstring":
        this.writeCString(o, p);
        break;
      case "string":
        this.writeString(o, z, p);
        break;
      case "u16string":
        this.writeUCS2String(o, this.endianness, p);
        break;
      case "u16stringle":
        this.writeUCS2String(o, u.LITTLE_ENDIAN, p);
        break;
      case "u16stringbe":
        this.writeUCS2String(o, u.BIG_ENDIAN, p);
        break;
      default:
        if (n.length == 3) {
          for (var V = n[1], Q = 0; Q < o.length; Q++)
            this.writeType(V, o[Q]);
          break;
        } else {
          this.writeStruct(n, o);
          break;
        }
    }
    p != null && (this.position = Z, this._realloc(p), this.position = Z + p);
  }, u.prototype.writeUint64 = function(n) {
    var o = Math.floor(n / I);
    this.writeUint32(o), this.writeUint32(n & 4294967295);
  }, u.prototype.writeUint24 = function(n) {
    this.writeUint8((n & 16711680) >> 16), this.writeUint8((n & 65280) >> 8), this.writeUint8(n & 255);
  }, u.prototype.adjustUint32 = function(n, o) {
    var l = this.position;
    this.seek(n), this.writeUint32(o), this.seek(l);
  }, u.prototype.mapInt32Array = function(n, o) {
    this._realloc(n * 4);
    var l = new Int32Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 4, l;
  }, u.prototype.mapInt16Array = function(n, o) {
    this._realloc(n * 2);
    var l = new Int16Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 2, l;
  }, u.prototype.mapInt8Array = function(n) {
    this._realloc(n * 1);
    var o = new Int8Array(this._buffer, this.byteOffset + this.position, n);
    return this.position += n * 1, o;
  }, u.prototype.mapUint32Array = function(n, o) {
    this._realloc(n * 4);
    var l = new Uint32Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 4, l;
  }, u.prototype.mapUint16Array = function(n, o) {
    this._realloc(n * 2);
    var l = new Uint16Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 2, l;
  }, u.prototype.mapFloat64Array = function(n, o) {
    this._realloc(n * 8);
    var l = new Float64Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 8, l;
  }, u.prototype.mapFloat32Array = function(n, o) {
    this._realloc(n * 4);
    var l = new Float32Array(this._buffer, this.byteOffset + this.position, n);
    return u.arrayToNative(l, o == null ? this.endianness : o), this.position += n * 4, l;
  };
  var E = function(n) {
    this.buffers = [], this.bufferIndex = -1, n && (this.insertBuffer(n), this.bufferIndex = 0);
  };
  E.prototype = new u(new ArrayBuffer(), 0, u.BIG_ENDIAN), E.prototype.initialized = function() {
    var n;
    return this.bufferIndex > -1 ? !0 : this.buffers.length > 0 ? (n = this.buffers[0], n.fileStart === 0 ? (this.buffer = n, this.bufferIndex = 0, e.debug("MultiBufferStream", "Stream ready for parsing"), !0) : (e.warn("MultiBufferStream", "The first buffer should have a fileStart of 0"), this.logBufferLevel(), !1)) : (e.warn("MultiBufferStream", "No buffer to start parsing from"), this.logBufferLevel(), !1);
  }, ArrayBuffer.concat = function(n, o) {
    e.debug("ArrayBuffer", "Trying to create a new buffer of size: " + (n.byteLength + o.byteLength));
    var l = new Uint8Array(n.byteLength + o.byteLength);
    return l.set(new Uint8Array(n), 0), l.set(new Uint8Array(o), n.byteLength), l.buffer;
  }, E.prototype.reduceBuffer = function(n, o, l) {
    var h;
    return h = new Uint8Array(l), h.set(new Uint8Array(n, o, l)), h.buffer.fileStart = n.fileStart + o, h.buffer.usedBytes = 0, h.buffer;
  }, E.prototype.insertBuffer = function(n) {
    for (var o = !0, l = 0; l < this.buffers.length; l++) {
      var h = this.buffers[l];
      if (n.fileStart <= h.fileStart) {
        if (n.fileStart === h.fileStart)
          if (n.byteLength > h.byteLength) {
            this.buffers.splice(l, 1), l--;
            continue;
          } else
            e.warn("MultiBufferStream", "Buffer (fileStart: " + n.fileStart + " - Length: " + n.byteLength + ") already appended, ignoring");
        else
          n.fileStart + n.byteLength <= h.fileStart || (n = this.reduceBuffer(n, 0, h.fileStart - n.fileStart)), e.debug("MultiBufferStream", "Appending new buffer (fileStart: " + n.fileStart + " - Length: " + n.byteLength + ")"), this.buffers.splice(l, 0, n), l === 0 && (this.buffer = n);
        o = !1;
        break;
      } else if (n.fileStart < h.fileStart + h.byteLength) {
        var p = h.fileStart + h.byteLength - n.fileStart, z = n.byteLength - p;
        if (z > 0)
          n = this.reduceBuffer(n, p, z);
        else {
          o = !1;
          break;
        }
      }
    }
    o && (e.debug("MultiBufferStream", "Appending new buffer (fileStart: " + n.fileStart + " - Length: " + n.byteLength + ")"), this.buffers.push(n), l === 0 && (this.buffer = n));
  }, E.prototype.logBufferLevel = function(n) {
    var o, l, h, p, z = [], Z, V = "";
    for (h = 0, p = 0, o = 0; o < this.buffers.length; o++)
      l = this.buffers[o], o === 0 ? (Z = {}, z.push(Z), Z.start = l.fileStart, Z.end = l.fileStart + l.byteLength, V += "[" + Z.start + "-") : Z.end === l.fileStart ? Z.end = l.fileStart + l.byteLength : (Z = {}, Z.start = l.fileStart, V += z[z.length - 1].end - 1 + "], [" + Z.start + "-", Z.end = l.fileStart + l.byteLength, z.push(Z)), h += l.usedBytes, p += l.byteLength;
    z.length > 0 && (V += Z.end - 1 + "]");
    var Q = n ? e.info : e.debug;
    this.buffers.length === 0 ? Q("MultiBufferStream", "No more buffer in memory") : Q("MultiBufferStream", "" + this.buffers.length + " stored buffer(s) (" + h + "/" + p + " bytes), continuous ranges: " + V);
  }, E.prototype.cleanBuffers = function() {
    var n, o;
    for (n = 0; n < this.buffers.length; n++)
      o = this.buffers[n], o.usedBytes === o.byteLength && (e.debug("MultiBufferStream", "Removing buffer #" + n), this.buffers.splice(n, 1), n--);
  }, E.prototype.mergeNextBuffer = function() {
    var n;
    if (this.bufferIndex + 1 < this.buffers.length)
      if (n = this.buffers[this.bufferIndex + 1], n.fileStart === this.buffer.fileStart + this.buffer.byteLength) {
        var o = this.buffer.byteLength, l = this.buffer.usedBytes, h = this.buffer.fileStart;
        return this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, n), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = l, this.buffer.fileStart = h, e.debug("ISOFile", "Concatenating buffer for box parsing (length: " + o + "->" + this.buffer.byteLength + ")"), !0;
      } else
        return !1;
    else
      return !1;
  }, E.prototype.findPosition = function(n, o, l) {
    var h, p = null, z = -1;
    for (n === !0 ? h = 0 : h = this.bufferIndex; h < this.buffers.length && (p = this.buffers[h], p.fileStart <= o); ) {
      z = h, l && (p.fileStart + p.byteLength <= o ? p.usedBytes = p.byteLength : p.usedBytes = o - p.fileStart, this.logBufferLevel());
      h++;
    }
    return z !== -1 ? (p = this.buffers[z], p.fileStart + p.byteLength >= o ? (e.debug("MultiBufferStream", "Found position in existing buffer #" + z), z) : -1) : -1;
  }, E.prototype.findEndContiguousBuf = function(n) {
    var o, l, h, p = n !== void 0 ? n : this.bufferIndex;
    if (l = this.buffers[p], this.buffers.length > p + 1)
      for (o = p + 1; o < this.buffers.length && (h = this.buffers[o], h.fileStart === l.fileStart + l.byteLength); o++)
        l = h;
    return l.fileStart + l.byteLength;
  }, E.prototype.getEndFilePositionAfter = function(n) {
    var o = this.findPosition(!0, n, !1);
    return o !== -1 ? this.findEndContiguousBuf(o) : n;
  }, E.prototype.addUsedBytes = function(n) {
    this.buffer.usedBytes += n, this.logBufferLevel();
  }, E.prototype.setAllUsedBytes = function() {
    this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel();
  }, E.prototype.seek = function(n, o, l) {
    var h;
    return h = this.findPosition(o, n, l), h !== -1 ? (this.buffer = this.buffers[h], this.bufferIndex = h, this.position = n - this.buffer.fileStart, e.debug("MultiBufferStream", "Repositioning parser at buffer position: " + this.position), !0) : (e.debug("MultiBufferStream", "Position " + n + " not found in buffered data"), !1);
  }, E.prototype.getPosition = function() {
    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)
      throw "Error accessing position in the MultiBufferStream";
    return this.buffers[this.bufferIndex].fileStart + this.position;
  }, E.prototype.getLength = function() {
    return this.byteLength;
  }, E.prototype.getEndPosition = function() {
    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)
      throw "Error accessing position in the MultiBufferStream";
    return this.buffers[this.bufferIndex].fileStart + this.byteLength;
  }, t.MultiBufferStream = E;
  var k = function() {
    var n = 3, o = 4, l = 5, h = 6, p = [];
    p[n] = "ES_Descriptor", p[o] = "DecoderConfigDescriptor", p[l] = "DecoderSpecificInfo", p[h] = "SLConfigDescriptor", this.getDescriptorName = function(V) {
      return p[V];
    };
    var z = this, Z = {};
    return this.parseOneDescriptor = function(V) {
      var Q = 0, vt, Lt, zt;
      for (vt = V.readUint8(), zt = V.readUint8(); zt & 128; )
        Q = (Q << 7) + (zt & 127), zt = V.readUint8();
      return Q = (Q << 7) + (zt & 127), e.debug("MPEG4DescriptorParser", "Found " + (p[vt] || "Descriptor " + vt) + ", size " + Q + " at position " + V.getPosition()), p[vt] ? Lt = new Z[p[vt]](Q) : Lt = new Z.Descriptor(Q), Lt.parse(V), Lt;
    }, Z.Descriptor = function(V, Q) {
      this.tag = V, this.size = Q, this.descs = [];
    }, Z.Descriptor.prototype.parse = function(V) {
      this.data = V.readUint8Array(this.size);
    }, Z.Descriptor.prototype.findDescriptor = function(V) {
      for (var Q = 0; Q < this.descs.length; Q++)
        if (this.descs[Q].tag == V)
          return this.descs[Q];
      return null;
    }, Z.Descriptor.prototype.parseRemainingDescriptors = function(V) {
      for (var Q = V.position; V.position < Q + this.size; ) {
        var vt = z.parseOneDescriptor(V);
        this.descs.push(vt);
      }
    }, Z.ES_Descriptor = function(V) {
      Z.Descriptor.call(this, n, V);
    }, Z.ES_Descriptor.prototype = new Z.Descriptor(), Z.ES_Descriptor.prototype.parse = function(V) {
      if (this.ES_ID = V.readUint16(), this.flags = V.readUint8(), this.size -= 3, this.flags & 128 ? (this.dependsOn_ES_ID = V.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, this.flags & 64) {
        var Q = V.readUint8();
        this.URL = V.readString(Q), this.size -= Q + 1;
      } else
        this.URL = "";
      this.flags & 32 ? (this.OCR_ES_ID = V.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(V);
    }, Z.ES_Descriptor.prototype.getOTI = function(V) {
      var Q = this.findDescriptor(o);
      return Q ? Q.oti : 0;
    }, Z.ES_Descriptor.prototype.getAudioConfig = function(V) {
      var Q = this.findDescriptor(o);
      if (!Q) return null;
      var vt = Q.findDescriptor(l);
      if (vt && vt.data) {
        var Lt = (vt.data[0] & 248) >> 3;
        return Lt === 31 && vt.data.length >= 2 && (Lt = 32 + ((vt.data[0] & 7) << 3) + ((vt.data[1] & 224) >> 5)), Lt;
      } else
        return null;
    }, Z.DecoderConfigDescriptor = function(V) {
      Z.Descriptor.call(this, o, V);
    }, Z.DecoderConfigDescriptor.prototype = new Z.Descriptor(), Z.DecoderConfigDescriptor.prototype.parse = function(V) {
      this.oti = V.readUint8(), this.streamType = V.readUint8(), this.upStream = (this.streamType >> 1 & 1) !== 0, this.streamType = this.streamType >>> 2, this.bufferSize = V.readUint24(), this.maxBitrate = V.readUint32(), this.avgBitrate = V.readUint32(), this.size -= 13, this.parseRemainingDescriptors(V);
    }, Z.DecoderSpecificInfo = function(V) {
      Z.Descriptor.call(this, l, V);
    }, Z.DecoderSpecificInfo.prototype = new Z.Descriptor(), Z.SLConfigDescriptor = function(V) {
      Z.Descriptor.call(this, h, V);
    }, Z.SLConfigDescriptor.prototype = new Z.Descriptor(), this;
  };
  t.MPEG4DescriptorParser = k;
  var g = {
    ERR_INVALID_DATA: -1,
    ERR_NOT_ENOUGH_DATA: 0,
    OK: 1,
    // Boxes to be created with default parsing
    BASIC_BOXES: [
      { type: "mdat", name: "MediaDataBox" },
      { type: "idat", name: "ItemDataBox" },
      { type: "free", name: "FreeSpaceBox" },
      { type: "skip", name: "FreeSpaceBox" },
      { type: "meco", name: "AdditionalMetadataContainerBox" },
      { type: "strk", name: "SubTrackBox" }
    ],
    FULL_BOXES: [
      { type: "hmhd", name: "HintMediaHeaderBox" },
      { type: "nmhd", name: "NullMediaHeaderBox" },
      { type: "iods", name: "ObjectDescriptorBox" },
      { type: "xml ", name: "XMLBox" },
      { type: "bxml", name: "BinaryXMLBox" },
      { type: "ipro", name: "ItemProtectionBox" },
      { type: "mere", name: "MetaboxRelationBox" }
    ],
    CONTAINER_BOXES: [
      [{ type: "moov", name: "CompressedMovieBox" }, ["trak", "pssh"]],
      [{ type: "trak", name: "TrackBox" }],
      [{ type: "edts", name: "EditBox" }],
      [{ type: "mdia", name: "MediaBox" }],
      [{ type: "minf", name: "MediaInformationBox" }],
      [{ type: "dinf", name: "DataInformationBox" }],
      [{ type: "stbl", name: "SampleTableBox" }, ["sgpd", "sbgp"]],
      [{ type: "mvex", name: "MovieExtendsBox" }, ["trex"]],
      [{ type: "moof", name: "CompressedMovieFragmentBox" }, ["traf"]],
      [{ type: "traf", name: "TrackFragmentBox" }, ["trun", "sgpd", "sbgp"]],
      [{ type: "vttc", name: "VTTCueBox" }],
      [{ type: "tref", name: "TrackReferenceBox" }],
      [{ type: "iref", name: "ItemReferenceBox" }],
      [{ type: "mfra", name: "MovieFragmentRandomAccessBox" }, ["tfra"]],
      [{ type: "meco", name: "AdditionalMetadataContainerBox" }],
      [{ type: "hnti", name: "trackhintinformation" }],
      [{ type: "hinf", name: "hintstatisticsbox" }],
      [{ type: "strk", name: "SubTrackBox" }],
      [{ type: "strd", name: "SubTrackDefinitionBox" }],
      [{ type: "sinf", name: "ProtectionSchemeInfoBox" }],
      [{ type: "rinf", name: "RestrictedSchemeInfoBox" }],
      [{ type: "schi", name: "SchemeInformationBox" }],
      [{ type: "trgr", name: "TrackGroupBox" }],
      [{ type: "udta", name: "UserDataBox" }, ["kind"]],
      [{ type: "iprp", name: "ItemPropertiesBox" }, ["ipma"]],
      [{ type: "ipco", name: "ItemPropertyContainerBox" }],
      [{ type: "grpl", name: "GroupsListBox" }],
      [{ type: "j2kH", name: "J2KHeaderInfoBox" }],
      [{ type: "etyp", name: "ExtendedTypeBox" }, ["tyco"]]
    ],
    // Boxes effectively created
    boxCodes: [],
    fullBoxCodes: [],
    containerBoxCodes: [],
    sampleEntryCodes: {},
    sampleGroupEntryCodes: [],
    trackGroupTypes: [],
    UUIDBoxes: {},
    UUIDs: [],
    initialize: function() {
      g.FullBox.prototype = new g.Box(), g.ContainerBox.prototype = new g.Box(), g.SampleEntry.prototype = new g.Box(), g.TrackGroupTypeBox.prototype = new g.FullBox(), g.BASIC_BOXES.forEach(function(n) {
        g.createBoxCtor(n.type, n.name);
      }), g.FULL_BOXES.forEach(function(n) {
        g.createFullBoxCtor(n.type, n.name);
      }), g.CONTAINER_BOXES.forEach(function(n) {
        g.createContainerBoxCtor(n[0].type, n[0].name, null, n[1]);
      });
    },
    Box: function(n, o, l, h) {
      this.type = n, this.box_name = l, this.size = o, this.uuid = h;
    },
    FullBox: function(n, o, l, h) {
      g.Box.call(this, n, o, l, h), this.flags = 0, this.version = 0;
    },
    ContainerBox: function(n, o, l, h) {
      g.Box.call(this, n, o, l, h), this.boxes = [];
    },
    SampleEntry: function(n, o, l, h) {
      g.ContainerBox.call(this, n, o), this.hdr_size = l, this.start = h;
    },
    SampleGroupEntry: function(n) {
      this.grouping_type = n;
    },
    TrackGroupTypeBox: function(n, o) {
      g.FullBox.call(this, n, o);
    },
    createBoxCtor: function(n, o, l) {
      g.boxCodes.push(n), g[n + "Box"] = function(h) {
        g.Box.call(this, n, h, o);
      }, g[n + "Box"].prototype = new g.Box(), l && (g[n + "Box"].prototype.parse = l);
    },
    createFullBoxCtor: function(n, o, l) {
      g[n + "Box"] = function(h) {
        g.FullBox.call(this, n, h, o);
      }, g[n + "Box"].prototype = new g.FullBox(), g[n + "Box"].prototype.parse = function(h) {
        this.parseFullHeader(h), l && l.call(this, h);
      };
    },
    addSubBoxArrays: function(n) {
      if (n) {
        this.subBoxNames = n;
        for (var o = n.length, l = 0; l < o; l++)
          this[n[l] + "s"] = [];
      }
    },
    createContainerBoxCtor: function(n, o, l, h) {
      g[n + "Box"] = function(p) {
        g.ContainerBox.call(this, n, p, o), g.addSubBoxArrays.call(this, h);
      }, g[n + "Box"].prototype = new g.ContainerBox(), l && (g[n + "Box"].prototype.parse = l);
    },
    createMediaSampleEntryCtor: function(n, o, l) {
      g.sampleEntryCodes[n] = [], g[n + "SampleEntry"] = function(h, p) {
        g.SampleEntry.call(this, h, p), g.addSubBoxArrays.call(this, l);
      }, g[n + "SampleEntry"].prototype = new g.SampleEntry(), o && (g[n + "SampleEntry"].prototype.parse = o);
    },
    createSampleEntryCtor: function(n, o, l, h) {
      g.sampleEntryCodes[n].push(o), g[o + "SampleEntry"] = function(p) {
        g[n + "SampleEntry"].call(this, o, p), g.addSubBoxArrays.call(this, h);
      }, g[o + "SampleEntry"].prototype = new g[n + "SampleEntry"](), l && (g[o + "SampleEntry"].prototype.parse = l);
    },
    createEncryptedSampleEntryCtor: function(n, o, l) {
      g.createSampleEntryCtor.call(this, n, o, l, ["sinf"]);
    },
    createSampleGroupCtor: function(n, o) {
      g[n + "SampleGroupEntry"] = function(l) {
        g.SampleGroupEntry.call(this, n, l);
      }, g[n + "SampleGroupEntry"].prototype = new g.SampleGroupEntry(), o && (g[n + "SampleGroupEntry"].prototype.parse = o);
    },
    createTrackGroupCtor: function(n, o) {
      g[n + "TrackGroupTypeBox"] = function(l) {
        g.TrackGroupTypeBox.call(this, n, l);
      }, g[n + "TrackGroupTypeBox"].prototype = new g.TrackGroupTypeBox(), o && (g[n + "TrackGroupTypeBox"].prototype.parse = o);
    },
    createUUIDBox: function(n, o, l, h, p) {
      g.UUIDs.push(n), g.UUIDBoxes[n] = function(z) {
        l ? g.FullBox.call(this, "uuid", z, o, n) : h ? g.ContainerBox.call(this, "uuid", z, o, n) : g.Box.call(this, "uuid", z, o, n);
      }, g.UUIDBoxes[n].prototype = l ? new g.FullBox() : h ? new g.ContainerBox() : new g.Box(), p && (l ? g.UUIDBoxes[n].prototype.parse = function(z) {
        this.parseFullHeader(z), p && p.call(this, z);
      } : g.UUIDBoxes[n].prototype.parse = p);
    }
  };
  g.initialize(), g.TKHD_FLAG_ENABLED = 1, g.TKHD_FLAG_IN_MOVIE = 2, g.TKHD_FLAG_IN_PREVIEW = 4, g.TFHD_FLAG_BASE_DATA_OFFSET = 1, g.TFHD_FLAG_SAMPLE_DESC = 2, g.TFHD_FLAG_SAMPLE_DUR = 8, g.TFHD_FLAG_SAMPLE_SIZE = 16, g.TFHD_FLAG_SAMPLE_FLAGS = 32, g.TFHD_FLAG_DUR_EMPTY = 65536, g.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, g.TRUN_FLAGS_DATA_OFFSET = 1, g.TRUN_FLAGS_FIRST_FLAG = 4, g.TRUN_FLAGS_DURATION = 256, g.TRUN_FLAGS_SIZE = 512, g.TRUN_FLAGS_FLAGS = 1024, g.TRUN_FLAGS_CTS_OFFSET = 2048, g.Box.prototype.add = function(n) {
    return this.addBox(new g[n + "Box"]());
  }, g.Box.prototype.addBox = function(n) {
    return this.boxes.push(n), this[n.type + "s"] ? this[n.type + "s"].push(n) : this[n.type] = n, n;
  }, g.Box.prototype.set = function(n, o) {
    return this[n] = o, this;
  }, g.Box.prototype.addEntry = function(n, o) {
    var l = o || "entries";
    return this[l] || (this[l] = []), this[l].push(n), this;
  }, t.BoxParser = g, g.parseUUID = function(n) {
    return g.parseHex16(n);
  }, g.parseHex16 = function(n) {
    for (var o = "", l = 0; l < 16; l++) {
      var h = n.readUint8().toString(16);
      o += h.length === 1 ? "0" + h : h;
    }
    return o;
  }, g.parseOneBox = function(n, o, l) {
    var h, p = n.getPosition(), z = 0, Z, V;
    if (n.getEndPosition() - p < 8)
      return e.debug("BoxParser", "Not enough data in stream to parse the type and size of the box"), { code: g.ERR_NOT_ENOUGH_DATA };
    if (l && l < 8)
      return e.debug("BoxParser", "Not enough bytes left in the parent box to parse a new box"), { code: g.ERR_NOT_ENOUGH_DATA };
    var Q = n.readUint32(), vt = n.readString(4), Lt = vt;
    if (e.debug("BoxParser", "Found box of type '" + vt + "' and size " + Q + " at position " + p), z = 8, vt == "uuid") {
      if (n.getEndPosition() - n.getPosition() < 16 || l - z < 16)
        return n.seek(p), e.debug("BoxParser", "Not enough bytes left in the parent box to parse a UUID box"), { code: g.ERR_NOT_ENOUGH_DATA };
      V = g.parseUUID(n), z += 16, Lt = V;
    }
    if (Q == 1) {
      if (n.getEndPosition() - n.getPosition() < 8 || l && l - z < 8)
        return n.seek(p), e.warn("BoxParser", 'Not enough data in stream to parse the extended size of the "' + vt + '" box'), { code: g.ERR_NOT_ENOUGH_DATA };
      Q = n.readUint64(), z += 8;
    } else if (Q === 0) {
      if (l)
        Q = l;
      else if (vt !== "mdat")
        return e.error("BoxParser", "Unlimited box size not supported for type: '" + vt + "'"), h = new g.Box(vt, Q), { code: g.OK, box: h, size: h.size };
    }
    return Q !== 0 && Q < z ? (e.error("BoxParser", "Box of type " + vt + " has an invalid size " + Q + " (too small to be a box)"), { code: g.ERR_NOT_ENOUGH_DATA, type: vt, size: Q, hdr_size: z, start: p }) : Q !== 0 && l && Q > l ? (e.error("BoxParser", "Box of type '" + vt + "' has a size " + Q + " greater than its container size " + l), { code: g.ERR_NOT_ENOUGH_DATA, type: vt, size: Q, hdr_size: z, start: p }) : Q !== 0 && p + Q > n.getEndPosition() ? (n.seek(p), e.info("BoxParser", "Not enough data in stream to parse the entire '" + vt + "' box"), { code: g.ERR_NOT_ENOUGH_DATA, type: vt, size: Q, hdr_size: z, start: p }) : o ? { code: g.OK, type: vt, size: Q, hdr_size: z, start: p } : (g[vt + "Box"] ? h = new g[vt + "Box"](Q) : vt !== "uuid" ? (e.warn("BoxParser", "Unknown box type: '" + vt + "'"), h = new g.Box(vt, Q), h.has_unparsed_data = !0) : g.UUIDBoxes[V] ? h = new g.UUIDBoxes[V](Q) : (e.warn("BoxParser", "Unknown uuid type: '" + V + "'"), h = new g.Box(vt, Q), h.uuid = V, h.has_unparsed_data = !0), h.hdr_size = z, h.start = p, h.write === g.Box.prototype.write && h.type !== "mdat" && (e.info("BoxParser", "'" + Lt + "' box writing not yet implemented, keeping unparsed data in memory for later write"), h.parseDataAndRewind(n)), h.parse(n), Z = n.getPosition() - (h.start + h.size), Z < 0 ? (e.warn("BoxParser", "Parsing of box '" + Lt + "' did not read the entire indicated box data size (missing " + -Z + " bytes), seeking forward"), n.seek(h.start + h.size)) : Z > 0 && (e.error("BoxParser", "Parsing of box '" + Lt + "' read " + Z + " more bytes than the indicated box data size, seeking backwards"), h.size !== 0 && n.seek(h.start + h.size)), { code: g.OK, box: h, size: h.size });
  }, g.Box.prototype.parse = function(n) {
    this.type != "mdat" ? this.data = n.readUint8Array(this.size - this.hdr_size) : this.size === 0 ? n.seek(n.getEndPosition()) : n.seek(this.start + this.size);
  }, g.Box.prototype.parseDataAndRewind = function(n) {
    this.data = n.readUint8Array(this.size - this.hdr_size), n.position -= this.size - this.hdr_size;
  }, g.FullBox.prototype.parseDataAndRewind = function(n) {
    this.parseFullHeader(n), this.data = n.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, n.position -= this.size - this.hdr_size;
  }, g.FullBox.prototype.parseFullHeader = function(n) {
    this.version = n.readUint8(), this.flags = n.readUint24(), this.hdr_size += 4;
  }, g.FullBox.prototype.parse = function(n) {
    this.parseFullHeader(n), this.data = n.readUint8Array(this.size - this.hdr_size);
  }, g.ContainerBox.prototype.parse = function(n) {
    for (var o, l; n.getPosition() < this.start + this.size; )
      if (o = g.parseOneBox(n, !1, this.size - (n.getPosition() - this.start)), o.code === g.OK)
        if (l = o.box, this.boxes.push(l), this.subBoxNames && this.subBoxNames.indexOf(l.type) != -1)
          this[this.subBoxNames[this.subBoxNames.indexOf(l.type)] + "s"].push(l);
        else {
          var h = l.type !== "uuid" ? l.type : l.uuid;
          this[h] ? e.warn("Box of type " + h + " already stored in field of this type") : this[h] = l;
        }
      else
        return;
  }, g.Box.prototype.parseLanguage = function(n) {
    this.language = n.readUint16();
    var o = [];
    o[0] = this.language >> 10 & 31, o[1] = this.language >> 5 & 31, o[2] = this.language & 31, this.languageString = String.fromCharCode(o[0] + 96, o[1] + 96, o[2] + 96);
  }, g.SAMPLE_ENTRY_TYPE_VISUAL = "Visual", g.SAMPLE_ENTRY_TYPE_AUDIO = "Audio", g.SAMPLE_ENTRY_TYPE_HINT = "Hint", g.SAMPLE_ENTRY_TYPE_METADATA = "Metadata", g.SAMPLE_ENTRY_TYPE_SUBTITLE = "Subtitle", g.SAMPLE_ENTRY_TYPE_SYSTEM = "System", g.SAMPLE_ENTRY_TYPE_TEXT = "Text", g.SampleEntry.prototype.parseHeader = function(n) {
    n.readUint8Array(6), this.data_reference_index = n.readUint16(), this.hdr_size += 8;
  }, g.SampleEntry.prototype.parse = function(n) {
    this.parseHeader(n), this.data = n.readUint8Array(this.size - this.hdr_size);
  }, g.SampleEntry.prototype.parseDataAndRewind = function(n) {
    this.parseHeader(n), this.data = n.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, n.position -= this.size - this.hdr_size;
  }, g.SampleEntry.prototype.parseFooter = function(n) {
    g.ContainerBox.prototype.parse.call(this, n);
  }, g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_HINT), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_METADATA), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SYSTEM), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_TEXT), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, function(n) {
    var o;
    this.parseHeader(n), n.readUint16(), n.readUint16(), n.readUint32Array(3), this.width = n.readUint16(), this.height = n.readUint16(), this.horizresolution = n.readUint32(), this.vertresolution = n.readUint32(), n.readUint32(), this.frame_count = n.readUint16(), o = Math.min(31, n.readUint8()), this.compressorname = n.readString(o), o < 31 && n.readString(31 - o), this.depth = n.readUint16(), n.readUint16(), this.parseFooter(n);
  }), g.createMediaSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, function(n) {
    this.parseHeader(n), n.readUint32Array(2), this.channel_count = n.readUint16(), this.samplesize = n.readUint16(), n.readUint16(), n.readUint16(), this.samplerate = n.readUint32() / 65536, this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "avc1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "avc2"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "avc3"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "avc4"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "av01"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "dav1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "hvc1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "hev1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "hvt1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "lhe1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "dvh1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "dvhe"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vvc1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vvi1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vvs1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vvcN"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vp08"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "vp09"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "avs3"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "j2ki"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "mjp2"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "mjpg"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "uncv"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "mp4a"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "ac-3"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "ac-4"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "ec-3"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "Opus"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "mha1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "mha2"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "mhm1"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "mhm2"), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "fLaC"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_VISUAL, "encv"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_AUDIO, "enca"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE, "encu"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SYSTEM, "encs"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_TEXT, "enct"), g.createEncryptedSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_METADATA, "encm"), g.createBoxCtor("a1lx", "AV1LayeredImageIndexingProperty", function(n) {
    var o = n.readUint8() & 1, l = ((o & 1) + 1) * 16;
    this.layer_size = [];
    for (var h = 0; h < 3; h++)
      l == 16 ? this.layer_size[h] = n.readUint16() : this.layer_size[h] = n.readUint32();
  }), g.createBoxCtor("a1op", "OperatingPointSelectorProperty", function(n) {
    this.op_index = n.readUint8();
  }), g.createFullBoxCtor("auxC", "AuxiliaryTypeProperty", function(n) {
    this.aux_type = n.readCString();
    var o = this.size - this.hdr_size - (this.aux_type.length + 1);
    this.aux_subtype = n.readUint8Array(o);
  }), g.createBoxCtor("av1C", "AV1CodecConfigurationBox", function(n) {
    var o = n.readUint8();
    if ((o >> 7 & 1) !== 1) {
      e.error("av1C marker problem");
      return;
    }
    if (this.version = o & 127, this.version !== 1) {
      e.error("av1C version " + this.version + " not supported");
      return;
    }
    if (o = n.readUint8(), this.seq_profile = o >> 5 & 7, this.seq_level_idx_0 = o & 31, o = n.readUint8(), this.seq_tier_0 = o >> 7 & 1, this.high_bitdepth = o >> 6 & 1, this.twelve_bit = o >> 5 & 1, this.monochrome = o >> 4 & 1, this.chroma_subsampling_x = o >> 3 & 1, this.chroma_subsampling_y = o >> 2 & 1, this.chroma_sample_position = o & 3, o = n.readUint8(), this.reserved_1 = o >> 5 & 7, this.reserved_1 !== 0) {
      e.error("av1C reserved_1 parsing problem");
      return;
    }
    if (this.initial_presentation_delay_present = o >> 4 & 1, this.initial_presentation_delay_present === 1)
      this.initial_presentation_delay_minus_one = o & 15;
    else if (this.reserved_2 = o & 15, this.reserved_2 !== 0) {
      e.error("av1C reserved_2 parsing problem");
      return;
    }
    var l = this.size - this.hdr_size - 4;
    this.configOBUs = n.readUint8Array(l);
  });
  function w(n) {
    var o = "<table class='inner-table'>";
    o += "<thead><tr><th>length</th><th>nalu_data</th></tr></thead>", o += "<tbody>";
    for (var l = 0; l < n.length; l++) {
      var h = n[l];
      o += "<tr>", o += "<td>" + h.length + "</td>", o += "<td>", o += h.nalu.reduce(function(p, z) {
        return p + z.toString(16).padStart(2, "0");
      }, "0x"), o += "</td></tr>";
    }
    return o += "</tbody></table>", o;
  }
  g.createBoxCtor("avcC", "AVCConfigurationBox", function(n) {
    var o, l;
    for (this.configurationVersion = n.readUint8(), this.AVCProfileIndication = n.readUint8(), this.profile_compatibility = n.readUint8(), this.AVCLevelIndication = n.readUint8(), this.lengthSizeMinusOne = n.readUint8() & 3, this.nb_SPS_nalus = n.readUint8() & 31, l = this.size - this.hdr_size - 6, this.SPS = [], this.SPS.toString = function() {
      return w(this);
    }, o = 0; o < this.nb_SPS_nalus; o++)
      this.SPS[o] = {}, this.SPS[o].length = n.readUint16(), this.SPS[o].nalu = n.readUint8Array(this.SPS[o].length), l -= 2 + this.SPS[o].length;
    for (this.nb_PPS_nalus = n.readUint8(), l--, this.PPS = [], this.PPS.toString = function() {
      return w(this);
    }, o = 0; o < this.nb_PPS_nalus; o++)
      this.PPS[o] = {}, this.PPS[o].length = n.readUint16(), this.PPS[o].nalu = n.readUint8Array(this.PPS[o].length), l -= 2 + this.PPS[o].length;
    l > 0 && (this.ext = n.readUint8Array(l));
  }), g.createBoxCtor("btrt", "BitRateBox", function(n) {
    this.bufferSizeDB = n.readUint32(), this.maxBitrate = n.readUint32(), this.avgBitrate = n.readUint32();
  }), g.createFullBoxCtor("ccst", "CodingConstraintsBox", function(n) {
    var o = n.readUint8();
    this.all_ref_pics_intra = (o & 128) == 128, this.intra_pred_used = (o & 64) == 64, this.max_ref_per_pic = (o & 63) >> 2, n.readUint24();
  }), g.createBoxCtor("cdef", "ComponentDefinitionBox", function(n) {
    var o;
    for (this.channel_count = n.readUint16(), this.channel_indexes = [], this.channel_types = [], this.channel_associations = [], o = 0; o < this.channel_count; o++)
      this.channel_indexes.push(n.readUint16()), this.channel_types.push(n.readUint16()), this.channel_associations.push(n.readUint16());
  }), g.createBoxCtor("clap", "CleanApertureBox", function(n) {
    this.cleanApertureWidthN = n.readUint32(), this.cleanApertureWidthD = n.readUint32(), this.cleanApertureHeightN = n.readUint32(), this.cleanApertureHeightD = n.readUint32(), this.horizOffN = n.readUint32(), this.horizOffD = n.readUint32(), this.vertOffN = n.readUint32(), this.vertOffD = n.readUint32();
  }), g.createBoxCtor("clli", "ContentLightLevelBox", function(n) {
    this.max_content_light_level = n.readUint16(), this.max_pic_average_light_level = n.readUint16();
  }), g.createFullBoxCtor("cmex", "CameraExtrinsicMatrixProperty", function(n) {
    this.flags & 1 && (this.pos_x = n.readInt32()), this.flags & 2 && (this.pos_y = n.readInt32()), this.flags & 4 && (this.pos_z = n.readInt32()), this.flags & 8 && (this.version == 0 ? this.flags & 16 ? (this.quat_x = n.readInt32(), this.quat_y = n.readInt32(), this.quat_z = n.readInt32()) : (this.quat_x = n.readInt16(), this.quat_y = n.readInt16(), this.quat_z = n.readInt16()) : this.version == 1), this.flags & 32 && (this.id = n.readUint32());
  }), g.createFullBoxCtor("cmin", "CameraIntrinsicMatrixProperty", function(n) {
    this.focal_length_x = n.readInt32(), this.principal_point_x = n.readInt32(), this.principal_point_y = n.readInt32(), this.flags & 1 && (this.focal_length_y = n.readInt32(), this.skew_factor = n.readInt32());
  }), g.createBoxCtor("cmpd", "ComponentDefinitionBox", function(n) {
    for (this.component_count = n.readUint32(), this.component_types = [], this.component_type_urls = [], i = 0; i < this.component_count; i++) {
      var o = n.readUint16();
      this.component_types.push(o), o >= 32768 && this.component_type_urls.push(n.readCString());
    }
  }), g.createFullBoxCtor("co64", "ChunkLargeOffsetBox", function(n) {
    var o, l;
    if (o = n.readUint32(), this.chunk_offsets = [], this.version === 0)
      for (l = 0; l < o; l++)
        this.chunk_offsets.push(n.readUint64());
  }), g.createFullBoxCtor("CoLL", "ContentLightLevelBox", function(n) {
    this.maxCLL = n.readUint16(), this.maxFALL = n.readUint16();
  }), g.createBoxCtor("colr", "ColourInformationBox", function(n) {
    if (this.colour_type = n.readString(4), this.colour_type === "nclx") {
      this.colour_primaries = n.readUint16(), this.transfer_characteristics = n.readUint16(), this.matrix_coefficients = n.readUint16();
      var o = n.readUint8();
      this.full_range_flag = o >> 7;
    } else this.colour_type === "rICC" ? this.ICC_profile = n.readUint8Array(this.size - 4) : this.colour_type === "prof" && (this.ICC_profile = n.readUint8Array(this.size - 4));
  }), g.createFullBoxCtor("cprt", "CopyrightBox", function(n) {
    this.parseLanguage(n), this.notice = n.readCString();
  }), g.createFullBoxCtor("cslg", "CompositionToDecodeBox", function(n) {
    this.version === 0 && (this.compositionToDTSShift = n.readInt32(), this.leastDecodeToDisplayDelta = n.readInt32(), this.greatestDecodeToDisplayDelta = n.readInt32(), this.compositionStartTime = n.readInt32(), this.compositionEndTime = n.readInt32());
  }), g.createFullBoxCtor("ctts", "CompositionOffsetBox", function(n) {
    var o, l;
    if (o = n.readUint32(), this.sample_counts = [], this.sample_offsets = [], this.version === 0)
      for (l = 0; l < o; l++) {
        this.sample_counts.push(n.readUint32());
        var h = n.readInt32();
        h < 0 && e.warn("BoxParser", "ctts box uses negative values without using version 1"), this.sample_offsets.push(h);
      }
    else if (this.version == 1)
      for (l = 0; l < o; l++)
        this.sample_counts.push(n.readUint32()), this.sample_offsets.push(n.readInt32());
  }), g.createBoxCtor("dac3", "AC3SpecificBox", function(n) {
    var o = n.readUint8(), l = n.readUint8(), h = n.readUint8();
    this.fscod = o >> 6, this.bsid = o >> 1 & 31, this.bsmod = (o & 1) << 2 | l >> 6 & 3, this.acmod = l >> 3 & 7, this.lfeon = l >> 2 & 1, this.bit_rate_code = l & 3 | h >> 5 & 7;
  }), g.createBoxCtor("dec3", "EC3SpecificBox", function(n) {
    var o = n.readUint16();
    this.data_rate = o >> 3, this.num_ind_sub = o & 7, this.ind_subs = [];
    for (var l = 0; l < this.num_ind_sub + 1; l++) {
      var h = {};
      this.ind_subs.push(h);
      var p = n.readUint8(), z = n.readUint8(), Z = n.readUint8();
      h.fscod = p >> 6, h.bsid = p >> 1 & 31, h.bsmod = (p & 1) << 4 | z >> 4 & 15, h.acmod = z >> 1 & 7, h.lfeon = z & 1, h.num_dep_sub = Z >> 1 & 15, h.num_dep_sub > 0 && (h.chan_loc = (Z & 1) << 8 | n.readUint8());
    }
  }), g.createFullBoxCtor("dfLa", "FLACSpecificBox", function(n) {
    var o = 127, l = 128, h = [], p = [
      "STREAMINFO",
      "PADDING",
      "APPLICATION",
      "SEEKTABLE",
      "VORBIS_COMMENT",
      "CUESHEET",
      "PICTURE",
      "RESERVED"
    ];
    do {
      var z = n.readUint8(), Z = Math.min(
        z & o,
        p.length - 1
      );
      if (Z ? n.readUint8Array(n.readUint24()) : (n.readUint8Array(13), this.samplerate = n.readUint32() >> 12, n.readUint8Array(20)), h.push(p[Z]), z & l)
        break;
    } while (!0);
    this.numMetadataBlocks = h.length + " (" + h.join(", ") + ")";
  }), g.createBoxCtor("dimm", "hintimmediateBytesSent", function(n) {
    this.bytessent = n.readUint64();
  }), g.createBoxCtor("dmax", "hintlongestpacket", function(n) {
    this.time = n.readUint32();
  }), g.createBoxCtor("dmed", "hintmediaBytesSent", function(n) {
    this.bytessent = n.readUint64();
  }), g.createBoxCtor("dOps", "OpusSpecificBox", function(n) {
    if (this.Version = n.readUint8(), this.OutputChannelCount = n.readUint8(), this.PreSkip = n.readUint16(), this.InputSampleRate = n.readUint32(), this.OutputGain = n.readInt16(), this.ChannelMappingFamily = n.readUint8(), this.ChannelMappingFamily !== 0) {
      this.StreamCount = n.readUint8(), this.CoupledCount = n.readUint8(), this.ChannelMapping = [];
      for (var o = 0; o < this.OutputChannelCount; o++)
        this.ChannelMapping[o] = n.readUint8();
    }
  }), g.createFullBoxCtor("dref", "DataReferenceBox", function(n) {
    var o, l;
    this.entries = [];
    for (var h = n.readUint32(), p = 0; p < h; p++)
      if (o = g.parseOneBox(n, !1, this.size - (n.getPosition() - this.start)), o.code === g.OK)
        l = o.box, this.entries.push(l);
      else
        return;
  }), g.createBoxCtor("drep", "hintrepeatedBytesSent", function(n) {
    this.bytessent = n.readUint64();
  }), g.createFullBoxCtor("elng", "ExtendedLanguageBox", function(n) {
    this.extended_language = n.readString(this.size - this.hdr_size);
  }), g.createFullBoxCtor("elst", "EditListBox", function(n) {
    this.entries = [];
    for (var o = n.readUint32(), l = 0; l < o; l++) {
      var h = {};
      this.entries.push(h), this.version === 1 ? (h.segment_duration = n.readUint64(), h.media_time = n.readInt64()) : (h.segment_duration = n.readUint32(), h.media_time = n.readInt32()), h.media_rate_integer = n.readInt16(), h.media_rate_fraction = n.readInt16();
    }
  }), g.createFullBoxCtor("emsg", "EventMessageBox", function(n) {
    this.version == 1 ? (this.timescale = n.readUint32(), this.presentation_time = n.readUint64(), this.event_duration = n.readUint32(), this.id = n.readUint32(), this.scheme_id_uri = n.readCString(), this.value = n.readCString()) : (this.scheme_id_uri = n.readCString(), this.value = n.readCString(), this.timescale = n.readUint32(), this.presentation_time_delta = n.readUint32(), this.event_duration = n.readUint32(), this.id = n.readUint32());
    var o = this.size - this.hdr_size - (4 * 4 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));
    this.version == 1 && (o -= 4), this.message_data = n.readUint8Array(o);
  }), g.createEntityToGroupCtor = function(n, o) {
    g[n + "Box"] = function(l) {
      g.FullBox.call(this, n, l);
    }, g[n + "Box"].prototype = new g.FullBox(), g[n + "Box"].prototype.parse = function(l) {
      if (this.parseFullHeader(l), o)
        o.call(this, l);
      else
        for (this.group_id = l.readUint32(), this.num_entities_in_group = l.readUint32(), this.entity_ids = [], i = 0; i < this.num_entities_in_group; i++) {
          var h = l.readUint32();
          this.entity_ids.push(h);
        }
    };
  }, g.createEntityToGroupCtor("aebr"), g.createEntityToGroupCtor("afbr"), g.createEntityToGroupCtor("albc"), g.createEntityToGroupCtor("altr"), g.createEntityToGroupCtor("brst"), g.createEntityToGroupCtor("dobr"), g.createEntityToGroupCtor("eqiv"), g.createEntityToGroupCtor("favc"), g.createEntityToGroupCtor("fobr"), g.createEntityToGroupCtor("iaug"), g.createEntityToGroupCtor("pano"), g.createEntityToGroupCtor("slid"), g.createEntityToGroupCtor("ster"), g.createEntityToGroupCtor("tsyn"), g.createEntityToGroupCtor("wbbr"), g.createEntityToGroupCtor("prgr"), g.createEntityToGroupCtor("pymd", function(n) {
    this.group_id = n.readUint32(), this.num_entities_in_group = n.readUint32(), this.entity_ids = [];
    for (var o = 0; o < this.num_entities_in_group; o++) {
      var l = n.readUint32();
      this.entity_ids.push(l);
    }
    for (this.tile_size_x = n.readUint16(), this.tile_size_y = n.readUint16(), this.layer_binning = [], this.tiles_in_layer_column_minus1 = [], this.tiles_in_layer_row_minus1 = [], o = 0; o < this.num_entities_in_group; o++)
      this.layer_binning[o] = n.readUint16(), this.tiles_in_layer_row_minus1[o] = n.readUint16(), this.tiles_in_layer_column_minus1[o] = n.readUint16();
  }), g.createFullBoxCtor("esds", "ElementaryStreamDescriptorBox", function(n) {
    var o = n.readUint8Array(this.size - this.hdr_size);
    if (typeof k != "undefined") {
      var l = new k();
      this.esd = l.parseOneDescriptor(new u(o.buffer, 0, u.BIG_ENDIAN));
    }
  }), g.createBoxCtor("fiel", "FieldHandlingBox", function(n) {
    this.fieldCount = n.readUint8(), this.fieldOrdering = n.readUint8();
  }), g.createBoxCtor("frma", "OriginalFormatBox", function(n) {
    this.data_format = n.readString(4);
  }), g.createBoxCtor("ftyp", "FileTypeBox", function(n) {
    var o = this.size - this.hdr_size;
    this.major_brand = n.readString(4), this.minor_version = n.readUint32(), o -= 8, this.compatible_brands = [];
    for (var l = 0; o >= 4; )
      this.compatible_brands[l] = n.readString(4), o -= 4, l++;
  }), g.createFullBoxCtor("hdlr", "HandlerBox", function(n) {
    this.version === 0 && (n.readUint32(), this.handler = n.readString(4), n.readUint32Array(3), this.name = n.readString(this.size - this.hdr_size - 20), this.name[this.name.length - 1] === "\0" && (this.name = this.name.slice(0, -1)));
  }), g.createBoxCtor("hvcC", "HEVCConfigurationBox", function(n) {
    var o, l, h, p;
    this.configurationVersion = n.readUint8(), p = n.readUint8(), this.general_profile_space = p >> 6, this.general_tier_flag = (p & 32) >> 5, this.general_profile_idc = p & 31, this.general_profile_compatibility = n.readUint32(), this.general_constraint_indicator = n.readUint8Array(6), this.general_level_idc = n.readUint8(), this.min_spatial_segmentation_idc = n.readUint16() & 4095, this.parallelismType = n.readUint8() & 3, this.chroma_format_idc = n.readUint8() & 3, this.bit_depth_luma_minus8 = n.readUint8() & 7, this.bit_depth_chroma_minus8 = n.readUint8() & 7, this.avgFrameRate = n.readUint16(), p = n.readUint8(), this.constantFrameRate = p >> 6, this.numTemporalLayers = (p & 13) >> 3, this.temporalIdNested = (p & 4) >> 2, this.lengthSizeMinusOne = p & 3, this.nalu_arrays = [], this.nalu_arrays.toString = function() {
      var vt = "<table class='inner-table'>";
      vt += "<thead><tr><th>completeness</th><th>nalu_type</th><th>nalu_data</th></tr></thead>", vt += "<tbody>";
      for (var Lt = 0; Lt < this.length; Lt++) {
        var zt = this[Lt];
        vt += "<tr>", vt += "<td rowspan='" + zt.length + "'>" + zt.completeness + "</td>", vt += "<td rowspan='" + zt.length + "'>" + zt.nalu_type + "</td>";
        for (var X = 0; X < zt.length; X++) {
          var D = zt[X];
          X !== 0 && (vt += "<tr>"), vt += "<td>", vt += D.data.reduce(function(yt, Mt) {
            return yt + Mt.toString(16).padStart(2, "0");
          }, "0x"), vt += "</td></tr>";
        }
      }
      return vt += "</tbody></table>", vt;
    };
    var z = n.readUint8();
    for (o = 0; o < z; o++) {
      var Z = [];
      this.nalu_arrays.push(Z), p = n.readUint8(), Z.completeness = (p & 128) >> 7, Z.nalu_type = p & 63;
      var V = n.readUint16();
      for (l = 0; l < V; l++) {
        var Q = {};
        Z.push(Q), h = n.readUint16(), Q.data = n.readUint8Array(h);
      }
    }
  }), g.createFullBoxCtor("iinf", "ItemInfoBox", function(n) {
    var o;
    this.version === 0 ? this.entry_count = n.readUint16() : this.entry_count = n.readUint32(), this.item_infos = [];
    for (var l = 0; l < this.entry_count; l++)
      if (o = g.parseOneBox(n, !1, this.size - (n.getPosition() - this.start)), o.code === g.OK)
        o.box.type !== "infe" && e.error("BoxParser", "Expected 'infe' box, got " + o.box.type), this.item_infos[l] = o.box;
      else
        return;
  }), g.createFullBoxCtor("iloc", "ItemLocationBox", function(n) {
    var o;
    o = n.readUint8(), this.offset_size = o >> 4 & 15, this.length_size = o & 15, o = n.readUint8(), this.base_offset_size = o >> 4 & 15, this.version === 1 || this.version === 2 ? this.index_size = o & 15 : this.index_size = 0, this.items = [];
    var l = 0;
    if (this.version < 2)
      l = n.readUint16();
    else if (this.version === 2)
      l = n.readUint32();
    else
      throw "version of iloc box not supported";
    for (var h = 0; h < l; h++) {
      var p = {};
      if (this.items.push(p), this.version < 2)
        p.item_ID = n.readUint16();
      else if (this.version === 2)
        p.item_ID = n.readUint32();
      else
        throw "version of iloc box not supported";
      switch (this.version === 1 || this.version === 2 ? p.construction_method = n.readUint16() & 15 : p.construction_method = 0, p.data_reference_index = n.readUint16(), this.base_offset_size) {
        case 0:
          p.base_offset = 0;
          break;
        case 4:
          p.base_offset = n.readUint32();
          break;
        case 8:
          p.base_offset = n.readUint64();
          break;
        default:
          throw "Error reading base offset size";
      }
      var z = n.readUint16();
      p.extents = [];
      for (var Z = 0; Z < z; Z++) {
        var V = {};
        if (p.extents.push(V), this.version === 1 || this.version === 2)
          switch (this.index_size) {
            case 0:
              V.extent_index = 0;
              break;
            case 4:
              V.extent_index = n.readUint32();
              break;
            case 8:
              V.extent_index = n.readUint64();
              break;
            default:
              throw "Error reading extent index";
          }
        switch (this.offset_size) {
          case 0:
            V.extent_offset = 0;
            break;
          case 4:
            V.extent_offset = n.readUint32();
            break;
          case 8:
            V.extent_offset = n.readUint64();
            break;
          default:
            throw "Error reading extent index";
        }
        switch (this.length_size) {
          case 0:
            V.extent_length = 0;
            break;
          case 4:
            V.extent_length = n.readUint32();
            break;
          case 8:
            V.extent_length = n.readUint64();
            break;
          default:
            throw "Error reading extent index";
        }
      }
    }
  }), g.createBoxCtor("imir", "ImageMirror", function(n) {
    var o = n.readUint8();
    this.reserved = o >> 7, this.axis = o & 1;
  }), g.createFullBoxCtor("infe", "ItemInfoEntry", function(n) {
    if ((this.version === 0 || this.version === 1) && (this.item_ID = n.readUint16(), this.item_protection_index = n.readUint16(), this.item_name = n.readCString(), this.content_type = n.readCString(), this.content_encoding = n.readCString()), this.version === 1) {
      this.extension_type = n.readString(4), e.warn("BoxParser", "Cannot parse extension type"), n.seek(this.start + this.size);
      return;
    }
    this.version >= 2 && (this.version === 2 ? this.item_ID = n.readUint16() : this.version === 3 && (this.item_ID = n.readUint32()), this.item_protection_index = n.readUint16(), this.item_type = n.readString(4), this.item_name = n.readCString(), this.item_type === "mime" ? (this.content_type = n.readCString(), this.content_encoding = n.readCString()) : this.item_type === "uri " && (this.item_uri_type = n.readCString()));
  }), g.createFullBoxCtor("ipma", "ItemPropertyAssociationBox", function(n) {
    var o, l;
    for (entry_count = n.readUint32(), this.associations = [], o = 0; o < entry_count; o++) {
      var h = {};
      this.associations.push(h), this.version < 1 ? h.id = n.readUint16() : h.id = n.readUint32();
      var p = n.readUint8();
      for (h.props = [], l = 0; l < p; l++) {
        var z = n.readUint8(), Z = {};
        h.props.push(Z), Z.essential = (z & 128) >> 7 === 1, this.flags & 1 ? Z.property_index = (z & 127) << 8 | n.readUint8() : Z.property_index = z & 127;
      }
    }
  }), g.createFullBoxCtor("iref", "ItemReferenceBox", function(n) {
    var o, l;
    for (this.references = []; n.getPosition() < this.start + this.size; )
      if (o = g.parseOneBox(n, !0, this.size - (n.getPosition() - this.start)), o.code === g.OK)
        this.version === 0 ? l = new g.SingleItemTypeReferenceBox(o.type, o.size, o.hdr_size, o.start) : l = new g.SingleItemTypeReferenceBoxLarge(o.type, o.size, o.hdr_size, o.start), l.write === g.Box.prototype.write && l.type !== "mdat" && (e.warn("BoxParser", l.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), l.parseDataAndRewind(n)), l.parse(n), this.references.push(l);
      else
        return;
  }), g.createBoxCtor("irot", "ImageRotation", function(n) {
    this.angle = n.readUint8() & 3;
  }), g.createFullBoxCtor("ispe", "ImageSpatialExtentsProperty", function(n) {
    this.image_width = n.readUint32(), this.image_height = n.readUint32();
  }), g.createFullBoxCtor("kind", "KindBox", function(n) {
    this.schemeURI = n.readCString(), this.value = n.readCString();
  }), g.createFullBoxCtor("leva", "LevelAssignmentBox", function(n) {
    var o = n.readUint8();
    this.levels = [];
    for (var l = 0; l < o; l++) {
      var h = {};
      this.levels[l] = h, h.track_ID = n.readUint32();
      var p = n.readUint8();
      switch (h.padding_flag = p >> 7, h.assignment_type = p & 127, h.assignment_type) {
        case 0:
          h.grouping_type = n.readString(4);
          break;
        case 1:
          h.grouping_type = n.readString(4), h.grouping_type_parameter = n.readUint32();
          break;
        case 2:
          break;
        case 3:
          break;
        case 4:
          h.sub_track_id = n.readUint32();
          break;
        default:
          e.warn("BoxParser", "Unknown leva assignement type");
      }
    }
  }), g.createBoxCtor("lhvC", "LHEVCConfigurationBox", function(n) {
    var o, l, h;
    this.configurationVersion = n.readUint8(), this.min_spatial_segmentation_idc = n.readUint16() & 4095, this.parallelismType = n.readUint8() & 3, h = n.readUint8(), this.numTemporalLayers = (h & 13) >> 3, this.temporalIdNested = (h & 4) >> 2, this.lengthSizeMinusOne = h & 3, this.nalu_arrays = [], this.nalu_arrays.toString = function() {
      var vt = "<table class='inner-table'>";
      vt += "<thead><tr><th>completeness</th><th>nalu_type</th><th>nalu_data</th></tr></thead>", vt += "<tbody>";
      for (var Lt = 0; Lt < this.length; Lt++) {
        var zt = this[Lt];
        vt += "<tr>", vt += "<td rowspan='" + zt.length + "'>" + zt.completeness + "</td>", vt += "<td rowspan='" + zt.length + "'>" + zt.nalu_type + "</td>";
        for (var X = 0; X < zt.length; X++) {
          var D = zt[X];
          X !== 0 && (vt += "<tr>"), vt += "<td>", vt += D.data.reduce(function(yt, Mt) {
            return yt + Mt.toString(16).padStart(2, "0");
          }, "0x"), vt += "</td></tr>";
        }
      }
      return vt += "</tbody></table>", vt;
    };
    var p = n.readUint8();
    for (o = 0; o < p; o++) {
      var z = [];
      this.nalu_arrays.push(z), h = n.readUint8(), z.completeness = (h & 128) >> 7, z.nalu_type = h & 63;
      var Z = n.readUint16();
      for (l = 0; l < Z; l++) {
        var V = {};
        z.push(V);
        var Q = n.readUint16();
        V.data = n.readUint8Array(Q);
      }
    }
  }), g.createBoxCtor("lsel", "LayerSelectorProperty", function(n) {
    this.layer_id = n.readUint16();
  }), g.createBoxCtor("maxr", "hintmaxrate", function(n) {
    this.period = n.readUint32(), this.bytes = n.readUint32();
  });
  function B(n, o) {
    this.x = n, this.y = o;
  }
  B.prototype.toString = function() {
    return "(" + this.x + "," + this.y + ")";
  }, g.createBoxCtor("mdcv", "MasteringDisplayColourVolumeBox", function(n) {
    this.display_primaries = [], this.display_primaries[0] = new B(n.readUint16(), n.readUint16()), this.display_primaries[1] = new B(n.readUint16(), n.readUint16()), this.display_primaries[2] = new B(n.readUint16(), n.readUint16()), this.white_point = new B(n.readUint16(), n.readUint16()), this.max_display_mastering_luminance = n.readUint32(), this.min_display_mastering_luminance = n.readUint32();
  }), g.createFullBoxCtor("mdhd", "MediaHeaderBox", function(n) {
    this.version == 1 ? (this.creation_time = n.readUint64(), this.modification_time = n.readUint64(), this.timescale = n.readUint32(), this.duration = n.readUint64()) : (this.creation_time = n.readUint32(), this.modification_time = n.readUint32(), this.timescale = n.readUint32(), this.duration = n.readUint32()), this.parseLanguage(n), n.readUint16();
  }), g.createFullBoxCtor("mehd", "MovieExtendsHeaderBox", function(n) {
    this.flags & 1 && (e.warn("BoxParser", "mehd box incorrectly uses flags set to 1, converting version to 1"), this.version = 1), this.version == 1 ? this.fragment_duration = n.readUint64() : this.fragment_duration = n.readUint32();
  }), g.createFullBoxCtor("meta", "MetaBox", function(n) {
    this.boxes = [], g.ContainerBox.prototype.parse.call(this, n);
  }), g.createFullBoxCtor("mfhd", "MovieFragmentHeaderBox", function(n) {
    this.sequence_number = n.readUint32();
  }), g.createFullBoxCtor("mfro", "MovieFragmentRandomAccessOffsetBox", function(n) {
    this._size = n.readUint32();
  }), g.createFullBoxCtor("mskC", "MaskConfigurationProperty", function(n) {
    this.bits_per_pixel = n.readUint8();
  }), g.createFullBoxCtor("mvhd", "MovieHeaderBox", function(n) {
    this.version == 1 ? (this.creation_time = n.readUint64(), this.modification_time = n.readUint64(), this.timescale = n.readUint32(), this.duration = n.readUint64()) : (this.creation_time = n.readUint32(), this.modification_time = n.readUint32(), this.timescale = n.readUint32(), this.duration = n.readUint32()), this.rate = n.readUint32(), this.volume = n.readUint16() >> 8, n.readUint16(), n.readUint32Array(2), this.matrix = n.readUint32Array(9), n.readUint32Array(6), this.next_track_id = n.readUint32();
  }), g.createBoxCtor("npck", "hintPacketsSent", function(n) {
    this.packetssent = n.readUint32();
  }), g.createBoxCtor("nump", "hintPacketsSent", function(n) {
    this.packetssent = n.readUint64();
  }), g.createFullBoxCtor("padb", "PaddingBitsBox", function(n) {
    var o = n.readUint32();
    this.padbits = [];
    for (var l = 0; l < Math.floor((o + 1) / 2); l++)
      this.padbits = n.readUint8();
  }), g.createBoxCtor("pasp", "PixelAspectRatioBox", function(n) {
    this.hSpacing = n.readUint32(), this.vSpacing = n.readUint32();
  }), g.createBoxCtor("payl", "CuePayloadBox", function(n) {
    this.text = n.readString(this.size - this.hdr_size);
  }), g.createBoxCtor("payt", "hintpayloadID", function(n) {
    this.payloadID = n.readUint32();
    var o = n.readUint8();
    this.rtpmap_string = n.readString(o);
  }), g.createFullBoxCtor("pdin", "ProgressiveDownloadInfoBox", function(n) {
    var o = (this.size - this.hdr_size) / 8;
    this.rate = [], this.initial_delay = [];
    for (var l = 0; l < o; l++)
      this.rate[l] = n.readUint32(), this.initial_delay[l] = n.readUint32();
  }), g.createFullBoxCtor("pitm", "PrimaryItemBox", function(n) {
    this.version === 0 ? this.item_id = n.readUint16() : this.item_id = n.readUint32();
  }), g.createFullBoxCtor("pixi", "PixelInformationProperty", function(n) {
    var o;
    for (this.num_channels = n.readUint8(), this.bits_per_channels = [], o = 0; o < this.num_channels; o++)
      this.bits_per_channels[o] = n.readUint8();
  }), g.createBoxCtor("pmax", "hintlargestpacket", function(n) {
    this.bytes = n.readUint32();
  }), g.createFullBoxCtor("prdi", "ProgressiveDerivedImageItemInformationProperty", function(n) {
    if (this.step_count = n.readUint16(), this.item_count = [], this.flags & 2)
      for (var o = 0; o < this.step_count; o++)
        this.item_count[o] = n.readUint16();
  }), g.createFullBoxCtor("prft", "ProducerReferenceTimeBox", function(n) {
    this.ref_track_id = n.readUint32(), this.ntp_timestamp = n.readUint64(), this.version === 0 ? this.media_time = n.readUint32() : this.media_time = n.readUint64();
  }), g.createFullBoxCtor("pssh", "ProtectionSystemSpecificHeaderBox", function(n) {
    if (this.system_id = g.parseHex16(n), this.version > 0) {
      var o = n.readUint32();
      this.kid = [];
      for (var l = 0; l < o; l++)
        this.kid[l] = g.parseHex16(n);
    }
    var h = n.readUint32();
    h > 0 && (this.data = n.readUint8Array(h));
  }), g.createFullBoxCtor("clef", "TrackCleanApertureDimensionsBox", function(n) {
    this.width = n.readUint32(), this.height = n.readUint32();
  }), g.createFullBoxCtor("enof", "TrackEncodedPixelsDimensionsBox", function(n) {
    this.width = n.readUint32(), this.height = n.readUint32();
  }), g.createFullBoxCtor("prof", "TrackProductionApertureDimensionsBox", function(n) {
    this.width = n.readUint32(), this.height = n.readUint32();
  }), g.createContainerBoxCtor("tapt", "TrackApertureModeDimensionsBox", null, ["clef", "prof", "enof"]), g.createBoxCtor("rtp ", "rtpmoviehintinformation", function(n) {
    this.descriptionformat = n.readString(4), this.sdptext = n.readString(this.size - this.hdr_size - 4);
  }), g.createFullBoxCtor("saio", "SampleAuxiliaryInformationOffsetsBox", function(n) {
    this.flags & 1 && (this.aux_info_type = n.readString(4), this.aux_info_type_parameter = n.readUint32());
    var o = n.readUint32();
    this.offset = [];
    for (var l = 0; l < o; l++)
      this.version === 0 ? this.offset[l] = n.readUint32() : this.offset[l] = n.readUint64();
  }), g.createFullBoxCtor("saiz", "SampleAuxiliaryInformationSizesBox", function(n) {
    if (this.flags & 1 && (this.aux_info_type = n.readString(4), this.aux_info_type_parameter = n.readUint32()), this.default_sample_info_size = n.readUint8(), this.sample_count = n.readUint32(), this.sample_info_size = [], this.default_sample_info_size === 0)
      for (var o = 0; o < this.sample_count; o++)
        this.sample_info_size[o] = n.readUint8();
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_METADATA, "mett", function(n) {
    this.parseHeader(n), this.content_encoding = n.readCString(), this.mime_format = n.readCString(), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_METADATA, "metx", function(n) {
    this.parseHeader(n), this.content_encoding = n.readCString(), this.namespace = n.readCString(), this.schema_location = n.readCString(), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE, "sbtt", function(n) {
    this.parseHeader(n), this.content_encoding = n.readCString(), this.mime_format = n.readCString(), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE, "stpp", function(n) {
    this.parseHeader(n), this.namespace = n.readCString(), this.schema_location = n.readCString(), this.auxiliary_mime_types = n.readCString(), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE, "stxt", function(n) {
    this.parseHeader(n), this.content_encoding = n.readCString(), this.mime_format = n.readCString(), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_SUBTITLE, "tx3g", function(n) {
    this.parseHeader(n), this.displayFlags = n.readUint32(), this.horizontal_justification = n.readInt8(), this.vertical_justification = n.readInt8(), this.bg_color_rgba = n.readUint8Array(4), this.box_record = n.readInt16Array(4), this.style_record = n.readUint8Array(12), this.parseFooter(n);
  }), g.createSampleEntryCtor(g.SAMPLE_ENTRY_TYPE_METADATA, "wvtt", function(n) {
    this.parseHeader(n), this.parseFooter(n);
  }), g.createSampleGroupCtor("alst", function(n) {
    var o, l = n.readUint16();
    for (this.first_output_sample = n.readUint16(), this.sample_offset = [], o = 0; o < l; o++)
      this.sample_offset[o] = n.readUint32();
    var h = this.description_length - 4 - 4 * l;
    for (this.num_output_samples = [], this.num_total_samples = [], o = 0; o < h / 4; o++)
      this.num_output_samples[o] = n.readUint16(), this.num_total_samples[o] = n.readUint16();
  }), g.createSampleGroupCtor("avll", function(n) {
    this.layerNumber = n.readUint8(), this.accurateStatisticsFlag = n.readUint8(), this.avgBitRate = n.readUint16(), this.avgFrameRate = n.readUint16();
  }), g.createSampleGroupCtor("avss", function(n) {
    this.subSequenceIdentifier = n.readUint16(), this.layerNumber = n.readUint8();
    var o = n.readUint8();
    this.durationFlag = o >> 7, this.avgRateFlag = o >> 6 & 1, this.durationFlag && (this.duration = n.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = n.readUint8(), this.avgBitRate = n.readUint16(), this.avgFrameRate = n.readUint16()), this.dependency = [];
    for (var l = n.readUint8(), h = 0; h < l; h++) {
      var p = {};
      this.dependency.push(p), p.subSeqDirectionFlag = n.readUint8(), p.layerNumber = n.readUint8(), p.subSequenceIdentifier = n.readUint16();
    }
  }), g.createSampleGroupCtor("dtrt", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("mvif", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("prol", function(n) {
    this.roll_distance = n.readInt16();
  }), g.createSampleGroupCtor("rap ", function(n) {
    var o = n.readUint8();
    this.num_leading_samples_known = o >> 7, this.num_leading_samples = o & 127;
  }), g.createSampleGroupCtor("rash", function(n) {
    if (this.operation_point_count = n.readUint16(), this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9)
      e.warn("BoxParser", "Mismatch in " + this.grouping_type + " sample group length"), this.data = n.readUint8Array(this.description_length - 2);
    else {
      if (this.operation_point_count === 1)
        this.target_rate_share = n.readUint16();
      else {
        this.target_rate_share = [], this.available_bitrate = [];
        for (var o = 0; o < this.operation_point_count; o++)
          this.available_bitrate[o] = n.readUint32(), this.target_rate_share[o] = n.readUint16();
      }
      this.maximum_bitrate = n.readUint32(), this.minimum_bitrate = n.readUint32(), this.discard_priority = n.readUint8();
    }
  }), g.createSampleGroupCtor("roll", function(n) {
    this.roll_distance = n.readInt16();
  }), g.SampleGroupEntry.prototype.parse = function(n) {
    e.warn("BoxParser", "Unknown Sample Group type: " + this.grouping_type), this.data = n.readUint8Array(this.description_length);
  }, g.createSampleGroupCtor("scif", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("scnm", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("seig", function(n) {
    this.reserved = n.readUint8();
    var o = n.readUint8();
    this.crypt_byte_block = o >> 4, this.skip_byte_block = o & 15, this.isProtected = n.readUint8(), this.Per_Sample_IV_Size = n.readUint8(), this.KID = g.parseHex16(n), this.constant_IV_size = 0, this.constant_IV = 0, this.isProtected === 1 && this.Per_Sample_IV_Size === 0 && (this.constant_IV_size = n.readUint8(), this.constant_IV = n.readUint8Array(this.constant_IV_size));
  }), g.createSampleGroupCtor("stsa", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("sync", function(n) {
    var o = n.readUint8();
    this.NAL_unit_type = o & 63;
  }), g.createSampleGroupCtor("tele", function(n) {
    var o = n.readUint8();
    this.level_independently_decodable = o >> 7;
  }), g.createSampleGroupCtor("tsas", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("tscl", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createSampleGroupCtor("vipr", function(n) {
    e.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), g.createFullBoxCtor("sbgp", "SampleToGroupBox", function(n) {
    this.grouping_type = n.readString(4), this.version === 1 ? this.grouping_type_parameter = n.readUint32() : this.grouping_type_parameter = 0, this.entries = [];
    for (var o = n.readUint32(), l = 0; l < o; l++) {
      var h = {};
      this.entries.push(h), h.sample_count = n.readInt32(), h.group_description_index = n.readInt32();
    }
  });
  function c(n, o) {
    this.bad_pixel_row = n, this.bad_pixel_column = o;
  }
  c.prototype.toString = function() {
    return "[row: " + this.bad_pixel_row + ", column: " + this.bad_pixel_column + "]";
  }, g.createFullBoxCtor("sbpm", "SensorBadPixelsMapBox", function(n) {
    var o;
    for (this.component_count = n.readUint16(), this.component_index = [], o = 0; o < this.component_count; o++)
      this.component_index.push(n.readUint16());
    var l = n.readUint8();
    for (this.correction_applied = (l & 128) == 128, this.num_bad_rows = n.readUint32(), this.num_bad_cols = n.readUint32(), this.num_bad_pixels = n.readUint32(), this.bad_rows = [], this.bad_columns = [], this.bad_pixels = [], o = 0; o < this.num_bad_rows; o++)
      this.bad_rows.push(n.readUint32());
    for (o = 0; o < this.num_bad_cols; o++)
      this.bad_columns.push(n.readUint32());
    for (o = 0; o < this.num_bad_pixels; o++) {
      var h = n.readUint32(), p = n.readUint32();
      this.bad_pixels.push(new c(h, p));
    }
  }), g.createFullBoxCtor("schm", "SchemeTypeBox", function(n) {
    this.scheme_type = n.readString(4), this.scheme_version = n.readUint32(), this.flags & 1 && (this.scheme_uri = n.readString(this.size - this.hdr_size - 8));
  }), g.createBoxCtor("sdp ", "rtptracksdphintinformation", function(n) {
    this.sdptext = n.readString(this.size - this.hdr_size);
  }), g.createFullBoxCtor("sdtp", "SampleDependencyTypeBox", function(n) {
    var o, l = this.size - this.hdr_size;
    this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];
    for (var h = 0; h < l; h++)
      o = n.readUint8(), this.is_leading[h] = o >> 6, this.sample_depends_on[h] = o >> 4 & 3, this.sample_is_depended_on[h] = o >> 2 & 3, this.sample_has_redundancy[h] = o & 3;
  }), g.createFullBoxCtor("senc", "SampleEncryptionBox", function(n) {
    var o = n.readUint32();
    this.samples = [];
    for (var l = 0; l < o; l++) {
      var h = {}, p = 8;
      if (h.InitializationVector = n.readUint8Array(p), this.flags & 2) {
        h.subsamples = [], subsample_count = n.readUint16();
        for (var z = 0; z < subsample_count; z++) {
          var Z = {};
          Z.BytesOfClearData = n.readUint16(), Z.BytesOfProtectedData = n.readUint32(), h.subsamples.push(Z);
        }
      }
      this.samples.push(h);
    }
  }), g.createFullBoxCtor("sgpd", "SampleGroupDescriptionBox", function(n) {
    this.grouping_type = n.readString(4), e.debug("BoxParser", "Found Sample Groups of type " + this.grouping_type), this.version === 1 ? this.default_length = n.readUint32() : this.default_length = 0, this.version >= 2 && (this.default_group_description_index = n.readUint32()), this.entries = [];
    for (var o = n.readUint32(), l = 0; l < o; l++) {
      var h;
      g[this.grouping_type + "SampleGroupEntry"] ? h = new g[this.grouping_type + "SampleGroupEntry"](this.grouping_type) : h = new g.SampleGroupEntry(this.grouping_type), this.entries.push(h), this.version === 1 ? this.default_length === 0 ? h.description_length = n.readUint32() : h.description_length = this.default_length : h.description_length = this.default_length, h.write === g.SampleGroupEntry.prototype.write && (e.info("BoxParser", "SampleGroup for type " + this.grouping_type + " writing not yet implemented, keeping unparsed data in memory for later write"), h.data = n.readUint8Array(h.description_length), n.position -= h.description_length), h.parse(n);
    }
  }), g.createFullBoxCtor("sidx", "CompressedSegmentIndexBox", function(n) {
    this.reference_ID = n.readUint32(), this.timescale = n.readUint32(), this.version === 0 ? (this.earliest_presentation_time = n.readUint32(), this.first_offset = n.readUint32()) : (this.earliest_presentation_time = n.readUint64(), this.first_offset = n.readUint64()), n.readUint16(), this.references = [];
    for (var o = n.readUint16(), l = 0; l < o; l++) {
      var h = {};
      this.references.push(h);
      var p = n.readUint32();
      h.reference_type = p >> 31 & 1, h.referenced_size = p & 2147483647, h.subsegment_duration = n.readUint32(), p = n.readUint32(), h.starts_with_SAP = p >> 31 & 1, h.SAP_type = p >> 28 & 7, h.SAP_delta_time = p & 268435455;
    }
  }), g.SingleItemTypeReferenceBox = function(n, o, l, h) {
    g.Box.call(this, n, o), this.hdr_size = l, this.start = h;
  }, g.SingleItemTypeReferenceBox.prototype = new g.Box(), g.SingleItemTypeReferenceBox.prototype.parse = function(n) {
    this.from_item_ID = n.readUint16();
    var o = n.readUint16();
    this.references = [];
    for (var l = 0; l < o; l++)
      this.references[l] = {}, this.references[l].to_item_ID = n.readUint16();
  }, g.SingleItemTypeReferenceBoxLarge = function(n, o, l, h) {
    g.Box.call(this, n, o), this.hdr_size = l, this.start = h;
  }, g.SingleItemTypeReferenceBoxLarge.prototype = new g.Box(), g.SingleItemTypeReferenceBoxLarge.prototype.parse = function(n) {
    this.from_item_ID = n.readUint32();
    var o = n.readUint16();
    this.references = [];
    for (var l = 0; l < o; l++)
      this.references[l] = {}, this.references[l].to_item_ID = n.readUint32();
  }, g.createFullBoxCtor("SmDm", "SMPTE2086MasteringDisplayMetadataBox", function(n) {
    this.primaryRChromaticity_x = n.readUint16(), this.primaryRChromaticity_y = n.readUint16(), this.primaryGChromaticity_x = n.readUint16(), this.primaryGChromaticity_y = n.readUint16(), this.primaryBChromaticity_x = n.readUint16(), this.primaryBChromaticity_y = n.readUint16(), this.whitePointChromaticity_x = n.readUint16(), this.whitePointChromaticity_y = n.readUint16(), this.luminanceMax = n.readUint32(), this.luminanceMin = n.readUint32();
  }), g.createFullBoxCtor("smhd", "SoundMediaHeaderBox", function(n) {
    this.balance = n.readUint16(), n.readUint16();
  }), g.createFullBoxCtor("ssix", "CompressedSubsegmentIndexBox", function(n) {
    this.subsegments = [];
    for (var o = n.readUint32(), l = 0; l < o; l++) {
      var h = {};
      this.subsegments.push(h), h.ranges = [];
      for (var p = n.readUint32(), z = 0; z < p; z++) {
        var Z = {};
        h.ranges.push(Z), Z.level = n.readUint8(), Z.range_size = n.readUint24();
      }
    }
  }), g.createFullBoxCtor("stco", "ChunkOffsetBox", function(n) {
    var o;
    if (o = n.readUint32(), this.chunk_offsets = [], this.version === 0)
      for (var l = 0; l < o; l++)
        this.chunk_offsets.push(n.readUint32());
  }), g.createFullBoxCtor("stdp", "DegradationPriorityBox", function(n) {
    var o = (this.size - this.hdr_size) / 2;
    this.priority = [];
    for (var l = 0; l < o; l++)
      this.priority[l] = n.readUint16();
  }), g.createFullBoxCtor("sthd", "SubtitleMediaHeaderBox"), g.createFullBoxCtor("stri", "SubTrackInformationBox", function(n) {
    this.switch_group = n.readUint16(), this.alternate_group = n.readUint16(), this.sub_track_id = n.readUint32();
    var o = (this.size - this.hdr_size - 8) / 4;
    this.attribute_list = [];
    for (var l = 0; l < o; l++)
      this.attribute_list[l] = n.readUint32();
  }), g.createFullBoxCtor("stsc", "SampleToChunkBox", function(n) {
    var o, l;
    if (o = n.readUint32(), this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], this.version === 0)
      for (l = 0; l < o; l++)
        this.first_chunk.push(n.readUint32()), this.samples_per_chunk.push(n.readUint32()), this.sample_description_index.push(n.readUint32());
  }), g.createFullBoxCtor("stsd", "SampleDescriptionBox", function(n) {
    var o, l, h, p;
    for (this.entries = [], h = n.readUint32(), o = 1; o <= h; o++)
      if (l = g.parseOneBox(n, !0, this.size - (n.getPosition() - this.start)), l.code === g.OK)
        g[l.type + "SampleEntry"] ? (p = new g[l.type + "SampleEntry"](l.size), p.hdr_size = l.hdr_size, p.start = l.start) : (e.warn("BoxParser", "Unknown sample entry type: " + l.type), p = new g.SampleEntry(l.type, l.size, l.hdr_size, l.start)), p.write === g.SampleEntry.prototype.write && (e.info("BoxParser", "SampleEntry " + p.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), p.parseDataAndRewind(n)), p.parse(n), this.entries.push(p);
      else
        return;
  }), g.createFullBoxCtor("stsg", "SubTrackSampleGroupBox", function(n) {
    this.grouping_type = n.readUint32();
    var o = n.readUint16();
    this.group_description_index = [];
    for (var l = 0; l < o; l++)
      this.group_description_index[l] = n.readUint32();
  }), g.createFullBoxCtor("stsh", "ShadowSyncSampleBox", function(n) {
    var o, l;
    if (o = n.readUint32(), this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], this.version === 0)
      for (l = 0; l < o; l++)
        this.shadowed_sample_numbers.push(n.readUint32()), this.sync_sample_numbers.push(n.readUint32());
  }), g.createFullBoxCtor("stss", "SyncSampleBox", function(n) {
    var o, l;
    if (l = n.readUint32(), this.version === 0)
      for (this.sample_numbers = [], o = 0; o < l; o++)
        this.sample_numbers.push(n.readUint32());
  }), g.createFullBoxCtor("stsz", "SampleSizeBox", function(n) {
    var o;
    if (this.sample_sizes = [], this.version === 0)
      for (this.sample_size = n.readUint32(), this.sample_count = n.readUint32(), o = 0; o < this.sample_count; o++)
        this.sample_size === 0 ? this.sample_sizes.push(n.readUint32()) : this.sample_sizes[o] = this.sample_size;
  }), g.createFullBoxCtor("stts", "TimeToSampleBox", function(n) {
    var o, l, h;
    if (o = n.readUint32(), this.sample_counts = [], this.sample_deltas = [], this.version === 0)
      for (l = 0; l < o; l++)
        this.sample_counts.push(n.readUint32()), h = n.readInt32(), h < 0 && (e.warn("BoxParser", "File uses negative stts sample delta, using value 1 instead, sync may be lost!"), h = 1), this.sample_deltas.push(h);
  }), g.createFullBoxCtor("stvi", "StereoVideoBox", function(n) {
    var o = n.readUint32();
    this.single_view_allowed = o & 3, this.stereo_scheme = n.readUint32();
    var l = n.readUint32();
    this.stereo_indication_type = n.readString(l);
    var h, p;
    for (this.boxes = []; n.getPosition() < this.start + this.size; )
      if (h = g.parseOneBox(n, !1, this.size - (n.getPosition() - this.start)), h.code === g.OK)
        p = h.box, this.boxes.push(p), this[p.type] = p;
      else
        return;
  }), g.createBoxCtor("styp", "SegmentTypeBox", function(n) {
    g.ftypBox.prototype.parse.call(this, n);
  }), g.createFullBoxCtor("stz2", "CompactSampleSizeBox", function(n) {
    var o, l;
    if (this.sample_sizes = [], this.version === 0)
      if (this.reserved = n.readUint24(), this.field_size = n.readUint8(), l = n.readUint32(), this.field_size === 4)
        for (o = 0; o < l; o += 2) {
          var h = n.readUint8();
          this.sample_sizes[o] = h >> 4 & 15, this.sample_sizes[o + 1] = h & 15;
        }
      else if (this.field_size === 8)
        for (o = 0; o < l; o++)
          this.sample_sizes[o] = n.readUint8();
      else if (this.field_size === 16)
        for (o = 0; o < l; o++)
          this.sample_sizes[o] = n.readUint16();
      else
        e.error("BoxParser", "Error in length field in stz2 box");
  }), g.createFullBoxCtor("subs", "SubSampleInformationBox", function(n) {
    var o, l, h, p;
    for (h = n.readUint32(), this.entries = [], o = 0; o < h; o++) {
      var z = {};
      if (this.entries[o] = z, z.sample_delta = n.readUint32(), z.subsamples = [], p = n.readUint16(), p > 0)
        for (l = 0; l < p; l++) {
          var Z = {};
          z.subsamples.push(Z), this.version == 1 ? Z.size = n.readUint32() : Z.size = n.readUint16(), Z.priority = n.readUint8(), Z.discardable = n.readUint8(), Z.codec_specific_parameters = n.readUint32();
        }
    }
  }), g.createFullBoxCtor("tenc", "TrackEncryptionBox", function(n) {
    if (n.readUint8(), this.version === 0)
      n.readUint8();
    else {
      var o = n.readUint8();
      this.default_crypt_byte_block = o >> 4 & 15, this.default_skip_byte_block = o & 15;
    }
    this.default_isProtected = n.readUint8(), this.default_Per_Sample_IV_Size = n.readUint8(), this.default_KID = g.parseHex16(n), this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0 && (this.default_constant_IV_size = n.readUint8(), this.default_constant_IV = n.readUint8Array(this.default_constant_IV_size));
  }), g.createFullBoxCtor("tfdt", "TrackFragmentBaseMediaDecodeTimeBox", function(n) {
    this.version == 1 ? this.baseMediaDecodeTime = n.readUint64() : this.baseMediaDecodeTime = n.readUint32();
  }), g.createFullBoxCtor("tfhd", "TrackFragmentHeaderBox", function(n) {
    var o = 0;
    this.track_id = n.readUint32(), this.size - this.hdr_size > o && this.flags & g.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = n.readUint64(), o += 8) : this.base_data_offset = 0, this.size - this.hdr_size > o && this.flags & g.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = n.readUint32(), o += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > o && this.flags & g.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = n.readUint32(), o += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > o && this.flags & g.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = n.readUint32(), o += 4) : this.default_sample_size = 0, this.size - this.hdr_size > o && this.flags & g.TFHD_FLAG_SAMPLE_FLAGS ? (this.default_sample_flags = n.readUint32(), o += 4) : this.default_sample_flags = 0;
  }), g.createFullBoxCtor("tfra", "TrackFragmentRandomAccessBox", function(n) {
    this.track_ID = n.readUint32(), n.readUint24();
    var o = n.readUint8();
    this.length_size_of_traf_num = o >> 4 & 3, this.length_size_of_trun_num = o >> 2 & 3, this.length_size_of_sample_num = o & 3, this.entries = [];
    for (var l = n.readUint32(), h = 0; h < l; h++)
      this.version === 1 ? (this.time = n.readUint64(), this.moof_offset = n.readUint64()) : (this.time = n.readUint32(), this.moof_offset = n.readUint32()), this.traf_number = n["readUint" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = n["readUint" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = n["readUint" + 8 * (this.length_size_of_sample_num + 1)]();
  }), g.createFullBoxCtor("tkhd", "TrackHeaderBox", function(n) {
    this.version == 1 ? (this.creation_time = n.readUint64(), this.modification_time = n.readUint64(), this.track_id = n.readUint32(), n.readUint32(), this.duration = n.readUint64()) : (this.creation_time = n.readUint32(), this.modification_time = n.readUint32(), this.track_id = n.readUint32(), n.readUint32(), this.duration = n.readUint32()), n.readUint32Array(2), this.layer = n.readInt16(), this.alternate_group = n.readInt16(), this.volume = n.readInt16() >> 8, n.readUint16(), this.matrix = n.readInt32Array(9), this.width = n.readUint32(), this.height = n.readUint32();
  }), g.createBoxCtor("tmax", "hintmaxrelativetime", function(n) {
    this.time = n.readUint32();
  }), g.createBoxCtor("tmin", "hintminrelativetime", function(n) {
    this.time = n.readUint32();
  }), g.createBoxCtor("totl", "hintBytesSent", function(n) {
    this.bytessent = n.readUint32();
  }), g.createBoxCtor("tpay", "hintBytesSent", function(n) {
    this.bytessent = n.readUint32();
  }), g.createBoxCtor("tpyl", "hintBytesSent", function(n) {
    this.bytessent = n.readUint64();
  }), g.TrackGroupTypeBox.prototype.parse = function(n) {
    this.parseFullHeader(n), this.track_group_id = n.readUint32();
  }, g.createTrackGroupCtor("msrc"), g.TrackReferenceTypeBox = function(n, o, l, h) {
    g.Box.call(this, n, o), this.hdr_size = l, this.start = h;
  }, g.TrackReferenceTypeBox.prototype = new g.Box(), g.TrackReferenceTypeBox.prototype.parse = function(n) {
    this.track_ids = n.readUint32Array((this.size - this.hdr_size) / 4);
  }, g.trefBox.prototype.parse = function(n) {
    for (var o, l; n.getPosition() < this.start + this.size; )
      if (o = g.parseOneBox(n, !0, this.size - (n.getPosition() - this.start)), o.code === g.OK)
        l = new g.TrackReferenceTypeBox(o.type, o.size, o.hdr_size, o.start), l.write === g.Box.prototype.write && l.type !== "mdat" && (e.info("BoxParser", "TrackReference " + l.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), l.parseDataAndRewind(n)), l.parse(n), this.boxes.push(l);
      else
        return;
  }, g.createFullBoxCtor("trep", "TrackExtensionPropertiesBox", function(n) {
    for (this.track_ID = n.readUint32(), this.boxes = []; n.getPosition() < this.start + this.size; )
      if (ret = g.parseOneBox(n, !1, this.size - (n.getPosition() - this.start)), ret.code === g.OK)
        box = ret.box, this.boxes.push(box);
      else
        return;
  }), g.createFullBoxCtor("trex", "TrackExtendsBox", function(n) {
    this.track_id = n.readUint32(), this.default_sample_description_index = n.readUint32(), this.default_sample_duration = n.readUint32(), this.default_sample_size = n.readUint32(), this.default_sample_flags = n.readUint32();
  }), g.createBoxCtor("trpy", "hintBytesSent", function(n) {
    this.bytessent = n.readUint64();
  }), g.createFullBoxCtor("trun", "TrackRunBox", function(n) {
    var o = 0;
    if (this.sample_count = n.readUint32(), o += 4, this.size - this.hdr_size > o && this.flags & g.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = n.readInt32(), o += 4) : this.data_offset = 0, this.size - this.hdr_size > o && this.flags & g.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = n.readUint32(), o += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > o)
      for (var l = 0; l < this.sample_count; l++)
        this.flags & g.TRUN_FLAGS_DURATION && (this.sample_duration[l] = n.readUint32()), this.flags & g.TRUN_FLAGS_SIZE && (this.sample_size[l] = n.readUint32()), this.flags & g.TRUN_FLAGS_FLAGS && (this.sample_flags[l] = n.readUint32()), this.flags & g.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? this.sample_composition_time_offset[l] = n.readUint32() : this.sample_composition_time_offset[l] = n.readInt32());
  }), g.createFullBoxCtor("tsel", "TrackSelectionBox", function(n) {
    this.switch_group = n.readUint32();
    var o = (this.size - this.hdr_size - 4) / 4;
    this.attribute_list = [];
    for (var l = 0; l < o; l++)
      this.attribute_list[l] = n.readUint32();
  }), g.createFullBoxCtor("txtC", "TextConfigBox", function(n) {
    this.config = n.readCString();
  }), g.createBoxCtor("tyco", "TypeCombinationBox", function(n) {
    var o = (this.size - this.hdr_size) / 4;
    this.compatible_brands = [];
    for (var l = 0; l < o; l++)
      this.compatible_brands[l] = n.readString(4);
  }), g.createFullBoxCtor("udes", "UserDescriptionProperty", function(n) {
    this.lang = n.readCString(), this.name = n.readCString(), this.description = n.readCString(), this.tags = n.readCString();
  }), g.createFullBoxCtor("uncC", "UncompressedFrameConfigBox", function(n) {
    var o;
    if (this.profile = n.readString(4), this.version != 1) {
      if (this.version == 0) {
        for (this.component_count = n.readUint32(), this.component_index = [], this.component_bit_depth_minus_one = [], this.component_format = [], this.component_align_size = [], o = 0; o < this.component_count; o++)
          this.component_index.push(n.readUint16()), this.component_bit_depth_minus_one.push(n.readUint8()), this.component_format.push(n.readUint8()), this.component_align_size.push(n.readUint8());
        this.sampling_type = n.readUint8(), this.interleave_type = n.readUint8(), this.block_size = n.readUint8();
        var l = n.readUint8();
        this.component_little_endian = l >> 7 & 1, this.block_pad_lsb = l >> 6 & 1, this.block_little_endian = l >> 5 & 1, this.block_reversed = l >> 4 & 1, this.pad_unknown = l >> 3 & 1, this.pixel_size = n.readUint32(), this.row_align_size = n.readUint32(), this.tile_align_size = n.readUint32(), this.num_tile_cols_minus_one = n.readUint32(), this.num_tile_rows_minus_one = n.readUint32();
      }
    }
  }), g.createFullBoxCtor("url ", "DataEntryUrlBox", function(n) {
    this.flags !== 1 && (this.location = n.readCString());
  }), g.createFullBoxCtor("urn ", "DataEntryUrnBox", function(n) {
    this.name = n.readCString(), this.size - this.hdr_size - this.name.length - 1 > 0 && (this.location = n.readCString());
  }), g.createUUIDBox("a5d40b30e81411ddba2f0800200c9a66", "LiveServerManifestBox", !0, !1, function(n) {
    this.LiveServerManifest = n.readString(this.size - this.hdr_size).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }), g.createUUIDBox("d08a4f1810f34a82b6c832d8aba183d3", "PiffProtectionSystemSpecificHeaderBox", !0, !1, function(n) {
    this.system_id = g.parseHex16(n);
    var o = n.readUint32();
    o > 0 && (this.data = n.readUint8Array(o));
  }), g.createUUIDBox(
    "a2394f525a9b4f14a2446c427c648df4",
    "PiffSampleEncryptionBox",
    !0,
    !1
    /*, function(stream) {
      if (this.flags & 0x1) {
        this.AlgorithmID = stream.readUint24();
        this.IV_size = stream.readUint8();
        this.KID = BoxParser.parseHex16(stream);
      }
      var sample_count = stream.readUint32();
      this.samples = [];
      for (var i = 0; i < sample_count; i++) {
        var sample = {};
        sample.InitializationVector = this.readUint8Array(this.IV_size*8);
        if (this.flags & 0x2) {
          sample.subsamples = [];
          sample.NumberOfEntries = stream.readUint16();
          for (var j = 0; j < sample.NumberOfEntries; j++) {
            var subsample = {};
            subsample.BytesOfClearData = stream.readUint16();
            subsample.BytesOfProtectedData = stream.readUint32();
            sample.subsamples.push(subsample);
          }
        }
        this.samples.push(sample);
      }
    }*/
  ), g.createUUIDBox("8974dbce7be74c5184f97148f9882554", "PiffTrackEncryptionBox", !0, !1, function(n) {
    this.default_AlgorithmID = n.readUint24(), this.default_IV_size = n.readUint8(), this.default_KID = g.parseHex16(n);
  }), g.createUUIDBox("d4807ef2ca3946958e5426cb9e46a79f", "TfrfBox", !0, !1, function(n) {
    this.fragment_count = n.readUint8(), this.entries = [];
    for (var o = 0; o < this.fragment_count; o++) {
      var l = {}, h = 0, p = 0;
      this.version === 1 ? (h = n.readUint64(), p = n.readUint64()) : (h = n.readUint32(), p = n.readUint32()), l.absolute_time = h, l.absolute_duration = p, this.entries.push(l);
    }
  }), g.createUUIDBox("6d1d9b0542d544e680e2141daff757b2", "TfxdBox", !0, !1, function(n) {
    this.version === 1 ? (this.absolute_time = n.readUint64(), this.duration = n.readUint64()) : (this.absolute_time = n.readUint32(), this.duration = n.readUint32());
  }), g.createFullBoxCtor("vmhd", "VideoMediaHeaderBox", function(n) {
    this.graphicsmode = n.readUint16(), this.opcolor = n.readUint16Array(3);
  }), g.createFullBoxCtor("vpcC", "VPCodecConfigurationRecord", function(n) {
    var o;
    this.version === 1 ? (this.profile = n.readUint8(), this.level = n.readUint8(), o = n.readUint8(), this.bitDepth = o >> 4, this.chromaSubsampling = o >> 1 & 7, this.videoFullRangeFlag = o & 1, this.colourPrimaries = n.readUint8(), this.transferCharacteristics = n.readUint8(), this.matrixCoefficients = n.readUint8(), this.codecIntializationDataSize = n.readUint16(), this.codecIntializationData = n.readUint8Array(this.codecIntializationDataSize)) : (this.profile = n.readUint8(), this.level = n.readUint8(), o = n.readUint8(), this.bitDepth = o >> 4 & 15, this.colorSpace = o & 15, o = n.readUint8(), this.chromaSubsampling = o >> 4 & 15, this.transferFunction = o >> 1 & 7, this.videoFullRangeFlag = o & 1, this.codecIntializationDataSize = n.readUint16(), this.codecIntializationData = n.readUint8Array(this.codecIntializationDataSize));
  }), g.createBoxCtor("vttC", "WebVTTConfigurationBox", function(n) {
    this.text = n.readString(this.size - this.hdr_size);
  }), g.createFullBoxCtor("vvcC", "VvcConfigurationBox", function(n) {
    var o, l, h = {
      held_bits: void 0,
      num_held_bits: 0,
      stream_read_1_bytes: function(D) {
        this.held_bits = D.readUint8(), this.num_held_bits = 8;
      },
      stream_read_2_bytes: function(D) {
        this.held_bits = D.readUint16(), this.num_held_bits = 16;
      },
      extract_bits: function(D) {
        var yt = this.held_bits >> this.num_held_bits - D & (1 << D) - 1;
        return this.num_held_bits -= D, yt;
      }
    };
    if (h.stream_read_1_bytes(n), h.extract_bits(5), this.lengthSizeMinusOne = h.extract_bits(2), this.ptl_present_flag = h.extract_bits(1), this.ptl_present_flag) {
      h.stream_read_2_bytes(n), this.ols_idx = h.extract_bits(9), this.num_sublayers = h.extract_bits(3), this.constant_frame_rate = h.extract_bits(2), this.chroma_format_idc = h.extract_bits(2), h.stream_read_1_bytes(n), this.bit_depth_minus8 = h.extract_bits(3), h.extract_bits(5);
      {
        if (h.stream_read_2_bytes(n), h.extract_bits(2), this.num_bytes_constraint_info = h.extract_bits(6), this.general_profile_idc = h.extract_bits(7), this.general_tier_flag = h.extract_bits(1), this.general_level_idc = n.readUint8(), h.stream_read_1_bytes(n), this.ptl_frame_only_constraint_flag = h.extract_bits(1), this.ptl_multilayer_enabled_flag = h.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {
          for (o = 0; o < this.num_bytes_constraint_info - 1; o++) {
            var p = h.extract_bits(6);
            h.stream_read_1_bytes(n);
            var z = h.extract_bits(2);
            this.general_constraint_info[o] = p << 2 | z;
          }
          this.general_constraint_info[this.num_bytes_constraint_info - 1] = h.extract_bits(6);
        } else
          h.extract_bits(6);
        if (this.num_sublayers > 1) {
          for (h.stream_read_1_bytes(n), this.ptl_sublayer_present_mask = 0, l = this.num_sublayers - 2; l >= 0; --l) {
            var Z = h.extract_bits(1);
            this.ptl_sublayer_present_mask |= Z << l;
          }
          for (l = this.num_sublayers; l <= 8 && this.num_sublayers > 1; ++l)
            h.extract_bits(1);
          for (this.sublayer_level_idc = [], l = this.num_sublayers - 2; l >= 0; --l)
            this.ptl_sublayer_present_mask & 1 << l && (this.sublayer_level_idc[l] = n.readUint8());
        }
        if (this.ptl_num_sub_profiles = n.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles)
          for (o = 0; o < this.ptl_num_sub_profiles; o++)
            this.general_sub_profile_idc.push(n.readUint32());
      }
      this.max_picture_width = n.readUint16(), this.max_picture_height = n.readUint16(), this.avg_frame_rate = n.readUint16();
    }
    var V = 12, Q = 13;
    this.nalu_arrays = [];
    var vt = n.readUint8();
    for (o = 0; o < vt; o++) {
      var Lt = [];
      this.nalu_arrays.push(Lt), h.stream_read_1_bytes(n), Lt.completeness = h.extract_bits(1), h.extract_bits(2), Lt.nalu_type = h.extract_bits(5);
      var zt = 1;
      for (Lt.nalu_type != Q && Lt.nalu_type != V && (zt = n.readUint16()), l = 0; l < zt; l++) {
        var X = n.readUint16();
        Lt.push({
          data: n.readUint8Array(X),
          length: X
        });
      }
    }
  }), g.createFullBoxCtor("vvnC", "VvcNALUConfigBox", function(n) {
    var o = strm.readUint8();
    this.lengthSizeMinusOne = o & 3;
  }), g.SampleEntry.prototype.isVideo = function() {
    return !1;
  }, g.SampleEntry.prototype.isAudio = function() {
    return !1;
  }, g.SampleEntry.prototype.isSubtitle = function() {
    return !1;
  }, g.SampleEntry.prototype.isMetadata = function() {
    return !1;
  }, g.SampleEntry.prototype.isHint = function() {
    return !1;
  }, g.SampleEntry.prototype.getCodec = function() {
    return this.type.replace(".", "");
  }, g.SampleEntry.prototype.getWidth = function() {
    return "";
  }, g.SampleEntry.prototype.getHeight = function() {
    return "";
  }, g.SampleEntry.prototype.getChannelCount = function() {
    return "";
  }, g.SampleEntry.prototype.getSampleRate = function() {
    return "";
  }, g.SampleEntry.prototype.getSampleSize = function() {
    return "";
  }, g.VisualSampleEntry.prototype.isVideo = function() {
    return !0;
  }, g.VisualSampleEntry.prototype.getWidth = function() {
    return this.width;
  }, g.VisualSampleEntry.prototype.getHeight = function() {
    return this.height;
  }, g.AudioSampleEntry.prototype.isAudio = function() {
    return !0;
  }, g.AudioSampleEntry.prototype.getChannelCount = function() {
    return this.channel_count;
  }, g.AudioSampleEntry.prototype.getSampleRate = function() {
    return this.samplerate;
  }, g.AudioSampleEntry.prototype.getSampleSize = function() {
    return this.samplesize;
  }, g.SubtitleSampleEntry.prototype.isSubtitle = function() {
    return !0;
  }, g.MetadataSampleEntry.prototype.isMetadata = function() {
    return !0;
  }, g.decimalToHex = function(n, o) {
    var l = Number(n).toString(16);
    for (o = typeof o == "undefined" || o === null ? o = 2 : o; l.length < o; )
      l = "0" + l;
    return l;
  }, g.avc1SampleEntry.prototype.getCodec = g.avc2SampleEntry.prototype.getCodec = g.avc3SampleEntry.prototype.getCodec = g.avc4SampleEntry.prototype.getCodec = function() {
    var n = g.SampleEntry.prototype.getCodec.call(this);
    return this.avcC ? n + "." + g.decimalToHex(this.avcC.AVCProfileIndication) + g.decimalToHex(this.avcC.profile_compatibility) + g.decimalToHex(this.avcC.AVCLevelIndication) : n;
  }, g.hev1SampleEntry.prototype.getCodec = g.hvc1SampleEntry.prototype.getCodec = function() {
    var n, o = g.SampleEntry.prototype.getCodec.call(this);
    if (this.hvcC) {
      switch (o += ".", this.hvcC.general_profile_space) {
        case 0:
          o += "";
          break;
        case 1:
          o += "A";
          break;
        case 2:
          o += "B";
          break;
        case 3:
          o += "C";
          break;
      }
      o += this.hvcC.general_profile_idc, o += ".";
      var l = this.hvcC.general_profile_compatibility, h = 0;
      for (n = 0; n < 32 && (h |= l & 1, n != 31); n++)
        h <<= 1, l >>= 1;
      o += g.decimalToHex(h, 0), o += ".", this.hvcC.general_tier_flag === 0 ? o += "L" : o += "H", o += this.hvcC.general_level_idc;
      var p = !1, z = "";
      for (n = 5; n >= 0; n--)
        (this.hvcC.general_constraint_indicator[n] || p) && (z = "." + g.decimalToHex(this.hvcC.general_constraint_indicator[n], 0) + z, p = !0);
      o += z;
    }
    return o;
  }, g.vvc1SampleEntry.prototype.getCodec = g.vvi1SampleEntry.prototype.getCodec = function() {
    var n, o = g.SampleEntry.prototype.getCodec.call(this);
    if (this.vvcC) {
      o += "." + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? o += ".H" : o += ".L", o += this.vvcC.general_level_idc;
      var l = "";
      if (this.vvcC.general_constraint_info) {
        var h = [], p = 0;
        p |= this.vvcC.ptl_frame_only_constraint << 7, p |= this.vvcC.ptl_multilayer_enabled << 6;
        var z;
        for (n = 0; n < this.vvcC.general_constraint_info.length; ++n)
          p |= this.vvcC.general_constraint_info[n] >> 2 & 63, h.push(p), p && (z = n), p = this.vvcC.general_constraint_info[n] >> 2 & 3;
        if (z === void 0)
          l = ".CA";
        else {
          l = ".C";
          var Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", V = 0, Q = 0;
          for (n = 0; n <= z; ++n)
            for (V = V << 8 | h[n], Q += 8; Q >= 5; ) {
              var vt = V >> Q - 5 & 31;
              l += Z[vt], Q -= 5, V &= (1 << Q) - 1;
            }
          Q && (V <<= 5 - Q, l += Z[V & 31]);
        }
      }
      o += l;
    }
    return o;
  }, g.mp4aSampleEntry.prototype.getCodec = function() {
    var n = g.SampleEntry.prototype.getCodec.call(this);
    if (this.esds && this.esds.esd) {
      var o = this.esds.esd.getOTI(), l = this.esds.esd.getAudioConfig();
      return n + "." + g.decimalToHex(o) + (l ? "." + l : "");
    } else
      return n;
  }, g.stxtSampleEntry.prototype.getCodec = function() {
    var n = g.SampleEntry.prototype.getCodec.call(this);
    return this.mime_format ? n + "." + this.mime_format : n;
  }, g.vp08SampleEntry.prototype.getCodec = g.vp09SampleEntry.prototype.getCodec = function() {
    var n = g.SampleEntry.prototype.getCodec.call(this), o = this.vpcC.level;
    o == 0 && (o = "00");
    var l = this.vpcC.bitDepth;
    return l == 8 && (l = "08"), n + ".0" + this.vpcC.profile + "." + o + "." + l;
  }, g.av01SampleEntry.prototype.getCodec = function() {
    var n = g.SampleEntry.prototype.getCodec.call(this), o = this.av1C.seq_level_idx_0;
    o < 10 && (o = "0" + o);
    var l;
    return this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1 ? l = this.av1C.twelve_bit === 1 ? "12" : "10" : this.av1C.seq_profile <= 2 && (l = this.av1C.high_bitdepth === 1 ? "10" : "08"), n + "." + this.av1C.seq_profile + "." + o + (this.av1C.seq_tier_0 ? "H" : "M") + "." + l;
  }, g.Box.prototype.writeHeader = function(n, o) {
    this.size += 8, this.size > I && (this.size += 8), this.type === "uuid" && (this.size += 16), e.debug("BoxWriter", "Writing box " + this.type + " of size: " + this.size + " at position " + n.getPosition() + (o || "")), this.size > I ? n.writeUint32(1) : (this.sizePosition = n.getPosition(), n.writeUint32(this.size)), n.writeString(this.type, null, 4), this.type === "uuid" && n.writeUint8Array(this.uuid), this.size > I && n.writeUint64(this.size);
  }, g.FullBox.prototype.writeHeader = function(n) {
    this.size += 4, g.Box.prototype.writeHeader.call(this, n, " v=" + this.version + " f=" + this.flags), n.writeUint8(this.version), n.writeUint24(this.flags);
  }, g.Box.prototype.write = function(n) {
    this.type === "mdat" ? this.data && (this.size = this.data.length, this.writeHeader(n), n.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(n), this.data && n.writeUint8Array(this.data));
  }, g.ContainerBox.prototype.write = function(n) {
    this.size = 0, this.writeHeader(n);
    for (var o = 0; o < this.boxes.length; o++)
      this.boxes[o] && (this.boxes[o].write(n), this.size += this.boxes[o].size);
    e.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), n.adjustUint32(this.sizePosition, this.size);
  }, g.TrackReferenceTypeBox.prototype.write = function(n) {
    this.size = this.track_ids.length * 4, this.writeHeader(n), n.writeUint32Array(this.track_ids);
  }, g.avcCBox.prototype.write = function(n) {
    var o;
    for (this.size = 7, o = 0; o < this.SPS.length; o++)
      this.size += 2 + this.SPS[o].length;
    for (o = 0; o < this.PPS.length; o++)
      this.size += 2 + this.PPS[o].length;
    for (this.ext && (this.size += this.ext.length), this.writeHeader(n), n.writeUint8(this.configurationVersion), n.writeUint8(this.AVCProfileIndication), n.writeUint8(this.profile_compatibility), n.writeUint8(this.AVCLevelIndication), n.writeUint8(this.lengthSizeMinusOne + 252), n.writeUint8(this.SPS.length + 224), o = 0; o < this.SPS.length; o++)
      n.writeUint16(this.SPS[o].length), n.writeUint8Array(this.SPS[o].nalu);
    for (n.writeUint8(this.PPS.length), o = 0; o < this.PPS.length; o++)
      n.writeUint16(this.PPS[o].length), n.writeUint8Array(this.PPS[o].nalu);
    this.ext && n.writeUint8Array(this.ext);
  }, g.co64Box.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(n), n.writeUint32(this.chunk_offsets.length), o = 0; o < this.chunk_offsets.length; o++)
      n.writeUint64(this.chunk_offsets[o]);
  }, g.cslgBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(n), n.writeInt32(this.compositionToDTSShift), n.writeInt32(this.leastDecodeToDisplayDelta), n.writeInt32(this.greatestDecodeToDisplayDelta), n.writeInt32(this.compositionStartTime), n.writeInt32(this.compositionEndTime);
  }, g.cttsBox.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(n), n.writeUint32(this.sample_counts.length), o = 0; o < this.sample_counts.length; o++)
      n.writeUint32(this.sample_counts[o]), this.version === 1 ? n.writeInt32(this.sample_offsets[o]) : n.writeUint32(this.sample_offsets[o]);
  }, g.drefBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(n), n.writeUint32(this.entries.length);
    for (var o = 0; o < this.entries.length; o++)
      this.entries[o].write(n), this.size += this.entries[o].size;
    e.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), n.adjustUint32(this.sizePosition, this.size);
  }, g.elngBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(n), n.writeString(this.extended_language);
  }, g.elstBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(n), n.writeUint32(this.entries.length);
    for (var o = 0; o < this.entries.length; o++) {
      var l = this.entries[o];
      n.writeUint32(l.segment_duration), n.writeInt32(l.media_time), n.writeInt16(l.media_rate_integer), n.writeInt16(l.media_rate_fraction);
    }
  }, g.emsgBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 * 4 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(n), n.writeCString(this.scheme_id_uri), n.writeCString(this.value), n.writeUint32(this.timescale), n.writeUint32(this.presentation_time_delta), n.writeUint32(this.event_duration), n.writeUint32(this.id), n.writeUint8Array(this.message_data);
  }, g.ftypBox.prototype.write = function(n) {
    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(n), n.writeString(this.major_brand, null, 4), n.writeUint32(this.minor_version);
    for (var o = 0; o < this.compatible_brands.length; o++)
      n.writeString(this.compatible_brands[o], null, 4);
  }, g.hdlrBox.prototype.write = function(n) {
    this.size = 5 * 4 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(n), n.writeUint32(0), n.writeString(this.handler, null, 4), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeCString(this.name);
  }, g.hvcCBox.prototype.write = function(n) {
    var o, l;
    for (this.size = 23, o = 0; o < this.nalu_arrays.length; o++)
      for (this.size += 3, l = 0; l < this.nalu_arrays[o].length; l++)
        this.size += 2 + this.nalu_arrays[o][l].data.length;
    for (this.writeHeader(n), n.writeUint8(this.configurationVersion), n.writeUint8((this.general_profile_space << 6) + (this.general_tier_flag << 5) + this.general_profile_idc), n.writeUint32(this.general_profile_compatibility), n.writeUint8Array(this.general_constraint_indicator), n.writeUint8(this.general_level_idc), n.writeUint16(this.min_spatial_segmentation_idc + (15 << 24)), n.writeUint8(this.parallelismType + 252), n.writeUint8(this.chroma_format_idc + 252), n.writeUint8(this.bit_depth_luma_minus8 + 248), n.writeUint8(this.bit_depth_chroma_minus8 + 248), n.writeUint16(this.avgFrameRate), n.writeUint8((this.constantFrameRate << 6) + (this.numTemporalLayers << 3) + (this.temporalIdNested << 2) + this.lengthSizeMinusOne), n.writeUint8(this.nalu_arrays.length), o = 0; o < this.nalu_arrays.length; o++)
      for (n.writeUint8((this.nalu_arrays[o].completeness << 7) + this.nalu_arrays[o].nalu_type), n.writeUint16(this.nalu_arrays[o].length), l = 0; l < this.nalu_arrays[o].length; l++)
        n.writeUint16(this.nalu_arrays[o][l].data.length), n.writeUint8Array(this.nalu_arrays[o][l].data);
  }, g.kindBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(n), n.writeCString(this.schemeURI), n.writeCString(this.value);
  }, g.mdhdBox.prototype.write = function(n) {
    this.size = 4 * 4 + 2 * 2, this.flags = 0, this.version = 0, this.writeHeader(n), n.writeUint32(this.creation_time), n.writeUint32(this.modification_time), n.writeUint32(this.timescale), n.writeUint32(this.duration), n.writeUint16(this.language), n.writeUint16(0);
  }, g.mehdBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(n), n.writeUint32(this.fragment_duration);
  }, g.mfhdBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(n), n.writeUint32(this.sequence_number);
  }, g.mvhdBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 23 * 4 + 2 * 2, this.writeHeader(n), n.writeUint32(this.creation_time), n.writeUint32(this.modification_time), n.writeUint32(this.timescale), n.writeUint32(this.duration), n.writeUint32(this.rate), n.writeUint16(this.volume << 8), n.writeUint16(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32Array(this.matrix), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32(this.next_track_id);
  }, g.SampleEntry.prototype.writeHeader = function(n) {
    this.size = 8, g.Box.prototype.writeHeader.call(this, n), n.writeUint8(0), n.writeUint8(0), n.writeUint8(0), n.writeUint8(0), n.writeUint8(0), n.writeUint8(0), n.writeUint16(this.data_reference_index);
  }, g.SampleEntry.prototype.writeFooter = function(n) {
    for (var o = 0; o < this.boxes.length; o++)
      this.boxes[o].write(n), this.size += this.boxes[o].size;
    e.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), n.adjustUint32(this.sizePosition, this.size);
  }, g.SampleEntry.prototype.write = function(n) {
    this.writeHeader(n), n.writeUint8Array(this.data), this.size += this.data.length, e.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), n.adjustUint32(this.sizePosition, this.size);
  }, g.VisualSampleEntry.prototype.write = function(n) {
    this.writeHeader(n), this.size += 2 * 7 + 6 * 4 + 32, n.writeUint16(0), n.writeUint16(0), n.writeUint32(0), n.writeUint32(0), n.writeUint32(0), n.writeUint16(this.width), n.writeUint16(this.height), n.writeUint32(this.horizresolution), n.writeUint32(this.vertresolution), n.writeUint32(0), n.writeUint16(this.frame_count), n.writeUint8(Math.min(31, this.compressorname.length)), n.writeString(this.compressorname, null, 31), n.writeUint16(this.depth), n.writeInt16(-1), this.writeFooter(n);
  }, g.AudioSampleEntry.prototype.write = function(n) {
    this.writeHeader(n), this.size += 2 * 4 + 3 * 4, n.writeUint32(0), n.writeUint32(0), n.writeUint16(this.channel_count), n.writeUint16(this.samplesize), n.writeUint16(0), n.writeUint16(0), n.writeUint32(this.samplerate << 16), this.writeFooter(n);
  }, g.stppSampleEntry.prototype.write = function(n) {
    this.writeHeader(n), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, n.writeCString(this.namespace), n.writeCString(this.schema_location), n.writeCString(this.auxiliary_mime_types), this.writeFooter(n);
  }, g.SampleGroupEntry.prototype.write = function(n) {
    n.writeUint8Array(this.data);
  }, g.sbgpBox.prototype.write = function(n) {
    this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(n), n.writeString(this.grouping_type, null, 4), n.writeUint32(this.grouping_type_parameter), n.writeUint32(this.entries.length);
    for (var o = 0; o < this.entries.length; o++) {
      var l = this.entries[o];
      n.writeInt32(l.sample_count), n.writeInt32(l.group_description_index);
    }
  }, g.sgpdBox.prototype.write = function(n) {
    var o, l;
    for (this.flags = 0, this.size = 12, o = 0; o < this.entries.length; o++)
      l = this.entries[o], this.version === 1 && (this.default_length === 0 && (this.size += 4), this.size += l.data.length);
    for (this.writeHeader(n), n.writeString(this.grouping_type, null, 4), this.version === 1 && n.writeUint32(this.default_length), this.version >= 2 && n.writeUint32(this.default_sample_description_index), n.writeUint32(this.entries.length), o = 0; o < this.entries.length; o++)
      l = this.entries[o], this.version === 1 && this.default_length === 0 && n.writeUint32(l.description_length), l.write(n);
  }, g.sidxBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 * 4 + 2 + 2 + 12 * this.references.length, this.writeHeader(n), n.writeUint32(this.reference_ID), n.writeUint32(this.timescale), n.writeUint32(this.earliest_presentation_time), n.writeUint32(this.first_offset), n.writeUint16(0), n.writeUint16(this.references.length);
    for (var o = 0; o < this.references.length; o++) {
      var l = this.references[o];
      n.writeUint32(l.reference_type << 31 | l.referenced_size), n.writeUint32(l.subsegment_duration), n.writeUint32(l.starts_with_SAP << 31 | l.SAP_type << 28 | l.SAP_delta_time);
    }
  }, g.smhdBox.prototype.write = function(n) {
    this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(n), n.writeUint16(this.balance), n.writeUint16(0);
  }, g.stcoBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(n), n.writeUint32(this.chunk_offsets.length), n.writeUint32Array(this.chunk_offsets);
  }, g.stscBox.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(n), n.writeUint32(this.first_chunk.length), o = 0; o < this.first_chunk.length; o++)
      n.writeUint32(this.first_chunk[o]), n.writeUint32(this.samples_per_chunk[o]), n.writeUint32(this.sample_description_index[o]);
  }, g.stsdBox.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(n), n.writeUint32(this.entries.length), this.size += 4, o = 0; o < this.entries.length; o++)
      this.entries[o].write(n), this.size += this.entries[o].size;
    e.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), n.adjustUint32(this.sizePosition, this.size);
  }, g.stshBox.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(n), n.writeUint32(this.shadowed_sample_numbers.length), o = 0; o < this.shadowed_sample_numbers.length; o++)
      n.writeUint32(this.shadowed_sample_numbers[o]), n.writeUint32(this.sync_sample_numbers[o]);
  }, g.stssBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(n), n.writeUint32(this.sample_numbers.length), n.writeUint32Array(this.sample_numbers);
  }, g.stszBox.prototype.write = function(n) {
    var o, l = !0;
    if (this.version = 0, this.flags = 0, this.sample_sizes.length > 0)
      for (o = 0; o + 1 < this.sample_sizes.length; )
        if (this.sample_sizes[o + 1] !== this.sample_sizes[0]) {
          l = !1;
          break;
        } else
          o++;
    else
      l = !1;
    this.size = 8, l || (this.size += 4 * this.sample_sizes.length), this.writeHeader(n), l ? n.writeUint32(this.sample_sizes[0]) : n.writeUint32(0), n.writeUint32(this.sample_sizes.length), l || n.writeUint32Array(this.sample_sizes);
  }, g.sttsBox.prototype.write = function(n) {
    var o;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(n), n.writeUint32(this.sample_counts.length), o = 0; o < this.sample_counts.length; o++)
      n.writeUint32(this.sample_counts[o]), n.writeUint32(this.sample_deltas[o]);
  }, g.tfdtBox.prototype.write = function(n) {
    var o = Math.pow(2, 32) - 1;
    this.version = this.baseMediaDecodeTime > o ? 1 : 0, this.flags = 0, this.size = 4, this.version === 1 && (this.size += 4), this.writeHeader(n), this.version === 1 ? n.writeUint64(this.baseMediaDecodeTime) : n.writeUint32(this.baseMediaDecodeTime);
  }, g.tfhdBox.prototype.write = function(n) {
    this.version = 0, this.size = 4, this.flags & g.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & g.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & g.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & g.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & g.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(n), n.writeUint32(this.track_id), this.flags & g.TFHD_FLAG_BASE_DATA_OFFSET && n.writeUint64(this.base_data_offset), this.flags & g.TFHD_FLAG_SAMPLE_DESC && n.writeUint32(this.default_sample_description_index), this.flags & g.TFHD_FLAG_SAMPLE_DUR && n.writeUint32(this.default_sample_duration), this.flags & g.TFHD_FLAG_SAMPLE_SIZE && n.writeUint32(this.default_sample_size), this.flags & g.TFHD_FLAG_SAMPLE_FLAGS && n.writeUint32(this.default_sample_flags);
  }, g.tkhdBox.prototype.write = function(n) {
    this.version = 0, this.size = 4 * 18 + 2 * 4, this.writeHeader(n), n.writeUint32(this.creation_time), n.writeUint32(this.modification_time), n.writeUint32(this.track_id), n.writeUint32(0), n.writeUint32(this.duration), n.writeUint32(0), n.writeUint32(0), n.writeInt16(this.layer), n.writeInt16(this.alternate_group), n.writeInt16(this.volume << 8), n.writeUint16(0), n.writeInt32Array(this.matrix), n.writeUint32(this.width), n.writeUint32(this.height);
  }, g.trexBox.prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(n), n.writeUint32(this.track_id), n.writeUint32(this.default_sample_description_index), n.writeUint32(this.default_sample_duration), n.writeUint32(this.default_sample_size), n.writeUint32(this.default_sample_flags);
  }, g.trunBox.prototype.write = function(n) {
    this.version = 0, this.size = 4, this.flags & g.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & g.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & g.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & g.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & g.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & g.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(n), n.writeUint32(this.sample_count), this.flags & g.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = n.getPosition(), n.writeInt32(this.data_offset)), this.flags & g.TRUN_FLAGS_FIRST_FLAG && n.writeUint32(this.first_sample_flags);
    for (var o = 0; o < this.sample_count; o++)
      this.flags & g.TRUN_FLAGS_DURATION && n.writeUint32(this.sample_duration[o]), this.flags & g.TRUN_FLAGS_SIZE && n.writeUint32(this.sample_size[o]), this.flags & g.TRUN_FLAGS_FLAGS && n.writeUint32(this.sample_flags[o]), this.flags & g.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? n.writeUint32(this.sample_composition_time_offset[o]) : n.writeInt32(this.sample_composition_time_offset[o]));
  }, g["url Box"].prototype.write = function(n) {
    this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(n), this.location && n.writeCString(this.location);
  }, g["urn Box"].prototype.write = function(n) {
    this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(n), n.writeCString(this.name), this.location && n.writeCString(this.location);
  }, g.vmhdBox.prototype.write = function(n) {
    this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(n), n.writeUint16(this.graphicsmode), n.writeUint16Array(this.opcolor);
  }, g.cttsBox.prototype.unpack = function(n) {
    var o, l, h;
    for (h = 0, o = 0; o < this.sample_counts.length; o++)
      for (l = 0; l < this.sample_counts[o]; l++)
        n[h].pts = n[h].dts + this.sample_offsets[o], h++;
  }, g.sttsBox.prototype.unpack = function(n) {
    var o, l, h;
    for (h = 0, o = 0; o < this.sample_counts.length; o++)
      for (l = 0; l < this.sample_counts[o]; l++)
        h === 0 ? n[h].dts = 0 : n[h].dts = n[h - 1].dts + this.sample_deltas[o], h++;
  }, g.stcoBox.prototype.unpack = function(n) {
    var o;
    for (o = 0; o < this.chunk_offsets.length; o++)
      n[o].offset = this.chunk_offsets[o];
  }, g.stscBox.prototype.unpack = function(n) {
    var o, l, h, p, z;
    for (p = 0, z = 0, o = 0; o < this.first_chunk.length; o++)
      for (l = 0; l < (o + 1 < this.first_chunk.length ? this.first_chunk[o + 1] : 1 / 0); l++)
        for (z++, h = 0; h < this.samples_per_chunk[o]; h++) {
          if (n[p])
            n[p].description_index = this.sample_description_index[o], n[p].chunk_index = z;
          else
            return;
          p++;
        }
  }, g.stszBox.prototype.unpack = function(n) {
    var o;
    for (o = 0; o < this.sample_sizes.length; o++)
      n[o].size = this.sample_sizes[o];
  }, g.DIFF_BOXES_PROP_NAMES = [
    "boxes",
    "entries",
    "references",
    "subsamples",
    "items",
    "item_infos",
    "extents",
    "associations",
    "subsegments",
    "ranges",
    "seekLists",
    "seekPoints",
    "esd",
    "levels"
  ], g.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [
    "compatible_brands",
    "matrix",
    "opcolor",
    "sample_counts",
    "sample_deltas",
    "first_chunk",
    "samples_per_chunk",
    "sample_sizes",
    "chunk_offsets",
    "sample_offsets",
    "sample_description_index",
    "sample_duration"
  ], g.boxEqualFields = function(n, o) {
    if (n && !o) return !1;
    var l;
    for (l in n)
      if (!(g.DIFF_BOXES_PROP_NAMES.indexOf(l) > -1)) {
        if (n[l] instanceof g.Box || o[l] instanceof g.Box)
          continue;
        if (typeof n[l] == "undefined" || typeof o[l] == "undefined")
          continue;
        if (typeof n[l] == "function" || typeof o[l] == "function")
          continue;
        if (n.subBoxNames && n.subBoxNames.indexOf(l.slice(0, 4)) > -1 || o.subBoxNames && o.subBoxNames.indexOf(l.slice(0, 4)) > -1)
          continue;
        if (l === "data" || l === "start" || l === "size" || l === "creation_time" || l === "modification_time")
          continue;
        if (g.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(l) > -1)
          continue;
        if (n[l] !== o[l])
          return !1;
      }
    return !0;
  }, g.boxEqual = function(n, o) {
    if (!g.boxEqualFields(n, o))
      return !1;
    for (var l = 0; l < g.DIFF_BOXES_PROP_NAMES.length; l++) {
      var h = g.DIFF_BOXES_PROP_NAMES[l];
      if (n[h] && o[h] && !g.boxEqual(n[h], o[h]))
        return !1;
    }
    return !0;
  };
  var d = function() {
  };
  d.prototype.parseSample = function(n) {
    var o, l, h = new r(n.buffer);
    for (o = []; !h.isEos(); )
      l = g.parseOneBox(h, !1), l.code === g.OK && l.box.type === "vttc" && o.push(l.box);
    return o;
  }, d.prototype.getText = function(n, o, l) {
    function h(vt, Lt, zt) {
      return zt = zt || "0", vt = vt + "", vt.length >= Lt ? vt : new Array(Lt - vt.length + 1).join(zt) + vt;
    }
    function p(vt) {
      var Lt = Math.floor(vt / 3600), zt = Math.floor((vt - Lt * 3600) / 60), X = Math.floor(vt - Lt * 3600 - zt * 60), D = Math.floor((vt - Lt * 3600 - zt * 60 - X) * 1e3);
      return "" + h(Lt, 2) + ":" + h(zt, 2) + ":" + h(X, 2) + "." + h(D, 3);
    }
    for (var z = this.parseSample(l), Z = "", V = 0; V < z.length; V++) {
      var Q = z[V];
      Z += p(n) + " --> " + p(o) + `\r
`, Z += Q.payl.text;
    }
    return Z;
  };
  var m = function() {
  };
  m.prototype.parseSample = function(n) {
    var o = {}, l;
    o.resources = [];
    var h = new r(n.data.buffer);
    if (!n.subsamples || n.subsamples.length === 0)
      o.documentString = h.readString(n.data.length);
    else if (o.documentString = h.readString(n.subsamples[0].size), n.subsamples.length > 1)
      for (l = 1; l < n.subsamples.length; l++)
        o.resources[l] = h.readUint8Array(n.subsamples[l].size);
    return typeof DOMParser != "undefined" && (o.document = new DOMParser().parseFromString(o.documentString, "application/xml")), o;
  };
  var b = function() {
  };
  b.prototype.parseSample = function(n) {
    var o, l = new r(n.data.buffer);
    return o = l.readString(n.data.length), o;
  }, b.prototype.parseConfig = function(n) {
    var o, l = new r(n.buffer);
    return l.readUint32(), o = l.readCString(), o;
  }, t.VTTin4Parser = d, t.XMLSubtitlein4Parser = m, t.Textin4Parser = b;
  var y = function(n) {
    this.stream = n || new E(), this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.items = [], this.entity_groups = [], this.onSidx = null, this.sidxSent = !1;
  };
  y.prototype.setSegmentOptions = function(n, o, l) {
    var h = this.getTrackById(n);
    if (h) {
      var p = {};
      this.fragmentedTracks.push(p), p.id = n, p.user = o, p.trak = h, h.nextSample = 0, p.segmentStream = null, p.nb_samples = 1e3, p.rapAlignement = !0, l && (l.nbSamples && (p.nb_samples = l.nbSamples), l.rapAlignement && (p.rapAlignement = l.rapAlignement));
    }
  }, y.prototype.unsetSegmentOptions = function(n) {
    for (var o = -1, l = 0; l < this.fragmentedTracks.length; l++) {
      var h = this.fragmentedTracks[l];
      h.id == n && (o = l);
    }
    o > -1 && this.fragmentedTracks.splice(o, 1);
  }, y.prototype.setExtractionOptions = function(n, o, l) {
    var h = this.getTrackById(n);
    if (h) {
      var p = {};
      this.extractedTracks.push(p), p.id = n, p.user = o, p.trak = h, h.nextSample = 0, p.nb_samples = 1e3, p.samples = [], l && l.nbSamples && (p.nb_samples = l.nbSamples);
    }
  }, y.prototype.unsetExtractionOptions = function(n) {
    for (var o = -1, l = 0; l < this.extractedTracks.length; l++) {
      var h = this.extractedTracks[l];
      h.id == n && (o = l);
    }
    o > -1 && this.extractedTracks.splice(o, 1);
  }, y.prototype.parse = function() {
    var n, o, l = !1;
    if (!(this.restoreParsePosition && !this.restoreParsePosition()))
      for (; ; )
        if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {
          if (this.processIncompleteMdat())
            continue;
          return;
        } else if (this.saveParsePosition && this.saveParsePosition(), n = g.parseOneBox(this.stream, l), n.code === g.ERR_NOT_ENOUGH_DATA)
          if (this.processIncompleteBox) {
            if (this.processIncompleteBox(n))
              continue;
            return;
          } else
            return;
        else {
          var h;
          switch (o = n.box, h = o.type !== "uuid" ? o.type : o.uuid, this.boxes.push(o), h) {
            case "mdat":
              this.mdats.push(o);
              break;
            case "moof":
              this.moofs.push(o);
              break;
            case "moov":
              this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0);
            default:
              this[h] !== void 0 && e.warn("ISOFile", "Duplicate Box of type: " + h + ", overriding previous occurrence"), this[h] = o;
              break;
          }
          this.updateUsedBytes && this.updateUsedBytes(o, n);
        }
  }, y.prototype.checkBuffer = function(n) {
    if (n == null)
      throw "Buffer must be defined and non empty";
    if (n.fileStart === void 0)
      throw "Buffer must have a fileStart property";
    return n.byteLength === 0 ? (e.warn("ISOFile", "Ignoring empty buffer (fileStart: " + n.fileStart + ")"), this.stream.logBufferLevel(), !1) : (e.info("ISOFile", "Processing buffer (fileStart: " + n.fileStart + ")"), n.usedBytes = 0, this.stream.insertBuffer(n), this.stream.logBufferLevel(), this.stream.initialized() ? !0 : (e.warn("ISOFile", "Not ready to start parsing"), !1));
  }, y.prototype.appendBuffer = function(n, o) {
    var l;
    if (this.checkBuffer(n))
      return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(o), this.nextSeekPosition ? (l = this.nextSeekPosition, this.nextSeekPosition = void 0) : l = this.nextParsePosition, this.stream.getEndFilePositionAfter && (l = this.stream.getEndFilePositionAfter(l))) : this.nextParsePosition ? l = this.nextParsePosition : l = 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (e.info("ISOFile", "Done processing buffer (fileStart: " + n.fileStart + ") - next buffer to fetch should have a fileStart position of " + l), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), e.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize())), l;
  }, y.prototype.getInfo = function() {
    var n, o, l = {}, h, p, z, Z, V = (/* @__PURE__ */ new Date("1904-01-01T00:00:00Z")).getTime();
    if (this.moov)
      for (l.hasMoov = !0, l.duration = this.moov.mvhd.duration, l.timescale = this.moov.mvhd.timescale, l.isFragmented = this.moov.mvex != null, l.isFragmented && this.moov.mvex.mehd && (l.fragment_duration = this.moov.mvex.mehd.fragment_duration), l.isProgressive = this.isProgressive, l.hasIOD = this.moov.iods != null, l.brands = [], l.brands.push(this.ftyp.major_brand), l.brands = l.brands.concat(this.ftyp.compatible_brands), l.created = new Date(V + this.moov.mvhd.creation_time * 1e3), l.modified = new Date(V + this.moov.mvhd.modification_time * 1e3), l.tracks = [], l.audioTracks = [], l.videoTracks = [], l.subtitleTracks = [], l.metadataTracks = [], l.hintTracks = [], l.otherTracks = [], n = 0; n < this.moov.traks.length; n++) {
        if (h = this.moov.traks[n], Z = h.mdia.minf.stbl.stsd.entries[0], p = {}, l.tracks.push(p), p.id = h.tkhd.track_id, p.name = h.mdia.hdlr.name, p.references = [], h.tref)
          for (o = 0; o < h.tref.boxes.length; o++)
            z = {}, p.references.push(z), z.type = h.tref.boxes[o].type, z.track_ids = h.tref.boxes[o].track_ids;
        h.edts && (p.edits = h.edts.elst.entries), p.created = new Date(V + h.tkhd.creation_time * 1e3), p.modified = new Date(V + h.tkhd.modification_time * 1e3), p.movie_duration = h.tkhd.duration, p.movie_timescale = l.timescale, p.layer = h.tkhd.layer, p.alternate_group = h.tkhd.alternate_group, p.volume = h.tkhd.volume, p.matrix = h.tkhd.matrix, p.track_width = h.tkhd.width / 65536, p.track_height = h.tkhd.height / 65536, p.timescale = h.mdia.mdhd.timescale, p.cts_shift = h.mdia.minf.stbl.cslg, p.duration = h.mdia.mdhd.duration, p.samples_duration = h.samples_duration, p.codec = Z.getCodec(), p.kind = h.udta && h.udta.kinds.length ? h.udta.kinds[0] : { schemeURI: "", value: "" }, p.language = h.mdia.elng ? h.mdia.elng.extended_language : h.mdia.mdhd.languageString, p.nb_samples = h.samples.length, p.size = h.samples_size, p.bitrate = p.size * 8 * p.timescale / p.samples_duration, Z.isAudio() ? (p.type = "audio", l.audioTracks.push(p), p.audio = {}, p.audio.sample_rate = Z.getSampleRate(), p.audio.channel_count = Z.getChannelCount(), p.audio.sample_size = Z.getSampleSize()) : Z.isVideo() ? (p.type = "video", l.videoTracks.push(p), p.video = {}, p.video.width = Z.getWidth(), p.video.height = Z.getHeight()) : Z.isSubtitle() ? (p.type = "subtitles", l.subtitleTracks.push(p)) : Z.isHint() ? (p.type = "metadata", l.hintTracks.push(p)) : Z.isMetadata() ? (p.type = "metadata", l.metadataTracks.push(p)) : (p.type = "metadata", l.otherTracks.push(p));
      }
    else
      l.hasMoov = !1;
    if (l.mime = "", l.hasMoov && l.tracks) {
      for (l.videoTracks && l.videoTracks.length > 0 ? l.mime += 'video/mp4; codecs="' : l.audioTracks && l.audioTracks.length > 0 ? l.mime += 'audio/mp4; codecs="' : l.mime += 'application/mp4; codecs="', n = 0; n < l.tracks.length; n++)
        n !== 0 && (l.mime += ","), l.mime += l.tracks[n].codec;
      l.mime += '"; profiles="', l.mime += this.ftyp.compatible_brands.join(), l.mime += '"';
    }
    return l;
  }, y.prototype.setNextSeekPositionFromSample = function(n) {
    n && (this.nextSeekPosition ? this.nextSeekPosition = Math.min(n.offset + n.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = n.offset + n.alreadyRead);
  }, y.prototype.processSamples = function(n) {
    var o, l;
    if (this.sampleProcessingStarted) {
      if (this.isFragmentationInitialized && this.onSegment !== null)
        for (o = 0; o < this.fragmentedTracks.length; o++) {
          var h = this.fragmentedTracks[o];
          for (l = h.trak; l.nextSample < l.samples.length && this.sampleProcessingStarted; ) {
            e.debug("ISOFile", "Creating media fragment on track #" + h.id + " for sample " + l.nextSample);
            var p = this.createFragment(h.id, l.nextSample, h.segmentStream);
            if (p)
              h.segmentStream = p, l.nextSample++;
            else
              break;
            if ((l.nextSample % h.nb_samples === 0 || n || l.nextSample >= l.samples.length) && (e.info("ISOFile", "Sending fragmented data on track #" + h.id + " for samples [" + Math.max(0, l.nextSample - h.nb_samples) + "," + (l.nextSample - 1) + "]"), e.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(h.id, h.user, h.segmentStream.buffer, l.nextSample, n || l.nextSample >= l.samples.length), h.segmentStream = null, h !== this.fragmentedTracks[o]))
              break;
          }
        }
      if (this.onSamples !== null)
        for (o = 0; o < this.extractedTracks.length; o++) {
          var z = this.extractedTracks[o];
          for (l = z.trak; l.nextSample < l.samples.length && this.sampleProcessingStarted; ) {
            e.debug("ISOFile", "Exporting on track #" + z.id + " sample #" + l.nextSample);
            var Z = this.getSample(l, l.nextSample);
            if (Z)
              l.nextSample++, z.samples.push(Z);
            else {
              this.setNextSeekPositionFromSample(l.samples[l.nextSample]);
              break;
            }
            if ((l.nextSample % z.nb_samples === 0 || l.nextSample >= l.samples.length) && (e.debug("ISOFile", "Sending samples on track #" + z.id + " for sample " + l.nextSample), this.onSamples && this.onSamples(z.id, z.user, z.samples), z.samples = [], z !== this.extractedTracks[o]))
              break;
          }
        }
    }
  }, y.prototype.getBox = function(n) {
    var o = this.getBoxes(n, !0);
    return o.length ? o[0] : null;
  }, y.prototype.getBoxes = function(n, o) {
    var l = [];
    return y._sweep.call(this, n, l, o), l;
  }, y._sweep = function(n, o, l) {
    this.type && this.type == n && o.push(this);
    for (var h in this.boxes) {
      if (o.length && l) return;
      y._sweep.call(this.boxes[h], n, o, l);
    }
  }, y.prototype.getTrackSamplesInfo = function(n) {
    var o = this.getTrackById(n);
    if (o)
      return o.samples;
  }, y.prototype.getTrackSample = function(n, o) {
    var l = this.getTrackById(n), h = this.getSample(l, o);
    return h;
  }, y.prototype.releaseUsedSamples = function(n, o) {
    var l = 0, h = this.getTrackById(n);
    h.lastValidSample || (h.lastValidSample = 0);
    for (var p = h.lastValidSample; p < o; p++)
      l += this.releaseSample(h, p);
    e.info("ISOFile", "Track #" + n + " released samples up to " + o + " (released size: " + l + ", remaining: " + this.samplesDataSize + ")"), h.lastValidSample = o;
  }, y.prototype.start = function() {
    this.sampleProcessingStarted = !0, this.processSamples(!1);
  }, y.prototype.stop = function() {
    this.sampleProcessingStarted = !1;
  }, y.prototype.flush = function() {
    e.info("ISOFile", "Flushing remaining samples"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0);
  }, y.prototype.seekTrack = function(n, o, l) {
    var h, p, z = 1 / 0, Z = 0, V = 0, Q;
    if (l.samples.length === 0)
      return e.info("ISOFile", "No sample in track, cannot seek! Using time " + e.getDurationString(0, 1) + " and offset: 0"), { offset: 0, time: 0 };
    for (h = 0; h < l.samples.length; h++) {
      if (p = l.samples[h], h === 0)
        V = 0, Q = p.timescale;
      else if (p.cts > n * p.timescale) {
        V = h - 1;
        break;
      }
      o && p.is_sync && (Z = h);
    }
    for (o && (V = Z), n = l.samples[V].cts, l.nextSample = V; l.samples[V].alreadyRead === l.samples[V].size && l.samples[V + 1]; )
      V++;
    return z = l.samples[V].offset + l.samples[V].alreadyRead, e.info("ISOFile", "Seeking to " + (o ? "RAP" : "") + " sample #" + l.nextSample + " on track " + l.tkhd.track_id + ", time " + e.getDurationString(n, Q) + " and offset: " + z), { offset: z, time: n / Q };
  }, y.prototype.getTrackDuration = function(n) {
    var o;
    return n.samples ? (o = n.samples[n.samples.length - 1], (o.cts + o.duration) / o.timescale) : 1 / 0;
  }, y.prototype.seek = function(n, o) {
    var l = this.moov, h, p, z, Z = { offset: 1 / 0, time: 1 / 0 };
    if (this.moov) {
      for (z = 0; z < l.traks.length; z++)
        h = l.traks[z], !(n > this.getTrackDuration(h)) && (p = this.seekTrack(n, o, h), p.offset < Z.offset && (Z.offset = p.offset), p.time < Z.time && (Z.time = p.time));
      return e.info("ISOFile", "Seeking at time " + e.getDurationString(Z.time, 1) + " needs a buffer with a fileStart position of " + Z.offset), Z.offset === 1 / 0 ? Z = { offset: this.nextParsePosition, time: 0 } : Z.offset = this.stream.getEndFilePositionAfter(Z.offset), e.info("ISOFile", "Adjusted seek position (after checking data already in buffer): " + Z.offset), Z;
    } else
      throw "Cannot seek: moov not received!";
  }, y.prototype.equal = function(n) {
    for (var o = 0; o < this.boxes.length && o < n.boxes.length; ) {
      var l = this.boxes[o], h = n.boxes[o];
      if (!g.boxEqual(l, h))
        return !1;
      o++;
    }
    return !0;
  }, t.ISOFile = y, y.prototype.lastBoxStartPosition = 0, y.prototype.parsingMdat = null, y.prototype.nextParsePosition = 0, y.prototype.discardMdatData = !1, y.prototype.processIncompleteBox = function(n) {
    var o, l, h;
    return n.type === "mdat" ? (o = new g[n.type + "Box"](n.size), this.parsingMdat = o, this.boxes.push(o), this.mdats.push(o), o.start = n.start, o.hdr_size = n.hdr_size, this.stream.addUsedBytes(o.hdr_size), this.lastBoxStartPosition = o.start + o.size, h = this.stream.seek(o.start + o.size, !1, this.discardMdatData), h ? (this.parsingMdat = null, !0) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = o.start + o.size, !1)) : (n.type === "moov" && (this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0)), l = this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : !1, l ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (n.type ? this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + n.size : this.nextParsePosition = this.stream.getEndPosition(), !1));
  }, y.prototype.hasIncompleteMdat = function() {
    return this.parsingMdat !== null;
  }, y.prototype.processIncompleteMdat = function() {
    var n, o;
    return n = this.parsingMdat, o = this.stream.seek(n.start + n.size, !1, this.discardMdatData), o ? (e.debug("ISOFile", "Found 'mdat' end in buffered data"), this.parsingMdat = null, !0) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1);
  }, y.prototype.restoreParsePosition = function() {
    return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData);
  }, y.prototype.saveParsePosition = function() {
    this.lastBoxStartPosition = this.stream.getPosition();
  }, y.prototype.updateUsedBytes = function(n, o) {
    this.stream.addUsedBytes && (n.type === "mdat" ? (this.stream.addUsedBytes(n.hdr_size), this.discardMdatData && this.stream.addUsedBytes(n.size - n.hdr_size)) : this.stream.addUsedBytes(n.size));
  }, y.prototype.add = g.Box.prototype.add, y.prototype.addBox = g.Box.prototype.addBox, y.prototype.init = function(n) {
    var o = n || {};
    this.add("ftyp").set("major_brand", o.brands && o.brands[0] || "iso4").set("minor_version", 0).set("compatible_brands", o.brands || ["iso4"]);
    var l = this.add("moov");
    return l.add("mvhd").set("timescale", o.timescale || 600).set("rate", o.rate || 65536).set("creation_time", 0).set("modification_time", 0).set("duration", o.duration || 0).set("volume", o.width ? 0 : 256).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("next_track_id", 1), l.add("mvex"), this;
  }, y.prototype.addTrack = function(n) {
    this.moov || this.init(n);
    var o = n || {};
    o.width = o.width || 320, o.height = o.height || 320, o.id = o.id || this.moov.mvhd.next_track_id, o.type = o.type || "avc1";
    var l = this.moov.add("trak");
    this.moov.mvhd.next_track_id = o.id + 1, l.add("tkhd").set("flags", g.TKHD_FLAG_ENABLED | g.TKHD_FLAG_IN_MOVIE | g.TKHD_FLAG_IN_PREVIEW).set("creation_time", 0).set("modification_time", 0).set("track_id", o.id).set("duration", o.duration || 0).set("layer", o.layer || 0).set("alternate_group", 0).set("volume", 1).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("width", o.width << 16).set("height", o.height << 16);
    var h = l.add("mdia");
    h.add("mdhd").set("creation_time", 0).set("modification_time", 0).set("timescale", o.timescale || 1).set("duration", o.media_duration || 0).set("language", o.language || "und"), h.add("hdlr").set("handler", o.hdlr || "vide").set("name", o.name || "Track created with MP4Box.js"), h.add("elng").set("extended_language", o.language || "fr-FR");
    var p = h.add("minf");
    if (g[o.type + "SampleEntry"] !== void 0) {
      var z = new g[o.type + "SampleEntry"]();
      z.data_reference_index = 1;
      var Z = "";
      for (var V in g.sampleEntryCodes)
        for (var Q = g.sampleEntryCodes[V], vt = 0; vt < Q.length; vt++)
          if (Q.indexOf(o.type) > -1) {
            Z = V;
            break;
          }
      switch (Z) {
        case "Visual":
          if (p.add("vmhd").set("graphicsmode", 0).set("opcolor", [0, 0, 0]), z.set("width", o.width).set("height", o.height).set("horizresolution", 72 << 16).set("vertresolution", 72 << 16).set("frame_count", 1).set("compressorname", o.type + " Compressor").set("depth", 24), o.avcDecoderConfigRecord) {
            var Lt = new g.avcCBox();
            Lt.parse(new r(o.avcDecoderConfigRecord)), z.addBox(Lt);
          } else if (o.hevcDecoderConfigRecord) {
            var zt = new g.hvcCBox();
            zt.parse(new r(o.hevcDecoderConfigRecord)), z.addBox(zt);
          }
          break;
        case "Audio":
          p.add("smhd").set("balance", o.balance || 0), z.set("channel_count", o.channel_count || 2).set("samplesize", o.samplesize || 16).set("samplerate", o.samplerate || 65536);
          break;
        case "Hint":
          p.add("hmhd");
          break;
        case "Subtitle":
          switch (p.add("sthd"), o.type) {
            case "stpp":
              z.set("namespace", o.namespace || "nonamespace").set("schema_location", o.schema_location || "").set("auxiliary_mime_types", o.auxiliary_mime_types || "");
              break;
          }
          break;
        case "Metadata":
          p.add("nmhd");
          break;
        case "System":
          p.add("nmhd");
          break;
        default:
          p.add("nmhd");
          break;
      }
      o.description && z.addBox(o.description), o.description_boxes && o.description_boxes.forEach(function(D) {
        z.addBox(D);
      }), p.add("dinf").add("dref").addEntry(new g["url Box"]().set("flags", 1));
      var X = p.add("stbl");
      return X.add("stsd").addEntry(z), X.add("stts").set("sample_counts", []).set("sample_deltas", []), X.add("stsc").set("first_chunk", []).set("samples_per_chunk", []).set("sample_description_index", []), X.add("stco").set("chunk_offsets", []), X.add("stsz").set("sample_sizes", []), this.moov.mvex.add("trex").set("track_id", o.id).set("default_sample_description_index", o.default_sample_description_index || 1).set("default_sample_duration", o.default_sample_duration || 0).set("default_sample_size", o.default_sample_size || 0).set("default_sample_flags", o.default_sample_flags || 0), this.buildTrakSampleLists(l), o.id;
    }
  }, g.Box.prototype.computeSize = function(n) {
    var o = n || new u();
    o.endianness = u.BIG_ENDIAN, this.write(o);
  }, y.prototype.addSample = function(n, o, l) {
    var h = l || {}, p = {}, z = this.getTrackById(n);
    if (z !== null) {
      p.number = z.samples.length, p.track_id = z.tkhd.track_id, p.timescale = z.mdia.mdhd.timescale, p.description_index = h.sample_description_index ? h.sample_description_index - 1 : 0, p.description = z.mdia.minf.stbl.stsd.entries[p.description_index], p.data = o, p.size = o.byteLength, p.alreadyRead = p.size, p.duration = h.duration || 1, p.cts = h.cts || 0, p.dts = h.dts || 0, p.is_sync = h.is_sync || !1, p.is_leading = h.is_leading || 0, p.depends_on = h.depends_on || 0, p.is_depended_on = h.is_depended_on || 0, p.has_redundancy = h.has_redundancy || 0, p.degradation_priority = h.degradation_priority || 0, p.offset = 0, p.subsamples = h.subsamples, z.samples.push(p), z.samples_size += p.size, z.samples_duration += p.duration, z.first_dts === void 0 && (z.first_dts = h.dts), this.processSamples();
      var Z = this.createSingleSampleMoof(p);
      return this.addBox(Z), Z.computeSize(), Z.trafs[0].truns[0].data_offset = Z.size + 8, this.add("mdat").data = new Uint8Array(o), p;
    }
  }, y.prototype.createSingleSampleMoof = function(n) {
    var o = 0;
    n.is_sync ? o = 1 << 25 : o = 65536;
    var l = new g.moofBox();
    l.add("mfhd").set("sequence_number", this.nextMoofNumber), this.nextMoofNumber++;
    var h = l.add("traf"), p = this.getTrackById(n.track_id);
    return h.add("tfhd").set("track_id", n.track_id).set("flags", g.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), h.add("tfdt").set("baseMediaDecodeTime", n.dts - (p.first_dts || 0)), h.add("trun").set("flags", g.TRUN_FLAGS_DATA_OFFSET | g.TRUN_FLAGS_DURATION | g.TRUN_FLAGS_SIZE | g.TRUN_FLAGS_FLAGS | g.TRUN_FLAGS_CTS_OFFSET).set("data_offset", 0).set("first_sample_flags", 0).set("sample_count", 1).set("sample_duration", [n.duration]).set("sample_size", [n.size]).set("sample_flags", [o]).set("sample_composition_time_offset", [n.cts - n.dts]), l;
  }, y.prototype.lastMoofIndex = 0, y.prototype.samplesDataSize = 0, y.prototype.resetTables = function() {
    var n, o, l, h, p, z, Z, V;
    for (this.initial_duration = this.moov.mvhd.duration, this.moov.mvhd.duration = 0, n = 0; n < this.moov.traks.length; n++) {
      o = this.moov.traks[n], o.tkhd.duration = 0, o.mdia.mdhd.duration = 0, l = o.mdia.minf.stbl.stco || o.mdia.minf.stbl.co64, l.chunk_offsets = [], h = o.mdia.minf.stbl.stsc, h.first_chunk = [], h.samples_per_chunk = [], h.sample_description_index = [], p = o.mdia.minf.stbl.stsz || o.mdia.minf.stbl.stz2, p.sample_sizes = [], z = o.mdia.minf.stbl.stts, z.sample_counts = [], z.sample_deltas = [], Z = o.mdia.minf.stbl.ctts, Z && (Z.sample_counts = [], Z.sample_offsets = []), V = o.mdia.minf.stbl.stss;
      var Q = o.mdia.minf.stbl.boxes.indexOf(V);
      Q != -1 && (o.mdia.minf.stbl.boxes[Q] = null);
    }
  }, y.initSampleGroups = function(n, o, l, h, p) {
    var z, Z, V, Q;
    function vt(Lt, zt, X) {
      this.grouping_type = Lt, this.grouping_type_parameter = zt, this.sbgp = X, this.last_sample_in_run = -1, this.entry_index = -1;
    }
    for (o && (o.sample_groups_info = []), n.sample_groups_info || (n.sample_groups_info = []), Z = 0; Z < l.length; Z++) {
      for (Q = l[Z].grouping_type + "/" + l[Z].grouping_type_parameter, V = new vt(l[Z].grouping_type, l[Z].grouping_type_parameter, l[Z]), o && (o.sample_groups_info[Q] = V), n.sample_groups_info[Q] || (n.sample_groups_info[Q] = V), z = 0; z < h.length; z++)
        h[z].grouping_type === l[Z].grouping_type && (V.description = h[z], V.description.used = !0);
      if (p)
        for (z = 0; z < p.length; z++)
          p[z].grouping_type === l[Z].grouping_type && (V.fragment_description = p[z], V.fragment_description.used = !0, V.is_fragment = !0);
    }
    if (o) {
      if (p)
        for (Z = 0; Z < p.length; Z++)
          !p[Z].used && p[Z].version >= 2 && (Q = p[Z].grouping_type + "/0", V = new vt(p[Z].grouping_type, 0), V.is_fragment = !0, o.sample_groups_info[Q] || (o.sample_groups_info[Q] = V));
    } else
      for (Z = 0; Z < h.length; Z++)
        !h[Z].used && h[Z].version >= 2 && (Q = h[Z].grouping_type + "/0", V = new vt(h[Z].grouping_type, 0), n.sample_groups_info[Q] || (n.sample_groups_info[Q] = V));
  }, y.setSampleGroupProperties = function(n, o, l, h) {
    var p, z;
    o.sample_groups = [];
    for (p in h)
      if (o.sample_groups[p] = {}, o.sample_groups[p].grouping_type = h[p].grouping_type, o.sample_groups[p].grouping_type_parameter = h[p].grouping_type_parameter, l >= h[p].last_sample_in_run && (h[p].last_sample_in_run < 0 && (h[p].last_sample_in_run = 0), h[p].entry_index++, h[p].entry_index <= h[p].sbgp.entries.length - 1 && (h[p].last_sample_in_run += h[p].sbgp.entries[h[p].entry_index].sample_count)), h[p].entry_index <= h[p].sbgp.entries.length - 1 ? o.sample_groups[p].group_description_index = h[p].sbgp.entries[h[p].entry_index].group_description_index : o.sample_groups[p].group_description_index = -1, o.sample_groups[p].group_description_index !== 0) {
        var Z;
        h[p].fragment_description ? Z = h[p].fragment_description : Z = h[p].description, o.sample_groups[p].group_description_index > 0 ? (o.sample_groups[p].group_description_index > 65535 ? z = (o.sample_groups[p].group_description_index >> 16) - 1 : z = o.sample_groups[p].group_description_index - 1, Z && z >= 0 && (o.sample_groups[p].description = Z.entries[z])) : Z && Z.version >= 2 && Z.default_group_description_index > 0 && (o.sample_groups[p].description = Z.entries[Z.default_group_description_index - 1]);
      }
  }, y.process_sdtp = function(n, o, l) {
    o && (n ? (o.is_leading = n.is_leading[l], o.depends_on = n.sample_depends_on[l], o.is_depended_on = n.sample_is_depended_on[l], o.has_redundancy = n.sample_has_redundancy[l]) : (o.is_leading = 0, o.depends_on = 0, o.is_depended_on = 0, o.has_redundancy = 0));
  }, y.prototype.buildSampleLists = function() {
    var n, o;
    for (n = 0; n < this.moov.traks.length; n++)
      o = this.moov.traks[n], this.buildTrakSampleLists(o);
  }, y.prototype.buildTrakSampleLists = function(n) {
    var o, l, h, p, z, Z, V, Q, vt, Lt, zt, X, D, yt, Mt, at, Bt, jt, At, Ce, ne, Ht, Le, sn;
    if (n.samples = [], n.samples_duration = 0, n.samples_size = 0, l = n.mdia.minf.stbl.stco || n.mdia.minf.stbl.co64, h = n.mdia.minf.stbl.stsc, p = n.mdia.minf.stbl.stsz || n.mdia.minf.stbl.stz2, z = n.mdia.minf.stbl.stts, Z = n.mdia.minf.stbl.ctts, V = n.mdia.minf.stbl.stss, Q = n.mdia.minf.stbl.stsd, vt = n.mdia.minf.stbl.subs, X = n.mdia.minf.stbl.stdp, Lt = n.mdia.minf.stbl.sbgps, zt = n.mdia.minf.stbl.sgpds, jt = -1, At = -1, Ce = -1, ne = -1, Ht = 0, Le = 0, sn = 0, y.initSampleGroups(n, null, Lt, zt), typeof p != "undefined") {
      for (o = 0; o < p.sample_sizes.length; o++) {
        var we = {};
        we.number = o, we.track_id = n.tkhd.track_id, we.timescale = n.mdia.mdhd.timescale, we.alreadyRead = 0, n.samples[o] = we, we.size = p.sample_sizes[o], n.samples_size += we.size, o === 0 ? (yt = 1, D = 0, we.chunk_index = yt, we.chunk_run_index = D, Bt = h.samples_per_chunk[D], at = 0, D + 1 < h.first_chunk.length ? Mt = h.first_chunk[D + 1] - 1 : Mt = 1 / 0) : o < Bt ? (we.chunk_index = yt, we.chunk_run_index = D) : (yt++, we.chunk_index = yt, at = 0, yt <= Mt || (D++, D + 1 < h.first_chunk.length ? Mt = h.first_chunk[D + 1] - 1 : Mt = 1 / 0), we.chunk_run_index = D, Bt += h.samples_per_chunk[D]), we.description_index = h.sample_description_index[we.chunk_run_index] - 1, we.description = Q.entries[we.description_index], we.offset = l.chunk_offsets[we.chunk_index - 1] + at, at += we.size, o > jt && (At++, jt < 0 && (jt = 0), jt += z.sample_counts[At]), o > 0 ? (n.samples[o - 1].duration = z.sample_deltas[At], n.samples_duration += n.samples[o - 1].duration, we.dts = n.samples[o - 1].dts + n.samples[o - 1].duration) : we.dts = 0, Z ? (o >= Ce && (ne++, Ce < 0 && (Ce = 0), Ce += Z.sample_counts[ne]), we.cts = n.samples[o].dts + Z.sample_offsets[ne]) : we.cts = we.dts, V ? (o == V.sample_numbers[Ht] - 1 ? (we.is_sync = !0, Ht++) : (we.is_sync = !1, we.degradation_priority = 0), vt && vt.entries[Le].sample_delta + sn == o + 1 && (we.subsamples = vt.entries[Le].subsamples, sn += vt.entries[Le].sample_delta, Le++)) : we.is_sync = !0, y.process_sdtp(n.mdia.minf.stbl.sdtp, we, we.number), X ? we.degradation_priority = X.priority[o] : we.degradation_priority = 0, vt && vt.entries[Le].sample_delta + sn == o && (we.subsamples = vt.entries[Le].subsamples, sn += vt.entries[Le].sample_delta), (Lt.length > 0 || zt.length > 0) && y.setSampleGroupProperties(n, we, o, n.sample_groups_info);
      }
      o > 0 && (n.samples[o - 1].duration = Math.max(n.mdia.mdhd.duration - n.samples[o - 1].dts, 0), n.samples_duration += n.samples[o - 1].duration);
    }
  }, y.prototype.updateSampleLists = function() {
    var n, o, l, h, p, z, Z, V, Q, vt, Lt, zt, X, D, yt;
    if (this.moov !== void 0) {
      for (; this.lastMoofIndex < this.moofs.length; )
        if (Q = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, Q.type == "moof")
          for (vt = Q, n = 0; n < vt.trafs.length; n++) {
            for (Lt = vt.trafs[n], zt = this.getTrackById(Lt.tfhd.track_id), X = this.getTrexById(Lt.tfhd.track_id), Lt.tfhd.flags & g.TFHD_FLAG_SAMPLE_DESC ? h = Lt.tfhd.default_sample_description_index : h = X ? X.default_sample_description_index : 1, Lt.tfhd.flags & g.TFHD_FLAG_SAMPLE_DUR ? p = Lt.tfhd.default_sample_duration : p = X ? X.default_sample_duration : 0, Lt.tfhd.flags & g.TFHD_FLAG_SAMPLE_SIZE ? z = Lt.tfhd.default_sample_size : z = X ? X.default_sample_size : 0, Lt.tfhd.flags & g.TFHD_FLAG_SAMPLE_FLAGS ? Z = Lt.tfhd.default_sample_flags : Z = X ? X.default_sample_flags : 0, Lt.sample_number = 0, Lt.sbgps.length > 0 && y.initSampleGroups(zt, Lt, Lt.sbgps, zt.mdia.minf.stbl.sgpds, Lt.sgpds), o = 0; o < Lt.truns.length; o++) {
              var Mt = Lt.truns[o];
              for (l = 0; l < Mt.sample_count; l++) {
                D = {}, D.moof_number = this.lastMoofIndex, D.number_in_traf = Lt.sample_number, Lt.sample_number++, D.number = zt.samples.length, Lt.first_sample_index = zt.samples.length, zt.samples.push(D), D.track_id = zt.tkhd.track_id, D.timescale = zt.mdia.mdhd.timescale, D.description_index = h - 1, D.description = zt.mdia.minf.stbl.stsd.entries[D.description_index], D.size = z, Mt.flags & g.TRUN_FLAGS_SIZE && (D.size = Mt.sample_size[l]), zt.samples_size += D.size, D.duration = p, Mt.flags & g.TRUN_FLAGS_DURATION && (D.duration = Mt.sample_duration[l]), zt.samples_duration += D.duration, l > 0 ? D.dts = zt.samples[zt.samples.length - 2].dts + zt.samples[zt.samples.length - 2].duration : Lt.tfdt ? D.dts = Lt.tfdt.baseMediaDecodeTime : D.dts = 0, D.cts = D.dts, Mt.flags & g.TRUN_FLAGS_CTS_OFFSET && (D.cts = D.dts + Mt.sample_composition_time_offset[l]), yt = Z, Mt.flags & g.TRUN_FLAGS_FLAGS ? yt = Mt.sample_flags[l] : l === 0 && Mt.flags & g.TRUN_FLAGS_FIRST_FLAG && (yt = Mt.first_sample_flags), D.is_sync = !(yt >> 16 & 1), D.is_leading = yt >> 26 & 3, D.depends_on = yt >> 24 & 3, D.is_depended_on = yt >> 22 & 3, D.has_redundancy = yt >> 20 & 3, D.degradation_priority = yt & 65535;
                var at = !!(Lt.tfhd.flags & g.TFHD_FLAG_BASE_DATA_OFFSET), Bt = !!(Lt.tfhd.flags & g.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), jt = !!(Mt.flags & g.TRUN_FLAGS_DATA_OFFSET), At = 0;
                at ? At = Lt.tfhd.base_data_offset : Bt || o === 0 ? At = vt.start : At = V, o === 0 && l === 0 ? jt ? D.offset = At + Mt.data_offset : D.offset = At : D.offset = V, V = D.offset + D.size, (Lt.sbgps.length > 0 || Lt.sgpds.length > 0 || zt.mdia.minf.stbl.sbgps.length > 0 || zt.mdia.minf.stbl.sgpds.length > 0) && y.setSampleGroupProperties(zt, D, D.number_in_traf, Lt.sample_groups_info);
              }
            }
            if (Lt.subs) {
              zt.has_fragment_subsamples = !0;
              var Ce = Lt.first_sample_index;
              for (o = 0; o < Lt.subs.entries.length; o++)
                Ce += Lt.subs.entries[o].sample_delta, D = zt.samples[Ce - 1], D.subsamples = Lt.subs.entries[o].subsamples;
            }
          }
    }
  }, y.prototype.getSample = function(n, o) {
    var l, h = n.samples[o];
    if (!this.moov)
      return null;
    var p = this.moofs[h.moof_number - 1];
    if (!p)
      return e.debug("ISOFile", "Where's the moof?"), null;
    var z = p.trafs[0];
    if (!z)
      return e.debug("ISOFile", "Where's the traf?"), null;
    if (z.senc) {
      var Z = z.senc.samples[h.number_in_traf];
      h.encrypted = !0, h.InitializationVector = Z.InitializationVector;
    }
    if (!h.data)
      h.data = new Uint8Array(h.size), h.alreadyRead = 0, this.samplesDataSize += h.size, e.debug("ISOFile", "Allocating sample #" + o + " on track #" + n.tkhd.track_id + " of size " + h.size + " (total: " + this.samplesDataSize + ")");
    else if (h.alreadyRead == h.size)
      return h;
    for (; ; ) {
      var V = this.stream.findPosition(!0, h.offset + h.alreadyRead, !1);
      if (V > -1) {
        l = this.stream.buffers[V];
        var Q = l.byteLength - (h.offset + h.alreadyRead - l.fileStart);
        if (h.size - h.alreadyRead <= Q)
          return e.debug("ISOFile", "Getting sample #" + o + " data (alreadyRead: " + h.alreadyRead + " offset: " + (h.offset + h.alreadyRead - l.fileStart) + " read size: " + (h.size - h.alreadyRead) + " full size: " + h.size + ")"), u.memcpy(
            h.data.buffer,
            h.alreadyRead,
            l,
            h.offset + h.alreadyRead - l.fileStart,
            h.size - h.alreadyRead
          ), l.usedBytes += h.size - h.alreadyRead, this.stream.logBufferLevel(), h.alreadyRead = h.size, h;
        if (Q === 0) return null;
        e.debug("ISOFile", "Getting sample #" + o + " partial data (alreadyRead: " + h.alreadyRead + " offset: " + (h.offset + h.alreadyRead - l.fileStart) + " read size: " + Q + " full size: " + h.size + ")"), u.memcpy(
          h.data.buffer,
          h.alreadyRead,
          l,
          h.offset + h.alreadyRead - l.fileStart,
          Q
        ), h.alreadyRead += Q, l.usedBytes += Q, this.stream.logBufferLevel();
      } else
        return null;
    }
  }, y.prototype.releaseSample = function(n, o) {
    var l = n.samples[o];
    return l.data ? (this.samplesDataSize -= l.size, l.data = null, l.alreadyRead = 0, l.size) : 0;
  }, y.prototype.getAllocatedSampleDataSize = function() {
    return this.samplesDataSize;
  }, y.prototype.getCodecs = function() {
    var n, o = "";
    for (n = 0; n < this.moov.traks.length; n++) {
      var l = this.moov.traks[n];
      n > 0 && (o += ","), o += l.mdia.minf.stbl.stsd.entries[0].getCodec();
    }
    return o;
  }, y.prototype.getTrexById = function(n) {
    var o;
    if (!this.moov || !this.moov.mvex) return null;
    for (o = 0; o < this.moov.mvex.trexs.length; o++) {
      var l = this.moov.mvex.trexs[o];
      if (l.track_id == n) return l;
    }
    return null;
  }, y.prototype.getTrackById = function(n) {
    if (this.moov === void 0)
      return null;
    for (var o = 0; o < this.moov.traks.length; o++) {
      var l = this.moov.traks[o];
      if (l.tkhd.track_id == n) return l;
    }
    return null;
  }, y.prototype.itemsDataSize = 0, y.prototype.flattenItemInfo = function() {
    var n = this.items, o = this.entity_groups, l, h, p, z = this.meta;
    if (z != null && z.hdlr !== void 0 && z.iinf !== void 0) {
      for (l = 0; l < z.iinf.item_infos.length; l++)
        p = {}, p.id = z.iinf.item_infos[l].item_ID, n[p.id] = p, p.ref_to = [], p.name = z.iinf.item_infos[l].item_name, z.iinf.item_infos[l].protection_index > 0 && (p.protection = z.ipro.protections[z.iinf.item_infos[l].protection_index - 1]), z.iinf.item_infos[l].item_type ? p.type = z.iinf.item_infos[l].item_type : p.type = "mime", p.content_type = z.iinf.item_infos[l].content_type, p.content_encoding = z.iinf.item_infos[l].content_encoding, p.item_uri_type = z.iinf.item_infos[l].item_uri_type;
      if (z.grpl)
        for (l = 0; l < z.grpl.boxes.length; l++)
          entity_group = {}, entity_group.id = z.grpl.boxes[l].group_id, entity_group.entity_ids = z.grpl.boxes[l].entity_ids, entity_group.type = z.grpl.boxes[l].type, o[entity_group.id] = entity_group;
      if (z.iloc)
        for (l = 0; l < z.iloc.items.length; l++) {
          var Z = z.iloc.items[l];
          switch (p = n[Z.item_ID], Z.data_reference_index !== 0 && (e.warn("Item storage with reference to other files: not supported"), p.source = z.dinf.boxes[Z.data_reference_index - 1]), Z.construction_method) {
            case 0:
              break;
            case 1:
              break;
            case 2:
              e.warn("Item storage with construction_method : not supported");
              break;
          }
          for (p.extents = [], p.size = 0, h = 0; h < Z.extents.length; h++)
            p.extents[h] = {}, p.extents[h].offset = Z.extents[h].extent_offset + Z.base_offset, Z.construction_method == 1 && (p.extents[h].offset += z.idat.start + z.idat.hdr_size), p.extents[h].length = Z.extents[h].extent_length, p.extents[h].alreadyRead = 0, p.size += p.extents[h].length;
        }
      if (z.pitm && (n[z.pitm.item_id].primary = !0), z.iref)
        for (l = 0; l < z.iref.references.length; l++) {
          var V = z.iref.references[l];
          for (h = 0; h < V.references.length; h++)
            n[V.from_item_ID].ref_to.push({ type: V.type, id: V.references[h] });
        }
      if (z.iprp)
        for (var Q = 0; Q < z.iprp.ipmas.length; Q++) {
          var vt = z.iprp.ipmas[Q];
          for (l = 0; l < vt.associations.length; l++) {
            var Lt = vt.associations[l];
            if (p = n[Lt.id], p || (p = o[Lt.id]), p)
              for (p.properties === void 0 && (p.properties = {}, p.properties.boxes = []), h = 0; h < Lt.props.length; h++) {
                var zt = Lt.props[h];
                if (zt.property_index > 0 && zt.property_index - 1 < z.iprp.ipco.boxes.length) {
                  var X = z.iprp.ipco.boxes[zt.property_index - 1];
                  p.properties[X.type] = X, p.properties.boxes.push(X);
                }
              }
          }
        }
    }
  }, y.prototype.getItem = function(n) {
    var o, l;
    if (!this.meta)
      return null;
    if (l = this.items[n], !l.data && l.size)
      l.data = new Uint8Array(l.size), l.alreadyRead = 0, this.itemsDataSize += l.size, e.debug("ISOFile", "Allocating item #" + n + " of size " + l.size + " (total: " + this.itemsDataSize + ")");
    else if (l.alreadyRead === l.size)
      return l;
    for (var h = 0; h < l.extents.length; h++) {
      var p = l.extents[h];
      if (p.alreadyRead !== p.length) {
        var z = this.stream.findPosition(!0, p.offset + p.alreadyRead, !1);
        if (z > -1) {
          o = this.stream.buffers[z];
          var Z = o.byteLength - (p.offset + p.alreadyRead - o.fileStart);
          if (p.length - p.alreadyRead <= Z)
            e.debug("ISOFile", "Getting item #" + n + " extent #" + h + " data (alreadyRead: " + p.alreadyRead + " offset: " + (p.offset + p.alreadyRead - o.fileStart) + " read size: " + (p.length - p.alreadyRead) + " full extent size: " + p.length + " full item size: " + l.size + ")"), u.memcpy(
              l.data.buffer,
              l.alreadyRead,
              o,
              p.offset + p.alreadyRead - o.fileStart,
              p.length - p.alreadyRead
            ), o.usedBytes += p.length - p.alreadyRead, this.stream.logBufferLevel(), l.alreadyRead += p.length - p.alreadyRead, p.alreadyRead = p.length;
          else
            return e.debug("ISOFile", "Getting item #" + n + " extent #" + h + " partial data (alreadyRead: " + p.alreadyRead + " offset: " + (p.offset + p.alreadyRead - o.fileStart) + " read size: " + Z + " full extent size: " + p.length + " full item size: " + l.size + ")"), u.memcpy(
              l.data.buffer,
              l.alreadyRead,
              o,
              p.offset + p.alreadyRead - o.fileStart,
              Z
            ), p.alreadyRead += Z, l.alreadyRead += Z, o.usedBytes += Z, this.stream.logBufferLevel(), null;
        } else
          return null;
      }
    }
    return l.alreadyRead === l.size ? l : null;
  }, y.prototype.releaseItem = function(n) {
    var o = this.items[n];
    if (o.data) {
      this.itemsDataSize -= o.size, o.data = null, o.alreadyRead = 0;
      for (var l = 0; l < o.extents.length; l++) {
        var h = o.extents[l];
        h.alreadyRead = 0;
      }
      return o.size;
    } else
      return 0;
  }, y.prototype.processItems = function(n) {
    for (var o in this.items) {
      var l = this.items[o];
      this.getItem(l.id), n && !l.sent && (n(l), l.sent = !0, l.data = null);
    }
  }, y.prototype.hasItem = function(n) {
    for (var o in this.items) {
      var l = this.items[o];
      if (l.name === n)
        return l.id;
    }
    return -1;
  }, y.prototype.getMetaHandler = function() {
    return this.meta ? this.meta.hdlr.handler : null;
  }, y.prototype.getPrimaryItem = function() {
    return !this.meta || !this.meta.pitm ? null : this.getItem(this.meta.pitm.item_id);
  }, y.prototype.itemToFragmentedTrackFile = function(n) {
    var o = n || {}, l = null;
    if (o.itemId ? l = this.getItem(o.itemId) : l = this.getPrimaryItem(), l == null) return null;
    var h = new y();
    h.discardMdatData = !1;
    var p = { type: l.type, description_boxes: l.properties.boxes };
    l.properties.ispe && (p.width = l.properties.ispe.image_width, p.height = l.properties.ispe.image_height);
    var z = h.addTrack(p);
    return z ? (h.addSample(z, l.data), h) : null;
  }, y.prototype.write = function(n) {
    for (var o = 0; o < this.boxes.length; o++)
      this.boxes[o].write(n);
  }, y.prototype.createFragment = function(n, o, l) {
    var h = this.getTrackById(n), p = this.getSample(h, o);
    if (p == null)
      return this.setNextSeekPositionFromSample(h.samples[o]), null;
    var z = l || new u();
    z.endianness = u.BIG_ENDIAN;
    var Z = this.createSingleSampleMoof(p);
    Z.write(z), Z.trafs[0].truns[0].data_offset = Z.size + 8, e.debug("MP4Box", "Adjusting data_offset with new value " + Z.trafs[0].truns[0].data_offset), z.adjustUint32(Z.trafs[0].truns[0].data_offset_position, Z.trafs[0].truns[0].data_offset);
    var V = new g.mdatBox();
    return V.data = p.data, V.write(z), z;
  }, y.writeInitializationSegment = function(n, o, l, h) {
    var p;
    e.debug("ISOFile", "Generating initialization segment");
    var z = new u();
    z.endianness = u.BIG_ENDIAN, n.write(z);
    var Z = o.add("mvex");
    for (l && Z.add("mehd").set("fragment_duration", l), p = 0; p < o.traks.length; p++)
      Z.add("trex").set("track_id", o.traks[p].tkhd.track_id).set("default_sample_description_index", 1).set("default_sample_duration", h).set("default_sample_size", 0).set("default_sample_flags", 65536);
    return o.write(z), z.buffer;
  }, y.prototype.save = function(n) {
    var o = new u();
    o.endianness = u.BIG_ENDIAN, this.write(o), o.save(n);
  }, y.prototype.getBuffer = function() {
    var n = new u();
    return n.endianness = u.BIG_ENDIAN, this.write(n), n.buffer;
  }, y.prototype.initializeSegmentation = function() {
    var n, o, l, h;
    for (this.onSegment === null && e.warn("MP4Box", "No segmentation callback set!"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), o = [], n = 0; n < this.fragmentedTracks.length; n++) {
      var p = new g.moovBox();
      p.mvhd = this.moov.mvhd, p.boxes.push(p.mvhd), l = this.getTrackById(this.fragmentedTracks[n].id), p.boxes.push(l), p.traks.push(l), h = {}, h.id = l.tkhd.track_id, h.user = this.fragmentedTracks[n].user, h.buffer = y.writeInitializationSegment(this.ftyp, p, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, this.moov.traks[n].samples.length > 0 ? this.moov.traks[n].samples[0].duration : 0), o.push(h);
    }
    return o;
  }, g.Box.prototype.printHeader = function(n) {
    this.size += 8, this.size > I && (this.size += 8), this.type === "uuid" && (this.size += 16), n.log(n.indent + "size:" + this.size), n.log(n.indent + "type:" + this.type);
  }, g.FullBox.prototype.printHeader = function(n) {
    this.size += 4, g.Box.prototype.printHeader.call(this, n), n.log(n.indent + "version:" + this.version), n.log(n.indent + "flags:" + this.flags);
  }, g.Box.prototype.print = function(n) {
    this.printHeader(n);
  }, g.ContainerBox.prototype.print = function(n) {
    this.printHeader(n);
    for (var o = 0; o < this.boxes.length; o++)
      if (this.boxes[o]) {
        var l = n.indent;
        n.indent += " ", this.boxes[o].print(n), n.indent = l;
      }
  }, y.prototype.print = function(n) {
    n.indent = "";
    for (var o = 0; o < this.boxes.length; o++)
      this.boxes[o] && this.boxes[o].print(n);
  }, g.mvhdBox.prototype.print = function(n) {
    g.FullBox.prototype.printHeader.call(this, n), n.log(n.indent + "creation_time: " + this.creation_time), n.log(n.indent + "modification_time: " + this.modification_time), n.log(n.indent + "timescale: " + this.timescale), n.log(n.indent + "duration: " + this.duration), n.log(n.indent + "rate: " + this.rate), n.log(n.indent + "volume: " + (this.volume >> 8)), n.log(n.indent + "matrix: " + this.matrix.join(", ")), n.log(n.indent + "next_track_id: " + this.next_track_id);
  }, g.tkhdBox.prototype.print = function(n) {
    g.FullBox.prototype.printHeader.call(this, n), n.log(n.indent + "creation_time: " + this.creation_time), n.log(n.indent + "modification_time: " + this.modification_time), n.log(n.indent + "track_id: " + this.track_id), n.log(n.indent + "duration: " + this.duration), n.log(n.indent + "volume: " + (this.volume >> 8)), n.log(n.indent + "matrix: " + this.matrix.join(", ")), n.log(n.indent + "layer: " + this.layer), n.log(n.indent + "alternate_group: " + this.alternate_group), n.log(n.indent + "width: " + this.width), n.log(n.indent + "height: " + this.height);
  };
  var T = {};
  T.createFile = function(n, o) {
    var l = n !== void 0 ? n : !0, h = new y(o);
    return h.discardMdatData = !l, h;
  }, t.createFile = T.createFile;
})(JA);
var QA = { exports: {} }, tr = {}, qA = { exports: {} }, $A = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
  function e(jt, At) {
    var Ce = jt.length;
    jt.push(At);
    t: for (; 0 < Ce; ) {
      var ne = Ce - 1 >>> 1, Ht = jt[ne];
      if (0 < I(Ht, At)) jt[ne] = At, jt[Ce] = Ht, Ce = ne;
      else break t;
    }
  }
  function r(jt) {
    return jt.length === 0 ? null : jt[0];
  }
  function u(jt) {
    if (jt.length === 0) return null;
    var At = jt[0], Ce = jt.pop();
    if (Ce !== At) {
      jt[0] = Ce;
      t: for (var ne = 0, Ht = jt.length, Le = Ht >>> 1; ne < Le; ) {
        var sn = 2 * (ne + 1) - 1, we = jt[sn], ln = sn + 1, _e = jt[ln];
        if (0 > I(we, Ce)) ln < Ht && 0 > I(_e, we) ? (jt[ne] = _e, jt[ln] = Ce, ne = ln) : (jt[ne] = we, jt[sn] = Ce, ne = sn);
        else if (ln < Ht && 0 > I(_e, Ce)) jt[ne] = _e, jt[ln] = Ce, ne = ln;
        else break t;
      }
    }
    return At;
  }
  function I(jt, At) {
    var Ce = jt.sortIndex - At.sortIndex;
    return Ce !== 0 ? Ce : jt.id - At.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var E = performance;
    t.unstable_now = function() {
      return E.now();
    };
  } else {
    var k = Date, g = k.now();
    t.unstable_now = function() {
      return k.now() - g;
    };
  }
  var w = [], B = [], c = 1, d = null, m = 3, b = !1, y = !1, T = !1, n = typeof setTimeout == "function" ? setTimeout : null, o = typeof clearTimeout == "function" ? clearTimeout : null, l = typeof setImmediate != "undefined" ? setImmediate : null;
  typeof navigator != "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function h(jt) {
    for (var At = r(B); At !== null; ) {
      if (At.callback === null) u(B);
      else if (At.startTime <= jt) u(B), At.sortIndex = At.expirationTime, e(w, At);
      else break;
      At = r(B);
    }
  }
  function p(jt) {
    if (T = !1, h(jt), !y) if (r(w) !== null) y = !0, at(z);
    else {
      var At = r(B);
      At !== null && Bt(p, At.startTime - jt);
    }
  }
  function z(jt, At) {
    y = !1, T && (T = !1, o(Q), Q = -1), b = !0;
    var Ce = m;
    try {
      for (h(At), d = r(w); d !== null && (!(d.expirationTime > At) || jt && !zt()); ) {
        var ne = d.callback;
        if (typeof ne == "function") {
          d.callback = null, m = d.priorityLevel;
          var Ht = ne(d.expirationTime <= At);
          At = t.unstable_now(), typeof Ht == "function" ? d.callback = Ht : d === r(w) && u(w), h(At);
        } else u(w);
        d = r(w);
      }
      if (d !== null) var Le = !0;
      else {
        var sn = r(B);
        sn !== null && Bt(p, sn.startTime - At), Le = !1;
      }
      return Le;
    } finally {
      d = null, m = Ce, b = !1;
    }
  }
  var Z = !1, V = null, Q = -1, vt = 5, Lt = -1;
  function zt() {
    return !(t.unstable_now() - Lt < vt);
  }
  function X() {
    if (V !== null) {
      var jt = t.unstable_now();
      Lt = jt;
      var At = !0;
      try {
        At = V(!0, jt);
      } finally {
        At ? D() : (Z = !1, V = null);
      }
    } else Z = !1;
  }
  var D;
  if (typeof l == "function") D = function() {
    l(X);
  };
  else if (typeof MessageChannel != "undefined") {
    var yt = new MessageChannel(), Mt = yt.port2;
    yt.port1.onmessage = X, D = function() {
      Mt.postMessage(null);
    };
  } else D = function() {
    n(X, 0);
  };
  function at(jt) {
    V = jt, Z || (Z = !0, D());
  }
  function Bt(jt, At) {
    Q = n(function() {
      jt(t.unstable_now());
    }, At);
  }
  t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function(jt) {
    jt.callback = null;
  }, t.unstable_continueExecution = function() {
    y || b || (y = !0, at(z));
  }, t.unstable_forceFrameRate = function(jt) {
    0 > jt || 125 < jt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : vt = 0 < jt ? Math.floor(1e3 / jt) : 5;
  }, t.unstable_getCurrentPriorityLevel = function() {
    return m;
  }, t.unstable_getFirstCallbackNode = function() {
    return r(w);
  }, t.unstable_next = function(jt) {
    switch (m) {
      case 1:
      case 2:
      case 3:
        var At = 3;
        break;
      default:
        At = m;
    }
    var Ce = m;
    m = At;
    try {
      return jt();
    } finally {
      m = Ce;
    }
  }, t.unstable_pauseExecution = function() {
  }, t.unstable_requestPaint = function() {
  }, t.unstable_runWithPriority = function(jt, At) {
    switch (jt) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        jt = 3;
    }
    var Ce = m;
    m = jt;
    try {
      return At();
    } finally {
      m = Ce;
    }
  }, t.unstable_scheduleCallback = function(jt, At, Ce) {
    var ne = t.unstable_now();
    switch (typeof Ce == "object" && Ce !== null ? (Ce = Ce.delay, Ce = typeof Ce == "number" && 0 < Ce ? ne + Ce : ne) : Ce = ne, jt) {
      case 1:
        var Ht = -1;
        break;
      case 2:
        Ht = 250;
        break;
      case 5:
        Ht = 1073741823;
        break;
      case 4:
        Ht = 1e4;
        break;
      default:
        Ht = 5e3;
    }
    return Ht = Ce + Ht, jt = { id: c++, callback: At, priorityLevel: jt, startTime: Ce, expirationTime: Ht, sortIndex: -1 }, Ce > ne ? (jt.sortIndex = Ce, e(B, jt), r(w) === null && jt === r(B) && (T ? (o(Q), Q = -1) : T = !0, Bt(p, Ce - ne))) : (jt.sortIndex = Ht, e(w, jt), y || b || (y = !0, at(z))), jt;
  }, t.unstable_shouldYield = zt, t.unstable_wrapCallback = function(jt) {
    var At = m;
    return function() {
      var Ce = m;
      m = At;
      try {
        return jt.apply(this, arguments);
      } finally {
        m = Ce;
      }
    };
  };
})($A);
qA.exports = $A;
var mT = qA.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fT = Zg, qi = mT;
function gn(t) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++) e += "&args[]=" + encodeURIComponent(arguments[r]);
  return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var t_ = /* @__PURE__ */ new Set(), Du = {};
function Eo(t, e) {
  Sl(t, e), Sl(t + "Capture", e);
}
function Sl(t, e) {
  for (Du[t] = e, t = 0; t < e.length; t++) t_.add(e[t]);
}
var os = !(typeof window == "undefined" || typeof window.document == "undefined" || typeof window.document.createElement == "undefined"), Hm = Object.prototype.hasOwnProperty, hT = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, nC = {}, aC = {};
function pT(t) {
  return Hm.call(aC, t) ? !0 : Hm.call(nC, t) ? !1 : hT.test(t) ? aC[t] = !0 : (nC[t] = !0, !1);
}
function IT(t, e, r, u) {
  if (r !== null && r.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return u ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function CT(t, e, r, u) {
  if (e === null || typeof e == "undefined" || IT(t, e, r, u)) return !0;
  if (u) return !1;
  if (r !== null) switch (r.type) {
    case 3:
      return !e;
    case 4:
      return e === !1;
    case 5:
      return isNaN(e);
    case 6:
      return isNaN(e) || 1 > e;
  }
  return !1;
}
function vi(t, e, r, u, I, E, k) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = u, this.attributeNamespace = I, this.mustUseProperty = r, this.propertyName = t, this.type = e, this.sanitizeURL = E, this.removeEmptyString = k;
}
var di = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
  di[t] = new vi(t, 0, !1, t, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
  var e = t[0];
  di[e] = new vi(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
  di[t] = new vi(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
  di[t] = new vi(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
  di[t] = new vi(t, 3, !1, t.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
  di[t] = new vi(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function(t) {
  di[t] = new vi(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(t) {
  di[t] = new vi(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function(t) {
  di[t] = new vi(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var Xf = /[\-:]([a-z])/g;
function Wf(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
  var e = t.replace(
    Xf,
    Wf
  );
  di[e] = new vi(e, 1, !1, t, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
  var e = t.replace(Xf, Wf);
  di[e] = new vi(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
  var e = t.replace(Xf, Wf);
  di[e] = new vi(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(t) {
  di[t] = new vi(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
di.xlinkHref = new vi("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(t) {
  di[t] = new vi(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function jf(t, e, r, u) {
  var I = di.hasOwnProperty(e) ? di[e] : null;
  (I !== null ? I.type !== 0 : u || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (CT(e, r, I, u) && (r = null), u || I === null ? pT(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : I.mustUseProperty ? t[I.propertyName] = r === null ? I.type === 3 ? !1 : "" : r : (e = I.attributeName, u = I.attributeNamespace, r === null ? t.removeAttribute(e) : (I = I.type, r = I === 3 || I === 4 && r === !0 ? "" : "" + r, u ? t.setAttributeNS(u, e, r) : t.setAttribute(e, r))));
}
var gs = fT.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Hd = Symbol.for("react.element"), nl = Symbol.for("react.portal"), al = Symbol.for("react.fragment"), Zf = Symbol.for("react.strict_mode"), Pm = Symbol.for("react.profiler"), e_ = Symbol.for("react.provider"), n_ = Symbol.for("react.context"), Jf = Symbol.for("react.forward_ref"), Fm = Symbol.for("react.suspense"), Om = Symbol.for("react.suspense_list"), Qf = Symbol.for("react.memo"), Ds = Symbol.for("react.lazy"), a_ = Symbol.for("react.offscreen"), iC = Symbol.iterator;
function ru(t) {
  return t === null || typeof t != "object" ? null : (t = iC && t[iC] || t["@@iterator"], typeof t == "function" ? t : null);
}
var Ha = Object.assign, Xc;
function Iu(t) {
  if (Xc === void 0) try {
    throw Error();
  } catch (r) {
    var e = r.stack.trim().match(/\n( *(at )?)/);
    Xc = e && e[1] || "";
  }
  return `
` + Xc + t;
}
var Wc = !1;
function jc(t, e) {
  if (!t || Wc) return "";
  Wc = !0;
  var r = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e) if (e = function() {
      throw Error();
    }, Object.defineProperty(e.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(e, []);
      } catch (B) {
        var u = B;
      }
      Reflect.construct(t, [], e);
    } else {
      try {
        e.call();
      } catch (B) {
        u = B;
      }
      t.call(e.prototype);
    }
    else {
      try {
        throw Error();
      } catch (B) {
        u = B;
      }
      t();
    }
  } catch (B) {
    if (B && u && typeof B.stack == "string") {
      for (var I = B.stack.split(`
`), E = u.stack.split(`
`), k = I.length - 1, g = E.length - 1; 1 <= k && 0 <= g && I[k] !== E[g]; ) g--;
      for (; 1 <= k && 0 <= g; k--, g--) if (I[k] !== E[g]) {
        if (k !== 1 || g !== 1)
          do
            if (k--, g--, 0 > g || I[k] !== E[g]) {
              var w = `
` + I[k].replace(" at new ", " at ");
              return t.displayName && w.includes("<anonymous>") && (w = w.replace("<anonymous>", t.displayName)), w;
            }
          while (1 <= k && 0 <= g);
        break;
      }
    }
  } finally {
    Wc = !1, Error.prepareStackTrace = r;
  }
  return (t = t ? t.displayName || t.name : "") ? Iu(t) : "";
}
function yT(t) {
  switch (t.tag) {
    case 5:
      return Iu(t.type);
    case 16:
      return Iu("Lazy");
    case 13:
      return Iu("Suspense");
    case 19:
      return Iu("SuspenseList");
    case 0:
    case 2:
    case 15:
      return t = jc(t.type, !1), t;
    case 11:
      return t = jc(t.type.render, !1), t;
    case 1:
      return t = jc(t.type, !0), t;
    default:
      return "";
  }
}
function Um(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case al:
      return "Fragment";
    case nl:
      return "Portal";
    case Pm:
      return "Profiler";
    case Zf:
      return "StrictMode";
    case Fm:
      return "Suspense";
    case Om:
      return "SuspenseList";
  }
  if (typeof t == "object") switch (t.$$typeof) {
    case n_:
      return (t.displayName || "Context") + ".Consumer";
    case e_:
      return (t._context.displayName || "Context") + ".Provider";
    case Jf:
      var e = t.render;
      return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t;
    case Qf:
      return e = t.displayName || null, e !== null ? e : Um(t.type) || "Memo";
    case Ds:
      e = t._payload, t = t._init;
      try {
        return Um(t(e));
      } catch (r) {
      }
  }
  return null;
}
function AT(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Um(e);
    case 8:
      return e === Zf ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Xs(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function i_(t) {
  var e = t.type;
  return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
}
function _T(t) {
  var e = i_(t) ? "checked" : "value", r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), u = "" + t[e];
  if (!t.hasOwnProperty(e) && typeof r != "undefined" && typeof r.get == "function" && typeof r.set == "function") {
    var I = r.get, E = r.set;
    return Object.defineProperty(t, e, { configurable: !0, get: function() {
      return I.call(this);
    }, set: function(k) {
      u = "" + k, E.call(this, k);
    } }), Object.defineProperty(t, e, { enumerable: r.enumerable }), { getValue: function() {
      return u;
    }, setValue: function(k) {
      u = "" + k;
    }, stopTracking: function() {
      t._valueTracker = null, delete t[e];
    } };
  }
}
function Pd(t) {
  t._valueTracker || (t._valueTracker = _T(t));
}
function r_(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var r = e.getValue(), u = "";
  return t && (u = i_(t) ? t.checked ? "true" : "false" : t.value), t = u, t !== r ? (e.setValue(t), !0) : !1;
}
function wg(t) {
  if (t = t || (typeof document != "undefined" ? document : void 0), typeof t == "undefined") return null;
  try {
    return t.activeElement || t.body;
  } catch (e) {
    return t.body;
  }
}
function Km(t, e) {
  var r = e.checked;
  return Ha({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: r != null ? r : t._wrapperState.initialChecked });
}
function rC(t, e) {
  var r = e.defaultValue == null ? "" : e.defaultValue, u = e.checked != null ? e.checked : e.defaultChecked;
  r = Xs(e.value != null ? e.value : r), t._wrapperState = { initialChecked: u, initialValue: r, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null };
}
function s_(t, e) {
  e = e.checked, e != null && jf(t, "checked", e, !1);
}
function Vm(t, e) {
  s_(t, e);
  var r = Xs(e.value), u = e.type;
  if (r != null) u === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
  else if (u === "submit" || u === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value") ? Xm(t, e.type, r) : e.hasOwnProperty("defaultValue") && Xm(t, e.type, Xs(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked);
}
function sC(t, e, r) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var u = e.type;
    if (!(u !== "submit" && u !== "reset" || e.value !== void 0 && e.value !== null)) return;
    e = "" + t._wrapperState.initialValue, r || e === t.value || (t.value = e), t.defaultValue = e;
  }
  r = t.name, r !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, r !== "" && (t.name = r);
}
function Xm(t, e, r) {
  (e !== "number" || wg(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r));
}
var Cu = Array.isArray;
function Il(t, e, r, u) {
  if (t = t.options, e) {
    e = {};
    for (var I = 0; I < r.length; I++) e["$" + r[I]] = !0;
    for (r = 0; r < t.length; r++) I = e.hasOwnProperty("$" + t[r].value), t[r].selected !== I && (t[r].selected = I), I && u && (t[r].defaultSelected = !0);
  } else {
    for (r = "" + Xs(r), e = null, I = 0; I < t.length; I++) {
      if (t[I].value === r) {
        t[I].selected = !0, u && (t[I].defaultSelected = !0);
        return;
      }
      e !== null || t[I].disabled || (e = t[I]);
    }
    e !== null && (e.selected = !0);
  }
}
function Wm(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(gn(91));
  return Ha({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue });
}
function oC(t, e) {
  var r = e.value;
  if (r == null) {
    if (r = e.children, e = e.defaultValue, r != null) {
      if (e != null) throw Error(gn(92));
      if (Cu(r)) {
        if (1 < r.length) throw Error(gn(93));
        r = r[0];
      }
      e = r;
    }
    e == null && (e = ""), r = e;
  }
  t._wrapperState = { initialValue: Xs(r) };
}
function o_(t, e) {
  var r = Xs(e.value), u = Xs(e.defaultValue);
  r != null && (r = "" + r, r !== t.value && (t.value = r), e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)), u != null && (t.defaultValue = "" + u);
}
function lC(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function l_(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function jm(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml" ? l_(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t;
}
var Fd, u_ = function(t) {
  return typeof MSApp != "undefined" && MSApp.execUnsafeLocalFunction ? function(e, r, u, I) {
    MSApp.execUnsafeLocalFunction(function() {
      return t(e, r, u, I);
    });
  } : t;
}(function(t, e) {
  if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e;
  else {
    for (Fd = Fd || document.createElement("div"), Fd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Fd.firstChild; t.firstChild; ) t.removeChild(t.firstChild);
    for (; e.firstChild; ) t.appendChild(e.firstChild);
  }
});
function Bu(t, e) {
  if (e) {
    var r = t.firstChild;
    if (r && r === t.lastChild && r.nodeType === 3) {
      r.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var Su = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, bT = ["Webkit", "ms", "Moz", "O"];
Object.keys(Su).forEach(function(t) {
  bT.forEach(function(e) {
    e = e + t.charAt(0).toUpperCase() + t.substring(1), Su[e] = Su[t];
  });
});
function d_(t, e, r) {
  return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || Su.hasOwnProperty(t) && Su[t] ? ("" + e).trim() : e + "px";
}
function g_(t, e) {
  t = t.style;
  for (var r in e) if (e.hasOwnProperty(r)) {
    var u = r.indexOf("--") === 0, I = d_(r, e[r], u);
    r === "float" && (r = "cssFloat"), u ? t.setProperty(r, I) : t[r] = I;
  }
}
var ST = Ha({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function Zm(t, e) {
  if (e) {
    if (ST[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(gn(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(gn(60));
      if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(gn(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(gn(62));
  }
}
function Jm(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var Qm = null;
function qf(t) {
  return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t;
}
var qm = null, Cl = null, yl = null;
function uC(t) {
  if (t = nd(t)) {
    if (typeof qm != "function") throw Error(gn(280));
    var e = t.stateNode;
    e && (e = nc(e), qm(t.stateNode, t.type, e));
  }
}
function c_(t) {
  Cl ? yl ? yl.push(t) : yl = [t] : Cl = t;
}
function m_() {
  if (Cl) {
    var t = Cl, e = yl;
    if (yl = Cl = null, uC(t), e) for (t = 0; t < e.length; t++) uC(e[t]);
  }
}
function f_(t, e) {
  return t(e);
}
function h_() {
}
var Zc = !1;
function p_(t, e, r) {
  if (Zc) return t(e, r);
  Zc = !0;
  try {
    return f_(t, e, r);
  } finally {
    Zc = !1, (Cl !== null || yl !== null) && (h_(), m_());
  }
}
function xu(t, e) {
  var r = t.stateNode;
  if (r === null) return null;
  var u = nc(r);
  if (u === null) return null;
  r = u[e];
  t: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (u = !u.disabled) || (t = t.type, u = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !u;
      break t;
    default:
      t = !1;
  }
  if (t) return null;
  if (r && typeof r != "function") throw Error(gn(231, e, typeof r));
  return r;
}
var $m = !1;
if (os) try {
  var su = {};
  Object.defineProperty(su, "passive", { get: function() {
    $m = !0;
  } }), window.addEventListener("test", su, su), window.removeEventListener("test", su, su);
} catch (t) {
  $m = !1;
}
function wT(t, e, r, u, I, E, k, g, w) {
  var B = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(r, B);
  } catch (c) {
    this.onError(c);
  }
}
var wu = !1, vg = null, Eg = !1, tf = null, vT = { onError: function(t) {
  wu = !0, vg = t;
} };
function ET(t, e, r, u, I, E, k, g, w) {
  wu = !1, vg = null, wT.apply(vT, arguments);
}
function TT(t, e, r, u, I, E, k, g, w) {
  if (ET.apply(this, arguments), wu) {
    if (wu) {
      var B = vg;
      wu = !1, vg = null;
    } else throw Error(gn(198));
    Eg || (Eg = !0, tf = B);
  }
}
function To(t) {
  var e = t, r = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do
      e = t, e.flags & 4098 && (r = e.return), t = e.return;
    while (t);
  }
  return e.tag === 3 ? r : null;
}
function I_(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated;
  }
  return null;
}
function dC(t) {
  if (To(t) !== t) throw Error(gn(188));
}
function kT(t) {
  var e = t.alternate;
  if (!e) {
    if (e = To(t), e === null) throw Error(gn(188));
    return e !== t ? null : t;
  }
  for (var r = t, u = e; ; ) {
    var I = r.return;
    if (I === null) break;
    var E = I.alternate;
    if (E === null) {
      if (u = I.return, u !== null) {
        r = u;
        continue;
      }
      break;
    }
    if (I.child === E.child) {
      for (E = I.child; E; ) {
        if (E === r) return dC(I), t;
        if (E === u) return dC(I), e;
        E = E.sibling;
      }
      throw Error(gn(188));
    }
    if (r.return !== u.return) r = I, u = E;
    else {
      for (var k = !1, g = I.child; g; ) {
        if (g === r) {
          k = !0, r = I, u = E;
          break;
        }
        if (g === u) {
          k = !0, u = I, r = E;
          break;
        }
        g = g.sibling;
      }
      if (!k) {
        for (g = E.child; g; ) {
          if (g === r) {
            k = !0, r = E, u = I;
            break;
          }
          if (g === u) {
            k = !0, u = E, r = I;
            break;
          }
          g = g.sibling;
        }
        if (!k) throw Error(gn(189));
      }
    }
    if (r.alternate !== u) throw Error(gn(190));
  }
  if (r.tag !== 3) throw Error(gn(188));
  return r.stateNode.current === r ? t : e;
}
function C_(t) {
  return t = kT(t), t !== null ? y_(t) : null;
}
function y_(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = y_(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var A_ = qi.unstable_scheduleCallback, gC = qi.unstable_cancelCallback, LT = qi.unstable_shouldYield, MT = qi.unstable_requestPaint, Za = qi.unstable_now, RT = qi.unstable_getCurrentPriorityLevel, $f = qi.unstable_ImmediatePriority, __ = qi.unstable_UserBlockingPriority, Tg = qi.unstable_NormalPriority, DT = qi.unstable_LowPriority, b_ = qi.unstable_IdlePriority, qg = null, Kr = null;
function BT(t) {
  if (Kr && typeof Kr.onCommitFiberRoot == "function") try {
    Kr.onCommitFiberRoot(qg, t, void 0, (t.current.flags & 128) === 128);
  } catch (e) {
  }
}
var kr = Math.clz32 ? Math.clz32 : GT, xT = Math.log, NT = Math.LN2;
function GT(t) {
  return t >>>= 0, t === 0 ? 32 : 31 - (xT(t) / NT | 0) | 0;
}
var Od = 64, Ud = 4194304;
function yu(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function kg(t, e) {
  var r = t.pendingLanes;
  if (r === 0) return 0;
  var u = 0, I = t.suspendedLanes, E = t.pingedLanes, k = r & 268435455;
  if (k !== 0) {
    var g = k & ~I;
    g !== 0 ? u = yu(g) : (E &= k, E !== 0 && (u = yu(E)));
  } else k = r & ~I, k !== 0 ? u = yu(k) : E !== 0 && (u = yu(E));
  if (u === 0) return 0;
  if (e !== 0 && e !== u && !(e & I) && (I = u & -u, E = e & -e, I >= E || I === 16 && (E & 4194240) !== 0)) return e;
  if (u & 4 && (u |= r & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= u; 0 < e; ) r = 31 - kr(e), I = 1 << r, u |= t[r], e &= ~I;
  return u;
}
function zT(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function YT(t, e) {
  for (var r = t.suspendedLanes, u = t.pingedLanes, I = t.expirationTimes, E = t.pendingLanes; 0 < E; ) {
    var k = 31 - kr(E), g = 1 << k, w = I[k];
    w === -1 ? (!(g & r) || g & u) && (I[k] = zT(g, e)) : w <= e && (t.expiredLanes |= g), E &= ~g;
  }
}
function ef(t) {
  return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0;
}
function S_() {
  var t = Od;
  return Od <<= 1, !(Od & 4194240) && (Od = 64), t;
}
function Jc(t) {
  for (var e = [], r = 0; 31 > r; r++) e.push(t);
  return e;
}
function td(t, e, r) {
  t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - kr(e), t[e] = r;
}
function HT(t, e) {
  var r = t.pendingLanes & ~e;
  t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements;
  var u = t.eventTimes;
  for (t = t.expirationTimes; 0 < r; ) {
    var I = 31 - kr(r), E = 1 << I;
    e[I] = 0, u[I] = -1, t[I] = -1, r &= ~E;
  }
}
function th(t, e) {
  var r = t.entangledLanes |= e;
  for (t = t.entanglements; r; ) {
    var u = 31 - kr(r), I = 1 << u;
    I & e | t[u] & e && (t[u] |= e), r &= ~I;
  }
}
var ya = 0;
function w_(t) {
  return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1;
}
var v_, eh, E_, T_, k_, nf = !1, Kd = [], Ys = null, Hs = null, Ps = null, Nu = /* @__PURE__ */ new Map(), Gu = /* @__PURE__ */ new Map(), xs = [], PT = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function cC(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      Ys = null;
      break;
    case "dragenter":
    case "dragleave":
      Hs = null;
      break;
    case "mouseover":
    case "mouseout":
      Ps = null;
      break;
    case "pointerover":
    case "pointerout":
      Nu.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Gu.delete(e.pointerId);
  }
}
function ou(t, e, r, u, I, E) {
  return t === null || t.nativeEvent !== E ? (t = { blockedOn: e, domEventName: r, eventSystemFlags: u, nativeEvent: E, targetContainers: [I] }, e !== null && (e = nd(e), e !== null && eh(e)), t) : (t.eventSystemFlags |= u, e = t.targetContainers, I !== null && e.indexOf(I) === -1 && e.push(I), t);
}
function FT(t, e, r, u, I) {
  switch (e) {
    case "focusin":
      return Ys = ou(Ys, t, e, r, u, I), !0;
    case "dragenter":
      return Hs = ou(Hs, t, e, r, u, I), !0;
    case "mouseover":
      return Ps = ou(Ps, t, e, r, u, I), !0;
    case "pointerover":
      var E = I.pointerId;
      return Nu.set(E, ou(Nu.get(E) || null, t, e, r, u, I)), !0;
    case "gotpointercapture":
      return E = I.pointerId, Gu.set(E, ou(Gu.get(E) || null, t, e, r, u, I)), !0;
  }
  return !1;
}
function L_(t) {
  var e = po(t.target);
  if (e !== null) {
    var r = To(e);
    if (r !== null) {
      if (e = r.tag, e === 13) {
        if (e = I_(r), e !== null) {
          t.blockedOn = e, k_(t.priority, function() {
            E_(r);
          });
          return;
        }
      } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function ug(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var r = af(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (r === null) {
      r = t.nativeEvent;
      var u = new r.constructor(r.type, r);
      Qm = u, r.target.dispatchEvent(u), Qm = null;
    } else return e = nd(r), e !== null && eh(e), t.blockedOn = r, !1;
    e.shift();
  }
  return !0;
}
function mC(t, e, r) {
  ug(t) && r.delete(e);
}
function OT() {
  nf = !1, Ys !== null && ug(Ys) && (Ys = null), Hs !== null && ug(Hs) && (Hs = null), Ps !== null && ug(Ps) && (Ps = null), Nu.forEach(mC), Gu.forEach(mC);
}
function lu(t, e) {
  t.blockedOn === e && (t.blockedOn = null, nf || (nf = !0, qi.unstable_scheduleCallback(qi.unstable_NormalPriority, OT)));
}
function zu(t) {
  function e(I) {
    return lu(I, t);
  }
  if (0 < Kd.length) {
    lu(Kd[0], t);
    for (var r = 1; r < Kd.length; r++) {
      var u = Kd[r];
      u.blockedOn === t && (u.blockedOn = null);
    }
  }
  for (Ys !== null && lu(Ys, t), Hs !== null && lu(Hs, t), Ps !== null && lu(Ps, t), Nu.forEach(e), Gu.forEach(e), r = 0; r < xs.length; r++) u = xs[r], u.blockedOn === t && (u.blockedOn = null);
  for (; 0 < xs.length && (r = xs[0], r.blockedOn === null); ) L_(r), r.blockedOn === null && xs.shift();
}
var Al = gs.ReactCurrentBatchConfig, Lg = !0;
function UT(t, e, r, u) {
  var I = ya, E = Al.transition;
  Al.transition = null;
  try {
    ya = 1, nh(t, e, r, u);
  } finally {
    ya = I, Al.transition = E;
  }
}
function KT(t, e, r, u) {
  var I = ya, E = Al.transition;
  Al.transition = null;
  try {
    ya = 4, nh(t, e, r, u);
  } finally {
    ya = I, Al.transition = E;
  }
}
function nh(t, e, r, u) {
  if (Lg) {
    var I = af(t, e, r, u);
    if (I === null) sm(t, e, u, Mg, r), cC(t, u);
    else if (FT(I, t, e, r, u)) u.stopPropagation();
    else if (cC(t, u), e & 4 && -1 < PT.indexOf(t)) {
      for (; I !== null; ) {
        var E = nd(I);
        if (E !== null && v_(E), E = af(t, e, r, u), E === null && sm(t, e, u, Mg, r), E === I) break;
        I = E;
      }
      I !== null && u.stopPropagation();
    } else sm(t, e, u, null, r);
  }
}
var Mg = null;
function af(t, e, r, u) {
  if (Mg = null, t = qf(u), t = po(t), t !== null) if (e = To(t), e === null) t = null;
  else if (r = e.tag, r === 13) {
    if (t = I_(e), t !== null) return t;
    t = null;
  } else if (r === 3) {
    if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
    t = null;
  } else e !== t && (t = null);
  return Mg = t, null;
}
function M_(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (RT()) {
        case $f:
          return 1;
        case __:
          return 4;
        case Tg:
        case DT:
          return 16;
        case b_:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Gs = null, ah = null, dg = null;
function R_() {
  if (dg) return dg;
  var t, e = ah, r = e.length, u, I = "value" in Gs ? Gs.value : Gs.textContent, E = I.length;
  for (t = 0; t < r && e[t] === I[t]; t++) ;
  var k = r - t;
  for (u = 1; u <= k && e[r - u] === I[E - u]; u++) ;
  return dg = I.slice(t, 1 < u ? 1 - u : void 0);
}
function gg(t) {
  var e = t.keyCode;
  return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0;
}
function Vd() {
  return !0;
}
function fC() {
  return !1;
}
function er(t) {
  function e(r, u, I, E, k) {
    this._reactName = r, this._targetInst = I, this.type = u, this.nativeEvent = E, this.target = k, this.currentTarget = null;
    for (var g in t) t.hasOwnProperty(g) && (r = t[g], this[g] = r ? r(E) : E[g]);
    return this.isDefaultPrevented = (E.defaultPrevented != null ? E.defaultPrevented : E.returnValue === !1) ? Vd : fC, this.isPropagationStopped = fC, this;
  }
  return Ha(e.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var r = this.nativeEvent;
    r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1), this.isDefaultPrevented = Vd);
  }, stopPropagation: function() {
    var r = this.nativeEvent;
    r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0), this.isPropagationStopped = Vd);
  }, persist: function() {
  }, isPersistent: Vd }), e;
}
var Bl = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(t) {
  return t.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, ih = er(Bl), ed = Ha({}, Bl, { view: 0, detail: 0 }), VT = er(ed), Qc, qc, uu, $g = Ha({}, ed, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: rh, button: 0, buttons: 0, relatedTarget: function(t) {
  return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget;
}, movementX: function(t) {
  return "movementX" in t ? t.movementX : (t !== uu && (uu && t.type === "mousemove" ? (Qc = t.screenX - uu.screenX, qc = t.screenY - uu.screenY) : qc = Qc = 0, uu = t), Qc);
}, movementY: function(t) {
  return "movementY" in t ? t.movementY : qc;
} }), hC = er($g), XT = Ha({}, $g, { dataTransfer: 0 }), WT = er(XT), jT = Ha({}, ed, { relatedTarget: 0 }), $c = er(jT), ZT = Ha({}, Bl, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), JT = er(ZT), QT = Ha({}, Bl, { clipboardData: function(t) {
  return "clipboardData" in t ? t.clipboardData : window.clipboardData;
} }), qT = er(QT), $T = Ha({}, Bl, { data: 0 }), pC = er($T), tk = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, ek = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, nk = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function ak(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = nk[t]) ? !!e[t] : !1;
}
function rh() {
  return ak;
}
var ik = Ha({}, ed, { key: function(t) {
  if (t.key) {
    var e = tk[t.key] || t.key;
    if (e !== "Unidentified") return e;
  }
  return t.type === "keypress" ? (t = gg(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? ek[t.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: rh, charCode: function(t) {
  return t.type === "keypress" ? gg(t) : 0;
}, keyCode: function(t) {
  return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
}, which: function(t) {
  return t.type === "keypress" ? gg(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
} }), rk = er(ik), sk = Ha({}, $g, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), IC = er(sk), ok = Ha({}, ed, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: rh }), lk = er(ok), uk = Ha({}, Bl, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), dk = er(uk), gk = Ha({}, $g, {
  deltaX: function(t) {
    return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
  },
  deltaY: function(t) {
    return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), ck = er(gk), mk = [9, 13, 27, 32], sh = os && "CompositionEvent" in window, vu = null;
os && "documentMode" in document && (vu = document.documentMode);
var fk = os && "TextEvent" in window && !vu, D_ = os && (!sh || vu && 8 < vu && 11 >= vu), CC = " ", yC = !1;
function B_(t, e) {
  switch (t) {
    case "keyup":
      return mk.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function x_(t) {
  return t = t.detail, typeof t == "object" && "data" in t ? t.data : null;
}
var il = !1;
function hk(t, e) {
  switch (t) {
    case "compositionend":
      return x_(e);
    case "keypress":
      return e.which !== 32 ? null : (yC = !0, CC);
    case "textInput":
      return t = e.data, t === CC && yC ? null : t;
    default:
      return null;
  }
}
function pk(t, e) {
  if (il) return t === "compositionend" || !sh && B_(t, e) ? (t = R_(), dg = ah = Gs = null, il = !1, t) : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return D_ && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var Ik = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function AC(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!Ik[t.type] : e === "textarea";
}
function N_(t, e, r, u) {
  c_(u), e = Rg(e, "onChange"), 0 < e.length && (r = new ih("onChange", "change", null, r, u), t.push({ event: r, listeners: e }));
}
var Eu = null, Yu = null;
function Ck(t) {
  X_(t, 0);
}
function tc(t) {
  var e = ol(t);
  if (r_(e)) return t;
}
function yk(t, e) {
  if (t === "change") return e;
}
var G_ = !1;
if (os) {
  var tm;
  if (os) {
    var em = "oninput" in document;
    if (!em) {
      var _C = document.createElement("div");
      _C.setAttribute("oninput", "return;"), em = typeof _C.oninput == "function";
    }
    tm = em;
  } else tm = !1;
  G_ = tm && (!document.documentMode || 9 < document.documentMode);
}
function bC() {
  Eu && (Eu.detachEvent("onpropertychange", z_), Yu = Eu = null);
}
function z_(t) {
  if (t.propertyName === "value" && tc(Yu)) {
    var e = [];
    N_(e, Yu, t, qf(t)), p_(Ck, e);
  }
}
function Ak(t, e, r) {
  t === "focusin" ? (bC(), Eu = e, Yu = r, Eu.attachEvent("onpropertychange", z_)) : t === "focusout" && bC();
}
function _k(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown") return tc(Yu);
}
function bk(t, e) {
  if (t === "click") return tc(e);
}
function Sk(t, e) {
  if (t === "input" || t === "change") return tc(e);
}
function wk(t, e) {
  return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e;
}
var Mr = typeof Object.is == "function" ? Object.is : wk;
function Hu(t, e) {
  if (Mr(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1;
  var r = Object.keys(t), u = Object.keys(e);
  if (r.length !== u.length) return !1;
  for (u = 0; u < r.length; u++) {
    var I = r[u];
    if (!Hm.call(e, I) || !Mr(t[I], e[I])) return !1;
  }
  return !0;
}
function SC(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function wC(t, e) {
  var r = SC(t);
  t = 0;
  for (var u; r; ) {
    if (r.nodeType === 3) {
      if (u = t + r.textContent.length, t <= e && u >= e) return { node: r, offset: e - t };
      t = u;
    }
    t: {
      for (; r; ) {
        if (r.nextSibling) {
          r = r.nextSibling;
          break t;
        }
        r = r.parentNode;
      }
      r = void 0;
    }
    r = SC(r);
  }
}
function Y_(t, e) {
  return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? Y_(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1;
}
function H_() {
  for (var t = window, e = wg(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var r = typeof e.contentWindow.location.href == "string";
    } catch (u) {
      r = !1;
    }
    if (r) t = e.contentWindow;
    else break;
    e = wg(t.document);
  }
  return e;
}
function oh(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true");
}
function vk(t) {
  var e = H_(), r = t.focusedElem, u = t.selectionRange;
  if (e !== r && r && r.ownerDocument && Y_(r.ownerDocument.documentElement, r)) {
    if (u !== null && oh(r)) {
      if (e = u.start, t = u.end, t === void 0 && (t = e), "selectionStart" in r) r.selectionStart = e, r.selectionEnd = Math.min(t, r.value.length);
      else if (t = (e = r.ownerDocument || document) && e.defaultView || window, t.getSelection) {
        t = t.getSelection();
        var I = r.textContent.length, E = Math.min(u.start, I);
        u = u.end === void 0 ? E : Math.min(u.end, I), !t.extend && E > u && (I = u, u = E, E = I), I = wC(r, E);
        var k = wC(
          r,
          u
        );
        I && k && (t.rangeCount !== 1 || t.anchorNode !== I.node || t.anchorOffset !== I.offset || t.focusNode !== k.node || t.focusOffset !== k.offset) && (e = e.createRange(), e.setStart(I.node, I.offset), t.removeAllRanges(), E > u ? (t.addRange(e), t.extend(k.node, k.offset)) : (e.setEnd(k.node, k.offset), t.addRange(e)));
      }
    }
    for (e = [], t = r; t = t.parentNode; ) t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop });
    for (typeof r.focus == "function" && r.focus(), r = 0; r < e.length; r++) t = e[r], t.element.scrollLeft = t.left, t.element.scrollTop = t.top;
  }
}
var Ek = os && "documentMode" in document && 11 >= document.documentMode, rl = null, rf = null, Tu = null, sf = !1;
function vC(t, e, r) {
  var u = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
  sf || rl == null || rl !== wg(u) || (u = rl, "selectionStart" in u && oh(u) ? u = { start: u.selectionStart, end: u.selectionEnd } : (u = (u.ownerDocument && u.ownerDocument.defaultView || window).getSelection(), u = { anchorNode: u.anchorNode, anchorOffset: u.anchorOffset, focusNode: u.focusNode, focusOffset: u.focusOffset }), Tu && Hu(Tu, u) || (Tu = u, u = Rg(rf, "onSelect"), 0 < u.length && (e = new ih("onSelect", "select", null, e, r), t.push({ event: e, listeners: u }), e.target = rl)));
}
function Xd(t, e) {
  var r = {};
  return r[t.toLowerCase()] = e.toLowerCase(), r["Webkit" + t] = "webkit" + e, r["Moz" + t] = "moz" + e, r;
}
var sl = { animationend: Xd("Animation", "AnimationEnd"), animationiteration: Xd("Animation", "AnimationIteration"), animationstart: Xd("Animation", "AnimationStart"), transitionend: Xd("Transition", "TransitionEnd") }, nm = {}, P_ = {};
os && (P_ = document.createElement("div").style, "AnimationEvent" in window || (delete sl.animationend.animation, delete sl.animationiteration.animation, delete sl.animationstart.animation), "TransitionEvent" in window || delete sl.transitionend.transition);
function ec(t) {
  if (nm[t]) return nm[t];
  if (!sl[t]) return t;
  var e = sl[t], r;
  for (r in e) if (e.hasOwnProperty(r) && r in P_) return nm[t] = e[r];
  return t;
}
var F_ = ec("animationend"), O_ = ec("animationiteration"), U_ = ec("animationstart"), K_ = ec("transitionend"), V_ = /* @__PURE__ */ new Map(), EC = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Js(t, e) {
  V_.set(t, e), Eo(e, [t]);
}
for (var am = 0; am < EC.length; am++) {
  var im = EC[am], Tk = im.toLowerCase(), kk = im[0].toUpperCase() + im.slice(1);
  Js(Tk, "on" + kk);
}
Js(F_, "onAnimationEnd");
Js(O_, "onAnimationIteration");
Js(U_, "onAnimationStart");
Js("dblclick", "onDoubleClick");
Js("focusin", "onFocus");
Js("focusout", "onBlur");
Js(K_, "onTransitionEnd");
Sl("onMouseEnter", ["mouseout", "mouseover"]);
Sl("onMouseLeave", ["mouseout", "mouseover"]);
Sl("onPointerEnter", ["pointerout", "pointerover"]);
Sl("onPointerLeave", ["pointerout", "pointerover"]);
Eo("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Eo("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Eo("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Eo("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Eo("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Eo("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Au = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Lk = new Set("cancel close invalid load scroll toggle".split(" ").concat(Au));
function TC(t, e, r) {
  var u = t.type || "unknown-event";
  t.currentTarget = r, TT(u, e, void 0, t), t.currentTarget = null;
}
function X_(t, e) {
  e = (e & 4) !== 0;
  for (var r = 0; r < t.length; r++) {
    var u = t[r], I = u.event;
    u = u.listeners;
    t: {
      var E = void 0;
      if (e) for (var k = u.length - 1; 0 <= k; k--) {
        var g = u[k], w = g.instance, B = g.currentTarget;
        if (g = g.listener, w !== E && I.isPropagationStopped()) break t;
        TC(I, g, B), E = w;
      }
      else for (k = 0; k < u.length; k++) {
        if (g = u[k], w = g.instance, B = g.currentTarget, g = g.listener, w !== E && I.isPropagationStopped()) break t;
        TC(I, g, B), E = w;
      }
    }
  }
  if (Eg) throw t = tf, Eg = !1, tf = null, t;
}
function Ta(t, e) {
  var r = e[gf];
  r === void 0 && (r = e[gf] = /* @__PURE__ */ new Set());
  var u = t + "__bubble";
  r.has(u) || (W_(e, t, 2, !1), r.add(u));
}
function rm(t, e, r) {
  var u = 0;
  e && (u |= 4), W_(r, t, u, e);
}
var Wd = "_reactListening" + Math.random().toString(36).slice(2);
function Pu(t) {
  if (!t[Wd]) {
    t[Wd] = !0, t_.forEach(function(r) {
      r !== "selectionchange" && (Lk.has(r) || rm(r, !1, t), rm(r, !0, t));
    });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[Wd] || (e[Wd] = !0, rm("selectionchange", !1, e));
  }
}
function W_(t, e, r, u) {
  switch (M_(e)) {
    case 1:
      var I = UT;
      break;
    case 4:
      I = KT;
      break;
    default:
      I = nh;
  }
  r = I.bind(null, e, r, t), I = void 0, !$m || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (I = !0), u ? I !== void 0 ? t.addEventListener(e, r, { capture: !0, passive: I }) : t.addEventListener(e, r, !0) : I !== void 0 ? t.addEventListener(e, r, { passive: I }) : t.addEventListener(e, r, !1);
}
function sm(t, e, r, u, I) {
  var E = u;
  if (!(e & 1) && !(e & 2) && u !== null) t: for (; ; ) {
    if (u === null) return;
    var k = u.tag;
    if (k === 3 || k === 4) {
      var g = u.stateNode.containerInfo;
      if (g === I || g.nodeType === 8 && g.parentNode === I) break;
      if (k === 4) for (k = u.return; k !== null; ) {
        var w = k.tag;
        if ((w === 3 || w === 4) && (w = k.stateNode.containerInfo, w === I || w.nodeType === 8 && w.parentNode === I)) return;
        k = k.return;
      }
      for (; g !== null; ) {
        if (k = po(g), k === null) return;
        if (w = k.tag, w === 5 || w === 6) {
          u = E = k;
          continue t;
        }
        g = g.parentNode;
      }
    }
    u = u.return;
  }
  p_(function() {
    var B = E, c = qf(r), d = [];
    t: {
      var m = V_.get(t);
      if (m !== void 0) {
        var b = ih, y = t;
        switch (t) {
          case "keypress":
            if (gg(r) === 0) break t;
          case "keydown":
          case "keyup":
            b = rk;
            break;
          case "focusin":
            y = "focus", b = $c;
            break;
          case "focusout":
            y = "blur", b = $c;
            break;
          case "beforeblur":
          case "afterblur":
            b = $c;
            break;
          case "click":
            if (r.button === 2) break t;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            b = hC;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            b = WT;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            b = lk;
            break;
          case F_:
          case O_:
          case U_:
            b = JT;
            break;
          case K_:
            b = dk;
            break;
          case "scroll":
            b = VT;
            break;
          case "wheel":
            b = ck;
            break;
          case "copy":
          case "cut":
          case "paste":
            b = qT;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            b = IC;
        }
        var T = (e & 4) !== 0, n = !T && t === "scroll", o = T ? m !== null ? m + "Capture" : null : m;
        T = [];
        for (var l = B, h; l !== null; ) {
          h = l;
          var p = h.stateNode;
          if (h.tag === 5 && p !== null && (h = p, o !== null && (p = xu(l, o), p != null && T.push(Fu(l, p, h)))), n) break;
          l = l.return;
        }
        0 < T.length && (m = new b(m, y, null, r, c), d.push({ event: m, listeners: T }));
      }
    }
    if (!(e & 7)) {
      t: {
        if (m = t === "mouseover" || t === "pointerover", b = t === "mouseout" || t === "pointerout", m && r !== Qm && (y = r.relatedTarget || r.fromElement) && (po(y) || y[ls])) break t;
        if ((b || m) && (m = c.window === c ? c : (m = c.ownerDocument) ? m.defaultView || m.parentWindow : window, b ? (y = r.relatedTarget || r.toElement, b = B, y = y ? po(y) : null, y !== null && (n = To(y), y !== n || y.tag !== 5 && y.tag !== 6) && (y = null)) : (b = null, y = B), b !== y)) {
          if (T = hC, p = "onMouseLeave", o = "onMouseEnter", l = "mouse", (t === "pointerout" || t === "pointerover") && (T = IC, p = "onPointerLeave", o = "onPointerEnter", l = "pointer"), n = b == null ? m : ol(b), h = y == null ? m : ol(y), m = new T(p, l + "leave", b, r, c), m.target = n, m.relatedTarget = h, p = null, po(c) === B && (T = new T(o, l + "enter", y, r, c), T.target = h, T.relatedTarget = n, p = T), n = p, b && y) e: {
            for (T = b, o = y, l = 0, h = T; h; h = tl(h)) l++;
            for (h = 0, p = o; p; p = tl(p)) h++;
            for (; 0 < l - h; ) T = tl(T), l--;
            for (; 0 < h - l; ) o = tl(o), h--;
            for (; l--; ) {
              if (T === o || o !== null && T === o.alternate) break e;
              T = tl(T), o = tl(o);
            }
            T = null;
          }
          else T = null;
          b !== null && kC(d, m, b, T, !1), y !== null && n !== null && kC(d, n, y, T, !0);
        }
      }
      t: {
        if (m = B ? ol(B) : window, b = m.nodeName && m.nodeName.toLowerCase(), b === "select" || b === "input" && m.type === "file") var z = yk;
        else if (AC(m)) if (G_) z = Sk;
        else {
          z = _k;
          var Z = Ak;
        }
        else (b = m.nodeName) && b.toLowerCase() === "input" && (m.type === "checkbox" || m.type === "radio") && (z = bk);
        if (z && (z = z(t, B))) {
          N_(d, z, r, c);
          break t;
        }
        Z && Z(t, m, B), t === "focusout" && (Z = m._wrapperState) && Z.controlled && m.type === "number" && Xm(m, "number", m.value);
      }
      switch (Z = B ? ol(B) : window, t) {
        case "focusin":
          (AC(Z) || Z.contentEditable === "true") && (rl = Z, rf = B, Tu = null);
          break;
        case "focusout":
          Tu = rf = rl = null;
          break;
        case "mousedown":
          sf = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          sf = !1, vC(d, r, c);
          break;
        case "selectionchange":
          if (Ek) break;
        case "keydown":
        case "keyup":
          vC(d, r, c);
      }
      var V;
      if (sh) t: {
        switch (t) {
          case "compositionstart":
            var Q = "onCompositionStart";
            break t;
          case "compositionend":
            Q = "onCompositionEnd";
            break t;
          case "compositionupdate":
            Q = "onCompositionUpdate";
            break t;
        }
        Q = void 0;
      }
      else il ? B_(t, r) && (Q = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (Q = "onCompositionStart");
      Q && (D_ && r.locale !== "ko" && (il || Q !== "onCompositionStart" ? Q === "onCompositionEnd" && il && (V = R_()) : (Gs = c, ah = "value" in Gs ? Gs.value : Gs.textContent, il = !0)), Z = Rg(B, Q), 0 < Z.length && (Q = new pC(Q, t, null, r, c), d.push({ event: Q, listeners: Z }), V ? Q.data = V : (V = x_(r), V !== null && (Q.data = V)))), (V = fk ? hk(t, r) : pk(t, r)) && (B = Rg(B, "onBeforeInput"), 0 < B.length && (c = new pC("onBeforeInput", "beforeinput", null, r, c), d.push({ event: c, listeners: B }), c.data = V));
    }
    X_(d, e);
  });
}
function Fu(t, e, r) {
  return { instance: t, listener: e, currentTarget: r };
}
function Rg(t, e) {
  for (var r = e + "Capture", u = []; t !== null; ) {
    var I = t, E = I.stateNode;
    I.tag === 5 && E !== null && (I = E, E = xu(t, r), E != null && u.unshift(Fu(t, E, I)), E = xu(t, e), E != null && u.push(Fu(t, E, I))), t = t.return;
  }
  return u;
}
function tl(t) {
  if (t === null) return null;
  do
    t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function kC(t, e, r, u, I) {
  for (var E = e._reactName, k = []; r !== null && r !== u; ) {
    var g = r, w = g.alternate, B = g.stateNode;
    if (w !== null && w === u) break;
    g.tag === 5 && B !== null && (g = B, I ? (w = xu(r, E), w != null && k.unshift(Fu(r, w, g))) : I || (w = xu(r, E), w != null && k.push(Fu(r, w, g)))), r = r.return;
  }
  k.length !== 0 && t.push({ event: e, listeners: k });
}
var Mk = /\r\n?/g, Rk = /\u0000|\uFFFD/g;
function LC(t) {
  return (typeof t == "string" ? t : "" + t).replace(Mk, `
`).replace(Rk, "");
}
function jd(t, e, r) {
  if (e = LC(e), LC(t) !== e && r) throw Error(gn(425));
}
function Dg() {
}
var of = null, lf = null;
function uf(t, e) {
  return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
}
var df = typeof setTimeout == "function" ? setTimeout : void 0, Dk = typeof clearTimeout == "function" ? clearTimeout : void 0, MC = typeof Promise == "function" ? Promise : void 0, Bk = typeof queueMicrotask == "function" ? queueMicrotask : typeof MC != "undefined" ? function(t) {
  return MC.resolve(null).then(t).catch(xk);
} : df;
function xk(t) {
  setTimeout(function() {
    throw t;
  });
}
function om(t, e) {
  var r = e, u = 0;
  do {
    var I = r.nextSibling;
    if (t.removeChild(r), I && I.nodeType === 8) if (r = I.data, r === "/$") {
      if (u === 0) {
        t.removeChild(I), zu(e);
        return;
      }
      u--;
    } else r !== "$" && r !== "$?" && r !== "$!" || u++;
    r = I;
  } while (r);
  zu(e);
}
function Fs(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (e = t.data, e === "$" || e === "$!" || e === "$?") break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function RC(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var r = t.data;
      if (r === "$" || r === "$!" || r === "$?") {
        if (e === 0) return t;
        e--;
      } else r === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var xl = Math.random().toString(36).slice(2), Ur = "__reactFiber$" + xl, Ou = "__reactProps$" + xl, ls = "__reactContainer$" + xl, gf = "__reactEvents$" + xl, Nk = "__reactListeners$" + xl, Gk = "__reactHandles$" + xl;
function po(t) {
  var e = t[Ur];
  if (e) return e;
  for (var r = t.parentNode; r; ) {
    if (e = r[ls] || r[Ur]) {
      if (r = e.alternate, e.child !== null || r !== null && r.child !== null) for (t = RC(t); t !== null; ) {
        if (r = t[Ur]) return r;
        t = RC(t);
      }
      return e;
    }
    t = r, r = t.parentNode;
  }
  return null;
}
function nd(t) {
  return t = t[Ur] || t[ls], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t;
}
function ol(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(gn(33));
}
function nc(t) {
  return t[Ou] || null;
}
var cf = [], ll = -1;
function Qs(t) {
  return { current: t };
}
function La(t) {
  0 > ll || (t.current = cf[ll], cf[ll] = null, ll--);
}
function Sa(t, e) {
  ll++, cf[ll] = t.current, t.current = e;
}
var Ws = {}, yi = Qs(Ws), zi = Qs(!1), _o = Ws;
function wl(t, e) {
  var r = t.type.contextTypes;
  if (!r) return Ws;
  var u = t.stateNode;
  if (u && u.__reactInternalMemoizedUnmaskedChildContext === e) return u.__reactInternalMemoizedMaskedChildContext;
  var I = {}, E;
  for (E in r) I[E] = e[E];
  return u && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = I), I;
}
function Yi(t) {
  return t = t.childContextTypes, t != null;
}
function Bg() {
  La(zi), La(yi);
}
function DC(t, e, r) {
  if (yi.current !== Ws) throw Error(gn(168));
  Sa(yi, e), Sa(zi, r);
}
function j_(t, e, r) {
  var u = t.stateNode;
  if (e = e.childContextTypes, typeof u.getChildContext != "function") return r;
  u = u.getChildContext();
  for (var I in u) if (!(I in e)) throw Error(gn(108, AT(t) || "Unknown", I));
  return Ha({}, r, u);
}
function xg(t) {
  return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ws, _o = yi.current, Sa(yi, t), Sa(zi, zi.current), !0;
}
function BC(t, e, r) {
  var u = t.stateNode;
  if (!u) throw Error(gn(169));
  r ? (t = j_(t, e, _o), u.__reactInternalMemoizedMergedChildContext = t, La(zi), La(yi), Sa(yi, t)) : La(zi), Sa(zi, r);
}
var ns = null, ac = !1, lm = !1;
function Z_(t) {
  ns === null ? ns = [t] : ns.push(t);
}
function zk(t) {
  ac = !0, Z_(t);
}
function qs() {
  if (!lm && ns !== null) {
    lm = !0;
    var t = 0, e = ya;
    try {
      var r = ns;
      for (ya = 1; t < r.length; t++) {
        var u = r[t];
        do
          u = u(!0);
        while (u !== null);
      }
      ns = null, ac = !1;
    } catch (I) {
      throw ns !== null && (ns = ns.slice(t + 1)), A_($f, qs), I;
    } finally {
      ya = e, lm = !1;
    }
  }
  return null;
}
var ul = [], dl = 0, Ng = null, Gg = 0, dr = [], gr = 0, bo = null, as = 1, is = "";
function fo(t, e) {
  ul[dl++] = Gg, ul[dl++] = Ng, Ng = t, Gg = e;
}
function J_(t, e, r) {
  dr[gr++] = as, dr[gr++] = is, dr[gr++] = bo, bo = t;
  var u = as;
  t = is;
  var I = 32 - kr(u) - 1;
  u &= ~(1 << I), r += 1;
  var E = 32 - kr(e) + I;
  if (30 < E) {
    var k = I - I % 5;
    E = (u & (1 << k) - 1).toString(32), u >>= k, I -= k, as = 1 << 32 - kr(e) + I | r << I | u, is = E + t;
  } else as = 1 << E | r << I | u, is = t;
}
function lh(t) {
  t.return !== null && (fo(t, 1), J_(t, 1, 0));
}
function uh(t) {
  for (; t === Ng; ) Ng = ul[--dl], ul[dl] = null, Gg = ul[--dl], ul[dl] = null;
  for (; t === bo; ) bo = dr[--gr], dr[gr] = null, is = dr[--gr], dr[gr] = null, as = dr[--gr], dr[gr] = null;
}
var Ji = null, ji = null, Ba = !1, Tr = null;
function Q_(t, e) {
  var r = cr(5, null, null, 0);
  r.elementType = "DELETED", r.stateNode = e, r.return = t, e = t.deletions, e === null ? (t.deletions = [r], t.flags |= 16) : e.push(r);
}
function xC(t, e) {
  switch (t.tag) {
    case 5:
      var r = t.type;
      return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Ji = t, ji = Fs(e.firstChild), !0) : !1;
    case 6:
      return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Ji = t, ji = null, !0) : !1;
    case 13:
      return e = e.nodeType !== 8 ? null : e, e !== null ? (r = bo !== null ? { id: as, overflow: is } : null, t.memoizedState = { dehydrated: e, treeContext: r, retryLane: 1073741824 }, r = cr(18, null, null, 0), r.stateNode = e, r.return = t, t.child = r, Ji = t, ji = null, !0) : !1;
    default:
      return !1;
  }
}
function mf(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function ff(t) {
  if (Ba) {
    var e = ji;
    if (e) {
      var r = e;
      if (!xC(t, e)) {
        if (mf(t)) throw Error(gn(418));
        e = Fs(r.nextSibling);
        var u = Ji;
        e && xC(t, e) ? Q_(u, r) : (t.flags = t.flags & -4097 | 2, Ba = !1, Ji = t);
      }
    } else {
      if (mf(t)) throw Error(gn(418));
      t.flags = t.flags & -4097 | 2, Ba = !1, Ji = t;
    }
  }
}
function NC(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; ) t = t.return;
  Ji = t;
}
function Zd(t) {
  if (t !== Ji) return !1;
  if (!Ba) return NC(t), Ba = !0, !1;
  var e;
  if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !uf(t.type, t.memoizedProps)), e && (e = ji)) {
    if (mf(t)) throw q_(), Error(gn(418));
    for (; e; ) Q_(t, e), e = Fs(e.nextSibling);
  }
  if (NC(t), t.tag === 13) {
    if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(gn(317));
    t: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var r = t.data;
          if (r === "/$") {
            if (e === 0) {
              ji = Fs(t.nextSibling);
              break t;
            }
            e--;
          } else r !== "$" && r !== "$!" && r !== "$?" || e++;
        }
        t = t.nextSibling;
      }
      ji = null;
    }
  } else ji = Ji ? Fs(t.stateNode.nextSibling) : null;
  return !0;
}
function q_() {
  for (var t = ji; t; ) t = Fs(t.nextSibling);
}
function vl() {
  ji = Ji = null, Ba = !1;
}
function dh(t) {
  Tr === null ? Tr = [t] : Tr.push(t);
}
var Yk = gs.ReactCurrentBatchConfig;
function du(t, e, r) {
  if (t = r.ref, t !== null && typeof t != "function" && typeof t != "object") {
    if (r._owner) {
      if (r = r._owner, r) {
        if (r.tag !== 1) throw Error(gn(309));
        var u = r.stateNode;
      }
      if (!u) throw Error(gn(147, t));
      var I = u, E = "" + t;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === E ? e.ref : (e = function(k) {
        var g = I.refs;
        k === null ? delete g[E] : g[E] = k;
      }, e._stringRef = E, e);
    }
    if (typeof t != "string") throw Error(gn(284));
    if (!r._owner) throw Error(gn(290, t));
  }
  return t;
}
function Jd(t, e) {
  throw t = Object.prototype.toString.call(e), Error(gn(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t));
}
function GC(t) {
  var e = t._init;
  return e(t._payload);
}
function $_(t) {
  function e(o, l) {
    if (t) {
      var h = o.deletions;
      h === null ? (o.deletions = [l], o.flags |= 16) : h.push(l);
    }
  }
  function r(o, l) {
    if (!t) return null;
    for (; l !== null; ) e(o, l), l = l.sibling;
    return null;
  }
  function u(o, l) {
    for (o = /* @__PURE__ */ new Map(); l !== null; ) l.key !== null ? o.set(l.key, l) : o.set(l.index, l), l = l.sibling;
    return o;
  }
  function I(o, l) {
    return o = Vs(o, l), o.index = 0, o.sibling = null, o;
  }
  function E(o, l, h) {
    return o.index = h, t ? (h = o.alternate, h !== null ? (h = h.index, h < l ? (o.flags |= 2, l) : h) : (o.flags |= 2, l)) : (o.flags |= 1048576, l);
  }
  function k(o) {
    return t && o.alternate === null && (o.flags |= 2), o;
  }
  function g(o, l, h, p) {
    return l === null || l.tag !== 6 ? (l = hm(h, o.mode, p), l.return = o, l) : (l = I(l, h), l.return = o, l);
  }
  function w(o, l, h, p) {
    var z = h.type;
    return z === al ? c(o, l, h.props.children, p, h.key) : l !== null && (l.elementType === z || typeof z == "object" && z !== null && z.$$typeof === Ds && GC(z) === l.type) ? (p = I(l, h.props), p.ref = du(o, l, h), p.return = o, p) : (p = Cg(h.type, h.key, h.props, null, o.mode, p), p.ref = du(o, l, h), p.return = o, p);
  }
  function B(o, l, h, p) {
    return l === null || l.tag !== 4 || l.stateNode.containerInfo !== h.containerInfo || l.stateNode.implementation !== h.implementation ? (l = pm(h, o.mode, p), l.return = o, l) : (l = I(l, h.children || []), l.return = o, l);
  }
  function c(o, l, h, p, z) {
    return l === null || l.tag !== 7 ? (l = Ao(h, o.mode, p, z), l.return = o, l) : (l = I(l, h), l.return = o, l);
  }
  function d(o, l, h) {
    if (typeof l == "string" && l !== "" || typeof l == "number") return l = hm("" + l, o.mode, h), l.return = o, l;
    if (typeof l == "object" && l !== null) {
      switch (l.$$typeof) {
        case Hd:
          return h = Cg(l.type, l.key, l.props, null, o.mode, h), h.ref = du(o, null, l), h.return = o, h;
        case nl:
          return l = pm(l, o.mode, h), l.return = o, l;
        case Ds:
          var p = l._init;
          return d(o, p(l._payload), h);
      }
      if (Cu(l) || ru(l)) return l = Ao(l, o.mode, h, null), l.return = o, l;
      Jd(o, l);
    }
    return null;
  }
  function m(o, l, h, p) {
    var z = l !== null ? l.key : null;
    if (typeof h == "string" && h !== "" || typeof h == "number") return z !== null ? null : g(o, l, "" + h, p);
    if (typeof h == "object" && h !== null) {
      switch (h.$$typeof) {
        case Hd:
          return h.key === z ? w(o, l, h, p) : null;
        case nl:
          return h.key === z ? B(o, l, h, p) : null;
        case Ds:
          return z = h._init, m(
            o,
            l,
            z(h._payload),
            p
          );
      }
      if (Cu(h) || ru(h)) return z !== null ? null : c(o, l, h, p, null);
      Jd(o, h);
    }
    return null;
  }
  function b(o, l, h, p, z) {
    if (typeof p == "string" && p !== "" || typeof p == "number") return o = o.get(h) || null, g(l, o, "" + p, z);
    if (typeof p == "object" && p !== null) {
      switch (p.$$typeof) {
        case Hd:
          return o = o.get(p.key === null ? h : p.key) || null, w(l, o, p, z);
        case nl:
          return o = o.get(p.key === null ? h : p.key) || null, B(l, o, p, z);
        case Ds:
          var Z = p._init;
          return b(o, l, h, Z(p._payload), z);
      }
      if (Cu(p) || ru(p)) return o = o.get(h) || null, c(l, o, p, z, null);
      Jd(l, p);
    }
    return null;
  }
  function y(o, l, h, p) {
    for (var z = null, Z = null, V = l, Q = l = 0, vt = null; V !== null && Q < h.length; Q++) {
      V.index > Q ? (vt = V, V = null) : vt = V.sibling;
      var Lt = m(o, V, h[Q], p);
      if (Lt === null) {
        V === null && (V = vt);
        break;
      }
      t && V && Lt.alternate === null && e(o, V), l = E(Lt, l, Q), Z === null ? z = Lt : Z.sibling = Lt, Z = Lt, V = vt;
    }
    if (Q === h.length) return r(o, V), Ba && fo(o, Q), z;
    if (V === null) {
      for (; Q < h.length; Q++) V = d(o, h[Q], p), V !== null && (l = E(V, l, Q), Z === null ? z = V : Z.sibling = V, Z = V);
      return Ba && fo(o, Q), z;
    }
    for (V = u(o, V); Q < h.length; Q++) vt = b(V, o, Q, h[Q], p), vt !== null && (t && vt.alternate !== null && V.delete(vt.key === null ? Q : vt.key), l = E(vt, l, Q), Z === null ? z = vt : Z.sibling = vt, Z = vt);
    return t && V.forEach(function(zt) {
      return e(o, zt);
    }), Ba && fo(o, Q), z;
  }
  function T(o, l, h, p) {
    var z = ru(h);
    if (typeof z != "function") throw Error(gn(150));
    if (h = z.call(h), h == null) throw Error(gn(151));
    for (var Z = z = null, V = l, Q = l = 0, vt = null, Lt = h.next(); V !== null && !Lt.done; Q++, Lt = h.next()) {
      V.index > Q ? (vt = V, V = null) : vt = V.sibling;
      var zt = m(o, V, Lt.value, p);
      if (zt === null) {
        V === null && (V = vt);
        break;
      }
      t && V && zt.alternate === null && e(o, V), l = E(zt, l, Q), Z === null ? z = zt : Z.sibling = zt, Z = zt, V = vt;
    }
    if (Lt.done) return r(
      o,
      V
    ), Ba && fo(o, Q), z;
    if (V === null) {
      for (; !Lt.done; Q++, Lt = h.next()) Lt = d(o, Lt.value, p), Lt !== null && (l = E(Lt, l, Q), Z === null ? z = Lt : Z.sibling = Lt, Z = Lt);
      return Ba && fo(o, Q), z;
    }
    for (V = u(o, V); !Lt.done; Q++, Lt = h.next()) Lt = b(V, o, Q, Lt.value, p), Lt !== null && (t && Lt.alternate !== null && V.delete(Lt.key === null ? Q : Lt.key), l = E(Lt, l, Q), Z === null ? z = Lt : Z.sibling = Lt, Z = Lt);
    return t && V.forEach(function(X) {
      return e(o, X);
    }), Ba && fo(o, Q), z;
  }
  function n(o, l, h, p) {
    if (typeof h == "object" && h !== null && h.type === al && h.key === null && (h = h.props.children), typeof h == "object" && h !== null) {
      switch (h.$$typeof) {
        case Hd:
          t: {
            for (var z = h.key, Z = l; Z !== null; ) {
              if (Z.key === z) {
                if (z = h.type, z === al) {
                  if (Z.tag === 7) {
                    r(o, Z.sibling), l = I(Z, h.props.children), l.return = o, o = l;
                    break t;
                  }
                } else if (Z.elementType === z || typeof z == "object" && z !== null && z.$$typeof === Ds && GC(z) === Z.type) {
                  r(o, Z.sibling), l = I(Z, h.props), l.ref = du(o, Z, h), l.return = o, o = l;
                  break t;
                }
                r(o, Z);
                break;
              } else e(o, Z);
              Z = Z.sibling;
            }
            h.type === al ? (l = Ao(h.props.children, o.mode, p, h.key), l.return = o, o = l) : (p = Cg(h.type, h.key, h.props, null, o.mode, p), p.ref = du(o, l, h), p.return = o, o = p);
          }
          return k(o);
        case nl:
          t: {
            for (Z = h.key; l !== null; ) {
              if (l.key === Z) if (l.tag === 4 && l.stateNode.containerInfo === h.containerInfo && l.stateNode.implementation === h.implementation) {
                r(o, l.sibling), l = I(l, h.children || []), l.return = o, o = l;
                break t;
              } else {
                r(o, l);
                break;
              }
              else e(o, l);
              l = l.sibling;
            }
            l = pm(h, o.mode, p), l.return = o, o = l;
          }
          return k(o);
        case Ds:
          return Z = h._init, n(o, l, Z(h._payload), p);
      }
      if (Cu(h)) return y(o, l, h, p);
      if (ru(h)) return T(o, l, h, p);
      Jd(o, h);
    }
    return typeof h == "string" && h !== "" || typeof h == "number" ? (h = "" + h, l !== null && l.tag === 6 ? (r(o, l.sibling), l = I(l, h), l.return = o, o = l) : (r(o, l), l = hm(h, o.mode, p), l.return = o, o = l), k(o)) : r(o, l);
  }
  return n;
}
var El = $_(!0), tb = $_(!1), zg = Qs(null), Yg = null, gl = null, gh = null;
function ch() {
  gh = gl = Yg = null;
}
function mh(t) {
  var e = zg.current;
  La(zg), t._currentValue = e;
}
function hf(t, e, r) {
  for (; t !== null; ) {
    var u = t.alternate;
    if ((t.childLanes & e) !== e ? (t.childLanes |= e, u !== null && (u.childLanes |= e)) : u !== null && (u.childLanes & e) !== e && (u.childLanes |= e), t === r) break;
    t = t.return;
  }
}
function _l(t, e) {
  Yg = t, gh = gl = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Gi = !0), t.firstContext = null);
}
function hr(t) {
  var e = t._currentValue;
  if (gh !== t) if (t = { context: t, memoizedValue: e, next: null }, gl === null) {
    if (Yg === null) throw Error(gn(308));
    gl = t, Yg.dependencies = { lanes: 0, firstContext: t };
  } else gl = gl.next = t;
  return e;
}
var Io = null;
function fh(t) {
  Io === null ? Io = [t] : Io.push(t);
}
function eb(t, e, r, u) {
  var I = e.interleaved;
  return I === null ? (r.next = r, fh(e)) : (r.next = I.next, I.next = r), e.interleaved = r, us(t, u);
}
function us(t, e) {
  t.lanes |= e;
  var r = t.alternate;
  for (r !== null && (r.lanes |= e), r = t, t = t.return; t !== null; ) t.childLanes |= e, r = t.alternate, r !== null && (r.childLanes |= e), r = t, t = t.return;
  return r.tag === 3 ? r.stateNode : null;
}
var Bs = !1;
function hh(t) {
  t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function nb(t, e) {
  t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects });
}
function ss(t, e) {
  return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function Os(t, e, r) {
  var u = t.updateQueue;
  if (u === null) return null;
  if (u = u.shared, fa & 2) {
    var I = u.pending;
    return I === null ? e.next = e : (e.next = I.next, I.next = e), u.pending = e, us(t, r);
  }
  return I = u.interleaved, I === null ? (e.next = e, fh(u)) : (e.next = I.next, I.next = e), u.interleaved = e, us(t, r);
}
function cg(t, e, r) {
  if (e = e.updateQueue, e !== null && (e = e.shared, (r & 4194240) !== 0)) {
    var u = e.lanes;
    u &= t.pendingLanes, r |= u, e.lanes = r, th(t, r);
  }
}
function zC(t, e) {
  var r = t.updateQueue, u = t.alternate;
  if (u !== null && (u = u.updateQueue, r === u)) {
    var I = null, E = null;
    if (r = r.firstBaseUpdate, r !== null) {
      do {
        var k = { eventTime: r.eventTime, lane: r.lane, tag: r.tag, payload: r.payload, callback: r.callback, next: null };
        E === null ? I = E = k : E = E.next = k, r = r.next;
      } while (r !== null);
      E === null ? I = E = e : E = E.next = e;
    } else I = E = e;
    r = { baseState: u.baseState, firstBaseUpdate: I, lastBaseUpdate: E, shared: u.shared, effects: u.effects }, t.updateQueue = r;
    return;
  }
  t = r.lastBaseUpdate, t === null ? r.firstBaseUpdate = e : t.next = e, r.lastBaseUpdate = e;
}
function Hg(t, e, r, u) {
  var I = t.updateQueue;
  Bs = !1;
  var E = I.firstBaseUpdate, k = I.lastBaseUpdate, g = I.shared.pending;
  if (g !== null) {
    I.shared.pending = null;
    var w = g, B = w.next;
    w.next = null, k === null ? E = B : k.next = B, k = w;
    var c = t.alternate;
    c !== null && (c = c.updateQueue, g = c.lastBaseUpdate, g !== k && (g === null ? c.firstBaseUpdate = B : g.next = B, c.lastBaseUpdate = w));
  }
  if (E !== null) {
    var d = I.baseState;
    k = 0, c = B = w = null, g = E;
    do {
      var m = g.lane, b = g.eventTime;
      if ((u & m) === m) {
        c !== null && (c = c.next = {
          eventTime: b,
          lane: 0,
          tag: g.tag,
          payload: g.payload,
          callback: g.callback,
          next: null
        });
        t: {
          var y = t, T = g;
          switch (m = e, b = r, T.tag) {
            case 1:
              if (y = T.payload, typeof y == "function") {
                d = y.call(b, d, m);
                break t;
              }
              d = y;
              break t;
            case 3:
              y.flags = y.flags & -65537 | 128;
            case 0:
              if (y = T.payload, m = typeof y == "function" ? y.call(b, d, m) : y, m == null) break t;
              d = Ha({}, d, m);
              break t;
            case 2:
              Bs = !0;
          }
        }
        g.callback !== null && g.lane !== 0 && (t.flags |= 64, m = I.effects, m === null ? I.effects = [g] : m.push(g));
      } else b = { eventTime: b, lane: m, tag: g.tag, payload: g.payload, callback: g.callback, next: null }, c === null ? (B = c = b, w = d) : c = c.next = b, k |= m;
      if (g = g.next, g === null) {
        if (g = I.shared.pending, g === null) break;
        m = g, g = m.next, m.next = null, I.lastBaseUpdate = m, I.shared.pending = null;
      }
    } while (!0);
    if (c === null && (w = d), I.baseState = w, I.firstBaseUpdate = B, I.lastBaseUpdate = c, e = I.shared.interleaved, e !== null) {
      I = e;
      do
        k |= I.lane, I = I.next;
      while (I !== e);
    } else E === null && (I.shared.lanes = 0);
    wo |= k, t.lanes = k, t.memoizedState = d;
  }
}
function YC(t, e, r) {
  if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) {
    var u = t[e], I = u.callback;
    if (I !== null) {
      if (u.callback = null, u = r, typeof I != "function") throw Error(gn(191, I));
      I.call(u);
    }
  }
}
var ad = {}, Vr = Qs(ad), Uu = Qs(ad), Ku = Qs(ad);
function Co(t) {
  if (t === ad) throw Error(gn(174));
  return t;
}
function ph(t, e) {
  switch (Sa(Ku, e), Sa(Uu, t), Sa(Vr, ad), t = e.nodeType, t) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : jm(null, "");
      break;
    default:
      t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = jm(e, t);
  }
  La(Vr), Sa(Vr, e);
}
function Tl() {
  La(Vr), La(Uu), La(Ku);
}
function ab(t) {
  Co(Ku.current);
  var e = Co(Vr.current), r = jm(e, t.type);
  e !== r && (Sa(Uu, t), Sa(Vr, r));
}
function Ih(t) {
  Uu.current === t && (La(Vr), La(Uu));
}
var za = Qs(0);
function Pg(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var r = e.memoizedState;
      if (r !== null && (r = r.dehydrated, r === null || r.data === "$?" || r.data === "$!")) return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    e.sibling.return = e.return, e = e.sibling;
  }
  return null;
}
var um = [];
function Ch() {
  for (var t = 0; t < um.length; t++) um[t]._workInProgressVersionPrimary = null;
  um.length = 0;
}
var mg = gs.ReactCurrentDispatcher, dm = gs.ReactCurrentBatchConfig, So = 0, Ya = null, $a = null, ii = null, Fg = !1, ku = !1, Vu = 0, Hk = 0;
function mi() {
  throw Error(gn(321));
}
function yh(t, e) {
  if (e === null) return !1;
  for (var r = 0; r < e.length && r < t.length; r++) if (!Mr(t[r], e[r])) return !1;
  return !0;
}
function Ah(t, e, r, u, I, E) {
  if (So = E, Ya = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, mg.current = t === null || t.memoizedState === null ? Uk : Kk, t = r(u, I), ku) {
    E = 0;
    do {
      if (ku = !1, Vu = 0, 25 <= E) throw Error(gn(301));
      E += 1, ii = $a = null, e.updateQueue = null, mg.current = Vk, t = r(u, I);
    } while (ku);
  }
  if (mg.current = Og, e = $a !== null && $a.next !== null, So = 0, ii = $a = Ya = null, Fg = !1, e) throw Error(gn(300));
  return t;
}
function _h() {
  var t = Vu !== 0;
  return Vu = 0, t;
}
function Pr() {
  var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return ii === null ? Ya.memoizedState = ii = t : ii = ii.next = t, ii;
}
function pr() {
  if ($a === null) {
    var t = Ya.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = $a.next;
  var e = ii === null ? Ya.memoizedState : ii.next;
  if (e !== null) ii = e, $a = t;
  else {
    if (t === null) throw Error(gn(310));
    $a = t, t = { memoizedState: $a.memoizedState, baseState: $a.baseState, baseQueue: $a.baseQueue, queue: $a.queue, next: null }, ii === null ? Ya.memoizedState = ii = t : ii = ii.next = t;
  }
  return ii;
}
function Xu(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function gm(t) {
  var e = pr(), r = e.queue;
  if (r === null) throw Error(gn(311));
  r.lastRenderedReducer = t;
  var u = $a, I = u.baseQueue, E = r.pending;
  if (E !== null) {
    if (I !== null) {
      var k = I.next;
      I.next = E.next, E.next = k;
    }
    u.baseQueue = I = E, r.pending = null;
  }
  if (I !== null) {
    E = I.next, u = u.baseState;
    var g = k = null, w = null, B = E;
    do {
      var c = B.lane;
      if ((So & c) === c) w !== null && (w = w.next = { lane: 0, action: B.action, hasEagerState: B.hasEagerState, eagerState: B.eagerState, next: null }), u = B.hasEagerState ? B.eagerState : t(u, B.action);
      else {
        var d = {
          lane: c,
          action: B.action,
          hasEagerState: B.hasEagerState,
          eagerState: B.eagerState,
          next: null
        };
        w === null ? (g = w = d, k = u) : w = w.next = d, Ya.lanes |= c, wo |= c;
      }
      B = B.next;
    } while (B !== null && B !== E);
    w === null ? k = u : w.next = g, Mr(u, e.memoizedState) || (Gi = !0), e.memoizedState = u, e.baseState = k, e.baseQueue = w, r.lastRenderedState = u;
  }
  if (t = r.interleaved, t !== null) {
    I = t;
    do
      E = I.lane, Ya.lanes |= E, wo |= E, I = I.next;
    while (I !== t);
  } else I === null && (r.lanes = 0);
  return [e.memoizedState, r.dispatch];
}
function cm(t) {
  var e = pr(), r = e.queue;
  if (r === null) throw Error(gn(311));
  r.lastRenderedReducer = t;
  var u = r.dispatch, I = r.pending, E = e.memoizedState;
  if (I !== null) {
    r.pending = null;
    var k = I = I.next;
    do
      E = t(E, k.action), k = k.next;
    while (k !== I);
    Mr(E, e.memoizedState) || (Gi = !0), e.memoizedState = E, e.baseQueue === null && (e.baseState = E), r.lastRenderedState = E;
  }
  return [E, u];
}
function ib() {
}
function rb(t, e) {
  var r = Ya, u = pr(), I = e(), E = !Mr(u.memoizedState, I);
  if (E && (u.memoizedState = I, Gi = !0), u = u.queue, bh(lb.bind(null, r, u, t), [t]), u.getSnapshot !== e || E || ii !== null && ii.memoizedState.tag & 1) {
    if (r.flags |= 2048, Wu(9, ob.bind(null, r, u, I, e), void 0, null), ri === null) throw Error(gn(349));
    So & 30 || sb(r, e, I);
  }
  return I;
}
function sb(t, e, r) {
  t.flags |= 16384, t = { getSnapshot: e, value: r }, e = Ya.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ya.updateQueue = e, e.stores = [t]) : (r = e.stores, r === null ? e.stores = [t] : r.push(t));
}
function ob(t, e, r, u) {
  e.value = r, e.getSnapshot = u, ub(e) && db(t);
}
function lb(t, e, r) {
  return r(function() {
    ub(e) && db(t);
  });
}
function ub(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var r = e();
    return !Mr(t, r);
  } catch (u) {
    return !0;
  }
}
function db(t) {
  var e = us(t, 1);
  e !== null && Lr(e, t, 1, -1);
}
function HC(t) {
  var e = Pr();
  return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Xu, lastRenderedState: t }, e.queue = t, t = t.dispatch = Ok.bind(null, Ya, t), [e.memoizedState, t];
}
function Wu(t, e, r, u) {
  return t = { tag: t, create: e, destroy: r, deps: u, next: null }, e = Ya.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, Ya.updateQueue = e, e.lastEffect = t.next = t) : (r = e.lastEffect, r === null ? e.lastEffect = t.next = t : (u = r.next, r.next = t, t.next = u, e.lastEffect = t)), t;
}
function gb() {
  return pr().memoizedState;
}
function fg(t, e, r, u) {
  var I = Pr();
  Ya.flags |= t, I.memoizedState = Wu(1 | e, r, void 0, u === void 0 ? null : u);
}
function ic(t, e, r, u) {
  var I = pr();
  u = u === void 0 ? null : u;
  var E = void 0;
  if ($a !== null) {
    var k = $a.memoizedState;
    if (E = k.destroy, u !== null && yh(u, k.deps)) {
      I.memoizedState = Wu(e, r, E, u);
      return;
    }
  }
  Ya.flags |= t, I.memoizedState = Wu(1 | e, r, E, u);
}
function PC(t, e) {
  return fg(8390656, 8, t, e);
}
function bh(t, e) {
  return ic(2048, 8, t, e);
}
function cb(t, e) {
  return ic(4, 2, t, e);
}
function mb(t, e) {
  return ic(4, 4, t, e);
}
function fb(t, e) {
  if (typeof e == "function") return t = t(), e(t), function() {
    e(null);
  };
  if (e != null) return t = t(), e.current = t, function() {
    e.current = null;
  };
}
function hb(t, e, r) {
  return r = r != null ? r.concat([t]) : null, ic(4, 4, fb.bind(null, e, t), r);
}
function Sh() {
}
function pb(t, e) {
  var r = pr();
  e = e === void 0 ? null : e;
  var u = r.memoizedState;
  return u !== null && e !== null && yh(e, u[1]) ? u[0] : (r.memoizedState = [t, e], t);
}
function Ib(t, e) {
  var r = pr();
  e = e === void 0 ? null : e;
  var u = r.memoizedState;
  return u !== null && e !== null && yh(e, u[1]) ? u[0] : (t = t(), r.memoizedState = [t, e], t);
}
function Cb(t, e, r) {
  return So & 21 ? (Mr(r, e) || (r = S_(), Ya.lanes |= r, wo |= r, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Gi = !0), t.memoizedState = r);
}
function Pk(t, e) {
  var r = ya;
  ya = r !== 0 && 4 > r ? r : 4, t(!0);
  var u = dm.transition;
  dm.transition = {};
  try {
    t(!1), e();
  } finally {
    ya = r, dm.transition = u;
  }
}
function yb() {
  return pr().memoizedState;
}
function Fk(t, e, r) {
  var u = Ks(t);
  if (r = { lane: u, action: r, hasEagerState: !1, eagerState: null, next: null }, Ab(t)) _b(e, r);
  else if (r = eb(t, e, r, u), r !== null) {
    var I = Si();
    Lr(r, t, u, I), bb(r, e, u);
  }
}
function Ok(t, e, r) {
  var u = Ks(t), I = { lane: u, action: r, hasEagerState: !1, eagerState: null, next: null };
  if (Ab(t)) _b(e, I);
  else {
    var E = t.alternate;
    if (t.lanes === 0 && (E === null || E.lanes === 0) && (E = e.lastRenderedReducer, E !== null)) try {
      var k = e.lastRenderedState, g = E(k, r);
      if (I.hasEagerState = !0, I.eagerState = g, Mr(g, k)) {
        var w = e.interleaved;
        w === null ? (I.next = I, fh(e)) : (I.next = w.next, w.next = I), e.interleaved = I;
        return;
      }
    } catch (B) {
    } finally {
    }
    r = eb(t, e, I, u), r !== null && (I = Si(), Lr(r, t, u, I), bb(r, e, u));
  }
}
function Ab(t) {
  var e = t.alternate;
  return t === Ya || e !== null && e === Ya;
}
function _b(t, e) {
  ku = Fg = !0;
  var r = t.pending;
  r === null ? e.next = e : (e.next = r.next, r.next = e), t.pending = e;
}
function bb(t, e, r) {
  if (r & 4194240) {
    var u = e.lanes;
    u &= t.pendingLanes, r |= u, e.lanes = r, th(t, r);
  }
}
var Og = { readContext: hr, useCallback: mi, useContext: mi, useEffect: mi, useImperativeHandle: mi, useInsertionEffect: mi, useLayoutEffect: mi, useMemo: mi, useReducer: mi, useRef: mi, useState: mi, useDebugValue: mi, useDeferredValue: mi, useTransition: mi, useMutableSource: mi, useSyncExternalStore: mi, useId: mi, unstable_isNewReconciler: !1 }, Uk = { readContext: hr, useCallback: function(t, e) {
  return Pr().memoizedState = [t, e === void 0 ? null : e], t;
}, useContext: hr, useEffect: PC, useImperativeHandle: function(t, e, r) {
  return r = r != null ? r.concat([t]) : null, fg(
    4194308,
    4,
    fb.bind(null, e, t),
    r
  );
}, useLayoutEffect: function(t, e) {
  return fg(4194308, 4, t, e);
}, useInsertionEffect: function(t, e) {
  return fg(4, 2, t, e);
}, useMemo: function(t, e) {
  var r = Pr();
  return e = e === void 0 ? null : e, t = t(), r.memoizedState = [t, e], t;
}, useReducer: function(t, e, r) {
  var u = Pr();
  return e = r !== void 0 ? r(e) : e, u.memoizedState = u.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, u.queue = t, t = t.dispatch = Fk.bind(null, Ya, t), [u.memoizedState, t];
}, useRef: function(t) {
  var e = Pr();
  return t = { current: t }, e.memoizedState = t;
}, useState: HC, useDebugValue: Sh, useDeferredValue: function(t) {
  return Pr().memoizedState = t;
}, useTransition: function() {
  var t = HC(!1), e = t[0];
  return t = Pk.bind(null, t[1]), Pr().memoizedState = t, [e, t];
}, useMutableSource: function() {
}, useSyncExternalStore: function(t, e, r) {
  var u = Ya, I = Pr();
  if (Ba) {
    if (r === void 0) throw Error(gn(407));
    r = r();
  } else {
    if (r = e(), ri === null) throw Error(gn(349));
    So & 30 || sb(u, e, r);
  }
  I.memoizedState = r;
  var E = { value: r, getSnapshot: e };
  return I.queue = E, PC(lb.bind(
    null,
    u,
    E,
    t
  ), [t]), u.flags |= 2048, Wu(9, ob.bind(null, u, E, r, e), void 0, null), r;
}, useId: function() {
  var t = Pr(), e = ri.identifierPrefix;
  if (Ba) {
    var r = is, u = as;
    r = (u & ~(1 << 32 - kr(u) - 1)).toString(32) + r, e = ":" + e + "R" + r, r = Vu++, 0 < r && (e += "H" + r.toString(32)), e += ":";
  } else r = Hk++, e = ":" + e + "r" + r.toString(32) + ":";
  return t.memoizedState = e;
}, unstable_isNewReconciler: !1 }, Kk = {
  readContext: hr,
  useCallback: pb,
  useContext: hr,
  useEffect: bh,
  useImperativeHandle: hb,
  useInsertionEffect: cb,
  useLayoutEffect: mb,
  useMemo: Ib,
  useReducer: gm,
  useRef: gb,
  useState: function() {
    return gm(Xu);
  },
  useDebugValue: Sh,
  useDeferredValue: function(t) {
    var e = pr();
    return Cb(e, $a.memoizedState, t);
  },
  useTransition: function() {
    var t = gm(Xu)[0], e = pr().memoizedState;
    return [t, e];
  },
  useMutableSource: ib,
  useSyncExternalStore: rb,
  useId: yb,
  unstable_isNewReconciler: !1
}, Vk = { readContext: hr, useCallback: pb, useContext: hr, useEffect: bh, useImperativeHandle: hb, useInsertionEffect: cb, useLayoutEffect: mb, useMemo: Ib, useReducer: cm, useRef: gb, useState: function() {
  return cm(Xu);
}, useDebugValue: Sh, useDeferredValue: function(t) {
  var e = pr();
  return $a === null ? e.memoizedState = t : Cb(e, $a.memoizedState, t);
}, useTransition: function() {
  var t = cm(Xu)[0], e = pr().memoizedState;
  return [t, e];
}, useMutableSource: ib, useSyncExternalStore: rb, useId: yb, unstable_isNewReconciler: !1 };
function vr(t, e) {
  if (t && t.defaultProps) {
    e = Ha({}, e), t = t.defaultProps;
    for (var r in t) e[r] === void 0 && (e[r] = t[r]);
    return e;
  }
  return e;
}
function pf(t, e, r, u) {
  e = t.memoizedState, r = r(u, e), r = r == null ? e : Ha({}, e, r), t.memoizedState = r, t.lanes === 0 && (t.updateQueue.baseState = r);
}
var rc = { isMounted: function(t) {
  return (t = t._reactInternals) ? To(t) === t : !1;
}, enqueueSetState: function(t, e, r) {
  t = t._reactInternals;
  var u = Si(), I = Ks(t), E = ss(u, I);
  E.payload = e, r != null && (E.callback = r), e = Os(t, E, I), e !== null && (Lr(e, t, I, u), cg(e, t, I));
}, enqueueReplaceState: function(t, e, r) {
  t = t._reactInternals;
  var u = Si(), I = Ks(t), E = ss(u, I);
  E.tag = 1, E.payload = e, r != null && (E.callback = r), e = Os(t, E, I), e !== null && (Lr(e, t, I, u), cg(e, t, I));
}, enqueueForceUpdate: function(t, e) {
  t = t._reactInternals;
  var r = Si(), u = Ks(t), I = ss(r, u);
  I.tag = 2, e != null && (I.callback = e), e = Os(t, I, u), e !== null && (Lr(e, t, u, r), cg(e, t, u));
} };
function FC(t, e, r, u, I, E, k) {
  return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(u, E, k) : e.prototype && e.prototype.isPureReactComponent ? !Hu(r, u) || !Hu(I, E) : !0;
}
function Sb(t, e, r) {
  var u = !1, I = Ws, E = e.contextType;
  return typeof E == "object" && E !== null ? E = hr(E) : (I = Yi(e) ? _o : yi.current, u = e.contextTypes, E = (u = u != null) ? wl(t, I) : Ws), e = new e(r, E), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = rc, t.stateNode = e, e._reactInternals = t, u && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = I, t.__reactInternalMemoizedMaskedChildContext = E), e;
}
function OC(t, e, r, u) {
  t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, u), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, u), e.state !== t && rc.enqueueReplaceState(e, e.state, null);
}
function If(t, e, r, u) {
  var I = t.stateNode;
  I.props = r, I.state = t.memoizedState, I.refs = {}, hh(t);
  var E = e.contextType;
  typeof E == "object" && E !== null ? I.context = hr(E) : (E = Yi(e) ? _o : yi.current, I.context = wl(t, E)), I.state = t.memoizedState, E = e.getDerivedStateFromProps, typeof E == "function" && (pf(t, e, E, r), I.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (e = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), e !== I.state && rc.enqueueReplaceState(I, I.state, null), Hg(t, r, I, u), I.state = t.memoizedState), typeof I.componentDidMount == "function" && (t.flags |= 4194308);
}
function kl(t, e) {
  try {
    var r = "", u = e;
    do
      r += yT(u), u = u.return;
    while (u);
    var I = r;
  } catch (E) {
    I = `
Error generating stack: ` + E.message + `
` + E.stack;
  }
  return { value: t, source: e, stack: I, digest: null };
}
function mm(t, e, r) {
  return { value: t, source: null, stack: r != null ? r : null, digest: e != null ? e : null };
}
function Cf(t, e) {
  try {
    console.error(e.value);
  } catch (r) {
    setTimeout(function() {
      throw r;
    });
  }
}
var Xk = typeof WeakMap == "function" ? WeakMap : Map;
function wb(t, e, r) {
  r = ss(-1, r), r.tag = 3, r.payload = { element: null };
  var u = e.value;
  return r.callback = function() {
    Kg || (Kg = !0, kf = u), Cf(t, e);
  }, r;
}
function vb(t, e, r) {
  r = ss(-1, r), r.tag = 3;
  var u = t.type.getDerivedStateFromError;
  if (typeof u == "function") {
    var I = e.value;
    r.payload = function() {
      return u(I);
    }, r.callback = function() {
      Cf(t, e);
    };
  }
  var E = t.stateNode;
  return E !== null && typeof E.componentDidCatch == "function" && (r.callback = function() {
    Cf(t, e), typeof u != "function" && (Us === null ? Us = /* @__PURE__ */ new Set([this]) : Us.add(this));
    var k = e.stack;
    this.componentDidCatch(e.value, { componentStack: k !== null ? k : "" });
  }), r;
}
function UC(t, e, r) {
  var u = t.pingCache;
  if (u === null) {
    u = t.pingCache = new Xk();
    var I = /* @__PURE__ */ new Set();
    u.set(e, I);
  } else I = u.get(e), I === void 0 && (I = /* @__PURE__ */ new Set(), u.set(e, I));
  I.has(r) || (I.add(r), t = sL.bind(null, t, e, r), e.then(t, t));
}
function KC(t) {
  do {
    var e;
    if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function VC(t, e, r, u, I) {
  return t.mode & 1 ? (t.flags |= 65536, t.lanes = I, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, r.flags |= 131072, r.flags &= -52805, r.tag === 1 && (r.alternate === null ? r.tag = 17 : (e = ss(-1, 1), e.tag = 2, Os(r, e, 1))), r.lanes |= 1), t);
}
var Wk = gs.ReactCurrentOwner, Gi = !1;
function bi(t, e, r, u) {
  e.child = t === null ? tb(e, null, r, u) : El(e, t.child, r, u);
}
function XC(t, e, r, u, I) {
  r = r.render;
  var E = e.ref;
  return _l(e, I), u = Ah(t, e, r, u, E, I), r = _h(), t !== null && !Gi ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~I, ds(t, e, I)) : (Ba && r && lh(e), e.flags |= 1, bi(t, e, u, I), e.child);
}
function WC(t, e, r, u, I) {
  if (t === null) {
    var E = r.type;
    return typeof E == "function" && !Rh(E) && E.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15, e.type = E, Eb(t, e, E, u, I)) : (t = Cg(r.type, null, u, e, e.mode, I), t.ref = e.ref, t.return = e, e.child = t);
  }
  if (E = t.child, !(t.lanes & I)) {
    var k = E.memoizedProps;
    if (r = r.compare, r = r !== null ? r : Hu, r(k, u) && t.ref === e.ref) return ds(t, e, I);
  }
  return e.flags |= 1, t = Vs(E, u), t.ref = e.ref, t.return = e, e.child = t;
}
function Eb(t, e, r, u, I) {
  if (t !== null) {
    var E = t.memoizedProps;
    if (Hu(E, u) && t.ref === e.ref) if (Gi = !1, e.pendingProps = u = E, (t.lanes & I) !== 0) t.flags & 131072 && (Gi = !0);
    else return e.lanes = t.lanes, ds(t, e, I);
  }
  return yf(t, e, r, u, I);
}
function Tb(t, e, r) {
  var u = e.pendingProps, I = u.children, E = t !== null ? t.memoizedState : null;
  if (u.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Sa(ml, Wi), Wi |= r;
  else {
    if (!(r & 1073741824)) return t = E !== null ? E.baseLanes | r : r, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, Sa(ml, Wi), Wi |= t, null;
    e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, u = E !== null ? E.baseLanes : r, Sa(ml, Wi), Wi |= u;
  }
  else E !== null ? (u = E.baseLanes | r, e.memoizedState = null) : u = r, Sa(ml, Wi), Wi |= u;
  return bi(t, e, I, r), e.child;
}
function kb(t, e) {
  var r = e.ref;
  (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 512, e.flags |= 2097152);
}
function yf(t, e, r, u, I) {
  var E = Yi(r) ? _o : yi.current;
  return E = wl(e, E), _l(e, I), r = Ah(t, e, r, u, E, I), u = _h(), t !== null && !Gi ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~I, ds(t, e, I)) : (Ba && u && lh(e), e.flags |= 1, bi(t, e, r, I), e.child);
}
function jC(t, e, r, u, I) {
  if (Yi(r)) {
    var E = !0;
    xg(e);
  } else E = !1;
  if (_l(e, I), e.stateNode === null) hg(t, e), Sb(e, r, u), If(e, r, u, I), u = !0;
  else if (t === null) {
    var k = e.stateNode, g = e.memoizedProps;
    k.props = g;
    var w = k.context, B = r.contextType;
    typeof B == "object" && B !== null ? B = hr(B) : (B = Yi(r) ? _o : yi.current, B = wl(e, B));
    var c = r.getDerivedStateFromProps, d = typeof c == "function" || typeof k.getSnapshotBeforeUpdate == "function";
    d || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (g !== u || w !== B) && OC(e, k, u, B), Bs = !1;
    var m = e.memoizedState;
    k.state = m, Hg(e, u, k, I), w = e.memoizedState, g !== u || m !== w || zi.current || Bs ? (typeof c == "function" && (pf(e, r, c, u), w = e.memoizedState), (g = Bs || FC(e, r, g, u, m, w, B)) ? (d || typeof k.UNSAFE_componentWillMount != "function" && typeof k.componentWillMount != "function" || (typeof k.componentWillMount == "function" && k.componentWillMount(), typeof k.UNSAFE_componentWillMount == "function" && k.UNSAFE_componentWillMount()), typeof k.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof k.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = u, e.memoizedState = w), k.props = u, k.state = w, k.context = B, u = g) : (typeof k.componentDidMount == "function" && (e.flags |= 4194308), u = !1);
  } else {
    k = e.stateNode, nb(t, e), g = e.memoizedProps, B = e.type === e.elementType ? g : vr(e.type, g), k.props = B, d = e.pendingProps, m = k.context, w = r.contextType, typeof w == "object" && w !== null ? w = hr(w) : (w = Yi(r) ? _o : yi.current, w = wl(e, w));
    var b = r.getDerivedStateFromProps;
    (c = typeof b == "function" || typeof k.getSnapshotBeforeUpdate == "function") || typeof k.UNSAFE_componentWillReceiveProps != "function" && typeof k.componentWillReceiveProps != "function" || (g !== d || m !== w) && OC(e, k, u, w), Bs = !1, m = e.memoizedState, k.state = m, Hg(e, u, k, I);
    var y = e.memoizedState;
    g !== d || m !== y || zi.current || Bs ? (typeof b == "function" && (pf(e, r, b, u), y = e.memoizedState), (B = Bs || FC(e, r, B, u, m, y, w) || !1) ? (c || typeof k.UNSAFE_componentWillUpdate != "function" && typeof k.componentWillUpdate != "function" || (typeof k.componentWillUpdate == "function" && k.componentWillUpdate(u, y, w), typeof k.UNSAFE_componentWillUpdate == "function" && k.UNSAFE_componentWillUpdate(u, y, w)), typeof k.componentDidUpdate == "function" && (e.flags |= 4), typeof k.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof k.componentDidUpdate != "function" || g === t.memoizedProps && m === t.memoizedState || (e.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || g === t.memoizedProps && m === t.memoizedState || (e.flags |= 1024), e.memoizedProps = u, e.memoizedState = y), k.props = u, k.state = y, k.context = w, u = B) : (typeof k.componentDidUpdate != "function" || g === t.memoizedProps && m === t.memoizedState || (e.flags |= 4), typeof k.getSnapshotBeforeUpdate != "function" || g === t.memoizedProps && m === t.memoizedState || (e.flags |= 1024), u = !1);
  }
  return Af(t, e, r, u, E, I);
}
function Af(t, e, r, u, I, E) {
  kb(t, e);
  var k = (e.flags & 128) !== 0;
  if (!u && !k) return I && BC(e, r, !1), ds(t, e, E);
  u = e.stateNode, Wk.current = e;
  var g = k && typeof r.getDerivedStateFromError != "function" ? null : u.render();
  return e.flags |= 1, t !== null && k ? (e.child = El(e, t.child, null, E), e.child = El(e, null, g, E)) : bi(t, e, g, E), e.memoizedState = u.state, I && BC(e, r, !0), e.child;
}
function Lb(t) {
  var e = t.stateNode;
  e.pendingContext ? DC(t, e.pendingContext, e.pendingContext !== e.context) : e.context && DC(t, e.context, !1), ph(t, e.containerInfo);
}
function ZC(t, e, r, u, I) {
  return vl(), dh(I), e.flags |= 256, bi(t, e, r, u), e.child;
}
var _f = { dehydrated: null, treeContext: null, retryLane: 0 };
function bf(t) {
  return { baseLanes: t, cachePool: null, transitions: null };
}
function Mb(t, e, r) {
  var u = e.pendingProps, I = za.current, E = !1, k = (e.flags & 128) !== 0, g;
  if ((g = k) || (g = t !== null && t.memoizedState === null ? !1 : (I & 2) !== 0), g ? (E = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (I |= 1), Sa(za, I & 1), t === null)
    return ff(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (k = u.children, t = u.fallback, E ? (u = e.mode, E = e.child, k = { mode: "hidden", children: k }, !(u & 1) && E !== null ? (E.childLanes = 0, E.pendingProps = k) : E = lc(k, u, 0, null), t = Ao(t, u, r, null), E.return = e, t.return = e, E.sibling = t, e.child = E, e.child.memoizedState = bf(r), e.memoizedState = _f, t) : wh(e, k));
  if (I = t.memoizedState, I !== null && (g = I.dehydrated, g !== null)) return jk(t, e, k, u, g, I, r);
  if (E) {
    E = u.fallback, k = e.mode, I = t.child, g = I.sibling;
    var w = { mode: "hidden", children: u.children };
    return !(k & 1) && e.child !== I ? (u = e.child, u.childLanes = 0, u.pendingProps = w, e.deletions = null) : (u = Vs(I, w), u.subtreeFlags = I.subtreeFlags & 14680064), g !== null ? E = Vs(g, E) : (E = Ao(E, k, r, null), E.flags |= 2), E.return = e, u.return = e, u.sibling = E, e.child = u, u = E, E = e.child, k = t.child.memoizedState, k = k === null ? bf(r) : { baseLanes: k.baseLanes | r, cachePool: null, transitions: k.transitions }, E.memoizedState = k, E.childLanes = t.childLanes & ~r, e.memoizedState = _f, u;
  }
  return E = t.child, t = E.sibling, u = Vs(E, { mode: "visible", children: u.children }), !(e.mode & 1) && (u.lanes = r), u.return = e, u.sibling = null, t !== null && (r = e.deletions, r === null ? (e.deletions = [t], e.flags |= 16) : r.push(t)), e.child = u, e.memoizedState = null, u;
}
function wh(t, e) {
  return e = lc({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e;
}
function Qd(t, e, r, u) {
  return u !== null && dh(u), El(e, t.child, null, r), t = wh(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t;
}
function jk(t, e, r, u, I, E, k) {
  if (r)
    return e.flags & 256 ? (e.flags &= -257, u = mm(Error(gn(422))), Qd(t, e, k, u)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (E = u.fallback, I = e.mode, u = lc({ mode: "visible", children: u.children }, I, 0, null), E = Ao(E, I, k, null), E.flags |= 2, u.return = e, E.return = e, u.sibling = E, e.child = u, e.mode & 1 && El(e, t.child, null, k), e.child.memoizedState = bf(k), e.memoizedState = _f, E);
  if (!(e.mode & 1)) return Qd(t, e, k, null);
  if (I.data === "$!") {
    if (u = I.nextSibling && I.nextSibling.dataset, u) var g = u.dgst;
    return u = g, E = Error(gn(419)), u = mm(E, u, void 0), Qd(t, e, k, u);
  }
  if (g = (k & t.childLanes) !== 0, Gi || g) {
    if (u = ri, u !== null) {
      switch (k & -k) {
        case 4:
          I = 2;
          break;
        case 16:
          I = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          I = 32;
          break;
        case 536870912:
          I = 268435456;
          break;
        default:
          I = 0;
      }
      I = I & (u.suspendedLanes | k) ? 0 : I, I !== 0 && I !== E.retryLane && (E.retryLane = I, us(t, I), Lr(u, t, I, -1));
    }
    return Mh(), u = mm(Error(gn(421))), Qd(t, e, k, u);
  }
  return I.data === "$?" ? (e.flags |= 128, e.child = t.child, e = oL.bind(null, t), I._reactRetry = e, null) : (t = E.treeContext, ji = Fs(I.nextSibling), Ji = e, Ba = !0, Tr = null, t !== null && (dr[gr++] = as, dr[gr++] = is, dr[gr++] = bo, as = t.id, is = t.overflow, bo = e), e = wh(e, u.children), e.flags |= 4096, e);
}
function JC(t, e, r) {
  t.lanes |= e;
  var u = t.alternate;
  u !== null && (u.lanes |= e), hf(t.return, e, r);
}
function fm(t, e, r, u, I) {
  var E = t.memoizedState;
  E === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: u, tail: r, tailMode: I } : (E.isBackwards = e, E.rendering = null, E.renderingStartTime = 0, E.last = u, E.tail = r, E.tailMode = I);
}
function Rb(t, e, r) {
  var u = e.pendingProps, I = u.revealOrder, E = u.tail;
  if (bi(t, e, u.children, r), u = za.current, u & 2) u = u & 1 | 2, e.flags |= 128;
  else {
    if (t !== null && t.flags & 128) t: for (t = e.child; t !== null; ) {
      if (t.tag === 13) t.memoizedState !== null && JC(t, r, e);
      else if (t.tag === 19) JC(t, r, e);
      else if (t.child !== null) {
        t.child.return = t, t = t.child;
        continue;
      }
      if (t === e) break t;
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) break t;
        t = t.return;
      }
      t.sibling.return = t.return, t = t.sibling;
    }
    u &= 1;
  }
  if (Sa(za, u), !(e.mode & 1)) e.memoizedState = null;
  else switch (I) {
    case "forwards":
      for (r = e.child, I = null; r !== null; ) t = r.alternate, t !== null && Pg(t) === null && (I = r), r = r.sibling;
      r = I, r === null ? (I = e.child, e.child = null) : (I = r.sibling, r.sibling = null), fm(e, !1, I, r, E);
      break;
    case "backwards":
      for (r = null, I = e.child, e.child = null; I !== null; ) {
        if (t = I.alternate, t !== null && Pg(t) === null) {
          e.child = I;
          break;
        }
        t = I.sibling, I.sibling = r, r = I, I = t;
      }
      fm(e, !0, r, null, E);
      break;
    case "together":
      fm(e, !1, null, null, void 0);
      break;
    default:
      e.memoizedState = null;
  }
  return e.child;
}
function hg(t, e) {
  !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2);
}
function ds(t, e, r) {
  if (t !== null && (e.dependencies = t.dependencies), wo |= e.lanes, !(r & e.childLanes)) return null;
  if (t !== null && e.child !== t.child) throw Error(gn(153));
  if (e.child !== null) {
    for (t = e.child, r = Vs(t, t.pendingProps), e.child = r, r.return = e; t.sibling !== null; ) t = t.sibling, r = r.sibling = Vs(t, t.pendingProps), r.return = e;
    r.sibling = null;
  }
  return e.child;
}
function Zk(t, e, r) {
  switch (e.tag) {
    case 3:
      Lb(e), vl();
      break;
    case 5:
      ab(e);
      break;
    case 1:
      Yi(e.type) && xg(e);
      break;
    case 4:
      ph(e, e.stateNode.containerInfo);
      break;
    case 10:
      var u = e.type._context, I = e.memoizedProps.value;
      Sa(zg, u._currentValue), u._currentValue = I;
      break;
    case 13:
      if (u = e.memoizedState, u !== null)
        return u.dehydrated !== null ? (Sa(za, za.current & 1), e.flags |= 128, null) : r & e.child.childLanes ? Mb(t, e, r) : (Sa(za, za.current & 1), t = ds(t, e, r), t !== null ? t.sibling : null);
      Sa(za, za.current & 1);
      break;
    case 19:
      if (u = (r & e.childLanes) !== 0, t.flags & 128) {
        if (u) return Rb(t, e, r);
        e.flags |= 128;
      }
      if (I = e.memoizedState, I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), Sa(za, za.current), u) break;
      return null;
    case 22:
    case 23:
      return e.lanes = 0, Tb(t, e, r);
  }
  return ds(t, e, r);
}
var Db, Sf, Bb, xb;
Db = function(t, e) {
  for (var r = e.child; r !== null; ) {
    if (r.tag === 5 || r.tag === 6) t.appendChild(r.stateNode);
    else if (r.tag !== 4 && r.child !== null) {
      r.child.return = r, r = r.child;
      continue;
    }
    if (r === e) break;
    for (; r.sibling === null; ) {
      if (r.return === null || r.return === e) return;
      r = r.return;
    }
    r.sibling.return = r.return, r = r.sibling;
  }
};
Sf = function() {
};
Bb = function(t, e, r, u) {
  var I = t.memoizedProps;
  if (I !== u) {
    t = e.stateNode, Co(Vr.current);
    var E = null;
    switch (r) {
      case "input":
        I = Km(t, I), u = Km(t, u), E = [];
        break;
      case "select":
        I = Ha({}, I, { value: void 0 }), u = Ha({}, u, { value: void 0 }), E = [];
        break;
      case "textarea":
        I = Wm(t, I), u = Wm(t, u), E = [];
        break;
      default:
        typeof I.onClick != "function" && typeof u.onClick == "function" && (t.onclick = Dg);
    }
    Zm(r, u);
    var k;
    r = null;
    for (B in I) if (!u.hasOwnProperty(B) && I.hasOwnProperty(B) && I[B] != null) if (B === "style") {
      var g = I[B];
      for (k in g) g.hasOwnProperty(k) && (r || (r = {}), r[k] = "");
    } else B !== "dangerouslySetInnerHTML" && B !== "children" && B !== "suppressContentEditableWarning" && B !== "suppressHydrationWarning" && B !== "autoFocus" && (Du.hasOwnProperty(B) ? E || (E = []) : (E = E || []).push(B, null));
    for (B in u) {
      var w = u[B];
      if (g = I != null ? I[B] : void 0, u.hasOwnProperty(B) && w !== g && (w != null || g != null)) if (B === "style") if (g) {
        for (k in g) !g.hasOwnProperty(k) || w && w.hasOwnProperty(k) || (r || (r = {}), r[k] = "");
        for (k in w) w.hasOwnProperty(k) && g[k] !== w[k] && (r || (r = {}), r[k] = w[k]);
      } else r || (E || (E = []), E.push(
        B,
        r
      )), r = w;
      else B === "dangerouslySetInnerHTML" ? (w = w ? w.__html : void 0, g = g ? g.__html : void 0, w != null && g !== w && (E = E || []).push(B, w)) : B === "children" ? typeof w != "string" && typeof w != "number" || (E = E || []).push(B, "" + w) : B !== "suppressContentEditableWarning" && B !== "suppressHydrationWarning" && (Du.hasOwnProperty(B) ? (w != null && B === "onScroll" && Ta("scroll", t), E || g === w || (E = [])) : (E = E || []).push(B, w));
    }
    r && (E = E || []).push("style", r);
    var B = E;
    (e.updateQueue = B) && (e.flags |= 4);
  }
};
xb = function(t, e, r, u) {
  r !== u && (e.flags |= 4);
};
function gu(t, e) {
  if (!Ba) switch (t.tailMode) {
    case "hidden":
      e = t.tail;
      for (var r = null; e !== null; ) e.alternate !== null && (r = e), e = e.sibling;
      r === null ? t.tail = null : r.sibling = null;
      break;
    case "collapsed":
      r = t.tail;
      for (var u = null; r !== null; ) r.alternate !== null && (u = r), r = r.sibling;
      u === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : u.sibling = null;
  }
}
function fi(t) {
  var e = t.alternate !== null && t.alternate.child === t.child, r = 0, u = 0;
  if (e) for (var I = t.child; I !== null; ) r |= I.lanes | I.childLanes, u |= I.subtreeFlags & 14680064, u |= I.flags & 14680064, I.return = t, I = I.sibling;
  else for (I = t.child; I !== null; ) r |= I.lanes | I.childLanes, u |= I.subtreeFlags, u |= I.flags, I.return = t, I = I.sibling;
  return t.subtreeFlags |= u, t.childLanes = r, e;
}
function Jk(t, e, r) {
  var u = e.pendingProps;
  switch (uh(e), e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return fi(e), null;
    case 1:
      return Yi(e.type) && Bg(), fi(e), null;
    case 3:
      return u = e.stateNode, Tl(), La(zi), La(yi), Ch(), u.pendingContext && (u.context = u.pendingContext, u.pendingContext = null), (t === null || t.child === null) && (Zd(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, Tr !== null && (Rf(Tr), Tr = null))), Sf(t, e), fi(e), null;
    case 5:
      Ih(e);
      var I = Co(Ku.current);
      if (r = e.type, t !== null && e.stateNode != null) Bb(t, e, r, u, I), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
      else {
        if (!u) {
          if (e.stateNode === null) throw Error(gn(166));
          return fi(e), null;
        }
        if (t = Co(Vr.current), Zd(e)) {
          u = e.stateNode, r = e.type;
          var E = e.memoizedProps;
          switch (u[Ur] = e, u[Ou] = E, t = (e.mode & 1) !== 0, r) {
            case "dialog":
              Ta("cancel", u), Ta("close", u);
              break;
            case "iframe":
            case "object":
            case "embed":
              Ta("load", u);
              break;
            case "video":
            case "audio":
              for (I = 0; I < Au.length; I++) Ta(Au[I], u);
              break;
            case "source":
              Ta("error", u);
              break;
            case "img":
            case "image":
            case "link":
              Ta(
                "error",
                u
              ), Ta("load", u);
              break;
            case "details":
              Ta("toggle", u);
              break;
            case "input":
              rC(u, E), Ta("invalid", u);
              break;
            case "select":
              u._wrapperState = { wasMultiple: !!E.multiple }, Ta("invalid", u);
              break;
            case "textarea":
              oC(u, E), Ta("invalid", u);
          }
          Zm(r, E), I = null;
          for (var k in E) if (E.hasOwnProperty(k)) {
            var g = E[k];
            k === "children" ? typeof g == "string" ? u.textContent !== g && (E.suppressHydrationWarning !== !0 && jd(u.textContent, g, t), I = ["children", g]) : typeof g == "number" && u.textContent !== "" + g && (E.suppressHydrationWarning !== !0 && jd(
              u.textContent,
              g,
              t
            ), I = ["children", "" + g]) : Du.hasOwnProperty(k) && g != null && k === "onScroll" && Ta("scroll", u);
          }
          switch (r) {
            case "input":
              Pd(u), sC(u, E, !0);
              break;
            case "textarea":
              Pd(u), lC(u);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof E.onClick == "function" && (u.onclick = Dg);
          }
          u = I, e.updateQueue = u, u !== null && (e.flags |= 4);
        } else {
          k = I.nodeType === 9 ? I : I.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = l_(r)), t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = k.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof u.is == "string" ? t = k.createElement(r, { is: u.is }) : (t = k.createElement(r), r === "select" && (k = t, u.multiple ? k.multiple = !0 : u.size && (k.size = u.size))) : t = k.createElementNS(t, r), t[Ur] = e, t[Ou] = u, Db(t, e, !1, !1), e.stateNode = t;
          t: {
            switch (k = Jm(r, u), r) {
              case "dialog":
                Ta("cancel", t), Ta("close", t), I = u;
                break;
              case "iframe":
              case "object":
              case "embed":
                Ta("load", t), I = u;
                break;
              case "video":
              case "audio":
                for (I = 0; I < Au.length; I++) Ta(Au[I], t);
                I = u;
                break;
              case "source":
                Ta("error", t), I = u;
                break;
              case "img":
              case "image":
              case "link":
                Ta(
                  "error",
                  t
                ), Ta("load", t), I = u;
                break;
              case "details":
                Ta("toggle", t), I = u;
                break;
              case "input":
                rC(t, u), I = Km(t, u), Ta("invalid", t);
                break;
              case "option":
                I = u;
                break;
              case "select":
                t._wrapperState = { wasMultiple: !!u.multiple }, I = Ha({}, u, { value: void 0 }), Ta("invalid", t);
                break;
              case "textarea":
                oC(t, u), I = Wm(t, u), Ta("invalid", t);
                break;
              default:
                I = u;
            }
            Zm(r, I), g = I;
            for (E in g) if (g.hasOwnProperty(E)) {
              var w = g[E];
              E === "style" ? g_(t, w) : E === "dangerouslySetInnerHTML" ? (w = w ? w.__html : void 0, w != null && u_(t, w)) : E === "children" ? typeof w == "string" ? (r !== "textarea" || w !== "") && Bu(t, w) : typeof w == "number" && Bu(t, "" + w) : E !== "suppressContentEditableWarning" && E !== "suppressHydrationWarning" && E !== "autoFocus" && (Du.hasOwnProperty(E) ? w != null && E === "onScroll" && Ta("scroll", t) : w != null && jf(t, E, w, k));
            }
            switch (r) {
              case "input":
                Pd(t), sC(t, u, !1);
                break;
              case "textarea":
                Pd(t), lC(t);
                break;
              case "option":
                u.value != null && t.setAttribute("value", "" + Xs(u.value));
                break;
              case "select":
                t.multiple = !!u.multiple, E = u.value, E != null ? Il(t, !!u.multiple, E, !1) : u.defaultValue != null && Il(
                  t,
                  !!u.multiple,
                  u.defaultValue,
                  !0
                );
                break;
              default:
                typeof I.onClick == "function" && (t.onclick = Dg);
            }
            switch (r) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                u = !!u.autoFocus;
                break t;
              case "img":
                u = !0;
                break t;
              default:
                u = !1;
            }
          }
          u && (e.flags |= 4);
        }
        e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
      }
      return fi(e), null;
    case 6:
      if (t && e.stateNode != null) xb(t, e, t.memoizedProps, u);
      else {
        if (typeof u != "string" && e.stateNode === null) throw Error(gn(166));
        if (r = Co(Ku.current), Co(Vr.current), Zd(e)) {
          if (u = e.stateNode, r = e.memoizedProps, u[Ur] = e, (E = u.nodeValue !== r) && (t = Ji, t !== null)) switch (t.tag) {
            case 3:
              jd(u.nodeValue, r, (t.mode & 1) !== 0);
              break;
            case 5:
              t.memoizedProps.suppressHydrationWarning !== !0 && jd(u.nodeValue, r, (t.mode & 1) !== 0);
          }
          E && (e.flags |= 4);
        } else u = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(u), u[Ur] = e, e.stateNode = u;
      }
      return fi(e), null;
    case 13:
      if (La(za), u = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
        if (Ba && ji !== null && e.mode & 1 && !(e.flags & 128)) q_(), vl(), e.flags |= 98560, E = !1;
        else if (E = Zd(e), u !== null && u.dehydrated !== null) {
          if (t === null) {
            if (!E) throw Error(gn(318));
            if (E = e.memoizedState, E = E !== null ? E.dehydrated : null, !E) throw Error(gn(317));
            E[Ur] = e;
          } else vl(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
          fi(e), E = !1;
        } else Tr !== null && (Rf(Tr), Tr = null), E = !0;
        if (!E) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128 ? (e.lanes = r, e) : (u = u !== null, u !== (t !== null && t.memoizedState !== null) && u && (e.child.flags |= 8192, e.mode & 1 && (t === null || za.current & 1 ? ti === 0 && (ti = 3) : Mh())), e.updateQueue !== null && (e.flags |= 4), fi(e), null);
    case 4:
      return Tl(), Sf(t, e), t === null && Pu(e.stateNode.containerInfo), fi(e), null;
    case 10:
      return mh(e.type._context), fi(e), null;
    case 17:
      return Yi(e.type) && Bg(), fi(e), null;
    case 19:
      if (La(za), E = e.memoizedState, E === null) return fi(e), null;
      if (u = (e.flags & 128) !== 0, k = E.rendering, k === null) if (u) gu(E, !1);
      else {
        if (ti !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null; ) {
          if (k = Pg(t), k !== null) {
            for (e.flags |= 128, gu(E, !1), u = k.updateQueue, u !== null && (e.updateQueue = u, e.flags |= 4), e.subtreeFlags = 0, u = r, r = e.child; r !== null; ) E = r, t = u, E.flags &= 14680066, k = E.alternate, k === null ? (E.childLanes = 0, E.lanes = t, E.child = null, E.subtreeFlags = 0, E.memoizedProps = null, E.memoizedState = null, E.updateQueue = null, E.dependencies = null, E.stateNode = null) : (E.childLanes = k.childLanes, E.lanes = k.lanes, E.child = k.child, E.subtreeFlags = 0, E.deletions = null, E.memoizedProps = k.memoizedProps, E.memoizedState = k.memoizedState, E.updateQueue = k.updateQueue, E.type = k.type, t = k.dependencies, E.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), r = r.sibling;
            return Sa(za, za.current & 1 | 2), e.child;
          }
          t = t.sibling;
        }
        E.tail !== null && Za() > Ll && (e.flags |= 128, u = !0, gu(E, !1), e.lanes = 4194304);
      }
      else {
        if (!u) if (t = Pg(k), t !== null) {
          if (e.flags |= 128, u = !0, r = t.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), gu(E, !0), E.tail === null && E.tailMode === "hidden" && !k.alternate && !Ba) return fi(e), null;
        } else 2 * Za() - E.renderingStartTime > Ll && r !== 1073741824 && (e.flags |= 128, u = !0, gu(E, !1), e.lanes = 4194304);
        E.isBackwards ? (k.sibling = e.child, e.child = k) : (r = E.last, r !== null ? r.sibling = k : e.child = k, E.last = k);
      }
      return E.tail !== null ? (e = E.tail, E.rendering = e, E.tail = e.sibling, E.renderingStartTime = Za(), e.sibling = null, r = za.current, Sa(za, u ? r & 1 | 2 : r & 1), e) : (fi(e), null);
    case 22:
    case 23:
      return Lh(), u = e.memoizedState !== null, t !== null && t.memoizedState !== null !== u && (e.flags |= 8192), u && e.mode & 1 ? Wi & 1073741824 && (fi(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : fi(e), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(gn(156, e.tag));
}
function Qk(t, e) {
  switch (uh(e), e.tag) {
    case 1:
      return Yi(e.type) && Bg(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
    case 3:
      return Tl(), La(zi), La(yi), Ch(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null;
    case 5:
      return Ih(e), null;
    case 13:
      if (La(za), t = e.memoizedState, t !== null && t.dehydrated !== null) {
        if (e.alternate === null) throw Error(gn(340));
        vl();
      }
      return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null;
    case 19:
      return La(za), null;
    case 4:
      return Tl(), null;
    case 10:
      return mh(e.type._context), null;
    case 22:
    case 23:
      return Lh(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var qd = !1, Ii = !1, qk = typeof WeakSet == "function" ? WeakSet : Set, Ln = null;
function cl(t, e) {
  var r = t.ref;
  if (r !== null) if (typeof r == "function") try {
    r(null);
  } catch (u) {
    Fa(t, e, u);
  }
  else r.current = null;
}
function wf(t, e, r) {
  try {
    r();
  } catch (u) {
    Fa(t, e, u);
  }
}
var QC = !1;
function $k(t, e) {
  if (of = Lg, t = H_(), oh(t)) {
    if ("selectionStart" in t) var r = { start: t.selectionStart, end: t.selectionEnd };
    else t: {
      r = (r = t.ownerDocument) && r.defaultView || window;
      var u = r.getSelection && r.getSelection();
      if (u && u.rangeCount !== 0) {
        r = u.anchorNode;
        var I = u.anchorOffset, E = u.focusNode;
        u = u.focusOffset;
        try {
          r.nodeType, E.nodeType;
        } catch (p) {
          r = null;
          break t;
        }
        var k = 0, g = -1, w = -1, B = 0, c = 0, d = t, m = null;
        e: for (; ; ) {
          for (var b; d !== r || I !== 0 && d.nodeType !== 3 || (g = k + I), d !== E || u !== 0 && d.nodeType !== 3 || (w = k + u), d.nodeType === 3 && (k += d.nodeValue.length), (b = d.firstChild) !== null; )
            m = d, d = b;
          for (; ; ) {
            if (d === t) break e;
            if (m === r && ++B === I && (g = k), m === E && ++c === u && (w = k), (b = d.nextSibling) !== null) break;
            d = m, m = d.parentNode;
          }
          d = b;
        }
        r = g === -1 || w === -1 ? null : { start: g, end: w };
      } else r = null;
    }
    r = r || { start: 0, end: 0 };
  } else r = null;
  for (lf = { focusedElem: t, selectionRange: r }, Lg = !1, Ln = e; Ln !== null; ) if (e = Ln, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, Ln = t;
  else for (; Ln !== null; ) {
    e = Ln;
    try {
      var y = e.alternate;
      if (e.flags & 1024) switch (e.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (y !== null) {
            var T = y.memoizedProps, n = y.memoizedState, o = e.stateNode, l = o.getSnapshotBeforeUpdate(e.elementType === e.type ? T : vr(e.type, T), n);
            o.__reactInternalSnapshotBeforeUpdate = l;
          }
          break;
        case 3:
          var h = e.stateNode.containerInfo;
          h.nodeType === 1 ? h.textContent = "" : h.nodeType === 9 && h.documentElement && h.removeChild(h.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(gn(163));
      }
    } catch (p) {
      Fa(e, e.return, p);
    }
    if (t = e.sibling, t !== null) {
      t.return = e.return, Ln = t;
      break;
    }
    Ln = e.return;
  }
  return y = QC, QC = !1, y;
}
function Lu(t, e, r) {
  var u = e.updateQueue;
  if (u = u !== null ? u.lastEffect : null, u !== null) {
    var I = u = u.next;
    do {
      if ((I.tag & t) === t) {
        var E = I.destroy;
        I.destroy = void 0, E !== void 0 && wf(e, r, E);
      }
      I = I.next;
    } while (I !== u);
  }
}
function sc(t, e) {
  if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
    var r = e = e.next;
    do {
      if ((r.tag & t) === t) {
        var u = r.create;
        r.destroy = u();
      }
      r = r.next;
    } while (r !== e);
  }
}
function vf(t) {
  var e = t.ref;
  if (e !== null) {
    var r = t.stateNode;
    switch (t.tag) {
      case 5:
        t = r;
        break;
      default:
        t = r;
    }
    typeof e == "function" ? e(t) : e.current = t;
  }
}
function Nb(t) {
  var e = t.alternate;
  e !== null && (t.alternate = null, Nb(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[Ur], delete e[Ou], delete e[gf], delete e[Nk], delete e[Gk])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null;
}
function Gb(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function qC(t) {
  t: for (; ; ) {
    for (; t.sibling === null; ) {
      if (t.return === null || Gb(t.return)) return null;
      t = t.return;
    }
    for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue t;
      t.child.return = t, t = t.child;
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function Ef(t, e, r) {
  var u = t.tag;
  if (u === 5 || u === 6) t = t.stateNode, e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode, e.insertBefore(t, r)) : (e = r, e.appendChild(t)), r = r._reactRootContainer, r != null || e.onclick !== null || (e.onclick = Dg));
  else if (u !== 4 && (t = t.child, t !== null)) for (Ef(t, e, r), t = t.sibling; t !== null; ) Ef(t, e, r), t = t.sibling;
}
function Tf(t, e, r) {
  var u = t.tag;
  if (u === 5 || u === 6) t = t.stateNode, e ? r.insertBefore(t, e) : r.appendChild(t);
  else if (u !== 4 && (t = t.child, t !== null)) for (Tf(t, e, r), t = t.sibling; t !== null; ) Tf(t, e, r), t = t.sibling;
}
var li = null, Er = !1;
function Ls(t, e, r) {
  for (r = r.child; r !== null; ) zb(t, e, r), r = r.sibling;
}
function zb(t, e, r) {
  if (Kr && typeof Kr.onCommitFiberUnmount == "function") try {
    Kr.onCommitFiberUnmount(qg, r);
  } catch (g) {
  }
  switch (r.tag) {
    case 5:
      Ii || cl(r, e);
    case 6:
      var u = li, I = Er;
      li = null, Ls(t, e, r), li = u, Er = I, li !== null && (Er ? (t = li, r = r.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : li.removeChild(r.stateNode));
      break;
    case 18:
      li !== null && (Er ? (t = li, r = r.stateNode, t.nodeType === 8 ? om(t.parentNode, r) : t.nodeType === 1 && om(t, r), zu(t)) : om(li, r.stateNode));
      break;
    case 4:
      u = li, I = Er, li = r.stateNode.containerInfo, Er = !0, Ls(t, e, r), li = u, Er = I;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Ii && (u = r.updateQueue, u !== null && (u = u.lastEffect, u !== null))) {
        I = u = u.next;
        do {
          var E = I, k = E.destroy;
          E = E.tag, k !== void 0 && (E & 2 || E & 4) && wf(r, e, k), I = I.next;
        } while (I !== u);
      }
      Ls(t, e, r);
      break;
    case 1:
      if (!Ii && (cl(r, e), u = r.stateNode, typeof u.componentWillUnmount == "function")) try {
        u.props = r.memoizedProps, u.state = r.memoizedState, u.componentWillUnmount();
      } catch (g) {
        Fa(r, e, g);
      }
      Ls(t, e, r);
      break;
    case 21:
      Ls(t, e, r);
      break;
    case 22:
      r.mode & 1 ? (Ii = (u = Ii) || r.memoizedState !== null, Ls(t, e, r), Ii = u) : Ls(t, e, r);
      break;
    default:
      Ls(t, e, r);
  }
}
function $C(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var r = t.stateNode;
    r === null && (r = t.stateNode = new qk()), e.forEach(function(u) {
      var I = lL.bind(null, t, u);
      r.has(u) || (r.add(u), u.then(I, I));
    });
  }
}
function Sr(t, e) {
  var r = e.deletions;
  if (r !== null) for (var u = 0; u < r.length; u++) {
    var I = r[u];
    try {
      var E = t, k = e, g = k;
      t: for (; g !== null; ) {
        switch (g.tag) {
          case 5:
            li = g.stateNode, Er = !1;
            break t;
          case 3:
            li = g.stateNode.containerInfo, Er = !0;
            break t;
          case 4:
            li = g.stateNode.containerInfo, Er = !0;
            break t;
        }
        g = g.return;
      }
      if (li === null) throw Error(gn(160));
      zb(E, k, I), li = null, Er = !1;
      var w = I.alternate;
      w !== null && (w.return = null), I.return = null;
    } catch (B) {
      Fa(I, e, B);
    }
  }
  if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) Yb(e, t), e = e.sibling;
}
function Yb(t, e) {
  var r = t.alternate, u = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Sr(e, t), Hr(t), u & 4) {
        try {
          Lu(3, t, t.return), sc(3, t);
        } catch (T) {
          Fa(t, t.return, T);
        }
        try {
          Lu(5, t, t.return);
        } catch (T) {
          Fa(t, t.return, T);
        }
      }
      break;
    case 1:
      Sr(e, t), Hr(t), u & 512 && r !== null && cl(r, r.return);
      break;
    case 5:
      if (Sr(e, t), Hr(t), u & 512 && r !== null && cl(r, r.return), t.flags & 32) {
        var I = t.stateNode;
        try {
          Bu(I, "");
        } catch (T) {
          Fa(t, t.return, T);
        }
      }
      if (u & 4 && (I = t.stateNode, I != null)) {
        var E = t.memoizedProps, k = r !== null ? r.memoizedProps : E, g = t.type, w = t.updateQueue;
        if (t.updateQueue = null, w !== null) try {
          g === "input" && E.type === "radio" && E.name != null && s_(I, E), Jm(g, k);
          var B = Jm(g, E);
          for (k = 0; k < w.length; k += 2) {
            var c = w[k], d = w[k + 1];
            c === "style" ? g_(I, d) : c === "dangerouslySetInnerHTML" ? u_(I, d) : c === "children" ? Bu(I, d) : jf(I, c, d, B);
          }
          switch (g) {
            case "input":
              Vm(I, E);
              break;
            case "textarea":
              o_(I, E);
              break;
            case "select":
              var m = I._wrapperState.wasMultiple;
              I._wrapperState.wasMultiple = !!E.multiple;
              var b = E.value;
              b != null ? Il(I, !!E.multiple, b, !1) : m !== !!E.multiple && (E.defaultValue != null ? Il(
                I,
                !!E.multiple,
                E.defaultValue,
                !0
              ) : Il(I, !!E.multiple, E.multiple ? [] : "", !1));
          }
          I[Ou] = E;
        } catch (T) {
          Fa(t, t.return, T);
        }
      }
      break;
    case 6:
      if (Sr(e, t), Hr(t), u & 4) {
        if (t.stateNode === null) throw Error(gn(162));
        I = t.stateNode, E = t.memoizedProps;
        try {
          I.nodeValue = E;
        } catch (T) {
          Fa(t, t.return, T);
        }
      }
      break;
    case 3:
      if (Sr(e, t), Hr(t), u & 4 && r !== null && r.memoizedState.isDehydrated) try {
        zu(e.containerInfo);
      } catch (T) {
        Fa(t, t.return, T);
      }
      break;
    case 4:
      Sr(e, t), Hr(t);
      break;
    case 13:
      Sr(e, t), Hr(t), I = t.child, I.flags & 8192 && (E = I.memoizedState !== null, I.stateNode.isHidden = E, !E || I.alternate !== null && I.alternate.memoizedState !== null || (Th = Za())), u & 4 && $C(t);
      break;
    case 22:
      if (c = r !== null && r.memoizedState !== null, t.mode & 1 ? (Ii = (B = Ii) || c, Sr(e, t), Ii = B) : Sr(e, t), Hr(t), u & 8192) {
        if (B = t.memoizedState !== null, (t.stateNode.isHidden = B) && !c && t.mode & 1) for (Ln = t, c = t.child; c !== null; ) {
          for (d = Ln = c; Ln !== null; ) {
            switch (m = Ln, b = m.child, m.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Lu(4, m, m.return);
                break;
              case 1:
                cl(m, m.return);
                var y = m.stateNode;
                if (typeof y.componentWillUnmount == "function") {
                  u = m, r = m.return;
                  try {
                    e = u, y.props = e.memoizedProps, y.state = e.memoizedState, y.componentWillUnmount();
                  } catch (T) {
                    Fa(u, r, T);
                  }
                }
                break;
              case 5:
                cl(m, m.return);
                break;
              case 22:
                if (m.memoizedState !== null) {
                  ey(d);
                  continue;
                }
            }
            b !== null ? (b.return = m, Ln = b) : ey(d);
          }
          c = c.sibling;
        }
        t: for (c = null, d = t; ; ) {
          if (d.tag === 5) {
            if (c === null) {
              c = d;
              try {
                I = d.stateNode, B ? (E = I.style, typeof E.setProperty == "function" ? E.setProperty("display", "none", "important") : E.display = "none") : (g = d.stateNode, w = d.memoizedProps.style, k = w != null && w.hasOwnProperty("display") ? w.display : null, g.style.display = d_("display", k));
              } catch (T) {
                Fa(t, t.return, T);
              }
            }
          } else if (d.tag === 6) {
            if (c === null) try {
              d.stateNode.nodeValue = B ? "" : d.memoizedProps;
            } catch (T) {
              Fa(t, t.return, T);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === t) break t;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === t) break t;
            c === d && (c = null), d = d.return;
          }
          c === d && (c = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      Sr(e, t), Hr(t), u & 4 && $C(t);
      break;
    case 21:
      break;
    default:
      Sr(
        e,
        t
      ), Hr(t);
  }
}
function Hr(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      t: {
        for (var r = t.return; r !== null; ) {
          if (Gb(r)) {
            var u = r;
            break t;
          }
          r = r.return;
        }
        throw Error(gn(160));
      }
      switch (u.tag) {
        case 5:
          var I = u.stateNode;
          u.flags & 32 && (Bu(I, ""), u.flags &= -33);
          var E = qC(t);
          Tf(t, E, I);
          break;
        case 3:
        case 4:
          var k = u.stateNode.containerInfo, g = qC(t);
          Ef(t, g, k);
          break;
        default:
          throw Error(gn(161));
      }
    } catch (w) {
      Fa(t, t.return, w);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function tL(t, e, r) {
  Ln = t, Hb(t);
}
function Hb(t, e, r) {
  for (var u = (t.mode & 1) !== 0; Ln !== null; ) {
    var I = Ln, E = I.child;
    if (I.tag === 22 && u) {
      var k = I.memoizedState !== null || qd;
      if (!k) {
        var g = I.alternate, w = g !== null && g.memoizedState !== null || Ii;
        g = qd;
        var B = Ii;
        if (qd = k, (Ii = w) && !B) for (Ln = I; Ln !== null; ) k = Ln, w = k.child, k.tag === 22 && k.memoizedState !== null ? ny(I) : w !== null ? (w.return = k, Ln = w) : ny(I);
        for (; E !== null; ) Ln = E, Hb(E), E = E.sibling;
        Ln = I, qd = g, Ii = B;
      }
      ty(t);
    } else I.subtreeFlags & 8772 && E !== null ? (E.return = I, Ln = E) : ty(t);
  }
}
function ty(t) {
  for (; Ln !== null; ) {
    var e = Ln;
    if (e.flags & 8772) {
      var r = e.alternate;
      try {
        if (e.flags & 8772) switch (e.tag) {
          case 0:
          case 11:
          case 15:
            Ii || sc(5, e);
            break;
          case 1:
            var u = e.stateNode;
            if (e.flags & 4 && !Ii) if (r === null) u.componentDidMount();
            else {
              var I = e.elementType === e.type ? r.memoizedProps : vr(e.type, r.memoizedProps);
              u.componentDidUpdate(I, r.memoizedState, u.__reactInternalSnapshotBeforeUpdate);
            }
            var E = e.updateQueue;
            E !== null && YC(e, E, u);
            break;
          case 3:
            var k = e.updateQueue;
            if (k !== null) {
              if (r = null, e.child !== null) switch (e.child.tag) {
                case 5:
                  r = e.child.stateNode;
                  break;
                case 1:
                  r = e.child.stateNode;
              }
              YC(e, k, r);
            }
            break;
          case 5:
            var g = e.stateNode;
            if (r === null && e.flags & 4) {
              r = g;
              var w = e.memoizedProps;
              switch (e.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  w.autoFocus && r.focus();
                  break;
                case "img":
                  w.src && (r.src = w.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (e.memoizedState === null) {
              var B = e.alternate;
              if (B !== null) {
                var c = B.memoizedState;
                if (c !== null) {
                  var d = c.dehydrated;
                  d !== null && zu(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(gn(163));
        }
        Ii || e.flags & 512 && vf(e);
      } catch (m) {
        Fa(e, e.return, m);
      }
    }
    if (e === t) {
      Ln = null;
      break;
    }
    if (r = e.sibling, r !== null) {
      r.return = e.return, Ln = r;
      break;
    }
    Ln = e.return;
  }
}
function ey(t) {
  for (; Ln !== null; ) {
    var e = Ln;
    if (e === t) {
      Ln = null;
      break;
    }
    var r = e.sibling;
    if (r !== null) {
      r.return = e.return, Ln = r;
      break;
    }
    Ln = e.return;
  }
}
function ny(t) {
  for (; Ln !== null; ) {
    var e = Ln;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var r = e.return;
          try {
            sc(4, e);
          } catch (w) {
            Fa(e, r, w);
          }
          break;
        case 1:
          var u = e.stateNode;
          if (typeof u.componentDidMount == "function") {
            var I = e.return;
            try {
              u.componentDidMount();
            } catch (w) {
              Fa(e, I, w);
            }
          }
          var E = e.return;
          try {
            vf(e);
          } catch (w) {
            Fa(e, E, w);
          }
          break;
        case 5:
          var k = e.return;
          try {
            vf(e);
          } catch (w) {
            Fa(e, k, w);
          }
      }
    } catch (w) {
      Fa(e, e.return, w);
    }
    if (e === t) {
      Ln = null;
      break;
    }
    var g = e.sibling;
    if (g !== null) {
      g.return = e.return, Ln = g;
      break;
    }
    Ln = e.return;
  }
}
var eL = Math.ceil, Ug = gs.ReactCurrentDispatcher, vh = gs.ReactCurrentOwner, mr = gs.ReactCurrentBatchConfig, fa = 0, ri = null, Qa = null, ui = 0, Wi = 0, ml = Qs(0), ti = 0, ju = null, wo = 0, oc = 0, Eh = 0, Mu = null, Ni = null, Th = 0, Ll = 1 / 0, ts = null, Kg = !1, kf = null, Us = null, $d = !1, zs = null, Vg = 0, Ru = 0, Lf = null, pg = -1, Ig = 0;
function Si() {
  return fa & 6 ? Za() : pg !== -1 ? pg : pg = Za();
}
function Ks(t) {
  return t.mode & 1 ? fa & 2 && ui !== 0 ? ui & -ui : Yk.transition !== null ? (Ig === 0 && (Ig = S_()), Ig) : (t = ya, t !== 0 || (t = window.event, t = t === void 0 ? 16 : M_(t.type)), t) : 1;
}
function Lr(t, e, r, u) {
  if (50 < Ru) throw Ru = 0, Lf = null, Error(gn(185));
  td(t, r, u), (!(fa & 2) || t !== ri) && (t === ri && (!(fa & 2) && (oc |= r), ti === 4 && Ns(t, ui)), Hi(t, u), r === 1 && fa === 0 && !(e.mode & 1) && (Ll = Za() + 500, ac && qs()));
}
function Hi(t, e) {
  var r = t.callbackNode;
  YT(t, e);
  var u = kg(t, t === ri ? ui : 0);
  if (u === 0) r !== null && gC(r), t.callbackNode = null, t.callbackPriority = 0;
  else if (e = u & -u, t.callbackPriority !== e) {
    if (r != null && gC(r), e === 1) t.tag === 0 ? zk(ay.bind(null, t)) : Z_(ay.bind(null, t)), Bk(function() {
      !(fa & 6) && qs();
    }), r = null;
    else {
      switch (w_(u)) {
        case 1:
          r = $f;
          break;
        case 4:
          r = __;
          break;
        case 16:
          r = Tg;
          break;
        case 536870912:
          r = b_;
          break;
        default:
          r = Tg;
      }
      r = Wb(r, Pb.bind(null, t));
    }
    t.callbackPriority = e, t.callbackNode = r;
  }
}
function Pb(t, e) {
  if (pg = -1, Ig = 0, fa & 6) throw Error(gn(327));
  var r = t.callbackNode;
  if (bl() && t.callbackNode !== r) return null;
  var u = kg(t, t === ri ? ui : 0);
  if (u === 0) return null;
  if (u & 30 || u & t.expiredLanes || e) e = Xg(t, u);
  else {
    e = u;
    var I = fa;
    fa |= 2;
    var E = Ob();
    (ri !== t || ui !== e) && (ts = null, Ll = Za() + 500, yo(t, e));
    do
      try {
        iL();
        break;
      } catch (g) {
        Fb(t, g);
      }
    while (!0);
    ch(), Ug.current = E, fa = I, Qa !== null ? e = 0 : (ri = null, ui = 0, e = ti);
  }
  if (e !== 0) {
    if (e === 2 && (I = ef(t), I !== 0 && (u = I, e = Mf(t, I))), e === 1) throw r = ju, yo(t, 0), Ns(t, u), Hi(t, Za()), r;
    if (e === 6) Ns(t, u);
    else {
      if (I = t.current.alternate, !(u & 30) && !nL(I) && (e = Xg(t, u), e === 2 && (E = ef(t), E !== 0 && (u = E, e = Mf(t, E))), e === 1)) throw r = ju, yo(t, 0), Ns(t, u), Hi(t, Za()), r;
      switch (t.finishedWork = I, t.finishedLanes = u, e) {
        case 0:
        case 1:
          throw Error(gn(345));
        case 2:
          ho(t, Ni, ts);
          break;
        case 3:
          if (Ns(t, u), (u & 130023424) === u && (e = Th + 500 - Za(), 10 < e)) {
            if (kg(t, 0) !== 0) break;
            if (I = t.suspendedLanes, (I & u) !== u) {
              Si(), t.pingedLanes |= t.suspendedLanes & I;
              break;
            }
            t.timeoutHandle = df(ho.bind(null, t, Ni, ts), e);
            break;
          }
          ho(t, Ni, ts);
          break;
        case 4:
          if (Ns(t, u), (u & 4194240) === u) break;
          for (e = t.eventTimes, I = -1; 0 < u; ) {
            var k = 31 - kr(u);
            E = 1 << k, k = e[k], k > I && (I = k), u &= ~E;
          }
          if (u = I, u = Za() - u, u = (120 > u ? 120 : 480 > u ? 480 : 1080 > u ? 1080 : 1920 > u ? 1920 : 3e3 > u ? 3e3 : 4320 > u ? 4320 : 1960 * eL(u / 1960)) - u, 10 < u) {
            t.timeoutHandle = df(ho.bind(null, t, Ni, ts), u);
            break;
          }
          ho(t, Ni, ts);
          break;
        case 5:
          ho(t, Ni, ts);
          break;
        default:
          throw Error(gn(329));
      }
    }
  }
  return Hi(t, Za()), t.callbackNode === r ? Pb.bind(null, t) : null;
}
function Mf(t, e) {
  var r = Mu;
  return t.current.memoizedState.isDehydrated && (yo(t, e).flags |= 256), t = Xg(t, e), t !== 2 && (e = Ni, Ni = r, e !== null && Rf(e)), t;
}
function Rf(t) {
  Ni === null ? Ni = t : Ni.push.apply(Ni, t);
}
function nL(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var r = e.updateQueue;
      if (r !== null && (r = r.stores, r !== null)) for (var u = 0; u < r.length; u++) {
        var I = r[u], E = I.getSnapshot;
        I = I.value;
        try {
          if (!Mr(E(), I)) return !1;
        } catch (k) {
          return !1;
        }
      }
    }
    if (r = e.child, e.subtreeFlags & 16384 && r !== null) r.return = e, e = r;
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
  }
  return !0;
}
function Ns(t, e) {
  for (e &= ~Eh, e &= ~oc, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e; ) {
    var r = 31 - kr(e), u = 1 << r;
    t[r] = -1, e &= ~u;
  }
}
function ay(t) {
  if (fa & 6) throw Error(gn(327));
  bl();
  var e = kg(t, 0);
  if (!(e & 1)) return Hi(t, Za()), null;
  var r = Xg(t, e);
  if (t.tag !== 0 && r === 2) {
    var u = ef(t);
    u !== 0 && (e = u, r = Mf(t, u));
  }
  if (r === 1) throw r = ju, yo(t, 0), Ns(t, e), Hi(t, Za()), r;
  if (r === 6) throw Error(gn(345));
  return t.finishedWork = t.current.alternate, t.finishedLanes = e, ho(t, Ni, ts), Hi(t, Za()), null;
}
function kh(t, e) {
  var r = fa;
  fa |= 1;
  try {
    return t(e);
  } finally {
    fa = r, fa === 0 && (Ll = Za() + 500, ac && qs());
  }
}
function vo(t) {
  zs !== null && zs.tag === 0 && !(fa & 6) && bl();
  var e = fa;
  fa |= 1;
  var r = mr.transition, u = ya;
  try {
    if (mr.transition = null, ya = 1, t) return t();
  } finally {
    ya = u, mr.transition = r, fa = e, !(fa & 6) && qs();
  }
}
function Lh() {
  Wi = ml.current, La(ml);
}
function yo(t, e) {
  t.finishedWork = null, t.finishedLanes = 0;
  var r = t.timeoutHandle;
  if (r !== -1 && (t.timeoutHandle = -1, Dk(r)), Qa !== null) for (r = Qa.return; r !== null; ) {
    var u = r;
    switch (uh(u), u.tag) {
      case 1:
        u = u.type.childContextTypes, u != null && Bg();
        break;
      case 3:
        Tl(), La(zi), La(yi), Ch();
        break;
      case 5:
        Ih(u);
        break;
      case 4:
        Tl();
        break;
      case 13:
        La(za);
        break;
      case 19:
        La(za);
        break;
      case 10:
        mh(u.type._context);
        break;
      case 22:
      case 23:
        Lh();
    }
    r = r.return;
  }
  if (ri = t, Qa = t = Vs(t.current, null), ui = Wi = e, ti = 0, ju = null, Eh = oc = wo = 0, Ni = Mu = null, Io !== null) {
    for (e = 0; e < Io.length; e++) if (r = Io[e], u = r.interleaved, u !== null) {
      r.interleaved = null;
      var I = u.next, E = r.pending;
      if (E !== null) {
        var k = E.next;
        E.next = I, u.next = k;
      }
      r.pending = u;
    }
    Io = null;
  }
  return t;
}
function Fb(t, e) {
  do {
    var r = Qa;
    try {
      if (ch(), mg.current = Og, Fg) {
        for (var u = Ya.memoizedState; u !== null; ) {
          var I = u.queue;
          I !== null && (I.pending = null), u = u.next;
        }
        Fg = !1;
      }
      if (So = 0, ii = $a = Ya = null, ku = !1, Vu = 0, vh.current = null, r === null || r.return === null) {
        ti = 1, ju = e, Qa = null;
        break;
      }
      t: {
        var E = t, k = r.return, g = r, w = e;
        if (e = ui, g.flags |= 32768, w !== null && typeof w == "object" && typeof w.then == "function") {
          var B = w, c = g, d = c.tag;
          if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var m = c.alternate;
            m ? (c.updateQueue = m.updateQueue, c.memoizedState = m.memoizedState, c.lanes = m.lanes) : (c.updateQueue = null, c.memoizedState = null);
          }
          var b = KC(k);
          if (b !== null) {
            b.flags &= -257, VC(b, k, g, E, e), b.mode & 1 && UC(E, B, e), e = b, w = B;
            var y = e.updateQueue;
            if (y === null) {
              var T = /* @__PURE__ */ new Set();
              T.add(w), e.updateQueue = T;
            } else y.add(w);
            break t;
          } else {
            if (!(e & 1)) {
              UC(E, B, e), Mh();
              break t;
            }
            w = Error(gn(426));
          }
        } else if (Ba && g.mode & 1) {
          var n = KC(k);
          if (n !== null) {
            !(n.flags & 65536) && (n.flags |= 256), VC(n, k, g, E, e), dh(kl(w, g));
            break t;
          }
        }
        E = w = kl(w, g), ti !== 4 && (ti = 2), Mu === null ? Mu = [E] : Mu.push(E), E = k;
        do {
          switch (E.tag) {
            case 3:
              E.flags |= 65536, e &= -e, E.lanes |= e;
              var o = wb(E, w, e);
              zC(E, o);
              break t;
            case 1:
              g = w;
              var l = E.type, h = E.stateNode;
              if (!(E.flags & 128) && (typeof l.getDerivedStateFromError == "function" || h !== null && typeof h.componentDidCatch == "function" && (Us === null || !Us.has(h)))) {
                E.flags |= 65536, e &= -e, E.lanes |= e;
                var p = vb(E, g, e);
                zC(E, p);
                break t;
              }
          }
          E = E.return;
        } while (E !== null);
      }
      Kb(r);
    } catch (z) {
      e = z, Qa === r && r !== null && (Qa = r = r.return);
      continue;
    }
    break;
  } while (!0);
}
function Ob() {
  var t = Ug.current;
  return Ug.current = Og, t === null ? Og : t;
}
function Mh() {
  (ti === 0 || ti === 3 || ti === 2) && (ti = 4), ri === null || !(wo & 268435455) && !(oc & 268435455) || Ns(ri, ui);
}
function Xg(t, e) {
  var r = fa;
  fa |= 2;
  var u = Ob();
  (ri !== t || ui !== e) && (ts = null, yo(t, e));
  do
    try {
      aL();
      break;
    } catch (I) {
      Fb(t, I);
    }
  while (!0);
  if (ch(), fa = r, Ug.current = u, Qa !== null) throw Error(gn(261));
  return ri = null, ui = 0, ti;
}
function aL() {
  for (; Qa !== null; ) Ub(Qa);
}
function iL() {
  for (; Qa !== null && !LT(); ) Ub(Qa);
}
function Ub(t) {
  var e = Xb(t.alternate, t, Wi);
  t.memoizedProps = t.pendingProps, e === null ? Kb(t) : Qa = e, vh.current = null;
}
function Kb(t) {
  var e = t;
  do {
    var r = e.alternate;
    if (t = e.return, e.flags & 32768) {
      if (r = Qk(r, e), r !== null) {
        r.flags &= 32767, Qa = r;
        return;
      }
      if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null;
      else {
        ti = 6, Qa = null;
        return;
      }
    } else if (r = Jk(r, e, Wi), r !== null) {
      Qa = r;
      return;
    }
    if (e = e.sibling, e !== null) {
      Qa = e;
      return;
    }
    Qa = e = t;
  } while (e !== null);
  ti === 0 && (ti = 5);
}
function ho(t, e, r) {
  var u = ya, I = mr.transition;
  try {
    mr.transition = null, ya = 1, rL(t, e, r, u);
  } finally {
    mr.transition = I, ya = u;
  }
  return null;
}
function rL(t, e, r, u) {
  do
    bl();
  while (zs !== null);
  if (fa & 6) throw Error(gn(327));
  r = t.finishedWork;
  var I = t.finishedLanes;
  if (r === null) return null;
  if (t.finishedWork = null, t.finishedLanes = 0, r === t.current) throw Error(gn(177));
  t.callbackNode = null, t.callbackPriority = 0;
  var E = r.lanes | r.childLanes;
  if (HT(t, E), t === ri && (Qa = ri = null, ui = 0), !(r.subtreeFlags & 2064) && !(r.flags & 2064) || $d || ($d = !0, Wb(Tg, function() {
    return bl(), null;
  })), E = (r.flags & 15990) !== 0, r.subtreeFlags & 15990 || E) {
    E = mr.transition, mr.transition = null;
    var k = ya;
    ya = 1;
    var g = fa;
    fa |= 4, vh.current = null, $k(t, r), Yb(r, t), vk(lf), Lg = !!of, lf = of = null, t.current = r, tL(r), MT(), fa = g, ya = k, mr.transition = E;
  } else t.current = r;
  if ($d && ($d = !1, zs = t, Vg = I), E = t.pendingLanes, E === 0 && (Us = null), BT(r.stateNode), Hi(t, Za()), e !== null) for (u = t.onRecoverableError, r = 0; r < e.length; r++) I = e[r], u(I.value, { componentStack: I.stack, digest: I.digest });
  if (Kg) throw Kg = !1, t = kf, kf = null, t;
  return Vg & 1 && t.tag !== 0 && bl(), E = t.pendingLanes, E & 1 ? t === Lf ? Ru++ : (Ru = 0, Lf = t) : Ru = 0, qs(), null;
}
function bl() {
  if (zs !== null) {
    var t = w_(Vg), e = mr.transition, r = ya;
    try {
      if (mr.transition = null, ya = 16 > t ? 16 : t, zs === null) var u = !1;
      else {
        if (t = zs, zs = null, Vg = 0, fa & 6) throw Error(gn(331));
        var I = fa;
        for (fa |= 4, Ln = t.current; Ln !== null; ) {
          var E = Ln, k = E.child;
          if (Ln.flags & 16) {
            var g = E.deletions;
            if (g !== null) {
              for (var w = 0; w < g.length; w++) {
                var B = g[w];
                for (Ln = B; Ln !== null; ) {
                  var c = Ln;
                  switch (c.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Lu(8, c, E);
                  }
                  var d = c.child;
                  if (d !== null) d.return = c, Ln = d;
                  else for (; Ln !== null; ) {
                    c = Ln;
                    var m = c.sibling, b = c.return;
                    if (Nb(c), c === B) {
                      Ln = null;
                      break;
                    }
                    if (m !== null) {
                      m.return = b, Ln = m;
                      break;
                    }
                    Ln = b;
                  }
                }
              }
              var y = E.alternate;
              if (y !== null) {
                var T = y.child;
                if (T !== null) {
                  y.child = null;
                  do {
                    var n = T.sibling;
                    T.sibling = null, T = n;
                  } while (T !== null);
                }
              }
              Ln = E;
            }
          }
          if (E.subtreeFlags & 2064 && k !== null) k.return = E, Ln = k;
          else t: for (; Ln !== null; ) {
            if (E = Ln, E.flags & 2048) switch (E.tag) {
              case 0:
              case 11:
              case 15:
                Lu(9, E, E.return);
            }
            var o = E.sibling;
            if (o !== null) {
              o.return = E.return, Ln = o;
              break t;
            }
            Ln = E.return;
          }
        }
        var l = t.current;
        for (Ln = l; Ln !== null; ) {
          k = Ln;
          var h = k.child;
          if (k.subtreeFlags & 2064 && h !== null) h.return = k, Ln = h;
          else t: for (k = l; Ln !== null; ) {
            if (g = Ln, g.flags & 2048) try {
              switch (g.tag) {
                case 0:
                case 11:
                case 15:
                  sc(9, g);
              }
            } catch (z) {
              Fa(g, g.return, z);
            }
            if (g === k) {
              Ln = null;
              break t;
            }
            var p = g.sibling;
            if (p !== null) {
              p.return = g.return, Ln = p;
              break t;
            }
            Ln = g.return;
          }
        }
        if (fa = I, qs(), Kr && typeof Kr.onPostCommitFiberRoot == "function") try {
          Kr.onPostCommitFiberRoot(qg, t);
        } catch (z) {
        }
        u = !0;
      }
      return u;
    } finally {
      ya = r, mr.transition = e;
    }
  }
  return !1;
}
function iy(t, e, r) {
  e = kl(r, e), e = wb(t, e, 1), t = Os(t, e, 1), e = Si(), t !== null && (td(t, 1, e), Hi(t, e));
}
function Fa(t, e, r) {
  if (t.tag === 3) iy(t, t, r);
  else for (; e !== null; ) {
    if (e.tag === 3) {
      iy(e, t, r);
      break;
    } else if (e.tag === 1) {
      var u = e.stateNode;
      if (typeof e.type.getDerivedStateFromError == "function" || typeof u.componentDidCatch == "function" && (Us === null || !Us.has(u))) {
        t = kl(r, t), t = vb(e, t, 1), e = Os(e, t, 1), t = Si(), e !== null && (td(e, 1, t), Hi(e, t));
        break;
      }
    }
    e = e.return;
  }
}
function sL(t, e, r) {
  var u = t.pingCache;
  u !== null && u.delete(e), e = Si(), t.pingedLanes |= t.suspendedLanes & r, ri === t && (ui & r) === r && (ti === 4 || ti === 3 && (ui & 130023424) === ui && 500 > Za() - Th ? yo(t, 0) : Eh |= r), Hi(t, e);
}
function Vb(t, e) {
  e === 0 && (t.mode & 1 ? (e = Ud, Ud <<= 1, !(Ud & 130023424) && (Ud = 4194304)) : e = 1);
  var r = Si();
  t = us(t, e), t !== null && (td(t, e, r), Hi(t, r));
}
function oL(t) {
  var e = t.memoizedState, r = 0;
  e !== null && (r = e.retryLane), Vb(t, r);
}
function lL(t, e) {
  var r = 0;
  switch (t.tag) {
    case 13:
      var u = t.stateNode, I = t.memoizedState;
      I !== null && (r = I.retryLane);
      break;
    case 19:
      u = t.stateNode;
      break;
    default:
      throw Error(gn(314));
  }
  u !== null && u.delete(e), Vb(t, r);
}
var Xb;
Xb = function(t, e, r) {
  if (t !== null) if (t.memoizedProps !== e.pendingProps || zi.current) Gi = !0;
  else {
    if (!(t.lanes & r) && !(e.flags & 128)) return Gi = !1, Zk(t, e, r);
    Gi = !!(t.flags & 131072);
  }
  else Gi = !1, Ba && e.flags & 1048576 && J_(e, Gg, e.index);
  switch (e.lanes = 0, e.tag) {
    case 2:
      var u = e.type;
      hg(t, e), t = e.pendingProps;
      var I = wl(e, yi.current);
      _l(e, r), I = Ah(null, e, u, t, I, r);
      var E = _h();
      return e.flags |= 1, typeof I == "object" && I !== null && typeof I.render == "function" && I.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Yi(u) ? (E = !0, xg(e)) : E = !1, e.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, hh(e), I.updater = rc, e.stateNode = I, I._reactInternals = e, If(e, u, t, r), e = Af(null, e, u, !0, E, r)) : (e.tag = 0, Ba && E && lh(e), bi(null, e, I, r), e = e.child), e;
    case 16:
      u = e.elementType;
      t: {
        switch (hg(t, e), t = e.pendingProps, I = u._init, u = I(u._payload), e.type = u, I = e.tag = dL(u), t = vr(u, t), I) {
          case 0:
            e = yf(null, e, u, t, r);
            break t;
          case 1:
            e = jC(null, e, u, t, r);
            break t;
          case 11:
            e = XC(null, e, u, t, r);
            break t;
          case 14:
            e = WC(null, e, u, vr(u.type, t), r);
            break t;
        }
        throw Error(gn(
          306,
          u,
          ""
        ));
      }
      return e;
    case 0:
      return u = e.type, I = e.pendingProps, I = e.elementType === u ? I : vr(u, I), yf(t, e, u, I, r);
    case 1:
      return u = e.type, I = e.pendingProps, I = e.elementType === u ? I : vr(u, I), jC(t, e, u, I, r);
    case 3:
      t: {
        if (Lb(e), t === null) throw Error(gn(387));
        u = e.pendingProps, E = e.memoizedState, I = E.element, nb(t, e), Hg(e, u, null, r);
        var k = e.memoizedState;
        if (u = k.element, E.isDehydrated) if (E = { element: u, isDehydrated: !1, cache: k.cache, pendingSuspenseBoundaries: k.pendingSuspenseBoundaries, transitions: k.transitions }, e.updateQueue.baseState = E, e.memoizedState = E, e.flags & 256) {
          I = kl(Error(gn(423)), e), e = ZC(t, e, u, r, I);
          break t;
        } else if (u !== I) {
          I = kl(Error(gn(424)), e), e = ZC(t, e, u, r, I);
          break t;
        } else for (ji = Fs(e.stateNode.containerInfo.firstChild), Ji = e, Ba = !0, Tr = null, r = tb(e, null, u, r), e.child = r; r; ) r.flags = r.flags & -3 | 4096, r = r.sibling;
        else {
          if (vl(), u === I) {
            e = ds(t, e, r);
            break t;
          }
          bi(t, e, u, r);
        }
        e = e.child;
      }
      return e;
    case 5:
      return ab(e), t === null && ff(e), u = e.type, I = e.pendingProps, E = t !== null ? t.memoizedProps : null, k = I.children, uf(u, I) ? k = null : E !== null && uf(u, E) && (e.flags |= 32), kb(t, e), bi(t, e, k, r), e.child;
    case 6:
      return t === null && ff(e), null;
    case 13:
      return Mb(t, e, r);
    case 4:
      return ph(e, e.stateNode.containerInfo), u = e.pendingProps, t === null ? e.child = El(e, null, u, r) : bi(t, e, u, r), e.child;
    case 11:
      return u = e.type, I = e.pendingProps, I = e.elementType === u ? I : vr(u, I), XC(t, e, u, I, r);
    case 7:
      return bi(t, e, e.pendingProps, r), e.child;
    case 8:
      return bi(t, e, e.pendingProps.children, r), e.child;
    case 12:
      return bi(t, e, e.pendingProps.children, r), e.child;
    case 10:
      t: {
        if (u = e.type._context, I = e.pendingProps, E = e.memoizedProps, k = I.value, Sa(zg, u._currentValue), u._currentValue = k, E !== null) if (Mr(E.value, k)) {
          if (E.children === I.children && !zi.current) {
            e = ds(t, e, r);
            break t;
          }
        } else for (E = e.child, E !== null && (E.return = e); E !== null; ) {
          var g = E.dependencies;
          if (g !== null) {
            k = E.child;
            for (var w = g.firstContext; w !== null; ) {
              if (w.context === u) {
                if (E.tag === 1) {
                  w = ss(-1, r & -r), w.tag = 2;
                  var B = E.updateQueue;
                  if (B !== null) {
                    B = B.shared;
                    var c = B.pending;
                    c === null ? w.next = w : (w.next = c.next, c.next = w), B.pending = w;
                  }
                }
                E.lanes |= r, w = E.alternate, w !== null && (w.lanes |= r), hf(
                  E.return,
                  r,
                  e
                ), g.lanes |= r;
                break;
              }
              w = w.next;
            }
          } else if (E.tag === 10) k = E.type === e.type ? null : E.child;
          else if (E.tag === 18) {
            if (k = E.return, k === null) throw Error(gn(341));
            k.lanes |= r, g = k.alternate, g !== null && (g.lanes |= r), hf(k, r, e), k = E.sibling;
          } else k = E.child;
          if (k !== null) k.return = E;
          else for (k = E; k !== null; ) {
            if (k === e) {
              k = null;
              break;
            }
            if (E = k.sibling, E !== null) {
              E.return = k.return, k = E;
              break;
            }
            k = k.return;
          }
          E = k;
        }
        bi(t, e, I.children, r), e = e.child;
      }
      return e;
    case 9:
      return I = e.type, u = e.pendingProps.children, _l(e, r), I = hr(I), u = u(I), e.flags |= 1, bi(t, e, u, r), e.child;
    case 14:
      return u = e.type, I = vr(u, e.pendingProps), I = vr(u.type, I), WC(t, e, u, I, r);
    case 15:
      return Eb(t, e, e.type, e.pendingProps, r);
    case 17:
      return u = e.type, I = e.pendingProps, I = e.elementType === u ? I : vr(u, I), hg(t, e), e.tag = 1, Yi(u) ? (t = !0, xg(e)) : t = !1, _l(e, r), Sb(e, u, I), If(e, u, I, r), Af(null, e, u, !0, t, r);
    case 19:
      return Rb(t, e, r);
    case 22:
      return Tb(t, e, r);
  }
  throw Error(gn(156, e.tag));
};
function Wb(t, e) {
  return A_(t, e);
}
function uL(t, e, r, u) {
  this.tag = t, this.key = r, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = u, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function cr(t, e, r, u) {
  return new uL(t, e, r, u);
}
function Rh(t) {
  return t = t.prototype, !(!t || !t.isReactComponent);
}
function dL(t) {
  if (typeof t == "function") return Rh(t) ? 1 : 0;
  if (t != null) {
    if (t = t.$$typeof, t === Jf) return 11;
    if (t === Qf) return 14;
  }
  return 2;
}
function Vs(t, e) {
  var r = t.alternate;
  return r === null ? (r = cr(t.tag, e, t.key, t.mode), r.elementType = t.elementType, r.type = t.type, r.stateNode = t.stateNode, r.alternate = t, t.alternate = r) : (r.pendingProps = e, r.type = t.type, r.flags = 0, r.subtreeFlags = 0, r.deletions = null), r.flags = t.flags & 14680064, r.childLanes = t.childLanes, r.lanes = t.lanes, r.child = t.child, r.memoizedProps = t.memoizedProps, r.memoizedState = t.memoizedState, r.updateQueue = t.updateQueue, e = t.dependencies, r.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, r.sibling = t.sibling, r.index = t.index, r.ref = t.ref, r;
}
function Cg(t, e, r, u, I, E) {
  var k = 2;
  if (u = t, typeof t == "function") Rh(t) && (k = 1);
  else if (typeof t == "string") k = 5;
  else t: switch (t) {
    case al:
      return Ao(r.children, I, E, e);
    case Zf:
      k = 8, I |= 8;
      break;
    case Pm:
      return t = cr(12, r, e, I | 2), t.elementType = Pm, t.lanes = E, t;
    case Fm:
      return t = cr(13, r, e, I), t.elementType = Fm, t.lanes = E, t;
    case Om:
      return t = cr(19, r, e, I), t.elementType = Om, t.lanes = E, t;
    case a_:
      return lc(r, I, E, e);
    default:
      if (typeof t == "object" && t !== null) switch (t.$$typeof) {
        case e_:
          k = 10;
          break t;
        case n_:
          k = 9;
          break t;
        case Jf:
          k = 11;
          break t;
        case Qf:
          k = 14;
          break t;
        case Ds:
          k = 16, u = null;
          break t;
      }
      throw Error(gn(130, t == null ? t : typeof t, ""));
  }
  return e = cr(k, r, e, I), e.elementType = t, e.type = u, e.lanes = E, e;
}
function Ao(t, e, r, u) {
  return t = cr(7, t, u, e), t.lanes = r, t;
}
function lc(t, e, r, u) {
  return t = cr(22, t, u, e), t.elementType = a_, t.lanes = r, t.stateNode = { isHidden: !1 }, t;
}
function hm(t, e, r) {
  return t = cr(6, t, null, e), t.lanes = r, t;
}
function pm(t, e, r) {
  return e = cr(4, t.children !== null ? t.children : [], t.key, e), e.lanes = r, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e;
}
function gL(t, e, r, u, I) {
  this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Jc(0), this.expirationTimes = Jc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Jc(0), this.identifierPrefix = u, this.onRecoverableError = I, this.mutableSourceEagerHydrationData = null;
}
function Dh(t, e, r, u, I, E, k, g, w) {
  return t = new gL(t, e, r, g, w), e === 1 ? (e = 1, E === !0 && (e |= 8)) : e = 0, E = cr(3, null, null, e), t.current = E, E.stateNode = t, E.memoizedState = { element: u, isDehydrated: r, cache: null, transitions: null, pendingSuspenseBoundaries: null }, hh(E), t;
}
function cL(t, e, r) {
  var u = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: nl, key: u == null ? null : "" + u, children: t, containerInfo: e, implementation: r };
}
function jb(t) {
  if (!t) return Ws;
  t = t._reactInternals;
  t: {
    if (To(t) !== t || t.tag !== 1) throw Error(gn(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break t;
        case 1:
          if (Yi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break t;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(gn(171));
  }
  if (t.tag === 1) {
    var r = t.type;
    if (Yi(r)) return j_(t, r, e);
  }
  return e;
}
function Zb(t, e, r, u, I, E, k, g, w) {
  return t = Dh(r, u, !0, t, I, E, k, g, w), t.context = jb(null), r = t.current, u = Si(), I = Ks(r), E = ss(u, I), E.callback = e != null ? e : null, Os(r, E, I), t.current.lanes = I, td(t, I, u), Hi(t, u), t;
}
function uc(t, e, r, u) {
  var I = e.current, E = Si(), k = Ks(I);
  return r = jb(r), e.context === null ? e.context = r : e.pendingContext = r, e = ss(E, k), e.payload = { element: t }, u = u === void 0 ? null : u, u !== null && (e.callback = u), t = Os(I, e, k), t !== null && (Lr(t, I, k, E), cg(t, I, k)), k;
}
function Wg(t) {
  if (t = t.current, !t.child) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function ry(t, e) {
  if (t = t.memoizedState, t !== null && t.dehydrated !== null) {
    var r = t.retryLane;
    t.retryLane = r !== 0 && r < e ? r : e;
  }
}
function Bh(t, e) {
  ry(t, e), (t = t.alternate) && ry(t, e);
}
function mL() {
  return null;
}
var Jb = typeof reportError == "function" ? reportError : function(t) {
  console.error(t);
};
function xh(t) {
  this._internalRoot = t;
}
dc.prototype.render = xh.prototype.render = function(t) {
  var e = this._internalRoot;
  if (e === null) throw Error(gn(409));
  uc(t, e, null, null);
};
dc.prototype.unmount = xh.prototype.unmount = function() {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    vo(function() {
      uc(null, t, null, null);
    }), e[ls] = null;
  }
};
function dc(t) {
  this._internalRoot = t;
}
dc.prototype.unstable_scheduleHydration = function(t) {
  if (t) {
    var e = T_();
    t = { blockedOn: null, target: t, priority: e };
    for (var r = 0; r < xs.length && e !== 0 && e < xs[r].priority; r++) ;
    xs.splice(r, 0, t), r === 0 && L_(t);
  }
};
function Nh(t) {
  return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11);
}
function gc(t) {
  return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "));
}
function sy() {
}
function fL(t, e, r, u, I) {
  if (I) {
    if (typeof u == "function") {
      var E = u;
      u = function() {
        var B = Wg(k);
        E.call(B);
      };
    }
    var k = Zb(e, u, t, 0, null, !1, !1, "", sy);
    return t._reactRootContainer = k, t[ls] = k.current, Pu(t.nodeType === 8 ? t.parentNode : t), vo(), k;
  }
  for (; I = t.lastChild; ) t.removeChild(I);
  if (typeof u == "function") {
    var g = u;
    u = function() {
      var B = Wg(w);
      g.call(B);
    };
  }
  var w = Dh(t, 0, !1, null, null, !1, !1, "", sy);
  return t._reactRootContainer = w, t[ls] = w.current, Pu(t.nodeType === 8 ? t.parentNode : t), vo(function() {
    uc(e, w, r, u);
  }), w;
}
function cc(t, e, r, u, I) {
  var E = r._reactRootContainer;
  if (E) {
    var k = E;
    if (typeof I == "function") {
      var g = I;
      I = function() {
        var w = Wg(k);
        g.call(w);
      };
    }
    uc(e, k, t, I);
  } else k = fL(r, e, t, I, u);
  return Wg(k);
}
v_ = function(t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var r = yu(e.pendingLanes);
        r !== 0 && (th(e, r | 1), Hi(e, Za()), !(fa & 6) && (Ll = Za() + 500, qs()));
      }
      break;
    case 13:
      vo(function() {
        var u = us(t, 1);
        if (u !== null) {
          var I = Si();
          Lr(u, t, 1, I);
        }
      }), Bh(t, 1);
  }
};
eh = function(t) {
  if (t.tag === 13) {
    var e = us(t, 134217728);
    if (e !== null) {
      var r = Si();
      Lr(e, t, 134217728, r);
    }
    Bh(t, 134217728);
  }
};
E_ = function(t) {
  if (t.tag === 13) {
    var e = Ks(t), r = us(t, e);
    if (r !== null) {
      var u = Si();
      Lr(r, t, e, u);
    }
    Bh(t, e);
  }
};
T_ = function() {
  return ya;
};
k_ = function(t, e) {
  var r = ya;
  try {
    return ya = t, e();
  } finally {
    ya = r;
  }
};
qm = function(t, e, r) {
  switch (e) {
    case "input":
      if (Vm(t, r), e = r.name, r.type === "radio" && e != null) {
        for (r = t; r.parentNode; ) r = r.parentNode;
        for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < r.length; e++) {
          var u = r[e];
          if (u !== t && u.form === t.form) {
            var I = nc(u);
            if (!I) throw Error(gn(90));
            r_(u), Vm(u, I);
          }
        }
      }
      break;
    case "textarea":
      o_(t, r);
      break;
    case "select":
      e = r.value, e != null && Il(t, !!r.multiple, e, !1);
  }
};
f_ = kh;
h_ = vo;
var hL = { usingClientEntryPoint: !1, Events: [nd, ol, nc, c_, m_, kh] }, cu = { findFiberByHostInstance: po, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, pL = { bundleType: cu.bundleType, version: cu.version, rendererPackageName: cu.rendererPackageName, rendererConfig: cu.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: gs.ReactCurrentDispatcher, findHostInstanceByFiber: function(t) {
  return t = C_(t), t === null ? null : t.stateNode;
}, findFiberByHostInstance: cu.findFiberByHostInstance || mL, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != "undefined") {
  var tg = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!tg.isDisabled && tg.supportsFiber) try {
    qg = tg.inject(pL), Kr = tg;
  } catch (t) {
  }
}
tr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = hL;
tr.createPortal = function(t, e) {
  var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Nh(e)) throw Error(gn(200));
  return cL(t, e, null, r);
};
tr.createRoot = function(t, e) {
  if (!Nh(t)) throw Error(gn(299));
  var r = !1, u = "", I = Jb;
  return e != null && (e.unstable_strictMode === !0 && (r = !0), e.identifierPrefix !== void 0 && (u = e.identifierPrefix), e.onRecoverableError !== void 0 && (I = e.onRecoverableError)), e = Dh(t, 1, !1, null, null, r, !1, u, I), t[ls] = e.current, Pu(t.nodeType === 8 ? t.parentNode : t), new xh(e);
};
tr.findDOMNode = function(t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function" ? Error(gn(188)) : (t = Object.keys(t).join(","), Error(gn(268, t)));
  return t = C_(e), t = t === null ? null : t.stateNode, t;
};
tr.flushSync = function(t) {
  return vo(t);
};
tr.hydrate = function(t, e, r) {
  if (!gc(e)) throw Error(gn(200));
  return cc(null, t, e, !0, r);
};
tr.hydrateRoot = function(t, e, r) {
  if (!Nh(t)) throw Error(gn(405));
  var u = r != null && r.hydratedSources || null, I = !1, E = "", k = Jb;
  if (r != null && (r.unstable_strictMode === !0 && (I = !0), r.identifierPrefix !== void 0 && (E = r.identifierPrefix), r.onRecoverableError !== void 0 && (k = r.onRecoverableError)), e = Zb(e, null, t, 1, r != null ? r : null, I, !1, E, k), t[ls] = e.current, Pu(t), u) for (t = 0; t < u.length; t++) r = u[t], I = r._getVersion, I = I(r._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, I] : e.mutableSourceEagerHydrationData.push(
    r,
    I
  );
  return new dc(e);
};
tr.render = function(t, e, r) {
  if (!gc(e)) throw Error(gn(200));
  return cc(null, t, e, !1, r);
};
tr.unmountComponentAtNode = function(t) {
  if (!gc(t)) throw Error(gn(40));
  return t._reactRootContainer ? (vo(function() {
    cc(null, null, t, !1, function() {
      t._reactRootContainer = null, t[ls] = null;
    });
  }), !0) : !1;
};
tr.unstable_batchedUpdates = kh;
tr.unstable_renderSubtreeIntoContainer = function(t, e, r, u) {
  if (!gc(r)) throw Error(gn(200));
  if (t == null || t._reactInternals === void 0) throw Error(gn(38));
  return cc(t, e, r, !1, u);
};
tr.version = "18.3.1-next-f1338f8080-20240426";
function Qb() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Qb);
    } catch (t) {
      console.error(t);
    }
}
Qb(), QA.exports = tr;
var IL = QA.exports;
const qb = /* @__PURE__ */ Nf(IL);
(function(t, e) {
  try {
    if (typeof document < "u" && !document.getElementById("digital-things-shared-styles")) {
      var r = document.createElement("style");
      r.id = "digital-things-shared-styles";
      for (const u in e.attributes) r.setAttribute(u, e.attributes[u]);
      r.appendChild(document.createTextNode(`${t}`)), document.head.appendChild(r);
    }
  } catch (u) {
    console.error("vite-plugin-css-injected-by-js", u);
  }
})("._container_lzgh8_11{position:absolute;top:0;right:0;bottom:0;left:0;background-color:#0003;display:flex;align-items:center;justify-content:center;z-index:1;transition:opacity .25s;opacity:0}._container--shown_lzgh8_22{opacity:1;pointer-events:all;cursor:pointer}._container--modal_lzgh8_27{cursor:default}@media only screen and (max-width: 786px){._container--mobile-fullscreen_lzgh8_31 ._container__window_lzgh8_31>div>div:nth-child(2){width:100%!important;height:100%!important;overflow:auto!important;border-radius:unset!important;box-shadow:unset!important;max-width:unset;max-height:unset;padding:4px}._container--mobile-fullscreen_lzgh8_31 ._container__window_lzgh8_31>div{width:100%!important;height:100%!important;overflow:auto!important;border-radius:unset!important;box-shadow:unset!important;max-width:unset;max-height:unset;padding:4px}._container--mobile-fullscreen_lzgh8_31 ._container__window_lzgh8_31{height:100%;width:100%}}._container_37riv_11{position:fixed;top:0;right:0;bottom:0;left:0;z-index:10;pointer-events:none}._container_1vwk2_11{display:flex;justify-content:flex-end;padding:8px;gap:8px}._container_985xx_11{padding:8px;font-size:1rem;overflow-y:auto}._icon_t415l_11{display:flex;color:inherit;justify-content:center;align-items:center}._icon_t415l_11>span{display:flex;justify-content:center;align-items:center}._icon--shadow-text_t415l_22{text-shadow:0px 2px 4px rgba(0,0,0,.5)}._icon--shadow-svg_t415l_25>span>svg>path{filter:drop-shadow(0px 2px 4px rgb(0,0,0))}._container_197zl_11{display:flex;align-items:center;min-height:40px}._container__title_197zl_16{flex-grow:1;font-size:1.3rem;font-weight:700;padding:0 8px;overflow:hidden;text-wrap:nowrap;text-overflow:ellipsis}._container__actions_197zl_25{display:flex}._container__actions__action_197zl_28{cursor:pointer}._container_197zl_11 button{background-color:inherit!important;color:inherit!important}body{font-family:Avenir,sans-serif}._container_mo9s9_11{position:relative;width:100%;height:100%}._container__blur_mo9s9_16{position:absolute;top:0;right:0;bottom:0;left:0;-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px)}._container__image_mo9s9_21{position:absolute;top:0;right:0;bottom:0;left:0;background-repeat:no-repeat;background-size:contain;background-position:center;opacity:0;transition:opacity .25s;overflow:hidden}._container__image--loaded_mo9s9_31{opacity:1}", { styleId: "digital-things-shared-styles" });
var CL = Object.defineProperty, yL = (t, e, r) => e in t ? CL(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, AL = (t, e, r) => (yL(t, e + "", r), r);
Qu.createContext(null);
const $b = "image", t0 = "video", e0 = "hand-tracking", n0 = "model", a0 = "iframe", i0 = "social-media", r0 = "chroma-video", s0 = "multi-media", o0 = "volumetric-video", l0 = "rich-text", u0 = "campaign", d0 = "actions", g0 = "thing", c0 = "matte-video", _L = [
  $b,
  t0,
  e0,
  n0,
  a0,
  i0,
  r0,
  s0,
  o0,
  l0,
  u0,
  d0,
  g0,
  c0
], bL = "center", SL = "north", wL = "north-east", vL = "east", EL = "south-east", TL = "south", kL = "south-west", LL = "west", ML = "north-west", RL = [
  bL,
  SL,
  wL,
  vL,
  EL,
  TL,
  kL,
  LL,
  ML
], oy = "web", DL = "app", BL = "ios", ly = "8i", xL = "arcturus", NL = "mrcs", m0 = "link", GL = "share-link", zL = "email", YL = "call", HL = "sms", PL = "calendar", FL = "download", OL = "iframe-popup", UL = "open-thing", KL = "open-campaign", VL = "navigate-back", XL = [
  m0,
  VL,
  UL,
  KL,
  FL,
  YL,
  zL,
  HL,
  GL,
  PL,
  OL
], WL = "video", jL = "model", ZL = "image", JL = "document", QL = "metadata", qL = "archive", $L = "audio", tM = "text", eM = "binary", nM = "hosting", aM = "conversion", iM = "gaussian_splatting", rM = [
  WL,
  jL,
  ZL,
  JL,
  QL,
  qL,
  $L,
  tM,
  eM,
  nM,
  aM,
  iM
], sM = "cms", oM = "custom-model", lM = "sphere", uM = "cube", dM = "cylinder", gM = "cone", cM = "torus", mM = "card", fM = [
  mM,
  lM,
  uM,
  dM,
  gM,
  cM,
  oM
], hM = "ccbill", pM = "stripe", IM = "ownedLabel", CM = "purchaseLabel", yM = "saveLabel", uy = "unpublished", AM = "published", dy = "unpublished", _M = "published", f0 = "things-gallery", bM = "campaign", h0 = "group", SM = "creative-brief", p0 = "cover", jg = "contain", I0 = "blur", C0 = "center", Gh = "instagram", zh = "facebook", Yh = "twitter", Hh = "linkedin", Ml = "website", Ph = "youtube", Fh = "pinterest", Oh = "tiktok", wM = [
  Gh,
  zh,
  Yh,
  Hh,
  Ml,
  Ph,
  Fh,
  Oh
], vM = "night-sky", EM = "sky", TM = "gradient", kM = "color", id = [
  EM,
  vM,
  TM,
  kM,
  "BasketballArena",
  "sunrise",
  "AristeaWreck",
  "ScythianTombs",
  "Syferfontein",
  "ModernBuildings",
  "DancingHall",
  "StudioSmall",
  "PureSky",
  "PhotoStudio",
  "FarmField",
  "Kloppenheim",
  "SolitudeInterior",
  "HOCHeartCasePovLarge",
  "HOCHeartCasePennyTheWish",
  "HOCHeartCaseInternationalBMW",
  "HOCHeartTheCore",
  "MuseumFemaleSculptures",
  "MuseumBecoming",
  "MuseumFoundation",
  "MuseumWeHaventLandedOnEarthYet",
  "MuseumTulips",
  "MuseumSisters",
  "MuseumBubblegum",
  "MuseumHeech",
  "MuseumDesert",
  "MuseumParsec",
  "MuseumPillar",
  "BelfastSunsetPureSky",
  "Kloppenheim02PureSky",
  "Kloppenheim07PureSky",
  "RustigKoppiePureSky",
  "TableMountain1PureSky",
  "WastelandCloudsPureSky",
  "Kloofendal48dPartlyCloudyPureSky",
  "AlpsField",
  "IvyDemo",
  "MerryChristmasWorld",
  "NetrunnerFutureNeoTokyo",
  "FuturisticCity",
  "HDR_Chris_Johnson",
  "HDR_Brett2",
  "ArielleHDRI",
  "CourtneyHDRI",
  "JasmineHDRI",
  "LittleDragonHDRI",
  "MeaghanHDRI",
  "musicHDRI",
  "SocialHDRI",
  "StephMIHDRI",
  "TaylorHDRI",
  "HDR_Taryn",
  "HDR_Dannie",
  "HDR_Holly_Barker",
  "HDR_Barbie",
  "HDR_Jay_Chris",
  "HDR_Paige",
  "HDR_Nicusia",
  "FashionHDR"
], gy = "2d", LM = "3d", MM = "xr", RM = "vr", DM = "hand";
var BM = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xM(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function NM(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var r = function u() {
      return this instanceof u ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    r.prototype = e.prototype;
  } else
    r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(t).forEach(function(u) {
    var I = Object.getOwnPropertyDescriptor(t, u);
    Object.defineProperty(r, u, I.get ? I : {
      enumerable: !0,
      get: function() {
        return t[u];
      }
    });
  }), r;
}
var GM = { exports: {} };
(function(t, e) {
  (function(r, u) {
    t.exports = u();
  })(BM, function() {
    function r(b, y) {
      var T = window.matchMedia(b);
      y(T.matches);
      var n = function() {
        return y(T.matches);
      };
      return T.addListener(n), function() {
        return T.removeListener(n);
      };
    }
    function u(b, y) {
      return g[b] !== y && (g[b] = y, B(b, y), !0);
    }
    var I = typeof navigator < "u" && typeof window < "u";
    if (I && typeof nw < "u")
      try {
        nw.Window.get();
      } catch (b) {
        I = !1;
      }
    var E = !I, k = I ? navigator.userAgent : void 0, g = { gui: I, terminal: E, registerQuery: r };
    g.node = typeof process < "u" && !!process.versions && !!process.versions.node, g.pwa = g.gui && window.matchMedia("(display-mode: standalone)").matches && document.head.querySelector('[rel="manifest"]') !== null, g.uwp = typeof Windows < "u" && typeof MSApp < "u", g.nwjs = !(!g.node || !process.versions.nw), g.electron = !(!g.node || !process.versions.electron), g.cordova = !(!g.gui || !window.cordova), g.packaged = g.uwp || g.nwjs || g.electron || g.cordova, g.web = !g.node && !g.packaged, g.browser = g.web, g.website = g.web && !g.pwa, g.worker = !g.gui && typeof self < "u" && self.importScripts !== void 0, g.serviceWorker = g.worker && !!navigator.serviceWorker.controller || !1, g.android = !!g.gui && k.includes("Android"), g.chromeos = !!g.gui && k.includes("CrOS"), g.tizen = !!g.gui && k.includes("Tizen"), g.ios = g.gui && /iPad|iPhone|iPod/.test(k) && !window.MSStream || !1, g.linuxBased = g.android || g.tizen, g.windows = g.node ? process.platform === "win32" : k.includes("Windows"), g.macos = g.node ? process.platform === "darwin" : k.includes("Macintosh"), g.linux = g.node ? process.platform === "linux" : k.includes("Linux") && !g.linuxBased && !g.macos, g.edgeHtml = g.gui && k.includes("Edge/"), g.edgeChromium = g.gui && k.includes("Edg/"), g.edgeAndroid = g.gui && k.includes("EdgA/"), g.edgeIos = g.gui && k.includes("EdgiOS/"), g.chromeIos = g.gui && k.includes("CriOS/"), g.firefoxIos = g.gui && k.includes("FxiOS/"), g.edge = g.edgeHtml || g.edgeChromium || g.edgeAndroid || g.edgeIos, g.samsungBrowser = g.gui && k.includes("SamsungBrowser/"), g.opera = g.gui && (k.includes("Opera") || k.includes("OPR/")), g.firefox = g.gui && (k.includes("Firefox") || g.firefoxIos), g.chrome = g.gui && (k.includes("Chrome") || g.chromeIos) && !g.edge && !g.opera && !g.samsungBrowser, g.safari = g.gui && k.includes("Safari") && !g.chrome && !g.edge && !g.firefox && !g.opera && !g.samsungBrowser || g.edgeIos || g.chromeIos || g.firefoxIos, g.ie = g.trident = g.gui && k.includes("Trident"), g.blink = g.chrome && !g.chromeIos || g.edgeChromium || g.edgeAndroid || g.samsungBrowser, g.webkit = g.blink || g.safari, g.gecko = g.firefox && !g.firefoxIos && !g.webkit && !g.safari;
    var w = {};
    g.on = function(b, y) {
      w[b] = w[b] || /* @__PURE__ */ new Set(), w[b].add(y);
    }, g.off = g.removeListener = function(b, y) {
      w[b] && w[b].delete(y);
    };
    var B = g.emit = function(b, y) {
      w[b] && w[b].forEach(function(T) {
        return T(y);
      });
    };
    if (g.gui) {
      g.pixelRatio = parseFloat(window.devicePixelRatio.toFixed(2)), g.gameconsole = k.includes("Xbox") || k.includes("PlayStation");
      var c = 0;
      if (window.addEventListener("gamepadconnected", function(b) {
        return c++;
      }), window.addEventListener("gamepaddisconnected", function(b) {
        return c--;
      }), g.gameconsole)
        g.gamepad = !0, g.mouse = !0, g.touch = !1, g.tv = !0, g.battery = !1, g.phone = g.tablet = g.hybrid = g.laptop = g.desktop = !1, g.formfactor = "gameconsole";
      else {
        var d = function() {
          u("tv", g.formfactor === "tv"), u("phone", g.formfactor === "phone"), u("tablet", g.formfactor === "tablet"), u("hybrid", g.formfactor === "hybrid"), u("laptop", g.formfactor === "laptop"), u("desktop", g.formfactor === "desktop");
        }, m = function() {
          var b = Math.min(window.screen.width, window.screen.height);
          return g.tv ? "tv" : g.touch && b < 600 ? "phone" : g.touch && !g.mouse ? "tablet" : g.touch && g.mouse ? "hybrid" : g.battery ? "laptop" : "desktop";
        };
        g.touch = navigator.maxTouchPoints > 0, g.tv = k.includes("TV"), c = navigator.getGamepads ? Array.from(navigator.getGamepads()).filter(function(b) {
          return b != null;
        }).length : 0, g.gamepad = c > 0, r("(orientation: portrait)", function(b) {
          g.portrait = b, g.landscape = !b, g.orientation = b ? "portrait" : "landscape", B("portrait", g.portrait), B("landscape", g.landscape), B("orientation", g.orientation);
        }), r("(any-pointer: coarse)", function(b) {
          u("touch", b), u("formfactor", m()) && d();
        }), r("(hover: hover)", function(b) {
          u("mouse", b), u("input", b ? "mouse" : "touch"), u("formfactor", m()) && d();
        });
      }
    }
    return g.csp = g.uwp || !1, g.nwjs ? g.dev = process.versions["nw-flavor"] === "sdk" : g.electron ? g.dev = process.execPath.replace(/\\/g, "/").includes("node_modules/electron/") : g.uwp ? g.dev = Windows.ApplicationModel.Package.current.isDevelopmentMode : g.node ? g.dev = !1 : g.dev = void 0, g;
  });
})(GM);
const Im = (t = 0) => new Promise((e) => setTimeout(e, t));
function zM(t) {
  return t >= 55296 && t <= 56319;
}
function YM(t) {
  return t >= 56320 && t <= 57343;
}
var HM = function(t, e, r) {
  if (typeof e != "string")
    throw new Error("Input must be string");
  for (var u = e.length, I = 0, E, k, g = 0; g < u; g += 1) {
    if (E = e.charCodeAt(g), k = e[g], zM(E) && YM(e.charCodeAt(g + 1)) && (g += 1, k += e[g]), I += t(k), I === r)
      return e.slice(0, g + 1);
    if (I > r)
      return e.slice(0, g - k.length + 1);
  }
  return e;
};
function PM(t) {
  return t >= 55296 && t <= 56319;
}
function FM(t) {
  return t >= 56320 && t <= 57343;
}
var OM = function(t) {
  if (typeof t != "string")
    throw new Error("Input must be string");
  for (var e = t.length, r = 0, u = null, I = null, E = 0; E < e; E++)
    u = t.charCodeAt(E), FM(u) ? I != null && PM(I) ? r += 1 : r += 3 : u <= 127 ? r += 1 : u >= 128 && u <= 2047 ? r += 2 : u >= 2048 && u <= 65535 && (r += 3), I = u;
  return r;
}, UM = HM, KM = OM;
UM.bind(null, KM);
Zg.createContext(void 0);
var cy;
(function(t) {
  t.BORDER_BOX = "border-box", t.CONTENT_BOX = "content-box", t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(cy || (cy = {}));
var Uh = function(t) {
  return Object.freeze(t);
}, VM = /* @__PURE__ */ function() {
  function t(e, r) {
    this.inlineSize = e, this.blockSize = r, Uh(this);
  }
  return t;
}(), XM = function() {
  function t(e, r, u, I) {
    return this.x = e, this.y = r, this.width = u, this.height = I, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Uh(this);
  }
  return t.prototype.toJSON = function() {
    var e = this, r = e.x, u = e.y, I = e.top, E = e.right, k = e.bottom, g = e.left, w = e.width, B = e.height;
    return { x: r, y: u, top: I, right: E, bottom: k, left: g, width: w, height: B };
  }, t.fromRect = function(e) {
    return new t(e.x, e.y, e.width, e.height);
  }, t;
}(), my = typeof window < "u" ? window : {};
/msie|trident/i.test(my.navigator && my.navigator.userAgent);
var Cm = function(t, e, r) {
  return t === void 0 && (t = 0), e === void 0 && (e = 0), r === void 0 && (r = !1), new VM((r ? e : t) || 0, (r ? t : e) || 0);
};
Uh({
  devicePixelContentBoxSize: Cm(),
  borderBoxSize: Cm(),
  contentBoxSize: Cm(),
  contentRect: new XM(0, 0, 0, 0)
});
Qu[typeof document < "u" && document.createElement !== void 0 ? "useLayoutEffect" : "useEffect"];
var mu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fy;
function WM() {
  if (fy)
    return mu;
  fy = 1;
  var t = Qu, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), u = Object.prototype.hasOwnProperty, I = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, E = { key: !0, ref: !0, __self: !0, __source: !0 };
  function k(g, w, B) {
    var c, d = {}, m = null, b = null;
    B !== void 0 && (m = "" + B), w.key !== void 0 && (m = "" + w.key), w.ref !== void 0 && (b = w.ref);
    for (c in w)
      u.call(w, c) && !E.hasOwnProperty(c) && (d[c] = w[c]);
    if (g && g.defaultProps)
      for (c in w = g.defaultProps, w)
        d[c] === void 0 && (d[c] = w[c]);
    return { $$typeof: e, type: g, key: m, ref: b, props: d, _owner: I.current };
  }
  return mu.Fragment = r, mu.jsx = k, mu.jsxs = k, mu;
}
WM();
var Df = { exports: {} };
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  function r(V) {
    return typeof V == "object" && !("toString" in V) ? Object.prototype.toString.call(V).slice(8, -1) : V;
  }
  var u = typeof process == "object" && !0;
  function I(V, Q) {
    if (!V)
      throw u ? new Error("Invariant failed") : new Error(Q());
  }
  e.invariant = I;
  var E = Object.prototype.hasOwnProperty, k = Array.prototype.splice, g = Object.prototype.toString;
  function w(V) {
    return g.call(V).slice(8, -1);
  }
  var B = Object.assign || /* istanbul ignore next */
  function(V, Q) {
    return c(Q).forEach(function(vt) {
      E.call(Q, vt) && (V[vt] = Q[vt]);
    }), V;
  }, c = typeof Object.getOwnPropertySymbols == "function" ? function(V) {
    return Object.keys(V).concat(Object.getOwnPropertySymbols(V));
  } : function(V) {
    return Object.keys(V);
  };
  function d(V) {
    return Array.isArray(V) ? B(V.constructor(V.length), V) : w(V) === "Map" ? new Map(V) : w(V) === "Set" ? new Set(V) : V && typeof V == "object" ? B(Object.create(Object.getPrototypeOf(V)), V) : V;
  }
  var m = (
    /** @class */
    function() {
      function V() {
        this.commands = B({}, b), this.update = this.update.bind(this), this.update.extend = this.extend = this.extend.bind(this), this.update.isEquals = function(Q, vt) {
          return Q === vt;
        }, this.update.newContext = function() {
          return new V().update;
        };
      }
      return Object.defineProperty(V.prototype, "isEquals", {
        get: function() {
          return this.update.isEquals;
        },
        set: function(Q) {
          this.update.isEquals = Q;
        },
        enumerable: !0,
        configurable: !0
      }), V.prototype.extend = function(Q, vt) {
        this.commands[Q] = vt;
      }, V.prototype.update = function(Q, vt) {
        var Lt = this, zt = typeof vt == "function" ? { $apply: vt } : vt;
        Array.isArray(Q) && Array.isArray(zt) || I(!Array.isArray(zt), function() {
          return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
        }), I(typeof zt == "object" && zt !== null, function() {
          return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(Lt.commands).join(", ") + ".");
        });
        var X = Q;
        return c(zt).forEach(function(D) {
          if (E.call(Lt.commands, D)) {
            var yt = Q === X;
            X = Lt.commands[D](zt[D], X, zt, Q), yt && Lt.isEquals(X, Q) && (X = Q);
          } else {
            var Mt = w(Q) === "Map" ? Lt.update(Q.get(D), zt[D]) : Lt.update(Q[D], zt[D]), at = w(X) === "Map" ? X.get(D) : X[D];
            (!Lt.isEquals(Mt, at) || typeof Mt > "u" && !E.call(Q, D)) && (X === Q && (X = d(Q)), w(X) === "Map" ? X.set(D, Mt) : X[D] = Mt);
          }
        }), X;
      }, V;
    }()
  );
  e.Context = m;
  var b = {
    $push: function(V, Q, vt) {
      return T(Q, vt, "$push"), V.length ? Q.concat(V) : Q;
    },
    $unshift: function(V, Q, vt) {
      return T(Q, vt, "$unshift"), V.length ? V.concat(Q) : Q;
    },
    $splice: function(V, Q, vt, Lt) {
      return o(Q, vt), V.forEach(function(zt) {
        l(zt), Q === Lt && zt.length && (Q = d(Lt)), k.apply(Q, zt);
      }), Q;
    },
    $set: function(V, Q, vt) {
      return p(vt), V;
    },
    $toggle: function(V, Q) {
      n(V, "$toggle");
      var vt = V.length ? d(Q) : Q;
      return V.forEach(function(Lt) {
        vt[Lt] = !Q[Lt];
      }), vt;
    },
    $unset: function(V, Q, vt, Lt) {
      return n(V, "$unset"), V.forEach(function(zt) {
        Object.hasOwnProperty.call(Q, zt) && (Q === Lt && (Q = d(Lt)), delete Q[zt]);
      }), Q;
    },
    $add: function(V, Q, vt, Lt) {
      return Z(Q, "$add"), n(V, "$add"), w(Q) === "Map" ? V.forEach(function(zt) {
        var X = zt[0], D = zt[1];
        Q === Lt && Q.get(X) !== D && (Q = d(Lt)), Q.set(X, D);
      }) : V.forEach(function(zt) {
        Q === Lt && !Q.has(zt) && (Q = d(Lt)), Q.add(zt);
      }), Q;
    },
    $remove: function(V, Q, vt, Lt) {
      return Z(Q, "$remove"), n(V, "$remove"), V.forEach(function(zt) {
        Q === Lt && Q.has(zt) && (Q = d(Lt)), Q.delete(zt);
      }), Q;
    },
    $merge: function(V, Q, vt, Lt) {
      return z(Q, V), c(V).forEach(function(zt) {
        V[zt] !== Q[zt] && (Q === Lt && (Q = d(Lt)), Q[zt] = V[zt]);
      }), Q;
    },
    $apply: function(V, Q) {
      return h(V), V(Q);
    }
  }, y = new m();
  e.isEquals = y.update.isEquals, e.extend = y.extend, e.default = y.update, e.default.default = t.exports = B(e.default, e);
  function T(V, Q, vt) {
    I(Array.isArray(V), function() {
      return "update(): expected target of " + r(vt) + " to be an array; got " + r(V) + ".";
    }), n(Q[vt], vt);
  }
  function n(V, Q) {
    I(Array.isArray(V), function() {
      return "update(): expected spec of " + r(Q) + " to be an array; got " + r(V) + ". Did you forget to wrap your parameter in an array?";
    });
  }
  function o(V, Q) {
    I(Array.isArray(V), function() {
      return "Expected $splice target to be an array; got " + r(V);
    }), l(Q.$splice);
  }
  function l(V) {
    I(Array.isArray(V), function() {
      return "update(): expected spec of $splice to be an array of arrays; got " + r(V) + ". Did you forget to wrap your parameters in an array?";
    });
  }
  function h(V) {
    I(typeof V == "function", function() {
      return "update(): expected spec of $apply to be a function; got " + r(V) + ".";
    });
  }
  function p(V) {
    I(Object.keys(V).length === 1, function() {
      return "Cannot have more than one key in an object with $set";
    });
  }
  function z(V, Q) {
    I(Q && typeof Q == "object", function() {
      return "update(): $merge expects a spec of type 'object'; got " + r(Q);
    }), I(V && typeof V == "object", function() {
      return "update(): $merge expects a target of type 'object'; got " + r(V);
    });
  }
  function Z(V, Q) {
    var vt = w(V);
    I(vt === "Map" || vt === "Set", function() {
      return "update(): " + r(Q) + " expects a target of type Set or Map; got " + r(vt);
    });
  }
})(Df, Df.exports);
var jM = Df.exports;
const Ja = /* @__PURE__ */ xM(jM), ZM = [];
for (let t = 0; t < 256; ++t)
  ZM.push((t + 256).toString(16).slice(1));
typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const JM = "Label Type", QM = "Label", qM = "TYPE_BOOLEAN", $M = "TYPE_FLOAT", t1 = "TYPE_INTEGER", e1 = "TYPE_STRING", n1 = "TYPE_ARRAY", a1 = "TYPE_OBJECT", i1 = "aws-date-time", r1 = "aws-json", s1 = "color", o1 = "email", l1 = "multiline-string", u1 = "phone-number", d1 = "url", g1 = "uuid", ta = {
  name: qM
}, ka = {
  name: $M
}, ja = {
  name: t1
}, hn = {
  name: e1
}, ea = {
  name: n1
}, sa = {
  name: a1
}, fr = {
  name: i1
}, Oa = {
  name: r1
}, Zi = {
  name: s1
}, c1 = {
  name: o1
}, Kh = {
  name: l1
}, m1 = {
  name: u1
}, rs = {
  name: d1
}, Xn = {
  name: g1
}, Nl = {
  name: "Image",
  type: sa,
  attributes: {
    uploadId: {
      type: Xn
    },
    backgroundSize: {
      type: hn,
      defaultValue: jg,
      oneOf: [
        jg,
        p0,
        I0
      ]
    },
    backgroundPosition: {
      type: hn,
      defaultValue: C0
    }
  }
}, Zu = {
  name: "Video",
  type: sa,
  attributes: {
    uploadId: {
      type: Xn
    },
    posters: {
      type: ea,
      items: Nl
    },
    backgroundSize: {
      type: hn,
      defaultValue: jg,
      oneOf: [
        jg,
        p0,
        I0
      ]
    },
    backgroundPosition: {
      type: hn,
      defaultValue: C0
    }
  }
}, mc = {
  caption: {
    type: hn
  },
  title: {
    type: hn
  },
  subtitle: {
    type: hn
  },
  description: {
    type: Kh
  },
  tags: {
    type: ea,
    items: {
      type: hn
    }
  }
}, Vh = {
  colors: {
    type: sa,
    inline: !0,
    attributes: {
      background: {
        type: Zi
      },
      primary: {
        type: Zi
      },
      secondary: {
        type: Zi
      },
      borderColor: {
        type: Zi
      }
    }
  },
  imageBackground: Nl,
  videoBackground: Zu
}, Xh = {
  scale: {
    type: ea,
    isNew: !0,
    // The entire `transform` object might not be available.
    minLength: 3,
    maxLength: 3,
    defaultValue: [1, 1, 1],
    items: {
      type: ka
    }
  },
  translation: {
    type: ea,
    isNew: !0,
    // The entire `transform` object might not be available.
    minLength: 3,
    maxLength: 3,
    defaultValue: [0, 0, 0],
    items: {
      type: ka,
      // TODO
      required: !0
    }
  },
  quaternion: {
    type: ea,
    isNew: !0,
    // The entire `transform` object might not be available.
    minLength: 4,
    maxLength: 4,
    defaultValue: [0, 0, 0, 1],
    items: {
      type: ka,
      required: !0
    }
  },
  pivot: {
    type: ea,
    isNew: !0,
    // The entire `transform` object might not be available.
    minLength: 3,
    maxLength: 3,
    defaultValue: [0, 0, 0],
    items: {
      type: ka,
      required: !0
    }
  }
}, y0 = {
  type: sa,
  attributes: {
    type: {
      type: hn,
      defaultValue: oy,
      oneOf: [oy, DL, BL]
    },
    // Model Mesh
    uploadId: {
      type: Xn
    },
    // Model Preview Mesh
    previewUploadId: {
      type: Xn,
      isHidden: !0
    },
    // Model Posters, preferably PNG
    posters: {
      type: ea,
      items: Nl
    }
  }
}, f1 = {
  type: Oa,
  inline: !0,
  attributes: {
    sources: {
      type: ea,
      inline: !0,
      items: y0
    },
    autoRotate: {
      type: ta,
      defaultValue: !0
    },
    enableCameraControls: {
      type: ta,
      defaultValue: !1
    },
    // Whether to make use of WebAR.rocks.hand volumetric capture
    enableCustomVolumetricCapture: {
      type: ta,
      defaultValue: !1
    },
    // Whether to make use of volumetric capture where each frame is stored in
    // the asset.
    enableVolumetricCapture: {
      type: ta,
      defaultValue: !1
    },
    transform: {
      type: sa,
      inline: !0,
      attributes: Da({}, Xh)
    },
    hologram: {
      type: sa,
      attributes: {
        color: {
          type: Zi
        },
        alpha: {
          type: ka
        }
      }
    },
    blobShadow: {
      type: sa,
      attributes: {
        color: {
          type: Zi
        },
        size: {
          type: ka
        },
        radiusStart: {
          type: ka
        },
        alphaMax: {
          type: ka
        },
        translation: {
          type: ea,
          minLength: 3,
          maxLength: 3,
          defaultValue: [0, 0, 0],
          items: {
            type: ka,
            required: !0
          }
        },
        quaternion: {
          type: ea,
          minLength: 4,
          maxLength: 4,
          defaultValue: [0, 0, 0, 1],
          items: {
            type: ka,
            required: !0
          }
        },
        additiveBlending: {
          type: ta
        }
      }
    }
  }
}, h1 = {
  type: Oa,
  inline: !0,
  attributes: {
    url: {
      type: rs
    },
    allow: {
      type: hn
    },
    referrerpolicy: {
      type: hn,
      oneOf: [
        "no-referrer",
        "origin",
        "origin-when-cross-origin",
        "same-origin",
        "strict-origin",
        "strict-origin-when-cross-origin"
      ]
    },
    sandbox: {
      type: hn,
      defaultValue: ""
    }
  }
}, p1 = {
  type: Oa,
  inline: !0,
  attributes: {
    sources: {
      type: ea,
      items: Nl
    },
    allowFullScreen: {
      type: ta,
      defaultValue: !0
    }
  }
}, I1 = {
  type: Oa,
  inline: !0,
  attributes: {
    sources: {
      type: ea,
      inline: !0,
      items: y0
    },
    environmentPreset: {
      type: hn,
      oneOf: id
    },
    // enablePhysics: {
    //   type: BooleanType,
    //   defaultValue: false,
    //   isHidden: process.env.NODE_ENV === "production",
    // },
    // Whether to make use of volumetric capture where each frame is stored in
    // the asset.
    autoRotate: {
      type: ta,
      defaultValue: !0
    },
    enableCameraControls: {
      type: ta,
      defaultValue: !0
    },
    transform: {
      type: sa,
      inline: !0,
      isHidden: !0,
      attributes: Da({}, Xh)
    }
  }
}, C1 = {
  type: Oa,
  inline: !0,
  attributes: {
    links: {
      type: ea,
      inline: !0,
      items: {
        type: sa,
        attributes: {
          kind: {
            type: hn,
            required: !0,
            defaultValue: Ml,
            oneOf: [
              Gh,
              zh,
              Yh,
              Hh,
              Ml,
              Ph,
              Fh,
              Oh
            ]
          },
          label: {
            type: hn
          },
          url: {
            type: rs,
            required: !0
          }
        }
      }
    }
  }
}, y1 = {
  type: Oa,
  inline: !0,
  attributes: {
    sources: {
      type: ea,
      items: Zu
    },
    loop: {
      type: ta,
      defaultValue: !0
    },
    allowFullScreen: {
      type: ta,
      defaultValue: !0
    }
  }
}, A1 = {
  type: Oa,
  inline: !0,
  attributes: {
    sources: {
      type: ea,
      items: Zu
    },
    loop: {
      type: ta
    },
    color: {
      type: Zi,
      defaultValue: "#00ff00"
    },
    similarity: {
      type: ka,
      defaultValue: 0.29
    },
    smoothness: {
      type: ka,
      defaultValue: 0.3
    },
    spill: {
      type: ka,
      defaultValue: 0.49
    },
    environmentPreset: {
      type: hn,
      oneOf: id
    }
  }
}, _1 = {
  type: Oa,
  inline: !0,
  attributes: {
    provider: {
      type: hn,
      defaultValue: ly,
      oneOf: [
        ly,
        xL,
        NL
      ]
    },
    manifest: {
      type: rs,
      required: !0
    },
    poster: Nl,
    autoRotate: {
      type: ta,
      defaultValue: !1
    },
    loop: {
      type: ta,
      defaultValue: !0
    },
    enableCameraControls: {
      type: ta,
      defaultValue: !1,
      isHidden: !0
    },
    transform: {
      type: sa,
      inline: !0,
      // Automatically converted MVX containers do not receive this attribute.
      // Enforce bypassing error handling.
      isNew: !0,
      attributes: Da({}, Xh)
    },
    enable30FPS: {
      type: ta,
      defaultValue: !1
    },
    environmentPreset: {
      type: hn,
      oneOf: id
    }
  }
}, b1 = {
  type: Oa,
  inline: !0,
  attributes: {
    width: {
      type: ja,
      defaultValue: 2
    },
    height: {
      type: ja,
      defaultValue: 2
    },
    cards: {
      type: ea,
      defaultValue: [
        {
          position: [1, 0],
          size: [1, 1]
        },
        {
          position: [0, 1],
          size: [1, 1]
        },
        {
          position: [1, 1],
          size: [1, 1]
        }
      ],
      items: {
        type: sa,
        attributes: {
          cardId: {
            inline: !0,
            type: Xn
          },
          position: {
            type: ea,
            minLength: 2,
            maxLength: 2,
            defaultValue: [0, 0],
            items: {
              type: ja,
              min: 0
            }
          },
          size: {
            type: ea,
            minLength: 2,
            maxLength: 2,
            defaultValue: [1, 1],
            items: {
              type: ja,
              min: 1
            }
          }
        }
      }
    }
  }
}, S1 = {
  type: Oa,
  inline: !0,
  attributes: {
    paragraphs: {
      type: ea,
      inline: !0,
      defaultValue: [{ content: "", imageUploadId: null, videoUploadId: null }],
      items: {
        type: sa,
        attributes: {
          image: {
            type: sa,
            attributes: {
              uploadId: {
                type: Xn
              }
            }
          },
          video: {
            type: sa,
            attributes: {
              uploadId: {
                type: Xn
              }
            }
          },
          title: {
            type: hn
          },
          content: {
            type: Kh
          }
        }
      }
    }
  }
}, w1 = {
  type: Oa,
  inline: !0,
  attributes: {
    campaignIds: {
      type: ea,
      items: {
        type: Xn
      }
    }
  }
}, v1 = {
  type: Oa,
  inline: !0,
  attributes: {
    defaultButtonColor: {
      type: Zi
    },
    actions: {
      type: ea,
      inline: !0,
      items: {
        type: sa,
        attributes: {
          kind: {
            type: hn,
            required: !0,
            isDisabled: !0,
            defaultValue: m0,
            oneOf: XL
          },
          // For all action types
          iconSourceUploadId: {
            type: Xn
          },
          iconName: {
            type: hn
          },
          buttonColor: {
            type: Zi
          },
          label: {
            type: hn
          },
          url: {
            type: rs
          },
          linkKind: {
            type: hn,
            defaultValue: Ml,
            oneOf: wM
          },
          // ACTION_KIND_EMAIL
          emailAddress: {
            type: c1,
            isHidden: !1
          },
          // ACTION_KIND_CALL, ACTION_KIND_SMS
          phoneNumber: {
            type: m1,
            isHidden: !1
          },
          // ACTION_KIND_DOWNLOAD
          attachments: {
            type: ea,
            items: {
              type: sa,
              attributes: {
                uploadId: {
                  type: Xn
                },
                fileName: {
                  type: hn,
                  required: !0
                }
              }
            }
          },
          // ACTION_KIND_CALENDAR
          start: {
            type: fr,
            isHidden: !1
          },
          end: {
            type: fr,
            isHidden: !1
          },
          // ACTION_KIND_OPEN_THING
          thingId: {
            type: Xn,
            isHidden: !1
          },
          // ACTION_KIND_OPEN_CAMPAIGN
          campaignId: {
            type: Xn,
            isHidden: !1
          }
        }
      }
    }
  }
}, E1 = {
  type: Oa,
  inline: !0,
  attributes: {
    targetThingId: {
      type: Xn
    },
    campaignId: {
      type: Xn
    }
  }
}, T1 = {
  type: Oa,
  inline: !0,
  attributes: {
    source: Zu,
    matteSource: Zu,
    loop: {
      type: ta
    },
    environmentPreset: {
      type: hn,
      oneOf: id
    }
  }
}, Fi = {
  name: "Card",
  type: sa,
  attributes: Yr(Da(Yr(Da({
    id: {
      type: Xn,
      isHidden: !0
    },
    isArchived: {
      type: ta,
      isHidden: !0
    },
    cardType: {
      type: hn,
      required: !0,
      isHidden: !0,
      oneOf: _L
    },
    folderId: {
      type: Xn
    }
  }, Ja(mc, {
    caption: {
      required: {
        $set: !0
      }
    }
  })), {
    displayCardInformation: {
      type: ta,
      defaultValue: !1
    },
    cardInformationOrientation: {
      type: hn,
      oneOf: RL
    }
  }), Vh), {
    payload: {
      type: Oa,
      attributes: {},
      isHidden: !0,
      required: !0
    },
    createdAt: {
      type: fr,
      isHidden: !0,
      required: !0
    },
    updatedAt: {
      type: fr,
      isHidden: !0,
      required: !0
    },
    lastModifiedById: {
      type: Xn,
      isHidden: !0
    },
    lastModifiedByIP: {
      type: hn,
      isHidden: !0
    },
    createdById: {
      type: Xn,
      isHidden: !0
    },
    thingIds: {
      type: ea,
      items: {
        type: Xn
      },
      isHidden: !0
    },
    createdByIP: {
      type: hn,
      isHidden: !0
    }
  })
};
Ja(Fi, {
  name: { $set: "ImageCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: $b
      }
    },
    imageBackground: {
      isHidden: { $set: !0 }
    },
    videoBackground: {
      isHidden: { $set: !0 }
    },
    payload: { $set: p1 }
  }
});
Ja(Fi, {
  name: { $set: "VideoCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: t0
      }
    },
    imageBackground: {
      isHidden: { $set: !0 }
    },
    videoBackground: {
      isHidden: { $set: !0 }
    },
    payload: { $set: y1 }
  }
});
Ja(Fi, {
  name: { $set: "HandTrackingCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: e0
      }
    },
    payload: { $set: f1 }
  }
});
Ja(Fi, {
  name: { $set: "ModelCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: n0
      }
    },
    payload: { $set: I1 }
  }
});
Ja(Fi, {
  name: { $set: "EmbedCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: a0
      }
    },
    colors: {
      isHidden: { $set: !0 }
    },
    imageBackground: {
      isHidden: { $set: !0 }
    },
    videoBackground: {
      isHidden: { $set: !0 }
    },
    payload: { $set: h1 }
  }
});
Ja(Fi, {
  name: { $set: "SocialMediaCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: i0
      }
    },
    payload: { $set: C1 }
  }
});
Ja(Fi, {
  name: { $set: "ChromaKeyVideoCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: r0
      }
    },
    payload: { $set: A1 }
  }
});
Ja(Fi, {
  name: { $set: "MultiMediaCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: s0
      }
    },
    payload: { $set: b1 }
  }
});
Ja(Fi, {
  name: { $set: "VolumetricVideoCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: o0
      }
    },
    payload: { $set: _1 }
  }
});
Ja(Fi, {
  name: { $set: "RichTextCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: l0
      }
    },
    payload: { $set: S1 }
  }
});
Ja(Fi, {
  name: { $set: "CampaignCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: u0
      }
    },
    payload: { $set: w1 }
  }
});
Ja(Fi, {
  name: { $set: "ActionsCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: d0
      }
    },
    payload: { $set: v1 }
  }
});
Ja(Fi, {
  name: { $set: "ThingCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: g0
      }
    },
    payload: { $set: E1 }
  }
});
Ja(Fi, {
  name: { $set: "MatteVideoCard" },
  attributes: {
    cardType: {
      defaultValue: {
        $set: c0
      }
    },
    payload: { $set: T1 }
  }
});
const k1 = {
  type: Oa,
  inline: !0,
  attributes: {
    avatar: Nl,
    links: {
      type: ea,
      inline: !0,
      items: {
        type: sa,
        attributes: {
          kind: {
            type: hn,
            required: !0,
            defaultValue: Ml,
            oneOf: [
              Gh,
              zh,
              Yh,
              Hh,
              Ml,
              Ph,
              Fh,
              Oh
            ]
          },
          label: {
            type: hn,
            required: !0
          },
          url: {
            type: rs,
            required: !0
          },
          iconUploadId: {
            type: Xn,
            isHidden: !0
          }
        }
      }
    },
    tabs: {
      type: ea,
      inline: !0,
      items: {
        type: sa,
        attributes: {
          thingId: {
            type: Xn
          },
          iconSourceUploadId: {
            type: Xn
          },
          iconName: {
            type: hn
          },
          label: {
            type: hn
          },
          isActive: {
            type: ta,
            defaultValue: !0
          }
        }
      }
    }
  }
}, L1 = {
  type: Oa,
  attributes: {
    budget: {
      type: hn
    },
    timeline: {
      type: hn
    },
    creativeBrief: {
      type: hn
    },
    projectName: {
      type: hn
    },
    metadata: {
      type: sa,
      attributes: {
        calledPhoneNumber: {
          type: hn
        },
        callId: {
          type: hn
        },
        phoneNumber: {
          type: hn
        }
      }
    },
    contactInformation: {
      type: sa,
      attributes: {
        email: {
          type: hn
        },
        fullName: {
          type: hn
        },
        pointOfContact: {
          type: sa,
          attributes: {
            email: {
              type: hn
            },
            fullName: {
              type: hn
            },
            phoneNumber: {
              type: hn
            }
          }
        }
      }
    }
  }
}, Wh = {
  name: "Page",
  type: sa,
  attributes: Yr(Da(Da({
    id: {
      type: Xn,
      isHidden: !0
    },
    isArchived: {
      type: ta,
      isHidden: !0
    },
    isSFW: {
      type: ta,
      defaultValue: !0
    },
    publishedState: {
      type: hn,
      oneOf: [dy, _M],
      defaultValue: dy
    },
    slug: {
      type: hn,
      isHidden: !0
    },
    viewCount: {
      type: ja,
      isHidden: !0,
      required: !0,
      defaultValue: 0
    },
    shareCount: {
      type: ja,
      isHidden: !0,
      required: !0,
      defaultValue: 0
    },
    favoritesCount: {
      type: ja,
      isHidden: !0,
      required: !0,
      defaultValue: 0
    },
    purchaseCount: {
      type: ja,
      isHidden: !0,
      required: !0,
      defaultValue: 0
    },
    purchaseTotal: {
      type: ja,
      isHidden: !0,
      required: !0,
      defaultValue: 0
    }
  }, mc), Ja(Vh, {
    colors: {
      attributes: {
        $unset: ["borderColor"]
      }
    }
  })), {
    openGraphImageUploadId: {
      type: Xn
    },
    price: {
      type: ja,
      min: {
        value: 50,
        message: "Price must be larger than $0.50"
      }
    },
    currency: {
      type: hn,
      defaultValue: "usd",
      isHidden: !0,
      pattern: {
        value: /^usd$/,
        message: 'Currency must be "usd"'
      }
    },
    parentPageId: {
      type: Xn
    },
    pageType: {
      type: hn,
      oneOf: [f0, bM, h0]
    },
    pagePath: {
      type: hn,
      pattern: /^\//,
      required: !0
    },
    payload: {
      type: Oa,
      attributes: {},
      isHidden: !0,
      required: !0
    },
    things: {
      type: ea,
      items: {
        type: sa,
        attributes: {
          thingId: {
            type: Xn,
            required: !0
          },
          isLocked: {
            type: ta,
            isHidden: !0
          },
          isActive: {
            type: ta
          }
        }
      }
    },
    filters: {
      type: ea,
      items: {
        type: sa,
        attributes: {
          name: {
            type: hn
          },
          definition: {
            // TODO: Support for arbitrary JSON
            type: Oa,
            attributes: {}
          }
        }
      }
    },
    order: {
      type: ja,
      isHidden: !0
    },
    extendedInformation: {
      type: Oa,
      attributes: {}
    },
    generatedSummary: {
      type: hn,
      isDisabled: !0
    },
    createdAt: {
      type: fr
    },
    updatedAt: {
      type: fr
    },
    publishedAt: {
      type: fr
    },
    lastModifiedById: {
      type: Xn,
      isHidden: !0
    },
    lastModifiedByIP: {
      type: hn,
      isHidden: !0
    },
    createdById: {
      type: hn,
      isHidden: !0,
      isDisabled: !0
    },
    createdByIP: {
      type: hn,
      isHidden: !0,
      isDisabled: !0
    },
    source: {
      type: hn,
      isHidden: !0,
      isDisabled: !0
    },
    sourceId: {
      type: hn,
      isHidden: !0,
      isDisabled: !0
    }
  })
};
Ja(Wh, {
  name: { $set: "CampaignPage" },
  attributes: {
    pageType: {
      defaultValue: {
        $set: h0
      }
    },
    payload: {
      $set: k1
    }
  }
});
Ja(Wh, {
  name: { $set: "ThingsGalleryPage" },
  attributes: {
    pageType: {
      defaultValue: {
        $set: f0
      }
    }
  }
});
Ja(Wh, {
  name: { $set: "CreativeBriefPage" },
  attributes: {
    pageType: {
      defaultValue: {
        $set: SM
      }
    },
    slug: {
      defaultValue: {
        $set: "creative-brief"
      }
    },
    extendedInformation: {
      $set: L1
    },
    source: {
      defaultValue: {
        $set: sM
      }
    }
  }
});
Yr(Da(Yr(Da({
  id: {
    type: Xn,
    isHidden: !0
  },
  schemaOrgType: {
    type: hn,
    isDisabled: !0,
    defaultValue: "Thing"
  },
  folderId: {
    type: Xn
  },
  isArchived: {
    type: ta,
    isHidden: !0
  },
  isSFW: {
    type: ta,
    defaultValue: !0
  },
  slug: {
    type: hn,
    isHidden: !0
  },
  viewCount: {
    type: ja,
    isHidden: !0,
    required: !0,
    defaultValue: 0
  },
  shareCount: {
    type: ja,
    isHidden: !0,
    required: !0,
    defaultValue: 0
  },
  purchaseCount: {
    type: ja,
    isHidden: !0,
    required: !0,
    defaultValue: 0
  },
  favoritesCount: {
    type: ja,
    isHidden: !0,
    required: !0,
    defaultValue: 0
  },
  purchaseTotal: {
    type: ja,
    isHidden: !0,
    required: !0,
    defaultValue: 0
  }
}, Ja(mc, {
  caption: {
    required: {
      $set: !0
    }
  }
})), {
  permissions: {
    type: sa,
    inline: !0,
    required: !0,
    attributes: {
      allowShare: {
        type: ta,
        defaultValue: !0
      },
      allowSave: {
        type: ta,
        defaultValue: !0
      }
    }
  },
  paymentProvider: {
    type: hn,
    oneOf: [hM, pM]
  },
  price: {
    type: ja,
    min: {
      value: 50,
      message: "Price must be larger than $0.50"
    }
  },
  currency: {
    type: hn,
    defaultValue: "usd",
    pattern: {
      value: /^usd$/,
      message: 'Currency must be "usd"'
    }
  },
  balance: {
    type: ka
  }
}), Ja(Vh, {
  colors: {
    attributes: {
      background: {
        defaultValue: {
          $set: "#222222"
        }
      },
      primary: {
        defaultValue: {
          $set: "#fafafa"
        }
      }
    }
  }
})), {
  openGraphImageUploadId: {
    type: Xn
  },
  shapePreset: {
    type: hn,
    oneOf: fM
  },
  shapeOptions: {
    type: Oa,
    isHidden: !0,
    attributes: {
      environmentPreset: {
        type: hn,
        oneOf: id,
        defaultValue: "PureSky"
      },
      keepThingClosed: {
        type: ta,
        defaultValue: !1
      },
      autoRotate: {
        type: ta,
        defaultValue: !1
      },
      environmentPresetOptions: {
        type: sa,
        isNew: !0,
        attributes: {
          color: {
            type: sa,
            attributes: {
              backgroundColor: {
                type: Zi,
                defaultValue: "#00ff00"
              }
            }
          },
          gradient: {
            type: sa,
            attributes: {
              topColor: {
                type: Zi,
                defaultValue: "#000022"
              },
              bottomColor: {
                type: Zi,
                defaultValue: "#ffffff"
              },
              displayStars: {
                type: ta,
                defaultValue: !0
              }
            }
          }
        }
      },
      // If SHAPE_PRESET_CYLINDER
      radiusTop: {
        type: ka,
        defaultValue: 0.5
      },
      radiusBottom: {
        type: ka,
        defaultValue: 0.5
      },
      // If SHAPE_PRESET_CONE or SHAPE_PRESET_TORUS
      radius: {
        type: ka,
        defaultValue: 1
      },
      radialSegments: {
        type: ja,
        defaultValue: 32
      },
      // If SHAPE_PRESET_CYLINDER, SHAPE_PRESET_CONE
      height: {
        type: ka,
        defaultValue: 1
      },
      // If SHAPE_PRESET_TORUS
      tube: {
        type: ka,
        defaultValue: 0.25
      },
      openEnded: {
        type: ta,
        defaultValue: !1
      }
    }
  },
  cards: {
    type: ea,
    items: {
      type: sa,
      attributes: {
        cardId: {
          type: Xn
        },
        isActive: {
          type: ta,
          defaultValue: !1
        },
        isLocked: {
          type: ta,
          defaultValue: !1
        },
        isCenterCard: {
          type: ta,
          defaultValue: !1
        },
        isShareCard: {
          type: ta,
          defaultValue: !1
        },
        isPreviewCard: {
          type: ta,
          defaultValue: !1
        }
      }
    },
    required: !0
  },
  origins: {
    type: ea,
    items: {
      type: sa,
      attributes: {
        name: {
          type: hn,
          defaultValue: "Allow all Origins (Default)"
        },
        payload: {
          type: Oa,
          attributes: {
            host: {
              type: hn,
              defaultValue: "*"
            },
            defaultMode: {
              type: hn,
              oneOf: [gy, LM, DM, RM, MM],
              defaultValue: gy
            }
          }
        }
      }
    },
    required: !0
  },
  publishedState: {
    type: hn,
    oneOf: [
      uy,
      AM
    ],
    defaultValue: uy
  },
  location: {
    type: sa,
    required: !0,
    isHidden: !0,
    attributes: {
      lat: {
        type: ka,
        defaultValue: 0,
        required: !0
      },
      lon: {
        type: ka,
        defaultValue: 0,
        required: !0
      }
    }
  },
  labels: {
    type: ea,
    items: {
      type: sa,
      attributes: {
        type: {
          type: hn,
          label: JM,
          oneOf: [CM, yM, IM]
        },
        value: {
          label: QM,
          type: hn
        }
      }
    }
  },
  createdAt: {
    type: fr
  },
  updatedAt: {
    type: fr
  },
  publishedAt: {
    type: fr
  },
  lastModifiedById: {
    type: Xn,
    isHidden: !0
  },
  lastModifiedByIP: {
    type: hn,
    isHidden: !0
  },
  createdById: {
    type: Xn,
    isHidden: !0
  },
  createdByIP: {
    type: hn,
    isHidden: !0
  },
  uploadIds: {
    type: ea,
    isHidden: !0,
    items: {
      type: Xn
    }
  },
  pageIds: {
    type: ea,
    isHidden: !0,
    items: {
      type: Xn
    }
  }
});
Yr(Da({
  id: {
    type: Xn,
    isHidden: !0
  },
  createdAt: {
    type: fr
  },
  updatedAt: {
    type: fr
  },
  lastModifiedById: {
    type: Xn,
    isHidden: !0
  },
  lastModifiedByIP: {
    type: hn,
    isHidden: !0
  },
  uploadType: {
    type: hn,
    oneOf: rM
  },
  isIcon: {
    type: ta
  },
  isDerived: {
    type: ta
  },
  thumbnailUrl: {
    type: rs
  },
  posterUrls: {
    type: ea,
    defaultValue: [],
    items: {
      type: rs
    }
  },
  cdnUrl: {
    type: rs
  },
  streamUrl: {
    type: rs
  },
  cdnPrefix: {
    type: hn,
    isHidden: !0
  },
  preview: {
    type: hn,
    isHidden: !0
  },
  colors: {
    type: ea,
    items: {
      type: Zi
    }
  },
  folderId: {
    type: Xn,
    isHidden: !0
  },
  state: {
    type: hn
  }
}, mc), {
  generatedSummary: {
    type: Kh,
    isDisabled: !0
  },
  fileName: {
    type: hn
  },
  mimeType: {
    type: hn
  },
  size: {
    type: ja
  },
  width: {
    type: ja
  },
  height: {
    type: ja
  },
  duration: {
    type: ka
  },
  primaryH: {
    type: ka,
    isHidden: !0
  },
  primaryS: {
    type: ka,
    isHidden: !0
  },
  primaryL: {
    type: ka,
    isHidden: !0
  },
  thingIds: {
    type: ea,
    items: {
      type: Xn
    }
  },
  cardIds: {
    type: ea,
    items: {
      type: Xn
    }
  },
  pageIds: {
    type: ea,
    isHidden: !0,
    items: {
      type: Xn
    }
  },
  error: {
    type: hn,
    isHidden: !0
  },
  createdById: {
    type: Xn,
    isHidden: !0
  },
  createdByIP: {
    type: hn,
    isHidden: !0
  },
  source: {
    type: hn,
    isHidden: !0,
    isDisabled: !0
  },
  sourceId: {
    type: hn,
    isHidden: !0,
    isDisabled: !0
  }
});
var M1 = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(t) {
  (function() {
    var e = {}.hasOwnProperty;
    function r() {
      for (var E = "", k = 0; k < arguments.length; k++) {
        var g = arguments[k];
        g && (E = I(E, u(g)));
      }
      return E;
    }
    function u(E) {
      if (typeof E == "string" || typeof E == "number")
        return E;
      if (typeof E != "object")
        return "";
      if (Array.isArray(E))
        return r.apply(null, E);
      if (E.toString !== Object.prototype.toString && !E.toString.toString().includes("[native code]"))
        return E.toString();
      var k = "";
      for (var g in E)
        e.call(E, g) && E[g] && (k = I(k, g));
      return k;
    }
    function I(E, k) {
      return k ? E ? E + " " + k : E + k : E;
    }
    t.exports ? (r.default = r, t.exports = r) : window.classNames = r;
  })();
})(M1);
var jh = { exports: {} }, A0 = {}, _0 = { exports: {} }, ym, hy;
function R1() {
  if (hy)
    return ym;
  hy = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return ym = t, ym;
}
var Am, py;
function D1() {
  if (py)
    return Am;
  py = 1;
  var t = R1();
  function e() {
  }
  function r() {
  }
  return r.resetWarningCache = e, Am = function() {
    function u(k, g, w, B, c, d) {
      if (d !== t) {
        var m = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw m.name = "Invariant Violation", m;
      }
    }
    u.isRequired = u;
    function I() {
      return u;
    }
    var E = {
      array: u,
      bigint: u,
      bool: u,
      func: u,
      number: u,
      object: u,
      string: u,
      symbol: u,
      any: u,
      arrayOf: I,
      element: u,
      elementType: u,
      instanceOf: I,
      node: u,
      objectOf: I,
      oneOf: I,
      oneOfType: I,
      shape: I,
      exact: I,
      checkPropTypes: r,
      resetWarningCache: e
    };
    return E.PropTypes = E, E;
  }, Am;
}
_0.exports = D1()();
var Xa = _0.exports;
function b0(t) {
  var e, r, u = "";
  if (typeof t == "string" || typeof t == "number")
    u += t;
  else if (typeof t == "object")
    if (Array.isArray(t))
      for (e = 0; e < t.length; e++)
        t[e] && (r = b0(t[e])) && (u && (u += " "), u += r);
    else
      for (e in t)
        t[e] && (u && (u += " "), u += e);
  return u;
}
function Iy() {
  for (var t, e, r = 0, u = ""; r < arguments.length; )
    (t = arguments[r++]) && (e = b0(t)) && (u && (u += " "), u += e);
  return u;
}
const B1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: Iy,
  default: Iy
}, Symbol.toStringTag, { value: "Module" })), x1 = /* @__PURE__ */ NM(B1);
var Ua = {}, Xr = {};
Object.defineProperty(Xr, "__esModule", {
  value: !0
});
Xr.dontSetMe = H1;
Xr.findInArray = N1;
Xr.int = Y1;
Xr.isFunction = G1;
Xr.isNum = z1;
function N1(t, e) {
  for (let r = 0, u = t.length; r < u; r++)
    if (e.apply(e, [t[r], r, t]))
      return t[r];
}
function G1(t) {
  return typeof t == "function" || Object.prototype.toString.call(t) === "[object Function]";
}
function z1(t) {
  return typeof t == "number" && !isNaN(t);
}
function Y1(t) {
  return parseInt(t, 10);
}
function H1(t, e, r) {
  if (t[e])
    return new Error("Invalid prop ".concat(e, " passed to ").concat(r, " - do not set this, set it on the child."));
}
var ko = {};
Object.defineProperty(ko, "__esModule", {
  value: !0
});
ko.browserPrefixToKey = w0;
ko.browserPrefixToStyle = P1;
ko.default = void 0;
ko.getPrefix = S0;
const _m = ["Moz", "Webkit", "O", "ms"];
function S0() {
  var t;
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "transform";
  if (typeof window > "u")
    return "";
  const r = (t = window.document) === null || t === void 0 || (t = t.documentElement) === null || t === void 0 ? void 0 : t.style;
  if (!r || e in r)
    return "";
  for (let u = 0; u < _m.length; u++)
    if (w0(e, _m[u]) in r)
      return _m[u];
  return "";
}
function w0(t, e) {
  return e ? "".concat(e).concat(F1(t)) : t;
}
function P1(t, e) {
  return e ? "-".concat(e.toLowerCase(), "-").concat(t) : t;
}
function F1(t) {
  let e = "", r = !0;
  for (let u = 0; u < t.length; u++)
    r ? (e += t[u].toUpperCase(), r = !1) : t[u] === "-" ? r = !0 : e += t[u];
  return e;
}
ko.default = S0();
Object.defineProperty(Ua, "__esModule", {
  value: !0
});
Ua.addClassName = T0;
Ua.addEvent = K1;
Ua.addUserSelectStyles = eR;
Ua.createCSSTransform = Q1;
Ua.createSVGTransform = q1;
Ua.getTouch = $1;
Ua.getTouchIdentifier = tR;
Ua.getTranslation = Zh;
Ua.innerHeight = j1;
Ua.innerWidth = Z1;
Ua.matchesSelector = E0;
Ua.matchesSelectorAndParentsTo = U1;
Ua.offsetXYFromParent = J1;
Ua.outerHeight = X1;
Ua.outerWidth = W1;
Ua.removeClassName = k0;
Ua.removeEvent = V1;
Ua.removeUserSelectStyles = nR;
var Qi = Xr, Cy = O1(ko);
function v0(t) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (v0 = function(u) {
    return u ? r : e;
  })(t);
}
function O1(t, e) {
  if (t && t.__esModule)
    return t;
  if (t === null || typeof t != "object" && typeof t != "function")
    return { default: t };
  var r = v0(e);
  if (r && r.has(t))
    return r.get(t);
  var u = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var E in t)
    if (E !== "default" && Object.prototype.hasOwnProperty.call(t, E)) {
      var k = I ? Object.getOwnPropertyDescriptor(t, E) : null;
      k && (k.get || k.set) ? Object.defineProperty(u, E, k) : u[E] = t[E];
    }
  return u.default = t, r && r.set(t, u), u;
}
let eg = "";
function E0(t, e) {
  return eg || (eg = (0, Qi.findInArray)(["matches", "webkitMatchesSelector", "mozMatchesSelector", "msMatchesSelector", "oMatchesSelector"], function(r) {
    return (0, Qi.isFunction)(t[r]);
  })), (0, Qi.isFunction)(t[eg]) ? t[eg](e) : !1;
}
function U1(t, e, r) {
  let u = t;
  do {
    if (E0(u, e))
      return !0;
    if (u === r)
      return !1;
    u = u.parentNode;
  } while (u);
  return !1;
}
function K1(t, e, r, u) {
  if (!t)
    return;
  const I = Da({
    capture: !0
  }, u);
  t.addEventListener ? t.addEventListener(e, r, I) : t.attachEvent ? t.attachEvent("on" + e, r) : t["on" + e] = r;
}
function V1(t, e, r, u) {
  if (!t)
    return;
  const I = Da({
    capture: !0
  }, u);
  t.removeEventListener ? t.removeEventListener(e, r, I) : t.detachEvent ? t.detachEvent("on" + e, r) : t["on" + e] = null;
}
function X1(t) {
  let e = t.clientHeight;
  const r = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += (0, Qi.int)(r.borderTopWidth), e += (0, Qi.int)(r.borderBottomWidth), e;
}
function W1(t) {
  let e = t.clientWidth;
  const r = t.ownerDocument.defaultView.getComputedStyle(t);
  return e += (0, Qi.int)(r.borderLeftWidth), e += (0, Qi.int)(r.borderRightWidth), e;
}
function j1(t) {
  let e = t.clientHeight;
  const r = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= (0, Qi.int)(r.paddingTop), e -= (0, Qi.int)(r.paddingBottom), e;
}
function Z1(t) {
  let e = t.clientWidth;
  const r = t.ownerDocument.defaultView.getComputedStyle(t);
  return e -= (0, Qi.int)(r.paddingLeft), e -= (0, Qi.int)(r.paddingRight), e;
}
function J1(t, e, r) {
  const u = e === e.ownerDocument.body ? {
    left: 0,
    top: 0
  } : e.getBoundingClientRect(), I = (t.clientX + e.scrollLeft - u.left) / r, E = (t.clientY + e.scrollTop - u.top) / r;
  return {
    x: I,
    y: E
  };
}
function Q1(t, e) {
  const r = Zh(t, e, "px");
  return {
    [(0, Cy.browserPrefixToKey)("transform", Cy.default)]: r
  };
}
function q1(t, e) {
  return Zh(t, e, "");
}
function Zh(t, e, r) {
  let {
    x: u,
    y: I
  } = t, E = "translate(".concat(u).concat(r, ",").concat(I).concat(r, ")");
  if (e) {
    const k = "".concat(typeof e.x == "string" ? e.x : e.x + r), g = "".concat(typeof e.y == "string" ? e.y : e.y + r);
    E = "translate(".concat(k, ", ").concat(g, ")") + E;
  }
  return E;
}
function $1(t, e) {
  return t.targetTouches && (0, Qi.findInArray)(t.targetTouches, (r) => e === r.identifier) || t.changedTouches && (0, Qi.findInArray)(t.changedTouches, (r) => e === r.identifier);
}
function tR(t) {
  if (t.targetTouches && t.targetTouches[0])
    return t.targetTouches[0].identifier;
  if (t.changedTouches && t.changedTouches[0])
    return t.changedTouches[0].identifier;
}
function eR(t) {
  if (!t)
    return;
  let e = t.getElementById("react-draggable-style-el");
  e || (e = t.createElement("style"), e.type = "text/css", e.id = "react-draggable-style-el", e.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, e.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, t.getElementsByTagName("head")[0].appendChild(e)), t.body && T0(t.body, "react-draggable-transparent-selection");
}
function nR(t) {
  if (t)
    try {
      if (t.body && k0(t.body, "react-draggable-transparent-selection"), t.selection)
        t.selection.empty();
      else {
        const e = (t.defaultView || window).getSelection();
        e && e.type !== "Caret" && e.removeAllRanges();
      }
    } catch (e) {
    }
}
function T0(t, e) {
  t.classList ? t.classList.add(e) : t.className.match(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"))) || (t.className += " ".concat(e));
}
function k0(t, e) {
  t.classList ? t.classList.remove(e) : t.className = t.className.replace(new RegExp("(?:^|\\s)".concat(e, "(?!\\S)"), "g"), "");
}
var Wr = {};
Object.defineProperty(Wr, "__esModule", {
  value: !0
});
Wr.canDragX = rR;
Wr.canDragY = sR;
Wr.createCoreData = lR;
Wr.createDraggableData = uR;
Wr.getBoundPosition = aR;
Wr.getControlPosition = oR;
Wr.snapToGrid = iR;
var Xi = Xr, fl = Ua;
function aR(t, e, r) {
  if (!t.props.bounds)
    return [e, r];
  let {
    bounds: u
  } = t.props;
  u = typeof u == "string" ? u : dR(u);
  const I = Jh(t);
  if (typeof u == "string") {
    const {
      ownerDocument: E
    } = I, k = E.defaultView;
    let g;
    if (u === "parent" ? g = I.parentNode : g = E.querySelector(u), !(g instanceof k.HTMLElement))
      throw new Error('Bounds selector "' + u + '" could not find an element.');
    const w = g, B = k.getComputedStyle(I), c = k.getComputedStyle(w);
    u = {
      left: -I.offsetLeft + (0, Xi.int)(c.paddingLeft) + (0, Xi.int)(B.marginLeft),
      top: -I.offsetTop + (0, Xi.int)(c.paddingTop) + (0, Xi.int)(B.marginTop),
      right: (0, fl.innerWidth)(w) - (0, fl.outerWidth)(I) - I.offsetLeft + (0, Xi.int)(c.paddingRight) - (0, Xi.int)(B.marginRight),
      bottom: (0, fl.innerHeight)(w) - (0, fl.outerHeight)(I) - I.offsetTop + (0, Xi.int)(c.paddingBottom) - (0, Xi.int)(B.marginBottom)
    };
  }
  return (0, Xi.isNum)(u.right) && (e = Math.min(e, u.right)), (0, Xi.isNum)(u.bottom) && (r = Math.min(r, u.bottom)), (0, Xi.isNum)(u.left) && (e = Math.max(e, u.left)), (0, Xi.isNum)(u.top) && (r = Math.max(r, u.top)), [e, r];
}
function iR(t, e, r) {
  const u = Math.round(e / t[0]) * t[0], I = Math.round(r / t[1]) * t[1];
  return [u, I];
}
function rR(t) {
  return t.props.axis === "both" || t.props.axis === "x";
}
function sR(t) {
  return t.props.axis === "both" || t.props.axis === "y";
}
function oR(t, e, r) {
  const u = typeof e == "number" ? (0, fl.getTouch)(t, e) : null;
  if (typeof e == "number" && !u)
    return null;
  const I = Jh(r), E = r.props.offsetParent || I.offsetParent || I.ownerDocument.body;
  return (0, fl.offsetXYFromParent)(u || t, E, r.props.scale);
}
function lR(t, e, r) {
  const u = !(0, Xi.isNum)(t.lastX), I = Jh(t);
  return u ? {
    node: I,
    deltaX: 0,
    deltaY: 0,
    lastX: e,
    lastY: r,
    x: e,
    y: r
  } : {
    node: I,
    deltaX: e - t.lastX,
    deltaY: r - t.lastY,
    lastX: t.lastX,
    lastY: t.lastY,
    x: e,
    y: r
  };
}
function uR(t, e) {
  const r = t.props.scale;
  return {
    node: e.node,
    x: t.state.x + e.deltaX / r,
    y: t.state.y + e.deltaY / r,
    deltaX: e.deltaX / r,
    deltaY: e.deltaY / r,
    lastX: t.state.x,
    lastY: t.state.y
  };
}
function dR(t) {
  return {
    left: t.left,
    top: t.top,
    right: t.right,
    bottom: t.bottom
  };
}
function Jh(t) {
  const e = t.findDOMNode();
  if (!e)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return e;
}
var fc = {}, hc = {};
Object.defineProperty(hc, "__esModule", {
  value: !0
});
hc.default = gR;
function gR() {
}
Object.defineProperty(fc, "__esModule", {
  value: !0
});
fc.default = void 0;
var bm = mR(Qu), xi = Qh(Xa), cR = Qh(qb), hi = Ua, Ms = Wr, Sm = Xr, fu = Qh(hc);
function Qh(t) {
  return t && t.__esModule ? t : { default: t };
}
function L0(t) {
  if (typeof WeakMap != "function")
    return null;
  var e = /* @__PURE__ */ new WeakMap(), r = /* @__PURE__ */ new WeakMap();
  return (L0 = function(u) {
    return u ? r : e;
  })(t);
}
function mR(t, e) {
  if (t && t.__esModule)
    return t;
  if (t === null || typeof t != "object" && typeof t != "function")
    return { default: t };
  var r = L0(e);
  if (r && r.has(t))
    return r.get(t);
  var u = {}, I = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var E in t)
    if (E !== "default" && Object.prototype.hasOwnProperty.call(t, E)) {
      var k = I ? Object.getOwnPropertyDescriptor(t, E) : null;
      k && (k.get || k.set) ? Object.defineProperty(u, E, k) : u[E] = t[E];
    }
  return u.default = t, r && r.set(t, u), u;
}
function _i(t, e, r) {
  return e = fR(e), e in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
}
function fR(t) {
  var e = hR(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function hR(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var u = r.call(t, e || "default");
    if (typeof u != "object")
      return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
const wr = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let Rs = wr.mouse, pc = class extends bm.Component {
  constructor() {
    super(...arguments), _i(this, "dragging", !1), _i(this, "lastX", NaN), _i(this, "lastY", NaN), _i(this, "touchIdentifier", null), _i(this, "mounted", !1), _i(this, "handleDragStart", (t) => {
      if (this.props.onMouseDown(t), !this.props.allowAnyClick && typeof t.button == "number" && t.button !== 0)
        return !1;
      const e = this.findDOMNode();
      if (!e || !e.ownerDocument || !e.ownerDocument.body)
        throw new Error("<DraggableCore> not mounted on DragStart!");
      const {
        ownerDocument: r
      } = e;
      if (this.props.disabled || !(t.target instanceof r.defaultView.Node) || this.props.handle && !(0, hi.matchesSelectorAndParentsTo)(t.target, this.props.handle, e) || this.props.cancel && (0, hi.matchesSelectorAndParentsTo)(t.target, this.props.cancel, e))
        return;
      t.type === "touchstart" && t.preventDefault();
      const u = (0, hi.getTouchIdentifier)(t);
      this.touchIdentifier = u;
      const I = (0, Ms.getControlPosition)(t, u, this);
      if (I == null)
        return;
      const {
        x: E,
        y: k
      } = I, g = (0, Ms.createCoreData)(this, E, k);
      (0, fu.default)("DraggableCore: handleDragStart: %j", g), (0, fu.default)("calling", this.props.onStart), !(this.props.onStart(t, g) === !1 || this.mounted === !1) && (this.props.enableUserSelectHack && (0, hi.addUserSelectStyles)(r), this.dragging = !0, this.lastX = E, this.lastY = k, (0, hi.addEvent)(r, Rs.move, this.handleDrag), (0, hi.addEvent)(r, Rs.stop, this.handleDragStop));
    }), _i(this, "handleDrag", (t) => {
      const e = (0, Ms.getControlPosition)(t, this.touchIdentifier, this);
      if (e == null)
        return;
      let {
        x: r,
        y: u
      } = e;
      if (Array.isArray(this.props.grid)) {
        let E = r - this.lastX, k = u - this.lastY;
        if ([E, k] = (0, Ms.snapToGrid)(this.props.grid, E, k), !E && !k)
          return;
        r = this.lastX + E, u = this.lastY + k;
      }
      const I = (0, Ms.createCoreData)(this, r, u);
      if ((0, fu.default)("DraggableCore: handleDrag: %j", I), this.props.onDrag(t, I) === !1 || this.mounted === !1) {
        try {
          this.handleDragStop(new MouseEvent("mouseup"));
        } catch (E) {
          const k = document.createEvent("MouseEvents");
          k.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), this.handleDragStop(k);
        }
        return;
      }
      this.lastX = r, this.lastY = u;
    }), _i(this, "handleDragStop", (t) => {
      if (!this.dragging)
        return;
      const e = (0, Ms.getControlPosition)(t, this.touchIdentifier, this);
      if (e == null)
        return;
      let {
        x: r,
        y: u
      } = e;
      if (Array.isArray(this.props.grid)) {
        let k = r - this.lastX || 0, g = u - this.lastY || 0;
        [k, g] = (0, Ms.snapToGrid)(this.props.grid, k, g), r = this.lastX + k, u = this.lastY + g;
      }
      const I = (0, Ms.createCoreData)(this, r, u);
      if (this.props.onStop(t, I) === !1 || this.mounted === !1)
        return !1;
      const E = this.findDOMNode();
      E && this.props.enableUserSelectHack && (0, hi.removeUserSelectStyles)(E.ownerDocument), (0, fu.default)("DraggableCore: handleDragStop: %j", I), this.dragging = !1, this.lastX = NaN, this.lastY = NaN, E && ((0, fu.default)("DraggableCore: Removing handlers"), (0, hi.removeEvent)(E.ownerDocument, Rs.move, this.handleDrag), (0, hi.removeEvent)(E.ownerDocument, Rs.stop, this.handleDragStop));
    }), _i(this, "onMouseDown", (t) => (Rs = wr.mouse, this.handleDragStart(t))), _i(this, "onMouseUp", (t) => (Rs = wr.mouse, this.handleDragStop(t))), _i(this, "onTouchStart", (t) => (Rs = wr.touch, this.handleDragStart(t))), _i(this, "onTouchEnd", (t) => (Rs = wr.touch, this.handleDragStop(t)));
  }
  componentDidMount() {
    this.mounted = !0;
    const t = this.findDOMNode();
    t && (0, hi.addEvent)(t, wr.touch.start, this.onTouchStart, {
      passive: !1
    });
  }
  componentWillUnmount() {
    this.mounted = !1;
    const t = this.findDOMNode();
    if (t) {
      const {
        ownerDocument: e
      } = t;
      (0, hi.removeEvent)(e, wr.mouse.move, this.handleDrag), (0, hi.removeEvent)(e, wr.touch.move, this.handleDrag), (0, hi.removeEvent)(e, wr.mouse.stop, this.handleDragStop), (0, hi.removeEvent)(e, wr.touch.stop, this.handleDragStop), (0, hi.removeEvent)(t, wr.touch.start, this.onTouchStart, {
        passive: !1
      }), this.props.enableUserSelectHack && (0, hi.removeUserSelectStyles)(e);
    }
  }
  // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
  // the underlying DOM node ourselves. See the README for more information.
  findDOMNode() {
    var t, e;
    return (t = this.props) !== null && t !== void 0 && t.nodeRef ? (e = this.props) === null || e === void 0 || (e = e.nodeRef) === null || e === void 0 ? void 0 : e.current : cR.default.findDOMNode(this);
  }
  render() {
    return /* @__PURE__ */ bm.cloneElement(bm.Children.only(this.props.children), {
      // Note: mouseMove handler is attached to document so it will still function
      // when the user drags quickly and leaves the bounds of the element.
      onMouseDown: this.onMouseDown,
      onMouseUp: this.onMouseUp,
      // onTouchStart is added on `componentDidMount` so they can be added with
      // {passive: false}, which allows it to cancel. See
      // https://developers.google.com/web/updates/2017/01/scrolling-intervention
      onTouchEnd: this.onTouchEnd
    });
  }
};
fc.default = pc;
_i(pc, "displayName", "DraggableCore");
_i(pc, "propTypes", {
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: xi.default.bool,
  children: xi.default.node.isRequired,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: xi.default.bool,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: xi.default.bool,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: function(t, e) {
    if (t[e] && t[e].nodeType !== 1)
      throw new Error("Draggable's offsetParent must be a DOM Node.");
  },
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: xi.default.arrayOf(xi.default.number),
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: xi.default.string,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: xi.default.string,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: xi.default.object,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: xi.default.func,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: xi.default.func,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: xi.default.func,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: xi.default.func,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: xi.default.number,
  /**
   * These properties should be defined on the child, not here.
   */
  className: Sm.dontSetMe,
  style: Sm.dontSetMe,
  transform: Sm.dontSetMe
});
_i(pc, "defaultProps", {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
});
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "DraggableCore", {
    enumerable: !0,
    get: function() {
      return w.default;
    }
  }), t.default = void 0;
  var e = m(Qu), r = c(Xa), u = c(qb), I = c(x1), E = Ua, k = Wr, g = Xr, w = c(fc), B = c(hc);
  function c(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function d(l) {
    if (typeof WeakMap != "function")
      return null;
    var h = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap();
    return (d = function(z) {
      return z ? p : h;
    })(l);
  }
  function m(l, h) {
    if (l && l.__esModule)
      return l;
    if (l === null || typeof l != "object" && typeof l != "function")
      return { default: l };
    var p = d(h);
    if (p && p.has(l))
      return p.get(l);
    var z = {}, Z = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var V in l)
      if (V !== "default" && Object.prototype.hasOwnProperty.call(l, V)) {
        var Q = Z ? Object.getOwnPropertyDescriptor(l, V) : null;
        Q && (Q.get || Q.set) ? Object.defineProperty(z, V, Q) : z[V] = l[V];
      }
    return z.default = l, p && p.set(l, z), z;
  }
  function b() {
    return b = Object.assign ? Object.assign.bind() : function(l) {
      for (var h = 1; h < arguments.length; h++) {
        var p = arguments[h];
        for (var z in p)
          Object.prototype.hasOwnProperty.call(p, z) && (l[z] = p[z]);
      }
      return l;
    }, b.apply(this, arguments);
  }
  function y(l, h, p) {
    return h = T(h), h in l ? Object.defineProperty(l, h, { value: p, enumerable: !0, configurable: !0, writable: !0 }) : l[h] = p, l;
  }
  function T(l) {
    var h = n(l, "string");
    return typeof h == "symbol" ? h : String(h);
  }
  function n(l, h) {
    if (typeof l != "object" || l === null)
      return l;
    var p = l[Symbol.toPrimitive];
    if (p !== void 0) {
      var z = p.call(l, h || "default");
      if (typeof z != "object")
        return z;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (h === "string" ? String : Number)(l);
  }
  class o extends e.Component {
    // React 16.3+
    // Arity (props, state)
    static getDerivedStateFromProps(h, p) {
      let {
        position: z
      } = h, {
        prevPropsPosition: Z
      } = p;
      return z && (!Z || z.x !== Z.x || z.y !== Z.y) ? ((0, B.default)("Draggable: getDerivedStateFromProps %j", {
        position: z,
        prevPropsPosition: Z
      }), {
        x: z.x,
        y: z.y,
        prevPropsPosition: Da({}, z)
      }) : null;
    }
    constructor(h) {
      super(h), y(this, "onDragStart", (p, z) => {
        if ((0, B.default)("Draggable: onDragStart: %j", z), this.props.onStart(p, (0, k.createDraggableData)(this, z)) === !1)
          return !1;
        this.setState({
          dragging: !0,
          dragged: !0
        });
      }), y(this, "onDrag", (p, z) => {
        if (!this.state.dragging)
          return !1;
        (0, B.default)("Draggable: onDrag: %j", z);
        const Z = (0, k.createDraggableData)(this, z), V = {
          x: Z.x,
          y: Z.y,
          slackX: 0,
          slackY: 0
        };
        if (this.props.bounds) {
          const {
            x: Q,
            y: vt
          } = V;
          V.x += this.state.slackX, V.y += this.state.slackY;
          const [Lt, zt] = (0, k.getBoundPosition)(this, V.x, V.y);
          V.x = Lt, V.y = zt, V.slackX = this.state.slackX + (Q - V.x), V.slackY = this.state.slackY + (vt - V.y), Z.x = V.x, Z.y = V.y, Z.deltaX = V.x - this.state.x, Z.deltaY = V.y - this.state.y;
        }
        if (this.props.onDrag(p, Z) === !1)
          return !1;
        this.setState(V);
      }), y(this, "onDragStop", (p, z) => {
        if (!this.state.dragging || this.props.onStop(p, (0, k.createDraggableData)(this, z)) === !1)
          return !1;
        (0, B.default)("Draggable: onDragStop: %j", z);
        const Z = {
          dragging: !1,
          slackX: 0,
          slackY: 0
        };
        if (this.props.position) {
          const {
            x: V,
            y: Q
          } = this.props.position;
          Z.x = V, Z.y = Q;
        }
        this.setState(Z);
      }), this.state = {
        // Whether or not we are currently dragging.
        dragging: !1,
        // Whether or not we have been dragged before.
        dragged: !1,
        // Current transform x and y.
        x: h.position ? h.position.x : h.defaultPosition.x,
        y: h.position ? h.position.y : h.defaultPosition.y,
        prevPropsPosition: Da({}, h.position),
        // Used for compensating for out-of-bounds drags
        slackX: 0,
        slackY: 0,
        // Can only determine if SVG after mounting
        isElementSVG: !1
      }, h.position && !(h.onDrag || h.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
    }
    componentDidMount() {
      typeof window.SVGElement < "u" && this.findDOMNode() instanceof window.SVGElement && this.setState({
        isElementSVG: !0
      });
    }
    componentWillUnmount() {
      this.setState({
        dragging: !1
      });
    }
    // React Strict Mode compatibility: if `nodeRef` is passed, we will use it instead of trying to find
    // the underlying DOM node ourselves. See the README for more information.
    findDOMNode() {
      var h, p;
      return (h = (p = this.props) === null || p === void 0 || (p = p.nodeRef) === null || p === void 0 ? void 0 : p.current) !== null && h !== void 0 ? h : u.default.findDOMNode(this);
    }
    render() {
      const Ce = this.props, {
        axis: h,
        bounds: p,
        children: z,
        defaultPosition: Z,
        defaultClassName: V,
        defaultClassNameDragging: Q,
        defaultClassNameDragged: vt,
        position: Lt,
        positionOffset: zt,
        scale: X
      } = Ce, D = GI(Ce, [
        "axis",
        "bounds",
        "children",
        "defaultPosition",
        "defaultClassName",
        "defaultClassNameDragging",
        "defaultClassNameDragged",
        "position",
        "positionOffset",
        "scale"
      ]);
      let yt = {}, Mt = null;
      const at = !Lt || this.state.dragging, Bt = Lt || Z, jt = {
        // Set left if horizontal drag is enabled
        x: (0, k.canDragX)(this) && at ? this.state.x : Bt.x,
        // Set top if vertical drag is enabled
        y: (0, k.canDragY)(this) && at ? this.state.y : Bt.y
      };
      this.state.isElementSVG ? Mt = (0, E.createSVGTransform)(jt, zt) : yt = (0, E.createCSSTransform)(jt, zt);
      const At = (0, I.default)(z.props.className || "", V, {
        [Q]: this.state.dragging,
        [vt]: this.state.dragged
      });
      return /* @__PURE__ */ e.createElement(w.default, b({}, D, {
        onStart: this.onDragStart,
        onDrag: this.onDrag,
        onStop: this.onDragStop
      }), /* @__PURE__ */ e.cloneElement(e.Children.only(z), {
        className: At,
        style: Da(Da({}, z.props.style), yt),
        transform: Mt
      }));
    }
  }
  t.default = o, y(o, "displayName", "Draggable"), y(o, "propTypes", Yr(Da({}, w.default.propTypes), {
    /**
     * `axis` determines which axis the draggable can move.
     *
     *  Note that all callbacks will still return data as normal. This only
     *  controls flushing to the DOM.
     *
     * 'both' allows movement horizontally and vertically.
     * 'x' limits movement to horizontal axis.
     * 'y' limits movement to vertical axis.
     * 'none' limits all movement.
     *
     * Defaults to 'both'.
     */
    axis: r.default.oneOf(["both", "x", "y", "none"]),
    /**
     * `bounds` determines the range of movement available to the element.
     * Available values are:
     *
     * 'parent' restricts movement within the Draggable's parent node.
     *
     * Alternatively, pass an object with the following properties, all of which are optional:
     *
     * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
     *
     * All values are in px.
     *
     * Example:
     *
     * ```jsx
     *   let App = React.createClass({
     *       render: function () {
     *         return (
     *            <Draggable bounds={{right: 300, bottom: 300}}>
     *              <div>Content</div>
     *           </Draggable>
     *         );
     *       }
     *   });
     * ```
     */
    bounds: r.default.oneOfType([r.default.shape({
      left: r.default.number,
      right: r.default.number,
      top: r.default.number,
      bottom: r.default.number
    }), r.default.string, r.default.oneOf([!1])]),
    defaultClassName: r.default.string,
    defaultClassNameDragging: r.default.string,
    defaultClassNameDragged: r.default.string,
    /**
     * `defaultPosition` specifies the x and y that the dragged item should start at
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable defaultPosition={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    defaultPosition: r.default.shape({
      x: r.default.number,
      y: r.default.number
    }),
    positionOffset: r.default.shape({
      x: r.default.oneOfType([r.default.number, r.default.string]),
      y: r.default.oneOfType([r.default.number, r.default.string])
    }),
    /**
     * `position`, if present, defines the current position of the element.
     *
     *  This is similar to how form elements in React work - if no `position` is supplied, the component
     *  is uncontrolled.
     *
     * Example:
     *
     * ```jsx
     *      let App = React.createClass({
     *          render: function () {
     *              return (
     *                  <Draggable position={{x: 25, y: 25}}>
     *                      <div>I start with transformX: 25px and transformY: 25px;</div>
     *                  </Draggable>
     *              );
     *          }
     *      });
     * ```
     */
    position: r.default.shape({
      x: r.default.number,
      y: r.default.number
    }),
    /**
     * These properties should be defined on the child, not here.
     */
    className: g.dontSetMe,
    style: g.dontSetMe,
    transform: g.dontSetMe
  })), y(o, "defaultProps", Yr(Da({}, w.default.defaultProps), {
    axis: "both",
    bounds: !1,
    defaultClassName: "react-draggable",
    defaultClassNameDragging: "react-draggable-dragging",
    defaultClassNameDragged: "react-draggable-dragged",
    defaultPosition: {
      x: 0,
      y: 0
    },
    scale: 1
  }));
})(A0);
const {
  default: M0,
  DraggableCore: pR
} = A0;
jh.exports = M0;
jh.exports.default = M0;
jh.exports.DraggableCore = pR;
Xa.func, Xa.func, Xa.string, Xa.oneOf(["always", "once", "never"]), Xa.oneOfType([Xa.func, Xa.object, Xa.string]), Xa.bool, Xa.oneOfType([Xa.func, Xa.object, Xa.string]), Xa.func, Xa.bool, Xa.string.isRequired, Xa.string, Xa.bool, Xa.oneOf(["div", "span", "svg"]);
let ng;
class IR {
  static load(e) {
    return ng = new URLSearchParams(document.location.search).get("debugGA"), new Promise((r, u) => {
      this.scriptSrc = e;
      const I = document.createElement("script");
      I.src = this.scriptSrc, I.async = !0, I.addEventListener("load", () => {
        const E = window.dataLayer || [];
        window.gtag = function() {
          E.push(arguments);
        }, gtag("js", /* @__PURE__ */ new Date()), ng === "1" ? gtag("config", "G-4ZZX8P4KL8", { debug_mode: !0 }) : gtag("config", "G-4ZZX8P4KL8"), r();
      }), I.addEventListener("error", () => {
        u(new Error("Failed to load analytics script."));
      }), document.head.appendChild(I);
    });
  }
  static sendEvent({
    eventName: e,
    eventData: r
  }) {
    window.gtag ? (window.gtag("event", e, r), ng === "1" && console.log("ANALYTICS:", e, r)) : ng === "1" && console.log("ANALYTICS: disabled");
  }
}
AL(IR, "scriptSrc");
const CR = "sequence", yR = (t) => {
  const e = new Error(t);
  return e.name = "InvalidStateError", e.code = 11, e;
};
class AR extends EventTarget {
  constructor(e) {
    super(), this.workerPool = null, this.timestampOffset = 0, this.mimeType = "application/octet-stream", this.mode = CR, this.updating = !1, this.buffered = [], this.timescale = 0, this.duration = 0, this.frameDuration = 0, this._isInitialized = !1, this.bytesReceived = 0, this._fileStart = 0, this.mimeType = e, this._sortedSamples = new eC(), this.mp4File = JA.createFile(), this._sortedSamples = new eC();
    const r = new Qg("CustomSourceBuffer");
    this.logger = r, r.silly("Initializing MeshSourceBuffer for MIME type", e), Object.defineProperty(this, "buffered", {
      get() {
        const { _sortedSamples: u } = this;
        return {
          length: u.length,
          start: (I) => u.samples[I].start,
          end: (I) => u.samples[I].end
        };
      }
    }), this.bindEvents();
  }
  appendBuffer(e) {
    return Ca(this, null, function* () {
      const { logger: r, mp4File: u } = this, { byteLength: I } = e;
      if (this.updating)
        throw yR(
          "SourceBuffer.append() cannot be called while an update is in progress"
        );
      I <= KI && this._isInitialized ? (r.debug("Initial segment received. Resetting file start."), this._fileStart = 0) : I <= KI && !this._isInitialized && r.debug("Initial segment received. Waiting for initialization."), this.onBeginUpdate(), e.fileStart = this._fileStart, this._fileStart = u.appendBuffer(e), this.bytesReceived += I, yield Im(0), this.onEndUpdate();
    });
  }
  remove(e, r) {
    return Ca(this, null, function* () {
      const { logger: u } = this, { timescale: I, _sortedSamples: E } = this, k = e * I, g = r * I;
      u.debug(`Removing samples between ${e} and ${r}.`), E.remove(k, g), yield Im(0), this.onUpdate();
    });
  }
  reset() {
    this._sortedSamples.clear(), this._fileStart = 0, this.bytesReceived = 0;
  }
  abort() {
    this.reset(), this.updating = !1, this.dispatchEvent(new Event(EE)), this.dispatchEvent(new Event(UI));
  }
  processSamples(e) {
    return Ca(this, null, function* () {
      const { timescale: r, _sortedSamples: u } = this;
      this.onBeginUpdate();
      for (const I of e) {
        const { geometry: E, duration: k, timestamp: g } = I, w = g / r, B = (g + k) / r;
        if (I.start = w, I.end = B, E instanceof Wa.BufferGeometry || E.isBufferGeometry) {
          Object.setPrototypeOf(E, Wa.BufferGeometry.prototype), Object.setPrototypeOf(E.index, Wa.BufferAttribute.prototype);
          for (const m in E.attributes) {
            const { array: b, itemSize: y } = E.attributes[m];
            let T;
            switch (!0) {
              case b instanceof Float32Array:
                T = new Wa.Float32BufferAttribute(b, y);
                break;
              case b instanceof Uint16Array:
                T = new Wa.Uint16BufferAttribute(b, y);
                break;
              case b instanceof Uint32Array:
                T = new Wa.Uint32BufferAttribute(b, y);
                break;
            }
            Object.setPrototypeOf(T, Wa.BufferAttribute.prototype), E.attributes[m] = T;
          }
        } else
          throw new Error("Geometry is not a BufferGeometry");
        u.add(I);
        const c = u.at(0), d = u.at(1);
        if (c && d) {
          const { timescale: m, duration: b } = c;
          this.timescale = m, this.frameDuration = b, this._isInitialized = !0;
        }
      }
      yield Im(0), this.onEndUpdate();
    });
  }
  onWorkerMessage(e) {
    return Ca(this, null, function* () {
      const r = e.data;
      this.processSamples(r);
    });
  }
  onBeginUpdate() {
    this.updating = !0, this.dispatchEvent(new Event(wE));
  }
  onUpdate() {
    this.dispatchEvent(new Event(vE));
  }
  onEndUpdate() {
    this.updating = !1, this.dispatchEvent(new Event(UI));
  }
  // Initialization
  bindEvents() {
    return Ca(this, null, function* () {
      const { logger: e, mp4File: r } = this, u = () => {
        e.silly("Parsing header...");
      }, I = (B) => {
        e.silly("MeshSourceBuffer ready", B);
        const { duration: c, timescale: d, tracks: m } = B;
        this.timescale = d, this.duration = c;
        for (const b of m)
          r.setExtractionOptions(b.id, null, {
            nbSamples: NE,
            rapAlignment: "sync"
          });
        r.start();
      };
      r.onMoovStart = u, r.onReady = I;
      const E = (B, c, d) => Ca(this, null, function* () {
        for (const m of d)
          k.postMessage(m);
      });
      r.onSamples = E;
      const k = new cT(xE), g = (B) => {
        this.processSamples(B.data);
      }, w = (B) => e.error("Worker error", B.stack);
      k.onmessage = g, k.onerror = w, this.workerPool = k;
    });
  }
  seek(e) {
    const { logger: r, mp4File: u } = this;
    r.debug(`Seeking to ${e}`), u.seek(e, !1);
  }
  getFrame(e) {
    const { _sortedSamples: r, frameDuration: u } = this, I = e * u;
    return r.getAtTimestamp(I);
  }
  checkPlayback(e, r = 0) {
    const { buffered: u } = this;
    return ZA(u, e, r);
  }
}
var Bf = { exports: {} };
(function(t, e) {
  Object.defineProperty(e, "__esModule", { value: !0 });
  function r(V) {
    return typeof V == "object" && !("toString" in V) ? Object.prototype.toString.call(V).slice(8, -1) : V;
  }
  var u = typeof process == "object" && !0;
  function I(V, Q) {
    if (!V)
      throw u ? new Error("Invariant failed") : new Error(Q());
  }
  e.invariant = I;
  var E = Object.prototype.hasOwnProperty, k = Array.prototype.splice, g = Object.prototype.toString;
  function w(V) {
    return g.call(V).slice(8, -1);
  }
  var B = Object.assign || /* istanbul ignore next */
  function(V, Q) {
    return c(Q).forEach(function(vt) {
      E.call(Q, vt) && (V[vt] = Q[vt]);
    }), V;
  }, c = typeof Object.getOwnPropertySymbols == "function" ? function(V) {
    return Object.keys(V).concat(Object.getOwnPropertySymbols(V));
  } : function(V) {
    return Object.keys(V);
  };
  function d(V) {
    return Array.isArray(V) ? B(V.constructor(V.length), V) : w(V) === "Map" ? new Map(V) : w(V) === "Set" ? new Set(V) : V && typeof V == "object" ? B(Object.create(Object.getPrototypeOf(V)), V) : V;
  }
  var m = (
    /** @class */
    function() {
      function V() {
        this.commands = B({}, b), this.update = this.update.bind(this), this.update.extend = this.extend = this.extend.bind(this), this.update.isEquals = function(Q, vt) {
          return Q === vt;
        }, this.update.newContext = function() {
          return new V().update;
        };
      }
      return Object.defineProperty(V.prototype, "isEquals", {
        get: function() {
          return this.update.isEquals;
        },
        set: function(Q) {
          this.update.isEquals = Q;
        },
        enumerable: !0,
        configurable: !0
      }), V.prototype.extend = function(Q, vt) {
        this.commands[Q] = vt;
      }, V.prototype.update = function(Q, vt) {
        var Lt = this, zt = typeof vt == "function" ? { $apply: vt } : vt;
        Array.isArray(Q) && Array.isArray(zt) || I(!Array.isArray(zt), function() {
          return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
        }), I(typeof zt == "object" && zt !== null, function() {
          return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(Lt.commands).join(", ") + ".");
        });
        var X = Q;
        return c(zt).forEach(function(D) {
          if (E.call(Lt.commands, D)) {
            var yt = Q === X;
            X = Lt.commands[D](zt[D], X, zt, Q), yt && Lt.isEquals(X, Q) && (X = Q);
          } else {
            var Mt = w(Q) === "Map" ? Lt.update(Q.get(D), zt[D]) : Lt.update(Q[D], zt[D]), at = w(X) === "Map" ? X.get(D) : X[D];
            (!Lt.isEquals(Mt, at) || typeof Mt == "undefined" && !E.call(Q, D)) && (X === Q && (X = d(Q)), w(X) === "Map" ? X.set(D, Mt) : X[D] = Mt);
          }
        }), X;
      }, V;
    }()
  );
  e.Context = m;
  var b = {
    $push: function(V, Q, vt) {
      return T(Q, vt, "$push"), V.length ? Q.concat(V) : Q;
    },
    $unshift: function(V, Q, vt) {
      return T(Q, vt, "$unshift"), V.length ? V.concat(Q) : Q;
    },
    $splice: function(V, Q, vt, Lt) {
      return o(Q, vt), V.forEach(function(zt) {
        l(zt), Q === Lt && zt.length && (Q = d(Lt)), k.apply(Q, zt);
      }), Q;
    },
    $set: function(V, Q, vt) {
      return p(vt), V;
    },
    $toggle: function(V, Q) {
      n(V, "$toggle");
      var vt = V.length ? d(Q) : Q;
      return V.forEach(function(Lt) {
        vt[Lt] = !Q[Lt];
      }), vt;
    },
    $unset: function(V, Q, vt, Lt) {
      return n(V, "$unset"), V.forEach(function(zt) {
        Object.hasOwnProperty.call(Q, zt) && (Q === Lt && (Q = d(Lt)), delete Q[zt]);
      }), Q;
    },
    $add: function(V, Q, vt, Lt) {
      return Z(Q, "$add"), n(V, "$add"), w(Q) === "Map" ? V.forEach(function(zt) {
        var X = zt[0], D = zt[1];
        Q === Lt && Q.get(X) !== D && (Q = d(Lt)), Q.set(X, D);
      }) : V.forEach(function(zt) {
        Q === Lt && !Q.has(zt) && (Q = d(Lt)), Q.add(zt);
      }), Q;
    },
    $remove: function(V, Q, vt, Lt) {
      return Z(Q, "$remove"), n(V, "$remove"), V.forEach(function(zt) {
        Q === Lt && Q.has(zt) && (Q = d(Lt)), Q.delete(zt);
      }), Q;
    },
    $merge: function(V, Q, vt, Lt) {
      return z(Q, V), c(V).forEach(function(zt) {
        V[zt] !== Q[zt] && (Q === Lt && (Q = d(Lt)), Q[zt] = V[zt]);
      }), Q;
    },
    $apply: function(V, Q) {
      return h(V), V(Q);
    }
  }, y = new m();
  e.isEquals = y.update.isEquals, e.extend = y.extend, e.default = y.update, e.default.default = t.exports = B(e.default, e);
  function T(V, Q, vt) {
    I(Array.isArray(V), function() {
      return "update(): expected target of " + r(vt) + " to be an array; got " + r(V) + ".";
    }), n(Q[vt], vt);
  }
  function n(V, Q) {
    I(Array.isArray(V), function() {
      return "update(): expected spec of " + r(Q) + " to be an array; got " + r(V) + ". Did you forget to wrap your parameter in an array?";
    });
  }
  function o(V, Q) {
    I(Array.isArray(V), function() {
      return "Expected $splice target to be an array; got " + r(V);
    }), l(Q.$splice);
  }
  function l(V) {
    I(Array.isArray(V), function() {
      return "update(): expected spec of $splice to be an array of arrays; got " + r(V) + ". Did you forget to wrap your parameters in an array?";
    });
  }
  function h(V) {
    I(typeof V == "function", function() {
      return "update(): expected spec of $apply to be a function; got " + r(V) + ".";
    });
  }
  function p(V) {
    I(Object.keys(V).length === 1, function() {
      return "Cannot have more than one key in an object with $set";
    });
  }
  function z(V, Q) {
    I(Q && typeof Q == "object", function() {
      return "update(): $merge expects a spec of type 'object'; got " + r(Q);
    }), I(V && typeof V == "object", function() {
      return "update(): $merge expects a target of type 'object'; got " + r(V);
    });
  }
  function Z(V, Q) {
    var vt = w(V);
    I(vt === "Map" || vt === "Set", function() {
      return "update(): " + r(Q) + " expects a target of type Set or Map; got " + r(vt);
    });
  }
})(Bf, Bf.exports);
var _R = Bf.exports;
const bR = /* @__PURE__ */ Nf(_R), yy = "MPD", Ay = "XLinkExpansion", _y = "MediaSegment", by = "InitializationSegment", Sy = "BitstreamSwitchingSegment", wy = "IndexSegment", vy = "FragmentInfoSegment", Ey = "license", Ty = "other", SR = {
  debug: {
    logLevel: ra.Debug.LOG_LEVEL_WARNING,
    dispatchEvent: !1
  },
  streaming: {
    abandonLoadTimeout: 1e4,
    wallclockTimeUpdateInterval: 100,
    manifestUpdateRetryInterval: 100,
    liveUpdateTimeThresholdInMilliseconds: 0,
    cacheInitSegments: !1,
    applyServiceDescription: !0,
    applyProducerReferenceTime: !0,
    applyContentSteering: !0,
    enableManifestDurationMismatchFix: !0,
    parseInbandPrft: !1,
    enableManifestTimescaleMismatchFix: !1,
    capabilities: {
      filterUnsupportedEssentialProperties: !0,
      supportedEssentialProperties: [
        { schemeIdUri: ra.Constants.FONT_DOWNLOAD_DVB_SCHEME },
        {
          schemeIdUri: ra.Constants.COLOUR_PRIMARIES_SCHEME_ID_URI,
          value: /1|5|6|7/
        },
        { schemeIdUri: ra.Constants.URL_QUERY_INFO_SCHEME },
        { schemeIdUri: ra.Constants.EXT_URL_QUERY_INFO_SCHEME },
        {
          schemeIdUri: ra.Constants.MATRIX_COEFFICIENTS_SCHEME_ID_URI,
          value: /0|1|5|6/
        },
        {
          schemeIdUri: ra.Constants.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI,
          value: /1|6|13|14|15/
        },
        ...ra.Constants.THUMBNAILS_SCHEME_ID_URIS.map((t) => ({ schemeIdUri: t }))
      ],
      useMediaCapabilitiesApi: !0,
      filterVideoColorimetryEssentialProperties: !1,
      filterHDRMetadataFormatEssentialProperties: !1
    },
    timeShiftBuffer: {
      calcFromSegmentTimeline: !1,
      fallbackToSegmentTimeline: !0
    },
    metrics: {
      maxListDepth: 100
    },
    delay: {
      liveDelayFragmentCount: NaN,
      liveDelay: NaN,
      useSuggestedPresentationDelay: !0
    },
    protection: {
      keepProtectionMediaKeys: !1,
      ignoreEmeEncryptedEvent: !1,
      detectPlayreadyMessageFormat: !0
    },
    buffer: {
      enableSeekDecorrelationFix: !1,
      fastSwitchEnabled: null,
      flushBufferAtTrackSwitch: !1,
      reuseExistingSourceBuffers: !0,
      bufferPruningInterval: 10,
      bufferToKeep: 20,
      bufferTimeAtTopQuality: 30,
      bufferTimeAtTopQualityLongForm: 60,
      initialBufferLevel: NaN,
      bufferTimeDefault: 18,
      longFormContentDurationThreshold: 600,
      stallThreshold: 0.3,
      useAppendWindow: !0,
      setStallState: !0,
      avoidCurrentTimeRangePruning: !1,
      useChangeType: !0,
      mediaSourceDurationInfinity: !0,
      resetSourceBuffersForTrackSwitch: !1
    },
    gaps: {
      jumpGaps: !0,
      jumpLargeGaps: !0,
      smallGapLimit: 1.5,
      threshold: 0.3,
      enableSeekFix: !0,
      enableStallFix: !1,
      stallSeek: 0.1
    },
    utcSynchronization: {
      enabled: !0,
      useManifestDateHeaderTimeSource: !0,
      backgroundAttempts: 2,
      timeBetweenSyncAttempts: 30,
      maximumTimeBetweenSyncAttempts: 600,
      minimumTimeBetweenSyncAttempts: 2,
      timeBetweenSyncAttemptsAdjustmentFactor: 2,
      maximumAllowedDrift: 100,
      enableBackgroundSyncAfterSegmentDownloadError: !0,
      defaultTimingSource: {
        scheme: "urn:mpeg:dash:utc:http-xsdate:2014",
        value: "https://time.akamai.com/?iso&ms"
      }
    },
    scheduling: {
      defaultTimeout: 500,
      lowLatencyTimeout: 0,
      scheduleWhilePaused: !0
    },
    text: {
      defaultEnabled: !0,
      dispatchForManualRendering: !1,
      extendSegmentedCues: !0,
      imsc: {
        displayForcedOnlyMode: !1,
        enableRollUp: !0
      },
      webvtt: {
        customRenderingEnabled: !1
      }
    },
    liveCatchup: {
      maxDrift: NaN,
      playbackRate: {
        min: NaN,
        max: NaN
      },
      playbackBufferMin: 0.5,
      enabled: null,
      mode: ra.Constants.LIVE_CATCHUP_MODE_DEFAULT
    },
    lastBitrateCachingInfo: {
      enabled: !0,
      ttl: 36e4
    },
    lastMediaSettingsCachingInfo: {
      enabled: !0,
      ttl: 36e4
    },
    saveLastMediaSettingsForCurrentStreamingSession: !0,
    cacheLoadThresholds: {
      video: 10,
      audio: 5
    },
    trackSwitchMode: {
      audio: ra.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
      video: ra.Constants.TRACK_SWITCH_MODE_NEVER_REPLACE,
      mesh: ra.Constants.TRACK_SWITCH_MODE_NEVER_REPLACE
    },
    selectionModeForInitialTrack: ra.Constants.TRACK_SELECTION_MODE_HIGHEST_SELECTION_PRIORITY,
    fragmentRequestTimeout: 2e4,
    fragmentRequestProgressTimeout: -1,
    manifestRequestTimeout: 1e4,
    retryIntervals: {
      [yy]: 500,
      [Ay]: 500,
      [_y]: 1e3,
      [by]: 1e3,
      [Sy]: 1e3,
      [wy]: 1e3,
      [vy]: 1e3,
      [Ey]: 1e3,
      [Ty]: 1e3,
      lowLatencyReductionFactor: 10
    },
    retryAttempts: {
      [yy]: 3,
      [Ay]: 1,
      [_y]: 3,
      [by]: 3,
      [Sy]: 3,
      [wy]: 3,
      [vy]: 3,
      [Ey]: 3,
      [Ty]: 3,
      lowLatencyMultiplyFactor: 5
    },
    abr: {
      limitBitrateByPortal: !1,
      usePixelRatioInLimitBitrateByPortal: !1,
      enableSupplementalPropertyAdaptationSetSwitching: !0,
      rules: {
        throughputRule: {
          active: !0
        },
        bolaRule: {
          active: !0
        },
        insufficientBufferRule: {
          active: !0,
          parameters: {
            throughputSafetyFactor: 0.7,
            segmentIgnoreCount: 2
          }
        },
        switchHistoryRule: {
          active: !0,
          parameters: {
            sampleSize: 8,
            switchPercentageThreshold: 0.075
          }
        },
        droppedFramesRule: {
          active: !1,
          parameters: {
            minimumSampleSize: 375,
            droppedFramesPercentageThreshold: 0.15
          }
        },
        abandonRequestsRule: {
          active: !0,
          parameters: {
            abandonDurationMultiplier: 1.8,
            minSegmentDownloadTimeThresholdInMs: 500,
            minThroughputSamplesThreshold: 6
          }
        },
        l2ARule: {
          active: !1
        },
        loLPRule: {
          active: !1
        }
      },
      throughput: {
        averageCalculationMode: ra.Constants.THROUGHPUT_CALCULATION_MODES.EWMA,
        lowLatencyDownloadTimeCalculationMode: ra.Constants.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING,
        useResourceTimingApi: !0,
        useNetworkInformationApi: {
          xhr: !1,
          fetch: !1
        },
        useDeadTimeLatency: !0,
        bandwidthSafetyFactor: 0.9,
        sampleSettings: {
          live: 3,
          vod: 4,
          enableSampleSizeAdjustment: !0,
          decreaseScale: 0.7,
          increaseScale: 1.3,
          maxMeasurementsToKeep: 20,
          averageLatencySampleAmount: 4
        },
        ewma: {
          throughputSlowHalfLifeSeconds: 8,
          throughputFastHalfLifeSeconds: 3,
          latencySlowHalfLifeCount: 2,
          latencyFastHalfLifeCount: 1,
          weightDownloadTimeMultiplicationFactor: 15e-4
        }
      },
      maxBitrate: {
        audio: -1,
        video: -1,
        mesh: -1
      },
      minBitrate: {
        audio: -1,
        video: -1,
        mesh: -1
      },
      initialBitrate: {
        audio: -1,
        video: -1,
        mesh: 0
      },
      autoSwitchBitrate: {
        audio: !0,
        video: !0,
        mesh: !1
      }
    },
    cmcd: {
      applyParametersFromMpd: !0,
      enabled: !1,
      sid: null,
      cid: null,
      rtp: null,
      rtpSafetyFactor: 5,
      mode: ra.Constants.CMCD_MODE_QUERY,
      enabledKeys: ra.Constants.CMCD_AVAILABLE_KEYS,
      includeInRequests: ["segment", "mpd"]
    },
    cmsd: {
      enabled: !1,
      abr: {
        applyMb: !1,
        etpWeightRatio: 0
      }
    },
    defaultSchemeIdUri: {
      viewpoint: "",
      audioChannelConfiguration: "urn:mpeg:mpegB:cicp:ChannelConfiguration",
      role: "urn:mpeg:dash:role:2011",
      accessibility: "urn:mpeg:dash:role:2011"
    }
  },
  errors: {
    recoverAttempts: {
      mediaErrorDecode: 5
    }
  }
}, wR = /^(rtmp|https?:\/\/|mailto:|data:|tel:)/, vR = (t) => typeof t != "undefined", xf = (t) => typeof t == "number" && !isNaN(t), R0 = (t) => typeof t == "string", ER = (t) => R0(t) && t.trim().length > 0, TR = (t) => R0(t) ? wR.test(t) : !1, ky = 5e3, kR = "reset", D0 = "statechanged", LR = "PLAY", MR = "PAUSE", RR = "volumechange", DR = "timeupdate", BR = "canplay", xR = "canplaythrough", NR = "complete", GR = "durationchange", zR = "emptied", YR = "ended", HR = "error", PR = "loadeddata", FR = "loadedmetadata", OR = "loadstart", UR = "pause", KR = "play", VR = "playing", XR = "progress", WR = "ratechange", jR = "seeked", ZR = "seeking", JR = "stalled", QR = "suspend", qR = "timeupdate", $R = "volumechange", tD = "waiting", eD = Or >> 1, Ly = "none", nD = "failed", ag = "initializing", B0 = "initialized", aD = "seeking", iD = "buffering", x0 = "playing", N0 = "paused";
class rD extends EventTarget {
  constructor(e) {
    super(), this.player = null, this.qualityManager = null, this.timecodeByteLength = 0, this.useWebGL2 = !0, this.currentPoll = null, this.state = Ly, this.cancelPreviousPollForTime = () => Ca(this, null, function* () {
      const { pollForTimeTimerId: E, currentPoll: k } = this;
      window.clearTimeout(E), k && (k.reject(new Error("ERR_NEW_POLL_REQUEST")), this.currentPoll = null);
    }), this.onDashPlayerInitialized = () => Ca(this, null, function* () {
      const { logger: E } = this;
      E.silly("Player is initialized.");
    }), this.onQualityChange = () => Ca(this, null, function* () {
      const {
        logger: E,
        currentPoll: k,
        player: { video: g }
      } = this, w = g.currentTime;
      E.silly(`onQualityChange at ${w}`);
    }), this.onCanPlay = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onCanPlay: ${k == null ? void 0 : k.src}`), this.state === ag && this.setState(B0);
    }, this.onCanPlayThrough = () => {
      const { logger: E } = this;
      E.silly("onCanPlayThrough");
    }, this.onComplete = () => {
      const { logger: E } = this;
      E.silly("onComplete");
    }, this.onDurationChange = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onDurationChange: ${k.duration}`);
    }, this.onEmptied = () => {
      const { logger: E } = this;
      E.silly("onEmptied: The video element is now empty.");
    }, this.onEnded = () => {
      const { logger: E } = this;
      E.silly("onEnded");
    }, this.onError = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.error(`onError: ${k.error}`);
    }, this.onLoadedData = () => {
      const { logger: E } = this;
      E.silly("onLoadedData");
    }, this.onLoadedMetadata = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onLoadedMetadata: ${k.duration}`);
    }, this.onLoadStart = () => {
      const { logger: E } = this;
      E.silly("onLoadStart");
    }, this.onPause = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onPause: ${k == null ? void 0 : k.currentTime}`), this.setState(N0), this.dispatchEvent(fD());
    }, this.onPlay = () => {
      this.dispatchEvent(mD());
    }, this.onPlaying = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onPlaying: ${k == null ? void 0 : k.currentTime}`), this.setState(x0);
    }, this.onProgress = () => {
    }, this.onRateChange = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.debug(`onRateChange: ${k.playbackRate}`);
    }, this.onSeeked = () => Ca(this, null, function* () {
      const {
        logger: E,
        player: { video: k, meshSourceBuffer: g }
      } = this;
      E.silly(`onSeeked: ${k == null ? void 0 : k.currentTime}`), g.checkPlayback(k.currentTime) || this.pause();
    }), this.onSeeking = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(`onSeeking: ${k == null ? void 0 : k.currentTime}`), this.setState(aD);
    }, this.onStalled = () => {
      const { logger: E } = this;
      E.silly("onStalled: The video data is no longer available."), this.setState(iD);
    }, this.onSuspend = () => {
      const { logger: E } = this;
      E.silly("onSuspend: Video data loading has been suspended.");
    }, this.onTimeUpdate = () => {
      const {
        player: { video: E }
      } = this;
      E && this.dispatchEvent(pD(E));
    }, this.onVolumeChange = () => {
      const {
        logger: E,
        player: { video: k }
      } = this;
      E.silly(
        `onVolumeChange: Volume = ${k == null ? void 0 : k.volume}, Muted = ${k == null ? void 0 : k.muted}`
      ), this.dispatchEvent(hD(k));
    }, this.onWaiting = () => {
      const { logger: E } = this;
      E.silly("onWaiting: Video is waiting for more data.");
    };
    const { deviceCapabilities: r, qualityManager: u } = e, I = new Qg("PlaybackManager");
    this.player = e, this.logger = I, this.updateBufferSize(0, 0), this.useWebGL2 = !!r.webGL2, this.qualityManager = u, this.bindEvents(), this.setState(ag);
  }
  // buffer will hold all timecode pixels - 16*10*timecode_height_of_resolution*stride
  updateBufferSize(e, r) {
    const [u, I, E] = Vf(e), k = Sg * I * E;
    this.timecodeByteLength = k, this.timecodeBuffer = new Uint8ClampedArray(k);
  }
  bindEvents() {
    const {
      logger: e,
      player: r,
      player: { video: u, qualityManager: I, player: E }
    } = this;
    r.addEventListener(
      bg,
      this.onDashPlayerInitialized
    ), I.addEventListener(
      Kf,
      this.onQualityChange
    ), u.addEventListener(BR, this.onCanPlay), u.addEventListener(xR, this.onCanPlayThrough), u.addEventListener(NR, this.onComplete), u.addEventListener(GR, this.onDurationChange), u.addEventListener(zR, this.onEmptied), u.addEventListener(YR, this.onEnded), u.addEventListener(HR, this.onError), u.addEventListener(PR, this.onLoadedData), u.addEventListener(FR, this.onLoadedMetadata), u.addEventListener(OR, this.onLoadStart), u.addEventListener(UR, this.onPause), u.addEventListener(KR, this.onPlay), u.addEventListener(VR, this.onPlaying), u.addEventListener(XR, this.onProgress), u.addEventListener(WR, this.onRateChange), u.addEventListener(jR, this.onSeeked), u.addEventListener(ZR, this.onSeeking), u.addEventListener(JR, this.onStalled), u.addEventListener(QR, this.onSuspend), u.addEventListener(qR, this.onTimeUpdate), u.addEventListener($R, this.onVolumeChange), u.addEventListener(tD, this.onWaiting), E.on(dashjs.MediaPlayer.events.BUFFER_EMPTY, (k) => {
      this.state !== ag && (e.debug("Buffer is empty"), this.pause());
    }), E.on(dashjs.MediaPlayer.events.BUFFER_LOADED, (k) => {
      this.state !== ag && (e.debug("Buffer is loaded", this.isPaused()), this.play());
    });
  }
  setState(e) {
    const { logger: r } = this, u = this.state;
    if (u !== e) {
      if (u === nD)
        throw new Error(`Cannot transition from state ${u}`);
      r.info(
        `${D0} ${u} -> ${e}`
      ), this.state = e, this.dispatchEvent(
        cD(e, u)
      );
    }
  }
  reset() {
    const { logger: e } = this;
    e.info("Resetting PlaybackManager."), this.state = Ly, this.dispatchEvent(gD());
  }
  process() {
    const { timecodeBuffer: e } = this;
    let r = 0;
    for (let u = 0, I = 0; u < pl; ++u) {
      const E = e[I + eD];
      r = r << 1 | (E > 127 ? 1 : 0), I += Sg * Or;
    }
    return r;
  }
  isPaused() {
    const {
      player: { player: e }
    } = this;
    return e.isPaused();
  }
  pause() {
    const {
      logger: e,
      player: { player: r }
    } = this;
    e.silly("Pause");
    try {
      r.pause();
    } catch (u) {
      e.error(u);
    }
  }
  play() {
    const {
      logger: e,
      player: { player: r }
    } = this;
    e.silly("Play");
    try {
      r.play();
    } catch (u) {
      e.error(u);
    }
  }
  /**
   * Checks whether `currentTime` is buffered.
   */
  checkPlayback(e, r = 0) {
    const {
      player: {
        video: { buffered: u },
        meshSourceBuffer: I
      }
    } = this;
    return I.checkPlayback(
      e,
      r
    ) ? ZA(u, e, r) : !1;
  }
  requestPollForTime(e, r) {
    const {
      logger: u,
      player: { meshSourceBuffer: I }
    } = this;
    if (!I._isInitialized)
      return Promise.resolve();
    this.cancelPreviousPollForTime();
    const E = {
      time: e,
      wasPaused: r,
      resolve: el,
      reject: el
    };
    u.debug(`Requesting poll for time ${e} (was paused: ${r})`);
    const k = new Promise((g, w) => {
      E.reject = (d) => {
        E.resolved = !0, w(d);
      }, E.resolve = (d) => {
        E.resolved = !0, g(d);
      }, E.resolved = !1;
      const B = () => {
        E.resolved || (u.warn(
          `Could not seek to ${e} after timeout reached of ${ky}`
        ), E.reject(new Error("ERR_SEEK_TIMEOUT")), this.cancelPreviousPollForTime());
      }, c = () => {
        if (E.resolved)
          return;
        const {
          player: { video: d, meshSourceBuffer: m }
        } = this;
        if (d && m && this.checkPlayback(e)) {
          this.currentPoll = null, u.debug(
            `Resolved polling for ${e} (was paused: ${r})`
          ), E.resolve(void 0);
          return;
        }
        this.pollForTimeTimerId = window.setTimeout(c, 100);
      };
      c(), window.setTimeout(B, ky);
    });
    return this.currentPoll = E, k;
  }
  seek(e) {
    return Ca(this, null, function* () {
      const {
        logger: r,
        player: { player: u, video: I, meshSourceBuffer: E }
      } = this;
      r.debug(`Seeking to: ${e}`), u.seek(e), E.seek(e);
    });
  }
}
const Oi = (t, e) => new CustomEvent(t, { detail: e }), _u = (t) => Oi(SE, t), sD = (t) => Oi(GE, t), oD = (t, e, r) => Oi(zE, {
  framerates: t,
  meshRepresentations: e,
  videoRepresentations: r
}), G0 = (t) => Oi(Kf, t), z0 = (t) => Oi(KA, t), lD = () => Oi(bg), uD = () => Oi(HE), dD = () => Oi(YE), gD = () => Oi(kR), cD = (t, e) => Oi(D0, {
  newState: t,
  oldState: e
}), mD = () => Oi(LR), fD = () => Oi(MR), hD = (t) => Oi(RR, {
  target: t
}), pD = (t) => Oi(DR, { target: t }), My = (t) => {
  if (!ER(t))
    return -1;
  const e = /^(\d+)\/(\d+)$/.exec(t);
  if (!e)
    return -1;
  const r = e[1], u = e[2], I = parseFloat(r), E = parseFloat(u);
  return !xf(I) && !xf(E) ? -1 : I / E;
}, Ry = (t) => t.sort((e, r) => e.bandwidth - r.bandwidth);
class ID extends EventTarget {
  constructor(e) {
    super(), this.useDecodedByteCount = !1, this.lastDecodedByteCount = 0, this.framerates = [], this.videoRepresentations = [], this.meshRepresentations = [], this.currentRepresentations = {
      [UA]: null,
      [ur]: null,
      [ks]: null
    }, this.bitrate = NaN, this.resolution = [0, 0], this.fps = 0, this.targetFPS = -1, this.onDashPlayerInitialized = () => {
      const {
        logger: u,
        currentRepresentations: I,
        player: { player: E }
      } = this;
      for (const k in I) {
        const g = E.getCurrentRepresentationForType(k);
        if (!g) {
          u.warn(`Could not get current representation for ${k}`);
          continue;
        }
        I[k] = g.id, k === ur && this.selectMeshRepresentation(g);
      }
    }, this.onFragmentLoadingCompleted = () => {
    }, this.onQualityChangeRequested = (u) => {
      const {
        logger: I,
        currentRepresentations: E,
        player: { playbackManager: k }
      } = this, { mediaType: g, newRepresentation: w } = u;
      I.silly(
        `onQualityChangeRequested - mediaType: ${g}, id: ${w.id}, codecFamily: ${w.codecFamily}, codecs: ${w.codecs}`
      );
    }, this.onQualityChangeRendered = (u) => {
      const {
        logger: I,
        currentRepresentations: E,
        player: { playbackManager: k }
      } = this, { mediaType: g, newRepresentation: w } = u, B = w.id !== E[g];
      if (E[g] = w.id, I.silly(
        `onQualityChangeRendered - mediaType: ${g}, id: ${w.id}, codecFamily: ${w.codecFamily}, codecs: ${w.codecs}`
      ), g === ur && (this.selectMeshRepresentation(w), this.dispatchEvent(G0(w))), g === ks) {
        const { id: c } = w, d = c.replace(/fps$/, ""), m = parseFloat(d);
        this.setCurrentFrameRate(m), B && k.pause();
      }
    }, this.updateMeshRepresentation = () => {
      const {
        player: { player: u }
      } = this, I = u.getCurrentRepresentationForType(ur);
      this.selectMeshRepresentation(I);
    }, this.filterRepresentation = (u) => {
      const {
        logger: I,
        player: {
          options: { maximumTextureSize: E }
        }
      } = this, { targetFPS: k } = this, { mimeType: g } = u;
      return g.startsWith("video") && u.width > E ? (I.silly(
        `Representation rejected on mobile for ${g}: ${u.id}`
      ), !1) : "framerate" in u && k !== -1 && !(u.framerate === `${k}/1`) ? !1 : (I.silly(
        `Representation selected for ${g}: ${u.id}`
      ), !0);
    };
    const {
      options: { targetFPS: r }
    } = e;
    this.player = e, this.targetFPS = r, this.logger = new Qg("QualityManager");
    try {
      const u = document.createElement("video");
      this.useDecodedByteCount = vR(u.webkitVideoDecodedByteCount);
    } catch (u) {
    }
    this.bindEvents();
  }
  configure() {
    return Ca(this, null, function* () {
      const {
        logger: e,
        player: r,
        player: { player: u }
      } = this;
      e.info(
        `Configuring Player (is mobile: ${_g}, is iOS: ${Uc})`
      ), u.updateSettings(this.getDashSettings()), _g && Uc && (r.options.maximumTextureSize = 1024);
    });
  }
  bindEvents() {
    const {
      player: e,
      player: { player: r }
    } = this;
    e.addEventListener(
      bg,
      this.onDashPlayerInitialized
    ), r.on(
      ra.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED,
      this.onFragmentLoadingCompleted
    ), r.on(
      ra.MediaPlayer.events.QUALITY_CHANGE_REQUESTED,
      this.onQualityChangeRequested
    ), r.on(
      ra.MediaPlayer.events.QUALITY_CHANGE_RENDERED,
      this.onQualityChangeRendered
    );
  }
  unbindEvents() {
    const {
      player: e,
      player: { player: r }
    } = this;
    e.removeEventListener(
      bg,
      this.onDashPlayerInitialized
    ), r && (r.off(
      ra.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED,
      this.onFragmentLoadingCompleted
    ), r.off(
      ra.MediaPlayer.events.QUALITY_CHANGE_REQUESTED,
      this.onQualityChangeRequested
    ), r.off(
      ra.MediaPlayer.events.QUALITY_CHANGE_RENDERED,
      this.onQualityChangeRendered
    ));
  }
  setCurrentFrameRate(e) {
    this.fps = e, this.fps !== e ? this.logger.debug(
      `Frame rate changed to  ${e} (Previous: ${this.fps})`
    ) : this.logger.silly(`Setting frame rate to  ${e} (no change)`), this.dispatchEvent(z0(e));
  }
  enableABR() {
    const {
      logger: e,
      player: { player: r }
    } = this;
    e.info("Enabling ABR"), r.updateSettings({
      streaming: {
        abr: {
          autoSwitchBitrate: {
            [ur]: !0
          }
        }
      }
    });
  }
  disableABR() {
    const {
      logger: e,
      player: { player: r }
    } = this;
    e.info("Disabling ABR"), r.updateSettings({
      streaming: {
        abr: {
          autoSwitchBitrate: {
            [ur]: !1
          }
        }
      }
    });
  }
  /**
   * In case the video track changes, adapt to suitable representation of the
   * mesh.
   */
  selectMeshRepresentation(e) {
    const {
      logger: r,
      player: { player: u }
    } = this, { id: I, mediaType: E } = e;
    if (E === ur)
      throw new Error(
        `Expected ${ur}, but received ${E}.`
      );
    const k = u.getCurrentRepresentationForType(ks);
    if (k && I.endsWith(k.id)) {
      r.silly(
        `Mesh representation (already) selected for video ${I}:  ${k.id}`
      );
      const B = parseFloat(k.id.replace("fps", ""));
      this.setCurrentFrameRate(B);
      return;
    }
    const w = u.getRepresentationsByType(ks).find(
      (B) => I.endsWith(B.id)
    );
    if (w) {
      r.silly(
        `Selecting mesh representation for video ${I}: ${w.id}`
      );
      const B = parseFloat(w.id.replace("fps", ""));
      this.setCurrentFrameRate(B), u.setRepresentationForTypeById(
        ks,
        w.id,
        !0
      );
    } else
      throw new Error(`No mesh representation found for ${I}.`);
  }
  /**
   * In case the mesh track changes, adapt to suitable representation of the
   * video.
   */
  selectVideoRepresentation(e) {
    const {
      logger: r,
      player: { player: u }
    } = this, { id: I, mediaType: E } = e;
    if (E === ks)
      throw new Error(`
          Expected ${ks}, but received ${E}.
          `);
    const k = u.getCurrentRepresentationForType(ur);
    if (k && k.id.endsWith(I)) {
      r.info(
        `Video representation selected for mesh ${I}:  ${k.id}`
      );
      return;
    }
    const w = u.getRepresentationsByType(ur).find(
      (B) => B.id.endsWith(I)
    );
    if (w)
      r.info(
        `Selecting video representation for mesh ${I}: ${w.id}`
      ), u.setRepresentationForTypeById(
        ur,
        w.id,
        !0
      );
    else
      throw new Error(`No video representation found for ${I}.`);
  }
  parseManifest(e) {
    const {
      logger: r,
      player: u,
      player: {
        options: { maximumTextureSize: I }
      }
    } = this;
    r.silly("Parsing manifest:", e);
    const E = e.Period[0].AdaptationSet.find(
      (b) => b.contentType === ur
    ), k = Ry(
      E.Representation.map((b) => {
        const { id: y, framerate: T, bandwidth: n, width: o, height: l } = b;
        return {
          id: y,
          bandwidth: n,
          framerate: My(T),
          width: o,
          height: l
        };
      })
    );
    if (k.filter(
      ({ width: b }) => b <= I
    ).length === 0) {
      const b = Array.from(
        new Set(
          k.map(({ width: y, height: T }) => `${y}x${T}`)
        )
      );
      u.dispatchEvent(
        _u(
          `Could not find video stream smaller than the maximum size of ${I}x${I}.

Available: ${b.join(", ")}`
        )
      );
      return;
    }
    const w = e.Period[0].AdaptationSet.find(
      (b) => b.contentType === ks
    ), B = Ry(
      w.Representation.map((b) => {
        const { id: y, framerate: T, bandwidth: n, codecs: o } = b;
        return {
          id: y,
          bandwidth: n,
          framerate: My(T),
          codecs: o
        };
      })
    ), c = Array.from(
      new Set(k.map(({ framerate: b }) => b))
    ), d = c.join(", ");
    let { targetFPS: m } = this;
    if (m === -1)
      r.silly(
        `Selecting frame rate automatically. Available framerates in this manifest: ${d}.`
      );
    else if (c.includes(m))
      r.silly(
        `Selecting target frame rate ${m} from available frame rates in this manifest: ${d}.`
      );
    else {
      const b = c.reduce(
        (y, T) => Math.abs(T - m) < Math.abs(y - m) ? T : y
      );
      r.warn(
        `Target frame rate ${m} not available in frame rates: ${c.join(
          ", "
        )}. Selecting closest frame rate ${b}.`
      ), m = b;
    }
    this.targetFPS = m, this.videoRepresentations = k, this.meshRepresentations = B, this.framerates = c;
  }
  getDashSettings() {
    const {
      logger: e,
      player: {
        options: { abr: r }
      }
    } = this, u = {
      debug: {
        $merge: {
          logLevel: ra.Debug.LOG_LEVEL_WARNING
        }
      },
      streaming: {
        buffer: {
          $merge: {
            // See also https://github.com/Dash-Industry-Forum/dash.js/issues/3595
            fastSwitchEnabled: !0,
            reuseExistingSourceBuffers: !1,
            flushBufferAtTrackSwitch: !0,
            resetSourceBuffersForTrackSwitch: !0
          }
        },
        gaps: {
          $merge: {
            enableStallFix: !0,
            enableSeekFix: !1
          }
        },
        abr: {
          $merge: {
            autoSwitchBitrate: {
              audio: !1,
              video: !!r,
              // The mesh is selected in onQualityChangeRendered
              mesh: !1
            },
            rules: {
              throughputRule: {
                active: !0
              },
              bolaRule: {
                active: !1
              },
              insufficientBufferRule: {
                active: !0
              },
              switchHistoryRule: {
                active: !0
              },
              droppedFramesRule: {
                active: !0
              },
              abandonRequestsRule: {
                active: !0
              }
            }
          }
        },
        trackSwitchMode: {
          $merge: {
            audio: ra.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
            video: ra.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
            mesh: ra.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE
          }
        }
      }
    };
    (Uc || OA) && (u.streaming.buffer.$merge.bufferToKeep = 10, u.streaming.buffer.$merge.bufferTimeAtTopQuality = 10, u.streaming.buffer.$merge.bufferTimeAtTopQualityLongForm = 10, u.streaming.buffer.$merge.bufferPruningInterval = 4);
    const I = bR(SR, u);
    return e.silly("dash.js settings:", I), I;
  }
}
const Dy = (t) => (t == null ? void 0 : t.message) || (t == null ? void 0 : t.stack) || t, Y0 = (t, e) => {
  const r = window.URL.createObjectURL(t), u = document.createElement("a");
  u.href = r, u.setAttribute("download", e), document.body.appendChild(u), u.click(), document.body.removeChild(u);
};
var CD = `varying vec2 vUv;
uniform sampler2D videoMap;
uniform float contrast;
uniform float opacity;

void main() {
  vec3 col =
    clamp(texture2D(videoMap, vUv).rgb - vec3(1.0 - contrast), 0.0, 1.0) *
    1.0 /
    contrast;

  gl_FragColor = vec4(col, opacity);
}`, yD = `varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;
uniform sampler2D videoMap;
uniform float contrast;
uniform float opacity;

#define EPSILON (1e-6)

void main() {
  vec3 baseColor =
    clamp(texture2D(videoMap, vUv).rgb - vec3(1.0 - contrast), 0.0, 1.0) /
    contrast;
  vec3 viewDir = normalize(cameraPosition - vPosition);
  vec3 normal = normalize(vNormal);
  float lighting = smoothstep(
    0.0,
    1.0,
    max(dot(normal, viewDir), contrast * 0.85)
  );
  vec3 col = baseColor * lighting;
  gl_FragColor = vec4(col, opacity);
}`, AD = `attribute vec4 weightsAtt;
attribute vec4 bindingsAtt;

uniform mat4 boneTransforms[25];
varying vec2 vUv;

void main() {
  vUv = uv;
  
  vec4 totalAnimatedPos = vec4(0.0);
  for (int i = 0; i < 4; i++) {
    int index = int(bindingsAtt[i]);
    if (index == -1 || index == 0) {
      totalAnimatedPos = vec4(position, 1.0);
      break;
    }
    vec4 localAnimatedPos = boneTransforms[index] * vec4(position, 1.0);
    totalAnimatedPos += localAnimatedPos * weightsAtt[i];
  }
  gl_Position =
    projectionMatrix * modelViewMatrix * vec4(totalAnimatedPos.xyz, 1.0);
}`, _D = `attribute vec4 weightsAtt;
attribute vec4 bindingsAtt;

uniform mat4 boneTransforms[25];
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
  vUv = uv;
  vNormal = normal;

  
  vec4 totalAnimatedPos = vec4(0.0);
  for (int i = 0; i < 4; i++) {
    int index = int(bindingsAtt[i]);
    if (index == -1 || index == 0) {
      totalAnimatedPos = vec4(position, 1.0);
      break;
    }
    vec4 localAnimatedPos = boneTransforms[index] * vec4(position, 1.0);
    totalAnimatedPos += localAnimatedPos * weightsAtt[i];
  }
  gl_Position =
    projectionMatrix * modelViewMatrix * vec4(totalAnimatedPos.xyz, 1.0);
  vPosition = mat3(modelViewMatrix) * position;
}`;
const By = (t, e = BE, r = 0.98) => new Promise((u, I) => {
  try {
    const E = document.createElement("canvas");
    E.width = t.videoWidth, E.height = t.videoHeight;
    const k = E.getContext("2d");
    k.translate(0, E.height), k.scale(1, -1), k.drawImage(t, 0, 0, E.width, E.height);
    const g = E.toDataURL(e, r), w = new Image();
    w.src = g, new Wa.TextureLoader().load(g, u);
  } catch (E) {
    I(E);
  }
}), hu = (t, e) => String(t).padStart(e, "0"), wm = (t) => {
  const e = /* @__PURE__ */ new Date(), r = e.getFullYear(), u = hu(e.getMonth() + 1, 2), I = hu(e.getDate(), 2), E = {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: !0
  }, g = new Intl.DateTimeFormat("en-US", E).format(e), [w, B] = g.split(" "), [c, d, m] = w.split(/[: ]/), b = `${r}-${u}-${I}`, y = `${hu(c, 2)}-${hu(d, 2)}-${hu(m, 2)}${B ? "-" + B : ""}`;
  return `8i.com@${b}-${y}.${t}`;
};
class bD {
  setup(e) {
    this.player = e, e.setupTextures = this.setupTextures.bind(e), e.setupMaterials = this.setupMaterials.bind(e), e.setupMesh = this.setupMesh.bind(e), e.copyVideoToStagingTexture = this.copyVideoToStagingTexture.bind(e), e.updateRenderTexture = this.updateRenderTexture.bind(e), e.createTexture = this.createTexture.bind(e), e.createFramebuffer = this.createFramebuffer.bind(e), e.createPixelBuffer = this.createPixelBuffer.bind(e), e.processTimecode = this.processTimecode.bind(e), e.saveFrameAsGLTF = this.saveFrameAsGLTF.bind(e), e.saveFrameAsUSDZ = this.saveFrameAsUSDZ.bind(e), e.saveFrameAsScreenshot = this.saveFrameAsScreenshot.bind(e), e.getFrameAsScreenshot = this.getFrameAsScreenshot.bind(e), e.handleVideoResolutionChange = this.handleVideoResolutionChange.bind(e), e.setOpacity = this.setOpacity.bind(e), e.setContrast = this.setContrast.bind(e);
  }
  /**
   * Processes the timecode information from the video frame to determine the current frame number.
   * The timecode is encoded as a series of black and white pixels in the top-right corner of the video frame.
   * IMPORTANT:The width of the timecode is always 16px per bit, while the height scales with the texture resolution.
   *
   * @param videoWidth - The width of the current video frame
   */
  processTimecode(e) {
    const {
      framebuffer: r,
      gl: u,
      pixelBuffer: I,
      video: E,
      options: { displayDrawTimecodeRegion: k, displayEntireFramebuffer: g },
      playbackManager: { timecodeByteLength: w, useWebGL2: B, timecodeBuffer: c }
    } = this, [d, m, b] = Vf(e), y = e - m, T = 0;
    if (B) {
      u.bindFramebuffer(u.FRAMEBUFFER, r);
      const n = u.checkFramebufferStatus(u.FRAMEBUFFER);
      if (n !== u.FRAMEBUFFER_COMPLETE)
        return console.warn("Framebuffer is not complete. Status:", n), 0;
      u.bindBuffer(u.PIXEL_PACK_BUFFER, I), u.drawingBufferWidth, u.drawingBufferHeight, u.bufferData(u.PIXEL_PACK_BUFFER, w, u.STATIC_COPY), u.readPixels(
        y,
        T,
        m,
        b,
        u.RGBA,
        u.UNSIGNED_BYTE,
        0
        // Offset into the pixel buffer
      ), u.getBufferSubData(u.PIXEL_PACK_BUFFER, 0, c);
    } else {
      u.bindFramebuffer(u.FRAMEBUFFER, r);
      const n = u.checkFramebufferStatus(u.FRAMEBUFFER);
      if (n !== u.FRAMEBUFFER_COMPLETE)
        return console.warn("Framebuffer is not complete. Status:", n), 0;
      u.readPixels(
        y,
        T,
        m,
        b,
        u.RGBA,
        u.UNSIGNED_BYTE,
        c
      );
    }
    k && this.displayDrawTimecodeRegion(
      y,
      T,
      m,
      b
    ), g && this.debugDrawEntireFramebuffer();
  }
  handleVideoResolutionChange() {
    const {
      logger: e,
      video: { videoWidth: r, videoHeight: u }
    } = this;
    e.info(
      `Video resolution changed to ${r}x${u} - Resetting textures.`
    );
  }
  /**
   * Saves the current frame as a GLTF (binary) file.
   */
  saveFrameAsGLTF() {
    return Ca(this, arguments, function* (e = wm("glb")) {
      const { mesh: r, video: u } = this, I = !u.paused;
      let E = null, k = null, g = null;
      try {
        I && u.pause(), E = r.clone(), k = E.material.clone(), E.material = new Wa.MeshStandardMaterial(), E.material.map = yield By(u);
        const { GLTFExporter: w } = yield import("three/examples/jsm/exporters/GLTFExporter.js"), B = new w(), c = {
          onlyVisible: !1,
          binary: !0,
          embedImages: !0
        }, d = yield B.parseAsync(E, c);
        g = new Blob([d], { type: "model/gltf-binary" });
      } catch (w) {
        console.error(`Error when creating GLTF: ${w}`);
      }
      return E && (E.material = k), I && u.play(), {
        blob: g,
        filename: e
      };
    });
  }
  saveFrameAsUSDZ() {
    return Ca(this, arguments, function* (e = wm("usdz")) {
      const { mesh: r, video: u } = this, I = !u.paused;
      let E = null;
      const k = null;
      let g = null;
      try {
        I && u.pause(), E = r.clone();
        const w = E.material.clone();
        E.material = new Wa.MeshStandardMaterial(), E.material.map = yield By(u);
        const { USDZExporter: B } = yield import("three/examples/jsm/exporters/USDZExporter.js"), c = new B(), d = {
          maxTextureSize: 1 / 0,
          quickLookCompatible: !0
        }, m = yield c.parseAsync(E, d);
        g = new Blob([m], {
          type: "model/vnd.usdz+zip"
        });
      } catch (w) {
        console.error(`Error when creating USDZ: ${w}`);
      }
      return E.material = k, I && u.play(), {
        blob: g,
        filename: e
      };
    });
  }
  getFrameAsScreenshot() {
    return Ca(this, null, function* () {
      const { renderer: e } = this;
      return new Promise((r, u) => {
        try {
          e.domElement.toBlob(r);
        } catch (I) {
          reject(I);
        }
      });
    });
  }
  saveFrameAsScreenshot() {
    return Ca(this, arguments, function* (e = wm("png")) {
      const r = yield this.getFrameAsScreenshot();
      r.name = e, Y0(r, e);
    });
  }
  setupTextures() {
    const {
      gl: e,
      renderer: r,
      deviceCapabilities: { anisotropicExtension: u }
    } = this, I = this.createTexture(), E = this.createFramebuffer(I), k = this.createTexture(), g = this.createPixelBuffer();
    if (u) {
      e.bindTexture(e.TEXTURE_2D, k);
      const B = Math.min(
        10,
        e.getParameter(u.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      );
      e.texParameterf(
        e.TEXTURE_2D,
        u.TEXTURE_MAX_ANISOTROPY_EXT,
        B
      );
    }
    e.bindTexture(e.TEXTURE_2D, null);
    const w = r.properties.get(k);
    w.__webglTexture = k, this.pixelBuffer = g, this.framebuffer = E, this.stagingTexture = I, this.renderTexture = k;
  }
  setupMaterials() {
    const {
      renderTexture: e,
      options: { enableDirectionalLight: r, opacity: u, contrast: I }
    } = this, E = new Array(ME);
    E.fill(new Wa.Matrix4());
    const k = Wa.UniformsUtils.clone(Wa.ShaderMaterial.uniforms);
    k.videoMap = new Wa.Uniform(e), k.opacity = new Wa.Uniform(u), k.contrast = new Wa.Uniform(I), k.boneTransforms = new Wa.Uniform(E);
    const g = new Wa.ShaderMaterial({
      glslVersion: Wa.GLSL1,
      defaultAttributeValues: {
        weightsAtt: [0, 0, 0, 0],
        bindingsAtt: [0, 0, 0, 0]
      },
      uniforms: k,
      vertexShader: r ? _D : AD,
      fragmentShader: r ? yD : CD,
      transparent: !1,
      depthTest: !0,
      depthWrite: !0,
      side: Wa.DoubleSide
    });
    this.defaultMaterial = g;
  }
  setOpacity(e) {
    const { logger: r } = this;
    if (!this.mesh) {
      r.warn(`setOpacity: ${e} - No mesh available`);
      return;
    }
    r.debug(`setOpacity: ${e}`);
    const {
      mesh: { material: u }
    } = this;
    u.uniforms.opacity.value = e;
  }
  setContrast(e) {
    const { logger: r } = this;
    if (!this.mesh) {
      r.warn(`setContrast: ${e} - No mesh available`);
      return;
    }
    r.debug(`setContrast: ${e}`);
    const {
      mesh: { material: u }
    } = this;
    u.uniforms.contrast.value = e;
  }
  setupMesh() {
    const { defaultMaterial: e } = this, r = new Wa.Mesh(void 0, e);
    if (!r)
      throw new Error("Failed to initalize mesh");
    this.mesh = r;
  }
  copyVideoToStagingTexture() {
    const { gl: e, stagingTexture: r, video: u } = this;
    e.bindTexture(e.TEXTURE_2D, r), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, u), e.bindTexture(e.TEXTURE_2D, null);
  }
  /**
   * Updates the render texture with the current video frame.
   */
  updateRenderTexture() {
    const {
      gl: e,
      renderTexture: r,
      framebuffer: u,
      video: { videoWidth: I, videoHeight: E }
    } = this;
    e.bindTexture(e.TEXTURE_2D, r), e.bindFramebuffer(e.FRAMEBUFFER, u), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.copyTexImage2D(
      e.TEXTURE_2D,
      0,
      e.RGBA,
      0,
      // x
      0,
      // y
      I,
      // width
      E,
      // height
      0
    ), e.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  /**
   * Create a new WebGL texture with default values.
   */
  createTexture() {
    const { gl: e } = this, r = e.createTexture();
    if (!r)
      throw new Error("Failed to create WebGL texture");
    return e.bindTexture(e.TEXTURE_2D, r), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !1), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE), e.texImage2D(
      e.TEXTURE_2D,
      0,
      e.RGB,
      kE,
      LE,
      0,
      e.RGB,
      e.UNSIGNED_BYTE,
      null
    ), e.bindTexture(e.TEXTURE_2D, null), r;
  }
  /**
   * Create a new WebGL framebuffer with default values.
   * @param texture
   */
  createFramebuffer(e) {
    const { gl: r } = this, u = r.createFramebuffer();
    if (!u)
      throw new Error("Failed to create WebGL framebuffer");
    return r.bindFramebuffer(r.FRAMEBUFFER, u), r.framebufferTexture2D(
      r.FRAMEBUFFER,
      r.COLOR_ATTACHMENT0,
      r.TEXTURE_2D,
      e,
      0
    ), r.bindFramebuffer(r.FRAMEBUFFER, null), u;
  }
  /**
   * Create a new pixel buffer with default values.
   * The buffer is used in `timecode` in order to hold the current frame's
   * frame number.
   */
  createPixelBuffer() {
    const { gl: e } = this, r = e.createBuffer();
    if (!r)
      throw new Error("Failed to create WebGL pixel buffer");
    e.bindBuffer(e.PIXEL_PACK_BUFFER, r);
    const u = Or * Uf * Sg, I = new Uint8Array(u);
    return e.bufferData(e.PIXEL_PACK_BUFFER, I, e.STATIC_COPY), e.bindBuffer(e.PIXEL_PACK_BUFFER, null), r;
  }
}
const SD = {
  abr: !0,
  loop: !0,
  autoplay: !0,
  muted: !0,
  video: void 0,
  targetFPS: -1,
  maximumTextureSize: 1 / 0,
  displayDebugCanvas: !1,
  //The debugCanvas is the black box that displays the video timecode and framerate
  displayTimecodeInDebugCanvas: !1,
  //this is the timecode within the debugCanvas
  displayTimecodeVideoOrigin: !1,
  //this shows the actual video texture we are reading the timecode from
  displayDrawTimecodeRegion: !1,
  //this draws a red box around the timecode region of the timecode video origin
  displayEntireFramebuffer: !1,
  //this draws the entire video texture on the screen with a red box around it. It can catch discrepancies between the video texture and the timecode video origin
  displayFramerate: !1,
  licenseServerURL: void 0,
  enableDirectionalLight: !_g,
  opacity: DE,
  contrast: RE
}, vm = 320, Em = 96, Tm = Or, ig = 5;
class qh extends EventTarget {
  constructor(e, r) {
    super(), this.logger = null, this.fpsMeter = null, this.options = Da({}, SD), this.gl = null, this.renderer = null, this.video = null, this.canvas = null, this.implementation = null, this.qualityManager = null, this.playbackManager = null, this.meshSourceBuffer = null, this.player = null, this.mesh = null, this.stagingTexture = null, this.renderTexture = null, this.pixelBuffer = null, this.framebuffer = null, this.defaultMaterial = null, this.isInitialized = !1, this.isRendering = !1, this.isLoadingManifest = !1, this.loadManifestError = null, this.lastFrame = 0, this.manifestSrc = null, this.previousVideoWidth = 0, this.previousVideoHeight = 0, this.deviceCapabilities = {
      isMobile: _g,
      isTablet: bE,
      isDesktop: _E,
      isSafari: OA,
      webGL2: !1,
      requestVideoFrameCallback: !1,
      anisotropicExtension: !1,
      webWorkers: !1,
      supportImmersiveVR: !1,
      supportImmersiveAR: !1
    }, this.initialize = () => Ca(this, null, function* () {
      this.isInitialized || (yield this.installMediaSourcePolyfills(), this.setupPlayerEventListeners(), this.setupPublicAPI(), yield this.checkAsyncDeviceCapabilities(), this.isInitialized = !0);
    }), this.checkDeviceCapabilities = () => Ca(this, null, function* () {
      const { gl: I, logger: E, deviceCapabilities: k } = this;
      k.webGL2 = lT(), k.requestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, k.anisotropicExtension = I.getExtension("EXT_texture_filter_anisotropic") || I.getExtension("MOZ_EXT_texture_filter_anisotropic") || I.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), k.webWorkers = !!window.Worker, E.silly("Capabilities:", JSON.stringify(k));
    }), this.checkAsyncDeviceCapabilities = () => Ca(this, null, function* () {
      const { logger: I, deviceCapabilities: E } = this;
      let k = !1, g = !1;
      try {
        if (!navigator.xr || !navigator.xr.isSessionSupported || !navigator.xr.requestSession)
          throw new Error("Immersive VR support cannot be determined.");
        k = yield navigator.xr.isSessionSupported(
          PE
        );
      } catch (w) {
        I.warn(`Could not determine immersive VR support: ${w.stack}`);
      }
      E.supportImmersiveVR = k;
      try {
        if (!navigator.xr || !navigator.xr.isSessionSupported || !navigator.xr.requestSession)
          throw new Error("Immersive VR support cannot be determined.");
        g = yield navigator.xr.isSessionSupported(
          FE
        );
      } catch (w) {
        I.warn(`Could not determine immersive VR support: ${w.stack}`);
      }
      E.supportImmersiveAR = g, I.silly("Capabilities:", JSON.stringify(E));
    }), this.onManifestLoaded = ({ data: I }) => {
      const { qualityManager: E } = this;
      try {
        E.parseManifest(I);
        const { framerates: k, meshRepresentations: g, videoRepresentations: w } = E;
        this.dispatchEvent(
          oD(
            k,
            g,
            w
          )
        );
      } catch (k) {
        const g = Dy(k);
        this.dispatchEvent(
          _u(`Could not parse manifest: ${g}`)
        );
      }
    }, this.onStreamInitialized = (I) => {
      const { logger: E } = this;
      E.silly("onStreamInitialized", I);
    }, this.onPlayerError = (I) => {
      const { logger: E } = this, { error: k } = I, g = Dy(k);
      if (this.isLoadingManifest && (this.loadManifestError = k), k.code === ra.MediaPlayer.errors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE) {
        this.dispatchEvent(
          _u(`Could not obtain stream keys: ${g}`)
        );
        return;
      }
      E.error(g), this.dispatchEvent(_u(g));
    }, this.onQualityChange = (I) => {
      this.dispatchEvent(G0(I.detail));
    }, this.onFramerateChange = (I) => {
      this.dispatchEvent(z0(I.detail));
    }, this.onBufferEmpty = () => {
    }, this.onBufferLoaded = () => {
    }, this.logger = new Qg("8i Web Player"), this.options = Da(Da({}, this.options), r), this.renderer = e, this.logger.silly("DashPlayer settings:", this.options), this.gl = e.getContext(), this.checkDeviceCapabilities(), this.setupTextureVideoElement(), this.setupDebugCanvasElement(), new bD().setup(this), this.setupTextures(), this.setupMaterials(), this.setupMesh(), this.setupDashPlayer(), this.setupQualityManager(), this.setupPlaybackManager();
  }
  // The following methods must be implemented in `DashPlayerWebGLImplementation``
  setupTextures() {
    throw new Error(lr);
  }
  setupMaterials() {
    throw new Error(lr);
  }
  setupMesh() {
    throw new Error(lr);
  }
  copyVideoToStagingTexture() {
    throw new Error(lr);
  }
  processTimecode() {
    throw new Error(lr);
  }
  saveFrame() {
    return Ca(this, null, function* () {
      let e = null;
      const r = $r.iOS();
      r ? e = yield this.saveFrameAsUSDZ() : e = yield this.saveFrameAsGLTF();
      const { blob: u, filename: I } = e;
      if (u) {
        if (r) {
          const E = URL.createObjectURL(u), k = new URL(E, window.location.href), g = document.createElement("a"), w = document.createElement("img");
          g.appendChild(w), g.setAttribute("rel", "ar"), g.setAttribute("href", k.toString()), g.setAttribute("download", I), g.style.display = "none", g.click(), URL.revokeObjectURL(E);
          return;
        }
        Y0(u, I);
      }
    });
  }
  saveFrameAsGLTF() {
    return Ca(this, null, function* () {
      throw new Error(lr);
    });
  }
  saveFrameAsUSDZ() {
    return Ca(this, null, function* () {
      throw new Error(lr);
    });
  }
  saveFrameAsScreenshot() {
    return Ca(this, null, function* () {
      throw new Error(lr);
    });
  }
  getFrameAsScreenshot() {
    return Ca(this, null, function* () {
      throw new Error(lr);
    });
  }
  /**
   * Updates the render texture with the current video frame.
   */
  updateRenderTexture() {
    throw new Error(lr);
  }
  /**
   * Creates the underlying Dash.js `MediaPlayer` instance.
   */
  setupDashPlayer() {
    this.player = ra.MediaPlayer().create();
  }
  setupQualityManager() {
    this.qualityManager = new ID(this);
  }
  setupPlaybackManager() {
    this.playbackManager = new rD(this);
  }
  reset() {
    return Ca(this, null, function* () {
      const { logger: e, player: r, meshSourceBuffer: u, playbackManager: I } = this;
      e.debug("Resetting player."), r && r.reset(), I && I.reset(), u && u.reset();
    });
  }
  /**
   * Initializes the player, if applicable and loads the specified 8i MPD manifest.
   */
  loadManifest(e) {
    return Ca(this, null, function* () {
      const { logger: r, mesh: u } = this;
      this.loadManifestError = null, this.isLoadingManifest = !1, this.isRendering = !1, r.debug(`Loading manifest: ${e}`), this.dispatchEvent(sD(e)), this.isTextureAllocated = !1, u.visible && (u.visible = !1);
      const {
        player: I,
        qualityManager: E,
        video: k,
        options: { licenseServerURL: g, autoplay: w }
      } = this;
      this.isInitialized ? yield this.reset() : yield this.initialize(), this.manifestSrc = e, yield this.qualityManager.configure();
      let B;
      for (TR(g) && (B = {
        "org.w3.clearkey": {
          serverURL: g
        }
      }), B && (I.setProtectionData(B), I.registerLicenseResponseFilter((c) => Ca(this, null, function* () {
        const {
          url: d,
          data: { type: m, keys: b }
        } = c;
        if (!this.meshSourceBuffer)
          throw new Error("No MeshSourceBuffer instance available");
        r.info(
          `Retrieved ${b.length} ${m} key(s) from ${d}.`
        );
        for (const y of c.data.keys) {
          const T = yield window.crypto.subtle.importKey(
            KE,
            {
              kty: y.kty,
              k: y.k.replace(/=/g, ""),
              alg: OE,
              ext: !0
            },
            { name: VE },
            !1,
            [UE]
          );
          this.meshSourceBuffer.setKey(T);
        }
        return this.dispatchEvent(uD()), c;
      }))), I.registerCustomCapabilitiesFilter(
        E.filterRepresentation
      ), k.src = "", this.isLoadingManifest = !0, I.initialize(k, e, !!w); !(k.readyState >= HTMLMediaElement.HAVE_METADATA); ) {
        if (this.loadManifestError !== null)
          throw console.log("Manifest error", this.loadManifestError), this.loadManifestError;
        yield $I(100);
      }
      this.isLoadingManifest = !1;
    });
  }
  setTargetFPS(e) {
    return Ca(this, null, function* () {
      const { qualityManager: r, logger: u } = this;
      if (!xf(e))
        throw new Error(`Expected a number, received: ${e}`);
      if (e !== -1 && e < 0)
        throw new Error(
          `Expected target framerate to be -1 or >= 0, received: ${e}.`
        );
      return u.debug(`Set target FPS to ${e}`), r.targetFPS = e, this.loadManifest(this.manifestSrc);
    });
  }
  setOpacity() {
    throw new Error(lr);
  }
  setContrast() {
    throw new Error(lr);
  }
  destroy() {
    const { logger: e, player: r, mesh: u, qualityManager: I } = this;
    this.dispatchEvent(dD()), this.isInitialized = !1, e.debug("Destroying instance."), r && (r.off(
      ra.MediaPlayer.events.MANIFEST_LOADED,
      this.onManifestLoaded
    ), r.off(
      ra.MediaPlayer.events.STREAM_INITIALIZED,
      this.onStreamInitialized
    ), r.off(ra.MediaPlayer.events.ERROR, this.onPlayerError)), I.unbindEvents();
    try {
      r.destroy();
    } catch (E) {
    }
    if (this.player = null, u.parent)
      try {
        u.parent.remove(u);
      } catch (E) {
      }
    this.removeVideoElement();
  }
  setupPlayerEventListeners() {
    const { player: e, qualityManager: r } = this;
    e.on(ra.MediaPlayer.events.MANIFEST_LOADED, this.onManifestLoaded), e.on(
      ra.MediaPlayer.events.STREAM_INITIALIZED,
      this.onStreamInitialized
    ), e.on(ra.MediaPlayer.events.ERROR, this.onPlayerError), r.addEventListener(
      Kf,
      this.onQualityChange
    ), r.addEventListener(
      KA,
      this.onFramerateChange
    );
  }
  setupPublicAPI() {
    const { player: e, qualityManager: r, playbackManager: u } = this;
    this.play = (...I) => u.play(...I), this.isPaused = () => u.isPaused(), this.isMuted = () => e.isMuted(), this.setIsMuted = (I) => e.setMute(!!I), this.setVolume = (I) => e.setVolume(I), this.getCurrentFrame = () => {
      const { fps: I } = r;
      return Math.floor(e.time() * I);
    }, this.getCurrentTime = () => e.time(), this.getDuration = () => e.duration(), this.getVideo = () => e.getVideoElement(), this.getMeshSourceBuffer = () => this.meshSourceBuffer, this.pause = (...I) => u.pause(...I), this.seek = (...I) => u.seek(...I);
  }
  /**
   * Creates the underlying video element which is used in order to play back the actual stream. On iOS, it is required
   * that the video element is in view.
   */
  setupTextureVideoElement() {
    const {
      options: {
        loop: e,
        muted: r,
        displayTimecodeVideoOrigin: u,
        video: I
      }
    } = this, E = I || document.createElement("video");
    if (!I) {
      if (u) {
        let k;
        const g = {
          position: "absolute",
          top: "0px",
          right: "0px"
        };
        Object.assign(E.style, g), k = document.createElement("div"), k.classList.add("video-container");
        const w = {
          // overflow: "hidden", //Turned off for debug purposes.
          zIndex: "998",
          display: "block",
          pointerEvents: "none",
          backgroundColor: "green",
          position: "fixed",
          width: `${Or * pl}px`,
          height: `${Uf}px`,
          top: `${Em}px`
        };
        Object.assign(k.style, w), document.body.append(k), k.append(E);
      } else {
        const k = {
          position: "fixed",
          top: "0px",
          right: "0px",
          width: "2px",
          height: "2px",
          zIndex: "998",
          display: "block",
          opacity: "1"
          //Originally .01
        };
        Object.assign(E.style, k), document.body.append(E);
      }
      E.style.pointerEvents = "none";
    }
    E.setAttribute("crossorigin", "anonymous"), E.setAttribute("playsinline", "playsinline"), E.setMediaKeys = () => Promise.resolve(), this.video = E, E.muted = !!r, E.loop = !!e;
  }
  /**
   * Creates the underlying video element which is used in order to play back the actual stream. On iOS, it is required
   * that the video element is in view.
   */
  setupDebugCanvasElement() {
    const {
      options: { displayDebugCanvas: e, displayFramerate: r }
    } = this;
    if (e) {
      const I = document.createElement("canvas"), E = {
        position: "fixed",
        top: "0px",
        left: "0px",
        zIndex: "998",
        // canvas.style.opacity = "0.5";
        pointerEvents: "none"
      };
      Object.assign(I.style, E), document.body.append(I), this.canvas = I;
    }
    const u = e ? 64 : 0;
    if (r) {
      const I = new FPSMeter({
        interval: 1e3,
        top: u,
        left: 0,
        zIndex: 1e3
      });
      this.fpsMeter = I;
    }
  }
  /**
   * Removes the video element, if applicable.
   */
  removeVideoElement() {
    const { video: e } = this;
    if (e) {
      if (!e.paused)
        try {
          e.pause();
        } catch (r) {
        }
      e.parentElement && e.parentElement.removeChild(e), this.video = null;
    }
  }
  /**
   * Alternative to `startRenderLoop` -  Makes use of the `requestVideoFrameCallback` API
   * in order to be optimize calling `update`. This API is not supported on all
   * browsers.
   */
  attachVideoFrameCallback() {
    const {
      /*logger, */
      video: e
    } = this, r = () => {
      this.video && (this.update(), e.requestVideoFrameCallback(r));
    };
    if (e.requestVideoFrameCallback(r), window.requestIdleCallback) {
      const u = () => {
        this.video && (this.video.paused && this.update(), window.requestIdleCallback(u));
      };
      window.requestIdleCallback(u);
    } else {
      const u = () => {
        this.video && (this.video.paused && this.update(), window.requestAnimationFrame(u));
      };
      window.requestAnimationFrame(u);
    }
  }
  startRenderLoop() {
    const e = () => {
      this.video && (this.update(), window.requestAnimationFrame(e));
    };
    window.requestAnimationFrame(e);
  }
  installMediaSourcePolyfills() {
    return Ca(this, null, function* () {
      const {
        /*logger,*/
        video: e,
        deviceCapabilities: { webWorkers: r }
      } = this, u = this, I = window.MediaSource || window.ManagedMediaSource;
      if (typeof I == "undefined") {
        this.dispatchEvent(_u("MediaSource API not available.")), yield $I(1e3), alert("MediaSource API not available.");
        return;
      }
      const E = I.prototype.addSourceBuffer, k = r === !1, g = function(...c) {
        const d = c[0];
        if (d === VI || d === XI) {
          u.meshSourceBuffer && (u.meshSourceBuffer.abort(), u.meshSourceBuffer.reset());
          const m = new AR(d, k);
          return u.meshSourceBuffer = m, m;
        }
        return E.apply(this, c);
      };
      window.MediaSource && (window.MediaSource.prototype.addSourceBuffer = g), window.ManagedMediaSource && (window.ManagedMediaSource.prototype.addSourceBuffer = g);
      const w = I.isTypeSupported, B = function(c) {
        return c === VI || c === XI ? !0 : w(c);
      };
      window.MediaSource && (window.MediaSource.isTypeSupported = B), window.ManagedMediaSource && (window.ManagedMediaSource.isTypeSupported = B);
    });
  }
  onVideoResolutionChange() {
    const {
      logger: e,
      video: { videoWidth: r, videoHeight: u }
    } = this;
    e.debug(`Video resolution changed to ${r}x${u}`);
  }
  update() {
    this.updateVideo();
  }
  updateVideo() {
    const {
      canvas: e,
      options: { displayTimecodeInDebugCanvas: r },
      logger: u,
      video: I,
      meshSourceBuffer: E,
      qualityManager: k,
      mesh: g,
      playbackManager: w,
      previousVideoWidth: B,
      previousVideoHeight: c
    } = this;
    if (!this.isInitialized)
      return;
    if (!I || !E || !E._isInitialized) {
      u.debug(
        "Cannot update video: no video or source buffer not initialized."
      );
      return;
    }
    const d = [], m = I.currentTime, { readyState: b, videoWidth: y, videoHeight: T } = I;
    (B !== y || c !== T) && (this.onVideoResolutionChange(), this.previousVideoWidth = y, this.previousVideoHeight = T, u.silly(
      `Updating buffer size in DashPlayer to ${y}x${T}`
    ), w.updateBufferSize(y, T));
    let n;
    if (e && (e.width = vm, e.height = Em, n = e.getContext("2d"), n)) {
      n.fillStyle = "#222222", n.fillRect(0, 0, vm, Em), n.fillStyle = "#ffffff";
      const yt = [];
      for (const at in k.currentRepresentations)
        at !== UA && yt.push(
          `${at}: ${k.currentRepresentations[at]}`
        );
      const Mt = yt.join(", ");
      Mt && d.push(Mt), d.push(`${k.fps} FPS`), d.push(
        `${uT(E.bytesReceived)} received`
      );
    }
    if (b < I.HAVE_ENOUGH_DATA) {
      e && d.push("Not enough data"), u.debug(`Not enough data - video ready state: ${b}`);
      return;
    }
    if (y <= WI || T <= WI) {
      e && d.push("Video too small"), u.debug(`Video too small: ${y}x${T}`);
      return;
    }
    if (e && (w.state !== N0 && w.state !== x0 && w.state !== B0 ? d.push(
      `Mismatching playback state: ${w.state}`
    ) : d.push(`playback state: ${w.state}`)), !w.checkPlayback(m)) {
      e && d.push("NO MESH AVAILABLE AT TIME");
      return;
    }
    if (this.copyVideoToStagingTexture(), this.processTimecode(y), e && n && r) {
      const yt = vm - Or * pl, [Mt, at, Bt] = Vf(y), jt = n.createImageData(
        at,
        Bt
      );
      jt.data.set(w.timecodeBuffer), n.putImageData(jt, yt, 0);
      let At = "";
      for (let Ce = 0, ne = 0; Ce < pl; ++Ce) {
        const Ht = Ce * Or + (Or >> 1), Le = Tm >> 1;
        jt.data[ne] < 127 ? (n.fillStyle = "black", At += "0") : (n.fillStyle = "white", At += "1"), n.fillRect(
          yt + (Ht - ig / 2),
          Le - ig / 2,
          ig,
          ig
        ), ne += Sg * Or;
      }
      n.fillStyle = "#ffffff", n.fillText(
        `${At}`,
        yt,
        Tm + 12
      );
    }
    const l = w.process(), { timescale: h, frameDuration: p } = E, z = m * h, V = Math.floor(z / p) * p / p, Q = Math.floor(V / pu) * pu;
    e && d.push(`timecodeFrame: ${l}`);
    let vt = Q + l;
    V - vt > jI ? vt = vt + pu : vt - V > jI && (vt = vt - pu), e && n && (n.fillStyle = "#ffffff", d.push(`wrapped frame: ${vt}`));
    const Lt = (yt) => {
      if (!this.canvas) return;
      const Mt = this.canvas.getContext("2d");
      if (!Mt) {
        u.warn("Canvas context not found");
        return;
      }
      let at = 12;
      const Bt = Tm;
      for (const jt of yt)
        Mt.fillText(jt, 8, at), at += Bt;
    }, zt = E.getFrame(vt);
    let X = !1;
    if (zt || (e && d.push("MISS"), u.debug(
      `Could not find sample at frame: ${vt}, current time: ${m}`
    ), X = !0), X) {
      e && (d.push("MISS (fix: time)"), Lt(d));
      return;
    }
    this.lastFrame = vt;
    const { geometry: D } = zt;
    g.geometry.dispose(), g.geometry = D, g.visible || (g.visible = !0), this.isRendering || (u.silly(
      `Initial sample can be rendered at frame: ${vt}, current time: ${m}`
    ), this.isRendering = !0, this.dispatchEvent(lD())), e && Lt(d), this.updateRenderTexture();
  }
}
typeof window != "undefined" && (window.DashPlayer = qh);
typeof globalThis != "undefined" && (globalThis.DashPlayer = qh);
typeof global != "undefined" && (global.DashPlayer = qh);
export {
  qh as default
};
