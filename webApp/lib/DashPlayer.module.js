var Zh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Tg(Et) {
  return Et && Et.__esModule && Object.prototype.hasOwnProperty.call(Et, "default") ? Et.default : Et;
}
var Uu = { exports: {} };
/*! For license information please see dash.all.min.js.LICENSE.txt */
(function(Et, t) {
  (function(r, c) {
    Et.exports = c();
  })(self, function() {
    return function() {
      var r = { 5358: function(L, h, b) {
        var A = { "./af": 9066, "./af.js": 9066, "./ar": 1110, "./ar-dz": 4261, "./ar-dz.js": 4261, "./ar-kw": 7717, "./ar-kw.js": 7717, "./ar-ly": 7060, "./ar-ly.js": 7060, "./ar-ma": 2757, "./ar-ma.js": 2757, "./ar-ps": 8490, "./ar-ps.js": 8490, "./ar-sa": 735, "./ar-sa.js": 735, "./ar-tn": 5385, "./ar-tn.js": 5385, "./ar.js": 1110, "./az": 6190, "./az.js": 6190, "./be": 1448, "./be.js": 1448, "./bg": 7890, "./bg.js": 7890, "./bm": 6832, "./bm.js": 6832, "./bn": 7193, "./bn-bd": 196, "./bn-bd.js": 196, "./bn.js": 7193, "./bo": 6682, "./bo.js": 6682, "./br": 1133, "./br.js": 1133, "./bs": 1214, "./bs.js": 1214, "./ca": 7357, "./ca.js": 7357, "./cs": 1659, "./cs.js": 1659, "./cv": 3944, "./cv.js": 3944, "./cy": 9381, "./cy.js": 9381, "./da": 8782, "./da.js": 8782, "./de": 4722, "./de-at": 2170, "./de-at.js": 2170, "./de-ch": 1020, "./de-ch.js": 1020, "./de.js": 4722, "./dv": 9295, "./dv.js": 9295, "./el": 3372, "./el.js": 3372, "./en-au": 3797, "./en-au.js": 3797, "./en-ca": 8479, "./en-ca.js": 8479, "./en-gb": 4086, "./en-gb.js": 4086, "./en-ie": 3309, "./en-ie.js": 3309, "./en-il": 150, "./en-il.js": 150, "./en-in": 2332, "./en-in.js": 2332, "./en-nz": 2239, "./en-nz.js": 2239, "./en-sg": 5501, "./en-sg.js": 5501, "./eo": 325, "./eo.js": 325, "./es": 4049, "./es-do": 8143, "./es-do.js": 8143, "./es-mx": 1075, "./es-mx.js": 1075, "./es-us": 246, "./es-us.js": 246, "./es.js": 4049, "./et": 180, "./et.js": 180, "./eu": 9707, "./eu.js": 9707, "./fa": 4576, "./fa.js": 4576, "./fi": 3016, "./fi.js": 3016, "./fil": 2158, "./fil.js": 2158, "./fo": 5790, "./fo.js": 5790, "./fr": 5097, "./fr-ca": 8030, "./fr-ca.js": 8030, "./fr-ch": 3669, "./fr-ch.js": 3669, "./fr.js": 5097, "./fy": 8664, "./fy.js": 8664, "./ga": 409, "./ga.js": 409, "./gd": 4198, "./gd.js": 4198, "./gl": 2638, "./gl.js": 2638, "./gom-deva": 9871, "./gom-deva.js": 9871, "./gom-latn": 2624, "./gom-latn.js": 2624, "./gu": 2053, "./gu.js": 2053, "./he": 278, "./he.js": 278, "./hi": 8818, "./hi.js": 8818, "./hr": 9543, "./hr.js": 9543, "./hu": 4630, "./hu.js": 4630, "./hy-am": 2417, "./hy-am.js": 2417, "./id": 424, "./id.js": 424, "./is": 7213, "./is.js": 7213, "./it": 8, "./it-ch": 4354, "./it-ch.js": 4354, "./it.js": 8, "./ja": 6076, "./ja.js": 6076, "./jv": 7289, "./jv.js": 7289, "./ka": 6149, "./ka.js": 6149, "./kk": 2075, "./kk.js": 2075, "./km": 4001, "./km.js": 4001, "./kn": 4360, "./kn.js": 4360, "./ko": 5071, "./ko.js": 5071, "./ku": 1209, "./ku-kmr": 6882, "./ku-kmr.js": 6882, "./ku.js": 1209, "./ky": 4125, "./ky.js": 4125, "./lb": 8531, "./lb.js": 8531, "./lo": 5784, "./lo.js": 5784, "./lt": 4985, "./lt.js": 4985, "./lv": 1991, "./lv.js": 1991, "./me": 3507, "./me.js": 3507, "./mi": 6959, "./mi.js": 6959, "./mk": 7441, "./mk.js": 7441, "./ml": 9844, "./ml.js": 9844, "./mn": 4302, "./mn.js": 4302, "./mr": 1930, "./mr.js": 1930, "./ms": 4457, "./ms-my": 5748, "./ms-my.js": 5748, "./ms.js": 4457, "./mt": 3980, "./mt.js": 3980, "./my": 2639, "./my.js": 2639, "./nb": 5953, "./nb.js": 5953, "./ne": 5876, "./ne.js": 5876, "./nl": 7475, "./nl-be": 493, "./nl-be.js": 493, "./nl.js": 7475, "./nn": 9221, "./nn.js": 9221, "./oc-lnc": 6261, "./oc-lnc.js": 6261, "./pa-in": 4288, "./pa-in.js": 4288, "./pl": 5813, "./pl.js": 5813, "./pt": 2845, "./pt-br": 7078, "./pt-br.js": 7078, "./pt.js": 2845, "./ro": 6122, "./ro.js": 6122, "./ru": 936, "./ru.js": 936, "./sd": 2642, "./sd.js": 2642, "./se": 529, "./se.js": 529, "./si": 149, "./si.js": 149, "./sk": 2051, "./sk.js": 2051, "./sl": 5306, "./sl.js": 5306, "./sq": 4301, "./sq.js": 4301, "./sr": 2452, "./sr-cyrl": 555, "./sr-cyrl.js": 555, "./sr.js": 2452, "./ss": 395, "./ss.js": 395, "./sv": 4600, "./sv.js": 4600, "./sw": 6687, "./sw.js": 6687, "./ta": 5102, "./ta.js": 5102, "./te": 1298, "./te.js": 1298, "./tet": 9028, "./tet.js": 9028, "./tg": 8680, "./tg.js": 8680, "./th": 7093, "./th.js": 7093, "./tk": 2668, "./tk.js": 2668, "./tl-ph": 3890, "./tl-ph.js": 3890, "./tlh": 6717, "./tlh.js": 6717, "./tr": 6475, "./tr.js": 6475, "./tzl": 911, "./tzl.js": 911, "./tzm": 6552, "./tzm-latn": 8648, "./tzm-latn.js": 8648, "./tzm.js": 6552, "./ug-cn": 419, "./ug-cn.js": 419, "./uk": 6073, "./uk.js": 6073, "./ur": 210, "./ur.js": 210, "./uz": 9226, "./uz-latn": 4010, "./uz-latn.js": 4010, "./uz.js": 9226, "./vi": 3272, "./vi.js": 3272, "./x-pseudo": 8780, "./x-pseudo.js": 8780, "./yo": 6201, "./yo.js": 6201, "./zh-cn": 6893, "./zh-cn.js": 6893, "./zh-hk": 6977, "./zh-hk.js": 6977, "./zh-mo": 4068, "./zh-mo.js": 4068, "./zh-tw": 217, "./zh-tw.js": 217 };
        function l(u) {
          var g = o(u);
          return b(g);
        }
        function o(u) {
          if (!b.o(A, u)) {
            var g = new Error("Cannot find module '" + u + "'");
            throw g.code = "MODULE_NOT_FOUND", g;
          }
          return A[u];
        }
        l.keys = function() {
          return Object.keys(A);
        }, l.resolve = o, L.exports = l, l.id = 5358;
      }, 7267: function(L, h) {
        h.byteLength = function(S) {
          var e = g(S), n = e[0], d = e[1];
          return 3 * (n + d) / 4 - d;
        }, h.toByteArray = function(S) {
          var e, n, d = g(S), _ = d[0], p = d[1], P = new l(function(dt, xt, Nt) {
            return 3 * (xt + Nt) / 4 - Nt;
          }(0, _, p)), $ = 0, ot = p > 0 ? _ - 4 : _;
          for (n = 0; n < ot; n += 4) e = A[S.charCodeAt(n)] << 18 | A[S.charCodeAt(n + 1)] << 12 | A[S.charCodeAt(n + 2)] << 6 | A[S.charCodeAt(n + 3)], P[$++] = e >> 16 & 255, P[$++] = e >> 8 & 255, P[$++] = 255 & e;
          return p === 2 && (e = A[S.charCodeAt(n)] << 2 | A[S.charCodeAt(n + 1)] >> 4, P[$++] = 255 & e), p === 1 && (e = A[S.charCodeAt(n)] << 10 | A[S.charCodeAt(n + 1)] << 4 | A[S.charCodeAt(n + 2)] >> 2, P[$++] = e >> 8 & 255, P[$++] = 255 & e), P;
        }, h.fromByteArray = function(S) {
          for (var e, n = S.length, d = n % 3, _ = [], p = 16383, P = 0, $ = n - d; P < $; P += p) _.push(m(S, P, P + p > $ ? $ : P + p));
          return d === 1 ? (e = S[n - 1], _.push(b[e >> 2] + b[e << 4 & 63] + "==")) : d === 2 && (e = (S[n - 2] << 8) + S[n - 1], _.push(b[e >> 10] + b[e >> 4 & 63] + b[e << 2 & 63] + "=")), _.join("");
        };
        for (var b = [], A = [], l = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", u = 0; u < 64; ++u) b[u] = o[u], A[o.charCodeAt(u)] = u;
        function g(S) {
          var e = S.length;
          if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var n = S.indexOf("=");
          return n === -1 && (n = e), [n, n === e ? 0 : 4 - n % 4];
        }
        function m(S, e, n) {
          for (var d, _, p = [], P = e; P < n; P += 3) d = (S[P] << 16 & 16711680) + (S[P + 1] << 8 & 65280) + (255 & S[P + 2]), p.push(b[(_ = d) >> 18 & 63] + b[_ >> 12 & 63] + b[_ >> 6 & 63] + b[63 & _]);
          return p.join("");
        }
        A[45] = 62, A[95] = 63;
      }, 44: function(L, h, b) {
        var A = b(7267), l = b(7986), o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        h.Buffer = m, h.SlowBuffer = function(X) {
          return +X != X && (X = 0), m.alloc(+X);
        }, h.INSPECT_MAX_BYTES = 50;
        var u = 2147483647;
        function g(X) {
          if (X > u) throw new RangeError('The value "' + X + '" is invalid for option "size"');
          var Q = new Uint8Array(X);
          return Object.setPrototypeOf(Q, m.prototype), Q;
        }
        function m(X, Q, C) {
          if (typeof X == "number") {
            if (typeof Q == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
            return n(X);
          }
          return S(X, Q, C);
        }
        function S(X, Q, C) {
          if (typeof X == "string") return function(rt, Ft) {
            if (typeof Ft == "string" && Ft !== "" || (Ft = "utf8"), !m.isEncoding(Ft)) throw new TypeError("Unknown encoding: " + Ft);
            var ne = 0 | P(rt, Ft), Vt = g(ne), Xt = Vt.write(rt, Ft);
            return Xt !== ne && (Vt = Vt.slice(0, Xt)), Vt;
          }(X, Q);
          if (ArrayBuffer.isView(X)) return function(rt) {
            if (Yt(rt, Uint8Array)) {
              var Ft = new Uint8Array(rt);
              return _(Ft.buffer, Ft.byteOffset, Ft.byteLength);
            }
            return d(rt);
          }(X);
          if (X == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof X);
          if (Yt(X, ArrayBuffer) || X && Yt(X.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Yt(X, SharedArrayBuffer) || X && Yt(X.buffer, SharedArrayBuffer))) return _(X, Q, C);
          if (typeof X == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
          var U = X.valueOf && X.valueOf();
          if (U != null && U !== X) return m.from(U, Q, C);
          var gt = function(rt) {
            if (m.isBuffer(rt)) {
              var Ft = 0 | p(rt.length), ne = g(Ft);
              return ne.length === 0 || rt.copy(ne, 0, 0, Ft), ne;
            }
            return rt.length !== void 0 ? typeof rt.length != "number" || Ht(rt.length) ? g(0) : d(rt) : rt.type === "Buffer" && Array.isArray(rt.data) ? d(rt.data) : void 0;
          }(X);
          if (gt) return gt;
          if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof X[Symbol.toPrimitive] == "function") return m.from(X[Symbol.toPrimitive]("string"), Q, C);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof X);
        }
        function e(X) {
          if (typeof X != "number") throw new TypeError('"size" argument must be of type number');
          if (X < 0) throw new RangeError('The value "' + X + '" is invalid for option "size"');
        }
        function n(X) {
          return e(X), g(X < 0 ? 0 : 0 | p(X));
        }
        function d(X) {
          for (var Q = X.length < 0 ? 0 : 0 | p(X.length), C = g(Q), U = 0; U < Q; U += 1) C[U] = 255 & X[U];
          return C;
        }
        function _(X, Q, C) {
          if (Q < 0 || X.byteLength < Q) throw new RangeError('"offset" is outside of buffer bounds');
          if (X.byteLength < Q + (C || 0)) throw new RangeError('"length" is outside of buffer bounds');
          var U;
          return U = Q === void 0 && C === void 0 ? new Uint8Array(X) : C === void 0 ? new Uint8Array(X, Q) : new Uint8Array(X, Q, C), Object.setPrototypeOf(U, m.prototype), U;
        }
        function p(X) {
          if (X >= u) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + u.toString(16) + " bytes");
          return 0 | X;
        }
        function P(X, Q) {
          if (m.isBuffer(X)) return X.length;
          if (ArrayBuffer.isView(X) || Yt(X, ArrayBuffer)) return X.byteLength;
          if (typeof X != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof X);
          var C = X.length, U = arguments.length > 2 && arguments[2] === !0;
          if (!U && C === 0) return 0;
          for (var gt = !1; ; ) switch (Q) {
            case "ascii":
            case "latin1":
            case "binary":
              return C;
            case "utf8":
            case "utf-8":
              return bn(X).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * C;
            case "hex":
              return C >>> 1;
            case "base64":
              return pn(X).length;
            default:
              if (gt) return U ? -1 : bn(X).length;
              Q = ("" + Q).toLowerCase(), gt = !0;
          }
        }
        function $(X, Q, C) {
          var U = !1;
          if ((Q === void 0 || Q < 0) && (Q = 0), Q > this.length || ((C === void 0 || C > this.length) && (C = this.length), C <= 0) || (C >>>= 0) <= (Q >>>= 0)) return "";
          for (X || (X = "utf8"); ; ) switch (X) {
            case "hex":
              return qe(this, Q, C);
            case "utf8":
            case "utf-8":
              return et(this, Q, C);
            case "ascii":
              return ae(this, Q, C);
            case "latin1":
            case "binary":
              return St(this, Q, C);
            case "base64":
              return It(this, Q, C);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return zt(this, Q, C);
            default:
              if (U) throw new TypeError("Unknown encoding: " + X);
              X = (X + "").toLowerCase(), U = !0;
          }
        }
        function ot(X, Q, C) {
          var U = X[Q];
          X[Q] = X[C], X[C] = U;
        }
        function dt(X, Q, C, U, gt) {
          if (X.length === 0) return -1;
          if (typeof C == "string" ? (U = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), Ht(C = +C) && (C = gt ? 0 : X.length - 1), C < 0 && (C = X.length + C), C >= X.length) {
            if (gt) return -1;
            C = X.length - 1;
          } else if (C < 0) {
            if (!gt) return -1;
            C = 0;
          }
          if (typeof Q == "string" && (Q = m.from(Q, U)), m.isBuffer(Q)) return Q.length === 0 ? -1 : xt(X, Q, C, U, gt);
          if (typeof Q == "number") return Q &= 255, typeof Uint8Array.prototype.indexOf == "function" ? gt ? Uint8Array.prototype.indexOf.call(X, Q, C) : Uint8Array.prototype.lastIndexOf.call(X, Q, C) : xt(X, [Q], C, U, gt);
          throw new TypeError("val must be string, number or Buffer");
        }
        function xt(X, Q, C, U, gt) {
          var rt, Ft = 1, ne = X.length, Vt = Q.length;
          if (U !== void 0 && ((U = String(U).toLowerCase()) === "ucs2" || U === "ucs-2" || U === "utf16le" || U === "utf-16le")) {
            if (X.length < 2 || Q.length < 2) return -1;
            Ft = 2, ne /= 2, Vt /= 2, C /= 2;
          }
          function Xt(Jt, he) {
            return Ft === 1 ? Jt[he] : Jt.readUInt16BE(he * Ft);
          }
          if (gt) {
            var qt = -1;
            for (rt = C; rt < ne; rt++) if (Xt(X, rt) === Xt(Q, qt === -1 ? 0 : rt - qt)) {
              if (qt === -1 && (qt = rt), rt - qt + 1 === Vt) return qt * Ft;
            } else qt !== -1 && (rt -= rt - qt), qt = -1;
          } else for (C + Vt > ne && (C = ne - Vt), rt = C; rt >= 0; rt--) {
            for (var Gt = !0, se = 0; se < Vt; se++) if (Xt(X, rt + se) !== Xt(Q, se)) {
              Gt = !1;
              break;
            }
            if (Gt) return rt;
          }
          return -1;
        }
        function Nt(X, Q, C, U) {
          C = Number(C) || 0;
          var gt = X.length - C;
          U ? (U = Number(U)) > gt && (U = gt) : U = gt;
          var rt = Q.length;
          U > rt / 2 && (U = rt / 2);
          for (var Ft = 0; Ft < U; ++Ft) {
            var ne = parseInt(Q.substr(2 * Ft, 2), 16);
            if (Ht(ne)) return Ft;
            X[C + Ft] = ne;
          }
          return Ft;
        }
        function jt(X, Q, C, U) {
          return wn(bn(Q, X.length - C), X, C, U);
        }
        function q(X, Q, C, U) {
          return wn(function(gt) {
            for (var rt = [], Ft = 0; Ft < gt.length; ++Ft) rt.push(255 & gt.charCodeAt(Ft));
            return rt;
          }(Q), X, C, U);
        }
        function I(X, Q, C, U) {
          return wn(pn(Q), X, C, U);
        }
        function pt(X, Q, C, U) {
          return wn(function(gt, rt) {
            for (var Ft, ne, Vt, Xt = [], qt = 0; qt < gt.length && !((rt -= 2) < 0); ++qt) ne = (Ft = gt.charCodeAt(qt)) >> 8, Vt = Ft % 256, Xt.push(Vt), Xt.push(ne);
            return Xt;
          }(Q, X.length - C), X, C, U);
        }
        function It(X, Q, C) {
          return Q === 0 && C === X.length ? A.fromByteArray(X) : A.fromByteArray(X.slice(Q, C));
        }
        function et(X, Q, C) {
          C = Math.min(X.length, C);
          for (var U = [], gt = Q; gt < C; ) {
            var rt, Ft, ne, Vt, Xt = X[gt], qt = null, Gt = Xt > 239 ? 4 : Xt > 223 ? 3 : Xt > 191 ? 2 : 1;
            if (gt + Gt <= C) switch (Gt) {
              case 1:
                Xt < 128 && (qt = Xt);
                break;
              case 2:
                (192 & (rt = X[gt + 1])) == 128 && (Vt = (31 & Xt) << 6 | 63 & rt) > 127 && (qt = Vt);
                break;
              case 3:
                rt = X[gt + 1], Ft = X[gt + 2], (192 & rt) == 128 && (192 & Ft) == 128 && (Vt = (15 & Xt) << 12 | (63 & rt) << 6 | 63 & Ft) > 2047 && (Vt < 55296 || Vt > 57343) && (qt = Vt);
                break;
              case 4:
                rt = X[gt + 1], Ft = X[gt + 2], ne = X[gt + 3], (192 & rt) == 128 && (192 & Ft) == 128 && (192 & ne) == 128 && (Vt = (15 & Xt) << 18 | (63 & rt) << 12 | (63 & Ft) << 6 | 63 & ne) > 65535 && Vt < 1114112 && (qt = Vt);
            }
            qt === null ? (qt = 65533, Gt = 1) : qt > 65535 && (qt -= 65536, U.push(qt >>> 10 & 1023 | 55296), qt = 56320 | 1023 & qt), U.push(qt), gt += Gt;
          }
          return function(se) {
            var Jt = se.length;
            if (Jt <= Dt) return String.fromCharCode.apply(String, se);
            for (var he = "", an = 0; an < Jt; ) he += String.fromCharCode.apply(String, se.slice(an, an += Dt));
            return he;
          }(U);
        }
        h.kMaxLength = u, m.TYPED_ARRAY_SUPPORT = function() {
          try {
            var X = new Uint8Array(1), Q = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(Q, Uint8Array.prototype), Object.setPrototypeOf(X, Q), X.foo() === 42;
          } catch {
            return !1;
          }
        }(), m.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(m.prototype, "parent", { enumerable: !0, get: function() {
          if (m.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(m.prototype, "offset", { enumerable: !0, get: function() {
          if (m.isBuffer(this)) return this.byteOffset;
        } }), m.poolSize = 8192, m.from = function(X, Q, C) {
          return S(X, Q, C);
        }, Object.setPrototypeOf(m.prototype, Uint8Array.prototype), Object.setPrototypeOf(m, Uint8Array), m.alloc = function(X, Q, C) {
          return function(U, gt, rt) {
            return e(U), U <= 0 ? g(U) : gt !== void 0 ? typeof rt == "string" ? g(U).fill(gt, rt) : g(U).fill(gt) : g(U);
          }(X, Q, C);
        }, m.allocUnsafe = function(X) {
          return n(X);
        }, m.allocUnsafeSlow = function(X) {
          return n(X);
        }, m.isBuffer = function(X) {
          return X != null && X._isBuffer === !0 && X !== m.prototype;
        }, m.compare = function(X, Q) {
          if (Yt(X, Uint8Array) && (X = m.from(X, X.offset, X.byteLength)), Yt(Q, Uint8Array) && (Q = m.from(Q, Q.offset, Q.byteLength)), !m.isBuffer(X) || !m.isBuffer(Q)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (X === Q) return 0;
          for (var C = X.length, U = Q.length, gt = 0, rt = Math.min(C, U); gt < rt; ++gt) if (X[gt] !== Q[gt]) {
            C = X[gt], U = Q[gt];
            break;
          }
          return C < U ? -1 : U < C ? 1 : 0;
        }, m.isEncoding = function(X) {
          switch (String(X).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1;
          }
        }, m.concat = function(X, Q) {
          if (!Array.isArray(X)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (X.length === 0) return m.alloc(0);
          var C;
          if (Q === void 0) for (Q = 0, C = 0; C < X.length; ++C) Q += X[C].length;
          var U = m.allocUnsafe(Q), gt = 0;
          for (C = 0; C < X.length; ++C) {
            var rt = X[C];
            if (Yt(rt, Uint8Array)) gt + rt.length > U.length ? m.from(rt).copy(U, gt) : Uint8Array.prototype.set.call(U, rt, gt);
            else {
              if (!m.isBuffer(rt)) throw new TypeError('"list" argument must be an Array of Buffers');
              rt.copy(U, gt);
            }
            gt += rt.length;
          }
          return U;
        }, m.byteLength = P, m.prototype._isBuffer = !0, m.prototype.swap16 = function() {
          var X = this.length;
          if (X % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (var Q = 0; Q < X; Q += 2) ot(this, Q, Q + 1);
          return this;
        }, m.prototype.swap32 = function() {
          var X = this.length;
          if (X % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (var Q = 0; Q < X; Q += 4) ot(this, Q, Q + 3), ot(this, Q + 1, Q + 2);
          return this;
        }, m.prototype.swap64 = function() {
          var X = this.length;
          if (X % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (var Q = 0; Q < X; Q += 8) ot(this, Q, Q + 7), ot(this, Q + 1, Q + 6), ot(this, Q + 2, Q + 5), ot(this, Q + 3, Q + 4);
          return this;
        }, m.prototype.toString = function() {
          var X = this.length;
          return X === 0 ? "" : arguments.length === 0 ? et(this, 0, X) : $.apply(this, arguments);
        }, m.prototype.toLocaleString = m.prototype.toString, m.prototype.equals = function(X) {
          if (!m.isBuffer(X)) throw new TypeError("Argument must be a Buffer");
          return this === X || m.compare(this, X) === 0;
        }, m.prototype.inspect = function() {
          var X = "", Q = h.INSPECT_MAX_BYTES;
          return X = this.toString("hex", 0, Q).replace(/(.{2})/g, "$1 ").trim(), this.length > Q && (X += " ... "), "<Buffer " + X + ">";
        }, o && (m.prototype[o] = m.prototype.inspect), m.prototype.compare = function(X, Q, C, U, gt) {
          if (Yt(X, Uint8Array) && (X = m.from(X, X.offset, X.byteLength)), !m.isBuffer(X)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof X);
          if (Q === void 0 && (Q = 0), C === void 0 && (C = X ? X.length : 0), U === void 0 && (U = 0), gt === void 0 && (gt = this.length), Q < 0 || C > X.length || U < 0 || gt > this.length) throw new RangeError("out of range index");
          if (U >= gt && Q >= C) return 0;
          if (U >= gt) return -1;
          if (Q >= C) return 1;
          if (this === X) return 0;
          for (var rt = (gt >>>= 0) - (U >>>= 0), Ft = (C >>>= 0) - (Q >>>= 0), ne = Math.min(rt, Ft), Vt = this.slice(U, gt), Xt = X.slice(Q, C), qt = 0; qt < ne; ++qt) if (Vt[qt] !== Xt[qt]) {
            rt = Vt[qt], Ft = Xt[qt];
            break;
          }
          return rt < Ft ? -1 : Ft < rt ? 1 : 0;
        }, m.prototype.includes = function(X, Q, C) {
          return this.indexOf(X, Q, C) !== -1;
        }, m.prototype.indexOf = function(X, Q, C) {
          return dt(this, X, Q, C, !0);
        }, m.prototype.lastIndexOf = function(X, Q, C) {
          return dt(this, X, Q, C, !1);
        }, m.prototype.write = function(X, Q, C, U) {
          if (Q === void 0) U = "utf8", C = this.length, Q = 0;
          else if (C === void 0 && typeof Q == "string") U = Q, C = this.length, Q = 0;
          else {
            if (!isFinite(Q)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            Q >>>= 0, isFinite(C) ? (C >>>= 0, U === void 0 && (U = "utf8")) : (U = C, C = void 0);
          }
          var gt = this.length - Q;
          if ((C === void 0 || C > gt) && (C = gt), X.length > 0 && (C < 0 || Q < 0) || Q > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          U || (U = "utf8");
          for (var rt = !1; ; ) switch (U) {
            case "hex":
              return Nt(this, X, Q, C);
            case "utf8":
            case "utf-8":
              return jt(this, X, Q, C);
            case "ascii":
            case "latin1":
            case "binary":
              return q(this, X, Q, C);
            case "base64":
              return I(this, X, Q, C);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return pt(this, X, Q, C);
            default:
              if (rt) throw new TypeError("Unknown encoding: " + U);
              U = ("" + U).toLowerCase(), rt = !0;
          }
        }, m.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        var Dt = 4096;
        function ae(X, Q, C) {
          var U = "";
          C = Math.min(X.length, C);
          for (var gt = Q; gt < C; ++gt) U += String.fromCharCode(127 & X[gt]);
          return U;
        }
        function St(X, Q, C) {
          var U = "";
          C = Math.min(X.length, C);
          for (var gt = Q; gt < C; ++gt) U += String.fromCharCode(X[gt]);
          return U;
        }
        function qe(X, Q, C) {
          var U = X.length;
          (!Q || Q < 0) && (Q = 0), (!C || C < 0 || C > U) && (C = U);
          for (var gt = "", rt = Q; rt < C; ++rt) gt += Me[X[rt]];
          return gt;
        }
        function zt(X, Q, C) {
          for (var U = X.slice(Q, C), gt = "", rt = 0; rt < U.length - 1; rt += 2) gt += String.fromCharCode(U[rt] + 256 * U[rt + 1]);
          return gt;
        }
        function Ct(X, Q, C) {
          if (X % 1 != 0 || X < 0) throw new RangeError("offset is not uint");
          if (X + Q > C) throw new RangeError("Trying to access beyond buffer length");
        }
        function de(X, Q, C, U, gt, rt) {
          if (!m.isBuffer(X)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (Q > gt || Q < rt) throw new RangeError('"value" argument is out of bounds');
          if (C + U > X.length) throw new RangeError("Index out of range");
        }
        function ze(X, Q, C, U, gt, rt) {
          if (C + U > X.length) throw new RangeError("Index out of range");
          if (C < 0) throw new RangeError("Index out of range");
        }
        function le(X, Q, C, U, gt) {
          return Q = +Q, C >>>= 0, gt || ze(X, 0, C, 4), l.write(X, Q, C, U, 23, 4), C + 4;
        }
        function Ze(X, Q, C, U, gt) {
          return Q = +Q, C >>>= 0, gt || ze(X, 0, C, 8), l.write(X, Q, C, U, 52, 8), C + 8;
        }
        m.prototype.slice = function(X, Q) {
          var C = this.length;
          (X = ~~X) < 0 ? (X += C) < 0 && (X = 0) : X > C && (X = C), (Q = Q === void 0 ? C : ~~Q) < 0 ? (Q += C) < 0 && (Q = 0) : Q > C && (Q = C), Q < X && (Q = X);
          var U = this.subarray(X, Q);
          return Object.setPrototypeOf(U, m.prototype), U;
        }, m.prototype.readUintLE = m.prototype.readUIntLE = function(X, Q, C) {
          X >>>= 0, Q >>>= 0, C || Ct(X, Q, this.length);
          for (var U = this[X], gt = 1, rt = 0; ++rt < Q && (gt *= 256); ) U += this[X + rt] * gt;
          return U;
        }, m.prototype.readUintBE = m.prototype.readUIntBE = function(X, Q, C) {
          X >>>= 0, Q >>>= 0, C || Ct(X, Q, this.length);
          for (var U = this[X + --Q], gt = 1; Q > 0 && (gt *= 256); ) U += this[X + --Q] * gt;
          return U;
        }, m.prototype.readUint8 = m.prototype.readUInt8 = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 1, this.length), this[X];
        }, m.prototype.readUint16LE = m.prototype.readUInt16LE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 2, this.length), this[X] | this[X + 1] << 8;
        }, m.prototype.readUint16BE = m.prototype.readUInt16BE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 2, this.length), this[X] << 8 | this[X + 1];
        }, m.prototype.readUint32LE = m.prototype.readUInt32LE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), (this[X] | this[X + 1] << 8 | this[X + 2] << 16) + 16777216 * this[X + 3];
        }, m.prototype.readUint32BE = m.prototype.readUInt32BE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), 16777216 * this[X] + (this[X + 1] << 16 | this[X + 2] << 8 | this[X + 3]);
        }, m.prototype.readIntLE = function(X, Q, C) {
          X >>>= 0, Q >>>= 0, C || Ct(X, Q, this.length);
          for (var U = this[X], gt = 1, rt = 0; ++rt < Q && (gt *= 256); ) U += this[X + rt] * gt;
          return U >= (gt *= 128) && (U -= Math.pow(2, 8 * Q)), U;
        }, m.prototype.readIntBE = function(X, Q, C) {
          X >>>= 0, Q >>>= 0, C || Ct(X, Q, this.length);
          for (var U = Q, gt = 1, rt = this[X + --U]; U > 0 && (gt *= 256); ) rt += this[X + --U] * gt;
          return rt >= (gt *= 128) && (rt -= Math.pow(2, 8 * Q)), rt;
        }, m.prototype.readInt8 = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 1, this.length), 128 & this[X] ? -1 * (255 - this[X] + 1) : this[X];
        }, m.prototype.readInt16LE = function(X, Q) {
          X >>>= 0, Q || Ct(X, 2, this.length);
          var C = this[X] | this[X + 1] << 8;
          return 32768 & C ? 4294901760 | C : C;
        }, m.prototype.readInt16BE = function(X, Q) {
          X >>>= 0, Q || Ct(X, 2, this.length);
          var C = this[X + 1] | this[X] << 8;
          return 32768 & C ? 4294901760 | C : C;
        }, m.prototype.readInt32LE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), this[X] | this[X + 1] << 8 | this[X + 2] << 16 | this[X + 3] << 24;
        }, m.prototype.readInt32BE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), this[X] << 24 | this[X + 1] << 16 | this[X + 2] << 8 | this[X + 3];
        }, m.prototype.readFloatLE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), l.read(this, X, !0, 23, 4);
        }, m.prototype.readFloatBE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 4, this.length), l.read(this, X, !1, 23, 4);
        }, m.prototype.readDoubleLE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 8, this.length), l.read(this, X, !0, 52, 8);
        }, m.prototype.readDoubleBE = function(X, Q) {
          return X >>>= 0, Q || Ct(X, 8, this.length), l.read(this, X, !1, 52, 8);
        }, m.prototype.writeUintLE = m.prototype.writeUIntLE = function(X, Q, C, U) {
          X = +X, Q >>>= 0, C >>>= 0, U || de(this, X, Q, C, Math.pow(2, 8 * C) - 1, 0);
          var gt = 1, rt = 0;
          for (this[Q] = 255 & X; ++rt < C && (gt *= 256); ) this[Q + rt] = X / gt & 255;
          return Q + C;
        }, m.prototype.writeUintBE = m.prototype.writeUIntBE = function(X, Q, C, U) {
          X = +X, Q >>>= 0, C >>>= 0, U || de(this, X, Q, C, Math.pow(2, 8 * C) - 1, 0);
          var gt = C - 1, rt = 1;
          for (this[Q + gt] = 255 & X; --gt >= 0 && (rt *= 256); ) this[Q + gt] = X / rt & 255;
          return Q + C;
        }, m.prototype.writeUint8 = m.prototype.writeUInt8 = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 1, 255, 0), this[Q] = 255 & X, Q + 1;
        }, m.prototype.writeUint16LE = m.prototype.writeUInt16LE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 2, 65535, 0), this[Q] = 255 & X, this[Q + 1] = X >>> 8, Q + 2;
        }, m.prototype.writeUint16BE = m.prototype.writeUInt16BE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 2, 65535, 0), this[Q] = X >>> 8, this[Q + 1] = 255 & X, Q + 2;
        }, m.prototype.writeUint32LE = m.prototype.writeUInt32LE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 4, 4294967295, 0), this[Q + 3] = X >>> 24, this[Q + 2] = X >>> 16, this[Q + 1] = X >>> 8, this[Q] = 255 & X, Q + 4;
        }, m.prototype.writeUint32BE = m.prototype.writeUInt32BE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 4, 4294967295, 0), this[Q] = X >>> 24, this[Q + 1] = X >>> 16, this[Q + 2] = X >>> 8, this[Q + 3] = 255 & X, Q + 4;
        }, m.prototype.writeIntLE = function(X, Q, C, U) {
          if (X = +X, Q >>>= 0, !U) {
            var gt = Math.pow(2, 8 * C - 1);
            de(this, X, Q, C, gt - 1, -gt);
          }
          var rt = 0, Ft = 1, ne = 0;
          for (this[Q] = 255 & X; ++rt < C && (Ft *= 256); ) X < 0 && ne === 0 && this[Q + rt - 1] !== 0 && (ne = 1), this[Q + rt] = (X / Ft | 0) - ne & 255;
          return Q + C;
        }, m.prototype.writeIntBE = function(X, Q, C, U) {
          if (X = +X, Q >>>= 0, !U) {
            var gt = Math.pow(2, 8 * C - 1);
            de(this, X, Q, C, gt - 1, -gt);
          }
          var rt = C - 1, Ft = 1, ne = 0;
          for (this[Q + rt] = 255 & X; --rt >= 0 && (Ft *= 256); ) X < 0 && ne === 0 && this[Q + rt + 1] !== 0 && (ne = 1), this[Q + rt] = (X / Ft | 0) - ne & 255;
          return Q + C;
        }, m.prototype.writeInt8 = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 1, 127, -128), X < 0 && (X = 255 + X + 1), this[Q] = 255 & X, Q + 1;
        }, m.prototype.writeInt16LE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 2, 32767, -32768), this[Q] = 255 & X, this[Q + 1] = X >>> 8, Q + 2;
        }, m.prototype.writeInt16BE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 2, 32767, -32768), this[Q] = X >>> 8, this[Q + 1] = 255 & X, Q + 2;
        }, m.prototype.writeInt32LE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 4, 2147483647, -2147483648), this[Q] = 255 & X, this[Q + 1] = X >>> 8, this[Q + 2] = X >>> 16, this[Q + 3] = X >>> 24, Q + 4;
        }, m.prototype.writeInt32BE = function(X, Q, C) {
          return X = +X, Q >>>= 0, C || de(this, X, Q, 4, 2147483647, -2147483648), X < 0 && (X = 4294967295 + X + 1), this[Q] = X >>> 24, this[Q + 1] = X >>> 16, this[Q + 2] = X >>> 8, this[Q + 3] = 255 & X, Q + 4;
        }, m.prototype.writeFloatLE = function(X, Q, C) {
          return le(this, X, Q, !0, C);
        }, m.prototype.writeFloatBE = function(X, Q, C) {
          return le(this, X, Q, !1, C);
        }, m.prototype.writeDoubleLE = function(X, Q, C) {
          return Ze(this, X, Q, !0, C);
        }, m.prototype.writeDoubleBE = function(X, Q, C) {
          return Ze(this, X, Q, !1, C);
        }, m.prototype.copy = function(X, Q, C, U) {
          if (!m.isBuffer(X)) throw new TypeError("argument should be a Buffer");
          if (C || (C = 0), U || U === 0 || (U = this.length), Q >= X.length && (Q = X.length), Q || (Q = 0), U > 0 && U < C && (U = C), U === C || X.length === 0 || this.length === 0) return 0;
          if (Q < 0) throw new RangeError("targetStart out of bounds");
          if (C < 0 || C >= this.length) throw new RangeError("Index out of range");
          if (U < 0) throw new RangeError("sourceEnd out of bounds");
          U > this.length && (U = this.length), X.length - Q < U - C && (U = X.length - Q + C);
          var gt = U - C;
          return this === X && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(Q, C, U) : Uint8Array.prototype.set.call(X, this.subarray(C, U), Q), gt;
        }, m.prototype.fill = function(X, Q, C, U) {
          if (typeof X == "string") {
            if (typeof Q == "string" ? (U = Q, Q = 0, C = this.length) : typeof C == "string" && (U = C, C = this.length), U !== void 0 && typeof U != "string") throw new TypeError("encoding must be a string");
            if (typeof U == "string" && !m.isEncoding(U)) throw new TypeError("Unknown encoding: " + U);
            if (X.length === 1) {
              var gt = X.charCodeAt(0);
              (U === "utf8" && gt < 128 || U === "latin1") && (X = gt);
            }
          } else typeof X == "number" ? X &= 255 : typeof X == "boolean" && (X = Number(X));
          if (Q < 0 || this.length < Q || this.length < C) throw new RangeError("Out of range index");
          if (C <= Q) return this;
          var rt;
          if (Q >>>= 0, C = C === void 0 ? this.length : C >>> 0, X || (X = 0), typeof X == "number") for (rt = Q; rt < C; ++rt) this[rt] = X;
          else {
            var Ft = m.isBuffer(X) ? X : m.from(X, U), ne = Ft.length;
            if (ne === 0) throw new TypeError('The value "' + X + '" is invalid for argument "value"');
            for (rt = 0; rt < C - Q; ++rt) this[rt + Q] = Ft[rt % ne];
          }
          return this;
        };
        var me = /[^+/0-9A-Za-z-_]/g;
        function bn(X, Q) {
          var C;
          Q = Q || 1 / 0;
          for (var U = X.length, gt = null, rt = [], Ft = 0; Ft < U; ++Ft) {
            if ((C = X.charCodeAt(Ft)) > 55295 && C < 57344) {
              if (!gt) {
                if (C > 56319) {
                  (Q -= 3) > -1 && rt.push(239, 191, 189);
                  continue;
                }
                if (Ft + 1 === U) {
                  (Q -= 3) > -1 && rt.push(239, 191, 189);
                  continue;
                }
                gt = C;
                continue;
              }
              if (C < 56320) {
                (Q -= 3) > -1 && rt.push(239, 191, 189), gt = C;
                continue;
              }
              C = 65536 + (gt - 55296 << 10 | C - 56320);
            } else gt && (Q -= 3) > -1 && rt.push(239, 191, 189);
            if (gt = null, C < 128) {
              if ((Q -= 1) < 0) break;
              rt.push(C);
            } else if (C < 2048) {
              if ((Q -= 2) < 0) break;
              rt.push(C >> 6 | 192, 63 & C | 128);
            } else if (C < 65536) {
              if ((Q -= 3) < 0) break;
              rt.push(C >> 12 | 224, C >> 6 & 63 | 128, 63 & C | 128);
            } else {
              if (!(C < 1114112)) throw new Error("Invalid code point");
              if ((Q -= 4) < 0) break;
              rt.push(C >> 18 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, 63 & C | 128);
            }
          }
          return rt;
        }
        function pn(X) {
          return A.toByteArray(function(Q) {
            if ((Q = (Q = Q.split("=")[0]).trim().replace(me, "")).length < 2) return "";
            for (; Q.length % 4 != 0; ) Q += "=";
            return Q;
          }(X));
        }
        function wn(X, Q, C, U) {
          for (var gt = 0; gt < U && !(gt + C >= Q.length || gt >= X.length); ++gt) Q[gt + C] = X[gt];
          return gt;
        }
        function Yt(X, Q) {
          return X instanceof Q || X != null && X.constructor != null && X.constructor.name != null && X.constructor.name === Q.name;
        }
        function Ht(X) {
          return X != X;
        }
        var Me = function() {
          for (var X = "0123456789abcdef", Q = new Array(256), C = 0; C < 16; ++C) for (var U = 16 * C, gt = 0; gt < 16; ++gt) Q[U + gt] = X[C] + X[gt];
          return Q;
        }();
      }, 6877: function(L, h) {
        var b = { parseBuffer: function(o) {
          return new A(o).parse();
        }, addBoxProcessor: function(o, u) {
          typeof o == "string" && typeof u == "function" && (l.prototype._boxProcessors[o] = u);
        }, createFile: function() {
          return new A();
        }, createBox: function(o, u, g) {
          var m = l.create(o);
          return u && u.append(m, g), m;
        }, createFullBox: function(o, u, g) {
          var m = b.createBox(o, u, g);
          return m.version = 0, m.flags = 0, m;
        }, Utils: {} };
        b.Utils.dataViewToString = function(o, u) {
          var g = u || "utf-8";
          if (typeof TextDecoder < "u") return new TextDecoder(g).decode(o);
          var m = [], S = 0;
          if (g === "utf-8") for (; S < o.byteLength; ) {
            var e = o.getUint8(S++);
            e < 128 || (e < 224 ? (e = (31 & e) << 6, e |= 63 & o.getUint8(S++)) : e < 240 ? (e = (15 & e) << 12, e |= (63 & o.getUint8(S++)) << 6, e |= 63 & o.getUint8(S++)) : (e = (7 & e) << 18, e |= (63 & o.getUint8(S++)) << 12, e |= (63 & o.getUint8(S++)) << 6, e |= 63 & o.getUint8(S++))), m.push(String.fromCharCode(e));
          }
          else for (; S < o.byteLength; ) m.push(String.fromCharCode(o.getUint8(S++)));
          return m.join("");
        }, b.Utils.utf8ToByteArray = function(o) {
          var u, g;
          if (typeof TextEncoder < "u") u = new TextEncoder().encode(o);
          else for (u = [], g = 0; g < o.length; ++g) {
            var m = o.charCodeAt(g);
            m < 128 ? u.push(m) : m < 2048 ? (u.push(192 | m >> 6), u.push(128 | 63 & m)) : m < 65536 ? (u.push(224 | m >> 12), u.push(128 | 63 & m >> 6), u.push(128 | 63 & m)) : (u.push(240 | m >> 18), u.push(128 | 63 & m >> 12), u.push(128 | 63 & m >> 6), u.push(128 | 63 & m));
          }
          return u;
        }, b.Utils.appendBox = function(o, u, g) {
          if (u._offset = o._cursor.offset, u._root = o._root ? o._root : o, u._raw = o._raw, u._parent = o, g !== -1) if (g != null) {
            var m, S = -1;
            if (typeof g == "number") S = g;
            else {
              if (typeof g == "string") m = g;
              else {
                if (typeof g != "object" || !g.type) return void o.boxes.push(u);
                m = g.type;
              }
              for (var e = 0; e < o.boxes.length; e++) if (m === o.boxes[e].type) {
                S = e + 1;
                break;
              }
            }
            o.boxes.splice(S, 0, u);
          } else o.boxes.push(u);
        }, h.parseBuffer = b.parseBuffer, h.addBoxProcessor = b.addBoxProcessor, h.createFile = b.createFile, h.createBox = b.createBox, h.createFullBox = b.createFullBox, h.Utils = b.Utils, b.Cursor = function(o) {
          this.offset = o === void 0 ? 0 : o;
        };
        var A = function(o) {
          this._cursor = new b.Cursor(), this.boxes = [], o && (this._raw = new DataView(o));
        };
        A.prototype.fetch = function(o) {
          var u = this.fetchAll(o, !0);
          return u.length ? u[0] : null;
        }, A.prototype.fetchAll = function(o, u) {
          var g = [];
          return A._sweep.call(this, o, g, u), g;
        }, A.prototype.parse = function() {
          for (this._cursor.offset = 0, this.boxes = []; this._cursor.offset < this._raw.byteLength; ) {
            var o = l.parse(this);
            if (o.type === void 0) break;
            this.boxes.push(o);
          }
          return this;
        }, A._sweep = function(o, u, g) {
          for (var m in this.type && this.type == o && u.push(this), this.boxes) {
            if (u.length && g) return;
            A._sweep.call(this.boxes[m], o, u, g);
          }
        }, A.prototype.write = function() {
          var o, u = 0;
          for (o = 0; o < this.boxes.length; o++) u += this.boxes[o].getLength(!1);
          var g = new Uint8Array(u);
          for (this._rawo = new DataView(g.buffer), this.bytes = g, this._cursor.offset = 0, o = 0; o < this.boxes.length; o++) this.boxes[o].write();
          return g.buffer;
        }, A.prototype.append = function(o, u) {
          b.Utils.appendBox(this, o, u);
        };
        var l = function() {
          this._cursor = new b.Cursor();
        };
        l.parse = function(o) {
          var u = new l();
          return u._offset = o._cursor.offset, u._root = o._root ? o._root : o, u._raw = o._raw, u._parent = o, u._parseBox(), o._cursor.offset = u._raw.byteOffset + u._raw.byteLength, u;
        }, l.create = function(o) {
          var u = new l();
          return u.type = o, u.boxes = [], u;
        }, l.prototype._boxContainers = ["dinf", "edts", "mdia", "meco", "mfra", "minf", "moof", "moov", "mvex", "stbl", "strk", "traf", "trak", "tref", "udta", "vttc", "sinf", "schi", "encv", "enca", "meta", "grpl", "prsl"], l.prototype._boxProcessors = {}, l.prototype._procField = function(o, u, g) {
          this._parsing ? this[o] = this._readField(u, g) : this._writeField(u, g, this[o]);
        }, l.prototype._procFieldArray = function(o, u, g, m) {
          var S;
          if (this._parsing) for (this[o] = [], S = 0; S < u; S++) this[o][S] = this._readField(g, m);
          else for (S = 0; S < this[o].length; S++) this._writeField(g, m, this[o][S]);
        }, l.prototype._procFullBox = function() {
          this._procField("version", "uint", 8), this._procField("flags", "uint", 24);
        }, l.prototype._procEntries = function(o, u, g) {
          var m;
          if (this._parsing) for (this[o] = [], m = 0; m < u; m++) this[o].push({}), g.call(this, this[o][m]);
          else for (m = 0; m < u; m++) g.call(this, this[o][m]);
        }, l.prototype._procSubEntries = function(o, u, g, m) {
          var S;
          if (this._parsing) for (o[u] = [], S = 0; S < g; S++) o[u].push({}), m.call(this, o[u][S]);
          else for (S = 0; S < g; S++) m.call(this, o[u][S]);
        }, l.prototype._procEntryField = function(o, u, g, m) {
          this._parsing ? o[u] = this._readField(g, m) : this._writeField(g, m, o[u]);
        }, l.prototype._procSubBoxes = function(o, u) {
          var g;
          if (this._parsing) for (this[o] = [], g = 0; g < u; g++) this[o].push(l.parse(this));
          else for (g = 0; g < u; g++) this._rawo ? this[o][g].write() : this.size += this[o][g].getLength();
        }, l.prototype._readField = function(o, u) {
          switch (o) {
            case "uint":
              return this._readUint(u);
            case "int":
              return this._readInt(u);
            case "template":
              return this._readTemplate(u);
            case "string":
              return u === -1 ? this._readTerminatedString() : this._readString(u);
            case "data":
              return this._readData(u);
            case "utf8":
              return this._readUTF8String();
            case "utf8string":
              return this._readUTF8TerminatedString();
            default:
              return -1;
          }
        }, l.prototype._readInt = function(o) {
          var u = null, g = this._cursor.offset - this._raw.byteOffset;
          switch (o) {
            case 8:
              u = this._raw.getInt8(g);
              break;
            case 16:
              u = this._raw.getInt16(g);
              break;
            case 32:
              u = this._raw.getInt32(g);
              break;
            case 64:
              var m = this._raw.getInt32(g), S = this._raw.getInt32(g + 4);
              u = m * Math.pow(2, 32) + S;
          }
          return this._cursor.offset += o >> 3, u;
        }, l.prototype._readUint = function(o) {
          var u, g, m = null, S = this._cursor.offset - this._raw.byteOffset;
          switch (o) {
            case 8:
              m = this._raw.getUint8(S);
              break;
            case 16:
              m = this._raw.getUint16(S);
              break;
            case 24:
              m = ((u = this._raw.getUint16(S)) << 8) + (g = this._raw.getUint8(S + 2));
              break;
            case 32:
              m = this._raw.getUint32(S);
              break;
            case 64:
              u = this._raw.getUint32(S), g = this._raw.getUint32(S + 4), m = u * Math.pow(2, 32) + g;
          }
          return this._cursor.offset += o >> 3, m;
        }, l.prototype._readString = function(o) {
          for (var u = "", g = 0; g < o; g++) {
            var m = this._readUint(8);
            u += String.fromCharCode(m);
          }
          return u;
        }, l.prototype._readTemplate = function(o) {
          return this._readUint(o / 2) + this._readUint(o / 2) / Math.pow(2, o / 2);
        }, l.prototype._readTerminatedString = function() {
          for (var o = ""; this._cursor.offset - this._offset < this._raw.byteLength; ) {
            var u = this._readUint(8);
            if (u === 0) break;
            o += String.fromCharCode(u);
          }
          return o;
        }, l.prototype._readData = function(o) {
          var u = o > 0 ? o : this._raw.byteLength - (this._cursor.offset - this._offset);
          if (u > 0) {
            var g = new Uint8Array(this._raw.buffer, this._cursor.offset, u);
            return this._cursor.offset += u, g;
          }
          return null;
        }, l.prototype._readUTF8String = function() {
          var o = this._raw.byteLength - (this._cursor.offset - this._offset), u = null;
          return o > 0 && (u = new DataView(this._raw.buffer, this._cursor.offset, o), this._cursor.offset += o), u && b.Utils.dataViewToString(u);
        }, l.prototype._readUTF8TerminatedString = function() {
          var o = this._raw.byteLength - (this._cursor.offset - this._offset), u = null;
          if (o > 0) {
            var g;
            for (u = new DataView(this._raw.buffer, this._cursor.offset, o), g = 0; g < o && u.getUint8(g) !== 0; g++) ;
            u = new DataView(this._raw.buffer, this._cursor.offset, g), this._cursor.offset += Math.min(g + 1, o);
          }
          return u && b.Utils.dataViewToString(u);
        }, l.prototype._parseBox = function() {
          if (this._parsing = !0, this._cursor.offset = this._offset, this._offset + 8 > this._raw.buffer.byteLength) this._root._incomplete = !0;
          else {
            switch (this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this.size) {
              case 0:
                this._raw = new DataView(this._raw.buffer, this._offset);
                break;
              case 1:
                this._offset + this.size > this._raw.buffer.byteLength ? (this._incomplete = !0, this._root._incomplete = !0) : this._raw = new DataView(this._raw.buffer, this._offset, this.largesize);
                break;
              default:
                this._offset + this.size > this._raw.buffer.byteLength ? (this._incomplete = !0, this._root._incomplete = !0) : this._raw = new DataView(this._raw.buffer, this._offset, this.size);
            }
            this._incomplete || (this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1 ? this._parseContainerBox() : this._data = this._readData());
          }
        }, l.prototype._parseFullBox = function() {
          this.version = this._readUint(8), this.flags = this._readUint(24);
        }, l.prototype._parseContainerBox = function() {
          for (this.boxes = []; this._cursor.offset - this._raw.byteOffset < this._raw.byteLength; ) this.boxes.push(l.parse(this));
        }, l.prototype.append = function(o, u) {
          b.Utils.appendBox(this, o, u);
        }, l.prototype.getLength = function() {
          if (this._parsing = !1, this._rawo = null, this.size = 0, this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1) for (var o = 0; o < this.boxes.length; o++) this.size += this.boxes[o].getLength();
          return this._data && this._writeData(this._data), this.size;
        }, l.prototype.write = function() {
          switch (this._parsing = !1, this._cursor.offset = this._parent._cursor.offset, this.size) {
            case 0:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.parent._rawo.byteLength - this._cursor.offset);
              break;
            case 1:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.largesize);
              break;
            default:
              this._rawo = new DataView(this._parent._rawo.buffer, this._cursor.offset, this.size);
          }
          if (this._procField("size", "uint", 32), this._procField("type", "string", 4), this.size === 1 && this._procField("largesize", "uint", 64), this.type === "uuid" && this._procFieldArray("usertype", 16, "uint", 8), this._boxProcessors[this.type] && this._boxProcessors[this.type].call(this), this._boxContainers.indexOf(this.type) !== -1) for (var o = 0; o < this.boxes.length; o++) this.boxes[o].write();
          return this._data && this._writeData(this._data), this._parent._cursor.offset += this.size, this.size;
        }, l.prototype._writeInt = function(o, u) {
          if (this._rawo) {
            var g = this._cursor.offset - this._rawo.byteOffset;
            switch (o) {
              case 8:
                this._rawo.setInt8(g, u);
                break;
              case 16:
                this._rawo.setInt16(g, u);
                break;
              case 32:
                this._rawo.setInt32(g, u);
                break;
              case 64:
                var m = Math.floor(u / Math.pow(2, 32)), S = u - m * Math.pow(2, 32);
                this._rawo.setUint32(g, m), this._rawo.setUint32(g + 4, S);
            }
            this._cursor.offset += o >> 3;
          } else this.size += o >> 3;
        }, l.prototype._writeUint = function(o, u) {
          if (this._rawo) {
            var g, m, S = this._cursor.offset - this._rawo.byteOffset;
            switch (o) {
              case 8:
                this._rawo.setUint8(S, u);
                break;
              case 16:
                this._rawo.setUint16(S, u);
                break;
              case 24:
                g = (16776960 & u) >> 8, m = 255 & u, this._rawo.setUint16(S, g), this._rawo.setUint8(S + 2, m);
                break;
              case 32:
                this._rawo.setUint32(S, u);
                break;
              case 64:
                m = u - (g = Math.floor(u / Math.pow(2, 32))) * Math.pow(2, 32), this._rawo.setUint32(S, g), this._rawo.setUint32(S + 4, m);
            }
            this._cursor.offset += o >> 3;
          } else this.size += o >> 3;
        }, l.prototype._writeString = function(o, u) {
          for (var g = 0; g < o; g++) this._writeUint(8, u.charCodeAt(g));
        }, l.prototype._writeTerminatedString = function(o) {
          if (o.length !== 0) {
            for (var u = 0; u < o.length; u++) this._writeUint(8, o.charCodeAt(u));
            this._writeUint(8, 0);
          }
        }, l.prototype._writeTemplate = function(o, u) {
          var g = Math.floor(u), m = (u - g) * Math.pow(2, o / 2);
          this._writeUint(o / 2, g), this._writeUint(o / 2, m);
        }, l.prototype._writeData = function(o) {
          if (o) if (this._rawo) {
            if (o instanceof Array) {
              for (var u = this._cursor.offset - this._rawo.byteOffset, g = 0; g < o.length; g++) this._rawo.setInt8(u + g, o[g]);
              this._cursor.offset += o.length;
            }
            o instanceof Uint8Array && (this._root.bytes.set(o, this._cursor.offset), this._cursor.offset += o.length);
          } else this.size += o.length;
        }, l.prototype._writeUTF8String = function(o) {
          var u = b.Utils.utf8ToByteArray(o);
          if (this._rawo) for (var g = new DataView(this._rawo.buffer, this._cursor.offset, u.length), m = 0; m < u.length; m++) g.setUint8(m, u[m]);
          else this.size += u.length;
        }, l.prototype._writeField = function(o, u, g) {
          switch (o) {
            case "uint":
              this._writeUint(u, g);
              break;
            case "int":
              this._writeInt(u, g);
              break;
            case "template":
              this._writeTemplate(u, g);
              break;
            case "string":
              u == -1 ? this._writeTerminatedString(g) : this._writeString(u, g);
              break;
            case "data":
              this._writeData(g);
              break;
            case "utf8":
              this._writeUTF8String(g);
          }
        }, l.prototype._boxProcessors.ardi = function() {
          this._procFullBox(), this._procField("audio_rendering_indication", "uint", 8);
        }, l.prototype._boxProcessors.avc1 = l.prototype._boxProcessors.avc2 = l.prototype._boxProcessors.avc3 = l.prototype._boxProcessors.avc4 = l.prototype._boxProcessors.hvc1 = l.prototype._boxProcessors.hev1 = l.prototype._boxProcessors.encv = function() {
          this._procFieldArray("reserved1", 6, "uint", 8), this._procField("data_reference_index", "uint", 16), this._procField("pre_defined1", "uint", 16), this._procField("reserved2", "uint", 16), this._procFieldArray("pre_defined2", 3, "uint", 32), this._procField("width", "uint", 16), this._procField("height", "uint", 16), this._procField("horizresolution", "template", 32), this._procField("vertresolution", "template", 32), this._procField("reserved3", "uint", 32), this._procField("frame_count", "uint", 16), this._procFieldArray("compressorname", 32, "uint", 8), this._procField("depth", "uint", 16), this._procField("pre_defined3", "int", 16), this._procField("config", "data", -1);
        }, l.prototype._boxProcessors.ctts = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(o) {
            this._procEntryField(o, "sample_count", "uint", 32), this._procEntryField(o, "sample_offset", this.version === 1 ? "int" : "uint", 32);
          });
        }, l.prototype._boxProcessors.dref = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procSubBoxes("entries", this.entry_count);
        }, l.prototype._boxProcessors.elng = function() {
          this._procFullBox(), this._procField("extended_language", "utf8string");
        }, l.prototype._boxProcessors.elst = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(o) {
            this._procEntryField(o, "segment_duration", "uint", this.version === 1 ? 64 : 32), this._procEntryField(o, "media_time", "int", this.version === 1 ? 64 : 32), this._procEntryField(o, "media_rate_integer", "int", 16), this._procEntryField(o, "media_rate_fraction", "int", 16);
          });
        }, l.prototype._boxProcessors.emsg = function() {
          this._procFullBox(), this.version == 1 ? (this._procField("timescale", "uint", 32), this._procField("presentation_time", "uint", 64), this._procField("event_duration", "uint", 32), this._procField("id", "uint", 32), this._procField("scheme_id_uri", "string", -1), this._procField("value", "string", -1)) : (this._procField("scheme_id_uri", "string", -1), this._procField("value", "string", -1), this._procField("timescale", "uint", 32), this._procField("presentation_time_delta", "uint", 32), this._procField("event_duration", "uint", 32), this._procField("id", "uint", 32)), this._procField("message_data", "data", -1);
        }, l.prototype._boxProcessors.free = l.prototype._boxProcessors.skip = function() {
          this._procField("data", "data", -1);
        }, l.prototype._boxProcessors.frma = function() {
          this._procField("data_format", "uint", 32);
        }, l.prototype._boxProcessors.ftyp = l.prototype._boxProcessors.styp = function() {
          this._procField("major_brand", "string", 4), this._procField("minor_version", "uint", 32);
          var o = -1;
          this._parsing && (o = (this._raw.byteLength - (this._cursor.offset - this._raw.byteOffset)) / 4), this._procFieldArray("compatible_brands", o, "string", 4);
        }, l.prototype._boxProcessors.hdlr = function() {
          this._procFullBox(), this._procField("pre_defined", "uint", 32), this._procField("handler_type", "string", 4), this._procFieldArray("reserved", 3, "uint", 32), this._procField("name", "string", -1);
        }, l.prototype._boxProcessors.imda = function() {
          this._procField("imda_identifier", "uint", 32), this._procField("data", "data", -1);
        }, l.prototype._boxProcessors.kind = function() {
          this._procFullBox(), this._procField("schemeURI", "utf8string"), this._procField("value", "utf8string");
        }, l.prototype._boxProcessors.labl = function() {
          this._procFullBox(), this.is_group_label = !!(1 & this.flags), this._procField("label_id", "uint", 16), this._procField("language", "utf8string"), this._procField("label", "utf8string");
        }, l.prototype._boxProcessors.mdat = function() {
          this._procField("data", "data", -1);
        }, l.prototype._boxProcessors.mdhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("timescale", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._parsing || typeof this.language != "string" || (this.language = this.language.charCodeAt(0) - 96 << 10 | this.language.charCodeAt(1) - 96 << 5 | this.language.charCodeAt(2) - 96), this._procField("language", "uint", 16), this._parsing && (this.language = String.fromCharCode(96 + (this.language >> 10 & 31), 96 + (this.language >> 5 & 31), 96 + (31 & this.language))), this._procField("pre_defined", "uint", 16);
        }, l.prototype._boxProcessors.mehd = function() {
          this._procFullBox(), this._procField("fragment_duration", "uint", this.version == 1 ? 64 : 32);
        }, l.prototype._boxProcessors.meta = function() {
          this._procFullBox();
        }, l.prototype._boxProcessors.mfhd = function() {
          this._procFullBox(), this._procField("sequence_number", "uint", 32);
        }, l.prototype._boxProcessors.mfro = function() {
          this._procFullBox(), this._procField("mfra_size", "uint", 32);
        }, l.prototype._boxProcessors.mp4a = l.prototype._boxProcessors.enca = function() {
          this._procFieldArray("reserved1", 6, "uint", 8), this._procField("data_reference_index", "uint", 16), this._procFieldArray("reserved2", 2, "uint", 32), this._procField("channelcount", "uint", 16), this._procField("samplesize", "uint", 16), this._procField("pre_defined", "uint", 16), this._procField("reserved3", "uint", 16), this._procField("samplerate", "template", 32), this._procField("esds", "data", -1);
        }, l.prototype._boxProcessors.mvhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("timescale", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._procField("rate", "template", 32), this._procField("volume", "template", 16), this._procField("reserved1", "uint", 16), this._procFieldArray("reserved2", 2, "uint", 32), this._procFieldArray("matrix", 9, "template", 32), this._procFieldArray("pre_defined", 6, "uint", 32), this._procField("next_track_ID", "uint", 32);
        }, l.prototype._boxProcessors.payl = function() {
          this._procField("cue_text", "utf8");
        }, l.prototype._boxProcessors.prft = function() {
          this._procFullBox(), this._procField("reference_track_ID", "uint", 32), this._procField("ntp_timestamp_sec", "uint", 32), this._procField("ntp_timestamp_frac", "uint", 32), this._procField("media_time", "uint", this.version == 1 ? 64 : 32);
        }, l.prototype._boxProcessors.prsl = function() {
          this._procFullBox(), this._procField("group_id", "uint", 32), this._procField("num_entities_in_group", "uint", 32), this._procEntries("entities", this.num_entities_in_group, function(o) {
            this._procEntryField(o, "entity_id", "uint", 32);
          }), 4096 & this.flags && this._procField("preselection_tag", "utf8string"), 8192 & this.flags && this._procField("selection_priority", "uint", 8), 16384 & this.flags && this._procField("interleaving_tag", "utf8string");
        }, l.prototype._boxProcessors.pssh = function() {
          this._procFullBox(), this._procFieldArray("SystemID", 16, "uint", 8), this._procField("DataSize", "uint", 32), this._procFieldArray("Data", this.DataSize, "uint", 8);
        }, l.prototype._boxProcessors.schm = function() {
          this._procFullBox(), this._procField("scheme_type", "uint", 32), this._procField("scheme_version", "uint", 32), 1 & this.flags && this._procField("scheme_uri", "string", -1);
        }, l.prototype._boxProcessors.sdtp = function() {
          this._procFullBox();
          var o = -1;
          this._parsing && (o = this._raw.byteLength - (this._cursor.offset - this._raw.byteOffset)), this._procFieldArray("sample_dependency_table", o, "uint", 8);
        }, l.prototype._boxProcessors.sidx = function() {
          this._procFullBox(), this._procField("reference_ID", "uint", 32), this._procField("timescale", "uint", 32), this._procField("earliest_presentation_time", "uint", this.version == 1 ? 64 : 32), this._procField("first_offset", "uint", this.version == 1 ? 64 : 32), this._procField("reserved", "uint", 16), this._procField("reference_count", "uint", 16), this._procEntries("references", this.reference_count, function(o) {
            this._parsing || (o.reference = (1 & o.reference_type) << 31, o.reference |= 2147483647 & o.referenced_size, o.sap = (1 & o.starts_with_SAP) << 31, o.sap |= (3 & o.SAP_type) << 28, o.sap |= 268435455 & o.SAP_delta_time), this._procEntryField(o, "reference", "uint", 32), this._procEntryField(o, "subsegment_duration", "uint", 32), this._procEntryField(o, "sap", "uint", 32), this._parsing && (o.reference_type = o.reference >> 31 & 1, o.referenced_size = 2147483647 & o.reference, o.starts_with_SAP = o.sap >> 31 & 1, o.SAP_type = o.sap >> 28 & 7, o.SAP_delta_time = 268435455 & o.sap);
          });
        }, l.prototype._boxProcessors.smhd = function() {
          this._procFullBox(), this._procField("balance", "uint", 16), this._procField("reserved", "uint", 16);
        }, l.prototype._boxProcessors.ssix = function() {
          this._procFullBox(), this._procField("subsegment_count", "uint", 32), this._procEntries("subsegments", this.subsegment_count, function(o) {
            this._procEntryField(o, "ranges_count", "uint", 32), this._procSubEntries(o, "ranges", o.ranges_count, function(u) {
              this._procEntryField(u, "level", "uint", 8), this._procEntryField(u, "range_size", "uint", 24);
            });
          });
        }, l.prototype._boxProcessors.stsd = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procSubBoxes("entries", this.entry_count);
        }, l.prototype._boxProcessors.sttg = function() {
          this._procField("settings", "utf8");
        }, l.prototype._boxProcessors.stts = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(o) {
            this._procEntryField(o, "sample_count", "uint", 32), this._procEntryField(o, "sample_delta", "uint", 32);
          });
        }, l.prototype._boxProcessors.subs = function() {
          this._procFullBox(), this._procField("entry_count", "uint", 32), this._procEntries("entries", this.entry_count, function(o) {
            this._procEntryField(o, "sample_delta", "uint", 32), this._procEntryField(o, "subsample_count", "uint", 16), this._procSubEntries(o, "subsamples", o.subsample_count, function(u) {
              this._procEntryField(u, "subsample_size", "uint", this.version === 1 ? 32 : 16), this._procEntryField(u, "subsample_priority", "uint", 8), this._procEntryField(u, "discardable", "uint", 8), this._procEntryField(u, "codec_specific_parameters", "uint", 32);
            });
          });
        }, l.prototype._boxProcessors.tenc = function() {
          this._procFullBox(), this._procField("default_IsEncrypted", "uint", 24), this._procField("default_IV_size", "uint", 8), this._procFieldArray("default_KID", 16, "uint", 8);
        }, l.prototype._boxProcessors.tfdt = function() {
          this._procFullBox(), this._procField("baseMediaDecodeTime", "uint", this.version == 1 ? 64 : 32);
        }, l.prototype._boxProcessors.tfhd = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), 1 & this.flags && this._procField("base_data_offset", "uint", 64), 2 & this.flags && this._procField("sample_description_offset", "uint", 32), 8 & this.flags && this._procField("default_sample_duration", "uint", 32), 16 & this.flags && this._procField("default_sample_size", "uint", 32), 32 & this.flags && this._procField("default_sample_flags", "uint", 32);
        }, l.prototype._boxProcessors.tfra = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), this._parsing || (this.reserved = 0, this.reserved |= (48 & this.length_size_of_traf_num) << 4, this.reserved |= (12 & this.length_size_of_trun_num) << 2, this.reserved |= 3 & this.length_size_of_sample_num), this._procField("reserved", "uint", 32), this._parsing && (this.length_size_of_traf_num = (48 & this.reserved) >> 4, this.length_size_of_trun_num = (12 & this.reserved) >> 2, this.length_size_of_sample_num = 3 & this.reserved), this._procField("number_of_entry", "uint", 32), this._procEntries("entries", this.number_of_entry, function(o) {
            this._procEntryField(o, "time", "uint", this.version === 1 ? 64 : 32), this._procEntryField(o, "moof_offset", "uint", this.version === 1 ? 64 : 32), this._procEntryField(o, "traf_number", "uint", 8 * (this.length_size_of_traf_num + 1)), this._procEntryField(o, "trun_number", "uint", 8 * (this.length_size_of_trun_num + 1)), this._procEntryField(o, "sample_number", "uint", 8 * (this.length_size_of_sample_num + 1));
          });
        }, l.prototype._boxProcessors.tkhd = function() {
          this._procFullBox(), this._procField("creation_time", "uint", this.version == 1 ? 64 : 32), this._procField("modification_time", "uint", this.version == 1 ? 64 : 32), this._procField("track_ID", "uint", 32), this._procField("reserved1", "uint", 32), this._procField("duration", "uint", this.version == 1 ? 64 : 32), this._procFieldArray("reserved2", 2, "uint", 32), this._procField("layer", "uint", 16), this._procField("alternate_group", "uint", 16), this._procField("volume", "template", 16), this._procField("reserved3", "uint", 16), this._procFieldArray("matrix", 9, "template", 32), this._procField("width", "template", 32), this._procField("height", "template", 32);
        }, l.prototype._boxProcessors.trex = function() {
          this._procFullBox(), this._procField("track_ID", "uint", 32), this._procField("default_sample_description_index", "uint", 32), this._procField("default_sample_duration", "uint", 32), this._procField("default_sample_size", "uint", 32), this._procField("default_sample_flags", "uint", 32);
        }, l.prototype._boxProcessors.trun = function() {
          this._procFullBox(), this._procField("sample_count", "uint", 32), 1 & this.flags && this._procField("data_offset", "int", 32), 4 & this.flags && this._procField("first_sample_flags", "uint", 32), this._procEntries("samples", this.sample_count, function(o) {
            256 & this.flags && this._procEntryField(o, "sample_duration", "uint", 32), 512 & this.flags && this._procEntryField(o, "sample_size", "uint", 32), 1024 & this.flags && this._procEntryField(o, "sample_flags", "uint", 32), 2048 & this.flags && this._procEntryField(o, "sample_composition_time_offset", this.version === 1 ? "int" : "uint", 32);
          });
        }, l.prototype._boxProcessors["url "] = l.prototype._boxProcessors["urn "] = function() {
          this._procFullBox(), this.type === "urn " && this._procField("name", "string", -1), this._procField("location", "string", -1);
        }, l.prototype._boxProcessors.vlab = function() {
          this._procField("source_label", "utf8");
        }, l.prototype._boxProcessors.vmhd = function() {
          this._procFullBox(), this._procField("graphicsmode", "uint", 16), this._procFieldArray("opcolor", 3, "uint", 16);
        }, l.prototype._boxProcessors.vttC = function() {
          this._procField("config", "utf8");
        }, l.prototype._boxProcessors.vtte = function() {
        };
      }, 9826: function(L) {
        var h, b = typeof Reflect == "object" ? Reflect : null, A = b && typeof b.apply == "function" ? b.apply : function($, ot, dt) {
          return Function.prototype.apply.call($, ot, dt);
        };
        h = b && typeof b.ownKeys == "function" ? b.ownKeys : Object.getOwnPropertySymbols ? function($) {
          return Object.getOwnPropertyNames($).concat(Object.getOwnPropertySymbols($));
        } : function($) {
          return Object.getOwnPropertyNames($);
        };
        var l = Number.isNaN || function($) {
          return $ != $;
        };
        function o() {
          o.init.call(this);
        }
        L.exports = o, L.exports.once = function($, ot) {
          return new Promise(function(dt, xt) {
            function Nt(q) {
              $.removeListener(ot, jt), xt(q);
            }
            function jt() {
              typeof $.removeListener == "function" && $.removeListener("error", Nt), dt([].slice.call(arguments));
            }
            P($, ot, jt, { once: !0 }), ot !== "error" && function(q, I) {
              typeof q.on == "function" && P(q, "error", I, { once: !0 });
            }($, Nt);
          });
        }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
        var u = 10;
        function g($) {
          if (typeof $ != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof $);
        }
        function m($) {
          return $._maxListeners === void 0 ? o.defaultMaxListeners : $._maxListeners;
        }
        function S($, ot, dt, xt) {
          var Nt, jt, q, I;
          if (g(dt), (jt = $._events) === void 0 ? (jt = $._events = /* @__PURE__ */ Object.create(null), $._eventsCount = 0) : (jt.newListener !== void 0 && ($.emit("newListener", ot, dt.listener ? dt.listener : dt), jt = $._events), q = jt[ot]), q === void 0) q = jt[ot] = dt, ++$._eventsCount;
          else if (typeof q == "function" ? q = jt[ot] = xt ? [dt, q] : [q, dt] : xt ? q.unshift(dt) : q.push(dt), (Nt = m($)) > 0 && q.length > Nt && !q.warned) {
            q.warned = !0;
            var pt = new Error("Possible EventEmitter memory leak detected. " + q.length + " " + String(ot) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            pt.name = "MaxListenersExceededWarning", pt.emitter = $, pt.type = ot, pt.count = q.length, I = pt, console && console.warn && console.warn(I);
          }
          return $;
        }
        function e() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function n($, ot, dt) {
          var xt = { fired: !1, wrapFn: void 0, target: $, type: ot, listener: dt }, Nt = e.bind(xt);
          return Nt.listener = dt, xt.wrapFn = Nt, Nt;
        }
        function d($, ot, dt) {
          var xt = $._events;
          if (xt === void 0) return [];
          var Nt = xt[ot];
          return Nt === void 0 ? [] : typeof Nt == "function" ? dt ? [Nt.listener || Nt] : [Nt] : dt ? function(jt) {
            for (var q = new Array(jt.length), I = 0; I < q.length; ++I) q[I] = jt[I].listener || jt[I];
            return q;
          }(Nt) : p(Nt, Nt.length);
        }
        function _($) {
          var ot = this._events;
          if (ot !== void 0) {
            var dt = ot[$];
            if (typeof dt == "function") return 1;
            if (dt !== void 0) return dt.length;
          }
          return 0;
        }
        function p($, ot) {
          for (var dt = new Array(ot), xt = 0; xt < ot; ++xt) dt[xt] = $[xt];
          return dt;
        }
        function P($, ot, dt, xt) {
          if (typeof $.on == "function") xt.once ? $.once(ot, dt) : $.on(ot, dt);
          else {
            if (typeof $.addEventListener != "function") throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof $);
            $.addEventListener(ot, function Nt(jt) {
              xt.once && $.removeEventListener(ot, Nt), dt(jt);
            });
          }
        }
        Object.defineProperty(o, "defaultMaxListeners", { enumerable: !0, get: function() {
          return u;
        }, set: function($) {
          if (typeof $ != "number" || $ < 0 || l($)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + $ + ".");
          u = $;
        } }), o.init = function() {
          this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, o.prototype.setMaxListeners = function($) {
          if (typeof $ != "number" || $ < 0 || l($)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + $ + ".");
          return this._maxListeners = $, this;
        }, o.prototype.getMaxListeners = function() {
          return m(this);
        }, o.prototype.emit = function($) {
          for (var ot = [], dt = 1; dt < arguments.length; dt++) ot.push(arguments[dt]);
          var xt = $ === "error", Nt = this._events;
          if (Nt !== void 0) xt = xt && Nt.error === void 0;
          else if (!xt) return !1;
          if (xt) {
            var jt;
            if (ot.length > 0 && (jt = ot[0]), jt instanceof Error) throw jt;
            var q = new Error("Unhandled error." + (jt ? " (" + jt.message + ")" : ""));
            throw q.context = jt, q;
          }
          var I = Nt[$];
          if (I === void 0) return !1;
          if (typeof I == "function") A(I, this, ot);
          else {
            var pt = I.length, It = p(I, pt);
            for (dt = 0; dt < pt; ++dt) A(It[dt], this, ot);
          }
          return !0;
        }, o.prototype.addListener = function($, ot) {
          return S(this, $, ot, !1);
        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function($, ot) {
          return S(this, $, ot, !0);
        }, o.prototype.once = function($, ot) {
          return g(ot), this.on($, n(this, $, ot)), this;
        }, o.prototype.prependOnceListener = function($, ot) {
          return g(ot), this.prependListener($, n(this, $, ot)), this;
        }, o.prototype.removeListener = function($, ot) {
          var dt, xt, Nt, jt, q;
          if (g(ot), (xt = this._events) === void 0) return this;
          if ((dt = xt[$]) === void 0) return this;
          if (dt === ot || dt.listener === ot) --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete xt[$], xt.removeListener && this.emit("removeListener", $, dt.listener || ot));
          else if (typeof dt != "function") {
            for (Nt = -1, jt = dt.length - 1; jt >= 0; jt--) if (dt[jt] === ot || dt[jt].listener === ot) {
              q = dt[jt].listener, Nt = jt;
              break;
            }
            if (Nt < 0) return this;
            Nt === 0 ? dt.shift() : function(I, pt) {
              for (; pt + 1 < I.length; pt++) I[pt] = I[pt + 1];
              I.pop();
            }(dt, Nt), dt.length === 1 && (xt[$] = dt[0]), xt.removeListener !== void 0 && this.emit("removeListener", $, q || ot);
          }
          return this;
        }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function($) {
          var ot, dt, xt;
          if ((dt = this._events) === void 0) return this;
          if (dt.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : dt[$] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete dt[$]), this;
          if (arguments.length === 0) {
            var Nt, jt = Object.keys(dt);
            for (xt = 0; xt < jt.length; ++xt) (Nt = jt[xt]) !== "removeListener" && this.removeAllListeners(Nt);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (typeof (ot = dt[$]) == "function") this.removeListener($, ot);
          else if (ot !== void 0) for (xt = ot.length - 1; xt >= 0; xt--) this.removeListener($, ot[xt]);
          return this;
        }, o.prototype.listeners = function($) {
          return d(this, $, !0);
        }, o.prototype.rawListeners = function($) {
          return d(this, $, !1);
        }, o.listenerCount = function($, ot) {
          return typeof $.listenerCount == "function" ? $.listenerCount(ot) : _.call($, ot);
        }, o.prototype.listenerCount = _, o.prototype.eventNames = function() {
          return this._eventsCount > 0 ? h(this._events) : [];
        };
      }, 7316: function(L) {
        L.exports = function h(b, A) {
          if (b === A) return !0;
          if (b && A && typeof b == "object" && typeof A == "object") {
            if (b.constructor !== A.constructor) return !1;
            var l, o, u;
            if (Array.isArray(b)) {
              if ((l = b.length) != A.length) return !1;
              for (o = l; o-- != 0; ) if (!h(b[o], A[o])) return !1;
              return !0;
            }
            if (b.constructor === RegExp) return b.source === A.source && b.flags === A.flags;
            if (b.valueOf !== Object.prototype.valueOf) return b.valueOf() === A.valueOf();
            if (b.toString !== Object.prototype.toString) return b.toString() === A.toString();
            if ((l = (u = Object.keys(b)).length) !== Object.keys(A).length) return !1;
            for (o = l; o-- != 0; ) if (!Object.prototype.hasOwnProperty.call(A, u[o])) return !1;
            for (o = l; o-- != 0; ) {
              var g = u[o];
              if (!h(b[g], A[g])) return !1;
            }
            return !0;
          }
          return b != b && A != A;
        };
      }, 7986: function(L, h) {
        h.read = function(b, A, l, o, u) {
          var g, m, S = 8 * u - o - 1, e = (1 << S) - 1, n = e >> 1, d = -7, _ = l ? u - 1 : 0, p = l ? -1 : 1, P = b[A + _];
          for (_ += p, g = P & (1 << -d) - 1, P >>= -d, d += S; d > 0; g = 256 * g + b[A + _], _ += p, d -= 8) ;
          for (m = g & (1 << -d) - 1, g >>= -d, d += o; d > 0; m = 256 * m + b[A + _], _ += p, d -= 8) ;
          if (g === 0) g = 1 - n;
          else {
            if (g === e) return m ? NaN : 1 / 0 * (P ? -1 : 1);
            m += Math.pow(2, o), g -= n;
          }
          return (P ? -1 : 1) * m * Math.pow(2, g - o);
        }, h.write = function(b, A, l, o, u, g) {
          var m, S, e, n = 8 * g - u - 1, d = (1 << n) - 1, _ = d >> 1, p = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, P = o ? 0 : g - 1, $ = o ? 1 : -1, ot = A < 0 || A === 0 && 1 / A < 0 ? 1 : 0;
          for (A = Math.abs(A), isNaN(A) || A === 1 / 0 ? (S = isNaN(A) ? 1 : 0, m = d) : (m = Math.floor(Math.log(A) / Math.LN2), A * (e = Math.pow(2, -m)) < 1 && (m--, e *= 2), (A += m + _ >= 1 ? p / e : p * Math.pow(2, 1 - _)) * e >= 2 && (m++, e /= 2), m + _ >= d ? (S = 0, m = d) : m + _ >= 1 ? (S = (A * e - 1) * Math.pow(2, u), m += _) : (S = A * Math.pow(2, _ - 1) * Math.pow(2, u), m = 0)); u >= 8; b[l + P] = 255 & S, P += $, S /= 256, u -= 8) ;
          for (m = m << u | S, n += u; n > 0; b[l + P] = 255 & m, P += $, m /= 256, n -= 8) ;
          b[l + P - $] |= 128 * ot;
        };
      }, 5474: function(L, h, b) {
        (function(A) {
          A.parser = function(C, U) {
            return new u(C, U);
          }, A.SAXParser = u, A.SAXStream = m, A.createStream = function(C, U) {
            return new m(C, U);
          }, A.MAX_BUFFER_LENGTH = 65536;
          var l, o = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];
          function u(C, U) {
            if (!(this instanceof u)) return new u(C, U);
            var gt = this;
            (function(rt) {
              for (var Ft = 0, ne = o.length; Ft < ne; Ft++) rt[o[Ft]] = "";
            })(gt), gt.q = gt.c = "", gt.bufferCheckPosition = A.MAX_BUFFER_LENGTH, gt.opt = U || {}, gt.opt.lowercase = gt.opt.lowercase || gt.opt.lowercasetags, gt.looseCase = gt.opt.lowercase ? "toLowerCase" : "toUpperCase", gt.tags = [], gt.closed = gt.closedRoot = gt.sawRoot = !1, gt.tag = gt.error = null, gt.strict = !!C, gt.noscript = !(!C && !gt.opt.noscript), gt.state = St.BEGIN, gt.strictEntities = gt.opt.strictEntities, gt.ENTITIES = gt.strictEntities ? Object.create(A.XML_ENTITIES) : Object.create(A.ENTITIES), gt.attribList = [], gt.opt.xmlns && (gt.ns = Object.create(dt)), gt.trackPosition = gt.opt.position !== !1, gt.trackPosition && (gt.position = gt.line = gt.column = 0), zt(gt, "onready");
          }
          A.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function(C) {
            function U() {
            }
            return U.prototype = C, new U();
          }), Object.keys || (Object.keys = function(C) {
            var U = [];
            for (var gt in C) C.hasOwnProperty(gt) && U.push(gt);
            return U;
          }), u.prototype = { end: function() {
            Ze(this);
          }, write: function(C) {
            var U = this;
            if (this.error) throw this.error;
            if (U.closed) return le(U, "Cannot write after close. Assign an onready handler.");
            if (C === null) return Ze(U);
            typeof C == "object" && (C = C.toString());
            for (var gt = 0, rt = ""; rt = Q(C, gt++), U.c = rt, rt; ) switch (U.trackPosition && (U.position++, rt === `
` ? (U.line++, U.column = 0) : U.column++), U.state) {
              case St.BEGIN:
                if (U.state = St.BEGIN_WHITESPACE, rt === "\uFEFF") continue;
                X(U, rt);
                continue;
              case St.BEGIN_WHITESPACE:
                X(U, rt);
                continue;
              case St.TEXT:
                if (U.sawRoot && !U.closedRoot) {
                  for (var Ft = gt - 1; rt && rt !== "<" && rt !== "&"; ) (rt = Q(C, gt++)) && U.trackPosition && (U.position++, rt === `
` ? (U.line++, U.column = 0) : U.column++);
                  U.textNode += C.substring(Ft, gt - 1);
                }
                rt !== "<" || U.sawRoot && U.closedRoot && !U.strict ? (!It(S, rt) || U.sawRoot && !U.closedRoot || me(U, "Text data outside of root node."), rt === "&" ? U.state = St.TEXT_ENTITY : U.textNode += rt) : (U.state = St.OPEN_WAKA, U.startTagPosition = U.position);
                continue;
              case St.SCRIPT:
                rt === "<" ? U.state = St.SCRIPT_ENDING : U.script += rt;
                continue;
              case St.SCRIPT_ENDING:
                rt === "/" ? U.state = St.CLOSE_TAG : (U.script += "<" + rt, U.state = St.SCRIPT);
                continue;
              case St.OPEN_WAKA:
                if (rt === "!") U.state = St.SGML_DECL, U.sgmlDecl = "";
                else if (!pt(S, rt)) if (pt(xt, rt)) U.state = St.OPEN_TAG, U.tagName = rt;
                else if (rt === "/") U.state = St.CLOSE_TAG, U.tagName = "";
                else if (rt === "?") U.state = St.PROC_INST, U.procInstName = U.procInstBody = "";
                else {
                  if (me(U, "Unencoded <"), U.startTagPosition + 1 < U.position) {
                    var ne = U.position - U.startTagPosition;
                    rt = new Array(ne).join(" ") + rt;
                  }
                  U.textNode += "<" + rt, U.state = St.TEXT;
                }
                continue;
              case St.SGML_DECL:
                (U.sgmlDecl + rt).toUpperCase() === p ? (Ct(U, "onopencdata"), U.state = St.CDATA, U.sgmlDecl = "", U.cdata = "") : U.sgmlDecl + rt === "--" ? (U.state = St.COMMENT, U.comment = "", U.sgmlDecl = "") : (U.sgmlDecl + rt).toUpperCase() === P ? (U.state = St.DOCTYPE, (U.doctype || U.sawRoot) && me(U, "Inappropriately located doctype declaration"), U.doctype = "", U.sgmlDecl = "") : rt === ">" ? (Ct(U, "onsgmldeclaration", U.sgmlDecl), U.sgmlDecl = "", U.state = St.TEXT) : (pt(d, rt) && (U.state = St.SGML_DECL_QUOTED), U.sgmlDecl += rt);
                continue;
              case St.SGML_DECL_QUOTED:
                rt === U.q && (U.state = St.SGML_DECL, U.q = ""), U.sgmlDecl += rt;
                continue;
              case St.DOCTYPE:
                rt === ">" ? (U.state = St.TEXT, Ct(U, "ondoctype", U.doctype), U.doctype = !0) : (U.doctype += rt, rt === "[" ? U.state = St.DOCTYPE_DTD : pt(d, rt) && (U.state = St.DOCTYPE_QUOTED, U.q = rt));
                continue;
              case St.DOCTYPE_QUOTED:
                U.doctype += rt, rt === U.q && (U.q = "", U.state = St.DOCTYPE);
                continue;
              case St.DOCTYPE_DTD:
                U.doctype += rt, rt === "]" ? U.state = St.DOCTYPE : pt(d, rt) && (U.state = St.DOCTYPE_DTD_QUOTED, U.q = rt);
                continue;
              case St.DOCTYPE_DTD_QUOTED:
                U.doctype += rt, rt === U.q && (U.state = St.DOCTYPE_DTD, U.q = "");
                continue;
              case St.COMMENT:
                rt === "-" ? U.state = St.COMMENT_ENDING : U.comment += rt;
                continue;
              case St.COMMENT_ENDING:
                rt === "-" ? (U.state = St.COMMENT_ENDED, U.comment = ze(U.opt, U.comment), U.comment && Ct(U, "oncomment", U.comment), U.comment = "") : (U.comment += "-" + rt, U.state = St.COMMENT);
                continue;
              case St.COMMENT_ENDED:
                rt !== ">" ? (me(U, "Malformed comment"), U.comment += "--" + rt, U.state = St.COMMENT) : U.state = St.TEXT;
                continue;
              case St.CDATA:
                rt === "]" ? U.state = St.CDATA_ENDING : U.cdata += rt;
                continue;
              case St.CDATA_ENDING:
                rt === "]" ? U.state = St.CDATA_ENDING_2 : (U.cdata += "]" + rt, U.state = St.CDATA);
                continue;
              case St.CDATA_ENDING_2:
                rt === ">" ? (U.cdata && Ct(U, "oncdata", U.cdata), Ct(U, "onclosecdata"), U.cdata = "", U.state = St.TEXT) : rt === "]" ? U.cdata += "]" : (U.cdata += "]]" + rt, U.state = St.CDATA);
                continue;
              case St.PROC_INST:
                rt === "?" ? U.state = St.PROC_INST_ENDING : pt(S, rt) ? U.state = St.PROC_INST_BODY : U.procInstName += rt;
                continue;
              case St.PROC_INST_BODY:
                if (!U.procInstBody && pt(S, rt)) continue;
                rt === "?" ? U.state = St.PROC_INST_ENDING : U.procInstBody += rt;
                continue;
              case St.PROC_INST_ENDING:
                rt === ">" ? (Ct(U, "onprocessinginstruction", { name: U.procInstName, body: U.procInstBody }), U.procInstName = U.procInstBody = "", U.state = St.TEXT) : (U.procInstBody += "?" + rt, U.state = St.PROC_INST_BODY);
                continue;
              case St.OPEN_TAG:
                pt(Nt, rt) ? U.tagName += rt : (bn(U), rt === ">" ? Yt(U) : rt === "/" ? U.state = St.OPEN_TAG_SLASH : (It(S, rt) && me(U, "Invalid character in tag name"), U.state = St.ATTRIB));
                continue;
              case St.OPEN_TAG_SLASH:
                rt === ">" ? (Yt(U, !0), Ht(U)) : (me(U, "Forward-slash in opening tag not followed by >"), U.state = St.ATTRIB);
                continue;
              case St.ATTRIB:
                if (pt(S, rt)) continue;
                rt === ">" ? Yt(U) : rt === "/" ? U.state = St.OPEN_TAG_SLASH : pt(xt, rt) ? (U.attribName = rt, U.attribValue = "", U.state = St.ATTRIB_NAME) : me(U, "Invalid attribute name");
                continue;
              case St.ATTRIB_NAME:
                rt === "=" ? U.state = St.ATTRIB_VALUE : rt === ">" ? (me(U, "Attribute without value"), U.attribValue = U.attribName, wn(U), Yt(U)) : pt(S, rt) ? U.state = St.ATTRIB_NAME_SAW_WHITE : pt(Nt, rt) ? U.attribName += rt : me(U, "Invalid attribute name");
                continue;
              case St.ATTRIB_NAME_SAW_WHITE:
                if (rt === "=") U.state = St.ATTRIB_VALUE;
                else {
                  if (pt(S, rt)) continue;
                  me(U, "Attribute without value"), U.tag.attributes[U.attribName] = "", U.attribValue = "", Ct(U, "onattribute", { name: U.attribName, value: "" }), U.attribName = "", rt === ">" ? Yt(U) : pt(xt, rt) ? (U.attribName = rt, U.state = St.ATTRIB_NAME) : (me(U, "Invalid attribute name"), U.state = St.ATTRIB);
                }
                continue;
              case St.ATTRIB_VALUE:
                if (pt(S, rt)) continue;
                pt(d, rt) ? (U.q = rt, U.state = St.ATTRIB_VALUE_QUOTED) : (me(U, "Unquoted attribute value"), U.state = St.ATTRIB_VALUE_UNQUOTED, U.attribValue = rt);
                continue;
              case St.ATTRIB_VALUE_QUOTED:
                if (rt !== U.q) {
                  rt === "&" ? U.state = St.ATTRIB_VALUE_ENTITY_Q : U.attribValue += rt;
                  continue;
                }
                wn(U), U.q = "", U.state = St.ATTRIB_VALUE_CLOSED;
                continue;
              case St.ATTRIB_VALUE_CLOSED:
                pt(S, rt) ? U.state = St.ATTRIB : rt === ">" ? Yt(U) : rt === "/" ? U.state = St.OPEN_TAG_SLASH : pt(xt, rt) ? (me(U, "No whitespace between attributes"), U.attribName = rt, U.attribValue = "", U.state = St.ATTRIB_NAME) : me(U, "Invalid attribute name");
                continue;
              case St.ATTRIB_VALUE_UNQUOTED:
                if (It(_, rt)) {
                  rt === "&" ? U.state = St.ATTRIB_VALUE_ENTITY_U : U.attribValue += rt;
                  continue;
                }
                wn(U), rt === ">" ? Yt(U) : U.state = St.ATTRIB;
                continue;
              case St.CLOSE_TAG:
                if (U.tagName) rt === ">" ? Ht(U) : pt(Nt, rt) ? U.tagName += rt : U.script ? (U.script += "</" + U.tagName, U.tagName = "", U.state = St.SCRIPT) : (It(S, rt) && me(U, "Invalid tagname in closing tag"), U.state = St.CLOSE_TAG_SAW_WHITE);
                else {
                  if (pt(S, rt)) continue;
                  It(xt, rt) ? U.script ? (U.script += "</" + rt, U.state = St.SCRIPT) : me(U, "Invalid tagname in closing tag.") : U.tagName = rt;
                }
                continue;
              case St.CLOSE_TAG_SAW_WHITE:
                if (pt(S, rt)) continue;
                rt === ">" ? Ht(U) : me(U, "Invalid characters in closing tag");
                continue;
              case St.TEXT_ENTITY:
              case St.ATTRIB_VALUE_ENTITY_Q:
              case St.ATTRIB_VALUE_ENTITY_U:
                var Vt, Xt;
                switch (U.state) {
                  case St.TEXT_ENTITY:
                    Vt = St.TEXT, Xt = "textNode";
                    break;
                  case St.ATTRIB_VALUE_ENTITY_Q:
                    Vt = St.ATTRIB_VALUE_QUOTED, Xt = "attribValue";
                    break;
                  case St.ATTRIB_VALUE_ENTITY_U:
                    Vt = St.ATTRIB_VALUE_UNQUOTED, Xt = "attribValue";
                }
                rt === ";" ? (U[Xt] += Me(U), U.entity = "", U.state = Vt) : pt(U.entity.length ? q : jt, rt) ? U.entity += rt : (me(U, "Invalid character in entity name"), U[Xt] += "&" + U.entity + rt, U.entity = "", U.state = Vt);
                continue;
              default:
                throw new Error(U, "Unknown state: " + U.state);
            }
            return U.position >= U.bufferCheckPosition && function(qt) {
              for (var Gt = Math.max(A.MAX_BUFFER_LENGTH, 10), se = 0, Jt = 0, he = o.length; Jt < he; Jt++) {
                var an = qt[o[Jt]].length;
                if (an > Gt) switch (o[Jt]) {
                  case "textNode":
                    de(qt);
                    break;
                  case "cdata":
                    Ct(qt, "oncdata", qt.cdata), qt.cdata = "";
                    break;
                  case "script":
                    Ct(qt, "onscript", qt.script), qt.script = "";
                    break;
                  default:
                    le(qt, "Max buffer length exceeded: " + o[Jt]);
                }
                se = Math.max(se, an);
              }
              var Fe = A.MAX_BUFFER_LENGTH - se;
              qt.bufferCheckPosition = Fe + qt.position;
            }(U), U;
          }, resume: function() {
            return this.error = null, this;
          }, close: function() {
            return this.write(null);
          }, flush: function() {
            var C;
            de(C = this), C.cdata !== "" && (Ct(C, "oncdata", C.cdata), C.cdata = ""), C.script !== "" && (Ct(C, "onscript", C.script), C.script = "");
          } };
          try {
            l = b(3515).Stream;
          } catch {
            l = function() {
            };
          }
          var g = A.EVENTS.filter(function(C) {
            return C !== "error" && C !== "end";
          });
          function m(C, U) {
            if (!(this instanceof m)) return new m(C, U);
            l.apply(this), this._parser = new u(C, U), this.writable = !0, this.readable = !0;
            var gt = this;
            this._parser.onend = function() {
              gt.emit("end");
            }, this._parser.onerror = function(rt) {
              gt.emit("error", rt), gt._parser.error = null;
            }, this._decoder = null, g.forEach(function(rt) {
              Object.defineProperty(gt, "on" + rt, { get: function() {
                return gt._parser["on" + rt];
              }, set: function(Ft) {
                if (!Ft) return gt.removeAllListeners(rt), gt._parser["on" + rt] = Ft, Ft;
                gt.on(rt, Ft);
              }, enumerable: !0, configurable: !1 });
            });
          }
          m.prototype = Object.create(l.prototype, { constructor: { value: m } }), m.prototype.write = function(C) {
            if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(C)) {
              if (!this._decoder) {
                var U = b(748).I;
                this._decoder = new U("utf8");
              }
              C = this._decoder.write(C);
            }
            return this._parser.write(C.toString()), this.emit("data", C), !0;
          }, m.prototype.end = function(C) {
            return C && C.length && this.write(C), this._parser.end(), !0;
          }, m.prototype.on = function(C, U) {
            var gt = this;
            return gt._parser["on" + C] || g.indexOf(C) === -1 || (gt._parser["on" + C] = function() {
              var rt = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
              rt.splice(0, 0, C), gt.emit.apply(gt, rt);
            }), l.prototype.on.call(gt, C, U);
          };
          var S = `\r
	 `, e = "0124356789", n = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", d = `'"`, _ = S + ">", p = "[CDATA[", P = "DOCTYPE", $ = "http://www.w3.org/XML/1998/namespace", ot = "http://www.w3.org/2000/xmlns/", dt = { xml: $, xmlns: ot };
          S = I(S), e = I(e), n = I(n);
          var xt = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Nt = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/, jt = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, q = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/;
          function I(C) {
            return C.split("").reduce(function(U, gt) {
              return U[gt] = !0, U;
            }, {});
          }
          function pt(C, U) {
            return function(gt) {
              return Object.prototype.toString.call(gt) === "[object RegExp]";
            }(C) ? !!U.match(C) : C[U];
          }
          function It(C, U) {
            return !pt(C, U);
          }
          d = I(d), _ = I(_);
          var et, Dt, ae, St = 0;
          for (var qe in A.STATE = { BEGIN: St++, BEGIN_WHITESPACE: St++, TEXT: St++, TEXT_ENTITY: St++, OPEN_WAKA: St++, SGML_DECL: St++, SGML_DECL_QUOTED: St++, DOCTYPE: St++, DOCTYPE_QUOTED: St++, DOCTYPE_DTD: St++, DOCTYPE_DTD_QUOTED: St++, COMMENT_STARTING: St++, COMMENT: St++, COMMENT_ENDING: St++, COMMENT_ENDED: St++, CDATA: St++, CDATA_ENDING: St++, CDATA_ENDING_2: St++, PROC_INST: St++, PROC_INST_BODY: St++, PROC_INST_ENDING: St++, OPEN_TAG: St++, OPEN_TAG_SLASH: St++, ATTRIB: St++, ATTRIB_NAME: St++, ATTRIB_NAME_SAW_WHITE: St++, ATTRIB_VALUE: St++, ATTRIB_VALUE_QUOTED: St++, ATTRIB_VALUE_CLOSED: St++, ATTRIB_VALUE_UNQUOTED: St++, ATTRIB_VALUE_ENTITY_Q: St++, ATTRIB_VALUE_ENTITY_U: St++, CLOSE_TAG: St++, CLOSE_TAG_SAW_WHITE: St++, SCRIPT: St++, SCRIPT_ENDING: St++ }, A.XML_ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'" }, A.ENTITIES = { amp: "&", gt: ">", lt: "<", quot: '"', apos: "'", AElig: 198, Aacute: 193, Acirc: 194, Agrave: 192, Aring: 197, Atilde: 195, Auml: 196, Ccedil: 199, ETH: 208, Eacute: 201, Ecirc: 202, Egrave: 200, Euml: 203, Iacute: 205, Icirc: 206, Igrave: 204, Iuml: 207, Ntilde: 209, Oacute: 211, Ocirc: 212, Ograve: 210, Oslash: 216, Otilde: 213, Ouml: 214, THORN: 222, Uacute: 218, Ucirc: 219, Ugrave: 217, Uuml: 220, Yacute: 221, aacute: 225, acirc: 226, aelig: 230, agrave: 224, aring: 229, atilde: 227, auml: 228, ccedil: 231, eacute: 233, ecirc: 234, egrave: 232, eth: 240, euml: 235, iacute: 237, icirc: 238, igrave: 236, iuml: 239, ntilde: 241, oacute: 243, ocirc: 244, ograve: 242, oslash: 248, otilde: 245, ouml: 246, szlig: 223, thorn: 254, uacute: 250, ucirc: 251, ugrave: 249, uuml: 252, yacute: 253, yuml: 255, copy: 169, reg: 174, nbsp: 160, iexcl: 161, cent: 162, pound: 163, curren: 164, yen: 165, brvbar: 166, sect: 167, uml: 168, ordf: 170, laquo: 171, not: 172, shy: 173, macr: 175, deg: 176, plusmn: 177, sup1: 185, sup2: 178, sup3: 179, acute: 180, micro: 181, para: 182, middot: 183, cedil: 184, ordm: 186, raquo: 187, frac14: 188, frac12: 189, frac34: 190, iquest: 191, times: 215, divide: 247, OElig: 338, oelig: 339, Scaron: 352, scaron: 353, Yuml: 376, fnof: 402, circ: 710, tilde: 732, Alpha: 913, Beta: 914, Gamma: 915, Delta: 916, Epsilon: 917, Zeta: 918, Eta: 919, Theta: 920, Iota: 921, Kappa: 922, Lambda: 923, Mu: 924, Nu: 925, Xi: 926, Omicron: 927, Pi: 928, Rho: 929, Sigma: 931, Tau: 932, Upsilon: 933, Phi: 934, Chi: 935, Psi: 936, Omega: 937, alpha: 945, beta: 946, gamma: 947, delta: 948, epsilon: 949, zeta: 950, eta: 951, theta: 952, iota: 953, kappa: 954, lambda: 955, mu: 956, nu: 957, xi: 958, omicron: 959, pi: 960, rho: 961, sigmaf: 962, sigma: 963, tau: 964, upsilon: 965, phi: 966, chi: 967, psi: 968, omega: 969, thetasym: 977, upsih: 978, piv: 982, ensp: 8194, emsp: 8195, thinsp: 8201, zwnj: 8204, zwj: 8205, lrm: 8206, rlm: 8207, ndash: 8211, mdash: 8212, lsquo: 8216, rsquo: 8217, sbquo: 8218, ldquo: 8220, rdquo: 8221, bdquo: 8222, dagger: 8224, Dagger: 8225, bull: 8226, hellip: 8230, permil: 8240, prime: 8242, Prime: 8243, lsaquo: 8249, rsaquo: 8250, oline: 8254, frasl: 8260, euro: 8364, image: 8465, weierp: 8472, real: 8476, trade: 8482, alefsym: 8501, larr: 8592, uarr: 8593, rarr: 8594, darr: 8595, harr: 8596, crarr: 8629, lArr: 8656, uArr: 8657, rArr: 8658, dArr: 8659, hArr: 8660, forall: 8704, part: 8706, exist: 8707, empty: 8709, nabla: 8711, isin: 8712, notin: 8713, ni: 8715, prod: 8719, sum: 8721, minus: 8722, lowast: 8727, radic: 8730, prop: 8733, infin: 8734, ang: 8736, and: 8743, or: 8744, cap: 8745, cup: 8746, int: 8747, there4: 8756, sim: 8764, cong: 8773, asymp: 8776, ne: 8800, equiv: 8801, le: 8804, ge: 8805, sub: 8834, sup: 8835, nsub: 8836, sube: 8838, supe: 8839, oplus: 8853, otimes: 8855, perp: 8869, sdot: 8901, lceil: 8968, rceil: 8969, lfloor: 8970, rfloor: 8971, lang: 9001, rang: 9002, loz: 9674, spades: 9824, clubs: 9827, hearts: 9829, diams: 9830 }, Object.keys(A.ENTITIES).forEach(function(C) {
            var U = A.ENTITIES[C], gt = typeof U == "number" ? String.fromCharCode(U) : U;
            A.ENTITIES[C] = gt;
          }), A.STATE) A.STATE[A.STATE[qe]] = qe;
          function zt(C, U, gt) {
            C[U] && C[U](gt);
          }
          function Ct(C, U, gt) {
            C.textNode && de(C), zt(C, U, gt);
          }
          function de(C) {
            C.textNode = ze(C.opt, C.textNode), C.textNode && zt(C, "ontext", C.textNode), C.textNode = "";
          }
          function ze(C, U) {
            return C.trim && (U = U.trim()), C.normalize && (U = U.replace(/\s+/g, " ")), U;
          }
          function le(C, U) {
            return de(C), C.trackPosition && (U += `
Line: ` + C.line + `
Column: ` + C.column + `
Char: ` + C.c), U = new Error(U), C.error = U, zt(C, "onerror", U), C;
          }
          function Ze(C) {
            return C.sawRoot && !C.closedRoot && me(C, "Unclosed root tag"), C.state !== St.BEGIN && C.state !== St.BEGIN_WHITESPACE && C.state !== St.TEXT && le(C, "Unexpected end"), de(C), C.c = "", C.closed = !0, zt(C, "onend"), u.call(C, C.strict, C.opt), C;
          }
          function me(C, U) {
            if (typeof C != "object" || !(C instanceof u)) throw new Error("bad call to strictFail");
            C.strict && le(C, U);
          }
          function bn(C) {
            C.strict || (C.tagName = C.tagName[C.looseCase]());
            var U = C.tags[C.tags.length - 1] || C, gt = C.tag = { name: C.tagName, attributes: {} };
            C.opt.xmlns && (gt.ns = U.ns), C.attribList.length = 0, Ct(C, "onopentagstart", gt);
          }
          function pn(C, U) {
            var gt = C.indexOf(":") < 0 ? ["", C] : C.split(":"), rt = gt[0], Ft = gt[1];
            return U && C === "xmlns" && (rt = "xmlns", Ft = ""), { prefix: rt, local: Ft };
          }
          function wn(C) {
            if (C.strict || (C.attribName = C.attribName[C.looseCase]()), C.attribList.indexOf(C.attribName) !== -1 || C.tag.attributes.hasOwnProperty(C.attribName)) C.attribName = C.attribValue = "";
            else {
              if (C.opt.xmlns) {
                var U = pn(C.attribName, !0), gt = U.prefix, rt = U.local;
                if (gt === "xmlns") if (rt === "xml" && C.attribValue !== $) me(C, "xml: prefix must be bound to " + $ + `
Actual: ` + C.attribValue);
                else if (rt === "xmlns" && C.attribValue !== ot) me(C, "xmlns: prefix must be bound to " + ot + `
Actual: ` + C.attribValue);
                else {
                  var Ft = C.tag, ne = C.tags[C.tags.length - 1] || C;
                  Ft.ns === ne.ns && (Ft.ns = Object.create(ne.ns)), Ft.ns[rt] = C.attribValue;
                }
                C.attribList.push([C.attribName, C.attribValue]);
              } else C.tag.attributes[C.attribName] = C.attribValue, Ct(C, "onattribute", { name: C.attribName, value: C.attribValue });
              C.attribName = C.attribValue = "";
            }
          }
          function Yt(C, U) {
            if (C.opt.xmlns) {
              var gt = C.tag, rt = pn(C.tagName);
              gt.prefix = rt.prefix, gt.local = rt.local, gt.uri = gt.ns[rt.prefix] || "", gt.prefix && !gt.uri && (me(C, "Unbound namespace prefix: " + JSON.stringify(C.tagName)), gt.uri = rt.prefix);
              var Ft = C.tags[C.tags.length - 1] || C;
              gt.ns && Ft.ns !== gt.ns && Object.keys(gt.ns).forEach(function(ke) {
                Ct(C, "onopennamespace", { prefix: ke, uri: gt.ns[ke] });
              });
              for (var ne = 0, Vt = C.attribList.length; ne < Vt; ne++) {
                var Xt = C.attribList[ne], qt = Xt[0], Gt = Xt[1], se = pn(qt, !0), Jt = se.prefix, he = se.local, an = Jt === "" ? "" : gt.ns[Jt] || "", Fe = { name: qt, value: Gt, prefix: Jt, local: he, uri: an };
                Jt && Jt !== "xmlns" && !an && (me(C, "Unbound namespace prefix: " + JSON.stringify(Jt)), Fe.uri = Jt), C.tag.attributes[qt] = Fe, Ct(C, "onattribute", Fe);
              }
              C.attribList.length = 0;
            }
            C.tag.isSelfClosing = !!U, C.sawRoot = !0, C.tags.push(C.tag), Ct(C, "onopentag", C.tag), U || (C.noscript || C.tagName.toLowerCase() !== "script" ? C.state = St.TEXT : C.state = St.SCRIPT, C.tag = null, C.tagName = ""), C.attribName = C.attribValue = "", C.attribList.length = 0;
          }
          function Ht(C) {
            if (!C.tagName) return me(C, "Weird empty close tag."), C.textNode += "</>", void (C.state = St.TEXT);
            if (C.script) {
              if (C.tagName !== "script") return C.script += "</" + C.tagName + ">", C.tagName = "", void (C.state = St.SCRIPT);
              Ct(C, "onscript", C.script), C.script = "";
            }
            var U = C.tags.length, gt = C.tagName;
            C.strict || (gt = gt[C.looseCase]());
            for (var rt = gt; U-- && C.tags[U].name !== rt; ) me(C, "Unexpected close tag");
            if (U < 0) return me(C, "Unmatched closing tag: " + C.tagName), C.textNode += "</" + C.tagName + ">", void (C.state = St.TEXT);
            C.tagName = gt;
            for (var Ft = C.tags.length; Ft-- > U; ) {
              var ne = C.tag = C.tags.pop();
              C.tagName = C.tag.name, Ct(C, "onclosetag", C.tagName);
              var Vt = {};
              for (var Xt in ne.ns) Vt[Xt] = ne.ns[Xt];
              var qt = C.tags[C.tags.length - 1] || C;
              C.opt.xmlns && ne.ns !== qt.ns && Object.keys(ne.ns).forEach(function(Gt) {
                var se = ne.ns[Gt];
                Ct(C, "onclosenamespace", { prefix: Gt, uri: se });
              });
            }
            U === 0 && (C.closedRoot = !0), C.tagName = C.attribValue = C.attribName = "", C.attribList.length = 0, C.state = St.TEXT;
          }
          function Me(C) {
            var U, gt = C.entity, rt = gt.toLowerCase(), Ft = "";
            return C.ENTITIES[gt] ? C.ENTITIES[gt] : C.ENTITIES[rt] ? C.ENTITIES[rt] : ((gt = rt).charAt(0) === "#" && (gt.charAt(1) === "x" ? (gt = gt.slice(2), Ft = (U = parseInt(gt, 16)).toString(16)) : (gt = gt.slice(1), Ft = (U = parseInt(gt, 10)).toString(10))), gt = gt.replace(/^0+/, ""), Ft.toLowerCase() !== gt ? (me(C, "Invalid character entity"), "&" + C.entity + ";") : String.fromCodePoint(U));
          }
          function X(C, U) {
            U === "<" ? (C.state = St.OPEN_WAKA, C.startTagPosition = C.position) : It(S, U) && (me(C, "Non-whitespace before first tag."), C.textNode = U, C.state = St.TEXT);
          }
          function Q(C, U) {
            var gt = "";
            return U < C.length && (gt = C.charAt(U)), gt;
          }
          St = A.STATE, String.fromCodePoint || (et = String.fromCharCode, Dt = Math.floor, ae = function() {
            var C, U, gt = [], rt = -1, Ft = arguments.length;
            if (!Ft) return "";
            for (var ne = ""; ++rt < Ft; ) {
              var Vt = Number(arguments[rt]);
              if (!isFinite(Vt) || Vt < 0 || Vt > 1114111 || Dt(Vt) !== Vt) throw RangeError("Invalid code point: " + Vt);
              Vt <= 65535 ? gt.push(Vt) : (C = 55296 + ((Vt -= 65536) >> 10), U = Vt % 1024 + 56320, gt.push(C, U)), (rt + 1 === Ft || gt.length > 16384) && (ne += et.apply(null, gt), gt.length = 0);
            }
            return ne;
          }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", { value: ae, configurable: !0, writable: !0 }) : String.fromCodePoint = ae);
        })(h);
      }, 6739: function(L, h, b) {
        (function(A, l, o, u, g) {
          function m(Q) {
            if ("contents" in Q) for (var C = ("styleAttrs" in Q) ? Q.styleAttrs[u.byName.ruby.qname] : null, U = Q.kind === "span" && (C === "container" || C === "textContainer" || C === "baseContainer"), gt = Q.contents.length - 1; gt >= 0; gt--) !U || "styleAttrs" in Q.contents[gt] && u.byName.ruby.qname in Q.contents[gt].styleAttrs ? m(Q.contents[gt]) : delete Q.contents[gt];
          }
          function S(Q, C, U, gt) {
            var rt = gt && gt.timeContainer === "seq", Ft = 0;
            gt && (Ft = rt && U ? U.end : gt.begin), C.begin = C.explicit_begin ? C.explicit_begin + Ft : Ft;
            var ne = C.begin, Vt = null;
            if ("sets" in C) for (var Xt = 0; Xt < C.sets.length; Xt++) S(Q, C.sets[Xt], Vt, C), ne = C.timeContainer === "seq" ? C.sets[Xt].end : Math.max(ne, C.sets[Xt].end), Vt = C.sets[Xt];
            if ("contents" in C) {
              if ("contents" in C) for (var qt = 0; qt < C.contents.length; qt++) S(Q, C.contents[qt], Vt, C), ne = C.timeContainer === "seq" ? C.contents[qt].end : Math.max(ne, C.contents[qt].end), Vt = C.contents[qt];
            } else ne = rt ? C.begin : Number.POSITIVE_INFINITY;
            C.explicit_end !== null && C.explicit_dur !== null ? C.end = Math.min(C.begin + C.explicit_dur, Ft + C.explicit_end) : C.explicit_end === null && C.explicit_dur !== null ? C.end = C.begin + C.explicit_dur : C.explicit_end !== null && C.explicit_dur === null ? C.end = Ft + C.explicit_end : C.end = ne, delete C.explicit_begin, delete C.explicit_dur, delete C.explicit_end, Q._registerEvent(C);
          }
          function e(Q) {
            this.node = Q;
          }
          function n() {
            this.events = [], this.head = new d(), this.body = null;
          }
          function d() {
            this.styling = new _(), this.layout = new $();
          }
          function _() {
            this.styles = {}, this.initials = {};
          }
          function p() {
            this.id = null, this.styleAttrs = null, this.styleRefs = null;
          }
          function P() {
            this.styleAttrs = null;
          }
          function $() {
            this.regions = {};
          }
          function ot(Q, C) {
            dt.call(this, "image"), this.src = Q, this.type = C;
          }
          function dt(Q) {
            this.kind = Q;
          }
          function xt(Q) {
            this.id = Q;
          }
          function Nt(Q) {
            this.regionID = Q;
          }
          function jt(Q) {
            this.styleAttrs = Q;
          }
          function q(Q) {
            this.sets = Q;
          }
          function I(Q) {
            this.contents = Q;
          }
          function pt(Q, C, U) {
            this.explicit_begin = Q, this.explicit_end = C, this.explicit_dur = U;
          }
          function It() {
            dt.call(this, "body");
          }
          function et() {
            dt.call(this, "div");
          }
          function Dt() {
            dt.call(this, "p");
          }
          function ae() {
            dt.call(this, "span");
          }
          function St() {
            dt.call(this, "span");
          }
          function qe() {
            dt.call(this, "br");
          }
          function zt() {
          }
          function Ct() {
          }
          function de(Q) {
            return Q && "xml:id" in Q.attributes && Q.attributes["xml:id"].value || null;
          }
          function ze(Q) {
            return Q && "style" in Q.attributes ? Q.attributes.style.value.split(" ") : [];
          }
          function le(Q, C) {
            var U = {};
            if (Q !== null) for (var gt in Q.attributes) {
              var rt = Q.attributes[gt].uri + " " + Q.attributes[gt].local, Ft = u.byQName[rt];
              if (Ft !== void 0) {
                var ne = Ft.parse(Q.attributes[gt].value);
                ne !== null ? (U[rt] = ne, Ft === u.byName.zIndex && Yt(C, "zIndex attribute present but not used by IMSC1 since regions do not overlap")) : Ht(C, "Cannot parse styling attribute " + rt + " --> " + Q.attributes[gt].value);
              }
            }
            return U;
          }
          function Ze(Q, C, U) {
            for (var gt in Q.attributes) if (Q.attributes[gt].uri === C && Q.attributes[gt].local === U) return Q.attributes[gt].value;
            return null;
          }
          function me(Q, C, U) {
            var gt, rt = null;
            return (gt = /^(\d+(?:\.\d+)?)f$/.exec(U)) !== null ? C !== null && (rt = parseFloat(gt[1]) / C) : (gt = /^(\d+(?:\.\d+)?)t$/.exec(U)) !== null ? Q !== null && (rt = parseFloat(gt[1]) / Q) : (gt = /^(\d+(?:\.\d+)?)ms$/.exec(U)) !== null ? rt = parseFloat(gt[1]) / 1e3 : (gt = /^(\d+(?:\.\d+)?)s$/.exec(U)) !== null ? rt = parseFloat(gt[1]) : (gt = /^(\d+(?:\.\d+)?)h$/.exec(U)) !== null ? rt = 3600 * parseFloat(gt[1]) : (gt = /^(\d+(?:\.\d+)?)m$/.exec(U)) !== null ? rt = 60 * parseFloat(gt[1]) : (gt = /^(\d{2,}):(\d\d):(\d\d(?:\.\d+)?)$/.exec(U)) !== null ? rt = 3600 * parseInt(gt[1]) + 60 * parseInt(gt[2]) + parseFloat(gt[3]) : (gt = /^(\d{2,}):(\d\d):(\d\d)\:(\d{2,})$/.exec(U)) !== null && C !== null && (rt = 3600 * parseInt(gt[1]) + 60 * parseInt(gt[2]) + parseInt(gt[3]) + (gt[4] === null ? 0 : parseInt(gt[4]) / C)), rt;
          }
          function bn(Q, C, U) {
            for (; C.styleRefs.length > 0; ) {
              var gt = C.styleRefs.pop();
              gt in Q.styles ? (bn(Q, Q.styles[gt], U), wn(Q.styles[gt].styleAttrs, C.styleAttrs)) : Ht(U, "Non-existant style id referenced");
            }
          }
          function pn(Q, C, U, gt) {
            for (var rt = C.length - 1; rt >= 0; rt--) {
              var Ft = C[rt];
              Ft in Q.styles ? wn(Q.styles[Ft].styleAttrs, U) : Ht(gt, "Non-existant style id referenced");
            }
          }
          function wn(Q, C) {
            for (var U in Q) Q.hasOwnProperty(U) && (U in C || (C[U] = Q[U]));
          }
          function Yt(Q, C) {
            if (Q && Q.warn && Q.warn(C)) throw C;
          }
          function Ht(Q, C) {
            if (Q && Q.error && Q.error(C)) throw C;
          }
          function Me(Q, C) {
            throw Q && Q.fatal && Q.fatal(C), C;
          }
          function X(Q, C) {
            for (var U, gt = 0, rt = Q.length - 1; gt <= rt; ) {
              var Ft = Q[U = Math.floor((gt + rt) / 2)];
              if (Ft < C) gt = U + 1;
              else {
                if (!(Ft > C)) return { found: !0, index: U };
                rt = U - 1;
              }
            }
            return { found: !1, index: gt };
          }
          A.fromXML = function(Q, C, U) {
            var gt = l.parser(!0, { xmlns: !0 }), rt = [], Ft = [], ne = [], Vt = 0, Xt = null;
            gt.onclosetag = function(he) {
              if (rt[0] instanceof zt) Xt.head !== null && Xt.head.styling !== null && pn(Xt.head.styling, rt[0].styleRefs, rt[0].styleAttrs, C), delete rt[0].styleRefs;
              else if (rt[0] instanceof _) for (var an in rt[0].styles) rt[0].styles.hasOwnProperty(an) && bn(rt[0], rt[0].styles[an], C);
              else if (rt[0] instanceof Dt || rt[0] instanceof ae) {
                if (rt[0].contents.length > 1) {
                  var Fe, ke = [rt[0].contents[0]];
                  for (Fe = 1; Fe < rt[0].contents.length; Fe++) rt[0].contents[Fe] instanceof St && ke[ke.length - 1] instanceof St ? ke[ke.length - 1].text += rt[0].contents[Fe].text : ke.push(rt[0].contents[Fe]);
                  rt[0].contents = ke;
                }
                rt[0] instanceof ae && rt[0].contents.length === 1 && rt[0].contents[0] instanceof St && (rt[0].text = rt[0].contents[0].text, delete rt[0].contents);
              } else rt[0] instanceof e && (rt[0].node.uri === o.ns_tt && rt[0].node.local === "metadata" ? Vt-- : Vt > 0 && U && "onCloseTag" in U && U.onCloseTag());
              ne.shift(), Ft.shift(), rt.shift();
            }, gt.ontext = function(he) {
              if (rt[0] !== void 0) if (rt[0] instanceof ae || rt[0] instanceof Dt) {
                if (rt[0] instanceof ae) {
                  var an = rt[0].styleAttrs[u.byName.ruby.qname];
                  if (an === "container" || an === "textContainer" || an === "baseContainer") return;
                }
                var Fe = new St();
                Fe.initFromText(Xt, rt[0], he, Ft[0], ne[0], C), rt[0].contents.push(Fe);
              } else rt[0] instanceof e && Vt > 0 && U && "onText" in U && U.onText(he);
            }, gt.onopentag = function(he) {
              var an = he.attributes["xml:space"];
              an ? ne.unshift(an.value) : ne.length === 0 ? ne.unshift("default") : ne.unshift(ne[0]);
              var Fe = he.attributes["xml:lang"];
              if (Fe ? Ft.unshift(Fe.value) : Ft.length === 0 ? Ft.unshift("") : Ft.unshift(Ft[0]), he.uri === o.ns_tt) if (he.local === "tt") Xt !== null && Me(C, "Two <tt> elements at (" + this.line + "," + this.column + ")"), (Xt = new n()).initFromNode(he, Ft[0], C), rt.unshift(Xt);
              else if (he.local === "head") rt[0] instanceof n || Me(C, "Parent of <head> element is not <tt> at (" + this.line + "," + this.column + ")"), rt.unshift(Xt.head);
              else if (he.local === "styling") rt[0] instanceof d || Me(C, "Parent of <styling> element is not <head> at (" + this.line + "," + this.column + ")"), rt.unshift(Xt.head.styling);
              else if (he.local === "style") {
                var ke;
                rt[0] instanceof _ ? ((ke = new p()).initFromNode(he, C), ke.id ? Xt.head.styling.styles[ke.id] = ke : Ht(C, "<style> element missing @id attribute"), rt.unshift(ke)) : rt[0] instanceof zt ? ((ke = new p()).initFromNode(he, C), wn(ke.styleAttrs, rt[0].styleAttrs), rt.unshift(ke)) : Me(C, "Parent of <style> element is not <styling> or <region> at (" + this.line + "," + this.column + ")");
              } else if (he.local === "initial") {
                var ce;
                if (rt[0] instanceof _) {
                  for (var je in (ce = new P()).initFromNode(he, C), ce.styleAttrs) ce.styleAttrs.hasOwnProperty(je) && (Xt.head.styling.initials[je] = ce.styleAttrs[je]);
                  rt.unshift(ce);
                } else Me(C, "Parent of <initial> element is not <styling> at (" + this.line + "," + this.column + ")");
              } else if (he.local === "layout") rt[0] instanceof d || Me(C, "Parent of <layout> element is not <head> at " + this.line + "," + this.column + ")"), rt.unshift(Xt.head.layout);
              else if (he.local === "region") {
                rt[0] instanceof $ || Me(C, "Parent of <region> element is not <layout> at " + this.line + "," + this.column + ")");
                var ii = new zt();
                ii.initFromNode(Xt, he, Ft[0], C), !ii.id || ii.id in Xt.head.layout.regions ? Ht(C, "Ignoring <region> with duplicate or missing @id at " + this.line + "," + this.column + ")") : Xt.head.layout.regions[ii.id] = ii, rt.unshift(ii);
              } else if (he.local === "body") {
                rt[0] instanceof n || Me(C, "Parent of <body> element is not <tt> at " + this.line + "," + this.column + ")"), Xt.body !== null && Me(C, "Second <body> element at " + this.line + "," + this.column + ")");
                var Wn = new It();
                Wn.initFromNode(Xt, he, Ft[0], C), Xt.body = Wn, rt.unshift(Wn);
              } else if (he.local === "div") {
                rt[0] instanceof et || rt[0] instanceof It || Me(C, "Parent of <div> element is not <body> or <div> at " + this.line + "," + this.column + ")");
                var Ai = new et();
                Ai.initFromNode(Xt, rt[0], he, Ft[0], C);
                var Gn = Ai.styleAttrs[u.byName.backgroundImage.qname];
                Gn && (Ai.contents.push(new ot(Gn)), delete Ai.styleAttrs[u.byName.backgroundImage.qname]), rt[0].contents.push(Ai), rt.unshift(Ai);
              } else if (he.local === "image") {
                rt[0] instanceof et || Me(C, "Parent of <image> element is not <div> at " + this.line + "," + this.column + ")");
                var Di = new ot();
                Di.initFromNode(Xt, rt[0], he, Ft[0], C), rt[0].contents.push(Di), rt.unshift(Di);
              } else if (he.local === "p") {
                rt[0] instanceof et || Me(C, "Parent of <p> element is not <div> at " + this.line + "," + this.column + ")");
                var Ae = new Dt();
                Ae.initFromNode(Xt, rt[0], he, Ft[0], C), rt[0].contents.push(Ae), rt.unshift(Ae);
              } else if (he.local === "span") {
                rt[0] instanceof ae || rt[0] instanceof Dt || Me(C, "Parent of <span> element is not <span> or <p> at " + this.line + "," + this.column + ")");
                var Ke = new ae();
                Ke.initFromNode(Xt, rt[0], he, Ft[0], ne[0], C), rt[0].contents.push(Ke), rt.unshift(Ke);
              } else if (he.local === "br") {
                rt[0] instanceof ae || rt[0] instanceof Dt || Me(C, "Parent of <br> element is not <span> or <p> at " + this.line + "," + this.column + ")");
                var Re = new qe();
                Re.initFromNode(Xt, rt[0], he, Ft[0], C), rt[0].contents.push(Re), rt.unshift(Re);
              } else if (he.local === "set") {
                rt[0] instanceof ae || rt[0] instanceof Dt || rt[0] instanceof et || rt[0] instanceof It || rt[0] instanceof zt || rt[0] instanceof qe || Me(C, "Parent of <set> element is not a content element or a region at " + this.line + "," + this.column + ")");
                var pe = new Ct();
                pe.initFromNode(Xt, rt[0], he, C), rt[0].sets.push(pe), rt.unshift(pe);
              } else rt.unshift(new e(he));
              else rt.unshift(new e(he));
              if (rt[0] instanceof e) {
                if (he.uri === o.ns_tt && he.local === "metadata") Vt++;
                else if (Vt > 0 && U && "onOpenTag" in U) {
                  var Ce = [];
                  for (var He in he.attributes) Ce[he.attributes[He].uri + " " + he.attributes[He].local] = { uri: he.attributes[He].uri, local: he.attributes[He].local, value: he.attributes[He].value };
                  U.onOpenTag(he.uri, he.local, Ce);
                }
              }
            }, gt.write(Q).close(), delete Xt.head.styling.styles;
            var qt = !1;
            for (var Gt in Xt.head.layout.regions) if (Xt.head.layout.regions.hasOwnProperty(Gt)) {
              qt = !0;
              break;
            }
            if (!qt) {
              var se = zt.prototype.createDefaultRegion(Xt.lang);
              Xt.head.layout.regions[se.id] = se;
            }
            for (var Jt in Xt.head.layout.regions) Xt.head.layout.regions.hasOwnProperty(Jt) && S(Xt, Xt.head.layout.regions[Jt], null, null);
            return Xt.body && S(Xt, Xt.body, null, null), Xt.body && m(Xt.body), Xt;
          }, n.prototype.initFromNode = function(Q, C, U) {
            var gt = function(Vt, Xt) {
              var qt = Ze(Vt, o.ns_ttp, "cellResolution"), Gt = 15, se = 32;
              if (qt !== null) {
                var Jt = /(\d+) (\d+)/.exec(qt);
                Jt !== null ? (se = parseInt(Jt[1]), Gt = parseInt(Jt[2])) : Yt(Xt, "Malformed cellResolution value (using initial value instead)");
              }
              return { w: se, h: Gt };
            }(Q, U);
            this.cellLength = { h: new g.ComputedLength(0, 1 / gt.h), w: new g.ComputedLength(1 / gt.w, 0) };
            var rt = function(Vt, Xt) {
              var qt, Gt = Ze(Vt, o.ns_ttp, "frameRate"), se = 30;
              Gt !== null && ((qt = /(\d+)/.exec(Gt)) !== null ? se = parseInt(qt[1]) : Yt(Xt, "Malformed frame rate attribute (using initial value instead)"));
              var Jt = Ze(Vt, o.ns_ttp, "frameRateMultiplier"), he = 1;
              Jt !== null && ((qt = /(\d+) (\d+)/.exec(Jt)) !== null ? he = parseInt(qt[1]) / parseInt(qt[2]) : Yt(Xt, "Malformed frame rate multiplier attribute (using initial value instead)"));
              var an = he * se, Fe = 1, ke = Ze(Vt, o.ns_ttp, "tickRate");
              return ke === null ? Gt !== null && (Fe = an) : (qt = /(\d+)/.exec(ke)) !== null ? Fe = parseInt(qt[1]) : Yt(Xt, "Malformed tick rate attribute (using initial value instead)"), { effectiveFrameRate: an, tickRate: Fe };
            }(Q, U);
            this.effectiveFrameRate = rt.effectiveFrameRate, this.tickRate = rt.tickRate, this.aspectRatio = function(Vt, Xt) {
              var qt = Ze(Vt, o.ns_ittp, "aspectRatio");
              qt === null && (qt = Ze(Vt, o.ns_ttp, "displayAspectRatio"));
              var Gt = null;
              if (qt !== null) {
                var se = /(\d+)\s+(\d+)/.exec(qt);
                if (se !== null) {
                  var Jt = parseInt(se[1]), he = parseInt(se[2]);
                  Jt !== 0 && he !== 0 ? Gt = Jt / he : Ht(Xt, "Illegal aspectRatio values (ignoring)");
                } else Ht(Xt, "Malformed aspectRatio attribute (ignoring)");
              }
              return Gt;
            }(Q, U);
            var Ft = Ze(Q, o.ns_ttp, "timeBase");
            Ft !== null && Ft !== "media" && Me(U, "Unsupported time base");
            var ne = function(Vt, Xt) {
              var qt = Ze(Vt, o.ns_tts, "extent");
              if (qt === null) return null;
              var Gt = qt.split(" ");
              if (Gt.length !== 2) return Yt(Xt, "Malformed extent (ignoring)"), null;
              var se = g.parseLength(Gt[0]), Jt = g.parseLength(Gt[1]);
              return Jt && se ? { h: Jt, w: se } : (Yt(Xt, "Malformed extent values (ignoring)"), null);
            }(Q, U);
            ne === null ? this.pxLength = { h: null, w: null } : (ne.h.unit === "px" && ne.w.unit === "px" || Me(U, "Extent on TT must be in px or absent"), this.pxLength = { h: new g.ComputedLength(0, 1 / ne.h.value), w: new g.ComputedLength(1 / ne.w.value, 0) }), this.dimensions = { h: new g.ComputedLength(0, 1), w: new g.ComputedLength(1, 0) }, this.lang = C;
          }, n.prototype._registerEvent = function(Q) {
            if (!(Q.end <= Q.begin)) {
              var C = X(this.events, Q.begin);
              if (C.found || this.events.splice(C.index, 0, Q.begin), Q.end !== Number.POSITIVE_INFINITY) {
                var U = X(this.events, Q.end);
                U.found || this.events.splice(U.index, 0, Q.end);
              }
            }
          }, n.prototype.getMediaTimeRange = function() {
            return [this.events[0], this.events[this.events.length - 1]];
          }, n.prototype.getMediaTimeEvents = function() {
            return this.events;
          }, p.prototype.initFromNode = function(Q, C) {
            this.id = de(Q), this.styleAttrs = le(Q, C), this.styleRefs = ze(Q);
          }, P.prototype.initFromNode = function(Q, C) {
            for (var U in this.styleAttrs = {}, Q.attributes) if (Q.attributes[U].uri === o.ns_itts || Q.attributes[U].uri === o.ns_ebutts || Q.attributes[U].uri === o.ns_tts) {
              var gt = Q.attributes[U].uri + " " + Q.attributes[U].local;
              this.styleAttrs[gt] = Q.attributes[U].value;
            }
          }, ot.prototype.initFromNode = function(Q, C, U, gt, rt) {
            this.src = "src" in U.attributes ? U.attributes.src.value : null, this.src || Ht(rt, "Invalid image@src attribute"), this.type = "type" in U.attributes ? U.attributes.type.value : null, this.type || Ht(rt, "Invalid image@type attribute"), jt.prototype.initFromNode.call(this, Q, C, U, rt), pt.prototype.initFromNode.call(this, Q, C, U, rt), q.prototype.initFromNode.call(this, Q, C, U, rt), Nt.prototype.initFromNode.call(this, Q, C, U, rt), this.lang = gt;
          }, xt.prototype.initFromNode = function(Q, C, U, gt) {
            this.id = de(U);
          }, Nt.prototype.initFromNode = function(Q, C, U, gt) {
            this.regionID = function(rt) {
              return rt && "region" in rt.attributes ? rt.attributes.region.value : "";
            }(U);
          }, jt.prototype.initFromNode = function(Q, C, U, gt) {
            this.styleAttrs = le(U, gt), Q.head !== null && Q.head.styling !== null && pn(Q.head.styling, ze(U), this.styleAttrs, gt);
          }, q.prototype.initFromNode = function(Q, C, U, gt) {
            this.sets = [];
          }, I.prototype.initFromNode = function(Q, C, U, gt) {
            this.contents = [];
          }, pt.prototype.initFromNode = function(Q, C, U, gt) {
            var rt = function(Ft, ne, Vt, Xt) {
              var qt = null;
              Vt && "begin" in Vt.attributes && (qt = me(Ft.tickRate, Ft.effectiveFrameRate, Vt.attributes.begin.value)) === null && Yt(Xt, "Malformed begin value " + Vt.attributes.begin.value + " (using 0)");
              var Gt = null;
              Vt && "dur" in Vt.attributes && (Gt = me(Ft.tickRate, Ft.effectiveFrameRate, Vt.attributes.dur.value)) === null && Yt(Xt, "Malformed dur value " + Vt.attributes.dur.value + " (ignoring)");
              var se = null;
              return Vt && "end" in Vt.attributes && (se = me(Ft.tickRate, Ft.effectiveFrameRate, Vt.attributes.end.value)) === null && Yt(Xt, "Malformed end value (ignoring)"), { explicit_begin: qt, explicit_end: se, explicit_dur: Gt };
            }(Q, 0, U, gt);
            this.explicit_begin = rt.explicit_begin, this.explicit_end = rt.explicit_end, this.explicit_dur = rt.explicit_dur, this.timeContainer = function(Ft, ne) {
              var Vt = Ft && "timeContainer" in Ft.attributes ? Ft.attributes.timeContainer.value : null;
              return Vt && Vt !== "par" ? Vt === "seq" ? "seq" : (Ht(ne, "Illegal value of timeContainer (assuming 'par')"), "par") : "par";
            }(U, gt);
          }, It.prototype.initFromNode = function(Q, C, U, gt) {
            jt.prototype.initFromNode.call(this, Q, null, C, gt), pt.prototype.initFromNode.call(this, Q, null, C, gt), q.prototype.initFromNode.call(this, Q, null, C, gt), Nt.prototype.initFromNode.call(this, Q, null, C, gt), I.prototype.initFromNode.call(this, Q, null, C, gt), this.lang = U;
          }, et.prototype.initFromNode = function(Q, C, U, gt, rt) {
            jt.prototype.initFromNode.call(this, Q, C, U, rt), pt.prototype.initFromNode.call(this, Q, C, U, rt), q.prototype.initFromNode.call(this, Q, C, U, rt), Nt.prototype.initFromNode.call(this, Q, C, U, rt), I.prototype.initFromNode.call(this, Q, C, U, rt), this.lang = gt;
          }, Dt.prototype.initFromNode = function(Q, C, U, gt, rt) {
            jt.prototype.initFromNode.call(this, Q, C, U, rt), pt.prototype.initFromNode.call(this, Q, C, U, rt), q.prototype.initFromNode.call(this, Q, C, U, rt), Nt.prototype.initFromNode.call(this, Q, C, U, rt), I.prototype.initFromNode.call(this, Q, C, U, rt), this.lang = gt;
          }, ae.prototype.initFromNode = function(Q, C, U, gt, rt, Ft) {
            jt.prototype.initFromNode.call(this, Q, C, U, Ft), pt.prototype.initFromNode.call(this, Q, C, U, Ft), q.prototype.initFromNode.call(this, Q, C, U, Ft), Nt.prototype.initFromNode.call(this, Q, C, U, Ft), I.prototype.initFromNode.call(this, Q, C, U, Ft), this.space = rt, this.lang = gt;
          }, St.prototype.initFromText = function(Q, C, U, gt, rt, Ft) {
            pt.prototype.initFromNode.call(this, Q, C, null, Ft), this.text = U, this.space = rt, this.lang = gt;
          }, qe.prototype.initFromNode = function(Q, C, U, gt, rt) {
            Nt.prototype.initFromNode.call(this, Q, C, U, rt), pt.prototype.initFromNode.call(this, Q, C, U, rt), this.lang = gt;
          }, zt.prototype.createDefaultRegion = function(Q) {
            var C = new zt();
            return xt.call(C, ""), jt.call(C, {}), q.call(C, []), pt.call(C, 0, Number.POSITIVE_INFINITY, null), this.lang = Q, C;
          }, zt.prototype.initFromNode = function(Q, C, U, gt) {
            xt.prototype.initFromNode.call(this, Q, null, C, gt), pt.prototype.initFromNode.call(this, Q, null, C, gt), q.prototype.initFromNode.call(this, Q, null, C, gt), this.styleAttrs = le(C, gt), this.styleRefs = ze(C), this.lang = U;
          }, Ct.prototype.initFromNode = function(Q, C, U, gt) {
            pt.prototype.initFromNode.call(this, Q, C, U, gt);
            var rt = le(U, gt);
            for (var Ft in this.qname = null, this.value = null, rt) if (rt.hasOwnProperty(Ft)) {
              if (this.qname) {
                Ht(gt, "More than one style specified on set");
                break;
              }
              this.qname = Ft, this.value = rt[Ft];
            }
          };
        })(h, typeof sax > "u" ? b(5474) : sax, typeof imscNames > "u" ? b(977) : imscNames, typeof imscStyles > "u" ? b(1219) : imscStyles, typeof imscUtils > "u" ? b(6404) : imscUtils);
      }, 1612: function(L, h, b) {
        var A = /firefox/i.test(navigator.userAgent);
        (function(l, o, u) {
          function g(I, pt, It, et) {
            var Dt;
            if (It.kind === "region") (Dt = document.createElement("div")).style.position = "absolute";
            else if (It.kind === "body") Dt = document.createElement("div");
            else if (It.kind === "div") Dt = document.createElement("div");
            else if (It.kind === "image") {
              if (Dt = document.createElement("img"), I.imgResolver !== null && It.src !== null) {
                var ae = I.imgResolver(It.src, Dt);
                ae && (Dt.src = ae), Dt.height = I.regionH, Dt.width = I.regionW;
              }
            } else if (It.kind === "p") Dt = document.createElement("p");
            else if (It.kind === "span") if (It.styleAttrs[u.byName.ruby.qname] === "container") Dt = document.createElement("ruby"), I.ruby = !0;
            else if (It.styleAttrs[u.byName.ruby.qname] === "base") Dt = document.createElement("span");
            else if (It.styleAttrs[u.byName.ruby.qname] === "text") Dt = document.createElement("rt");
            else if (It.styleAttrs[u.byName.ruby.qname] === "baseContainer") Dt = document.createElement("rbc");
            else if (It.styleAttrs[u.byName.ruby.qname] === "textContainer") Dt = document.createElement("rtc");
            else {
              if (It.styleAttrs[u.byName.ruby.qname] === "delimiter") return;
              Dt = document.createElement("span");
            }
            else It.kind === "br" && (Dt = document.createElement("br"));
            if (Dt) {
              if (It.lang && (It.kind !== "region" && It.lang === et.lang || (Dt.lang = It.lang)), pt.appendChild(Dt), Dt.style.margin = "0", It.kind === "region") {
                var St = It.styleAttrs[u.byName.writingMode.qname];
                St === "lrtb" || St === "lr" ? (I.ipd = "lr", I.bpd = "tb") : St === "rltb" || St === "rl" ? (I.ipd = "rl", I.bpd = "tb") : St === "tblr" ? (I.ipd = "tb", I.bpd = "lr") : St !== "tbrl" && St !== "tb" || (I.ipd = "tb", I.bpd = "rl");
              } else if (It.kind === "p" && I.bpd === "tb") {
                var qe = It.styleAttrs[u.byName.direction.qname];
                I.ipd = qe === "ltr" ? "lr" : "rl";
              }
              for (var zt = 0; zt < P.length; zt++) {
                var Ct = P[zt], de = It.styleAttrs[Ct.qname];
                de !== void 0 && Ct.map !== null && Ct.map(I, Dt, It, de);
              }
              var ze = Dt, le = It.styleAttrs[u.byName.linePadding.qname];
              if (le && !le.isZero()) {
                var Ze = le.toUsedLength(I.w, I.h);
                if (Ze > 0) {
                  var me = Math.ceil(Ze) + "px";
                  I.bpd === "tb" ? (ze.style.paddingLeft = me, ze.style.paddingRight = me) : (ze.style.paddingTop = me, ze.style.paddingBottom = me), I.lp = le;
                }
              }
              var bn = It.styleAttrs[u.byName.multiRowAlign.qname];
              if (bn && bn !== "auto") {
                var pn = document.createElement("span");
                pn.style.display = "inline-block", pn.style.textAlign = bn, Dt.appendChild(pn), ze = pn, I.mra = bn;
              }
              var wn = It.styleAttrs[u.byName.rubyReserve.qname];
              if (wn && wn[0] !== "none" && (I.rubyReserve = wn), It.styleAttrs[u.byName.fillLineGap.qname] && (I.flg = !0), It.kind === "span" && It.text) {
                var Yt = It.styleAttrs[u.byName.textEmphasis.qname];
                if (Yt && Yt.style !== "none" && (I.textEmphasis = !0), u.byName.textCombine.qname in It.styleAttrs && It.styleAttrs[u.byName.textCombine.qname] === "all") Dt.textContent = It.text, Dt._isd_element = It, Yt && _(I, Dt, 0, Yt);
                else for (var Ht = "", Me = 0; Me < It.text.length; Me++) {
                  Ht += It.text.charAt(Me);
                  var X = It.text.charCodeAt(Me);
                  if (X < 55296 || X > 56319 || Me === It.text.length - 1) {
                    var Q = document.createElement("span");
                    Q.textContent = Ht, Yt && _(I, Q, 0, Yt), Dt.appendChild(Q), Ht = "", Q._isd_element = It;
                  }
                }
              }
              if ("contents" in It) for (var C = 0; C < It.contents.length; C++) g(I, ze, It.contents[C], It);
              var U = [];
              if (It.kind === "p" && (d(I, ze, U, null), I.rubyReserve && (function(Vt, Xt) {
                for (var qt = 0; qt < Vt.length; qt++) {
                  var Gt, se, Jt = document.createElement("ruby"), he = document.createElement("span");
                  he.textContent = "​", Jt.appendChild(he);
                  var an, Fe = Xt.rubyReserve[1].toUsedLength(Xt.w, Xt.h) + "px";
                  Xt.rubyReserve[0] === "both" || Xt.rubyReserve[0] === "outside" && Vt.length == 1 ? ((Gt = document.createElement("rtc")).style[xt] = dt ? "after" : "under", Gt.textContent = "​", Gt.style.fontSize = Fe, (se = document.createElement("rtc")).style[xt] = dt ? "before" : "over", se.textContent = "​", se.style.fontSize = Fe, Jt.appendChild(Gt), Jt.appendChild(se)) : ((Gt = document.createElement("rtc")).textContent = "​", Gt.style.fontSize = Fe, an = Xt.rubyReserve[0] === "after" || Xt.rubyReserve[0] === "outside" && qt > 0 ? dt ? "after" : Xt.bpd === "tb" || Xt.bpd === "rl" ? "under" : "over" : dt ? "before" : Xt.bpd === "tb" || Xt.bpd === "rl" ? "over" : "under", Gt.style[xt] = an, Jt.appendChild(Gt));
                  for (var ke = null, ce = 0; ce < Vt[qt].rbc.length; ce++) if (Vt[qt].rbc[ce].localName === "ruby") {
                    ke = Vt[qt].rbc[ce];
                    for (var je = 0; je < ke.style.length; je++) Jt.style.setProperty(ke.style.item(je), ke.style.getPropertyValue(ke.style.item(je)));
                    break;
                  }
                  (ke = ke || Vt[qt].elements[0].node).parentElement.insertBefore(Jt, ke);
                }
              }(U, I), I.rubyReserve = null), (I.ruby || I.rubyReserve) && (function(Vt, Xt) {
                for (var qt = 0; qt < Vt.length; qt++) for (var Gt = 0; Gt < Vt[qt].rbc.length; Gt++) {
                  var se;
                  Vt[qt].rbc[Gt].style[xt] || (se = dt ? qt === 0 ? "before" : "after" : Xt.bpd === "tb" || Xt.bpd === "rl" ? qt === 0 ? "over" : "under" : qt === 0 ? "under" : "over", Vt[qt].rbc[Gt].style[xt] = se);
                }
              }(U, I), I.ruby = null), I.textEmphasis && (function(Vt, Xt) {
                for (var qt = 0; qt < Vt.length; qt++) for (var Gt = 0; Gt < Vt[qt].te.length; Gt++) {
                  var se;
                  Vt[qt].te[Gt].style[jt] && Vt[qt].te[Gt].style[jt] !== "none" || (se = Xt.bpd === "tb" ? qt === 0 ? "left over" : "left under" : Xt.bpd === "rl" ? qt === 0 ? "right under" : "left under" : qt === 0 ? "left under" : "right under", Vt[qt].te[Gt].style[jt] = se);
                }
              }(U, I), I.textEmphasis = null), I.mra && (function(Vt) {
                for (var Xt = 0; Xt < Vt.length - 1; Xt++) {
                  var qt = Vt[Xt].elements.length;
                  if (qt !== 0 && Vt[Xt].br === !1) {
                    var Gt = document.createElement("br"), se = Vt[Xt].elements[qt - 1].node;
                    se.parentElement.insertBefore(Gt, se.nextSibling);
                  }
                }
              }(U), I.mra = null), I.lp && (function(Vt, Xt, qt) {
                if (Vt !== null) for (var Gt = 0; Gt < Vt.length; Gt++) {
                  var se = Vt[Gt].elements.length, Jt = Math.ceil(Xt) + "px", he = "-" + Math.ceil(Xt) + "px";
                  if (se !== 0) {
                    var an = Vt[Gt].elements[Vt[Gt].start_elem], Fe = Vt[Gt].elements[Vt[Gt].end_elem];
                    if (an === Fe) {
                      var ke = an.node.getBoundingClientRect();
                      if (ke.width == 0 || ke.height == 0) continue;
                    }
                    qt.ipd === "lr" ? (an.node.style.marginLeft = he, an.node.style.paddingLeft = Jt) : qt.ipd === "rl" ? (an.node.style.paddingRight = Jt, an.node.style.marginRight = he) : qt.ipd === "tb" && (an.node.style.paddingTop = Jt, an.node.style.marginTop = he), qt.ipd === "lr" ? (A || (Fe.node.style.marginRight = he), Fe.node.style.paddingRight = Jt) : qt.ipd === "rl" ? (Fe.node.style.paddingLeft = Jt, A || (Fe.node.style.marginLeft = he)) : qt.ipd === "tb" && (Fe.node.style.paddingBottom = Jt, Fe.node.style.marginBottom = he);
                  }
                }
              }(U, I.lp.toUsedLength(I.w, I.h), I), I.lp = null), function(Vt, Xt) {
                for (var qt = 0; qt < Vt.length; qt++) for (var Gt = Vt[qt], se = 1; se < Gt.elements.length; ) {
                  var Jt = Gt.elements[se - 1], he = Gt.elements[se];
                  S(Jt.node, he.node, Xt) ? Gt.elements.splice(se, 1) : se++;
                }
                for (var an, Fe, ke = [], ce = 0; ce < Vt.length; ce++) for (var je = 0; je < Vt[ce].elements.length; je++) (Fe = m(an = Vt[ce].elements[je].node, ke, !1)) && (an.style.backgroundColor = Fe);
                for (var ii = 0; ii < ke.length; ii++) ke[ii].style.backgroundColor = "";
              }(U, I), I.flg)) {
                var gt = n(ze.getBoundingClientRect(), I);
                (function(Vt, Xt, qt, Gt) {
                  for (var se = Math.sign(qt - Xt), Jt = 0; Jt <= Vt.length; Jt++) {
                    var he, an, Fe, ke;
                    if (he = Jt === 0 ? Math.round(Xt) : Jt === Vt.length ? Math.round(qt) : Math.round((Vt[Jt - 1].after + Vt[Jt].before) / 2), Jt > 0 && Vt[Jt - 1]) for (Fe = 0; Fe < Vt[Jt - 1].elements.length; Fe++) an = se * (he - (ke = Vt[Jt - 1].elements[Fe]).after) + "px", Gt.bpd === "lr" ? ke.node.style.paddingRight = an : Gt.bpd === "rl" ? ke.node.style.paddingLeft = an : Gt.bpd === "tb" && (ke.node.style.paddingBottom = an);
                    if (Jt < Vt.length) for (Fe = 0; Fe < Vt[Jt].elements.length; Fe++) an = se * ((ke = Vt[Jt].elements[Fe]).before - he) + "px", Gt.bpd === "lr" ? ke.node.style.paddingLeft = an : Gt.bpd === "rl" ? ke.node.style.paddingRight = an : Gt.bpd === "tb" && (ke.node.style.paddingTop = an);
                  }
                })(U, gt.before, gt.after, I), I.flg = null;
              }
              if (It.kind === "region" && I.bpd === "tb" && I.enableRollUp && It.contents.length > 0 && It.styleAttrs[u.byName.displayAlign.qname] === "after") {
                d(I, ze, U, null);
                var rt = new e(It.id === "" ? "_" : It.id, U);
                if (I.currentISDState[rt.id] = rt, I.previousISDState && rt.id in I.previousISDState && I.previousISDState[rt.id].plist.length > 0 && rt.plist.length > 1 && rt.plist[rt.plist.length - 2].text === I.previousISDState[rt.id].plist[I.previousISDState[rt.id].plist.length - 1].text) {
                  var Ft = Dt.firstElementChild, ne = rt.plist[rt.plist.length - 1].after - rt.plist[rt.plist.length - 1].before;
                  Ft.style.bottom = "-" + ne + "px", Ft.style.transition = "transform 0.4s", Ft.style.position = "relative", Ft.style.transform = "translateY(-" + ne + "px)";
                }
              }
            } else q(I.errorHandler, "Error processing ISD element kind: " + It.kind);
          }
          function m(I, pt, It) {
            return I.style.backgroundColor ? (It && !pt.includes(I) && pt.push(I), I.style.backgroundColor) : I.parentElement.nodeName === "SPAN" || I.parentElement.nodeName === "RUBY" || I.parentElement.nodeName === "RBC" || I.parentElement.nodeName === "RTC" || I.parentElement.nodeName === "RT" ? m(I.parentElement, pt, !0) : void 0;
          }
          function S(I, pt, It) {
            if (I.tagName === "SPAN" && pt.tagName === "SPAN" && I._isd_element === pt._isd_element) {
              if (!I._isd_element) return q(It.errorHandler, "Internal error: HTML span is not linked to a source element; cannot merge spans."), !1;
              I.textContent += pt.textContent;
              for (var et = 0; et < pt.style.length; et++) {
                var Dt = pt.style[et];
                (Dt.indexOf("border") >= 0 || Dt.indexOf("padding") >= 0 || Dt.indexOf("margin") >= 0) && (I.style[Dt] = pt.style[Dt]);
              }
              return pt.parentElement.removeChild(pt), !0;
            }
            return !1;
          }
          function e(I, pt) {
            this.id = I, this.plist = pt;
          }
          function n(I, pt) {
            var It = { before: null, after: null, start: null, end: null };
            return pt.bpd === "tb" ? (It.before = I.top, It.after = I.bottom, pt.ipd === "lr" ? (It.start = I.left, It.end = I.right) : (It.start = I.right, It.end = I.left)) : pt.bpd === "lr" ? (It.before = I.left, It.after = I.right, It.start = I.top, It.end = I.bottom) : pt.bpd === "rl" && (It.before = I.right, It.after = I.left, It.start = I.top, It.end = I.bottom), It;
          }
          function d(I, pt, It, et) {
            if (pt.localName !== "rt" && pt.localName !== "rtc") {
              var Dt, ae, St, qe, zt = pt.style.backgroundColor || et;
              if (pt.childElementCount === 0) if (pt.localName === "span" || pt.localName === "rb") {
                var Ct = n(pt.getBoundingClientRect(), I);
                if (It.length !== 0 && (Dt = Ct.before, ae = Ct.after, St = It[It.length - 1].before, ae < (qe = It[It.length - 1].after) && Dt > St || qe <= ae && St >= Dt)) {
                  var de = Math.sign(Ct.after - Ct.before), ze = Math.sign(Ct.end - Ct.start);
                  de * (Ct.before - It[It.length - 1].before) < 0 && (It[It.length - 1].before = Ct.before), de * (Ct.after - It[It.length - 1].after) > 0 && (It[It.length - 1].after = Ct.after), ze * (Ct.start - It[It.length - 1].start) < 0 && (It[It.length - 1].start = Ct.start, It[It.length - 1].start_elem = It[It.length - 1].elements.length), ze * (Ct.end - It[It.length - 1].end) > 0 && (It[It.length - 1].end = Ct.end, It[It.length - 1].end_elem = It[It.length - 1].elements.length);
                } else It.push({ before: Ct.before, after: Ct.after, start: Ct.start, end: Ct.end, start_elem: 0, end_elem: 0, elements: [], rbc: [], te: [], text: "", br: !1 });
                It[It.length - 1].text += pt.textContent, It[It.length - 1].elements.push({ node: pt, bgcolor: zt, before: Ct.before, after: Ct.after });
              } else pt.localName === "br" && It.length !== 0 && (It[It.length - 1].br = !0);
              else for (var le = pt.firstChild; le; ) le.nodeType === Node.ELEMENT_NODE && (d(I, le, It, zt), le.localName === "ruby" || le.localName === "rtc" ? It.length > 0 && It[It.length - 1].rbc.push(le) : le.localName === "span" && le.style[Nt] && le.style[Nt] !== "none" && It.length > 0 && It[It.length - 1].te.push(le)), le = le.nextSibling;
            }
          }
          function _(I, pt, It, et) {
            var Dt;
            et.style !== "none" && (et.style === "auto" ? pt.style[Nt] = "filled" : pt.style[Nt] = et.style + " " + et.symbol, (et.position === "before" || et.position === "after") && (Dt = I.bpd === "tb" ? et.position === "before" ? "left over" : "left under" : I.bpd === "rl" ? et.position === "before" ? "right under" : "left under" : et.position === "before" ? "left under" : "right under", pt.style[jt] = Dt));
          }
          function p(I, pt) {
            this.qname = I, this.map = pt;
          }
          l.render = function(I, pt, It, et, Dt, ae, St, qe, zt) {
            var Ct = et || pt.clientHeight, de = Dt || pt.clientWidth;
            if (I.aspectRatio !== null) {
              var ze = Ct * I.aspectRatio;
              ze > de ? Ct = Math.round(de / I.aspectRatio) : de = ze;
            }
            var le = document.createElement("div");
            le.style.position = "relative", le.style.width = de + "px", le.style.height = Ct + "px", le.style.margin = "auto", le.style.top = 0, le.style.bottom = 0, le.style.left = 0, le.style.right = 0, le.style.zIndex = 0;
            var Ze = { h: Ct, w: de, regionH: null, regionW: null, imgResolver: It, displayForcedOnlyMode: ae || !1, isd: I, errorHandler: St, previousISDState: qe, enableRollUp: zt || !1, currentISDState: {}, flg: null, lp: null, mra: null, ipd: null, bpd: null, ruby: null, textEmphasis: null, rubyReserve: null };
            if (pt.appendChild(le), "contents" in I) for (var me = 0; me < I.contents.length; me++) g(Ze, le, I.contents[me], I);
            return Ze.currentISDState;
          };
          for (var P = [new p("http://www.w3.org/ns/ttml#styling backgroundColor", function(I, pt, It, et) {
            et[3] !== 0 && (pt.style.backgroundColor = "rgba(" + et[0].toString() + "," + et[1].toString() + "," + et[2].toString() + "," + (et[3] / 255).toString() + ")");
          }), new p("http://www.w3.org/ns/ttml#styling color", function(I, pt, It, et) {
            pt.style.color = "rgba(" + et[0].toString() + "," + et[1].toString() + "," + et[2].toString() + "," + (et[3] / 255).toString() + ")";
          }), new p("http://www.w3.org/ns/ttml#styling direction", function(I, pt, It, et) {
            pt.style.direction = et;
          }), new p("http://www.w3.org/ns/ttml#styling display", function(I, pt, It, et) {
          }), new p("http://www.w3.org/ns/ttml#styling displayAlign", function(I, pt, It, et) {
            pt.style.display = "flex", pt.style.flexDirection = "column", et === "before" ? pt.style.justifyContent = "flex-start" : et === "center" ? pt.style.justifyContent = "center" : et === "after" && (pt.style.justifyContent = "flex-end");
          }), new p("http://www.w3.org/ns/ttml#styling extent", function(I, pt, It, et) {
            I.regionH = et.h.toUsedLength(I.w, I.h), I.regionW = et.w.toUsedLength(I.w, I.h);
            var Dt = 0, ae = 0, St = It.styleAttrs["http://www.w3.org/ns/ttml#styling padding"];
            St && (Dt = St[0].toUsedLength(I.w, I.h) + St[2].toUsedLength(I.w, I.h), ae = St[1].toUsedLength(I.w, I.h) + St[3].toUsedLength(I.w, I.h)), pt.style.height = I.regionH - Dt + "px", pt.style.width = I.regionW - ae + "px";
          }), new p("http://www.w3.org/ns/ttml#styling fontFamily", function(I, pt, It, et) {
            for (var Dt = [], ae = 0; ae < et.length; ae++) et[ae] = et[ae].trim(), et[ae] === "monospaceSerif" ? (Dt.push("Courier New"), Dt.push('"Liberation Mono"'), Dt.push("Courier"), Dt.push("monospace")) : et[ae] === "proportionalSansSerif" ? (Dt.push("Arial"), Dt.push("Helvetica"), Dt.push('"Liberation Sans"'), Dt.push("sans-serif")) : et[ae] === "monospace" ? Dt.push("monospace") : et[ae] === "sansSerif" ? Dt.push("sans-serif") : et[ae] === "serif" ? Dt.push("serif") : et[ae] === "monospaceSansSerif" ? (Dt.push("Consolas"), Dt.push("monospace")) : et[ae] === "proportionalSerif" ? Dt.push("serif") : Dt.push(et[ae]);
            if (Dt.length > 0) {
              for (var St = [Dt[0]], qe = 1; qe < Dt.length; qe++) St.indexOf(Dt[qe]) == -1 && St.push(Dt[qe]);
              Dt = St;
            }
            pt.style.fontFamily = Dt.join(",");
          }), new p("http://www.w3.org/ns/ttml#styling shear", function(I, pt, It, et) {
            if (et !== 0) {
              var Dt = -0.9 * et;
              I.bpd === "tb" ? pt.style.transform = "skewX(" + Dt + "deg)" : pt.style.transform = "skewY(" + Dt + "deg)";
            }
          }), new p("http://www.w3.org/ns/ttml#styling fontSize", function(I, pt, It, et) {
            pt.style.fontSize = et.toUsedLength(I.w, I.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling fontStyle", function(I, pt, It, et) {
            pt.style.fontStyle = et;
          }), new p("http://www.w3.org/ns/ttml#styling fontWeight", function(I, pt, It, et) {
            pt.style.fontWeight = et;
          }), new p("http://www.w3.org/ns/ttml#styling lineHeight", function(I, pt, It, et) {
            pt.style.lineHeight = et === "normal" ? "normal" : et.toUsedLength(I.w, I.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling opacity", function(I, pt, It, et) {
            pt.style.opacity = et;
          }), new p("http://www.w3.org/ns/ttml#styling origin", function(I, pt, It, et) {
            pt.style.top = et.h.toUsedLength(I.w, I.h) + "px", pt.style.left = et.w.toUsedLength(I.w, I.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling overflow", function(I, pt, It, et) {
            pt.style.overflow = et;
          }), new p("http://www.w3.org/ns/ttml#styling padding", function(I, pt, It, et) {
            var Dt = [];
            Dt[0] = et[0].toUsedLength(I.w, I.h) + "px", Dt[1] = et[3].toUsedLength(I.w, I.h) + "px", Dt[2] = et[2].toUsedLength(I.w, I.h) + "px", Dt[3] = et[1].toUsedLength(I.w, I.h) + "px", pt.style.padding = Dt.join(" ");
          }), new p("http://www.w3.org/ns/ttml#styling position", function(I, pt, It, et) {
            pt.style.top = et.h.toUsedLength(I.w, I.h) + "px", pt.style.left = et.w.toUsedLength(I.w, I.h) + "px";
          }), new p("http://www.w3.org/ns/ttml#styling rubyAlign", function(I, pt, It, et) {
            pt.style.rubyAlign = et === "spaceAround" ? "space-around" : "center";
          }), new p("http://www.w3.org/ns/ttml#styling rubyPosition", function(I, pt, It, et) {
            var Dt;
            et !== "before" && et !== "after" || (Dt = dt ? et : I.bpd === "tb" || I.bpd === "rl" ? et === "before" ? "over" : "under" : et === "before" ? "under" : "over", pt.parentElement.style[xt] = Dt);
          }), new p("http://www.w3.org/ns/ttml#styling showBackground", null), new p("http://www.w3.org/ns/ttml#styling textAlign", function(I, pt, It, et) {
            var Dt;
            Dt = et === "start" ? I.ipd === "rl" ? "right" : "left" : et === "end" ? I.ipd === "rl" ? "left" : "right" : et, pt.style.textAlign = Dt;
          }), new p("http://www.w3.org/ns/ttml#styling textDecoration", function(I, pt, It, et) {
            pt.style.textDecoration = et.join(" ").replace("lineThrough", "line-through");
          }), new p("http://www.w3.org/ns/ttml#styling textOutline", function(I, pt, It, et) {
          }), new p("http://www.w3.org/ns/ttml#styling textShadow", function(I, pt, It, et) {
            var Dt = It.styleAttrs[u.byName.textOutline.qname];
            if (et === "none" && Dt === "none") pt.style.textShadow = "";
            else {
              var ae = [];
              if (Dt !== "none") {
                var St = "rgba(" + Dt.color[0].toString() + "," + Dt.color[1].toString() + "," + Dt.color[2].toString() + "," + (Dt.color[3] / 255).toString() + ")";
                ae.push("1px 1px 1px " + St), ae.push("-1px 1px 1px " + St), ae.push("1px -1px 1px " + St), ae.push("-1px -1px 1px " + St);
              }
              if (et !== "none") for (var qe = 0; qe < et.length; qe++) ae.push(et[qe].x_off.toUsedLength(I.w, I.h) + "px " + et[qe].y_off.toUsedLength(I.w, I.h) + "px " + et[qe].b_radius.toUsedLength(I.w, I.h) + "px rgba(" + et[qe].color[0].toString() + "," + et[qe].color[1].toString() + "," + et[qe].color[2].toString() + "," + (et[qe].color[3] / 255).toString() + ")");
              pt.style.textShadow = ae.join(",");
            }
          }), new p("http://www.w3.org/ns/ttml#styling textCombine", function(I, pt, It, et) {
            pt.style.textCombineUpright = et;
          }), new p("http://www.w3.org/ns/ttml#styling textEmphasis", function(I, pt, It, et) {
          }), new p("http://www.w3.org/ns/ttml#styling unicodeBidi", function(I, pt, It, et) {
            var Dt;
            Dt = et === "bidiOverride" ? "bidi-override" : et, pt.style.unicodeBidi = Dt;
          }), new p("http://www.w3.org/ns/ttml#styling visibility", function(I, pt, It, et) {
            pt.style.visibility = et;
          }), new p("http://www.w3.org/ns/ttml#styling wrapOption", function(I, pt, It, et) {
            et === "wrap" ? It.space === "preserve" ? pt.style.whiteSpace = "pre-wrap" : pt.style.whiteSpace = "normal" : It.space === "preserve" ? pt.style.whiteSpace = "pre" : pt.style.whiteSpace = "noWrap";
          }), new p("http://www.w3.org/ns/ttml#styling writingMode", function(I, pt, It, et) {
            et === "lrtb" || et === "lr" || et === "rltb" || et === "rl" ? pt.style.writingMode = "horizontal-tb" : et === "tblr" ? pt.style.writingMode = "vertical-lr" : et !== "tbrl" && et !== "tb" || (pt.style.writingMode = "vertical-rl");
          }), new p("http://www.w3.org/ns/ttml#styling zIndex", function(I, pt, It, et) {
            pt.style.zIndex = et;
          }), new p("http://www.w3.org/ns/ttml/profile/imsc1#styling forcedDisplay", function(I, pt, It, et) {
            I.displayForcedOnlyMode && et === !1 && (pt.style.visibility = "hidden");
          })], $ = {}, ot = 0; ot < P.length; ot++) $[P[ot].qname] = P[ot];
          var dt = "webkitRubyPosition" in window.getComputedStyle(document.documentElement), xt = dt ? "webkitRubyPosition" : "rubyPosition", Nt = "webkitTextEmphasisStyle" in window.getComputedStyle(document.documentElement) ? "webkitTextEmphasisStyle" : "textEmphasisStyle", jt = "webkitTextEmphasisPosition" in window.getComputedStyle(document.documentElement) ? "webkitTextEmphasisPosition" : "textEmphasisPosition";
          function q(I, pt) {
            if (I && I.error && I.error(pt)) throw pt;
          }
        })(h, typeof imscNames > "u" ? b(977) : imscNames, typeof imscStyles > "u" ? b(1219) : imscStyles, typeof imscUtils > "u" ? b(6404) : imscUtils);
      }, 8905: function(L, h, b) {
        (function(A, l, o, u) {
          A.generateISD = function(p, P, $) {
            var ot, dt = new n(p), xt = {}, Nt = {}, jt = p.head.styling.initials[o.byName.showBackground.qname], q = p.head.styling.initials[o.byName.backgroundColor.qname];
            for (var I in p.head.layout.regions) if (p.head.layout.regions.hasOwnProperty(I)) {
              var pt = p.head.layout.regions[I], It = pt.styleAttrs[o.byName.showBackground.qname] || jt, et = pt.styleAttrs[o.byName.backgroundColor.qname] || q;
              Nt[pt.id] = (It === "always" || It === void 0) && et !== void 0 && !(P < pt.begin || P >= pt.end);
            }
            for (var Dt in p.body && p.body.regionID && (Nt[p.body.regionID] = !0), ot = p.body !== null ? function St(qe, zt) {
              if (zt.contents) {
                var Ct = {};
                for (var de in zt) zt.hasOwnProperty(de) && (Ct[de] = zt[de]);
                return Ct.contents = [], zt.contents.filter(function(ze) {
                  return !(qe < ze.begin || qe >= ze.end);
                }).forEach(function(ze) {
                  var le = St(qe, ze);
                  le.regionID && (Nt[le.regionID] = !0), le !== null && Ct.contents.push(le);
                }), Ct;
              }
              return zt;
            }(P, p.body) : null, Nt[""] !== void 0 && (Nt[""] = !0), Nt) if (Nt[Dt]) {
              var ae = m(p, P, p.head.layout.regions[Dt], ot, null, "", p.head.layout.regions[Dt], $, xt);
              ae !== null && dt.contents.push(ae.element);
            }
            return dt;
          };
          var g = [o.byName.color.qname, o.byName.textCombine.qname, o.byName.textDecoration.qname, o.byName.textEmphasis.qname, o.byName.textOutline.qname, o.byName.textShadow.qname];
          function m(p, P, $, ot, dt, xt, Nt, jt, q) {
            if (P < Nt.begin || P >= Nt.end) return null;
            var I = "regionID" in Nt && Nt.regionID !== "" ? Nt.regionID : xt;
            if (dt !== null && I !== $.id && (!("contents" in Nt) || "contents" in Nt && Nt.contents.length === 0 || I !== "")) return null;
            var pt = new d(Nt);
            if ("sets" in Nt) for (var It = 0; It < Nt.sets.length; It++) P < Nt.sets[It].begin || P >= Nt.sets[It].end || (pt.styleAttrs[Nt.sets[It].qname] = Nt.sets[It].value);
            var et = {};
            for (var Dt in pt.styleAttrs) if (pt.styleAttrs.hasOwnProperty(Dt) && (et[Dt] = !0, pt.kind === "region" && Dt === o.byName.writingMode.qname && !(o.byName.direction.qname in pt.styleAttrs))) {
              var ae = pt.styleAttrs[Dt];
              ae === "lrtb" || ae === "lr" ? pt.styleAttrs[o.byName.direction.qname] = "ltr" : ae !== "rltb" && ae !== "rl" || (pt.styleAttrs[o.byName.direction.qname] = "rtl");
            }
            if (dt !== null) for (var St = 0; St < o.all.length; St++) {
              var qe = o.all[St];
              if (qe.qname === o.byName.textDecoration.qname) {
                var zt = dt.styleAttrs[qe.qname], Ct = pt.styleAttrs[qe.qname], de = [];
                Ct === void 0 ? de = zt : Ct.indexOf("none") === -1 ? ((Ct.indexOf("noUnderline") === -1 && zt.indexOf("underline") !== -1 || Ct.indexOf("underline") !== -1) && de.push("underline"), (Ct.indexOf("noLineThrough") === -1 && zt.indexOf("lineThrough") !== -1 || Ct.indexOf("lineThrough") !== -1) && de.push("lineThrough"), (Ct.indexOf("noOverline") === -1 && zt.indexOf("overline") !== -1 || Ct.indexOf("overline") !== -1) && de.push("overline")) : de.push("none"), pt.styleAttrs[qe.qname] = de;
              } else if (qe.qname !== o.byName.fontSize.qname || qe.qname in pt.styleAttrs || pt.kind !== "span" || pt.styleAttrs[o.byName.ruby.qname] !== "textContainer") if (qe.qname !== o.byName.fontSize.qname || qe.qname in pt.styleAttrs || pt.kind !== "span" || pt.styleAttrs[o.byName.ruby.qname] !== "text") qe.inherit && qe.qname in dt.styleAttrs && !(qe.qname in pt.styleAttrs) && (pt.styleAttrs[qe.qname] = dt.styleAttrs[qe.qname]);
              else {
                var ze = dt.styleAttrs[o.byName.fontSize.qname];
                dt.styleAttrs[o.byName.ruby.qname] === "textContainer" ? pt.styleAttrs[qe.qname] = ze : pt.styleAttrs[qe.qname] = new u.ComputedLength(0.5 * ze.rw, 0.5 * ze.rh);
              }
              else {
                var le = dt.styleAttrs[o.byName.fontSize.qname];
                pt.styleAttrs[qe.qname] = new u.ComputedLength(0.5 * le.rw, 0.5 * le.rh);
              }
            }
            for (var Ze = 0; Ze < o.all.length; Ze++) {
              var me = o.all[Ze];
              if (!(me.qname in pt.styleAttrs) && !(me.qname === o.byName.position.qname && o.byName.origin.qname in pt.styleAttrs || me.qname === o.byName.origin.qname && o.byName.position.qname in pt.styleAttrs)) {
                var bn = p.head.styling.initials[me.qname] || me.initial;
                if (bn !== null && (pt.kind === "region" || me.inherit === !1 && bn !== null)) {
                  var pn = me.parse(bn);
                  pn !== null ? (pt.styleAttrs[me.qname] = pn, et[me.qname] = !0) : _(jt, "Invalid initial value for '" + me.qname + "' on element '" + pt.kind);
                }
              }
            }
            for (var wn = 0; wn < o.all.length; wn++) {
              var Yt = o.all[wn];
              if (Yt.qname in et && Yt.compute !== null) {
                var Ht = Yt.compute(p, dt, pt, pt.styleAttrs[Yt.qname], q);
                Ht !== null ? pt.styleAttrs[Yt.qname] = Ht : (pt.styleAttrs[Yt.qname] = Yt.compute(p, dt, pt, Yt.parse(Yt.initial), q), _(jt, "Style '" + Yt.qname + "' on element '" + pt.kind + "' cannot be computed"));
              }
            }
            if (pt.styleAttrs[o.byName.display.qname] === "none") return null;
            var Me = null;
            dt === null ? Me = ot === null ? [] : [ot] : "contents" in Nt && (Me = Nt.contents);
            for (var X = 0; Me !== null && X < Me.length; X++) {
              var Q = m(p, P, $, ot, pt, I, Me[X], jt, q);
              Q !== null && pt.contents.push(Q.element);
            }
            for (var C in pt.styleAttrs) if (pt.styleAttrs.hasOwnProperty(C)) {
              var U = !1;
              if (pt.kind === "span") {
                var gt = pt.styleAttrs[o.byName.ruby.qname];
                (U = (gt === "container" || gt === "textContainer" || gt === "baseContainer") && g.indexOf(C) !== -1) || (U = gt !== "container" && C === o.byName.rubyAlign.qname), U || (U = !(gt === "textContainer" || gt === "text") && C === o.byName.rubyPosition.qname);
              }
              if (!U) {
                var rt = o.byQName[C];
                "applies" in rt && (U = rt.applies.indexOf(pt.kind) === -1);
              }
              U && delete pt.styleAttrs[C];
            }
            var Ft = pt.styleAttrs[o.byName.ruby.qname];
            if (pt.kind === "p" || pt.kind === "span" && (Ft === "textContainer" || Ft === "text")) {
              var ne = [];
              S(pt, ne), function(Vt) {
                for (var Xt, qt = 0; qt < Vt.length; ) if ((Xt = Vt[qt]).kind !== "br" && Xt.space !== "preserve") {
                  var Gt = Xt.text.replace(/[\t\r\n ]+/g, " ");
                  /^[ ]/.test(Gt) && (qt === 0 || (se = Vt[qt - 1]).kind === "br" || /[\r\n\t ]$/.test(se.text)) && (Gt = Gt.substring(1)), Xt.text = Gt, Gt.length === 0 ? Vt.splice(qt, 1) : qt++;
                } else qt++;
                var se, Jt;
                for (qt = 0; qt < Vt.length; qt++) (Xt = Vt[qt]).kind !== "br" && Xt.space !== "preserve" ? /[ ]$/.test(Xt.text) && (qt === Vt.length - 1 || (Jt = Vt[qt + 1]).kind === "br" || Jt.space === "preserve" && /^[\r\n]/.test(Jt.text)) && (Xt.text = Xt.text.slice(0, -1)) : qt++;
              }(ne), e(pt);
            }
            return pt.kind === "div" && o.byName.backgroundImage.qname in pt.styleAttrs || pt.kind === "br" || pt.kind === "image" || "contents" in pt && pt.contents.length > 0 || pt.kind === "span" && pt.text !== null || pt.kind === "region" && pt.styleAttrs[o.byName.showBackground.qname] === "always" ? { region_id: I, element: pt } : null;
          }
          function S(p, P) {
            if ("contents" in p) for (var $ = 0; $ < p.contents.length; $++) {
              var ot = p.contents[$], dt = ot.styleAttrs[o.byName.ruby.qname];
              (ot.kind !== "span" || dt !== "textContainer" && dt !== "text") && ("contents" in ot ? S(ot, P) : (ot.kind === "span" && ot.text.length !== 0 || ot.kind === "br") && P.push(ot));
            }
          }
          function e(p) {
            if (p.kind === "br") return !1;
            if ("text" in p) return p.text.length === 0;
            if ("contents" in p) {
              for (var P = p.contents.length; P--; ) e(p.contents[P]) && p.contents.splice(P, 1);
              return p.contents.length === 0;
            }
          }
          function n(p) {
            this.contents = [], this.aspectRatio = p.aspectRatio, this.lang = p.lang;
          }
          function d(p) {
            for (var P in this.kind = p.kind || "region", this.lang = p.lang, p.id && (this.id = p.id), this.styleAttrs = {}, p.styleAttrs) p.styleAttrs.hasOwnProperty(P) && (this.styleAttrs[P] = p.styleAttrs[P]);
            "src" in p && (this.src = p.src), "type" in p && (this.type = p.type), "text" in p ? this.text = p.text : (this.kind === "region" || "contents" in p) && (this.contents = []), "space" in p && (this.space = p.space);
          }
          function _(p, P) {
            if (p && p.error && p.error(P)) throw P;
          }
        })(h, typeof imscNames > "u" ? b(977) : imscNames, typeof imscStyles > "u" ? b(1219) : imscStyles, typeof imscUtils > "u" ? b(6404) : imscUtils);
      }, 7640: function(L, h, b) {
        h.generateISD = b(8905).generateISD, h.fromXML = b(6739).fromXML, h.renderHTML = b(1612).render;
      }, 977: function(L, h) {
        (function(b) {
          b.ns_tt = "http://www.w3.org/ns/ttml", b.ns_tts = "http://www.w3.org/ns/ttml#styling", b.ns_ttp = "http://www.w3.org/ns/ttml#parameter", b.ns_xml = "http://www.w3.org/XML/1998/namespace", b.ns_itts = "http://www.w3.org/ns/ttml/profile/imsc1#styling", b.ns_ittp = "http://www.w3.org/ns/ttml/profile/imsc1#parameter", b.ns_smpte = "http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt", b.ns_ebutts = "urn:ebu:tt:style";
        })(h);
      }, 1219: function(L, h, b) {
        (function(A, l, o) {
          function u(S, e, n, d, _, p, P, $) {
            this.name = e, this.ns = S, this.qname = S + " " + e, this.inherit = _, this.animatable = p, this.initial = n, this.applies = d, this.parse = P, this.compute = $;
          }
          for (var g in A.all = [new u(l.ns_tts, "backgroundColor", "transparent", ["body", "div", "p", "region", "span"], !1, !0, o.parseColor, null), new u(l.ns_tts, "color", "white", ["span"], !0, !0, o.parseColor, null), new u(l.ns_tts, "direction", "ltr", ["p", "span"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "display", "auto", ["body", "div", "p", "region", "span"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "displayAlign", "before", ["region"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "extent", "auto", ["tt", "region"], !1, !0, function(S) {
            if (S === "auto") return S;
            var e = S.split(" ");
            if (e.length !== 2) return null;
            var n = o.parseLength(e[0]), d = o.parseLength(e[1]);
            return d && n ? { h: d, w: n } : null;
          }, function(S, e, n, d, _) {
            var p, P;
            if (d === "auto") p = new o.ComputedLength(0, 1);
            else if ((p = o.toComputedLength(d.h.value, d.h.unit, null, S.dimensions.h, null, S.pxLength.h)) === null) return null;
            if (d === "auto") P = new o.ComputedLength(1, 0);
            else if ((P = o.toComputedLength(d.w.value, d.w.unit, null, S.dimensions.w, null, S.pxLength.w)) === null) return null;
            return { h: p, w: P };
          }), new u(l.ns_tts, "fontFamily", "default", ["span", "p"], !0, !0, function(S) {
            for (var e = S.split(","), n = [], d = 0; d < e.length; d++) e[d] = e[d].trim(), e[d].charAt(0) !== "'" && e[d].charAt(0) !== '"' && e[d] === "default" ? n.push("monospaceSerif") : n.push(e[d]);
            return n;
          }, null), new u(l.ns_tts, "shear", "0%", ["p"], !0, !0, o.parseLength, function(S, e, n, d) {
            return d.unit !== "%" ? null : Math.abs(d.value) > 100 ? 100 * Math.sign(d.value) : d.value;
          }), new u(l.ns_tts, "fontSize", "1c", ["span", "p"], !0, !0, o.parseLength, function(S, e, n, d, _) {
            return o.toComputedLength(d.value, d.unit, e !== null ? e.styleAttrs[A.byName.fontSize.qname] : S.cellLength.h, e !== null ? e.styleAttrs[A.byName.fontSize.qname] : S.cellLength.h, S.cellLength.h, S.pxLength.h);
          }), new u(l.ns_tts, "fontStyle", "normal", ["span", "p"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "fontWeight", "normal", ["span", "p"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "lineHeight", "normal", ["p"], !0, !0, function(S) {
            return S === "normal" ? S : o.parseLength(S);
          }, function(S, e, n, d, _) {
            var p;
            if (d === "normal") p = d;
            else if ((p = o.toComputedLength(d.value, d.unit, n.styleAttrs[A.byName.fontSize.qname], n.styleAttrs[A.byName.fontSize.qname], S.cellLength.h, S.pxLength.h)) === null) return null;
            return p;
          }), new u(l.ns_tts, "opacity", 1, ["region"], !1, !0, parseFloat, null), new u(l.ns_tts, "origin", "auto", ["region"], !1, !0, function(S) {
            if (S === "auto") return S;
            var e = S.split(" ");
            if (e.length !== 2) return null;
            var n = o.parseLength(e[0]), d = o.parseLength(e[1]);
            return d && n ? { h: d, w: n } : null;
          }, function(S, e, n, d, _) {
            var p, P;
            if (d === "auto") p = new o.ComputedLength(0, 0);
            else if ((p = o.toComputedLength(d.h.value, d.h.unit, null, S.dimensions.h, null, S.pxLength.h)) === null) return null;
            if (d === "auto") P = new o.ComputedLength(0, 0);
            else if ((P = o.toComputedLength(d.w.value, d.w.unit, null, S.dimensions.w, null, S.pxLength.w)) === null) return null;
            return { h: p, w: P };
          }), new u(l.ns_tts, "overflow", "hidden", ["region"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "padding", "0px", ["region"], !1, !0, function(S) {
            var e = S.split(" ");
            if (e.length > 4) return null;
            for (var n = [], d = 0; d < e.length; d++) {
              var _ = o.parseLength(e[d]);
              if (!_) return null;
              n.push(_);
            }
            return n;
          }, function(S, e, n, d, _) {
            var p;
            if (d.length === 1) p = [d[0], d[0], d[0], d[0]];
            else if (d.length === 2) p = [d[0], d[1], d[0], d[1]];
            else if (d.length === 3) p = [d[0], d[1], d[2], d[1]];
            else {
              if (d.length !== 4) return null;
              p = [d[0], d[1], d[2], d[3]];
            }
            var P = n.styleAttrs[A.byName.writingMode.qname];
            if (P === "lrtb" || P === "lr") p = [p[0], p[3], p[2], p[1]];
            else if (P === "rltb" || P === "rl") p = [p[0], p[1], p[2], p[3]];
            else if (P === "tblr") p = [p[3], p[0], p[1], p[2]];
            else {
              if (P !== "tbrl" && P !== "tb") return null;
              p = [p[3], p[2], p[1], p[0]];
            }
            for (var $ = [], ot = 0; ot < p.length; ot++) if (p[ot].value === 0) $[ot] = new o.ComputedLength(0, 0);
            else if ($[ot] = o.toComputedLength(p[ot].value, p[ot].unit, n.styleAttrs[A.byName.fontSize.qname], ot === 0 || ot === 2 ? n.styleAttrs[A.byName.extent.qname].h : n.styleAttrs[A.byName.extent.qname].w, ot === 0 || ot === 2 ? S.cellLength.h : S.cellLength.w, ot === 0 || ot === 2 ? S.pxLength.h : S.pxLength.w), $[ot] === null) return null;
            return $;
          }), new u(l.ns_tts, "position", "top left", ["region"], !1, !0, function(S) {
            return o.parsePosition(S);
          }, function(S, e, n, d) {
            var _, p;
            return (_ = o.toComputedLength(d.v.offset.value, d.v.offset.unit, null, new o.ComputedLength(-n.styleAttrs[A.byName.extent.qname].h.rw, S.dimensions.h.rh - n.styleAttrs[A.byName.extent.qname].h.rh), null, S.pxLength.h)) === null ? null : (d.v.edge === "bottom" && (_ = new o.ComputedLength(-_.rw - n.styleAttrs[A.byName.extent.qname].h.rw, S.dimensions.h.rh - _.rh - n.styleAttrs[A.byName.extent.qname].h.rh)), p = o.toComputedLength(d.h.offset.value, d.h.offset.unit, null, new o.ComputedLength(S.dimensions.w.rw - n.styleAttrs[A.byName.extent.qname].w.rw, -n.styleAttrs[A.byName.extent.qname].w.rh), null, S.pxLength.w), _ === null ? null : (d.h.edge === "right" && (p = new o.ComputedLength(S.dimensions.w.rw - p.rw - n.styleAttrs[A.byName.extent.qname].w.rw, -p.rh - n.styleAttrs[A.byName.extent.qname].w.rh)), { h: _, w: p }));
          }), new u(l.ns_tts, "ruby", "none", ["span"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "rubyAlign", "center", ["span"], !0, !0, function(S) {
            return S !== "center" && S !== "spaceAround" ? null : S;
          }, null), new u(l.ns_tts, "rubyPosition", "outside", ["span"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "rubyReserve", "none", ["p"], !0, !0, function(S) {
            var e = S.split(" "), n = [null, null];
            if (e.length === 0 || e.length > 2 || e[0] !== "none" && e[0] !== "both" && e[0] !== "after" && e[0] !== "before" && e[0] !== "outside") return null;
            if (n[0] = e[0], e.length === 2 && e[0] !== "none") {
              var d = o.parseLength(e[1]);
              if (!d) return null;
              n[1] = d;
            }
            return n;
          }, function(S, e, n, d, _) {
            if (d[0] === "none") return d;
            var p;
            return (p = d[1] === null ? new o.ComputedLength(0.5 * n.styleAttrs[A.byName.fontSize.qname].rw, 0.5 * n.styleAttrs[A.byName.fontSize.qname].rh) : o.toComputedLength(d[1].value, d[1].unit, n.styleAttrs[A.byName.fontSize.qname], n.styleAttrs[A.byName.fontSize.qname], S.cellLength.h, S.pxLength.h)) === null ? null : [d[0], p];
          }), new u(l.ns_tts, "showBackground", "always", ["region"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "textAlign", "start", ["p"], !0, !0, function(S) {
            return S;
          }, function(S, e, n, d, _) {
            return d === "left" ? "start" : d === "right" ? "end" : d;
          }), new u(l.ns_tts, "textCombine", "none", ["span"], !0, !0, function(S) {
            return S === "none" || S === "all" ? S : null;
          }, null), new u(l.ns_tts, "textDecoration", "none", ["span"], !0, !0, function(S) {
            return S.split(" ");
          }, null), new u(l.ns_tts, "textEmphasis", "none", ["span"], !0, !0, function(S) {
            for (var e = S.split(" "), n = { style: null, symbol: null, color: null, position: null }, d = 0; d < e.length; d++) if (e[d] === "none" || e[d] === "auto") n.style = e[d];
            else if (e[d] === "filled" || e[d] === "open") n.style = e[d];
            else if (e[d] === "circle" || e[d] === "dot" || e[d] === "sesame") n.symbol = e[d];
            else if (e[d] === "current") n.color = e[d];
            else if (e[d] === "outside" || e[d] === "before" || e[d] === "after") n.position = e[d];
            else if (n.color = o.parseColor(e[d]), n.color === null) return null;
            return n.style == null && n.symbol == null ? n.style = "auto" : (n.symbol = n.symbol || "circle", n.style = n.style || "filled"), n.position = n.position || "outside", n.color = n.color || "current", n;
          }, null), new u(l.ns_tts, "textOutline", "none", ["span"], !0, !0, function(S) {
            if (S === "none") return S;
            var e = {}, n = S.split(" ");
            if (n.length === 0 || n.length > 2) return null;
            var d = o.parseColor(n[0]);
            if (e.color = d, d !== null && n.shift(), n.length !== 1) return null;
            var _ = o.parseLength(n[0]);
            return _ ? (e.thickness = _, e) : null;
          }, function(S, e, n, d, _) {
            if (d === "none") return d;
            var p = {};
            return d.color === null ? p.color = n.styleAttrs[A.byName.color.qname] : p.color = d.color, p.thickness = o.toComputedLength(d.thickness.value, d.thickness.unit, n.styleAttrs[A.byName.fontSize.qname], n.styleAttrs[A.byName.fontSize.qname], S.cellLength.h, S.pxLength.h), p.thickness === null ? null : p;
          }), new u(l.ns_tts, "textShadow", "none", ["span"], !0, !0, o.parseTextShadow, function(S, e, n, d) {
            if (d === "none") return d;
            for (var _ = [], p = 0; p < d.length; p++) {
              var P = {};
              if (P.x_off = o.toComputedLength(d[p][0].value, d[p][0].unit, null, n.styleAttrs[A.byName.fontSize.qname], null, S.pxLength.w), P.x_off === null || (P.y_off = o.toComputedLength(d[p][1].value, d[p][1].unit, null, n.styleAttrs[A.byName.fontSize.qname], null, S.pxLength.h), P.y_off === null)) return null;
              if (d[p][2] === null) P.b_radius = 0;
              else if (P.b_radius = o.toComputedLength(d[p][2].value, d[p][2].unit, null, n.styleAttrs[A.byName.fontSize.qname], null, S.pxLength.h), P.b_radius === null) return null;
              d[p][3] === null ? P.color = n.styleAttrs[A.byName.color.qname] : P.color = d[p][3], _.push(P);
            }
            return _;
          }), new u(l.ns_tts, "unicodeBidi", "normal", ["span", "p"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "visibility", "visible", ["body", "div", "p", "region", "span"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "wrapOption", "wrap", ["span"], !0, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "writingMode", "lrtb", ["region"], !1, !0, function(S) {
            return S;
          }, null), new u(l.ns_tts, "zIndex", "auto", ["region"], !1, !0, function(S) {
            var e;
            return S === "auto" ? e = S : (e = parseInt(S), isNaN(e) && (e = null)), e;
          }, null), new u(l.ns_ebutts, "linePadding", "0c", ["p"], !0, !1, o.parseLength, function(S, e, n, d, _) {
            return o.toComputedLength(d.value, d.unit, null, null, S.cellLength.w, null);
          }), new u(l.ns_ebutts, "multiRowAlign", "auto", ["p"], !0, !1, function(S) {
            return S;
          }, null), new u(l.ns_smpte, "backgroundImage", null, ["div"], !1, !1, function(S) {
            return S;
          }, null), new u(l.ns_itts, "forcedDisplay", "false", ["body", "div", "p", "region", "span"], !0, !0, function(S) {
            return S === "true";
          }, null), new u(l.ns_itts, "fillLineGap", "false", ["p"], !0, !0, function(S) {
            return S === "true";
          }, null)], A.byQName = {}, A.all) A.byQName[A.all[g].qname] = A.all[g];
          for (var m in A.byName = {}, A.all) A.byName[A.all[m].name] = A.all[m];
        })(h, typeof imscNames > "u" ? b(977) : imscNames, typeof imscUtils > "u" ? b(6404) : imscUtils);
      }, 6404: function(L, h) {
        (function(b) {
          var A = /#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?/, l = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/, o = /rgba\(\s*(\d+),\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/, u = { transparent: [0, 0, 0, 0], black: [0, 0, 0, 255], silver: [192, 192, 192, 255], gray: [128, 128, 128, 255], white: [255, 255, 255, 255], maroon: [128, 0, 0, 255], red: [255, 0, 0, 255], purple: [128, 0, 128, 255], fuchsia: [255, 0, 255, 255], magenta: [255, 0, 255, 255], green: [0, 128, 0, 255], lime: [0, 255, 0, 255], olive: [128, 128, 0, 255], yellow: [255, 255, 0, 255], navy: [0, 0, 128, 255], blue: [0, 0, 255, 255], teal: [0, 128, 128, 255], aqua: [0, 255, 255, 255], cyan: [0, 255, 255, 255] };
          b.parseColor = function(m) {
            var S, e = null, n = u[m.toLowerCase()];
            return n !== void 0 ? e = n : (S = A.exec(m)) !== null ? e = [parseInt(S[1], 16), parseInt(S[2], 16), parseInt(S[3], 16), S[4] !== void 0 ? parseInt(S[4], 16) : 255] : (S = l.exec(m)) !== null ? e = [parseInt(S[1]), parseInt(S[2]), parseInt(S[3]), 255] : (S = o.exec(m)) !== null && (e = [parseInt(S[1]), parseInt(S[2]), parseInt(S[3]), parseInt(S[4])]), e;
          };
          var g = /^((?:\+|\-)?\d*(?:\.\d+)?)(px|em|c|%|rh|rw)$/;
          b.parseLength = function(m) {
            var S, e = null;
            return (S = g.exec(m)) !== null && (e = { value: parseFloat(S[1]), unit: S[2] }), e;
          }, b.parseTextShadow = function(m) {
            for (var S = m.match(/([^\(,\)]|\([^\)]+\))+/g), e = [], n = 0; n < S.length; n++) {
              var d = S[n].split(" ");
              if (d.length === 1 && d[0] === "none") return "none";
              if (d.length > 1 && d.length < 5) {
                var _ = [null, null, null, null], p = b.parseLength(d.shift());
                if (p === null || (_[0] = p, (p = b.parseLength(d.shift())) === null)) return null;
                if (_[1] = p, d.length === 0) {
                  e.push(_);
                  continue;
                }
                if ((p = b.parseLength(d[0])) !== null && (_[2] = p, d.shift()), d.length === 0) {
                  e.push(_);
                  continue;
                }
                var P = b.parseColor(d[0]);
                if (P === null) return null;
                _[3] = P, e.push(_);
              }
            }
            return e;
          }, b.parsePosition = function(m) {
            var S = m.split(" "), e = function(ot) {
              return ot === "center" || ot === "left" || ot === "top" || ot === "bottom" || ot === "right";
            };
            if (S.length > 4) return null;
            for (var n = 0; n < S.length; n++) if (!e(S[n])) {
              var d = b.parseLength(S[n]);
              if (d === null) return null;
              S[n] = d;
            }
            for (var _ = { h: { edge: "left", offset: { value: 50, unit: "%" } }, v: { edge: "top", offset: { value: 50, unit: "%" } } }, p = 0; p < S.length; ) {
              var P = S[p++];
              if (e(P)) {
                var $ = { value: 0, unit: "%" };
                S.length !== 2 && p < S.length && !e(S[p]) && ($ = S[p++]), P === "right" ? (_.h.edge = P, _.h.offset = $) : P === "bottom" ? (_.v.edge = P, _.v.offset = $) : P === "left" ? _.h.offset = $ : P === "top" && (_.v.offset = $);
              } else {
                if (S.length !== 1 && S.length !== 2) return null;
                p === 1 ? _.h.offset = P : _.v.offset = P;
              }
            }
            return _;
          }, b.ComputedLength = function(m, S) {
            this.rw = m, this.rh = S;
          }, b.ComputedLength.prototype.toUsedLength = function(m, S) {
            return m * this.rw + S * this.rh;
          }, b.ComputedLength.prototype.isZero = function() {
            return this.rw === 0 && this.rh === 0;
          }, b.toComputedLength = function(m, S, e, n, d, _) {
            return S === "%" && n ? new b.ComputedLength(n.rw * m / 100, n.rh * m / 100) : S === "em" && e ? new b.ComputedLength(e.rw * m, e.rh * m) : S === "c" && d ? new b.ComputedLength(m * d.rw, m * d.rh) : S === "px" && _ ? new b.ComputedLength(m * _.rw, m * _.rh) : S === "rh" ? new b.ComputedLength(0, m / 100) : S === "rw" ? new b.ComputedLength(m / 100, 0) : null;
          };
        })(h);
      }, 7523: function(L) {
        typeof Object.create == "function" ? L.exports = function(h, b) {
          b && (h.super_ = b, h.prototype = Object.create(b.prototype, { constructor: { value: h, enumerable: !1, writable: !0, configurable: !0 } }));
        } : L.exports = function(h, b) {
          if (b) {
            h.super_ = b;
            var A = function() {
            };
            A.prototype = b.prototype, h.prototype = new A(), h.prototype.constructor = h;
          }
        };
      }, 9066: function(L, h, b) {
        (function(A) {
          A.defineLocale("af", { months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"), weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"), weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"), weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"), meridiemParse: /vm|nm/i, isPM: function(l) {
            return /^nm$/i.test(l);
          }, meridiem: function(l, o, u) {
            return l < 12 ? u ? "vm" : "VM" : u ? "nm" : "NM";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Vandag om] LT", nextDay: "[Môre om] LT", nextWeek: "dddd [om] LT", lastDay: "[Gister om] LT", lastWeek: "[Laas] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oor %s", past: "%s gelede", s: "'n paar sekondes", ss: "%d sekondes", m: "'n minuut", mm: "%d minute", h: "'n uur", hh: "%d ure", d: "'n dag", dd: "%d dae", M: "'n maand", MM: "%d maande", y: "'n jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(l) {
            return l + (l === 1 || l === 8 || l >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4261: function(L, h, b) {
        (function(A) {
          var l = function(m) {
            return m === 0 ? 0 : m === 1 ? 1 : m === 2 ? 2 : m % 100 >= 3 && m % 100 <= 10 ? 3 : m % 100 >= 11 ? 4 : 5;
          }, o = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, u = function(m) {
            return function(S, e, n, d) {
              var _ = l(S), p = o[m][l(S)];
              return _ === 2 && (p = p[e ? 0 : 1]), p.replace(/%d/i, S);
            };
          }, g = ["جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          A.defineLocale("ar-dz", { months: g, monthsShort: g, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(m) {
            return m === "م";
          }, meridiem: function(m, S, e) {
            return m < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: u("s"), ss: u("s"), m: u("m"), mm: u("m"), h: u("h"), hh: u("h"), d: u("d"), dd: u("d"), M: u("M"), MM: u("M"), y: u("y"), yy: u("y") }, postformat: function(m) {
            return m.replace(/,/g, "،");
          }, week: { dow: 0, doy: 4 } });
        })(b(7840));
      }, 7717: function(L, h, b) {
        (function(A) {
          A.defineLocale("ar-kw", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 0, doy: 12 } });
        })(b(7840));
      }, 7060: function(L, h, b) {
        (function(A) {
          var l = { 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9", 0: "0" }, o = function(S) {
            return S === 0 ? 0 : S === 1 ? 1 : S === 2 ? 2 : S % 100 >= 3 && S % 100 <= 10 ? 3 : S % 100 >= 11 ? 4 : 5;
          }, u = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, g = function(S) {
            return function(e, n, d, _) {
              var p = o(e), P = u[S][o(e)];
              return p === 2 && (P = P[n ? 0 : 1]), P.replace(/%d/i, e);
            };
          }, m = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          A.defineLocale("ar-ly", { months: m, monthsShort: m, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(S) {
            return S === "م";
          }, meridiem: function(S, e, n) {
            return S < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: g("s"), ss: g("s"), m: g("m"), mm: g("m"), h: g("h"), hh: g("h"), d: g("d"), dd: g("d"), M: g("M"), MM: g("M"), y: g("y"), yy: g("y") }, preparse: function(S) {
            return S.replace(/،/g, ",");
          }, postformat: function(S) {
            return S.replace(/\d/g, function(e) {
              return l[e];
            }).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 2757: function(L, h, b) {
        (function(A) {
          A.defineLocale("ar-ma", { months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8490: function(L, h, b) {
        (function(A) {
          var l = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, o = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" };
          A.defineLocale("ar-ps", { months: "كانون الثاني_شباط_آذار_نيسان_أيّار_حزيران_تمّوز_آب_أيلول_تشري الأوّل_تشرين الثاني_كانون الأوّل".split("_"), monthsShort: "ك٢_شباط_آذار_نيسان_أيّار_حزيران_تمّوز_آب_أيلول_ت١_ت٢_ك١".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(u) {
            return u === "م";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, preparse: function(u) {
            return u.replace(/[٣٤٥٦٧٨٩٠]/g, function(g) {
              return o[g];
            }).split("").reverse().join("").replace(/[١٢](?![\u062a\u0643])/g, function(g) {
              return o[g];
            }).split("").reverse().join("").replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            }).replace(/,/g, "،");
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 735: function(L, h, b) {
        (function(A) {
          var l = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, o = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" };
          A.defineLocale("ar-sa", { months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(u) {
            return u === "م";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, preparse: function(u) {
            return u.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function(g) {
              return o[g];
            }).replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            }).replace(/,/g, "،");
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 5385: function(L, h, b) {
        (function(A) {
          A.defineLocale("ar-tn", { months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"), weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[اليوم على الساعة] LT", nextDay: "[غدا على الساعة] LT", nextWeek: "dddd [على الساعة] LT", lastDay: "[أمس على الساعة] LT", lastWeek: "dddd [على الساعة] LT", sameElse: "L" }, relativeTime: { future: "في %s", past: "منذ %s", s: "ثوان", ss: "%d ثانية", m: "دقيقة", mm: "%d دقائق", h: "ساعة", hh: "%d ساعات", d: "يوم", dd: "%d أيام", M: "شهر", MM: "%d أشهر", y: "سنة", yy: "%d سنوات" }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1110: function(L, h, b) {
        (function(A) {
          var l = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, o = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }, u = function(e) {
            return e === 0 ? 0 : e === 1 ? 1 : e === 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
          }, g = { s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"], m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"], h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"], d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"], M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"], y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"] }, m = function(e) {
            return function(n, d, _, p) {
              var P = u(n), $ = g[e][u(n)];
              return P === 2 && ($ = $[d ? 0 : 1]), $.replace(/%d/i, n);
            };
          }, S = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
          A.defineLocale("ar", { months: S, monthsShort: S, weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"), weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"), weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/‏M/‏YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /ص|م/, isPM: function(e) {
            return e === "م";
          }, meridiem: function(e, n, d) {
            return e < 12 ? "ص" : "م";
          }, calendar: { sameDay: "[اليوم عند الساعة] LT", nextDay: "[غدًا عند الساعة] LT", nextWeek: "dddd [عند الساعة] LT", lastDay: "[أمس عند الساعة] LT", lastWeek: "dddd [عند الساعة] LT", sameElse: "L" }, relativeTime: { future: "بعد %s", past: "منذ %s", s: m("s"), ss: m("s"), m: m("m"), mm: m("m"), h: m("h"), hh: m("h"), d: m("d"), dd: m("d"), M: m("M"), MM: m("M"), y: m("y"), yy: m("y") }, preparse: function(e) {
            return e.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function(n) {
              return o[n];
            }).replace(/،/g, ",");
          }, postformat: function(e) {
            return e.replace(/\d/g, function(n) {
              return l[n];
            }).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 6190: function(L, h, b) {
        (function(A) {
          var l = { 1: "-inci", 5: "-inci", 8: "-inci", 70: "-inci", 80: "-inci", 2: "-nci", 7: "-nci", 20: "-nci", 50: "-nci", 3: "-üncü", 4: "-üncü", 100: "-üncü", 6: "-ncı", 9: "-uncu", 10: "-uncu", 30: "-uncu", 60: "-ıncı", 90: "-ıncı" };
          A.defineLocale("az", { months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"), monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"), weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"), weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"), weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[sabah saat] LT", nextWeek: "[gələn həftə] dddd [saat] LT", lastDay: "[dünən] LT", lastWeek: "[keçən həftə] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s əvvəl", s: "bir neçə saniyə", ss: "%d saniyə", m: "bir dəqiqə", mm: "%d dəqiqə", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", M: "bir ay", MM: "%d ay", y: "bir il", yy: "%d il" }, meridiemParse: /gecə|səhər|gündüz|axşam/, isPM: function(o) {
            return /^(gündüz|axşam)$/.test(o);
          }, meridiem: function(o, u, g) {
            return o < 4 ? "gecə" : o < 12 ? "səhər" : o < 17 ? "gündüz" : "axşam";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/, ordinal: function(o) {
            if (o === 0) return o + "-ıncı";
            var u = o % 10;
            return o + (l[u] || l[o % 100 - u] || l[o >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 1448: function(L, h, b) {
        (function(A) {
          function l(o, u, g) {
            return g === "m" ? u ? "хвіліна" : "хвіліну" : g === "h" ? u ? "гадзіна" : "гадзіну" : o + " " + (m = +o, S = { ss: u ? "секунда_секунды_секунд" : "секунду_секунды_секунд", mm: u ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін", hh: u ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін", dd: "дзень_дні_дзён", MM: "месяц_месяцы_месяцаў", yy: "год_гады_гадоў" }[g].split("_"), m % 10 == 1 && m % 100 != 11 ? S[0] : m % 10 >= 2 && m % 10 <= 4 && (m % 100 < 10 || m % 100 >= 20) ? S[1] : S[2]);
            var m, S;
          }
          A.defineLocale("be", { months: { format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"), standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_") }, monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"), weekdays: { format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"), standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"), isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/ }, weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"), weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., HH:mm", LLLL: "dddd, D MMMM YYYY г., HH:mm" }, calendar: { sameDay: "[Сёння ў] LT", nextDay: "[Заўтра ў] LT", lastDay: "[Учора ў] LT", nextWeek: function() {
            return "[У] dddd [ў] LT";
          }, lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return "[У мінулую] dddd [ў] LT";
              case 1:
              case 2:
              case 4:
                return "[У мінулы] dddd [ў] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "праз %s", past: "%s таму", s: "некалькі секунд", m: l, mm: l, h: l, hh: l, d: "дзень", dd: l, M: "месяц", MM: l, y: "год", yy: l }, meridiemParse: /ночы|раніцы|дня|вечара/, isPM: function(o) {
            return /^(дня|вечара)$/.test(o);
          }, meridiem: function(o, u, g) {
            return o < 4 ? "ночы" : o < 12 ? "раніцы" : o < 17 ? "дня" : "вечара";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/, ordinal: function(o, u) {
            switch (u) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return o % 10 != 2 && o % 10 != 3 || o % 100 == 12 || o % 100 == 13 ? o + "-ы" : o + "-і";
              case "D":
                return o + "-га";
              default:
                return o;
            }
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 7890: function(L, h, b) {
        (function(A) {
          A.defineLocale("bg", { months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"), monthsShort: "яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"), weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"), weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Днес в] LT", nextDay: "[Утре в] LT", nextWeek: "dddd [в] LT", lastDay: "[Вчера в] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[Миналата] dddd [в] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Миналия] dddd [в] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "след %s", past: "преди %s", s: "няколко секунди", ss: "%d секунди", m: "минута", mm: "%d минути", h: "час", hh: "%d часа", d: "ден", dd: "%d дена", w: "седмица", ww: "%d седмици", M: "месец", MM: "%d месеца", y: "година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function(l) {
            var o = l % 10, u = l % 100;
            return l === 0 ? l + "-ев" : u === 0 ? l + "-ен" : u > 10 && u < 20 ? l + "-ти" : o === 1 ? l + "-ви" : o === 2 ? l + "-ри" : o === 7 || o === 8 ? l + "-ми" : l + "-ти";
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 6832: function(L, h, b) {
        (function(A) {
          A.defineLocale("bm", { months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo".split("_"), monthsShort: "Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des".split("_"), weekdays: "Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"), weekdaysShort: "Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib".split("_"), weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "MMMM [tile] D [san] YYYY", LLL: "MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm", LLLL: "dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm" }, calendar: { sameDay: "[Bi lɛrɛ] LT", nextDay: "[Sini lɛrɛ] LT", nextWeek: "dddd [don lɛrɛ] LT", lastDay: "[Kunu lɛrɛ] LT", lastWeek: "dddd [tɛmɛnen lɛrɛ] LT", sameElse: "L" }, relativeTime: { future: "%s kɔnɔ", past: "a bɛ %s bɔ", s: "sanga dama dama", ss: "sekondi %d", m: "miniti kelen", mm: "miniti %d", h: "lɛrɛ kelen", hh: "lɛrɛ %d", d: "tile kelen", dd: "tile %d", M: "kalo kelen", MM: "kalo %d", y: "san kelen", yy: "san %d" }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 196: function(L, h, b) {
        (function(A) {
          var l = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" }, o = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
          A.defineLocale("bn-bd", { months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"), monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"), weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"), weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"), weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"), longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" }, calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s পরে", past: "%s আগে", s: "কয়েক সেকেন্ড", ss: "%d সেকেন্ড", m: "এক মিনিট", mm: "%d মিনিট", h: "এক ঘন্টা", hh: "%d ঘন্টা", d: "এক দিন", dd: "%d দিন", M: "এক মাস", MM: "%d মাস", y: "এক বছর", yy: "%d বছর" }, preparse: function(u) {
            return u.replace(/[১২৩৪৫৬৭৮৯০]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "রাত" ? u < 4 ? u : u + 12 : g === "ভোর" || g === "সকাল" ? u : g === "দুপুর" ? u >= 3 ? u : u + 12 : g === "বিকাল" || g === "সন্ধ্যা" ? u + 12 : void 0;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "রাত" : u < 6 ? "ভোর" : u < 12 ? "সকাল" : u < 15 ? "দুপুর" : u < 18 ? "বিকাল" : u < 20 ? "সন্ধ্যা" : "রাত";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 7193: function(L, h, b) {
        (function(A) {
          var l = { 1: "১", 2: "২", 3: "৩", 4: "৪", 5: "৫", 6: "৬", 7: "৭", 8: "৮", 9: "৯", 0: "০" }, o = { "১": "1", "২": "2", "৩": "3", "৪": "4", "৫": "5", "৬": "6", "৭": "7", "৮": "8", "৯": "9", "০": "0" };
          A.defineLocale("bn", { months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"), monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"), weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"), weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"), weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"), longDateFormat: { LT: "A h:mm সময়", LTS: "A h:mm:ss সময়", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm সময়", LLLL: "dddd, D MMMM YYYY, A h:mm সময়" }, calendar: { sameDay: "[আজ] LT", nextDay: "[আগামীকাল] LT", nextWeek: "dddd, LT", lastDay: "[গতকাল] LT", lastWeek: "[গত] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s পরে", past: "%s আগে", s: "কয়েক সেকেন্ড", ss: "%d সেকেন্ড", m: "এক মিনিট", mm: "%d মিনিট", h: "এক ঘন্টা", hh: "%d ঘন্টা", d: "এক দিন", dd: "%d দিন", M: "এক মাস", MM: "%d মাস", y: "এক বছর", yy: "%d বছর" }, preparse: function(u) {
            return u.replace(/[১২৩৪৫৬৭৮৯০]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "রাত" && u >= 4 || g === "দুপুর" && u < 5 || g === "বিকাল" ? u + 12 : u;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "রাত" : u < 10 ? "সকাল" : u < 17 ? "দুপুর" : u < 20 ? "বিকাল" : "রাত";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 6682: function(L, h, b) {
        (function(A) {
          var l = { 1: "༡", 2: "༢", 3: "༣", 4: "༤", 5: "༥", 6: "༦", 7: "༧", 8: "༨", 9: "༩", 0: "༠" }, o = { "༡": "1", "༢": "2", "༣": "3", "༤": "4", "༥": "5", "༦": "6", "༧": "7", "༨": "8", "༩": "9", "༠": "0" };
          A.defineLocale("bo", { months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"), monthsShort: "ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12".split("_"), monthsShortRegex: /^(ཟླ་\d{1,2})/, monthsParseExact: !0, weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"), weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"), weekdaysMin: "ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[དི་རིང] LT", nextDay: "[སང་ཉིན] LT", nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT", lastDay: "[ཁ་སང] LT", lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ལ་", past: "%s སྔན་ལ", s: "ལམ་སང", ss: "%d སྐར་ཆ།", m: "སྐར་མ་གཅིག", mm: "%d སྐར་མ", h: "ཆུ་ཚོད་གཅིག", hh: "%d ཆུ་ཚོད", d: "ཉིན་གཅིག", dd: "%d ཉིན་", M: "ཟླ་བ་གཅིག", MM: "%d ཟླ་བ", y: "ལོ་གཅིག", yy: "%d ལོ" }, preparse: function(u) {
            return u.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "མཚན་མོ" && u >= 4 || g === "ཉིན་གུང" && u < 5 || g === "དགོང་དག" ? u + 12 : u;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "མཚན་མོ" : u < 10 ? "ཞོགས་ཀས" : u < 17 ? "ཉིན་གུང" : u < 20 ? "དགོང་དག" : "མཚན་མོ";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 1133: function(L, h, b) {
        (function(A) {
          function l(S, e, n) {
            return S + " " + function(d, _) {
              return _ === 2 ? function(p) {
                var P = { m: "v", b: "v", d: "z" };
                return P[p.charAt(0)] === void 0 ? p : P[p.charAt(0)] + p.substring(1);
              }(d) : d;
            }({ mm: "munutenn", MM: "miz", dd: "devezh" }[n], S);
          }
          function o(S) {
            return S > 9 ? o(S % 10) : S;
          }
          var u = [/^gen/i, /^c[ʼ\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i], g = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, m = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
          A.defineLocale("br", { months: "Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"), monthsShort: "Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"), weekdays: "Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn".split("_"), weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"), weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"), weekdaysParse: m, fullWeekdaysParse: [/^sul/i, /^lun/i, /^meurzh/i, /^merc[ʼ\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i], shortWeekdaysParse: [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i], minWeekdaysParse: m, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex: /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [a viz] MMMM YYYY", LLL: "D [a viz] MMMM YYYY HH:mm", LLLL: "dddd, D [a viz] MMMM YYYY HH:mm" }, calendar: { sameDay: "[Hiziv da] LT", nextDay: "[Warcʼhoazh da] LT", nextWeek: "dddd [da] LT", lastDay: "[Decʼh da] LT", lastWeek: "dddd [paset da] LT", sameElse: "L" }, relativeTime: { future: "a-benn %s", past: "%s ʼzo", s: "un nebeud segondennoù", ss: "%d eilenn", m: "ur vunutenn", mm: l, h: "un eur", hh: "%d eur", d: "un devezh", dd: l, M: "ur miz", MM: l, y: "ur bloaz", yy: function(S) {
            switch (o(S)) {
              case 1:
              case 3:
              case 4:
              case 5:
              case 9:
                return S + " bloaz";
              default:
                return S + " vloaz";
            }
          } }, dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/, ordinal: function(S) {
            return S + (S === 1 ? "añ" : "vet");
          }, week: { dow: 1, doy: 4 }, meridiemParse: /a.m.|g.m./, isPM: function(S) {
            return S === "g.m.";
          }, meridiem: function(S, e, n) {
            return S < 12 ? "a.m." : "g.m.";
          } });
        })(b(7840));
      }, 1214: function(L, h, b) {
        (function(A) {
          function l(o, u, g) {
            var m = o + " ";
            switch (g) {
              case "ss":
                return m + (o === 1 ? "sekunda" : o === 2 || o === 3 || o === 4 ? "sekunde" : "sekundi");
              case "mm":
                return m + (o === 1 ? "minuta" : o === 2 || o === 3 || o === 4 ? "minute" : "minuta");
              case "h":
                return "jedan sat";
              case "hh":
                return m + (o === 1 ? "sat" : o === 2 || o === 3 || o === 4 ? "sata" : "sati");
              case "dd":
                return m + (o === 1 ? "dan" : "dana");
              case "MM":
                return m + (o === 1 ? "mjesec" : o === 2 || o === 3 || o === 4 ? "mjeseca" : "mjeseci");
              case "yy":
                return m + (o === 1 ? "godina" : o === 2 || o === 3 || o === 4 ? "godine" : "godina");
            }
          }
          A.defineLocale("bs", { months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jučer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
                return "[prošlu] dddd [u] LT";
              case 6:
                return "[prošle] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prošli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: l, m: function(o, u, g, m) {
            if (g === "m") return u ? "jedna minuta" : m ? "jednu minutu" : "jedne minute";
          }, mm: l, h: l, hh: l, d: "dan", dd: l, M: "mjesec", MM: l, y: "godinu", yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 7357: function(L, h, b) {
        (function(A) {
          A.defineLocale("ca", { months: { standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"), format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"), monthsParseExact: !0, weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a les] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a les] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: function() {
            return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, nextDay: function() {
            return "[demà a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, nextWeek: function() {
            return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, lastDay: function() {
            return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "d'aquí %s", past: "fa %s", s: "uns segons", ss: "%d segons", m: "un minut", mm: "%d minuts", h: "una hora", hh: "%d hores", d: "un dia", dd: "%d dies", M: "un mes", MM: "%d mesos", y: "un any", yy: "%d anys" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/, ordinal: function(l, o) {
            var u = l === 1 ? "r" : l === 2 ? "n" : l === 3 ? "r" : l === 4 ? "t" : "è";
            return o !== "w" && o !== "W" || (u = "a"), l + u;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1659: function(L, h, b) {
        (function(A) {
          var l = { standalone: "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"), format: "ledna_února_března_dubna_května_června_července_srpna_září_října_listopadu_prosince".split("_"), isFormat: /DD?[o.]?(\[[^\[\]]*\]|\s)+MMMM/ }, o = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"), u = [/^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i], g = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;
          function m(e) {
            return e > 1 && e < 5 && ~~(e / 10) != 1;
          }
          function S(e, n, d, _) {
            var p = e + " ";
            switch (d) {
              case "s":
                return n || _ ? "pár sekund" : "pár sekundami";
              case "ss":
                return n || _ ? p + (m(e) ? "sekundy" : "sekund") : p + "sekundami";
              case "m":
                return n ? "minuta" : _ ? "minutu" : "minutou";
              case "mm":
                return n || _ ? p + (m(e) ? "minuty" : "minut") : p + "minutami";
              case "h":
                return n ? "hodina" : _ ? "hodinu" : "hodinou";
              case "hh":
                return n || _ ? p + (m(e) ? "hodiny" : "hodin") : p + "hodinami";
              case "d":
                return n || _ ? "den" : "dnem";
              case "dd":
                return n || _ ? p + (m(e) ? "dny" : "dní") : p + "dny";
              case "M":
                return n || _ ? "měsíc" : "měsícem";
              case "MM":
                return n || _ ? p + (m(e) ? "měsíce" : "měsíců") : p + "měsíci";
              case "y":
                return n || _ ? "rok" : "rokem";
              case "yy":
                return n || _ ? p + (m(e) ? "roky" : "let") : p + "lety";
            }
          }
          A.defineLocale("cs", { months: l, monthsShort: o, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i, monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"), weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"), weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm", l: "D. M. YYYY" }, calendar: { sameDay: "[dnes v] LT", nextDay: "[zítra v] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v neděli v] LT";
              case 1:
              case 2:
                return "[v] dddd [v] LT";
              case 3:
                return "[ve středu v] LT";
              case 4:
                return "[ve čtvrtek v] LT";
              case 5:
                return "[v pátek v] LT";
              case 6:
                return "[v sobotu v] LT";
            }
          }, lastDay: "[včera v] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulou neděli v] LT";
              case 1:
              case 2:
                return "[minulé] dddd [v] LT";
              case 3:
                return "[minulou středu v] LT";
              case 4:
              case 5:
                return "[minulý] dddd [v] LT";
              case 6:
                return "[minulou sobotu v] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "před %s", s: S, ss: S, m: S, mm: S, h: S, hh: S, d: S, dd: S, M: S, MM: S, y: S, yy: S }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 3944: function(L, h, b) {
        (function(A) {
          A.defineLocale("cv", { months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"), monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"), weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"), weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"), weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]", LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm", LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm" }, calendar: { sameDay: "[Паян] LT [сехетре]", nextDay: "[Ыран] LT [сехетре]", lastDay: "[Ӗнер] LT [сехетре]", nextWeek: "[Ҫитес] dddd LT [сехетре]", lastWeek: "[Иртнӗ] dddd LT [сехетре]", sameElse: "L" }, relativeTime: { future: function(l) {
            return l + (/сехет$/i.exec(l) ? "рен" : /ҫул$/i.exec(l) ? "тан" : "ран");
          }, past: "%s каялла", s: "пӗр-ик ҫеккунт", ss: "%d ҫеккунт", m: "пӗр минут", mm: "%d минут", h: "пӗр сехет", hh: "%d сехет", d: "пӗр кун", dd: "%d кун", M: "пӗр уйӑх", MM: "%d уйӑх", y: "пӗр ҫул", yy: "%d ҫул" }, dayOfMonthOrdinalParse: /\d{1,2}-мӗш/, ordinal: "%d-мӗш", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 9381: function(L, h, b) {
        (function(A) {
          A.defineLocale("cy", { months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"), monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"), weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"), weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"), weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Heddiw am] LT", nextDay: "[Yfory am] LT", nextWeek: "dddd [am] LT", lastDay: "[Ddoe am] LT", lastWeek: "dddd [diwethaf am] LT", sameElse: "L" }, relativeTime: { future: "mewn %s", past: "%s yn ôl", s: "ychydig eiliadau", ss: "%d eiliad", m: "munud", mm: "%d munud", h: "awr", hh: "%d awr", d: "diwrnod", dd: "%d diwrnod", M: "mis", MM: "%d mis", y: "blwyddyn", yy: "%d flynedd" }, dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/, ordinal: function(l) {
            var o = "";
            return l > 20 ? o = l === 40 || l === 50 || l === 60 || l === 80 || l === 100 ? "fed" : "ain" : l > 0 && (o = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"][l]), l + o;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8782: function(L, h, b) {
        (function(A) {
          A.defineLocale("da", { months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "på dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[i] dddd[s kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "få sekunder", ss: "%d sekunder", m: "et minut", mm: "%d minutter", h: "en time", hh: "%d timer", d: "en dag", dd: "%d dage", M: "en måned", MM: "%d måneder", y: "et år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2170: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [o + " Tage", o + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [o + " Monate", o + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [o + " Jahre", o + " Jahren"] };
            return u ? S[g][0] : S[g][1];
          }
          A.defineLocale("de-at", { months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: l, mm: "%d Minuten", h: l, hh: "%d Stunden", d: l, dd: l, w: l, ww: "%d Wochen", M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1020: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [o + " Tage", o + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [o + " Monate", o + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [o + " Jahre", o + " Jahren"] };
            return u ? S[g][0] : S[g][1];
          }
          A.defineLocale("de-ch", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: l, mm: "%d Minuten", h: l, hh: "%d Stunden", d: l, dd: l, w: l, ww: "%d Wochen", M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4722: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { m: ["eine Minute", "einer Minute"], h: ["eine Stunde", "einer Stunde"], d: ["ein Tag", "einem Tag"], dd: [o + " Tage", o + " Tagen"], w: ["eine Woche", "einer Woche"], M: ["ein Monat", "einem Monat"], MM: [o + " Monate", o + " Monaten"], y: ["ein Jahr", "einem Jahr"], yy: [o + " Jahre", o + " Jahren"] };
            return u ? S[g][0] : S[g][1];
          }
          A.defineLocale("de", { months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"), weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY HH:mm", LLLL: "dddd, D. MMMM YYYY HH:mm" }, calendar: { sameDay: "[heute um] LT [Uhr]", sameElse: "L", nextDay: "[morgen um] LT [Uhr]", nextWeek: "dddd [um] LT [Uhr]", lastDay: "[gestern um] LT [Uhr]", lastWeek: "[letzten] dddd [um] LT [Uhr]" }, relativeTime: { future: "in %s", past: "vor %s", s: "ein paar Sekunden", ss: "%d Sekunden", m: l, mm: "%d Minuten", h: l, hh: "%d Stunden", d: l, dd: l, w: l, ww: "%d Wochen", M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 9295: function(L, h, b) {
        (function(A) {
          var l = ["ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު"], o = ["އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު"];
          A.defineLocale("dv", { months: l, monthsShort: l, weekdays: o, weekdaysShort: o, weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "D/M/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, meridiemParse: /މކ|މފ/, isPM: function(u) {
            return u === "މފ";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "މކ" : "މފ";
          }, calendar: { sameDay: "[މިއަދު] LT", nextDay: "[މާދަމާ] LT", nextWeek: "dddd LT", lastDay: "[އިއްޔެ] LT", lastWeek: "[ފާއިތުވި] dddd LT", sameElse: "L" }, relativeTime: { future: "ތެރޭގައި %s", past: "ކުރިން %s", s: "ސިކުންތުކޮޅެއް", ss: "d% ސިކުންތު", m: "މިނިޓެއް", mm: "މިނިޓު %d", h: "ގަޑިއިރެއް", hh: "ގަޑިއިރު %d", d: "ދުވަހެއް", dd: "ދުވަސް %d", M: "މަހެއް", MM: "މަސް %d", y: "އަހަރެއް", yy: "އަހަރު %d" }, preparse: function(u) {
            return u.replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/,/g, "،");
          }, week: { dow: 7, doy: 12 } });
        })(b(7840));
      }, 3372: function(L, h, b) {
        (function(A) {
          A.defineLocale("el", { monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"), monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"), months: function(l, o) {
            return l ? typeof o == "string" && /D/.test(o.substring(0, o.indexOf("MMMM"))) ? this._monthsGenitiveEl[l.month()] : this._monthsNominativeEl[l.month()] : this._monthsNominativeEl;
          }, monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"), weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"), weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"), weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"), meridiem: function(l, o, u) {
            return l > 11 ? u ? "μμ" : "ΜΜ" : u ? "πμ" : "ΠΜ";
          }, isPM: function(l) {
            return (l + "").toLowerCase()[0] === "μ";
          }, meridiemParse: /[ΠΜ]\.?Μ?\.?/i, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendarEl: { sameDay: "[Σήμερα {}] LT", nextDay: "[Αύριο {}] LT", nextWeek: "dddd [{}] LT", lastDay: "[Χθες {}] LT", lastWeek: function() {
            return this.day() === 6 ? "[το προηγούμενο] dddd [{}] LT" : "[την προηγούμενη] dddd [{}] LT";
          }, sameElse: "L" }, calendar: function(l, o) {
            var u, g = this._calendarEl[l], m = o && o.hours();
            return u = g, (typeof Function < "u" && u instanceof Function || Object.prototype.toString.call(u) === "[object Function]") && (g = g.apply(o)), g.replace("{}", m % 12 == 1 ? "στη" : "στις");
          }, relativeTime: { future: "σε %s", past: "%s πριν", s: "λίγα δευτερόλεπτα", ss: "%d δευτερόλεπτα", m: "ένα λεπτό", mm: "%d λεπτά", h: "μία ώρα", hh: "%d ώρες", d: "μία μέρα", dd: "%d μέρες", M: "ένας μήνας", MM: "%d μήνες", y: "ένας χρόνος", yy: "%d χρόνια" }, dayOfMonthOrdinalParse: /\d{1,2}η/, ordinal: "%dη", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 3797: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-au", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 0, doy: 4 } });
        })(b(7840));
      }, 8479: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-ca", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "YYYY-MM-DD", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          } });
        })(b(7840));
      }, 4086: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-gb", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 3309: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-ie", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 150: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-il", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          } });
        })(b(7840));
      }, 2332: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-in", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 2239: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-nz", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5501: function(L, h, b) {
        (function(A) {
          A.defineLocale("en-sg", { months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 325: function(L, h, b) {
        (function(A) {
          A.defineLocale("eo", { months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"), monthsShort: "jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec".split("_"), weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"), weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"), weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "[la] D[-an de] MMMM, YYYY", LLL: "[la] D[-an de] MMMM, YYYY HH:mm", LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm", llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm" }, meridiemParse: /[ap]\.t\.m/i, isPM: function(l) {
            return l.charAt(0).toLowerCase() === "p";
          }, meridiem: function(l, o, u) {
            return l > 11 ? u ? "p.t.m." : "P.T.M." : u ? "a.t.m." : "A.T.M.";
          }, calendar: { sameDay: "[Hodiaŭ je] LT", nextDay: "[Morgaŭ je] LT", nextWeek: "dddd[n je] LT", lastDay: "[Hieraŭ je] LT", lastWeek: "[pasintan] dddd[n je] LT", sameElse: "L" }, relativeTime: { future: "post %s", past: "antaŭ %s", s: "kelkaj sekundoj", ss: "%d sekundoj", m: "unu minuto", mm: "%d minutoj", h: "unu horo", hh: "%d horoj", d: "unu tago", dd: "%d tagoj", M: "unu monato", MM: "%d monatoj", y: "unu jaro", yy: "%d jaroj" }, dayOfMonthOrdinalParse: /\d{1,2}a/, ordinal: "%da", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 8143: function(L, h, b) {
        (function(A) {
          var l = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), o = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), u = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], g = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          A.defineLocale("es-do", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1075: function(L, h, b) {
        (function(A) {
          var l = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), o = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), u = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], g = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          A.defineLocale("es-mx", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 0, doy: 4 }, invalidDate: "Fecha inválida" });
        })(b(7840));
      }, 246: function(L, h, b) {
        (function(A) {
          var l = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), o = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), u = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], g = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          A.defineLocale("es-us", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "MM/DD/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY h:mm A", LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 4049: function(L, h, b) {
        (function(A) {
          var l = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"), o = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), u = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i], g = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
          A.defineLocale("es", { months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i, monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"), weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"), weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextDay: function() {
            return "[mañana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, nextWeek: function() {
            return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastDay: function() {
            return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, lastWeek: function() {
            return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: "en %s", past: "hace %s", s: "unos segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "una hora", hh: "%d horas", d: "un día", dd: "%d días", w: "una semana", ww: "%d semanas", M: "un mes", MM: "%d meses", y: "un año", yy: "%d años" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 }, invalidDate: "Fecha inválida" });
        })(b(7840));
      }, 180: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { s: ["mõne sekundi", "mõni sekund", "paar sekundit"], ss: [o + "sekundi", o + "sekundit"], m: ["ühe minuti", "üks minut"], mm: [o + " minuti", o + " minutit"], h: ["ühe tunni", "tund aega", "üks tund"], hh: [o + " tunni", o + " tundi"], d: ["ühe päeva", "üks päev"], M: ["kuu aja", "kuu aega", "üks kuu"], MM: [o + " kuu", o + " kuud"], y: ["ühe aasta", "aasta", "üks aasta"], yy: [o + " aasta", o + " aastat"] };
            return u ? S[g][2] ? S[g][2] : S[g][1] : m ? S[g][0] : S[g][1];
          }
          A.defineLocale("et", { months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"), monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"), weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"), weekdaysShort: "P_E_T_K_N_R_L".split("_"), weekdaysMin: "P_E_T_K_N_R_L".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[Täna,] LT", nextDay: "[Homme,] LT", nextWeek: "[Järgmine] dddd LT", lastDay: "[Eile,] LT", lastWeek: "[Eelmine] dddd LT", sameElse: "L" }, relativeTime: { future: "%s pärast", past: "%s tagasi", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: "%d päeva", M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 9707: function(L, h, b) {
        (function(A) {
          A.defineLocale("eu", { months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"), monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"), monthsParseExact: !0, weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"), weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"), weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY[ko] MMMM[ren] D[a]", LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm", LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm", l: "YYYY-M-D", ll: "YYYY[ko] MMM D[a]", lll: "YYYY[ko] MMM D[a] HH:mm", llll: "ddd, YYYY[ko] MMM D[a] HH:mm" }, calendar: { sameDay: "[gaur] LT[etan]", nextDay: "[bihar] LT[etan]", nextWeek: "dddd LT[etan]", lastDay: "[atzo] LT[etan]", lastWeek: "[aurreko] dddd LT[etan]", sameElse: "L" }, relativeTime: { future: "%s barru", past: "duela %s", s: "segundo batzuk", ss: "%d segundo", m: "minutu bat", mm: "%d minutu", h: "ordu bat", hh: "%d ordu", d: "egun bat", dd: "%d egun", M: "hilabete bat", MM: "%d hilabete", y: "urte bat", yy: "%d urte" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 4576: function(L, h, b) {
        (function(A) {
          var l = { 1: "۱", 2: "۲", 3: "۳", 4: "۴", 5: "۵", 6: "۶", 7: "۷", 8: "۸", 9: "۹", 0: "۰" }, o = { "۱": "1", "۲": "2", "۳": "3", "۴": "4", "۵": "5", "۶": "6", "۷": "7", "۸": "8", "۹": "9", "۰": "0" };
          A.defineLocale("fa", { months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"), weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"), weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /قبل از ظهر|بعد از ظهر/, isPM: function(u) {
            return /بعد از ظهر/.test(u);
          }, meridiem: function(u, g, m) {
            return u < 12 ? "قبل از ظهر" : "بعد از ظهر";
          }, calendar: { sameDay: "[امروز ساعت] LT", nextDay: "[فردا ساعت] LT", nextWeek: "dddd [ساعت] LT", lastDay: "[دیروز ساعت] LT", lastWeek: "dddd [پیش] [ساعت] LT", sameElse: "L" }, relativeTime: { future: "در %s", past: "%s پیش", s: "چند ثانیه", ss: "%d ثانیه", m: "یک دقیقه", mm: "%d دقیقه", h: "یک ساعت", hh: "%d ساعت", d: "یک روز", dd: "%d روز", M: "یک ماه", MM: "%d ماه", y: "یک سال", yy: "%d سال" }, preparse: function(u) {
            return u.replace(/[۰-۹]/g, function(g) {
              return o[g];
            }).replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            }).replace(/,/g, "،");
          }, dayOfMonthOrdinalParse: /\d{1,2}م/, ordinal: "%dم", week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 3016: function(L, h, b) {
        (function(A) {
          var l = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "), o = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", l[7], l[8], l[9]];
          function u(g, m, S, e) {
            var n = "";
            switch (S) {
              case "s":
                return e ? "muutaman sekunnin" : "muutama sekunti";
              case "ss":
                n = e ? "sekunnin" : "sekuntia";
                break;
              case "m":
                return e ? "minuutin" : "minuutti";
              case "mm":
                n = e ? "minuutin" : "minuuttia";
                break;
              case "h":
                return e ? "tunnin" : "tunti";
              case "hh":
                n = e ? "tunnin" : "tuntia";
                break;
              case "d":
                return e ? "päivän" : "päivä";
              case "dd":
                n = e ? "päivän" : "päivää";
                break;
              case "M":
                return e ? "kuukauden" : "kuukausi";
              case "MM":
                n = e ? "kuukauden" : "kuukautta";
                break;
              case "y":
                return e ? "vuoden" : "vuosi";
              case "yy":
                n = e ? "vuoden" : "vuotta";
            }
            return function(d, _) {
              return d < 10 ? _ ? o[d] : l[d] : d;
            }(g, e) + " " + n;
          }
          A.defineLocale("fi", { months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"), monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"), weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"), weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"), weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "Do MMMM[ta] YYYY", LLL: "Do MMMM[ta] YYYY, [klo] HH.mm", LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm", l: "D.M.YYYY", ll: "Do MMM YYYY", lll: "Do MMM YYYY, [klo] HH.mm", llll: "ddd, Do MMM YYYY, [klo] HH.mm" }, calendar: { sameDay: "[tänään] [klo] LT", nextDay: "[huomenna] [klo] LT", nextWeek: "dddd [klo] LT", lastDay: "[eilen] [klo] LT", lastWeek: "[viime] dddd[na] [klo] LT", sameElse: "L" }, relativeTime: { future: "%s päästä", past: "%s sitten", s: u, ss: u, m: u, mm: u, h: u, hh: u, d: u, dd: u, M: u, MM: u, y: u, yy: u }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2158: function(L, h, b) {
        (function(A) {
          A.defineLocale("fil", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(l) {
            return l;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5790: function(L, h, b) {
        (function(A) {
          A.defineLocale("fo", { months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"), weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"), weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"), weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D. MMMM, YYYY HH:mm" }, calendar: { sameDay: "[Í dag kl.] LT", nextDay: "[Í morgin kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[Í gjár kl.] LT", lastWeek: "[síðstu] dddd [kl] LT", sameElse: "L" }, relativeTime: { future: "um %s", past: "%s síðani", s: "fá sekund", ss: "%d sekundir", m: "ein minuttur", mm: "%d minuttir", h: "ein tími", hh: "%d tímar", d: "ein dagur", dd: "%d dagar", M: "ein mánaður", MM: "%d mánaðir", y: "eitt ár", yy: "%d ár" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8030: function(L, h, b) {
        (function(A) {
          A.defineLocale("fr-ca", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(l, o) {
            switch (o) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return l + (l === 1 ? "er" : "e");
              case "w":
              case "W":
                return l + (l === 1 ? "re" : "e");
            }
          } });
        })(b(7840));
      }, 3669: function(L, h, b) {
        (function(A) {
          A.defineLocale("fr-ch", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsParseExact: !0, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|e)/, ordinal: function(l, o) {
            switch (o) {
              default:
              case "M":
              case "Q":
              case "D":
              case "DDD":
              case "d":
                return l + (l === 1 ? "er" : "e");
              case "w":
              case "W":
                return l + (l === 1 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5097: function(L, h, b) {
        (function(A) {
          var l = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, o = [/^janv/i, /^févr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^août/i, /^sept/i, /^oct/i, /^nov/i, /^déc/i];
          A.defineLocale("fr", { months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"), monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"), monthsRegex: l, monthsShortRegex: l, monthsStrictRegex: /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i, monthsShortStrictRegex: /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i, monthsParse: o, longMonthsParse: o, shortMonthsParse: o, weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"), weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"), weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Aujourd’hui à] LT", nextDay: "[Demain à] LT", nextWeek: "dddd [à] LT", lastDay: "[Hier à] LT", lastWeek: "dddd [dernier à] LT", sameElse: "L" }, relativeTime: { future: "dans %s", past: "il y a %s", s: "quelques secondes", ss: "%d secondes", m: "une minute", mm: "%d minutes", h: "une heure", hh: "%d heures", d: "un jour", dd: "%d jours", w: "une semaine", ww: "%d semaines", M: "un mois", MM: "%d mois", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(er|)/, ordinal: function(u, g) {
            switch (g) {
              case "D":
                return u + (u === 1 ? "er" : "");
              default:
              case "M":
              case "Q":
              case "DDD":
              case "d":
                return u + (u === 1 ? "er" : "e");
              case "w":
              case "W":
                return u + (u === 1 ? "re" : "e");
            }
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8664: function(L, h, b) {
        (function(A) {
          var l = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), o = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
          A.defineLocale("fy", { months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"), monthsShort: function(u, g) {
            return u ? /-MMM-/.test(g) ? o[u.month()] : l[u.month()] : l;
          }, monthsParseExact: !0, weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"), weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"), weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[hjoed om] LT", nextDay: "[moarn om] LT", nextWeek: "dddd [om] LT", lastDay: "[juster om] LT", lastWeek: "[ôfrûne] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "oer %s", past: "%s lyn", s: "in pear sekonden", ss: "%d sekonden", m: "ien minút", mm: "%d minuten", h: "ien oere", hh: "%d oeren", d: "ien dei", dd: "%d dagen", M: "ien moanne", MM: "%d moannen", y: "ien jier", yy: "%d jierren" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(u) {
            return u + (u === 1 || u === 8 || u >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 409: function(L, h, b) {
        (function(A) {
          A.defineLocale("ga", { months: ["Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig"], monthsShort: ["Ean", "Feabh", "Márt", "Aib", "Beal", "Meith", "Iúil", "Lún", "M.F.", "D.F.", "Samh", "Noll"], monthsParseExact: !0, weekdays: ["Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn"], weekdaysShort: ["Domh", "Luan", "Máirt", "Céad", "Déar", "Aoine", "Sath"], weekdaysMin: ["Do", "Lu", "Má", "Cé", "Dé", "A", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Inniu ag] LT", nextDay: "[Amárach ag] LT", nextWeek: "dddd [ag] LT", lastDay: "[Inné ag] LT", lastWeek: "dddd [seo caite] [ag] LT", sameElse: "L" }, relativeTime: { future: "i %s", past: "%s ó shin", s: "cúpla soicind", ss: "%d soicind", m: "nóiméad", mm: "%d nóiméad", h: "uair an chloig", hh: "%d uair an chloig", d: "lá", dd: "%d lá", M: "mí", MM: "%d míonna", y: "bliain", yy: "%d bliain" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(l) {
            return l + (l === 1 ? "d" : l % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4198: function(L, h, b) {
        (function(A) {
          A.defineLocale("gd", { months: ["Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd"], monthsShort: ["Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh"], monthsParseExact: !0, weekdays: ["Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"], weekdaysShort: ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], weekdaysMin: ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"], longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[An-diugh aig] LT", nextDay: "[A-màireach aig] LT", nextWeek: "dddd [aig] LT", lastDay: "[An-dè aig] LT", lastWeek: "dddd [seo chaidh] [aig] LT", sameElse: "L" }, relativeTime: { future: "ann an %s", past: "bho chionn %s", s: "beagan diogan", ss: "%d diogan", m: "mionaid", mm: "%d mionaidean", h: "uair", hh: "%d uairean", d: "latha", dd: "%d latha", M: "mìos", MM: "%d mìosan", y: "bliadhna", yy: "%d bliadhna" }, dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/, ordinal: function(l) {
            return l + (l === 1 ? "d" : l % 10 == 2 ? "na" : "mh");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2638: function(L, h, b) {
        (function(A) {
          A.defineLocale("gl", { months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"), monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"), weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"), weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY H:mm", LLLL: "dddd, D [de] MMMM [de] YYYY H:mm" }, calendar: { sameDay: function() {
            return "[hoxe " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
          }, nextDay: function() {
            return "[mañá " + (this.hours() !== 1 ? "ás" : "á") + "] LT";
          }, nextWeek: function() {
            return "dddd [" + (this.hours() !== 1 ? "ás" : "a") + "] LT";
          }, lastDay: function() {
            return "[onte " + (this.hours() !== 1 ? "á" : "a") + "] LT";
          }, lastWeek: function() {
            return "[o] dddd [pasado " + (this.hours() !== 1 ? "ás" : "a") + "] LT";
          }, sameElse: "L" }, relativeTime: { future: function(l) {
            return l.indexOf("un") === 0 ? "n" + l : "en " + l;
          }, past: "hai %s", s: "uns segundos", ss: "%d segundos", m: "un minuto", mm: "%d minutos", h: "unha hora", hh: "%d horas", d: "un día", dd: "%d días", M: "un mes", MM: "%d meses", y: "un ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 9871: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { s: ["थोडया सॅकंडांनी", "थोडे सॅकंड"], ss: [o + " सॅकंडांनी", o + " सॅकंड"], m: ["एका मिणटान", "एक मिनूट"], mm: [o + " मिणटांनी", o + " मिणटां"], h: ["एका वरान", "एक वर"], hh: [o + " वरांनी", o + " वरां"], d: ["एका दिसान", "एक दीस"], dd: [o + " दिसांनी", o + " दीस"], M: ["एका म्हयन्यान", "एक म्हयनो"], MM: [o + " म्हयन्यानी", o + " म्हयने"], y: ["एका वर्सान", "एक वर्स"], yy: [o + " वर्सांनी", o + " वर्सां"] };
            return m ? S[g][0] : S[g][1];
          }
          A.defineLocale("gom-deva", { months: { standalone: "जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), format: "जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), monthsParseExact: !0, weekdays: "आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार".split("_"), weekdaysShort: "आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.".split("_"), weekdaysMin: "आ_सो_मं_बु_ब्रे_सु_शे".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm [वाजतां]", LTS: "A h:mm:ss [वाजतां]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [वाजतां]", LLLL: "dddd, MMMM Do, YYYY, A h:mm [वाजतां]", llll: "ddd, D MMM YYYY, A h:mm [वाजतां]" }, calendar: { sameDay: "[आयज] LT", nextDay: "[फाल्यां] LT", nextWeek: "[फुडलो] dddd[,] LT", lastDay: "[काल] LT", lastWeek: "[फाटलो] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s आदीं", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}(वेर)/, ordinal: function(o, u) {
            return u === "D" ? o + "वेर" : o;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /राती|सकाळीं|दनपारां|सांजे/, meridiemHour: function(o, u) {
            return o === 12 && (o = 0), u === "राती" ? o < 4 ? o : o + 12 : u === "सकाळीं" ? o : u === "दनपारां" ? o > 12 ? o : o + 12 : u === "सांजे" ? o + 12 : void 0;
          }, meridiem: function(o, u, g) {
            return o < 4 ? "राती" : o < 12 ? "सकाळीं" : o < 16 ? "दनपारां" : o < 20 ? "सांजे" : "राती";
          } });
        })(b(7840));
      }, 2624: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { s: ["thoddea sekondamni", "thodde sekond"], ss: [o + " sekondamni", o + " sekond"], m: ["eka mintan", "ek minut"], mm: [o + " mintamni", o + " mintam"], h: ["eka voran", "ek vor"], hh: [o + " voramni", o + " voram"], d: ["eka disan", "ek dis"], dd: [o + " disamni", o + " dis"], M: ["eka mhoinean", "ek mhoino"], MM: [o + " mhoineamni", o + " mhoine"], y: ["eka vorsan", "ek voros"], yy: [o + " vorsamni", o + " vorsam"] };
            return m ? S[g][0] : S[g][1];
          }
          A.defineLocale("gom-latn", { months: { standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"), format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"), isFormat: /MMMM(\s)+D[oD]?/ }, monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"), weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"), weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "A h:mm [vazta]", LTS: "A h:mm:ss [vazta]", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY A h:mm [vazta]", LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]", llll: "ddd, D MMM YYYY, A h:mm [vazta]" }, calendar: { sameDay: "[Aiz] LT", nextDay: "[Faleam] LT", nextWeek: "[Fuddlo] dddd[,] LT", lastDay: "[Kal] LT", lastWeek: "[Fattlo] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%s", past: "%s adim", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}(er)/, ordinal: function(o, u) {
            return u === "D" ? o + "er" : o;
          }, week: { dow: 0, doy: 3 }, meridiemParse: /rati|sokallim|donparam|sanje/, meridiemHour: function(o, u) {
            return o === 12 && (o = 0), u === "rati" ? o < 4 ? o : o + 12 : u === "sokallim" ? o : u === "donparam" ? o > 12 ? o : o + 12 : u === "sanje" ? o + 12 : void 0;
          }, meridiem: function(o, u, g) {
            return o < 4 ? "rati" : o < 12 ? "sokallim" : o < 16 ? "donparam" : o < 20 ? "sanje" : "rati";
          } });
        })(b(7840));
      }, 2053: function(L, h, b) {
        (function(A) {
          var l = { 1: "૧", 2: "૨", 3: "૩", 4: "૪", 5: "૫", 6: "૬", 7: "૭", 8: "૮", 9: "૯", 0: "૦" }, o = { "૧": "1", "૨": "2", "૩": "3", "૪": "4", "૫": "5", "૬": "6", "૭": "7", "૮": "8", "૯": "9", "૦": "0" };
          A.defineLocale("gu", { months: "જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર".split("_"), monthsShort: "જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.".split("_"), monthsParseExact: !0, weekdays: "રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર".split("_"), weekdaysShort: "રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ".split("_"), weekdaysMin: "ર_સો_મં_બુ_ગુ_શુ_શ".split("_"), longDateFormat: { LT: "A h:mm વાગ્યે", LTS: "A h:mm:ss વાગ્યે", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm વાગ્યે", LLLL: "dddd, D MMMM YYYY, A h:mm વાગ્યે" }, calendar: { sameDay: "[આજ] LT", nextDay: "[કાલે] LT", nextWeek: "dddd, LT", lastDay: "[ગઇકાલે] LT", lastWeek: "[પાછલા] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s મા", past: "%s પહેલા", s: "અમુક પળો", ss: "%d સેકંડ", m: "એક મિનિટ", mm: "%d મિનિટ", h: "એક કલાક", hh: "%d કલાક", d: "એક દિવસ", dd: "%d દિવસ", M: "એક મહિનો", MM: "%d મહિનો", y: "એક વર્ષ", yy: "%d વર્ષ" }, preparse: function(u) {
            return u.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /રાત|બપોર|સવાર|સાંજ/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "રાત" ? u < 4 ? u : u + 12 : g === "સવાર" ? u : g === "બપોર" ? u >= 10 ? u : u + 12 : g === "સાંજ" ? u + 12 : void 0;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "રાત" : u < 10 ? "સવાર" : u < 17 ? "બપોર" : u < 20 ? "સાંજ" : "રાત";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 278: function(L, h, b) {
        (function(A) {
          A.defineLocale("he", { months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"), monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"), weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"), weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"), weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [ב]MMMM YYYY", LLL: "D [ב]MMMM YYYY HH:mm", LLLL: "dddd, D [ב]MMMM YYYY HH:mm", l: "D/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[היום ב־]LT", nextDay: "[מחר ב־]LT", nextWeek: "dddd [בשעה] LT", lastDay: "[אתמול ב־]LT", lastWeek: "[ביום] dddd [האחרון בשעה] LT", sameElse: "L" }, relativeTime: { future: "בעוד %s", past: "לפני %s", s: "מספר שניות", ss: "%d שניות", m: "דקה", mm: "%d דקות", h: "שעה", hh: function(l) {
            return l === 2 ? "שעתיים" : l + " שעות";
          }, d: "יום", dd: function(l) {
            return l === 2 ? "יומיים" : l + " ימים";
          }, M: "חודש", MM: function(l) {
            return l === 2 ? "חודשיים" : l + " חודשים";
          }, y: "שנה", yy: function(l) {
            return l === 2 ? "שנתיים" : l % 10 == 0 && l !== 10 ? l + " שנה" : l + " שנים";
          } }, meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i, isPM: function(l) {
            return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(l);
          }, meridiem: function(l, o, u) {
            return l < 5 ? "לפנות בוקר" : l < 10 ? "בבוקר" : l < 12 ? u ? 'לפנה"צ' : "לפני הצהריים" : l < 18 ? u ? 'אחה"צ' : "אחרי הצהריים" : "בערב";
          } });
        })(b(7840));
      }, 8818: function(L, h, b) {
        (function(A) {
          var l = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, o = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" }, u = [/^जन/i, /^फ़र|फर/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सितं|सित/i, /^अक्टू/i, /^नव|नवं/i, /^दिसं|दिस/i];
          A.defineLocale("hi", { months: { format: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"), standalone: "जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर".split("_") }, monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"), weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm बजे", LTS: "A h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm बजे", LLLL: "dddd, D MMMM YYYY, A h:mm बजे" }, monthsParse: u, longMonthsParse: u, shortMonthsParse: [/^जन/i, /^फ़र/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सित/i, /^अक्टू/i, /^नव/i, /^दिस/i], monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i, monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i, monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i, monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i, calendar: { sameDay: "[आज] LT", nextDay: "[कल] LT", nextWeek: "dddd, LT", lastDay: "[कल] LT", lastWeek: "[पिछले] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s में", past: "%s पहले", s: "कुछ ही क्षण", ss: "%d सेकंड", m: "एक मिनट", mm: "%d मिनट", h: "एक घंटा", hh: "%d घंटे", d: "एक दिन", dd: "%d दिन", M: "एक महीने", MM: "%d महीने", y: "एक वर्ष", yy: "%d वर्ष" }, preparse: function(g) {
            return g.replace(/[१२३४५६७८९०]/g, function(m) {
              return o[m];
            });
          }, postformat: function(g) {
            return g.replace(/\d/g, function(m) {
              return l[m];
            });
          }, meridiemParse: /रात|सुबह|दोपहर|शाम/, meridiemHour: function(g, m) {
            return g === 12 && (g = 0), m === "रात" ? g < 4 ? g : g + 12 : m === "सुबह" ? g : m === "दोपहर" ? g >= 10 ? g : g + 12 : m === "शाम" ? g + 12 : void 0;
          }, meridiem: function(g, m, S) {
            return g < 4 ? "रात" : g < 10 ? "सुबह" : g < 17 ? "दोपहर" : g < 20 ? "शाम" : "रात";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 9543: function(L, h, b) {
        (function(A) {
          function l(o, u, g) {
            var m = o + " ";
            switch (g) {
              case "ss":
                return m + (o === 1 ? "sekunda" : o === 2 || o === 3 || o === 4 ? "sekunde" : "sekundi");
              case "m":
                return u ? "jedna minuta" : "jedne minute";
              case "mm":
                return m + (o === 1 ? "minuta" : o === 2 || o === 3 || o === 4 ? "minute" : "minuta");
              case "h":
                return u ? "jedan sat" : "jednog sata";
              case "hh":
                return m + (o === 1 ? "sat" : o === 2 || o === 3 || o === 4 ? "sata" : "sati");
              case "dd":
                return m + (o === 1 ? "dan" : "dana");
              case "MM":
                return m + (o === 1 ? "mjesec" : o === 2 || o === 3 || o === 4 ? "mjeseca" : "mjeseci");
              case "yy":
                return m + (o === 1 ? "godina" : o === 2 || o === 3 || o === 4 ? "godine" : "godina");
            }
          }
          A.defineLocale("hr", { months: { format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"), standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_") }, monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM YYYY", LLL: "Do MMMM YYYY H:mm", LLLL: "dddd, Do MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[jučer u] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prošlu] [nedjelju] [u] LT";
              case 3:
                return "[prošlu] [srijedu] [u] LT";
              case 6:
                return "[prošle] [subote] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prošli] dddd [u] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "par sekundi", ss: l, m: l, mm: l, h: l, hh: l, d: "dan", dd: l, M: "mjesec", MM: l, y: "godinu", yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 4630: function(L, h, b) {
        (function(A) {
          var l = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");
          function o(g, m, S, e) {
            var n = g;
            switch (S) {
              case "s":
                return e || m ? "néhány másodperc" : "néhány másodperce";
              case "ss":
                return n + (e || m) ? " másodperc" : " másodperce";
              case "m":
                return "egy" + (e || m ? " perc" : " perce");
              case "mm":
                return n + (e || m ? " perc" : " perce");
              case "h":
                return "egy" + (e || m ? " óra" : " órája");
              case "hh":
                return n + (e || m ? " óra" : " órája");
              case "d":
                return "egy" + (e || m ? " nap" : " napja");
              case "dd":
                return n + (e || m ? " nap" : " napja");
              case "M":
                return "egy" + (e || m ? " hónap" : " hónapja");
              case "MM":
                return n + (e || m ? " hónap" : " hónapja");
              case "y":
                return "egy" + (e || m ? " év" : " éve");
              case "yy":
                return n + (e || m ? " év" : " éve");
            }
            return "";
          }
          function u(g) {
            return (g ? "" : "[múlt] ") + "[" + l[this.day()] + "] LT[-kor]";
          }
          A.defineLocale("hu", { months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"), monthsShort: "jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"), weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"), weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY. MMMM D.", LLL: "YYYY. MMMM D. H:mm", LLLL: "YYYY. MMMM D., dddd H:mm" }, meridiemParse: /de|du/i, isPM: function(g) {
            return g.charAt(1).toLowerCase() === "u";
          }, meridiem: function(g, m, S) {
            return g < 12 ? S === !0 ? "de" : "DE" : S === !0 ? "du" : "DU";
          }, calendar: { sameDay: "[ma] LT[-kor]", nextDay: "[holnap] LT[-kor]", nextWeek: function() {
            return u.call(this, !0);
          }, lastDay: "[tegnap] LT[-kor]", lastWeek: function() {
            return u.call(this, !1);
          }, sameElse: "L" }, relativeTime: { future: "%s múlva", past: "%s", s: o, ss: o, m: o, mm: o, h: o, hh: o, d: o, dd: o, M: o, MM: o, y: o, yy: o }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2417: function(L, h, b) {
        (function(A) {
          A.defineLocale("hy-am", { months: { format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"), standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_") }, monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"), weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"), weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY թ.", LLL: "D MMMM YYYY թ., HH:mm", LLLL: "dddd, D MMMM YYYY թ., HH:mm" }, calendar: { sameDay: "[այսօր] LT", nextDay: "[վաղը] LT", lastDay: "[երեկ] LT", nextWeek: function() {
            return "dddd [օրը ժամը] LT";
          }, lastWeek: function() {
            return "[անցած] dddd [օրը ժամը] LT";
          }, sameElse: "L" }, relativeTime: { future: "%s հետո", past: "%s առաջ", s: "մի քանի վայրկյան", ss: "%d վայրկյան", m: "րոպե", mm: "%d րոպե", h: "ժամ", hh: "%d ժամ", d: "օր", dd: "%d օր", M: "ամիս", MM: "%d ամիս", y: "տարի", yy: "%d տարի" }, meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/, isPM: function(l) {
            return /^(ցերեկվա|երեկոյան)$/.test(l);
          }, meridiem: function(l) {
            return l < 4 ? "գիշերվա" : l < 12 ? "առավոտվա" : l < 17 ? "ցերեկվա" : "երեկոյան";
          }, dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/, ordinal: function(l, o) {
            switch (o) {
              case "DDD":
              case "w":
              case "W":
              case "DDDo":
                return l === 1 ? l + "-ին" : l + "-րդ";
              default:
                return l;
            }
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 424: function(L, h, b) {
        (function(A) {
          A.defineLocale("id", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"), weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"), weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|siang|sore|malam/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "pagi" ? l : o === "siang" ? l >= 11 ? l : l + 12 : o === "sore" || o === "malam" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            return l < 11 ? "pagi" : l < 15 ? "siang" : l < 19 ? "sore" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Besok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kemarin pukul] LT", lastWeek: "dddd [lalu pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lalu", s: "beberapa detik", ss: "%d detik", m: "semenit", mm: "%d menit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 7213: function(L, h, b) {
        (function(A) {
          function l(u) {
            return u % 100 == 11 || u % 10 != 1;
          }
          function o(u, g, m, S) {
            var e = u + " ";
            switch (m) {
              case "s":
                return g || S ? "nokkrar sekúndur" : "nokkrum sekúndum";
              case "ss":
                return l(u) ? e + (g || S ? "sekúndur" : "sekúndum") : e + "sekúnda";
              case "m":
                return g ? "mínúta" : "mínútu";
              case "mm":
                return l(u) ? e + (g || S ? "mínútur" : "mínútum") : g ? e + "mínúta" : e + "mínútu";
              case "hh":
                return l(u) ? e + (g || S ? "klukkustundir" : "klukkustundum") : e + "klukkustund";
              case "d":
                return g ? "dagur" : S ? "dag" : "degi";
              case "dd":
                return l(u) ? g ? e + "dagar" : e + (S ? "daga" : "dögum") : g ? e + "dagur" : e + (S ? "dag" : "degi");
              case "M":
                return g ? "mánuður" : S ? "mánuð" : "mánuði";
              case "MM":
                return l(u) ? g ? e + "mánuðir" : e + (S ? "mánuði" : "mánuðum") : g ? e + "mánuður" : e + (S ? "mánuð" : "mánuði");
              case "y":
                return g || S ? "ár" : "ári";
              case "yy":
                return l(u) ? e + (g || S ? "ár" : "árum") : e + (g || S ? "ár" : "ári");
            }
          }
          A.defineLocale("is", { months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"), monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"), weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"), weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"), weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd, D. MMMM YYYY [kl.] H:mm" }, calendar: { sameDay: "[í dag kl.] LT", nextDay: "[á morgun kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[í gær kl.] LT", lastWeek: "[síðasta] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "eftir %s", past: "fyrir %s síðan", s: o, ss: o, m: o, mm: o, h: "klukkustund", hh: o, d: o, dd: o, M: o, MM: o, y: o, yy: o }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4354: function(L, h, b) {
        (function(A) {
          A.defineLocale("it-ch", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Oggi alle] LT", nextDay: "[Domani alle] LT", nextWeek: "dddd [alle] LT", lastDay: "[Ieri alle] LT", lastWeek: function() {
            return this.day() === 0 ? "[la scorsa] dddd [alle] LT" : "[lo scorso] dddd [alle] LT";
          }, sameElse: "L" }, relativeTime: { future: function(l) {
            return (/^[0-9].+$/.test(l) ? "tra" : "in") + " " + l;
          }, past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8: function(L, h, b) {
        (function(A) {
          A.defineLocale("it", { months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"), monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"), weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"), weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"), weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: function() {
            return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, nextDay: function() {
            return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, nextWeek: function() {
            return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, lastDay: function() {
            return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, lastWeek: function() {
            return this.day() === 0 ? "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT" : "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }, sameElse: "L" }, relativeTime: { future: "tra %s", past: "%s fa", s: "alcuni secondi", ss: "%d secondi", m: "un minuto", mm: "%d minuti", h: "un'ora", hh: "%d ore", d: "un giorno", dd: "%d giorni", w: "una settimana", ww: "%d settimane", M: "un mese", MM: "%d mesi", y: "un anno", yy: "%d anni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6076: function(L, h, b) {
        (function(A) {
          A.defineLocale("ja", { eras: [{ since: "2019-05-01", offset: 1, name: "令和", narrow: "㋿", abbr: "R" }, { since: "1989-01-08", until: "2019-04-30", offset: 1, name: "平成", narrow: "㍻", abbr: "H" }, { since: "1926-12-25", until: "1989-01-07", offset: 1, name: "昭和", narrow: "㍼", abbr: "S" }, { since: "1912-07-30", until: "1926-12-24", offset: 1, name: "大正", narrow: "㍽", abbr: "T" }, { since: "1873-01-01", until: "1912-07-29", offset: 6, name: "明治", narrow: "㍾", abbr: "M" }, { since: "0001-01-01", until: "1873-12-31", offset: 1, name: "西暦", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "紀元前", narrow: "BC", abbr: "BC" }], eraYearOrdinalRegex: /(元|\d+)年/, eraYearOrdinalParse: function(l, o) {
            return o[1] === "元" ? 1 : parseInt(o[1] || l, 10);
          }, months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"), weekdaysShort: "日_月_火_水_木_金_土".split("_"), weekdaysMin: "日_月_火_水_木_金_土".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日 dddd HH:mm", l: "YYYY/MM/DD", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日(ddd) HH:mm" }, meridiemParse: /午前|午後/i, isPM: function(l) {
            return l === "午後";
          }, meridiem: function(l, o, u) {
            return l < 12 ? "午前" : "午後";
          }, calendar: { sameDay: "[今日] LT", nextDay: "[明日] LT", nextWeek: function(l) {
            return l.week() !== this.week() ? "[来週]dddd LT" : "dddd LT";
          }, lastDay: "[昨日] LT", lastWeek: function(l) {
            return this.week() !== l.week() ? "[先週]dddd LT" : "dddd LT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}日/, ordinal: function(l, o) {
            switch (o) {
              case "y":
                return l === 1 ? "元年" : l + "年";
              case "d":
              case "D":
              case "DDD":
                return l + "日";
              default:
                return l;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "数秒", ss: "%d秒", m: "1分", mm: "%d分", h: "1時間", hh: "%d時間", d: "1日", dd: "%d日", M: "1ヶ月", MM: "%dヶ月", y: "1年", yy: "%d年" } });
        })(b(7840));
      }, 7289: function(L, h, b) {
        (function(A) {
          A.defineLocale("jv", { months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"), monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"), weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"), weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"), weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /enjing|siyang|sonten|ndalu/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "enjing" ? l : o === "siyang" ? l >= 11 ? l : l + 12 : o === "sonten" || o === "ndalu" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            return l < 11 ? "enjing" : l < 15 ? "siyang" : l < 19 ? "sonten" : "ndalu";
          }, calendar: { sameDay: "[Dinten puniko pukul] LT", nextDay: "[Mbenjang pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kala wingi pukul] LT", lastWeek: "dddd [kepengker pukul] LT", sameElse: "L" }, relativeTime: { future: "wonten ing %s", past: "%s ingkang kepengker", s: "sawetawis detik", ss: "%d detik", m: "setunggal menit", mm: "%d menit", h: "setunggal jam", hh: "%d jam", d: "sedinten", dd: "%d dinten", M: "sewulan", MM: "%d wulan", y: "setaun", yy: "%d taun" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 6149: function(L, h, b) {
        (function(A) {
          A.defineLocale("ka", { months: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"), monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"), weekdays: { standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"), format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"), isFormat: /(წინა|შემდეგ)/ }, weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"), weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[დღეს] LT[-ზე]", nextDay: "[ხვალ] LT[-ზე]", lastDay: "[გუშინ] LT[-ზე]", nextWeek: "[შემდეგ] dddd LT[-ზე]", lastWeek: "[წინა] dddd LT-ზე", sameElse: "L" }, relativeTime: { future: function(l) {
            return l.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, function(o, u, g) {
              return g === "ი" ? u + "ში" : u + g + "ში";
            });
          }, past: function(l) {
            return /(წამი|წუთი|საათი|დღე|თვე)/.test(l) ? l.replace(/(ი|ე)$/, "ის წინ") : /წელი/.test(l) ? l.replace(/წელი$/, "წლის წინ") : l;
          }, s: "რამდენიმე წამი", ss: "%d წამი", m: "წუთი", mm: "%d წუთი", h: "საათი", hh: "%d საათი", d: "დღე", dd: "%d დღე", M: "თვე", MM: "%d თვე", y: "წელი", yy: "%d წელი" }, dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/, ordinal: function(l) {
            return l === 0 ? l : l === 1 ? l + "-ლი" : l < 20 || l <= 100 && l % 20 == 0 || l % 100 == 0 ? "მე-" + l : l + "-ე";
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 2075: function(L, h, b) {
        (function(A) {
          var l = { 0: "-ші", 1: "-ші", 2: "-ші", 3: "-ші", 4: "-ші", 5: "-ші", 6: "-шы", 7: "-ші", 8: "-ші", 9: "-шы", 10: "-шы", 20: "-шы", 30: "-шы", 40: "-шы", 50: "-ші", 60: "-шы", 70: "-ші", 80: "-ші", 90: "-шы", 100: "-ші" };
          A.defineLocale("kk", { months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"), monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"), weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"), weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"), weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгін сағат] LT", nextDay: "[Ертең сағат] LT", nextWeek: "dddd [сағат] LT", lastDay: "[Кеше сағат] LT", lastWeek: "[Өткен аптаның] dddd [сағат] LT", sameElse: "L" }, relativeTime: { future: "%s ішінде", past: "%s бұрын", s: "бірнеше секунд", ss: "%d секунд", m: "бір минут", mm: "%d минут", h: "бір сағат", hh: "%d сағат", d: "бір күн", dd: "%d күн", M: "бір ай", MM: "%d ай", y: "бір жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/, ordinal: function(o) {
            return o + (l[o] || l[o % 10] || l[o >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 4001: function(L, h, b) {
        (function(A) {
          var l = { 1: "១", 2: "២", 3: "៣", 4: "៤", 5: "៥", 6: "៦", 7: "៧", 8: "៨", 9: "៩", 0: "០" }, o = { "១": "1", "២": "2", "៣": "3", "៤": "4", "៥": "5", "៦": "6", "៧": "7", "៨": "8", "៩": "9", "០": "0" };
          A.defineLocale("km", { months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"), weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"), weekdaysShort: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"), weekdaysMin: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /ព្រឹក|ល្ងាច/, isPM: function(u) {
            return u === "ល្ងាច";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "ព្រឹក" : "ល្ងាច";
          }, calendar: { sameDay: "[ថ្ងៃនេះ ម៉ោង] LT", nextDay: "[ស្អែក ម៉ោង] LT", nextWeek: "dddd [ម៉ោង] LT", lastDay: "[ម្សិលមិញ ម៉ោង] LT", lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT", sameElse: "L" }, relativeTime: { future: "%sទៀត", past: "%sមុន", s: "ប៉ុន្មានវិនាទី", ss: "%d វិនាទី", m: "មួយនាទី", mm: "%d នាទី", h: "មួយម៉ោង", hh: "%d ម៉ោង", d: "មួយថ្ងៃ", dd: "%d ថ្ងៃ", M: "មួយខែ", MM: "%d ខែ", y: "មួយឆ្នាំ", yy: "%d ឆ្នាំ" }, dayOfMonthOrdinalParse: /ទី\d{1,2}/, ordinal: "ទី%d", preparse: function(u) {
            return u.replace(/[១២៣៤៥៦៧៨៩០]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4360: function(L, h, b) {
        (function(A) {
          var l = { 1: "೧", 2: "೨", 3: "೩", 4: "೪", 5: "೫", 6: "೬", 7: "೭", 8: "೮", 9: "೯", 0: "೦" }, o = { "೧": "1", "೨": "2", "೩": "3", "೪": "4", "೫": "5", "೬": "6", "೭": "7", "೮": "8", "೯": "9", "೦": "0" };
          A.defineLocale("kn", { months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"), monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ".split("_"), monthsParseExact: !0, weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"), weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"), weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[ಇಂದು] LT", nextDay: "[ನಾಳೆ] LT", nextWeek: "dddd, LT", lastDay: "[ನಿನ್ನೆ] LT", lastWeek: "[ಕೊನೆಯ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ನಂತರ", past: "%s ಹಿಂದೆ", s: "ಕೆಲವು ಕ್ಷಣಗಳು", ss: "%d ಸೆಕೆಂಡುಗಳು", m: "ಒಂದು ನಿಮಿಷ", mm: "%d ನಿಮಿಷ", h: "ಒಂದು ಗಂಟೆ", hh: "%d ಗಂಟೆ", d: "ಒಂದು ದಿನ", dd: "%d ದಿನ", M: "ಒಂದು ತಿಂಗಳು", MM: "%d ತಿಂಗಳು", y: "ಒಂದು ವರ್ಷ", yy: "%d ವರ್ಷ" }, preparse: function(u) {
            return u.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "ರಾತ್ರಿ" ? u < 4 ? u : u + 12 : g === "ಬೆಳಿಗ್ಗೆ" ? u : g === "ಮಧ್ಯಾಹ್ನ" ? u >= 10 ? u : u + 12 : g === "ಸಂಜೆ" ? u + 12 : void 0;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "ರಾತ್ರಿ" : u < 10 ? "ಬೆಳಿಗ್ಗೆ" : u < 17 ? "ಮಧ್ಯಾಹ್ನ" : u < 20 ? "ಸಂಜೆ" : "ರಾತ್ರಿ";
          }, dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/, ordinal: function(u) {
            return u + "ನೇ";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 5071: function(L, h, b) {
        (function(A) {
          A.defineLocale("ko", { months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"), weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"), weekdaysShort: "일_월_화_수_목_금_토".split("_"), weekdaysMin: "일_월_화_수_목_금_토".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "YYYY.MM.DD.", LL: "YYYY년 MMMM D일", LLL: "YYYY년 MMMM D일 A h:mm", LLLL: "YYYY년 MMMM D일 dddd A h:mm", l: "YYYY.MM.DD.", ll: "YYYY년 MMMM D일", lll: "YYYY년 MMMM D일 A h:mm", llll: "YYYY년 MMMM D일 dddd A h:mm" }, calendar: { sameDay: "오늘 LT", nextDay: "내일 LT", nextWeek: "dddd LT", lastDay: "어제 LT", lastWeek: "지난주 dddd LT", sameElse: "L" }, relativeTime: { future: "%s 후", past: "%s 전", s: "몇 초", ss: "%d초", m: "1분", mm: "%d분", h: "한 시간", hh: "%d시간", d: "하루", dd: "%d일", M: "한 달", MM: "%d달", y: "일 년", yy: "%d년" }, dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "일";
              case "M":
                return l + "월";
              case "w":
              case "W":
                return l + "주";
              default:
                return l;
            }
          }, meridiemParse: /오전|오후/, isPM: function(l) {
            return l === "오후";
          }, meridiem: function(l, o, u) {
            return l < 12 ? "오전" : "오후";
          } });
        })(b(7840));
      }, 6882: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { s: ["çend sanîye", "çend sanîyeyan"], ss: [o + " sanîye", o + " sanîyeyan"], m: ["deqîqeyek", "deqîqeyekê"], mm: [o + " deqîqe", o + " deqîqeyan"], h: ["saetek", "saetekê"], hh: [o + " saet", o + " saetan"], d: ["rojek", "rojekê"], dd: [o + " roj", o + " rojan"], w: ["hefteyek", "hefteyekê"], ww: [o + " hefte", o + " hefteyan"], M: ["mehek", "mehekê"], MM: [o + " meh", o + " mehan"], y: ["salek", "salekê"], yy: [o + " sal", o + " salan"] };
            return u ? S[g][0] : S[g][1];
          }
          A.defineLocale("ku-kmr", { months: "Rêbendan_Sibat_Adar_Nîsan_Gulan_Hezîran_Tîrmeh_Tebax_Îlon_Cotmeh_Mijdar_Berfanbar".split("_"), monthsShort: "Rêb_Sib_Ada_Nîs_Gul_Hez_Tîr_Teb_Îlo_Cot_Mij_Ber".split("_"), monthsParseExact: !0, weekdays: "Yekşem_Duşem_Sêşem_Çarşem_Pêncşem_În_Şemî".split("_"), weekdaysShort: "Yek_Du_Sê_Çar_Pên_În_Şem".split("_"), weekdaysMin: "Ye_Du_Sê_Ça_Pê_În_Şe".split("_"), meridiem: function(o, u, g) {
            return o < 12 ? g ? "bn" : "BN" : g ? "pn" : "PN";
          }, meridiemParse: /bn|BN|pn|PN/, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "Do MMMM[a] YYYY[an]", LLL: "Do MMMM[a] YYYY[an] HH:mm", LLLL: "dddd, Do MMMM[a] YYYY[an] HH:mm", ll: "Do MMM[.] YYYY[an]", lll: "Do MMM[.] YYYY[an] HH:mm", llll: "ddd[.], Do MMM[.] YYYY[an] HH:mm" }, calendar: { sameDay: "[Îro di saet] LT [de]", nextDay: "[Sibê di saet] LT [de]", nextWeek: "dddd [di saet] LT [de]", lastDay: "[Duh di saet] LT [de]", lastWeek: "dddd[a borî di saet] LT [de]", sameElse: "L" }, relativeTime: { future: "di %s de", past: "berî %s", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, w: l, ww: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}(?:yê|ê|\.)/, ordinal: function(o, u) {
            var g = u.toLowerCase();
            return g.includes("w") || g.includes("m") ? o + "." : o + function(m) {
              var S = (m = "" + m).substring(m.length - 1), e = m.length > 1 ? m.substring(m.length - 2) : "";
              return e == 12 || e == 13 || S != "2" && S != "3" && e != "50" && S != "70" && S != "80" ? "ê" : "yê";
            }(o);
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1209: function(L, h, b) {
        (function(A) {
          var l = { 1: "١", 2: "٢", 3: "٣", 4: "٤", 5: "٥", 6: "٦", 7: "٧", 8: "٨", 9: "٩", 0: "٠" }, o = { "١": "1", "٢": "2", "٣": "3", "٤": "4", "٥": "5", "٦": "6", "٧": "7", "٨": "8", "٩": "9", "٠": "0" }, u = ["کانونی دووەم", "شوبات", "ئازار", "نیسان", "ئایار", "حوزەیران", "تەمموز", "ئاب", "ئەیلوول", "تشرینی یەكەم", "تشرینی دووەم", "كانونی یەکەم"];
          A.defineLocale("ku", { months: u, monthsShort: u, weekdays: "یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌".split("_"), weekdaysShort: "یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌".split("_"), weekdaysMin: "ی_د_س_چ_پ_ه_ش".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, meridiemParse: /ئێواره‌|به‌یانی/, isPM: function(g) {
            return /ئێواره‌/.test(g);
          }, meridiem: function(g, m, S) {
            return g < 12 ? "به‌یانی" : "ئێواره‌";
          }, calendar: { sameDay: "[ئه‌مرۆ كاتژمێر] LT", nextDay: "[به‌یانی كاتژمێر] LT", nextWeek: "dddd [كاتژمێر] LT", lastDay: "[دوێنێ كاتژمێر] LT", lastWeek: "dddd [كاتژمێر] LT", sameElse: "L" }, relativeTime: { future: "له‌ %s", past: "%s", s: "چه‌ند چركه‌یه‌ك", ss: "چركه‌ %d", m: "یه‌ك خوله‌ك", mm: "%d خوله‌ك", h: "یه‌ك كاتژمێر", hh: "%d كاتژمێر", d: "یه‌ك ڕۆژ", dd: "%d ڕۆژ", M: "یه‌ك مانگ", MM: "%d مانگ", y: "یه‌ك ساڵ", yy: "%d ساڵ" }, preparse: function(g) {
            return g.replace(/[١٢٣٤٥٦٧٨٩٠]/g, function(m) {
              return o[m];
            }).replace(/،/g, ",");
          }, postformat: function(g) {
            return g.replace(/\d/g, function(m) {
              return l[m];
            }).replace(/,/g, "،");
          }, week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 4125: function(L, h, b) {
        (function(A) {
          var l = { 0: "-чү", 1: "-чи", 2: "-чи", 3: "-чү", 4: "-чү", 5: "-чи", 6: "-чы", 7: "-чи", 8: "-чи", 9: "-чу", 10: "-чу", 20: "-чы", 30: "-чу", 40: "-чы", 50: "-чү", 60: "-чы", 70: "-чи", 80: "-чи", 90: "-чу", 100: "-чү" };
          A.defineLocale("ky", { months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"), monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"), weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"), weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"), weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Бүгүн саат] LT", nextDay: "[Эртең саат] LT", nextWeek: "dddd [саат] LT", lastDay: "[Кечээ саат] LT", lastWeek: "[Өткөн аптанын] dddd [күнү] [саат] LT", sameElse: "L" }, relativeTime: { future: "%s ичинде", past: "%s мурун", s: "бирнече секунд", ss: "%d секунд", m: "бир мүнөт", mm: "%d мүнөт", h: "бир саат", hh: "%d саат", d: "бир күн", dd: "%d күн", M: "бир ай", MM: "%d ай", y: "бир жыл", yy: "%d жыл" }, dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/, ordinal: function(o) {
            return o + (l[o] || l[o % 10] || l[o >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 8531: function(L, h, b) {
        (function(A) {
          function l(u, g, m, S) {
            var e = { m: ["eng Minutt", "enger Minutt"], h: ["eng Stonn", "enger Stonn"], d: ["een Dag", "engem Dag"], M: ["ee Mount", "engem Mount"], y: ["ee Joer", "engem Joer"] };
            return g ? e[m][0] : e[m][1];
          }
          function o(u) {
            if (u = parseInt(u, 10), isNaN(u)) return !1;
            if (u < 0) return !0;
            if (u < 10) return 4 <= u && u <= 7;
            if (u < 100) {
              var g = u % 10;
              return o(g === 0 ? u / 10 : g);
            }
            if (u < 1e4) {
              for (; u >= 10; ) u /= 10;
              return o(u);
            }
            return o(u /= 1e3);
          }
          A.defineLocale("lb", { months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"), monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"), monthsParseExact: !0, weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"), weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"), weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm [Auer]", LTS: "H:mm:ss [Auer]", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm [Auer]", LLLL: "dddd, D. MMMM YYYY H:mm [Auer]" }, calendar: { sameDay: "[Haut um] LT", sameElse: "L", nextDay: "[Muer um] LT", nextWeek: "dddd [um] LT", lastDay: "[Gëschter um] LT", lastWeek: function() {
            switch (this.day()) {
              case 2:
              case 4:
                return "[Leschten] dddd [um] LT";
              default:
                return "[Leschte] dddd [um] LT";
            }
          } }, relativeTime: { future: function(u) {
            return o(u.substr(0, u.indexOf(" "))) ? "a " + u : "an " + u;
          }, past: function(u) {
            return o(u.substr(0, u.indexOf(" "))) ? "viru " + u : "virun " + u;
          }, s: "e puer Sekonnen", ss: "%d Sekonnen", m: l, mm: "%d Minutten", h: l, hh: "%d Stonnen", d: l, dd: "%d Deeg", M: l, MM: "%d Méint", y: l, yy: "%d Joer" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5784: function(L, h, b) {
        (function(A) {
          A.defineLocale("lo", { months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"), weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"), weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "ວັນdddd D MMMM YYYY HH:mm" }, meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/, isPM: function(l) {
            return l === "ຕອນແລງ";
          }, meridiem: function(l, o, u) {
            return l < 12 ? "ຕອນເຊົ້າ" : "ຕອນແລງ";
          }, calendar: { sameDay: "[ມື້ນີ້ເວລາ] LT", nextDay: "[ມື້ອື່ນເວລາ] LT", nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT", lastDay: "[ມື້ວານນີ້ເວລາ] LT", lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT", sameElse: "L" }, relativeTime: { future: "ອີກ %s", past: "%sຜ່ານມາ", s: "ບໍ່ເທົ່າໃດວິນາທີ", ss: "%d ວິນາທີ", m: "1 ນາທີ", mm: "%d ນາທີ", h: "1 ຊົ່ວໂມງ", hh: "%d ຊົ່ວໂມງ", d: "1 ມື້", dd: "%d ມື້", M: "1 ເດືອນ", MM: "%d ເດືອນ", y: "1 ປີ", yy: "%d ປີ" }, dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/, ordinal: function(l) {
            return "ທີ່" + l;
          } });
        })(b(7840));
      }, 4985: function(L, h, b) {
        (function(A) {
          var l = { ss: "sekundė_sekundžių_sekundes", m: "minutė_minutės_minutę", mm: "minutės_minučių_minutes", h: "valanda_valandos_valandą", hh: "valandos_valandų_valandas", d: "diena_dienos_dieną", dd: "dienos_dienų_dienas", M: "mėnuo_mėnesio_mėnesį", MM: "mėnesiai_mėnesių_mėnesius", y: "metai_metų_metus", yy: "metai_metų_metus" };
          function o(S, e, n, d) {
            return e ? g(n)[0] : d ? g(n)[1] : g(n)[2];
          }
          function u(S) {
            return S % 10 == 0 || S > 10 && S < 20;
          }
          function g(S) {
            return l[S].split("_");
          }
          function m(S, e, n, d) {
            var _ = S + " ";
            return S === 1 ? _ + o(0, e, n[0], d) : e ? _ + (u(S) ? g(n)[1] : g(n)[0]) : d ? _ + g(n)[1] : _ + (u(S) ? g(n)[1] : g(n)[2]);
          }
          A.defineLocale("lt", { months: { format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"), standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"), isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/ }, monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"), weekdays: { format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"), standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"), isFormat: /dddd HH:mm/ }, weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"), weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY [m.] MMMM D [d.]", LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]", LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]", l: "YYYY-MM-DD", ll: "YYYY [m.] MMMM D [d.]", lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]", llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]" }, calendar: { sameDay: "[Šiandien] LT", nextDay: "[Rytoj] LT", nextWeek: "dddd LT", lastDay: "[Vakar] LT", lastWeek: "[Praėjusį] dddd LT", sameElse: "L" }, relativeTime: { future: "po %s", past: "prieš %s", s: function(S, e, n, d) {
            return e ? "kelios sekundės" : d ? "kelių sekundžių" : "kelias sekundes";
          }, ss: m, m: o, mm: m, h: o, hh: m, d: o, dd: m, M: o, MM: m, y: o, yy: m }, dayOfMonthOrdinalParse: /\d{1,2}-oji/, ordinal: function(S) {
            return S + "-oji";
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 1991: function(L, h, b) {
        (function(A) {
          var l = { ss: "sekundes_sekundēm_sekunde_sekundes".split("_"), m: "minūtes_minūtēm_minūte_minūtes".split("_"), mm: "minūtes_minūtēm_minūte_minūtes".split("_"), h: "stundas_stundām_stunda_stundas".split("_"), hh: "stundas_stundām_stunda_stundas".split("_"), d: "dienas_dienām_diena_dienas".split("_"), dd: "dienas_dienām_diena_dienas".split("_"), M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"), y: "gada_gadiem_gads_gadi".split("_"), yy: "gada_gadiem_gads_gadi".split("_") };
          function o(m, S, e) {
            return e ? S % 10 == 1 && S % 100 != 11 ? m[2] : m[3] : S % 10 == 1 && S % 100 != 11 ? m[0] : m[1];
          }
          function u(m, S, e) {
            return m + " " + o(l[e], m, S);
          }
          function g(m, S, e) {
            return o(l[e], m, S);
          }
          A.defineLocale("lv", { months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"), monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"), weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"), weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY.", LL: "YYYY. [gada] D. MMMM", LLL: "YYYY. [gada] D. MMMM, HH:mm", LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm" }, calendar: { sameDay: "[Šodien pulksten] LT", nextDay: "[Rīt pulksten] LT", nextWeek: "dddd [pulksten] LT", lastDay: "[Vakar pulksten] LT", lastWeek: "[Pagājušā] dddd [pulksten] LT", sameElse: "L" }, relativeTime: { future: "pēc %s", past: "pirms %s", s: function(m, S) {
            return S ? "dažas sekundes" : "dažām sekundēm";
          }, ss: u, m: g, mm: u, h: g, hh: u, d: g, dd: u, M: g, MM: u, y: g, yy: u }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 3507: function(L, h, b) {
        (function(A) {
          var l = { words: { ss: ["sekund", "sekunda", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], dd: ["dan", "dana", "dana"], MM: ["mjesec", "mjeseca", "mjeseci"], yy: ["godina", "godine", "godina"] }, correctGrammaticalCase: function(o, u) {
            return o === 1 ? u[0] : o >= 2 && o <= 4 ? u[1] : u[2];
          }, translate: function(o, u, g) {
            var m = l.words[g];
            return g.length === 1 ? u ? m[0] : m[1] : o + " " + l.correctGrammaticalCase(o, m);
          } };
          A.defineLocale("me", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sjutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedjelju] [u] LT";
              case 3:
                return "[u] [srijedu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juče u] LT", lastWeek: function() {
            return ["[prošle] [nedjelje] [u] LT", "[prošlog] [ponedjeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srijede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "prije %s", s: "nekoliko sekundi", ss: l.translate, m: l.translate, mm: l.translate, h: l.translate, hh: l.translate, d: "dan", dd: l.translate, M: "mjesec", MM: l.translate, y: "godinu", yy: l.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 6959: function(L, h, b) {
        (function(A) {
          A.defineLocale("mi", { months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"), monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"), monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i, monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i, weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"), weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [i] HH:mm", LLLL: "dddd, D MMMM YYYY [i] HH:mm" }, calendar: { sameDay: "[i teie mahana, i] LT", nextDay: "[apopo i] LT", nextWeek: "dddd [i] LT", lastDay: "[inanahi i] LT", lastWeek: "dddd [whakamutunga i] LT", sameElse: "L" }, relativeTime: { future: "i roto i %s", past: "%s i mua", s: "te hēkona ruarua", ss: "%d hēkona", m: "he meneti", mm: "%d meneti", h: "te haora", hh: "%d haora", d: "he ra", dd: "%d ra", M: "he marama", MM: "%d marama", y: "he tau", yy: "%d tau" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 7441: function(L, h, b) {
        (function(A) {
          A.defineLocale("mk", { months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"), monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"), weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"), weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"), weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[Денес во] LT", nextDay: "[Утре во] LT", nextWeek: "[Во] dddd [во] LT", lastDay: "[Вчера во] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 6:
                return "[Изминатата] dddd [во] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[Изминатиот] dddd [во] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "пред %s", s: "неколку секунди", ss: "%d секунди", m: "една минута", mm: "%d минути", h: "еден час", hh: "%d часа", d: "еден ден", dd: "%d дена", M: "еден месец", MM: "%d месеци", y: "една година", yy: "%d години" }, dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/, ordinal: function(l) {
            var o = l % 10, u = l % 100;
            return l === 0 ? l + "-ев" : u === 0 ? l + "-ен" : u > 10 && u < 20 ? l + "-ти" : o === 1 ? l + "-ви" : o === 2 ? l + "-ри" : o === 7 || o === 8 ? l + "-ми" : l + "-ти";
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 9844: function(L, h, b) {
        (function(A) {
          A.defineLocale("ml", { months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"), monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"), monthsParseExact: !0, weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"), weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"), weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"), longDateFormat: { LT: "A h:mm -നു", LTS: "A h:mm:ss -നു", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm -നു", LLLL: "dddd, D MMMM YYYY, A h:mm -നു" }, calendar: { sameDay: "[ഇന്ന്] LT", nextDay: "[നാളെ] LT", nextWeek: "dddd, LT", lastDay: "[ഇന്നലെ] LT", lastWeek: "[കഴിഞ്ഞ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s കഴിഞ്ഞ്", past: "%s മുൻപ്", s: "അൽപ നിമിഷങ്ങൾ", ss: "%d സെക്കൻഡ്", m: "ഒരു മിനിറ്റ്", mm: "%d മിനിറ്റ്", h: "ഒരു മണിക്കൂർ", hh: "%d മണിക്കൂർ", d: "ഒരു ദിവസം", dd: "%d ദിവസം", M: "ഒരു മാസം", MM: "%d മാസം", y: "ഒരു വർഷം", yy: "%d വർഷം" }, meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "രാത്രി" && l >= 4 || o === "ഉച്ച കഴിഞ്ഞ്" || o === "വൈകുന്നേരം" ? l + 12 : l;
          }, meridiem: function(l, o, u) {
            return l < 4 ? "രാത്രി" : l < 12 ? "രാവിലെ" : l < 17 ? "ഉച്ച കഴിഞ്ഞ്" : l < 20 ? "വൈകുന്നേരം" : "രാത്രി";
          } });
        })(b(7840));
      }, 4302: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            switch (g) {
              case "s":
                return u ? "хэдхэн секунд" : "хэдхэн секундын";
              case "ss":
                return o + (u ? " секунд" : " секундын");
              case "m":
              case "mm":
                return o + (u ? " минут" : " минутын");
              case "h":
              case "hh":
                return o + (u ? " цаг" : " цагийн");
              case "d":
              case "dd":
                return o + (u ? " өдөр" : " өдрийн");
              case "M":
              case "MM":
                return o + (u ? " сар" : " сарын");
              case "y":
              case "yy":
                return o + (u ? " жил" : " жилийн");
              default:
                return o;
            }
          }
          A.defineLocale("mn", { months: "Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар".split("_"), monthsShort: "1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар".split("_"), monthsParseExact: !0, weekdays: "Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба".split("_"), weekdaysShort: "Ням_Дав_Мяг_Лха_Пүр_Баа_Бям".split("_"), weekdaysMin: "Ня_Да_Мя_Лх_Пү_Ба_Бя".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY оны MMMMын D", LLL: "YYYY оны MMMMын D HH:mm", LLLL: "dddd, YYYY оны MMMMын D HH:mm" }, meridiemParse: /ҮӨ|ҮХ/i, isPM: function(o) {
            return o === "ҮХ";
          }, meridiem: function(o, u, g) {
            return o < 12 ? "ҮӨ" : "ҮХ";
          }, calendar: { sameDay: "[Өнөөдөр] LT", nextDay: "[Маргааш] LT", nextWeek: "[Ирэх] dddd LT", lastDay: "[Өчигдөр] LT", lastWeek: "[Өнгөрсөн] dddd LT", sameElse: "L" }, relativeTime: { future: "%s дараа", past: "%s өмнө", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2} өдөр/, ordinal: function(o, u) {
            switch (u) {
              case "d":
              case "D":
              case "DDD":
                return o + " өдөр";
              default:
                return o;
            }
          } });
        })(b(7840));
      }, 1930: function(L, h, b) {
        (function(A) {
          var l = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, o = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
          function u(g, m, S, e) {
            var n = "";
            if (m) switch (S) {
              case "s":
                n = "काही सेकंद";
                break;
              case "ss":
                n = "%d सेकंद";
                break;
              case "m":
                n = "एक मिनिट";
                break;
              case "mm":
                n = "%d मिनिटे";
                break;
              case "h":
                n = "एक तास";
                break;
              case "hh":
                n = "%d तास";
                break;
              case "d":
                n = "एक दिवस";
                break;
              case "dd":
                n = "%d दिवस";
                break;
              case "M":
                n = "एक महिना";
                break;
              case "MM":
                n = "%d महिने";
                break;
              case "y":
                n = "एक वर्ष";
                break;
              case "yy":
                n = "%d वर्षे";
            }
            else switch (S) {
              case "s":
                n = "काही सेकंदां";
                break;
              case "ss":
                n = "%d सेकंदां";
                break;
              case "m":
                n = "एका मिनिटा";
                break;
              case "mm":
                n = "%d मिनिटां";
                break;
              case "h":
                n = "एका तासा";
                break;
              case "hh":
                n = "%d तासां";
                break;
              case "d":
                n = "एका दिवसा";
                break;
              case "dd":
                n = "%d दिवसां";
                break;
              case "M":
                n = "एका महिन्या";
                break;
              case "MM":
                n = "%d महिन्यां";
                break;
              case "y":
                n = "एका वर्षा";
                break;
              case "yy":
                n = "%d वर्षां";
            }
            return n.replace(/%d/i, g);
          }
          A.defineLocale("mr", { months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"), monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"), monthsParseExact: !0, weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"), weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"), weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"), longDateFormat: { LT: "A h:mm वाजता", LTS: "A h:mm:ss वाजता", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm वाजता", LLLL: "dddd, D MMMM YYYY, A h:mm वाजता" }, calendar: { sameDay: "[आज] LT", nextDay: "[उद्या] LT", nextWeek: "dddd, LT", lastDay: "[काल] LT", lastWeek: "[मागील] dddd, LT", sameElse: "L" }, relativeTime: { future: "%sमध्ये", past: "%sपूर्वी", s: u, ss: u, m: u, mm: u, h: u, hh: u, d: u, dd: u, M: u, MM: u, y: u, yy: u }, preparse: function(g) {
            return g.replace(/[१२३४५६७८९०]/g, function(m) {
              return o[m];
            });
          }, postformat: function(g) {
            return g.replace(/\d/g, function(m) {
              return l[m];
            });
          }, meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/, meridiemHour: function(g, m) {
            return g === 12 && (g = 0), m === "पहाटे" || m === "सकाळी" ? g : m === "दुपारी" || m === "सायंकाळी" || m === "रात्री" ? g >= 12 ? g : g + 12 : void 0;
          }, meridiem: function(g, m, S) {
            return g >= 0 && g < 6 ? "पहाटे" : g < 12 ? "सकाळी" : g < 17 ? "दुपारी" : g < 20 ? "सायंकाळी" : "रात्री";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 5748: function(L, h, b) {
        (function(A) {
          A.defineLocale("ms-my", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "pagi" ? l : o === "tengahari" ? l >= 11 ? l : l + 12 : o === "petang" || o === "malam" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            return l < 11 ? "pagi" : l < 15 ? "tengahari" : l < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 4457: function(L, h, b) {
        (function(A) {
          A.defineLocale("ms", { months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"), weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"), weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"), weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [pukul] HH.mm", LLLL: "dddd, D MMMM YYYY [pukul] HH.mm" }, meridiemParse: /pagi|tengahari|petang|malam/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "pagi" ? l : o === "tengahari" ? l >= 11 ? l : l + 12 : o === "petang" || o === "malam" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            return l < 11 ? "pagi" : l < 15 ? "tengahari" : l < 19 ? "petang" : "malam";
          }, calendar: { sameDay: "[Hari ini pukul] LT", nextDay: "[Esok pukul] LT", nextWeek: "dddd [pukul] LT", lastDay: "[Kelmarin pukul] LT", lastWeek: "dddd [lepas pukul] LT", sameElse: "L" }, relativeTime: { future: "dalam %s", past: "%s yang lepas", s: "beberapa saat", ss: "%d saat", m: "seminit", mm: "%d minit", h: "sejam", hh: "%d jam", d: "sehari", dd: "%d hari", M: "sebulan", MM: "%d bulan", y: "setahun", yy: "%d tahun" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 3980: function(L, h, b) {
        (function(A) {
          A.defineLocale("mt", { months: "Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru".split("_"), monthsShort: "Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ".split("_"), weekdays: "Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt".split("_"), weekdaysShort: "Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib".split("_"), weekdaysMin: "Ħa_Tn_Tl_Er_Ħa_Ġi_Si".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Illum fil-]LT", nextDay: "[Għada fil-]LT", nextWeek: "dddd [fil-]LT", lastDay: "[Il-bieraħ fil-]LT", lastWeek: "dddd [li għadda] [fil-]LT", sameElse: "L" }, relativeTime: { future: "f’ %s", past: "%s ilu", s: "ftit sekondi", ss: "%d sekondi", m: "minuta", mm: "%d minuti", h: "siegħa", hh: "%d siegħat", d: "ġurnata", dd: "%d ġranet", M: "xahar", MM: "%d xhur", y: "sena", yy: "%d sni" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2639: function(L, h, b) {
        (function(A) {
          var l = { 1: "၁", 2: "၂", 3: "၃", 4: "၄", 5: "၅", 6: "၆", 7: "၇", 8: "၈", 9: "၉", 0: "၀" }, o = { "၁": "1", "၂": "2", "၃": "3", "၄": "4", "၅": "5", "၆": "6", "၇": "7", "၈": "8", "၉": "9", "၀": "0" };
          A.defineLocale("my", { months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"), monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"), weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"), weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ယနေ.] LT [မှာ]", nextDay: "[မနက်ဖြန်] LT [မှာ]", nextWeek: "dddd LT [မှာ]", lastDay: "[မနေ.က] LT [မှာ]", lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]", sameElse: "L" }, relativeTime: { future: "လာမည့် %s မှာ", past: "လွန်ခဲ့သော %s က", s: "စက္ကန်.အနည်းငယ်", ss: "%d စက္ကန့်", m: "တစ်မိနစ်", mm: "%d မိနစ်", h: "တစ်နာရီ", hh: "%d နာရီ", d: "တစ်ရက်", dd: "%d ရက်", M: "တစ်လ", MM: "%d လ", y: "တစ်နှစ်", yy: "%d နှစ်" }, preparse: function(u) {
            return u.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5953: function(L, h, b) {
        (function(A) {
          A.defineLocale("nb", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: !0, weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"), weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"), weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] HH:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[i dag kl.] LT", nextDay: "[i morgen kl.] LT", nextWeek: "dddd [kl.] LT", lastDay: "[i går kl.] LT", lastWeek: "[forrige] dddd [kl.] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s siden", s: "noen sekunder", ss: "%d sekunder", m: "ett minutt", mm: "%d minutter", h: "én time", hh: "%d timer", d: "én dag", dd: "%d dager", w: "én uke", ww: "%d uker", M: "én måned", MM: "%d måneder", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5876: function(L, h, b) {
        (function(A) {
          var l = { 1: "१", 2: "२", 3: "३", 4: "४", 5: "५", 6: "६", 7: "७", 8: "८", 9: "९", 0: "०" }, o = { "१": "1", "२": "2", "३": "3", "४": "4", "५": "5", "६": "6", "७": "7", "८": "8", "९": "9", "०": "0" };
          A.defineLocale("ne", { months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"), monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"), monthsParseExact: !0, weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"), weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"), weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "Aको h:mm बजे", LTS: "Aको h:mm:ss बजे", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, Aको h:mm बजे", LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे" }, preparse: function(u) {
            return u.replace(/[१२३४५६७८९०]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /राति|बिहान|दिउँसो|साँझ/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "राति" ? u < 4 ? u : u + 12 : g === "बिहान" ? u : g === "दिउँसो" ? u >= 10 ? u : u + 12 : g === "साँझ" ? u + 12 : void 0;
          }, meridiem: function(u, g, m) {
            return u < 3 ? "राति" : u < 12 ? "बिहान" : u < 16 ? "दिउँसो" : u < 20 ? "साँझ" : "राति";
          }, calendar: { sameDay: "[आज] LT", nextDay: "[भोलि] LT", nextWeek: "[आउँदो] dddd[,] LT", lastDay: "[हिजो] LT", lastWeek: "[गएको] dddd[,] LT", sameElse: "L" }, relativeTime: { future: "%sमा", past: "%s अगाडि", s: "केही क्षण", ss: "%d सेकेण्ड", m: "एक मिनेट", mm: "%d मिनेट", h: "एक घण्टा", hh: "%d घण्टा", d: "एक दिन", dd: "%d दिन", M: "एक महिना", MM: "%d महिना", y: "एक बर्ष", yy: "%d बर्ष" }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 493: function(L, h, b) {
        (function(A) {
          var l = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), o = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), u = [/^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], g = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          A.defineLocale("nl-be", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(m) {
            return m + (m === 1 || m === 8 || m >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 7475: function(L, h, b) {
        (function(A) {
          var l = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), o = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), u = [/^jan/i, /^feb/i, /^(maart|mrt\.?)$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i], g = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
          A.defineLocale("nl", { months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"), monthsShort: function(m, S) {
            return m ? /-MMM-/.test(S) ? o[m.month()] : l[m.month()] : l;
          }, monthsRegex: g, monthsShortRegex: g, monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i, monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i, monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"), weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"), weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD-MM-YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[vandaag om] LT", nextDay: "[morgen om] LT", nextWeek: "dddd [om] LT", lastDay: "[gisteren om] LT", lastWeek: "[afgelopen] dddd [om] LT", sameElse: "L" }, relativeTime: { future: "over %s", past: "%s geleden", s: "een paar seconden", ss: "%d seconden", m: "één minuut", mm: "%d minuten", h: "één uur", hh: "%d uur", d: "één dag", dd: "%d dagen", w: "één week", ww: "%d weken", M: "één maand", MM: "%d maanden", y: "één jaar", yy: "%d jaar" }, dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/, ordinal: function(m) {
            return m + (m === 1 || m === 8 || m >= 20 ? "ste" : "de");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 9221: function(L, h, b) {
        (function(A) {
          A.defineLocale("nn", { months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"), monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"), monthsParseExact: !0, weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"), weekdaysShort: "su._må._ty._on._to._fr._lau.".split("_"), weekdaysMin: "su_må_ty_on_to_fr_la".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY [kl.] H:mm", LLLL: "dddd D. MMMM YYYY [kl.] HH:mm" }, calendar: { sameDay: "[I dag klokka] LT", nextDay: "[I morgon klokka] LT", nextWeek: "dddd [klokka] LT", lastDay: "[I går klokka] LT", lastWeek: "[Føregåande] dddd [klokka] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "%s sidan", s: "nokre sekund", ss: "%d sekund", m: "eit minutt", mm: "%d minutt", h: "ein time", hh: "%d timar", d: "ein dag", dd: "%d dagar", w: "ei veke", ww: "%d veker", M: "ein månad", MM: "%d månader", y: "eit år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6261: function(L, h, b) {
        (function(A) {
          A.defineLocale("oc-lnc", { months: { standalone: "genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre".split("_"), format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split("_"), isFormat: /D[oD]?(\s)+MMMM/ }, monthsShort: "gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte".split("_"), weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"), weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [de] YYYY", ll: "D MMM YYYY", LLL: "D MMMM [de] YYYY [a] H:mm", lll: "D MMM YYYY, H:mm", LLLL: "dddd D MMMM [de] YYYY [a] H:mm", llll: "ddd D MMM YYYY, H:mm" }, calendar: { sameDay: "[uèi a] LT", nextDay: "[deman a] LT", nextWeek: "dddd [a] LT", lastDay: "[ièr a] LT", lastWeek: "dddd [passat a] LT", sameElse: "L" }, relativeTime: { future: "d'aquí %s", past: "fa %s", s: "unas segondas", ss: "%d segondas", m: "una minuta", mm: "%d minutas", h: "una ora", hh: "%d oras", d: "un jorn", dd: "%d jorns", M: "un mes", MM: "%d meses", y: "un an", yy: "%d ans" }, dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/, ordinal: function(l, o) {
            var u = l === 1 ? "r" : l === 2 ? "n" : l === 3 ? "r" : l === 4 ? "t" : "è";
            return o !== "w" && o !== "W" || (u = "a"), l + u;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4288: function(L, h, b) {
        (function(A) {
          var l = { 1: "੧", 2: "੨", 3: "੩", 4: "੪", 5: "੫", 6: "੬", 7: "੭", 8: "੮", 9: "੯", 0: "੦" }, o = { "੧": "1", "੨": "2", "੩": "3", "੪": "4", "੫": "5", "੬": "6", "੭": "7", "੮": "8", "੯": "9", "੦": "0" };
          A.defineLocale("pa-in", { months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"), weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"), weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"), longDateFormat: { LT: "A h:mm ਵਜੇ", LTS: "A h:mm:ss ਵਜੇ", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm ਵਜੇ", LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ" }, calendar: { sameDay: "[ਅਜ] LT", nextDay: "[ਕਲ] LT", nextWeek: "[ਅਗਲਾ] dddd, LT", lastDay: "[ਕਲ] LT", lastWeek: "[ਪਿਛਲੇ] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s ਵਿੱਚ", past: "%s ਪਿਛਲੇ", s: "ਕੁਝ ਸਕਿੰਟ", ss: "%d ਸਕਿੰਟ", m: "ਇਕ ਮਿੰਟ", mm: "%d ਮਿੰਟ", h: "ਇੱਕ ਘੰਟਾ", hh: "%d ਘੰਟੇ", d: "ਇੱਕ ਦਿਨ", dd: "%d ਦਿਨ", M: "ਇੱਕ ਮਹੀਨਾ", MM: "%d ਮਹੀਨੇ", y: "ਇੱਕ ਸਾਲ", yy: "%d ਸਾਲ" }, preparse: function(u) {
            return u.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "ਰਾਤ" ? u < 4 ? u : u + 12 : g === "ਸਵੇਰ" ? u : g === "ਦੁਪਹਿਰ" ? u >= 10 ? u : u + 12 : g === "ਸ਼ਾਮ" ? u + 12 : void 0;
          }, meridiem: function(u, g, m) {
            return u < 4 ? "ਰਾਤ" : u < 10 ? "ਸਵੇਰ" : u < 17 ? "ਦੁਪਹਿਰ" : u < 20 ? "ਸ਼ਾਮ" : "ਰਾਤ";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 5813: function(L, h, b) {
        (function(A) {
          var l = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"), o = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"), u = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^paź/i, /^lis/i, /^gru/i];
          function g(S) {
            return S % 10 < 5 && S % 10 > 1 && ~~(S / 10) % 10 != 1;
          }
          function m(S, e, n) {
            var d = S + " ";
            switch (n) {
              case "ss":
                return d + (g(S) ? "sekundy" : "sekund");
              case "m":
                return e ? "minuta" : "minutę";
              case "mm":
                return d + (g(S) ? "minuty" : "minut");
              case "h":
                return e ? "godzina" : "godzinę";
              case "hh":
                return d + (g(S) ? "godziny" : "godzin");
              case "ww":
                return d + (g(S) ? "tygodnie" : "tygodni");
              case "MM":
                return d + (g(S) ? "miesiące" : "miesięcy");
              case "yy":
                return d + (g(S) ? "lata" : "lat");
            }
          }
          A.defineLocale("pl", { months: function(S, e) {
            return S ? /D MMMM/.test(e) ? o[S.month()] : l[S.month()] : l;
          }, monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"), monthsParse: u, longMonthsParse: u, shortMonthsParse: u, weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"), weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"), weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Dziś o] LT", nextDay: "[Jutro o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W niedzielę o] LT";
              case 2:
                return "[We wtorek o] LT";
              case 3:
                return "[W środę o] LT";
              case 6:
                return "[W sobotę o] LT";
              default:
                return "[W] dddd [o] LT";
            }
          }, lastDay: "[Wczoraj o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[W zeszłą niedzielę o] LT";
              case 3:
                return "[W zeszłą środę o] LT";
              case 6:
                return "[W zeszłą sobotę o] LT";
              default:
                return "[W zeszły] dddd [o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "%s temu", s: "kilka sekund", ss: m, m, mm: m, h: m, hh: m, d: "1 dzień", dd: "%d dni", w: "tydzień", ww: m, M: "miesiąc", MM: m, y: "rok", yy: m }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 7078: function(L, h, b) {
        (function(A) {
          A.defineLocale("pt-br", { months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"), weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"), weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY [às] HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "há %s", s: "poucos segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", invalidDate: "Data inválida" });
        })(b(7840));
      }, 2845: function(L, h, b) {
        (function(A) {
          A.defineLocale("pt", { months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"), monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"), weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"), weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"), weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D [de] MMMM [de] YYYY", LLL: "D [de] MMMM [de] YYYY HH:mm", LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm" }, calendar: { sameDay: "[Hoje às] LT", nextDay: "[Amanhã às] LT", nextWeek: "dddd [às] LT", lastDay: "[Ontem às] LT", lastWeek: function() {
            return this.day() === 0 || this.day() === 6 ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT";
          }, sameElse: "L" }, relativeTime: { future: "em %s", past: "há %s", s: "segundos", ss: "%d segundos", m: "um minuto", mm: "%d minutos", h: "uma hora", hh: "%d horas", d: "um dia", dd: "%d dias", w: "uma semana", ww: "%d semanas", M: "um mês", MM: "%d meses", y: "um ano", yy: "%d anos" }, dayOfMonthOrdinalParse: /\d{1,2}º/, ordinal: "%dº", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6122: function(L, h, b) {
        (function(A) {
          function l(o, u, g) {
            var m = " ";
            return (o % 100 >= 20 || o >= 100 && o % 100 == 0) && (m = " de "), o + m + { ss: "secunde", mm: "minute", hh: "ore", dd: "zile", ww: "săptămâni", MM: "luni", yy: "ani" }[g];
          }
          A.defineLocale("ro", { months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"), monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"), weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"), weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY H:mm", LLLL: "dddd, D MMMM YYYY H:mm" }, calendar: { sameDay: "[azi la] LT", nextDay: "[mâine la] LT", nextWeek: "dddd [la] LT", lastDay: "[ieri la] LT", lastWeek: "[fosta] dddd [la] LT", sameElse: "L" }, relativeTime: { future: "peste %s", past: "%s în urmă", s: "câteva secunde", ss: l, m: "un minut", mm: l, h: "o oră", hh: l, d: "o zi", dd: l, w: "o săptămână", ww: l, M: "o lună", MM: l, y: "un an", yy: l }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 936: function(L, h, b) {
        (function(A) {
          function l(u, g, m) {
            return m === "m" ? g ? "минута" : "минуту" : u + " " + (S = +u, e = { ss: g ? "секунда_секунды_секунд" : "секунду_секунды_секунд", mm: g ? "минута_минуты_минут" : "минуту_минуты_минут", hh: "час_часа_часов", dd: "день_дня_дней", ww: "неделя_недели_недель", MM: "месяц_месяца_месяцев", yy: "год_года_лет" }[m].split("_"), S % 10 == 1 && S % 100 != 11 ? e[0] : S % 10 >= 2 && S % 10 <= 4 && (S % 100 < 10 || S % 100 >= 20) ? e[1] : e[2]);
            var S, e;
          }
          var o = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
          A.defineLocale("ru", { months: { format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"), standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_") }, monthsShort: { format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"), standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_") }, weekdays: { standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"), format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"), isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/ }, weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"), monthsParse: o, longMonthsParse: o, shortMonthsParse: o, monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i, monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i, monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY г.", LLL: "D MMMM YYYY г., H:mm", LLLL: "dddd, D MMMM YYYY г., H:mm" }, calendar: { sameDay: "[Сегодня, в] LT", nextDay: "[Завтра, в] LT", lastDay: "[Вчера, в] LT", nextWeek: function(u) {
            if (u.week() === this.week()) return this.day() === 2 ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
            switch (this.day()) {
              case 0:
                return "[В следующее] dddd, [в] LT";
              case 1:
              case 2:
              case 4:
                return "[В следующий] dddd, [в] LT";
              case 3:
              case 5:
              case 6:
                return "[В следующую] dddd, [в] LT";
            }
          }, lastWeek: function(u) {
            if (u.week() === this.week()) return this.day() === 2 ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
            switch (this.day()) {
              case 0:
                return "[В прошлое] dddd, [в] LT";
              case 1:
              case 2:
              case 4:
                return "[В прошлый] dddd, [в] LT";
              case 3:
              case 5:
              case 6:
                return "[В прошлую] dddd, [в] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "через %s", past: "%s назад", s: "несколько секунд", ss: l, m: l, mm: l, h: "час", hh: l, d: "день", dd: l, w: "неделя", ww: l, M: "месяц", MM: l, y: "год", yy: l }, meridiemParse: /ночи|утра|дня|вечера/i, isPM: function(u) {
            return /^(дня|вечера)$/.test(u);
          }, meridiem: function(u, g, m) {
            return u < 4 ? "ночи" : u < 12 ? "утра" : u < 17 ? "дня" : "вечера";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/, ordinal: function(u, g) {
            switch (g) {
              case "M":
              case "d":
              case "DDD":
                return u + "-й";
              case "D":
                return u + "-го";
              case "w":
              case "W":
                return u + "-я";
              default:
                return u;
            }
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 2642: function(L, h, b) {
        (function(A) {
          var l = ["جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر"], o = ["آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر"];
          A.defineLocale("sd", { months: l, monthsShort: l, weekdays: o, weekdaysShort: o, weekdaysMin: o, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function(u) {
            return u === "شام";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "صبح" : "شام";
          }, calendar: { sameDay: "[اڄ] LT", nextDay: "[سڀاڻي] LT", nextWeek: "dddd [اڳين هفتي تي] LT", lastDay: "[ڪالهه] LT", lastWeek: "[گزريل هفتي] dddd [تي] LT", sameElse: "L" }, relativeTime: { future: "%s پوء", past: "%s اڳ", s: "چند سيڪنڊ", ss: "%d سيڪنڊ", m: "هڪ منٽ", mm: "%d منٽ", h: "هڪ ڪلاڪ", hh: "%d ڪلاڪ", d: "هڪ ڏينهن", dd: "%d ڏينهن", M: "هڪ مهينو", MM: "%d مهينا", y: "هڪ سال", yy: "%d سال" }, preparse: function(u) {
            return u.replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/,/g, "،");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 529: function(L, h, b) {
        (function(A) {
          A.defineLocale("se", { months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"), monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"), weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"), weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"), weekdaysMin: "s_v_m_g_d_b_L".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "MMMM D. [b.] YYYY", LLL: "MMMM D. [b.] YYYY [ti.] HH:mm", LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm" }, calendar: { sameDay: "[otne ti] LT", nextDay: "[ihttin ti] LT", nextWeek: "dddd [ti] LT", lastDay: "[ikte ti] LT", lastWeek: "[ovddit] dddd [ti] LT", sameElse: "L" }, relativeTime: { future: "%s geažes", past: "maŋit %s", s: "moadde sekunddat", ss: "%d sekunddat", m: "okta minuhta", mm: "%d minuhtat", h: "okta diimmu", hh: "%d diimmut", d: "okta beaivi", dd: "%d beaivvit", M: "okta mánnu", MM: "%d mánut", y: "okta jahki", yy: "%d jagit" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 149: function(L, h, b) {
        (function(A) {
          A.defineLocale("si", { months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"), monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"), weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"), weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"), weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "a h:mm", LTS: "a h:mm:ss", L: "YYYY/MM/DD", LL: "YYYY MMMM D", LLL: "YYYY MMMM D, a h:mm", LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss" }, calendar: { sameDay: "[අද] LT[ට]", nextDay: "[හෙට] LT[ට]", nextWeek: "dddd LT[ට]", lastDay: "[ඊයේ] LT[ට]", lastWeek: "[පසුගිය] dddd LT[ට]", sameElse: "L" }, relativeTime: { future: "%sකින්", past: "%sකට පෙර", s: "තත්පර කිහිපය", ss: "තත්පර %d", m: "මිනිත්තුව", mm: "මිනිත්තු %d", h: "පැය", hh: "පැය %d", d: "දිනය", dd: "දින %d", M: "මාසය", MM: "මාස %d", y: "වසර", yy: "වසර %d" }, dayOfMonthOrdinalParse: /\d{1,2} වැනි/, ordinal: function(l) {
            return l + " වැනි";
          }, meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./, isPM: function(l) {
            return l === "ප.ව." || l === "පස් වරු";
          }, meridiem: function(l, o, u) {
            return l > 11 ? u ? "ප.ව." : "පස් වරු" : u ? "පෙ.ව." : "පෙර වරු";
          } });
        })(b(7840));
      }, 2051: function(L, h, b) {
        (function(A) {
          var l = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"), o = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");
          function u(m) {
            return m > 1 && m < 5;
          }
          function g(m, S, e, n) {
            var d = m + " ";
            switch (e) {
              case "s":
                return S || n ? "pár sekúnd" : "pár sekundami";
              case "ss":
                return S || n ? d + (u(m) ? "sekundy" : "sekúnd") : d + "sekundami";
              case "m":
                return S ? "minúta" : n ? "minútu" : "minútou";
              case "mm":
                return S || n ? d + (u(m) ? "minúty" : "minút") : d + "minútami";
              case "h":
                return S ? "hodina" : n ? "hodinu" : "hodinou";
              case "hh":
                return S || n ? d + (u(m) ? "hodiny" : "hodín") : d + "hodinami";
              case "d":
                return S || n ? "deň" : "dňom";
              case "dd":
                return S || n ? d + (u(m) ? "dni" : "dní") : d + "dňami";
              case "M":
                return S || n ? "mesiac" : "mesiacom";
              case "MM":
                return S || n ? d + (u(m) ? "mesiace" : "mesiacov") : d + "mesiacmi";
              case "y":
                return S || n ? "rok" : "rokom";
              case "yy":
                return S || n ? d + (u(m) ? "roky" : "rokov") : d + "rokmi";
            }
          }
          A.defineLocale("sk", { months: l, monthsShort: o, weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"), weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"), weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"), longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD.MM.YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd D. MMMM YYYY H:mm" }, calendar: { sameDay: "[dnes o] LT", nextDay: "[zajtra o] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v nedeľu o] LT";
              case 1:
              case 2:
                return "[v] dddd [o] LT";
              case 3:
                return "[v stredu o] LT";
              case 4:
                return "[vo štvrtok o] LT";
              case 5:
                return "[v piatok o] LT";
              case 6:
                return "[v sobotu o] LT";
            }
          }, lastDay: "[včera o] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[minulú nedeľu o] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[minulý] dddd [o] LT";
              case 3:
                return "[minulú stredu o] LT";
              case 6:
                return "[minulú sobotu o] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pred %s", s: g, ss: g, m: g, mm: g, h: g, hh: g, d: g, dd: g, M: g, MM: g, y: g, yy: g }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 5306: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = o + " ";
            switch (g) {
              case "s":
                return u || m ? "nekaj sekund" : "nekaj sekundami";
              case "ss":
                return S + (o === 1 ? u ? "sekundo" : "sekundi" : o === 2 ? u || m ? "sekundi" : "sekundah" : o < 5 ? u || m ? "sekunde" : "sekundah" : "sekund");
              case "m":
                return u ? "ena minuta" : "eno minuto";
              case "mm":
                return S + (o === 1 ? u ? "minuta" : "minuto" : o === 2 ? u || m ? "minuti" : "minutama" : o < 5 ? u || m ? "minute" : "minutami" : u || m ? "minut" : "minutami");
              case "h":
                return u ? "ena ura" : "eno uro";
              case "hh":
                return S + (o === 1 ? u ? "ura" : "uro" : o === 2 ? u || m ? "uri" : "urama" : o < 5 ? u || m ? "ure" : "urami" : u || m ? "ur" : "urami");
              case "d":
                return u || m ? "en dan" : "enim dnem";
              case "dd":
                return S + (o === 1 ? u || m ? "dan" : "dnem" : o === 2 ? u || m ? "dni" : "dnevoma" : u || m ? "dni" : "dnevi");
              case "M":
                return u || m ? "en mesec" : "enim mesecem";
              case "MM":
                return S + (o === 1 ? u || m ? "mesec" : "mesecem" : o === 2 ? u || m ? "meseca" : "mesecema" : o < 5 ? u || m ? "mesece" : "meseci" : u || m ? "mesecev" : "meseci");
              case "y":
                return u || m ? "eno leto" : "enim letom";
              case "yy":
                return S + (o === 1 ? u || m ? "leto" : "letom" : o === 2 ? u || m ? "leti" : "letoma" : o < 5 ? u || m ? "leta" : "leti" : u || m ? "let" : "leti");
            }
          }
          A.defineLocale("sl", { months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"), monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"), weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"), weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD. MM. YYYY", LL: "D. MMMM YYYY", LLL: "D. MMMM YYYY H:mm", LLLL: "dddd, D. MMMM YYYY H:mm" }, calendar: { sameDay: "[danes ob] LT", nextDay: "[jutri ob] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[v] [nedeljo] [ob] LT";
              case 3:
                return "[v] [sredo] [ob] LT";
              case 6:
                return "[v] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[v] dddd [ob] LT";
            }
          }, lastDay: "[včeraj ob] LT", lastWeek: function() {
            switch (this.day()) {
              case 0:
                return "[prejšnjo] [nedeljo] [ob] LT";
              case 3:
                return "[prejšnjo] [sredo] [ob] LT";
              case 6:
                return "[prejšnjo] [soboto] [ob] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[prejšnji] dddd [ob] LT";
            }
          }, sameElse: "L" }, relativeTime: { future: "čez %s", past: "pred %s", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 4301: function(L, h, b) {
        (function(A) {
          A.defineLocale("sq", { months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"), monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"), weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"), weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"), weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"), weekdaysParseExact: !0, meridiemParse: /PD|MD/, isPM: function(l) {
            return l.charAt(0) === "M";
          }, meridiem: function(l, o, u) {
            return l < 12 ? "PD" : "MD";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Sot në] LT", nextDay: "[Nesër në] LT", nextWeek: "dddd [në] LT", lastDay: "[Dje në] LT", lastWeek: "dddd [e kaluar në] LT", sameElse: "L" }, relativeTime: { future: "në %s", past: "%s më parë", s: "disa sekonda", ss: "%d sekonda", m: "një minutë", mm: "%d minuta", h: "një orë", hh: "%d orë", d: "një ditë", dd: "%d ditë", M: "një muaj", MM: "%d muaj", y: "një vit", yy: "%d vite" }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 555: function(L, h, b) {
        (function(A) {
          var l = { words: { ss: ["секунда", "секунде", "секунди"], m: ["један минут", "једног минута"], mm: ["минут", "минута", "минута"], h: ["један сат", "једног сата"], hh: ["сат", "сата", "сати"], d: ["један дан", "једног дана"], dd: ["дан", "дана", "дана"], M: ["један месец", "једног месеца"], MM: ["месец", "месеца", "месеци"], y: ["једну годину", "једне године"], yy: ["годину", "године", "година"] }, correctGrammaticalCase: function(o, u) {
            return o % 10 >= 1 && o % 10 <= 4 && (o % 100 < 10 || o % 100 >= 20) ? o % 10 == 1 ? u[0] : u[1] : u[2];
          }, translate: function(o, u, g, m) {
            var S, e = l.words[g];
            return g.length === 1 ? g === "y" && u ? "једна година" : m || u ? e[0] : e[1] : (S = l.correctGrammaticalCase(o, e), g === "yy" && u && S === "годину" ? o + " година" : o + " " + S);
          } };
          A.defineLocale("sr-cyrl", { months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"), monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"), monthsParseExact: !0, weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"), weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"), weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[данас у] LT", nextDay: "[сутра у] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[у] [недељу] [у] LT";
              case 3:
                return "[у] [среду] [у] LT";
              case 6:
                return "[у] [суботу] [у] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[у] dddd [у] LT";
            }
          }, lastDay: "[јуче у] LT", lastWeek: function() {
            return ["[прошле] [недеље] [у] LT", "[прошлог] [понедељка] [у] LT", "[прошлог] [уторка] [у] LT", "[прошле] [среде] [у] LT", "[прошлог] [четвртка] [у] LT", "[прошлог] [петка] [у] LT", "[прошле] [суботе] [у] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "пре %s", s: "неколико секунди", ss: l.translate, m: l.translate, mm: l.translate, h: l.translate, hh: l.translate, d: l.translate, dd: l.translate, M: l.translate, MM: l.translate, y: l.translate, yy: l.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 2452: function(L, h, b) {
        (function(A) {
          var l = { words: { ss: ["sekunda", "sekunde", "sekundi"], m: ["jedan minut", "jednog minuta"], mm: ["minut", "minuta", "minuta"], h: ["jedan sat", "jednog sata"], hh: ["sat", "sata", "sati"], d: ["jedan dan", "jednog dana"], dd: ["dan", "dana", "dana"], M: ["jedan mesec", "jednog meseca"], MM: ["mesec", "meseca", "meseci"], y: ["jednu godinu", "jedne godine"], yy: ["godinu", "godine", "godina"] }, correctGrammaticalCase: function(o, u) {
            return o % 10 >= 1 && o % 10 <= 4 && (o % 100 < 10 || o % 100 >= 20) ? o % 10 == 1 ? u[0] : u[1] : u[2];
          }, translate: function(o, u, g, m) {
            var S, e = l.words[g];
            return g.length === 1 ? g === "y" && u ? "jedna godina" : m || u ? e[0] : e[1] : (S = l.correctGrammaticalCase(o, e), g === "yy" && u && S === "godinu" ? o + " godina" : o + " " + S);
          } };
          A.defineLocale("sr", { months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"), monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"), monthsParseExact: !0, weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"), weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"), weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "D. M. YYYY.", LL: "D. MMMM YYYY.", LLL: "D. MMMM YYYY. H:mm", LLLL: "dddd, D. MMMM YYYY. H:mm" }, calendar: { sameDay: "[danas u] LT", nextDay: "[sutra u] LT", nextWeek: function() {
            switch (this.day()) {
              case 0:
                return "[u] [nedelju] [u] LT";
              case 3:
                return "[u] [sredu] [u] LT";
              case 6:
                return "[u] [subotu] [u] LT";
              case 1:
              case 2:
              case 4:
              case 5:
                return "[u] dddd [u] LT";
            }
          }, lastDay: "[juče u] LT", lastWeek: function() {
            return ["[prošle] [nedelje] [u] LT", "[prošlog] [ponedeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()];
          }, sameElse: "L" }, relativeTime: { future: "za %s", past: "pre %s", s: "nekoliko sekundi", ss: l.translate, m: l.translate, mm: l.translate, h: l.translate, hh: l.translate, d: l.translate, dd: l.translate, M: l.translate, MM: l.translate, y: l.translate, yy: l.translate }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 395: function(L, h, b) {
        (function(A) {
          A.defineLocale("ss", { months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"), monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"), weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"), weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"), weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Namuhla nga] LT", nextDay: "[Kusasa nga] LT", nextWeek: "dddd [nga] LT", lastDay: "[Itolo nga] LT", lastWeek: "dddd [leliphelile] [nga] LT", sameElse: "L" }, relativeTime: { future: "nga %s", past: "wenteka nga %s", s: "emizuzwana lomcane", ss: "%d mzuzwana", m: "umzuzu", mm: "%d emizuzu", h: "lihora", hh: "%d emahora", d: "lilanga", dd: "%d emalanga", M: "inyanga", MM: "%d tinyanga", y: "umnyaka", yy: "%d iminyaka" }, meridiemParse: /ekuseni|emini|entsambama|ebusuku/, meridiem: function(l, o, u) {
            return l < 11 ? "ekuseni" : l < 15 ? "emini" : l < 19 ? "entsambama" : "ebusuku";
          }, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "ekuseni" ? l : o === "emini" ? l >= 11 ? l : l + 12 : o === "entsambama" || o === "ebusuku" ? l === 0 ? 0 : l + 12 : void 0;
          }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: "%d", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4600: function(L, h, b) {
        (function(A) {
          A.defineLocale("sv", { months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"), monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"), weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"), weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"), weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "D MMMM YYYY", LLL: "D MMMM YYYY [kl.] HH:mm", LLLL: "dddd D MMMM YYYY [kl.] HH:mm", lll: "D MMM YYYY HH:mm", llll: "ddd D MMM YYYY HH:mm" }, calendar: { sameDay: "[Idag] LT", nextDay: "[Imorgon] LT", lastDay: "[Igår] LT", nextWeek: "[På] dddd LT", lastWeek: "[I] dddd[s] LT", sameElse: "L" }, relativeTime: { future: "om %s", past: "för %s sedan", s: "några sekunder", ss: "%d sekunder", m: "en minut", mm: "%d minuter", h: "en timme", hh: "%d timmar", d: "en dag", dd: "%d dagar", M: "en månad", MM: "%d månader", y: "ett år", yy: "%d år" }, dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? ":e" : o === 1 || o === 2 ? ":a" : ":e");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6687: function(L, h, b) {
        (function(A) {
          A.defineLocale("sw", { months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"), monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"), weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"), weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"), weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "hh:mm A", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[leo saa] LT", nextDay: "[kesho saa] LT", nextWeek: "[wiki ijayo] dddd [saat] LT", lastDay: "[jana] LT", lastWeek: "[wiki iliyopita] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s baadaye", past: "tokea %s", s: "hivi punde", ss: "sekunde %d", m: "dakika moja", mm: "dakika %d", h: "saa limoja", hh: "masaa %d", d: "siku moja", dd: "siku %d", M: "mwezi mmoja", MM: "miezi %d", y: "mwaka mmoja", yy: "miaka %d" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 5102: function(L, h, b) {
        (function(A) {
          var l = { 1: "௧", 2: "௨", 3: "௩", 4: "௪", 5: "௫", 6: "௬", 7: "௭", 8: "௮", 9: "௯", 0: "௦" }, o = { "௧": "1", "௨": "2", "௩": "3", "௪": "4", "௫": "5", "௬": "6", "௭": "7", "௮": "8", "௯": "9", "௦": "0" };
          A.defineLocale("ta", { months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"), weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"), weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"), weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, HH:mm", LLLL: "dddd, D MMMM YYYY, HH:mm" }, calendar: { sameDay: "[இன்று] LT", nextDay: "[நாளை] LT", nextWeek: "dddd, LT", lastDay: "[நேற்று] LT", lastWeek: "[கடந்த வாரம்] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s இல்", past: "%s முன்", s: "ஒரு சில விநாடிகள்", ss: "%d விநாடிகள்", m: "ஒரு நிமிடம்", mm: "%d நிமிடங்கள்", h: "ஒரு மணி நேரம்", hh: "%d மணி நேரம்", d: "ஒரு நாள்", dd: "%d நாட்கள்", M: "ஒரு மாதம்", MM: "%d மாதங்கள்", y: "ஒரு வருடம்", yy: "%d ஆண்டுகள்" }, dayOfMonthOrdinalParse: /\d{1,2}வது/, ordinal: function(u) {
            return u + "வது";
          }, preparse: function(u) {
            return u.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, function(g) {
              return o[g];
            });
          }, postformat: function(u) {
            return u.replace(/\d/g, function(g) {
              return l[g];
            });
          }, meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/, meridiem: function(u, g, m) {
            return u < 2 ? " யாமம்" : u < 6 ? " வைகறை" : u < 10 ? " காலை" : u < 14 ? " நண்பகல்" : u < 18 ? " எற்பாடு" : u < 22 ? " மாலை" : " யாமம்";
          }, meridiemHour: function(u, g) {
            return u === 12 && (u = 0), g === "யாமம்" ? u < 2 ? u : u + 12 : g === "வைகறை" || g === "காலை" || g === "நண்பகல்" && u >= 10 ? u : u + 12;
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 1298: function(L, h, b) {
        (function(A) {
          A.defineLocale("te", { months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"), monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"), monthsParseExact: !0, weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"), weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"), weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"), longDateFormat: { LT: "A h:mm", LTS: "A h:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY, A h:mm", LLLL: "dddd, D MMMM YYYY, A h:mm" }, calendar: { sameDay: "[నేడు] LT", nextDay: "[రేపు] LT", nextWeek: "dddd, LT", lastDay: "[నిన్న] LT", lastWeek: "[గత] dddd, LT", sameElse: "L" }, relativeTime: { future: "%s లో", past: "%s క్రితం", s: "కొన్ని క్షణాలు", ss: "%d సెకన్లు", m: "ఒక నిమిషం", mm: "%d నిమిషాలు", h: "ఒక గంట", hh: "%d గంటలు", d: "ఒక రోజు", dd: "%d రోజులు", M: "ఒక నెల", MM: "%d నెలలు", y: "ఒక సంవత్సరం", yy: "%d సంవత్సరాలు" }, dayOfMonthOrdinalParse: /\d{1,2}వ/, ordinal: "%dవ", meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "రాత్రి" ? l < 4 ? l : l + 12 : o === "ఉదయం" ? l : o === "మధ్యాహ్నం" ? l >= 10 ? l : l + 12 : o === "సాయంత్రం" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            return l < 4 ? "రాత్రి" : l < 10 ? "ఉదయం" : l < 17 ? "మధ్యాహ్నం" : l < 20 ? "సాయంత్రం" : "రాత్రి";
          }, week: { dow: 0, doy: 6 } });
        })(b(7840));
      }, 9028: function(L, h, b) {
        (function(A) {
          A.defineLocale("tet", { months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"), monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"), weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"), weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"), weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Ohin iha] LT", nextDay: "[Aban iha] LT", nextWeek: "dddd [iha] LT", lastDay: "[Horiseik iha] LT", lastWeek: "dddd [semana kotuk] [iha] LT", sameElse: "L" }, relativeTime: { future: "iha %s", past: "%s liuba", s: "segundu balun", ss: "segundu %d", m: "minutu ida", mm: "minutu %d", h: "oras ida", hh: "oras %d", d: "loron ida", dd: "loron %d", M: "fulan ida", MM: "fulan %d", y: "tinan ida", yy: "tinan %d" }, dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8680: function(L, h, b) {
        (function(A) {
          var l = { 0: "-ум", 1: "-ум", 2: "-юм", 3: "-юм", 4: "-ум", 5: "-ум", 6: "-ум", 7: "-ум", 8: "-ум", 9: "-ум", 10: "-ум", 12: "-ум", 13: "-ум", 20: "-ум", 30: "-юм", 40: "-ум", 50: "-ум", 60: "-ум", 70: "-ум", 80: "-ум", 90: "-ум", 100: "-ум" };
          A.defineLocale("tg", { months: { format: "январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри".split("_"), standalone: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_") }, monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе".split("_"), weekdaysShort: "яшб_дшб_сшб_чшб_пшб_ҷум_шнб".split("_"), weekdaysMin: "яш_дш_сш_чш_пш_ҷм_шб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[Имрӯз соати] LT", nextDay: "[Фардо соати] LT", lastDay: "[Дирӯз соати] LT", nextWeek: "dddd[и] [ҳафтаи оянда соати] LT", lastWeek: "dddd[и] [ҳафтаи гузашта соати] LT", sameElse: "L" }, relativeTime: { future: "баъди %s", past: "%s пеш", s: "якчанд сония", m: "як дақиқа", mm: "%d дақиқа", h: "як соат", hh: "%d соат", d: "як рӯз", dd: "%d рӯз", M: "як моҳ", MM: "%d моҳ", y: "як сол", yy: "%d сол" }, meridiemParse: /шаб|субҳ|рӯз|бегоҳ/, meridiemHour: function(o, u) {
            return o === 12 && (o = 0), u === "шаб" ? o < 4 ? o : o + 12 : u === "субҳ" ? o : u === "рӯз" ? o >= 11 ? o : o + 12 : u === "бегоҳ" ? o + 12 : void 0;
          }, meridiem: function(o, u, g) {
            return o < 4 ? "шаб" : o < 11 ? "субҳ" : o < 16 ? "рӯз" : o < 19 ? "бегоҳ" : "шаб";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/, ordinal: function(o) {
            return o + (l[o] || l[o % 10] || l[o >= 100 ? 100 : null]);
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 7093: function(L, h, b) {
        (function(A) {
          A.defineLocale("th", { months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"), monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"), monthsParseExact: !0, weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"), weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"), weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "H:mm", LTS: "H:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY เวลา H:mm", LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm" }, meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/, isPM: function(l) {
            return l === "หลังเที่ยง";
          }, meridiem: function(l, o, u) {
            return l < 12 ? "ก่อนเที่ยง" : "หลังเที่ยง";
          }, calendar: { sameDay: "[วันนี้ เวลา] LT", nextDay: "[พรุ่งนี้ เวลา] LT", nextWeek: "dddd[หน้า เวลา] LT", lastDay: "[เมื่อวานนี้ เวลา] LT", lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT", sameElse: "L" }, relativeTime: { future: "อีก %s", past: "%sที่แล้ว", s: "ไม่กี่วินาที", ss: "%d วินาที", m: "1 นาที", mm: "%d นาที", h: "1 ชั่วโมง", hh: "%d ชั่วโมง", d: "1 วัน", dd: "%d วัน", w: "1 สัปดาห์", ww: "%d สัปดาห์", M: "1 เดือน", MM: "%d เดือน", y: "1 ปี", yy: "%d ปี" } });
        })(b(7840));
      }, 2668: function(L, h, b) {
        (function(A) {
          var l = { 1: "'inji", 5: "'inji", 8: "'inji", 70: "'inji", 80: "'inji", 2: "'nji", 7: "'nji", 20: "'nji", 50: "'nji", 3: "'ünji", 4: "'ünji", 100: "'ünji", 6: "'njy", 9: "'unjy", 10: "'unjy", 30: "'unjy", 60: "'ynjy", 90: "'ynjy" };
          A.defineLocale("tk", { months: "Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr".split("_"), monthsShort: "Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek".split("_"), weekdays: "Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe".split("_"), weekdaysShort: "Ýek_Duş_Siş_Çar_Pen_Ann_Şen".split("_"), weekdaysMin: "Ýk_Dş_Sş_Çr_Pn_An_Şn".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün sagat] LT", nextDay: "[ertir sagat] LT", nextWeek: "[indiki] dddd [sagat] LT", lastDay: "[düýn] LT", lastWeek: "[geçen] dddd [sagat] LT", sameElse: "L" }, relativeTime: { future: "%s soň", past: "%s öň", s: "birnäçe sekunt", m: "bir minut", mm: "%d minut", h: "bir sagat", hh: "%d sagat", d: "bir gün", dd: "%d gün", M: "bir aý", MM: "%d aý", y: "bir ýyl", yy: "%d ýyl" }, ordinal: function(o, u) {
            switch (u) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return o;
              default:
                if (o === 0) return o + "'unjy";
                var g = o % 10;
                return o + (l[g] || l[o % 100 - g] || l[o >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 3890: function(L, h, b) {
        (function(A) {
          A.defineLocale("tl-ph", { months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"), monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"), weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"), weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"), weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "MM/D/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY HH:mm", LLLL: "dddd, MMMM DD, YYYY HH:mm" }, calendar: { sameDay: "LT [ngayong araw]", nextDay: "[Bukas ng] LT", nextWeek: "LT [sa susunod na] dddd", lastDay: "LT [kahapon]", lastWeek: "LT [noong nakaraang] dddd", sameElse: "L" }, relativeTime: { future: "sa loob ng %s", past: "%s ang nakalipas", s: "ilang segundo", ss: "%d segundo", m: "isang minuto", mm: "%d minuto", h: "isang oras", hh: "%d oras", d: "isang araw", dd: "%d araw", M: "isang buwan", MM: "%d buwan", y: "isang taon", yy: "%d taon" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(l) {
            return l;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6717: function(L, h, b) {
        (function(A) {
          var l = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
          function o(u, g, m, S) {
            var e = function(n) {
              var d = Math.floor(n % 1e3 / 100), _ = Math.floor(n % 100 / 10), p = n % 10, P = "";
              return d > 0 && (P += l[d] + "vatlh"), _ > 0 && (P += (P !== "" ? " " : "") + l[_] + "maH"), p > 0 && (P += (P !== "" ? " " : "") + l[p]), P === "" ? "pagh" : P;
            }(u);
            switch (m) {
              case "ss":
                return e + " lup";
              case "mm":
                return e + " tup";
              case "hh":
                return e + " rep";
              case "dd":
                return e + " jaj";
              case "MM":
                return e + " jar";
              case "yy":
                return e + " DIS";
            }
          }
          A.defineLocale("tlh", { months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"), monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"), monthsParseExact: !0, weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[DaHjaj] LT", nextDay: "[wa’leS] LT", nextWeek: "LLL", lastDay: "[wa’Hu’] LT", lastWeek: "LLL", sameElse: "L" }, relativeTime: { future: function(u) {
            var g = u;
            return u.indexOf("jaj") !== -1 ? g.slice(0, -3) + "leS" : u.indexOf("jar") !== -1 ? g.slice(0, -3) + "waQ" : u.indexOf("DIS") !== -1 ? g.slice(0, -3) + "nem" : g + " pIq";
          }, past: function(u) {
            var g = u;
            return u.indexOf("jaj") !== -1 ? g.slice(0, -3) + "Hu’" : u.indexOf("jar") !== -1 ? g.slice(0, -3) + "wen" : u.indexOf("DIS") !== -1 ? g.slice(0, -3) + "ben" : g + " ret";
          }, s: "puS lup", ss: o, m: "wa’ tup", mm: o, h: "wa’ rep", hh: o, d: "wa’ jaj", dd: o, M: "wa’ jar", MM: o, y: "wa’ DIS", yy: o }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6475: function(L, h, b) {
        (function(A) {
          var l = { 1: "'inci", 5: "'inci", 8: "'inci", 70: "'inci", 80: "'inci", 2: "'nci", 7: "'nci", 20: "'nci", 50: "'nci", 3: "'üncü", 4: "'üncü", 100: "'üncü", 6: "'ncı", 9: "'uncu", 10: "'uncu", 30: "'uncu", 60: "'ıncı", 90: "'ıncı" };
          A.defineLocale("tr", { months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"), monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"), weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"), weekdaysShort: "Paz_Pzt_Sal_Çar_Per_Cum_Cmt".split("_"), weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"), meridiem: function(o, u, g) {
            return o < 12 ? g ? "öö" : "ÖÖ" : g ? "ös" : "ÖS";
          }, meridiemParse: /öö|ÖÖ|ös|ÖS/, isPM: function(o) {
            return o === "ös" || o === "ÖS";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[bugün saat] LT", nextDay: "[yarın saat] LT", nextWeek: "[gelecek] dddd [saat] LT", lastDay: "[dün] LT", lastWeek: "[geçen] dddd [saat] LT", sameElse: "L" }, relativeTime: { future: "%s sonra", past: "%s önce", s: "birkaç saniye", ss: "%d saniye", m: "bir dakika", mm: "%d dakika", h: "bir saat", hh: "%d saat", d: "bir gün", dd: "%d gün", w: "bir hafta", ww: "%d hafta", M: "bir ay", MM: "%d ay", y: "bir yıl", yy: "%d yıl" }, ordinal: function(o, u) {
            switch (u) {
              case "d":
              case "D":
              case "Do":
              case "DD":
                return o;
              default:
                if (o === 0) return o + "'ıncı";
                var g = o % 10;
                return o + (l[g] || l[o % 100 - g] || l[o >= 100 ? 100 : null]);
            }
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 911: function(L, h, b) {
        (function(A) {
          function l(o, u, g, m) {
            var S = { s: ["viensas secunds", "'iensas secunds"], ss: [o + " secunds", o + " secunds"], m: ["'n míut", "'iens míut"], mm: [o + " míuts", o + " míuts"], h: ["'n þora", "'iensa þora"], hh: [o + " þoras", o + " þoras"], d: ["'n ziua", "'iensa ziua"], dd: [o + " ziuas", o + " ziuas"], M: ["'n mes", "'iens mes"], MM: [o + " mesen", o + " mesen"], y: ["'n ar", "'iens ar"], yy: [o + " ars", o + " ars"] };
            return m || u ? S[g][0] : S[g][1];
          }
          A.defineLocale("tzl", { months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"), monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"), weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"), weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"), weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"), longDateFormat: { LT: "HH.mm", LTS: "HH.mm.ss", L: "DD.MM.YYYY", LL: "D. MMMM [dallas] YYYY", LLL: "D. MMMM [dallas] YYYY HH.mm", LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm" }, meridiemParse: /d\'o|d\'a/i, isPM: function(o) {
            return o.toLowerCase() === "d'o";
          }, meridiem: function(o, u, g) {
            return o > 11 ? g ? "d'o" : "D'O" : g ? "d'a" : "D'A";
          }, calendar: { sameDay: "[oxhi à] LT", nextDay: "[demà à] LT", nextWeek: "dddd [à] LT", lastDay: "[ieiri à] LT", lastWeek: "[sür el] dddd [lasteu à] LT", sameElse: "L" }, relativeTime: { future: "osprei %s", past: "ja%s", s: l, ss: l, m: l, mm: l, h: l, hh: l, d: l, dd: l, M: l, MM: l, y: l, yy: l }, dayOfMonthOrdinalParse: /\d{1,2}\./, ordinal: "%d.", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8648: function(L, h, b) {
        (function(A) {
          A.defineLocale("tzm-latn", { months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"), weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[asdkh g] LT", nextDay: "[aska g] LT", nextWeek: "dddd [g] LT", lastDay: "[assant g] LT", lastWeek: "dddd [g] LT", sameElse: "L" }, relativeTime: { future: "dadkh s yan %s", past: "yan %s", s: "imik", ss: "%d imik", m: "minuḍ", mm: "%d minuḍ", h: "saɛa", hh: "%d tassaɛin", d: "ass", dd: "%d ossan", M: "ayowr", MM: "%d iyyirn", y: "asgas", yy: "%d isgasn" }, week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 6552: function(L, h, b) {
        (function(A) {
          A.defineLocale("tzm", { months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"), weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd D MMMM YYYY HH:mm" }, calendar: { sameDay: "[ⴰⵙⴷⵅ ⴴ] LT", nextDay: "[ⴰⵙⴽⴰ ⴴ] LT", nextWeek: "dddd [ⴴ] LT", lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT", lastWeek: "dddd [ⴴ] LT", sameElse: "L" }, relativeTime: { future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s", past: "ⵢⴰⵏ %s", s: "ⵉⵎⵉⴽ", ss: "%d ⵉⵎⵉⴽ", m: "ⵎⵉⵏⵓⴺ", mm: "%d ⵎⵉⵏⵓⴺ", h: "ⵙⴰⵄⴰ", hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ", d: "ⴰⵙⵙ", dd: "%d oⵙⵙⴰⵏ", M: "ⴰⵢoⵓⵔ", MM: "%d ⵉⵢⵢⵉⵔⵏ", y: "ⴰⵙⴳⴰⵙ", yy: "%d ⵉⵙⴳⴰⵙⵏ" }, week: { dow: 6, doy: 12 } });
        })(b(7840));
      }, 419: function(L, h, b) {
        (function(A) {
          A.defineLocale("ug-cn", { months: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"), monthsShort: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"), weekdays: "يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە".split("_"), weekdaysShort: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"), weekdaysMin: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY-MM-DD", LL: "YYYY-يىلىM-ئاينىڭD-كۈنى", LLL: "YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm", LLLL: "dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm" }, meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "يېرىم كېچە" || o === "سەھەر" || o === "چۈشتىن بۇرۇن" ? l : o === "چۈشتىن كېيىن" || o === "كەچ" ? l + 12 : l >= 11 ? l : l + 12;
          }, meridiem: function(l, o, u) {
            var g = 100 * l + o;
            return g < 600 ? "يېرىم كېچە" : g < 900 ? "سەھەر" : g < 1130 ? "چۈشتىن بۇرۇن" : g < 1230 ? "چۈش" : g < 1800 ? "چۈشتىن كېيىن" : "كەچ";
          }, calendar: { sameDay: "[بۈگۈن سائەت] LT", nextDay: "[ئەتە سائەت] LT", nextWeek: "[كېلەركى] dddd [سائەت] LT", lastDay: "[تۆنۈگۈن] LT", lastWeek: "[ئالدىنقى] dddd [سائەت] LT", sameElse: "L" }, relativeTime: { future: "%s كېيىن", past: "%s بۇرۇن", s: "نەچچە سېكونت", ss: "%d سېكونت", m: "بىر مىنۇت", mm: "%d مىنۇت", h: "بىر سائەت", hh: "%d سائەت", d: "بىر كۈن", dd: "%d كۈن", M: "بىر ئاي", MM: "%d ئاي", y: "بىر يىل", yy: "%d يىل" }, dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "-كۈنى";
              case "w":
              case "W":
                return l + "-ھەپتە";
              default:
                return l;
            }
          }, preparse: function(l) {
            return l.replace(/،/g, ",");
          }, postformat: function(l) {
            return l.replace(/,/g, "،");
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 6073: function(L, h, b) {
        (function(A) {
          function l(u, g, m) {
            return m === "m" ? g ? "хвилина" : "хвилину" : m === "h" ? g ? "година" : "годину" : u + " " + (S = +u, e = { ss: g ? "секунда_секунди_секунд" : "секунду_секунди_секунд", mm: g ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин", hh: g ? "година_години_годин" : "годину_години_годин", dd: "день_дні_днів", MM: "місяць_місяці_місяців", yy: "рік_роки_років" }[m].split("_"), S % 10 == 1 && S % 100 != 11 ? e[0] : S % 10 >= 2 && S % 10 <= 4 && (S % 100 < 10 || S % 100 >= 20) ? e[1] : e[2]);
            var S, e;
          }
          function o(u) {
            return function() {
              return u + "о" + (this.hours() === 11 ? "б" : "") + "] LT";
            };
          }
          A.defineLocale("uk", { months: { format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"), standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_") }, monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"), weekdays: function(u, g) {
            var m = { nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"), accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"), genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_") };
            return u === !0 ? m.nominative.slice(1, 7).concat(m.nominative.slice(0, 1)) : u ? m[/(\[[ВвУу]\]) ?dddd/.test(g) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(g) ? "genitive" : "nominative"][u.day()] : m.nominative;
          }, weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"), weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD.MM.YYYY", LL: "D MMMM YYYY р.", LLL: "D MMMM YYYY р., HH:mm", LLLL: "dddd, D MMMM YYYY р., HH:mm" }, calendar: { sameDay: o("[Сьогодні "), nextDay: o("[Завтра "), lastDay: o("[Вчора "), nextWeek: o("[У] dddd ["), lastWeek: function() {
            switch (this.day()) {
              case 0:
              case 3:
              case 5:
              case 6:
                return o("[Минулої] dddd [").call(this);
              case 1:
              case 2:
              case 4:
                return o("[Минулого] dddd [").call(this);
            }
          }, sameElse: "L" }, relativeTime: { future: "за %s", past: "%s тому", s: "декілька секунд", ss: l, m: l, mm: l, h: "годину", hh: l, d: "день", dd: l, M: "місяць", MM: l, y: "рік", yy: l }, meridiemParse: /ночі|ранку|дня|вечора/, isPM: function(u) {
            return /^(дня|вечора)$/.test(u);
          }, meridiem: function(u, g, m) {
            return u < 4 ? "ночі" : u < 12 ? "ранку" : u < 17 ? "дня" : "вечора";
          }, dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/, ordinal: function(u, g) {
            switch (g) {
              case "M":
              case "d":
              case "DDD":
              case "w":
              case "W":
                return u + "-й";
              case "D":
                return u + "-го";
              default:
                return u;
            }
          }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 210: function(L, h, b) {
        (function(A) {
          var l = ["جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر"], o = ["اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ"];
          A.defineLocale("ur", { months: l, monthsShort: l, weekdays: o, weekdaysShort: o, weekdaysMin: o, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd، D MMMM YYYY HH:mm" }, meridiemParse: /صبح|شام/, isPM: function(u) {
            return u === "شام";
          }, meridiem: function(u, g, m) {
            return u < 12 ? "صبح" : "شام";
          }, calendar: { sameDay: "[آج بوقت] LT", nextDay: "[کل بوقت] LT", nextWeek: "dddd [بوقت] LT", lastDay: "[گذشتہ روز بوقت] LT", lastWeek: "[گذشتہ] dddd [بوقت] LT", sameElse: "L" }, relativeTime: { future: "%s بعد", past: "%s قبل", s: "چند سیکنڈ", ss: "%d سیکنڈ", m: "ایک منٹ", mm: "%d منٹ", h: "ایک گھنٹہ", hh: "%d گھنٹے", d: "ایک دن", dd: "%d دن", M: "ایک ماہ", MM: "%d ماہ", y: "ایک سال", yy: "%d سال" }, preparse: function(u) {
            return u.replace(/،/g, ",");
          }, postformat: function(u) {
            return u.replace(/,/g, "،");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 4010: function(L, h, b) {
        (function(A) {
          A.defineLocale("uz-latn", { months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"), monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"), weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"), weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"), weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Bugun soat] LT [da]", nextDay: "[Ertaga] LT [da]", nextWeek: "dddd [kuni soat] LT [da]", lastDay: "[Kecha soat] LT [da]", lastWeek: "[O'tgan] dddd [kuni soat] LT [da]", sameElse: "L" }, relativeTime: { future: "Yaqin %s ichida", past: "Bir necha %s oldin", s: "soniya", ss: "%d soniya", m: "bir daqiqa", mm: "%d daqiqa", h: "bir soat", hh: "%d soat", d: "bir kun", dd: "%d kun", M: "bir oy", MM: "%d oy", y: "bir yil", yy: "%d yil" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 9226: function(L, h, b) {
        (function(A) {
          A.defineLocale("uz", { months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"), monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"), weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"), weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"), weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "D MMMM YYYY, dddd HH:mm" }, calendar: { sameDay: "[Бугун соат] LT [да]", nextDay: "[Эртага] LT [да]", nextWeek: "dddd [куни соат] LT [да]", lastDay: "[Кеча соат] LT [да]", lastWeek: "[Утган] dddd [куни соат] LT [да]", sameElse: "L" }, relativeTime: { future: "Якин %s ичида", past: "Бир неча %s олдин", s: "фурсат", ss: "%d фурсат", m: "бир дакика", mm: "%d дакика", h: "бир соат", hh: "%d соат", d: "бир кун", dd: "%d кун", M: "бир ой", MM: "%d ой", y: "бир йил", yy: "%d йил" }, week: { dow: 1, doy: 7 } });
        })(b(7840));
      }, 3272: function(L, h, b) {
        (function(A) {
          A.defineLocale("vi", { months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"), monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"), monthsParseExact: !0, weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"), weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"), weekdaysParseExact: !0, meridiemParse: /sa|ch/i, isPM: function(l) {
            return /^ch$/i.test(l);
          }, meridiem: function(l, o, u) {
            return l < 12 ? u ? "sa" : "SA" : u ? "ch" : "CH";
          }, longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "D MMMM [năm] YYYY", LLL: "D MMMM [năm] YYYY HH:mm", LLLL: "dddd, D MMMM [năm] YYYY HH:mm", l: "DD/M/YYYY", ll: "D MMM YYYY", lll: "D MMM YYYY HH:mm", llll: "ddd, D MMM YYYY HH:mm" }, calendar: { sameDay: "[Hôm nay lúc] LT", nextDay: "[Ngày mai lúc] LT", nextWeek: "dddd [tuần tới lúc] LT", lastDay: "[Hôm qua lúc] LT", lastWeek: "dddd [tuần trước lúc] LT", sameElse: "L" }, relativeTime: { future: "%s tới", past: "%s trước", s: "vài giây", ss: "%d giây", m: "một phút", mm: "%d phút", h: "một giờ", hh: "%d giờ", d: "một ngày", dd: "%d ngày", w: "một tuần", ww: "%d tuần", M: "một tháng", MM: "%d tháng", y: "một năm", yy: "%d năm" }, dayOfMonthOrdinalParse: /\d{1,2}/, ordinal: function(l) {
            return l;
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 8780: function(L, h, b) {
        (function(A) {
          A.defineLocale("x-pseudo", { months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"), monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"), monthsParseExact: !0, weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"), weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"), weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"), weekdaysParseExact: !0, longDateFormat: { LT: "HH:mm", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY HH:mm", LLLL: "dddd, D MMMM YYYY HH:mm" }, calendar: { sameDay: "[T~ódá~ý át] LT", nextDay: "[T~ómó~rró~w át] LT", nextWeek: "dddd [át] LT", lastDay: "[Ý~ést~érdá~ý át] LT", lastWeek: "[L~ást] dddd [át] LT", sameElse: "L" }, relativeTime: { future: "í~ñ %s", past: "%s á~gó", s: "á ~féw ~sécó~ñds", ss: "%d s~écóñ~ds", m: "á ~míñ~úté", mm: "%d m~íñú~tés", h: "á~ñ hó~úr", hh: "%d h~óúrs", d: "á ~dáý", dd: "%d d~áýs", M: "á ~móñ~th", MM: "%d m~óñt~hs", y: "á ~ýéár", yy: "%d ý~éárs" }, dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(l) {
            var o = l % 10;
            return l + (~~(l % 100 / 10) == 1 ? "th" : o === 1 ? "st" : o === 2 ? "nd" : o === 3 ? "rd" : "th");
          }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6201: function(L, h, b) {
        (function(A) {
          A.defineLocale("yo", { months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"), monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"), weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"), weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"), weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"), longDateFormat: { LT: "h:mm A", LTS: "h:mm:ss A", L: "DD/MM/YYYY", LL: "D MMMM YYYY", LLL: "D MMMM YYYY h:mm A", LLLL: "dddd, D MMMM YYYY h:mm A" }, calendar: { sameDay: "[Ònì ni] LT", nextDay: "[Ọ̀la ni] LT", nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT", lastDay: "[Àna ni] LT", lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT", sameElse: "L" }, relativeTime: { future: "ní %s", past: "%s kọjá", s: "ìsẹjú aayá die", ss: "aayá %d", m: "ìsẹjú kan", mm: "ìsẹjú %d", h: "wákati kan", hh: "wákati %d", d: "ọjọ́ kan", dd: "ọjọ́ %d", M: "osù kan", MM: "osù %d", y: "ọdún kan", yy: "ọdún %d" }, dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/, ordinal: "ọjọ́ %d", week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6893: function(L, h, b) {
        (function(A) {
          A.defineLocale("zh-cn", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日Ah点mm分", LLLL: "YYYY年M月D日ddddAh点mm分", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "凌晨" || o === "早上" || o === "上午" ? l : o === "下午" || o === "晚上" ? l + 12 : l >= 11 ? l : l + 12;
          }, meridiem: function(l, o, u) {
            var g = 100 * l + o;
            return g < 600 ? "凌晨" : g < 900 ? "早上" : g < 1130 ? "上午" : g < 1230 ? "中午" : g < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: function(l) {
            return l.week() !== this.week() ? "[下]dddLT" : "[本]dddLT";
          }, lastDay: "[昨天]LT", lastWeek: function(l) {
            return this.week() !== l.week() ? "[上]dddLT" : "[本]dddLT";
          }, sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "日";
              case "M":
                return l + "月";
              case "w":
              case "W":
                return l + "周";
              default:
                return l;
            }
          }, relativeTime: { future: "%s后", past: "%s前", s: "几秒", ss: "%d 秒", m: "1 分钟", mm: "%d 分钟", h: "1 小时", hh: "%d 小时", d: "1 天", dd: "%d 天", w: "1 周", ww: "%d 周", M: "1 个月", MM: "%d 个月", y: "1 年", yy: "%d 年" }, week: { dow: 1, doy: 4 } });
        })(b(7840));
      }, 6977: function(L, h, b) {
        (function(A) {
          A.defineLocale("zh-hk", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "凌晨" || o === "早上" || o === "上午" ? l : o === "中午" ? l >= 11 ? l : l + 12 : o === "下午" || o === "晚上" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            var g = 100 * l + o;
            return g < 600 ? "凌晨" : g < 900 ? "早上" : g < 1200 ? "上午" : g === 1200 ? "中午" : g < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天]LT", nextDay: "[明天]LT", nextWeek: "[下]ddddLT", lastDay: "[昨天]LT", lastWeek: "[上]ddddLT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "日";
              case "M":
                return l + "月";
              case "w":
              case "W":
                return l + "週";
              default:
                return l;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(b(7840));
      }, 4068: function(L, h, b) {
        (function(A) {
          A.defineLocale("zh-mo", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "DD/MM/YYYY", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "D/M/YYYY", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "凌晨" || o === "早上" || o === "上午" ? l : o === "中午" ? l >= 11 ? l : l + 12 : o === "下午" || o === "晚上" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            var g = 100 * l + o;
            return g < 600 ? "凌晨" : g < 900 ? "早上" : g < 1130 ? "上午" : g < 1230 ? "中午" : g < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "日";
              case "M":
                return l + "月";
              case "w":
              case "W":
                return l + "週";
              default:
                return l;
            }
          }, relativeTime: { future: "%s內", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(b(7840));
      }, 217: function(L, h, b) {
        (function(A) {
          A.defineLocale("zh-tw", { months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"), monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"), weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"), weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"), weekdaysMin: "日_一_二_三_四_五_六".split("_"), longDateFormat: { LT: "HH:mm", LTS: "HH:mm:ss", L: "YYYY/MM/DD", LL: "YYYY年M月D日", LLL: "YYYY年M月D日 HH:mm", LLLL: "YYYY年M月D日dddd HH:mm", l: "YYYY/M/D", ll: "YYYY年M月D日", lll: "YYYY年M月D日 HH:mm", llll: "YYYY年M月D日dddd HH:mm" }, meridiemParse: /凌晨|早上|上午|中午|下午|晚上/, meridiemHour: function(l, o) {
            return l === 12 && (l = 0), o === "凌晨" || o === "早上" || o === "上午" ? l : o === "中午" ? l >= 11 ? l : l + 12 : o === "下午" || o === "晚上" ? l + 12 : void 0;
          }, meridiem: function(l, o, u) {
            var g = 100 * l + o;
            return g < 600 ? "凌晨" : g < 900 ? "早上" : g < 1130 ? "上午" : g < 1230 ? "中午" : g < 1800 ? "下午" : "晚上";
          }, calendar: { sameDay: "[今天] LT", nextDay: "[明天] LT", nextWeek: "[下]dddd LT", lastDay: "[昨天] LT", lastWeek: "[上]dddd LT", sameElse: "L" }, dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/, ordinal: function(l, o) {
            switch (o) {
              case "d":
              case "D":
              case "DDD":
                return l + "日";
              case "M":
                return l + "月";
              case "w":
              case "W":
                return l + "週";
              default:
                return l;
            }
          }, relativeTime: { future: "%s後", past: "%s前", s: "幾秒", ss: "%d 秒", m: "1 分鐘", mm: "%d 分鐘", h: "1 小時", hh: "%d 小時", d: "1 天", dd: "%d 天", M: "1 個月", MM: "%d 個月", y: "1 年", yy: "%d 年" } });
        })(b(7840));
      }, 7840: function(L, h, b) {
        (L = b.nmd(L)).exports = function() {
          var A, l;
          function o() {
            return A.apply(null, arguments);
          }
          function u(T) {
            return T instanceof Array || Object.prototype.toString.call(T) === "[object Array]";
          }
          function g(T) {
            return T != null && Object.prototype.toString.call(T) === "[object Object]";
          }
          function m(T, j) {
            return Object.prototype.hasOwnProperty.call(T, j);
          }
          function S(T) {
            if (Object.getOwnPropertyNames) return Object.getOwnPropertyNames(T).length === 0;
            var j;
            for (j in T) if (m(T, j)) return !1;
            return !0;
          }
          function e(T) {
            return T === void 0;
          }
          function n(T) {
            return typeof T == "number" || Object.prototype.toString.call(T) === "[object Number]";
          }
          function d(T) {
            return T instanceof Date || Object.prototype.toString.call(T) === "[object Date]";
          }
          function _(T, j) {
            var ut, wt = [], Ut = T.length;
            for (ut = 0; ut < Ut; ++ut) wt.push(j(T[ut], ut));
            return wt;
          }
          function p(T, j) {
            for (var ut in j) m(j, ut) && (T[ut] = j[ut]);
            return m(j, "toString") && (T.toString = j.toString), m(j, "valueOf") && (T.valueOf = j.valueOf), T;
          }
          function P(T, j, ut, wt) {
            return fr(T, j, ut, wt, !0).utc();
          }
          function $(T) {
            return T._pf == null && (T._pf = { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidEra: null, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1, parsedDateParts: [], era: null, meridiem: null, rfc2822: !1, weekdayMismatch: !1 }), T._pf;
          }
          function ot(T) {
            var j = null, ut = !1, wt = T._d && !isNaN(T._d.getTime());
            return wt && (j = $(T), ut = l.call(j.parsedDateParts, function(Ut) {
              return Ut != null;
            }), wt = j.overflow < 0 && !j.empty && !j.invalidEra && !j.invalidMonth && !j.invalidWeekday && !j.weekdayMismatch && !j.nullInput && !j.invalidFormat && !j.userInvalidated && (!j.meridiem || j.meridiem && ut), T._strict && (wt = wt && j.charsLeftOver === 0 && j.unusedTokens.length === 0 && j.bigHour === void 0)), Object.isFrozen != null && Object.isFrozen(T) ? wt : (T._isValid = wt, T._isValid);
          }
          function dt(T) {
            var j = P(NaN);
            return T != null ? p($(j), T) : $(j).userInvalidated = !0, j;
          }
          l = Array.prototype.some ? Array.prototype.some : function(T) {
            var j, ut = Object(this), wt = ut.length >>> 0;
            for (j = 0; j < wt; j++) if (j in ut && T.call(this, ut[j], j, ut)) return !0;
            return !1;
          };
          var xt = o.momentProperties = [], Nt = !1;
          function jt(T, j) {
            var ut, wt, Ut, oe = xt.length;
            if (e(j._isAMomentObject) || (T._isAMomentObject = j._isAMomentObject), e(j._i) || (T._i = j._i), e(j._f) || (T._f = j._f), e(j._l) || (T._l = j._l), e(j._strict) || (T._strict = j._strict), e(j._tzm) || (T._tzm = j._tzm), e(j._isUTC) || (T._isUTC = j._isUTC), e(j._offset) || (T._offset = j._offset), e(j._pf) || (T._pf = $(j)), e(j._locale) || (T._locale = j._locale), oe > 0) for (ut = 0; ut < oe; ut++) e(Ut = j[wt = xt[ut]]) || (T[wt] = Ut);
            return T;
          }
          function q(T) {
            jt(this, T), this._d = new Date(T._d != null ? T._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Nt === !1 && (Nt = !0, o.updateOffset(this), Nt = !1);
          }
          function I(T) {
            return T instanceof q || T != null && T._isAMomentObject != null;
          }
          function pt(T) {
            o.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + T);
          }
          function It(T, j) {
            var ut = !0;
            return p(function() {
              if (o.deprecationHandler != null && o.deprecationHandler(null, T), ut) {
                var wt, Ut, oe, _e = [], en = arguments.length;
                for (Ut = 0; Ut < en; Ut++) {
                  if (wt = "", typeof arguments[Ut] == "object") {
                    for (oe in wt += `
[` + Ut + "] ", arguments[0]) m(arguments[0], oe) && (wt += oe + ": " + arguments[0][oe] + ", ");
                    wt = wt.slice(0, -2);
                  } else wt = arguments[Ut];
                  _e.push(wt);
                }
                pt(T + `
Arguments: ` + Array.prototype.slice.call(_e).join("") + `
` + new Error().stack), ut = !1;
              }
              return j.apply(this, arguments);
            }, j);
          }
          var et, Dt = {};
          function ae(T, j) {
            o.deprecationHandler != null && o.deprecationHandler(T, j), Dt[T] || (pt(j), Dt[T] = !0);
          }
          function St(T) {
            return typeof Function < "u" && T instanceof Function || Object.prototype.toString.call(T) === "[object Function]";
          }
          function qe(T, j) {
            var ut, wt = p({}, T);
            for (ut in j) m(j, ut) && (g(T[ut]) && g(j[ut]) ? (wt[ut] = {}, p(wt[ut], T[ut]), p(wt[ut], j[ut])) : j[ut] != null ? wt[ut] = j[ut] : delete wt[ut]);
            for (ut in T) m(T, ut) && !m(j, ut) && g(T[ut]) && (wt[ut] = p({}, wt[ut]));
            return wt;
          }
          function zt(T) {
            T != null && this.set(T);
          }
          o.suppressDeprecationWarnings = !1, o.deprecationHandler = null, et = Object.keys ? Object.keys : function(T) {
            var j, ut = [];
            for (j in T) m(T, j) && ut.push(j);
            return ut;
          };
          function Ct(T, j, ut) {
            var wt = "" + Math.abs(T), Ut = j - wt.length;
            return (T >= 0 ? ut ? "+" : "" : "-") + Math.pow(10, Math.max(0, Ut)).toString().substr(1) + wt;
          }
          var de = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ze = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, le = {}, Ze = {};
          function me(T, j, ut, wt) {
            var Ut = wt;
            typeof wt == "string" && (Ut = function() {
              return this[wt]();
            }), T && (Ze[T] = Ut), j && (Ze[j[0]] = function() {
              return Ct(Ut.apply(this, arguments), j[1], j[2]);
            }), ut && (Ze[ut] = function() {
              return this.localeData().ordinal(Ut.apply(this, arguments), T);
            });
          }
          function bn(T, j) {
            return T.isValid() ? (j = pn(j, T.localeData()), le[j] = le[j] || function(ut) {
              var wt, Ut, oe, _e = ut.match(de);
              for (wt = 0, Ut = _e.length; wt < Ut; wt++) Ze[_e[wt]] ? _e[wt] = Ze[_e[wt]] : _e[wt] = (oe = _e[wt]).match(/\[[\s\S]/) ? oe.replace(/^\[|\]$/g, "") : oe.replace(/\\/g, "");
              return function(en) {
                var Ne, xn = "";
                for (Ne = 0; Ne < Ut; Ne++) xn += St(_e[Ne]) ? _e[Ne].call(en, ut) : _e[Ne];
                return xn;
              };
            }(j), le[j](T)) : T.localeData().invalidDate();
          }
          function pn(T, j) {
            var ut = 5;
            function wt(Ut) {
              return j.longDateFormat(Ut) || Ut;
            }
            for (ze.lastIndex = 0; ut >= 0 && ze.test(T); ) T = T.replace(ze, wt), ze.lastIndex = 0, ut -= 1;
            return T;
          }
          var wn = { D: "date", dates: "date", date: "date", d: "day", days: "day", day: "day", e: "weekday", weekdays: "weekday", weekday: "weekday", E: "isoWeekday", isoweekdays: "isoWeekday", isoweekday: "isoWeekday", DDD: "dayOfYear", dayofyears: "dayOfYear", dayofyear: "dayOfYear", h: "hour", hours: "hour", hour: "hour", ms: "millisecond", milliseconds: "millisecond", millisecond: "millisecond", m: "minute", minutes: "minute", minute: "minute", M: "month", months: "month", month: "month", Q: "quarter", quarters: "quarter", quarter: "quarter", s: "second", seconds: "second", second: "second", gg: "weekYear", weekyears: "weekYear", weekyear: "weekYear", GG: "isoWeekYear", isoweekyears: "isoWeekYear", isoweekyear: "isoWeekYear", w: "week", weeks: "week", week: "week", W: "isoWeek", isoweeks: "isoWeek", isoweek: "isoWeek", y: "year", years: "year", year: "year" };
          function Yt(T) {
            return typeof T == "string" ? wn[T] || wn[T.toLowerCase()] : void 0;
          }
          function Ht(T) {
            var j, ut, wt = {};
            for (ut in T) m(T, ut) && (j = Yt(ut)) && (wt[j] = T[ut]);
            return wt;
          }
          var Me = { date: 9, day: 11, weekday: 11, isoWeekday: 11, dayOfYear: 4, hour: 13, millisecond: 16, minute: 14, month: 8, quarter: 7, second: 15, weekYear: 1, isoWeekYear: 1, week: 5, isoWeek: 5, year: 1 }, X, Q = /\d/, C = /\d\d/, U = /\d{3}/, gt = /\d{4}/, rt = /[+-]?\d{6}/, Ft = /\d\d?/, ne = /\d\d\d\d?/, Vt = /\d\d\d\d\d\d?/, Xt = /\d{1,3}/, qt = /\d{1,4}/, Gt = /[+-]?\d{1,6}/, se = /\d+/, Jt = /[+-]?\d+/, he = /Z|[+-]\d\d:?\d\d/gi, an = /Z|[+-]\d\d(?::?\d\d)?/gi, Fe = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, ke = /^[1-9]\d?/, ce = /^([1-9]\d|\d)/;
          function je(T, j, ut) {
            X[T] = St(j) ? j : function(wt, Ut) {
              return wt && ut ? ut : j;
            };
          }
          function ii(T, j) {
            return m(X, T) ? X[T](j._strict, j._locale) : new RegExp(function(ut) {
              return Wn(ut.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(wt, Ut, oe, _e, en) {
                return Ut || oe || _e || en;
              }));
            }(T));
          }
          function Wn(T) {
            return T.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          }
          function Ai(T) {
            return T < 0 ? Math.ceil(T) || 0 : Math.floor(T);
          }
          function Gn(T) {
            var j = +T, ut = 0;
            return j !== 0 && isFinite(j) && (ut = Ai(j)), ut;
          }
          X = {};
          var Di = {};
          function Ae(T, j) {
            var ut, wt, Ut = j;
            for (typeof T == "string" && (T = [T]), n(j) && (Ut = function(oe, _e) {
              _e[j] = Gn(oe);
            }), wt = T.length, ut = 0; ut < wt; ut++) Di[T[ut]] = Ut;
          }
          function Ke(T, j) {
            Ae(T, function(ut, wt, Ut, oe) {
              Ut._w = Ut._w || {}, j(ut, Ut._w, Ut, oe);
            });
          }
          function Re(T, j, ut) {
            j != null && m(Di, T) && Di[T](j, ut._a, ut, T);
          }
          function pe(T) {
            return T % 4 == 0 && T % 100 != 0 || T % 400 == 0;
          }
          var Ce = 0, He = 1, Je = 2, tn = 3, xe = 4, Se = 5, $e = 6, kn = 7, Ge = 8;
          function En(T) {
            return pe(T) ? 366 : 365;
          }
          me("Y", 0, 0, function() {
            var T = this.year();
            return T <= 9999 ? Ct(T, 4) : "+" + T;
          }), me(0, ["YY", 2], 0, function() {
            return this.year() % 100;
          }), me(0, ["YYYY", 4], 0, "year"), me(0, ["YYYYY", 5], 0, "year"), me(0, ["YYYYYY", 6, !0], 0, "year"), je("Y", Jt), je("YY", Ft, C), je("YYYY", qt, gt), je("YYYYY", Gt, rt), je("YYYYYY", Gt, rt), Ae(["YYYYY", "YYYYYY"], Ce), Ae("YYYY", function(T, j) {
            j[Ce] = T.length === 2 ? o.parseTwoDigitYear(T) : Gn(T);
          }), Ae("YY", function(T, j) {
            j[Ce] = o.parseTwoDigitYear(T);
          }), Ae("Y", function(T, j) {
            j[Ce] = parseInt(T, 10);
          }), o.parseTwoDigitYear = function(T) {
            return Gn(T) + (Gn(T) > 68 ? 1900 : 2e3);
          };
          var An, Dn = In("FullYear", !0);
          function In(T, j) {
            return function(ut) {
              return ut != null ? (vn(this, T, ut), o.updateOffset(this, j), this) : Kn(this, T);
            };
          }
          function Kn(T, j) {
            if (!T.isValid()) return NaN;
            var ut = T._d, wt = T._isUTC;
            switch (j) {
              case "Milliseconds":
                return wt ? ut.getUTCMilliseconds() : ut.getMilliseconds();
              case "Seconds":
                return wt ? ut.getUTCSeconds() : ut.getSeconds();
              case "Minutes":
                return wt ? ut.getUTCMinutes() : ut.getMinutes();
              case "Hours":
                return wt ? ut.getUTCHours() : ut.getHours();
              case "Date":
                return wt ? ut.getUTCDate() : ut.getDate();
              case "Day":
                return wt ? ut.getUTCDay() : ut.getDay();
              case "Month":
                return wt ? ut.getUTCMonth() : ut.getMonth();
              case "FullYear":
                return wt ? ut.getUTCFullYear() : ut.getFullYear();
              default:
                return NaN;
            }
          }
          function vn(T, j, ut) {
            var wt, Ut, oe, _e, en;
            if (T.isValid() && !isNaN(ut)) {
              switch (wt = T._d, Ut = T._isUTC, j) {
                case "Milliseconds":
                  return void (Ut ? wt.setUTCMilliseconds(ut) : wt.setMilliseconds(ut));
                case "Seconds":
                  return void (Ut ? wt.setUTCSeconds(ut) : wt.setSeconds(ut));
                case "Minutes":
                  return void (Ut ? wt.setUTCMinutes(ut) : wt.setMinutes(ut));
                case "Hours":
                  return void (Ut ? wt.setUTCHours(ut) : wt.setHours(ut));
                case "Date":
                  return void (Ut ? wt.setUTCDate(ut) : wt.setDate(ut));
                case "FullYear":
                  break;
                default:
                  return;
              }
              oe = ut, _e = T.month(), en = (en = T.date()) !== 29 || _e !== 1 || pe(oe) ? en : 28, Ut ? wt.setUTCFullYear(oe, _e, en) : wt.setFullYear(oe, _e, en);
            }
          }
          function ve(T, j) {
            if (isNaN(T) || isNaN(j)) return NaN;
            var ut, wt = (j % (ut = 12) + ut) % ut;
            return T += (j - wt) / 12, wt === 1 ? pe(T) ? 29 : 28 : 31 - wt % 7 % 2;
          }
          An = Array.prototype.indexOf ? Array.prototype.indexOf : function(T) {
            var j;
            for (j = 0; j < this.length; ++j) if (this[j] === T) return j;
            return -1;
          }, me("M", ["MM", 2], "Mo", function() {
            return this.month() + 1;
          }), me("MMM", 0, 0, function(T) {
            return this.localeData().monthsShort(this, T);
          }), me("MMMM", 0, 0, function(T) {
            return this.localeData().months(this, T);
          }), je("M", Ft, ke), je("MM", Ft, C), je("MMM", function(T, j) {
            return j.monthsShortRegex(T);
          }), je("MMMM", function(T, j) {
            return j.monthsRegex(T);
          }), Ae(["M", "MM"], function(T, j) {
            j[He] = Gn(T) - 1;
          }), Ae(["MMM", "MMMM"], function(T, j, ut, wt) {
            var Ut = ut._locale.monthsParse(T, wt, ut._strict);
            Ut != null ? j[He] = Ut : $(ut).invalidMonth = T;
          });
          var ue = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Be = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), dn = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Yn = Fe, $n = Fe;
          function ui(T, j, ut) {
            var wt, Ut, oe, _e = T.toLocaleLowerCase();
            if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], wt = 0; wt < 12; ++wt) oe = P([2e3, wt]), this._shortMonthsParse[wt] = this.monthsShort(oe, "").toLocaleLowerCase(), this._longMonthsParse[wt] = this.months(oe, "").toLocaleLowerCase();
            return ut ? j === "MMM" ? (Ut = An.call(this._shortMonthsParse, _e)) !== -1 ? Ut : null : (Ut = An.call(this._longMonthsParse, _e)) !== -1 ? Ut : null : j === "MMM" ? (Ut = An.call(this._shortMonthsParse, _e)) !== -1 || (Ut = An.call(this._longMonthsParse, _e)) !== -1 ? Ut : null : (Ut = An.call(this._longMonthsParse, _e)) !== -1 || (Ut = An.call(this._shortMonthsParse, _e)) !== -1 ? Ut : null;
          }
          function Ii(T, j) {
            if (!T.isValid()) return T;
            if (typeof j == "string") {
              if (/^\d+$/.test(j)) j = Gn(j);
              else if (!n(j = T.localeData().monthsParse(j))) return T;
            }
            var ut = j, wt = T.date();
            return wt = wt < 29 ? wt : Math.min(wt, ve(T.year(), ut)), T._isUTC ? T._d.setUTCMonth(ut, wt) : T._d.setMonth(ut, wt), T;
          }
          function Ei(T) {
            return T != null ? (Ii(this, T), o.updateOffset(this, !0), this) : Kn(this, "Month");
          }
          function ai() {
            function T(Ne, xn) {
              return xn.length - Ne.length;
            }
            var j, ut, wt, Ut, oe = [], _e = [], en = [];
            for (j = 0; j < 12; j++) ut = P([2e3, j]), wt = Wn(this.monthsShort(ut, "")), Ut = Wn(this.months(ut, "")), oe.push(wt), _e.push(Ut), en.push(Ut), en.push(wt);
            oe.sort(T), _e.sort(T), en.sort(T), this._monthsRegex = new RegExp("^(" + en.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + _e.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + oe.join("|") + ")", "i");
          }
          function Mi(T, j, ut, wt, Ut, oe, _e) {
            var en;
            return T < 100 && T >= 0 ? (en = new Date(T + 400, j, ut, wt, Ut, oe, _e), isFinite(en.getFullYear()) && en.setFullYear(T)) : en = new Date(T, j, ut, wt, Ut, oe, _e), en;
          }
          function Oi(T) {
            var j, ut;
            return T < 100 && T >= 0 ? ((ut = Array.prototype.slice.call(arguments))[0] = T + 400, j = new Date(Date.UTC.apply(null, ut)), isFinite(j.getUTCFullYear()) && j.setUTCFullYear(T)) : j = new Date(Date.UTC.apply(null, arguments)), j;
          }
          function Bi(T, j, ut) {
            var wt = 7 + j - ut;
            return -(7 + Oi(T, 0, wt).getUTCDay() - j) % 7 + wt - 1;
          }
          function dr(T, j, ut, wt, Ut) {
            var oe, _e, en = 1 + 7 * (j - 1) + (7 + ut - wt) % 7 + Bi(T, wt, Ut);
            return en <= 0 ? _e = En(oe = T - 1) + en : en > En(T) ? (oe = T + 1, _e = en - En(T)) : (oe = T, _e = en), { year: oe, dayOfYear: _e };
          }
          function Ri(T, j, ut) {
            var wt, Ut, oe = Bi(T.year(), j, ut), _e = Math.floor((T.dayOfYear() - oe - 1) / 7) + 1;
            return _e < 1 ? wt = _e + Ci(Ut = T.year() - 1, j, ut) : _e > Ci(T.year(), j, ut) ? (wt = _e - Ci(T.year(), j, ut), Ut = T.year() + 1) : (Ut = T.year(), wt = _e), { week: wt, year: Ut };
          }
          function Ci(T, j, ut) {
            var wt = Bi(T, j, ut), Ut = Bi(T + 1, j, ut);
            return (En(T) - wt + Ut) / 7;
          }
          me("w", ["ww", 2], "wo", "week"), me("W", ["WW", 2], "Wo", "isoWeek"), je("w", Ft, ke), je("ww", Ft, C), je("W", Ft, ke), je("WW", Ft, C), Ke(["w", "ww", "W", "WW"], function(T, j, ut, wt) {
            j[wt.substr(0, 1)] = Gn(T);
          });
          function $i(T, j) {
            return T.slice(j, 7).concat(T.slice(0, j));
          }
          me("d", 0, "do", "day"), me("dd", 0, 0, function(T) {
            return this.localeData().weekdaysMin(this, T);
          }), me("ddd", 0, 0, function(T) {
            return this.localeData().weekdaysShort(this, T);
          }), me("dddd", 0, 0, function(T) {
            return this.localeData().weekdays(this, T);
          }), me("e", 0, 0, "weekday"), me("E", 0, 0, "isoWeekday"), je("d", Ft), je("e", Ft), je("E", Ft), je("dd", function(T, j) {
            return j.weekdaysMinRegex(T);
          }), je("ddd", function(T, j) {
            return j.weekdaysShortRegex(T);
          }), je("dddd", function(T, j) {
            return j.weekdaysRegex(T);
          }), Ke(["dd", "ddd", "dddd"], function(T, j, ut, wt) {
            var Ut = ut._locale.weekdaysParse(T, wt, ut._strict);
            Ut != null ? j.d = Ut : $(ut).invalidWeekday = T;
          }), Ke(["d", "e", "E"], function(T, j, ut, wt) {
            j[wt] = Gn(T);
          });
          var qr = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), ji = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), va = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ta = Fe, ia = Fe, wa = Fe;
          function Xe(T, j, ut) {
            var wt, Ut, oe, _e = T.toLocaleLowerCase();
            if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], wt = 0; wt < 7; ++wt) oe = P([2e3, 1]).day(wt), this._minWeekdaysParse[wt] = this.weekdaysMin(oe, "").toLocaleLowerCase(), this._shortWeekdaysParse[wt] = this.weekdaysShort(oe, "").toLocaleLowerCase(), this._weekdaysParse[wt] = this.weekdays(oe, "").toLocaleLowerCase();
            return ut ? j === "dddd" ? (Ut = An.call(this._weekdaysParse, _e)) !== -1 ? Ut : null : j === "ddd" ? (Ut = An.call(this._shortWeekdaysParse, _e)) !== -1 ? Ut : null : (Ut = An.call(this._minWeekdaysParse, _e)) !== -1 ? Ut : null : j === "dddd" ? (Ut = An.call(this._weekdaysParse, _e)) !== -1 || (Ut = An.call(this._shortWeekdaysParse, _e)) !== -1 || (Ut = An.call(this._minWeekdaysParse, _e)) !== -1 ? Ut : null : j === "ddd" ? (Ut = An.call(this._shortWeekdaysParse, _e)) !== -1 || (Ut = An.call(this._weekdaysParse, _e)) !== -1 || (Ut = An.call(this._minWeekdaysParse, _e)) !== -1 ? Ut : null : (Ut = An.call(this._minWeekdaysParse, _e)) !== -1 || (Ut = An.call(this._weekdaysParse, _e)) !== -1 || (Ut = An.call(this._shortWeekdaysParse, _e)) !== -1 ? Ut : null;
          }
          function fn() {
            function T(ti, ni) {
              return ni.length - ti.length;
            }
            var j, ut, wt, Ut, oe, _e = [], en = [], Ne = [], xn = [];
            for (j = 0; j < 7; j++) ut = P([2e3, 1]).day(j), wt = Wn(this.weekdaysMin(ut, "")), Ut = Wn(this.weekdaysShort(ut, "")), oe = Wn(this.weekdays(ut, "")), _e.push(wt), en.push(Ut), Ne.push(oe), xn.push(wt), xn.push(Ut), xn.push(oe);
            _e.sort(T), en.sort(T), Ne.sort(T), xn.sort(T), this._weekdaysRegex = new RegExp("^(" + xn.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + Ne.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + en.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + _e.join("|") + ")", "i");
          }
          function Fn() {
            return this.hours() % 12 || 12;
          }
          function Xn(T, j) {
            me(T, 0, 0, function() {
              return this.localeData().meridiem(this.hours(), this.minutes(), j);
            });
          }
          function di(T, j) {
            return j._meridiemParse;
          }
          me("H", ["HH", 2], 0, "hour"), me("h", ["hh", 2], 0, Fn), me("k", ["kk", 2], 0, function() {
            return this.hours() || 24;
          }), me("hmm", 0, 0, function() {
            return "" + Fn.apply(this) + Ct(this.minutes(), 2);
          }), me("hmmss", 0, 0, function() {
            return "" + Fn.apply(this) + Ct(this.minutes(), 2) + Ct(this.seconds(), 2);
          }), me("Hmm", 0, 0, function() {
            return "" + this.hours() + Ct(this.minutes(), 2);
          }), me("Hmmss", 0, 0, function() {
            return "" + this.hours() + Ct(this.minutes(), 2) + Ct(this.seconds(), 2);
          }), Xn("a", !0), Xn("A", !1), je("a", di), je("A", di), je("H", Ft, ce), je("h", Ft, ke), je("k", Ft, ke), je("HH", Ft, C), je("hh", Ft, C), je("kk", Ft, C), je("hmm", ne), je("hmmss", Vt), je("Hmm", ne), je("Hmmss", Vt), Ae(["H", "HH"], tn), Ae(["k", "kk"], function(T, j, ut) {
            var wt = Gn(T);
            j[tn] = wt === 24 ? 0 : wt;
          }), Ae(["a", "A"], function(T, j, ut) {
            ut._isPm = ut._locale.isPM(T), ut._meridiem = T;
          }), Ae(["h", "hh"], function(T, j, ut) {
            j[tn] = Gn(T), $(ut).bigHour = !0;
          }), Ae("hmm", function(T, j, ut) {
            var wt = T.length - 2;
            j[tn] = Gn(T.substr(0, wt)), j[xe] = Gn(T.substr(wt)), $(ut).bigHour = !0;
          }), Ae("hmmss", function(T, j, ut) {
            var wt = T.length - 4, Ut = T.length - 2;
            j[tn] = Gn(T.substr(0, wt)), j[xe] = Gn(T.substr(wt, 2)), j[Se] = Gn(T.substr(Ut)), $(ut).bigHour = !0;
          }), Ae("Hmm", function(T, j, ut) {
            var wt = T.length - 2;
            j[tn] = Gn(T.substr(0, wt)), j[xe] = Gn(T.substr(wt));
          }), Ae("Hmmss", function(T, j, ut) {
            var wt = T.length - 4, Ut = T.length - 2;
            j[tn] = Gn(T.substr(0, wt)), j[xe] = Gn(T.substr(wt, 2)), j[Se] = Gn(T.substr(Ut));
          });
          var xi = In("Hours", !0), oi, Zn = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: ue, monthsShort: Be, week: { dow: 0, doy: 6 }, weekdays: qr, weekdaysMin: va, weekdaysShort: ji, meridiemParse: /[ap]\.?m?\.?/i }, zn = {}, Qn = {};
          function mi(T, j) {
            var ut, wt = Math.min(T.length, j.length);
            for (ut = 0; ut < wt; ut += 1) if (T[ut] !== j[ut]) return ut;
            return wt;
          }
          function cr(T) {
            return T && T.toLowerCase().replace("_", "-");
          }
          function Yi(T) {
            var j = null;
            if (zn[T] === void 0 && L && L.exports && function(ut) {
              return !(!ut || !ut.match("^[^/\\\\]*$"));
            }(T)) try {
              j = oi._abbr, b(5358)("./" + T), Hi(j);
            } catch {
              zn[T] = null;
            }
            return zn[T];
          }
          function Hi(T, j) {
            var ut;
            return T && ((ut = e(j) ? qi(T) : Zi(T, j)) ? oi = ut : typeof console < "u" && console.warn && console.warn("Locale " + T + " not found. Did you forget to load it?")), oi._abbr;
          }
          function Zi(T, j) {
            if (j !== null) {
              var ut, wt = Zn;
              if (j.abbr = T, zn[T] != null) ae("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), wt = zn[T]._config;
              else if (j.parentLocale != null) if (zn[j.parentLocale] != null) wt = zn[j.parentLocale]._config;
              else {
                if ((ut = Yi(j.parentLocale)) == null) return Qn[j.parentLocale] || (Qn[j.parentLocale] = []), Qn[j.parentLocale].push({ name: T, config: j }), null;
                wt = ut._config;
              }
              return zn[T] = new zt(qe(wt, j)), Qn[T] && Qn[T].forEach(function(Ut) {
                Zi(Ut.name, Ut.config);
              }), Hi(T), zn[T];
            }
            return delete zn[T], null;
          }
          function qi(T) {
            var j;
            if (T && T._locale && T._locale._abbr && (T = T._locale._abbr), !T) return oi;
            if (!u(T)) {
              if (j = Yi(T)) return j;
              T = [T];
            }
            return function(ut) {
              for (var wt, Ut, oe, _e, en = 0; en < ut.length; ) {
                for (wt = (_e = cr(ut[en]).split("-")).length, Ut = (Ut = cr(ut[en + 1])) ? Ut.split("-") : null; wt > 0; ) {
                  if (oe = Yi(_e.slice(0, wt).join("-"))) return oe;
                  if (Ut && Ut.length >= wt && mi(_e, Ut) >= wt - 1) break;
                  wt--;
                }
                en++;
              }
              return oi;
            }(T);
          }
          function Fi(T) {
            var j, ut = T._a;
            return ut && $(T).overflow === -2 && (j = ut[He] < 0 || ut[He] > 11 ? He : ut[Je] < 1 || ut[Je] > ve(ut[Ce], ut[He]) ? Je : ut[tn] < 0 || ut[tn] > 24 || ut[tn] === 24 && (ut[xe] !== 0 || ut[Se] !== 0 || ut[$e] !== 0) ? tn : ut[xe] < 0 || ut[xe] > 59 ? xe : ut[Se] < 0 || ut[Se] > 59 ? Se : ut[$e] < 0 || ut[$e] > 999 ? $e : -1, $(T)._overflowDayOfYear && (j < Ce || j > Je) && (j = Je), $(T)._overflowWeeks && j === -1 && (j = kn), $(T)._overflowWeekday && j === -1 && (j = Ge), $(T).overflow = j), T;
          }
          var ra = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Gr = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, ss = /Z|[+-]\d\d(?::?\d\d)?/, sr = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]], Vi = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], Dr = /^\/?Date\((-?\d+)/i, Fa = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, tr = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
          function aa(T) {
            var j, ut, wt, Ut, oe, _e, en = T._i, Ne = ra.exec(en) || Gr.exec(en), xn = sr.length, ti = Vi.length;
            if (Ne) {
              for ($(T).iso = !0, j = 0, ut = xn; j < ut; j++) if (sr[j][1].exec(Ne[1])) {
                Ut = sr[j][0], wt = sr[j][2] !== !1;
                break;
              }
              if (Ut == null) return void (T._isValid = !1);
              if (Ne[3]) {
                for (j = 0, ut = ti; j < ut; j++) if (Vi[j][1].exec(Ne[3])) {
                  oe = (Ne[2] || " ") + Vi[j][0];
                  break;
                }
                if (oe == null) return void (T._isValid = !1);
              }
              if (!wt && oe != null) return void (T._isValid = !1);
              if (Ne[4]) {
                if (!ss.exec(Ne[4])) return void (T._isValid = !1);
                _e = "Z";
              }
              T._f = Ut + (oe || "") + (_e || ""), hr(T);
            } else T._isValid = !1;
          }
          function Aa(T) {
            var j = parseInt(T, 10);
            return j <= 49 ? 2e3 + j : j <= 999 ? 1900 + j : j;
          }
          function Ir(T) {
            var j, ut, wt, Ut, oe, _e, en, Ne, xn = Fa.exec(function(ti) {
              return ti.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
            }(T._i));
            if (xn) {
              if (ut = xn[4], wt = xn[3], Ut = xn[2], oe = xn[5], _e = xn[6], en = xn[7], Ne = [Aa(ut), Be.indexOf(wt), parseInt(Ut, 10), parseInt(oe, 10), parseInt(_e, 10)], en && Ne.push(parseInt(en, 10)), j = Ne, !function(ti, ni, yi) {
                return !ti || ji.indexOf(ti) === new Date(ni[0], ni[1], ni[2]).getDay() || ($(yi).weekdayMismatch = !0, yi._isValid = !1, !1);
              }(xn[1], j, T)) return;
              T._a = j, T._tzm = function(ti, ni, yi) {
                if (ti) return tr[ti];
                if (ni) return 0;
                var Ni = parseInt(yi, 10), Wi = Ni % 100;
                return (Ni - Wi) / 100 * 60 + Wi;
              }(xn[8], xn[9], xn[10]), T._d = Oi.apply(null, T._a), T._d.setUTCMinutes(T._d.getUTCMinutes() - T._tzm), $(T).rfc2822 = !0;
            } else T._isValid = !1;
          }
          function or(T, j, ut) {
            return T ?? j ?? ut;
          }
          function hi(T) {
            var j, ut, wt, Ut, oe, _e = [];
            if (!T._d) {
              for (wt = function(en) {
                var Ne = new Date(o.now());
                return en._useUTC ? [Ne.getUTCFullYear(), Ne.getUTCMonth(), Ne.getUTCDate()] : [Ne.getFullYear(), Ne.getMonth(), Ne.getDate()];
              }(T), T._w && T._a[Je] == null && T._a[He] == null && function(en) {
                var Ne, xn, ti, ni, yi, Ni, Wi, Pr, pr;
                (Ne = en._w).GG != null || Ne.W != null || Ne.E != null ? (yi = 1, Ni = 4, xn = or(Ne.GG, en._a[Ce], Ri(vi(), 1, 4).year), ti = or(Ne.W, 1), ((ni = or(Ne.E, 1)) < 1 || ni > 7) && (Pr = !0)) : (yi = en._locale._week.dow, Ni = en._locale._week.doy, pr = Ri(vi(), yi, Ni), xn = or(Ne.gg, en._a[Ce], pr.year), ti = or(Ne.w, pr.week), Ne.d != null ? ((ni = Ne.d) < 0 || ni > 6) && (Pr = !0) : Ne.e != null ? (ni = Ne.e + yi, (Ne.e < 0 || Ne.e > 6) && (Pr = !0)) : ni = yi), ti < 1 || ti > Ci(xn, yi, Ni) ? $(en)._overflowWeeks = !0 : Pr != null ? $(en)._overflowWeekday = !0 : (Wi = dr(xn, ti, ni, yi, Ni), en._a[Ce] = Wi.year, en._dayOfYear = Wi.dayOfYear);
              }(T), T._dayOfYear != null && (oe = or(T._a[Ce], wt[Ce]), (T._dayOfYear > En(oe) || T._dayOfYear === 0) && ($(T)._overflowDayOfYear = !0), ut = Oi(oe, 0, T._dayOfYear), T._a[He] = ut.getUTCMonth(), T._a[Je] = ut.getUTCDate()), j = 0; j < 3 && T._a[j] == null; ++j) T._a[j] = _e[j] = wt[j];
              for (; j < 7; j++) T._a[j] = _e[j] = T._a[j] == null ? j === 2 ? 1 : 0 : T._a[j];
              T._a[tn] === 24 && T._a[xe] === 0 && T._a[Se] === 0 && T._a[$e] === 0 && (T._nextDay = !0, T._a[tn] = 0), T._d = (T._useUTC ? Oi : Mi).apply(null, _e), Ut = T._useUTC ? T._d.getUTCDay() : T._d.getDay(), T._tzm != null && T._d.setUTCMinutes(T._d.getUTCMinutes() - T._tzm), T._nextDay && (T._a[tn] = 24), T._w && T._w.d !== void 0 && T._w.d !== Ut && ($(T).weekdayMismatch = !0);
            }
          }
          function hr(T) {
            if (T._f !== o.ISO_8601) if (T._f !== o.RFC_2822) {
              T._a = [], $(T).empty = !0;
              var j, ut, wt, Ut, oe, _e, en, Ne = "" + T._i, xn = Ne.length, ti = 0;
              for (en = (wt = pn(T._f, T._locale).match(de) || []).length, j = 0; j < en; j++) Ut = wt[j], (ut = (Ne.match(ii(Ut, T)) || [])[0]) && ((oe = Ne.substr(0, Ne.indexOf(ut))).length > 0 && $(T).unusedInput.push(oe), Ne = Ne.slice(Ne.indexOf(ut) + ut.length), ti += ut.length), Ze[Ut] ? (ut ? $(T).empty = !1 : $(T).unusedTokens.push(Ut), Re(Ut, ut, T)) : T._strict && !ut && $(T).unusedTokens.push(Ut);
              $(T).charsLeftOver = xn - ti, Ne.length > 0 && $(T).unusedInput.push(Ne), T._a[tn] <= 12 && $(T).bigHour === !0 && T._a[tn] > 0 && ($(T).bigHour = void 0), $(T).parsedDateParts = T._a.slice(0), $(T).meridiem = T._meridiem, T._a[tn] = function(ni, yi, Ni) {
                var Wi;
                return Ni == null ? yi : ni.meridiemHour != null ? ni.meridiemHour(yi, Ni) : (ni.isPM != null && ((Wi = ni.isPM(Ni)) && yi < 12 && (yi += 12), Wi || yi !== 12 || (yi = 0)), yi);
              }(T._locale, T._a[tn], T._meridiem), (_e = $(T).era) !== null && (T._a[Ce] = T._locale.erasConvertYear(_e, T._a[Ce])), hi(T), Fi(T);
            } else Ir(T);
            else aa(T);
          }
          function vr(T) {
            var j = T._i, ut = T._f;
            return T._locale = T._locale || qi(T._l), j === null || ut === void 0 && j === "" ? dt({ nullInput: !0 }) : (typeof j == "string" && (T._i = j = T._locale.preparse(j)), I(j) ? new q(Fi(j)) : (d(j) ? T._d = j : u(ut) ? function(wt) {
              var Ut, oe, _e, en, Ne, xn, ti = !1, ni = wt._f.length;
              if (ni === 0) return $(wt).invalidFormat = !0, void (wt._d = /* @__PURE__ */ new Date(NaN));
              for (en = 0; en < ni; en++) Ne = 0, xn = !1, Ut = jt({}, wt), wt._useUTC != null && (Ut._useUTC = wt._useUTC), Ut._f = wt._f[en], hr(Ut), ot(Ut) && (xn = !0), Ne += $(Ut).charsLeftOver, Ne += 10 * $(Ut).unusedTokens.length, $(Ut).score = Ne, ti ? Ne < _e && (_e = Ne, oe = Ut) : (_e == null || Ne < _e || xn) && (_e = Ne, oe = Ut, xn && (ti = !0));
              p(wt, oe || Ut);
            }(T) : ut ? hr(T) : function(wt) {
              var Ut = wt._i;
              e(Ut) ? wt._d = new Date(o.now()) : d(Ut) ? wt._d = new Date(Ut.valueOf()) : typeof Ut == "string" ? function(oe) {
                var _e = Dr.exec(oe._i);
                _e === null ? (aa(oe), oe._isValid === !1 && (delete oe._isValid, Ir(oe), oe._isValid === !1 && (delete oe._isValid, oe._strict ? oe._isValid = !1 : o.createFromInputFallback(oe)))) : oe._d = /* @__PURE__ */ new Date(+_e[1]);
              }(wt) : u(Ut) ? (wt._a = _(Ut.slice(0), function(oe) {
                return parseInt(oe, 10);
              }), hi(wt)) : g(Ut) ? function(oe) {
                if (!oe._d) {
                  var _e = Ht(oe._i), en = _e.day === void 0 ? _e.date : _e.day;
                  oe._a = _([_e.year, _e.month, en, _e.hour, _e.minute, _e.second, _e.millisecond], function(Ne) {
                    return Ne && parseInt(Ne, 10);
                  }), hi(oe);
                }
              }(wt) : n(Ut) ? wt._d = new Date(Ut) : o.createFromInputFallback(wt);
            }(T), ot(T) || (T._d = null), T));
          }
          function fr(T, j, ut, wt, Ut) {
            var oe, _e = {};
            return j !== !0 && j !== !1 || (wt = j, j = void 0), ut !== !0 && ut !== !1 || (wt = ut, ut = void 0), (g(T) && S(T) || u(T) && T.length === 0) && (T = void 0), _e._isAMomentObject = !0, _e._useUTC = _e._isUTC = Ut, _e._l = ut, _e._i = T, _e._f = j, _e._strict = wt, (oe = new q(Fi(vr(_e))))._nextDay && (oe.add(1, "d"), oe._nextDay = void 0), oe;
          }
          function vi(T, j, ut, wt) {
            return fr(T, j, ut, wt, !1);
          }
          o.createFromInputFallback = It("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(T) {
            T._d = /* @__PURE__ */ new Date(T._i + (T._useUTC ? " UTC" : ""));
          }), o.ISO_8601 = function() {
          }, o.RFC_2822 = function() {
          };
          var Xi = It("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
            var T = vi.apply(null, arguments);
            return this.isValid() && T.isValid() ? T < this ? this : T : dt();
          }), Rr = It("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
            var T = vi.apply(null, arguments);
            return this.isValid() && T.isValid() ? T > this ? this : T : dt();
          });
          function Qi(T, j) {
            var ut, wt;
            if (j.length === 1 && u(j[0]) && (j = j[0]), !j.length) return vi();
            for (ut = j[0], wt = 1; wt < j.length; ++wt) j[wt].isValid() && !j[wt][T](ut) || (ut = j[wt]);
            return ut;
          }
          var Tr = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
          function Sa(T) {
            var j = Ht(T), ut = j.year || 0, wt = j.quarter || 0, Ut = j.month || 0, oe = j.week || j.isoWeek || 0, _e = j.day || 0, en = j.hour || 0, Ne = j.minute || 0, xn = j.second || 0, ti = j.millisecond || 0;
            this._isValid = function(ni) {
              var yi, Ni, Wi = !1, Pr = Tr.length;
              for (yi in ni) if (m(ni, yi) && (An.call(Tr, yi) === -1 || ni[yi] != null && isNaN(ni[yi]))) return !1;
              for (Ni = 0; Ni < Pr; ++Ni) if (ni[Tr[Ni]]) {
                if (Wi) return !1;
                parseFloat(ni[Tr[Ni]]) !== Gn(ni[Tr[Ni]]) && (Wi = !0);
              }
              return !0;
            }(j), this._milliseconds = +ti + 1e3 * xn + 6e4 * Ne + 1e3 * en * 60 * 60, this._days = +_e + 7 * oe, this._months = +Ut + 3 * wt + 12 * ut, this._data = {}, this._locale = qi(), this._bubble();
          }
          function mr(T) {
            return T instanceof Sa;
          }
          function sa(T) {
            return T < 0 ? -1 * Math.round(-1 * T) : Math.round(T);
          }
          function Ua(T, j) {
            me(T, 0, 0, function() {
              var ut = this.utcOffset(), wt = "+";
              return ut < 0 && (ut = -ut, wt = "-"), wt + Ct(~~(ut / 60), 2) + j + Ct(~~ut % 60, 2);
            });
          }
          Ua("Z", ":"), Ua("ZZ", ""), je("Z", an), je("ZZ", an), Ae(["Z", "ZZ"], function(T, j, ut) {
            ut._useUTC = !0, ut._tzm = Vr(an, T);
          });
          var oa = /([\+\-]|\d\d)/gi;
          function Vr(T, j) {
            var ut, wt, Ut = (j || "").match(T);
            return Ut === null ? null : (wt = 60 * (ut = ((Ut[Ut.length - 1] || []) + "").match(oa) || ["-", 0, 0])[1] + Gn(ut[2])) === 0 ? 0 : ut[0] === "+" ? wt : -wt;
          }
          function la(T, j) {
            var ut, wt;
            return j._isUTC ? (ut = j.clone(), wt = (I(T) || d(T) ? T.valueOf() : vi(T).valueOf()) - ut.valueOf(), ut._d.setTime(ut._d.valueOf() + wt), o.updateOffset(ut, !1), ut) : vi(T).local();
          }
          function Cr(T) {
            return -Math.round(T._d.getTimezoneOffset());
          }
          function Ma() {
            return !!this.isValid() && this._isUTC && this._offset === 0;
          }
          o.updateOffset = function() {
          };
          var Zs = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, ys = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
          function lr(T, j) {
            var ut, wt, Ut, oe, _e, en, Ne = T, xn = null;
            return mr(T) ? Ne = { ms: T._milliseconds, d: T._days, M: T._months } : n(T) || !isNaN(+T) ? (Ne = {}, j ? Ne[j] = +T : Ne.milliseconds = +T) : (xn = Zs.exec(T)) ? (ut = xn[1] === "-" ? -1 : 1, Ne = { y: 0, d: Gn(xn[Je]) * ut, h: Gn(xn[tn]) * ut, m: Gn(xn[xe]) * ut, s: Gn(xn[Se]) * ut, ms: Gn(sa(1e3 * xn[$e])) * ut }) : (xn = ys.exec(T)) ? (ut = xn[1] === "-" ? -1 : 1, Ne = { y: kt(xn[2], ut), M: kt(xn[3], ut), w: kt(xn[4], ut), d: kt(xn[5], ut), h: kt(xn[6], ut), m: kt(xn[7], ut), s: kt(xn[8], ut) }) : Ne == null ? Ne = {} : typeof Ne == "object" && ("from" in Ne || "to" in Ne) && (oe = vi(Ne.from), _e = vi(Ne.to), Ut = oe.isValid() && _e.isValid() ? (_e = la(_e, oe), oe.isBefore(_e) ? en = Kt(oe, _e) : ((en = Kt(_e, oe)).milliseconds = -en.milliseconds, en.months = -en.months), en) : { milliseconds: 0, months: 0 }, (Ne = {}).ms = Ut.milliseconds, Ne.M = Ut.months), wt = new Sa(Ne), mr(T) && m(T, "_locale") && (wt._locale = T._locale), mr(T) && m(T, "_isValid") && (wt._isValid = T._isValid), wt;
          }
          function kt(T, j) {
            var ut = T && parseFloat(T.replace(",", "."));
            return (isNaN(ut) ? 0 : ut) * j;
          }
          function Kt(T, j) {
            var ut = {};
            return ut.months = j.month() - T.month() + 12 * (j.year() - T.year()), T.clone().add(ut.months, "M").isAfter(j) && --ut.months, ut.milliseconds = +j - +T.clone().add(ut.months, "M"), ut;
          }
          function we(T, j) {
            return function(ut, wt) {
              var Ut;
              return wt === null || isNaN(+wt) || (ae(j, "moment()." + j + "(period, number) is deprecated. Please use moment()." + j + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), Ut = ut, ut = wt, wt = Ut), Oe(this, lr(ut, wt), T), this;
            };
          }
          function Oe(T, j, ut, wt) {
            var Ut = j._milliseconds, oe = sa(j._days), _e = sa(j._months);
            T.isValid() && (wt = wt == null || wt, _e && Ii(T, Kn(T, "Month") + _e * ut), oe && vn(T, "Date", Kn(T, "Date") + oe * ut), Ut && T._d.setTime(T._d.valueOf() + Ut * ut), wt && o.updateOffset(T, oe || _e));
          }
          lr.fn = Sa.prototype, lr.invalid = function() {
            return lr(NaN);
          };
          var yn = we(1, "add"), Hn = we(-1, "subtract");
          function Pn(T) {
            return typeof T == "string" || T instanceof String;
          }
          function Vn(T) {
            return I(T) || d(T) || Pn(T) || n(T) || function(j) {
              var ut = u(j), wt = !1;
              return ut && (wt = j.filter(function(Ut) {
                return !n(Ut) && Pn(j);
              }).length === 0), ut && wt;
            }(T) || function(j) {
              var ut, wt, Ut = g(j) && !S(j), oe = !1, _e = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], en = _e.length;
              for (ut = 0; ut < en; ut += 1) wt = _e[ut], oe = oe || m(j, wt);
              return Ut && oe;
            }(T) || T == null;
          }
          function ri(T, j) {
            if (T.date() < j.date()) return -ri(j, T);
            var ut = 12 * (j.year() - T.year()) + (j.month() - T.month()), wt = T.clone().add(ut, "months");
            return -(ut + (j - wt < 0 ? (j - wt) / (wt - T.clone().add(ut - 1, "months")) : (j - wt) / (T.clone().add(ut + 1, "months") - wt))) || 0;
          }
          function pi(T) {
            var j;
            return T === void 0 ? this._locale._abbr : ((j = qi(T)) != null && (this._locale = j), this);
          }
          o.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", o.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
          var Bn = It("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(T) {
            return T === void 0 ? this.localeData() : this.locale(T);
          });
          function Ti() {
            return this._locale;
          }
          var ei = 1e3, Si = 6e4, Pi = 36e5, ua = 126227808e5;
          function wr(T, j) {
            return (T % j + j) % j;
          }
          function ja(T, j, ut) {
            return T < 100 && T >= 0 ? new Date(T + 400, j, ut) - ua : new Date(T, j, ut).valueOf();
          }
          function os(T, j, ut) {
            return T < 100 && T >= 0 ? Date.UTC(T + 400, j, ut) - ua : Date.UTC(T, j, ut);
          }
          function da(T, j) {
            return j.erasAbbrRegex(T);
          }
          function Ba() {
            var T, j, ut, wt, Ut, oe = [], _e = [], en = [], Ne = [], xn = this.eras();
            for (T = 0, j = xn.length; T < j; ++T) ut = Wn(xn[T].name), wt = Wn(xn[T].abbr), Ut = Wn(xn[T].narrow), _e.push(ut), oe.push(wt), en.push(Ut), Ne.push(ut), Ne.push(wt), Ne.push(Ut);
            this._erasRegex = new RegExp("^(" + Ne.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + _e.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + oe.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + en.join("|") + ")", "i");
          }
          function ca(T, j) {
            me(0, [T, T.length], 0, j);
          }
          function bs(T, j, ut, wt, Ut) {
            var oe;
            return T == null ? Ri(this, wt, Ut).year : (j > (oe = Ci(T, wt, Ut)) && (j = oe), Fl.call(this, T, j, ut, wt, Ut));
          }
          function Fl(T, j, ut, wt, Ut) {
            var oe = dr(T, j, ut, wt, Ut), _e = Oi(oe.year, 0, oe.dayOfYear);
            return this.year(_e.getUTCFullYear()), this.month(_e.getUTCMonth()), this.date(_e.getUTCDate()), this;
          }
          me("N", 0, 0, "eraAbbr"), me("NN", 0, 0, "eraAbbr"), me("NNN", 0, 0, "eraAbbr"), me("NNNN", 0, 0, "eraName"), me("NNNNN", 0, 0, "eraNarrow"), me("y", ["y", 1], "yo", "eraYear"), me("y", ["yy", 2], 0, "eraYear"), me("y", ["yyy", 3], 0, "eraYear"), me("y", ["yyyy", 4], 0, "eraYear"), je("N", da), je("NN", da), je("NNN", da), je("NNNN", function(T, j) {
            return j.erasNameRegex(T);
          }), je("NNNNN", function(T, j) {
            return j.erasNarrowRegex(T);
          }), Ae(["N", "NN", "NNN", "NNNN", "NNNNN"], function(T, j, ut, wt) {
            var Ut = ut._locale.erasParse(T, wt, ut._strict);
            Ut ? $(ut).era = Ut : $(ut).invalidEra = T;
          }), je("y", se), je("yy", se), je("yyy", se), je("yyyy", se), je("yo", function(T, j) {
            return j._eraYearOrdinalRegex || se;
          }), Ae(["y", "yy", "yyy", "yyyy"], Ce), Ae(["yo"], function(T, j, ut, wt) {
            var Ut;
            ut._locale._eraYearOrdinalRegex && (Ut = T.match(ut._locale._eraYearOrdinalRegex)), ut._locale.eraYearOrdinalParse ? j[Ce] = ut._locale.eraYearOrdinalParse(T, Ut) : j[Ce] = parseInt(T, 10);
          }), me(0, ["gg", 2], 0, function() {
            return this.weekYear() % 100;
          }), me(0, ["GG", 2], 0, function() {
            return this.isoWeekYear() % 100;
          }), ca("gggg", "weekYear"), ca("ggggg", "weekYear"), ca("GGGG", "isoWeekYear"), ca("GGGGG", "isoWeekYear"), je("G", Jt), je("g", Jt), je("GG", Ft, C), je("gg", Ft, C), je("GGGG", qt, gt), je("gggg", qt, gt), je("GGGGG", Gt, rt), je("ggggg", Gt, rt), Ke(["gggg", "ggggg", "GGGG", "GGGGG"], function(T, j, ut, wt) {
            j[wt.substr(0, 2)] = Gn(T);
          }), Ke(["gg", "GG"], function(T, j, ut, wt) {
            j[wt] = o.parseTwoDigitYear(T);
          }), me("Q", 0, "Qo", "quarter"), je("Q", Q), Ae("Q", function(T, j) {
            j[He] = 3 * (Gn(T) - 1);
          }), me("D", ["DD", 2], "Do", "date"), je("D", Ft, ke), je("DD", Ft, C), je("Do", function(T, j) {
            return T ? j._dayOfMonthOrdinalParse || j._ordinalParse : j._dayOfMonthOrdinalParseLenient;
          }), Ae(["D", "DD"], Je), Ae("Do", function(T, j) {
            j[Je] = Gn(T.match(Ft)[0]);
          });
          var Io = In("Date", !0);
          me("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), je("DDD", Xt), je("DDDD", U), Ae(["DDD", "DDDD"], function(T, j, ut) {
            ut._dayOfYear = Gn(T);
          }), me("m", ["mm", 2], 0, "minute"), je("m", Ft, ce), je("mm", Ft, C), Ae(["m", "mm"], xe);
          var to = In("Minutes", !1);
          me("s", ["ss", 2], 0, "second"), je("s", Ft, ce), je("ss", Ft, C), Ae(["s", "ss"], Se);
          var ha, eo, Ro = In("Seconds", !1);
          for (me("S", 0, 0, function() {
            return ~~(this.millisecond() / 100);
          }), me(0, ["SS", 2], 0, function() {
            return ~~(this.millisecond() / 10);
          }), me(0, ["SSS", 3], 0, "millisecond"), me(0, ["SSSS", 4], 0, function() {
            return 10 * this.millisecond();
          }), me(0, ["SSSSS", 5], 0, function() {
            return 100 * this.millisecond();
          }), me(0, ["SSSSSS", 6], 0, function() {
            return 1e3 * this.millisecond();
          }), me(0, ["SSSSSSS", 7], 0, function() {
            return 1e4 * this.millisecond();
          }), me(0, ["SSSSSSSS", 8], 0, function() {
            return 1e5 * this.millisecond();
          }), me(0, ["SSSSSSSSS", 9], 0, function() {
            return 1e6 * this.millisecond();
          }), je("S", Xt, Q), je("SS", Xt, C), je("SSS", Xt, U), ha = "SSSS"; ha.length <= 9; ha += "S") je(ha, se);
          function Co(T, j) {
            j[$e] = Gn(1e3 * ("0." + T));
          }
          for (ha = "S"; ha.length <= 9; ha += "S") Ae(ha, Co);
          eo = In("Milliseconds", !1), me("z", 0, 0, "zoneAbbr"), me("zz", 0, 0, "zoneName");
          var mn = q.prototype;
          function No(T) {
            return T;
          }
          mn.add = yn, mn.calendar = function(T, j) {
            arguments.length === 1 && (arguments[0] ? Vn(arguments[0]) ? (T = arguments[0], j = void 0) : function(_e) {
              var en, Ne = g(_e) && !S(_e), xn = !1, ti = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
              for (en = 0; en < ti.length; en += 1) xn = xn || m(_e, ti[en]);
              return Ne && xn;
            }(arguments[0]) && (j = arguments[0], T = void 0) : (T = void 0, j = void 0));
            var ut = T || vi(), wt = la(ut, this).startOf("day"), Ut = o.calendarFormat(this, wt) || "sameElse", oe = j && (St(j[Ut]) ? j[Ut].call(this, ut) : j[Ut]);
            return this.format(oe || this.localeData().calendar(Ut, this, vi(ut)));
          }, mn.clone = function() {
            return new q(this);
          }, mn.diff = function(T, j, ut) {
            var wt, Ut, oe;
            if (!this.isValid()) return NaN;
            if (!(wt = la(T, this)).isValid()) return NaN;
            switch (Ut = 6e4 * (wt.utcOffset() - this.utcOffset()), j = Yt(j)) {
              case "year":
                oe = ri(this, wt) / 12;
                break;
              case "month":
                oe = ri(this, wt);
                break;
              case "quarter":
                oe = ri(this, wt) / 3;
                break;
              case "second":
                oe = (this - wt) / 1e3;
                break;
              case "minute":
                oe = (this - wt) / 6e4;
                break;
              case "hour":
                oe = (this - wt) / 36e5;
                break;
              case "day":
                oe = (this - wt - Ut) / 864e5;
                break;
              case "week":
                oe = (this - wt - Ut) / 6048e5;
                break;
              default:
                oe = this - wt;
            }
            return ut ? oe : Ai(oe);
          }, mn.endOf = function(T) {
            var j, ut;
            if ((T = Yt(T)) === void 0 || T === "millisecond" || !this.isValid()) return this;
            switch (ut = this._isUTC ? os : ja, T) {
              case "year":
                j = ut(this.year() + 1, 0, 1) - 1;
                break;
              case "quarter":
                j = ut(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
              case "month":
                j = ut(this.year(), this.month() + 1, 1) - 1;
                break;
              case "week":
                j = ut(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
              case "isoWeek":
                j = ut(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
              case "day":
              case "date":
                j = ut(this.year(), this.month(), this.date() + 1) - 1;
                break;
              case "hour":
                j = this._d.valueOf(), j += Pi - wr(j + (this._isUTC ? 0 : this.utcOffset() * Si), Pi) - 1;
                break;
              case "minute":
                j = this._d.valueOf(), j += Si - wr(j, Si) - 1;
                break;
              case "second":
                j = this._d.valueOf(), j += ei - wr(j, ei) - 1;
            }
            return this._d.setTime(j), o.updateOffset(this, !0), this;
          }, mn.format = function(T) {
            T || (T = this.isUtc() ? o.defaultFormatUtc : o.defaultFormat);
            var j = bn(this, T);
            return this.localeData().postformat(j);
          }, mn.from = function(T, j) {
            return this.isValid() && (I(T) && T.isValid() || vi(T).isValid()) ? lr({ to: this, from: T }).locale(this.locale()).humanize(!j) : this.localeData().invalidDate();
          }, mn.fromNow = function(T) {
            return this.from(vi(), T);
          }, mn.to = function(T, j) {
            return this.isValid() && (I(T) && T.isValid() || vi(T).isValid()) ? lr({ from: this, to: T }).locale(this.locale()).humanize(!j) : this.localeData().invalidDate();
          }, mn.toNow = function(T) {
            return this.to(vi(), T);
          }, mn.get = function(T) {
            return St(this[T = Yt(T)]) ? this[T]() : this;
          }, mn.invalidAt = function() {
            return $(this).overflow;
          }, mn.isAfter = function(T, j) {
            var ut = I(T) ? T : vi(T);
            return !(!this.isValid() || !ut.isValid()) && ((j = Yt(j) || "millisecond") === "millisecond" ? this.valueOf() > ut.valueOf() : ut.valueOf() < this.clone().startOf(j).valueOf());
          }, mn.isBefore = function(T, j) {
            var ut = I(T) ? T : vi(T);
            return !(!this.isValid() || !ut.isValid()) && ((j = Yt(j) || "millisecond") === "millisecond" ? this.valueOf() < ut.valueOf() : this.clone().endOf(j).valueOf() < ut.valueOf());
          }, mn.isBetween = function(T, j, ut, wt) {
            var Ut = I(T) ? T : vi(T), oe = I(j) ? j : vi(j);
            return !!(this.isValid() && Ut.isValid() && oe.isValid()) && ((wt = wt || "()")[0] === "(" ? this.isAfter(Ut, ut) : !this.isBefore(Ut, ut)) && (wt[1] === ")" ? this.isBefore(oe, ut) : !this.isAfter(oe, ut));
          }, mn.isSame = function(T, j) {
            var ut, wt = I(T) ? T : vi(T);
            return !(!this.isValid() || !wt.isValid()) && ((j = Yt(j) || "millisecond") === "millisecond" ? this.valueOf() === wt.valueOf() : (ut = wt.valueOf(), this.clone().startOf(j).valueOf() <= ut && ut <= this.clone().endOf(j).valueOf()));
          }, mn.isSameOrAfter = function(T, j) {
            return this.isSame(T, j) || this.isAfter(T, j);
          }, mn.isSameOrBefore = function(T, j) {
            return this.isSame(T, j) || this.isBefore(T, j);
          }, mn.isValid = function() {
            return ot(this);
          }, mn.lang = Bn, mn.locale = pi, mn.localeData = Ti, mn.max = Rr, mn.min = Xi, mn.parsingFlags = function() {
            return p({}, $(this));
          }, mn.set = function(T, j) {
            if (typeof T == "object") {
              var ut, wt = function(oe) {
                var _e, en = [];
                for (_e in oe) m(oe, _e) && en.push({ unit: _e, priority: Me[_e] });
                return en.sort(function(Ne, xn) {
                  return Ne.priority - xn.priority;
                }), en;
              }(T = Ht(T)), Ut = wt.length;
              for (ut = 0; ut < Ut; ut++) this[wt[ut].unit](T[wt[ut].unit]);
            } else if (St(this[T = Yt(T)])) return this[T](j);
            return this;
          }, mn.startOf = function(T) {
            var j, ut;
            if ((T = Yt(T)) === void 0 || T === "millisecond" || !this.isValid()) return this;
            switch (ut = this._isUTC ? os : ja, T) {
              case "year":
                j = ut(this.year(), 0, 1);
                break;
              case "quarter":
                j = ut(this.year(), this.month() - this.month() % 3, 1);
                break;
              case "month":
                j = ut(this.year(), this.month(), 1);
                break;
              case "week":
                j = ut(this.year(), this.month(), this.date() - this.weekday());
                break;
              case "isoWeek":
                j = ut(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
              case "day":
              case "date":
                j = ut(this.year(), this.month(), this.date());
                break;
              case "hour":
                j = this._d.valueOf(), j -= wr(j + (this._isUTC ? 0 : this.utcOffset() * Si), Pi);
                break;
              case "minute":
                j = this._d.valueOf(), j -= wr(j, Si);
                break;
              case "second":
                j = this._d.valueOf(), j -= wr(j, ei);
            }
            return this._d.setTime(j), o.updateOffset(this, !0), this;
          }, mn.subtract = Hn, mn.toArray = function() {
            var T = this;
            return [T.year(), T.month(), T.date(), T.hour(), T.minute(), T.second(), T.millisecond()];
          }, mn.toObject = function() {
            var T = this;
            return { years: T.year(), months: T.month(), date: T.date(), hours: T.hours(), minutes: T.minutes(), seconds: T.seconds(), milliseconds: T.milliseconds() };
          }, mn.toDate = function() {
            return new Date(this.valueOf());
          }, mn.toISOString = function(T) {
            if (!this.isValid()) return null;
            var j = T !== !0, ut = j ? this.clone().utc() : this;
            return ut.year() < 0 || ut.year() > 9999 ? bn(ut, j ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : St(Date.prototype.toISOString) ? j ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", bn(ut, "Z")) : bn(ut, j ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
          }, mn.inspect = function() {
            if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
            var T, j, ut, wt = "moment", Ut = "";
            return this.isLocal() || (wt = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", Ut = "Z"), T = "[" + wt + '("]', j = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", ut = Ut + '[")]', this.format(T + j + "-MM-DD[T]HH:mm:ss.SSS" + ut);
          }, typeof Symbol < "u" && Symbol.for != null && (mn[Symbol.for("nodejs.util.inspect.custom")] = function() {
            return "Moment<" + this.format() + ">";
          }), mn.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, mn.toString = function() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
          }, mn.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, mn.valueOf = function() {
            return this._d.valueOf() - 6e4 * (this._offset || 0);
          }, mn.creationData = function() {
            return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
          }, mn.eraName = function() {
            var T, j, ut, wt = this.localeData().eras();
            for (T = 0, j = wt.length; T < j; ++T)
              if (ut = this.clone().startOf("day").valueOf(), wt[T].since <= ut && ut <= wt[T].until || wt[T].until <= ut && ut <= wt[T].since) return wt[T].name;
            return "";
          }, mn.eraNarrow = function() {
            var T, j, ut, wt = this.localeData().eras();
            for (T = 0, j = wt.length; T < j; ++T)
              if (ut = this.clone().startOf("day").valueOf(), wt[T].since <= ut && ut <= wt[T].until || wt[T].until <= ut && ut <= wt[T].since) return wt[T].narrow;
            return "";
          }, mn.eraAbbr = function() {
            var T, j, ut, wt = this.localeData().eras();
            for (T = 0, j = wt.length; T < j; ++T)
              if (ut = this.clone().startOf("day").valueOf(), wt[T].since <= ut && ut <= wt[T].until || wt[T].until <= ut && ut <= wt[T].since) return wt[T].abbr;
            return "";
          }, mn.eraYear = function() {
            var T, j, ut, wt, Ut = this.localeData().eras();
            for (T = 0, j = Ut.length; T < j; ++T) if (ut = Ut[T].since <= Ut[T].until ? 1 : -1, wt = this.clone().startOf("day").valueOf(), Ut[T].since <= wt && wt <= Ut[T].until || Ut[T].until <= wt && wt <= Ut[T].since) return (this.year() - o(Ut[T].since).year()) * ut + Ut[T].offset;
            return this.year();
          }, mn.year = Dn, mn.isLeapYear = function() {
            return pe(this.year());
          }, mn.weekYear = function(T) {
            return bs.call(this, T, this.week(), this.weekday() + this.localeData()._week.dow, this.localeData()._week.dow, this.localeData()._week.doy);
          }, mn.isoWeekYear = function(T) {
            return bs.call(this, T, this.isoWeek(), this.isoWeekday(), 1, 4);
          }, mn.quarter = mn.quarters = function(T) {
            return T == null ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (T - 1) + this.month() % 3);
          }, mn.month = Ei, mn.daysInMonth = function() {
            return ve(this.year(), this.month());
          }, mn.week = mn.weeks = function(T) {
            var j = this.localeData().week(this);
            return T == null ? j : this.add(7 * (T - j), "d");
          }, mn.isoWeek = mn.isoWeeks = function(T) {
            var j = Ri(this, 1, 4).week;
            return T == null ? j : this.add(7 * (T - j), "d");
          }, mn.weeksInYear = function() {
            var T = this.localeData()._week;
            return Ci(this.year(), T.dow, T.doy);
          }, mn.weeksInWeekYear = function() {
            var T = this.localeData()._week;
            return Ci(this.weekYear(), T.dow, T.doy);
          }, mn.isoWeeksInYear = function() {
            return Ci(this.year(), 1, 4);
          }, mn.isoWeeksInISOWeekYear = function() {
            return Ci(this.isoWeekYear(), 1, 4);
          }, mn.date = Io, mn.day = mn.days = function(T) {
            if (!this.isValid()) return T != null ? this : NaN;
            var j = Kn(this, "Day");
            return T != null ? (T = function(ut, wt) {
              return typeof ut != "string" ? ut : isNaN(ut) ? typeof (ut = wt.weekdaysParse(ut)) == "number" ? ut : null : parseInt(ut, 10);
            }(T, this.localeData()), this.add(T - j, "d")) : j;
          }, mn.weekday = function(T) {
            if (!this.isValid()) return T != null ? this : NaN;
            var j = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return T == null ? j : this.add(T - j, "d");
          }, mn.isoWeekday = function(T) {
            if (!this.isValid()) return T != null ? this : NaN;
            if (T != null) {
              var j = function(ut, wt) {
                return typeof ut == "string" ? wt.weekdaysParse(ut) % 7 || 7 : isNaN(ut) ? null : ut;
              }(T, this.localeData());
              return this.day(this.day() % 7 ? j : j - 7);
            }
            return this.day() || 7;
          }, mn.dayOfYear = function(T) {
            var j = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return T == null ? j : this.add(T - j, "d");
          }, mn.hour = mn.hours = xi, mn.minute = mn.minutes = to, mn.second = mn.seconds = Ro, mn.millisecond = mn.milliseconds = eo, mn.utcOffset = function(T, j, ut) {
            var wt, Ut = this._offset || 0;
            if (!this.isValid()) return T != null ? this : NaN;
            if (T != null) {
              if (typeof T == "string") {
                if ((T = Vr(an, T)) === null) return this;
              } else Math.abs(T) < 16 && !ut && (T *= 60);
              return !this._isUTC && j && (wt = Cr(this)), this._offset = T, this._isUTC = !0, wt != null && this.add(wt, "m"), Ut !== T && (!j || this._changeInProgress ? Oe(this, lr(T - Ut, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, o.updateOffset(this, !0), this._changeInProgress = null)), this;
            }
            return this._isUTC ? Ut : Cr(this);
          }, mn.utc = function(T) {
            return this.utcOffset(0, T);
          }, mn.local = function(T) {
            return this._isUTC && (this.utcOffset(0, T), this._isUTC = !1, T && this.subtract(Cr(this), "m")), this;
          }, mn.parseZone = function() {
            if (this._tzm != null) this.utcOffset(this._tzm, !1, !0);
            else if (typeof this._i == "string") {
              var T = Vr(he, this._i);
              T != null ? this.utcOffset(T) : this.utcOffset(0, !0);
            }
            return this;
          }, mn.hasAlignedHourOffset = function(T) {
            return !!this.isValid() && (T = T ? vi(T).utcOffset() : 0, (this.utcOffset() - T) % 60 == 0);
          }, mn.isDST = function() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
          }, mn.isLocal = function() {
            return !!this.isValid() && !this._isUTC;
          }, mn.isUtcOffset = function() {
            return !!this.isValid() && this._isUTC;
          }, mn.isUtc = Ma, mn.isUTC = Ma, mn.zoneAbbr = function() {
            return this._isUTC ? "UTC" : "";
          }, mn.zoneName = function() {
            return this._isUTC ? "Coordinated Universal Time" : "";
          }, mn.dates = It("dates accessor is deprecated. Use date instead.", Io), mn.months = It("months accessor is deprecated. Use month instead", Ei), mn.years = It("years accessor is deprecated. Use year instead", Dn), mn.zone = It("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(T, j) {
            return T != null ? (typeof T != "string" && (T = -T), this.utcOffset(T, j), this) : -this.utcOffset();
          }), mn.isDSTShifted = It("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
            if (!e(this._isDSTShifted)) return this._isDSTShifted;
            var T, j = {};
            return jt(j, this), (j = vr(j))._a ? (T = j._isUTC ? P(j._a) : vi(j._a), this._isDSTShifted = this.isValid() && function(ut, wt, Ut) {
              var oe, _e = Math.min(ut.length, wt.length), en = Math.abs(ut.length - wt.length), Ne = 0;
              for (oe = 0; oe < _e; oe++) Gn(ut[oe]) !== Gn(wt[oe]) && Ne++;
              return Ne + en;
            }(j._a, T.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
          });
          var gi = zt.prototype;
          function ls(T, j, ut, wt) {
            var Ut = qi(), oe = P().set(wt, j);
            return Ut[ut](oe, T);
          }
          function no(T, j, ut) {
            if (n(T) && (j = T, T = void 0), T = T || "", j != null) return ls(T, j, ut, "month");
            var wt, Ut = [];
            for (wt = 0; wt < 12; wt++) Ut[wt] = ls(T, wt, ut, "month");
            return Ut;
          }
          function Es(T, j, ut, wt) {
            typeof T == "boolean" ? (n(j) && (ut = j, j = void 0), j = j || "") : (ut = j = T, T = !1, n(j) && (ut = j, j = void 0), j = j || "");
            var Ut, oe = qi(), _e = T ? oe._week.dow : 0, en = [];
            if (ut != null) return ls(j, (ut + _e) % 7, wt, "day");
            for (Ut = 0; Ut < 7; Ut++) en[Ut] = ls(j, (Ut + _e) % 7, wt, "day");
            return en;
          }
          gi.calendar = function(T, j, ut) {
            var wt = this._calendar[T] || this._calendar.sameElse;
            return St(wt) ? wt.call(j, ut) : wt;
          }, gi.longDateFormat = function(T) {
            var j = this._longDateFormat[T], ut = this._longDateFormat[T.toUpperCase()];
            return j || !ut ? j : (this._longDateFormat[T] = ut.match(de).map(function(wt) {
              return wt === "MMMM" || wt === "MM" || wt === "DD" || wt === "dddd" ? wt.slice(1) : wt;
            }).join(""), this._longDateFormat[T]);
          }, gi.invalidDate = function() {
            return this._invalidDate;
          }, gi.ordinal = function(T) {
            return this._ordinal.replace("%d", T);
          }, gi.preparse = No, gi.postformat = No, gi.relativeTime = function(T, j, ut, wt) {
            var Ut = this._relativeTime[ut];
            return St(Ut) ? Ut(T, j, ut, wt) : Ut.replace(/%d/i, T);
          }, gi.pastFuture = function(T, j) {
            var ut = this._relativeTime[T > 0 ? "future" : "past"];
            return St(ut) ? ut(j) : ut.replace(/%s/i, j);
          }, gi.set = function(T) {
            var j, ut;
            for (ut in T) m(T, ut) && (St(j = T[ut]) ? this[ut] = j : this["_" + ut] = j);
            this._config = T, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
          }, gi.eras = function(T, j) {
            var ut, wt, Ut, oe = this._eras || qi("en")._eras;
            for (ut = 0, wt = oe.length; ut < wt; ++ut) switch (typeof oe[ut].since == "string" && (Ut = o(oe[ut].since).startOf("day"), oe[ut].since = Ut.valueOf()), typeof oe[ut].until) {
              case "undefined":
                oe[ut].until = 1 / 0;
                break;
              case "string":
                Ut = o(oe[ut].until).startOf("day").valueOf(), oe[ut].until = Ut.valueOf();
            }
            return oe;
          }, gi.erasParse = function(T, j, ut) {
            var wt, Ut, oe, _e, en, Ne = this.eras();
            for (T = T.toUpperCase(), wt = 0, Ut = Ne.length; wt < Ut; ++wt) if (oe = Ne[wt].name.toUpperCase(), _e = Ne[wt].abbr.toUpperCase(), en = Ne[wt].narrow.toUpperCase(), ut) switch (j) {
              case "N":
              case "NN":
              case "NNN":
                if (_e === T) return Ne[wt];
                break;
              case "NNNN":
                if (oe === T) return Ne[wt];
                break;
              case "NNNNN":
                if (en === T) return Ne[wt];
            }
            else if ([oe, _e, en].indexOf(T) >= 0) return Ne[wt];
          }, gi.erasConvertYear = function(T, j) {
            var ut = T.since <= T.until ? 1 : -1;
            return j === void 0 ? o(T.since).year() : o(T.since).year() + (j - T.offset) * ut;
          }, gi.erasAbbrRegex = function(T) {
            return m(this, "_erasAbbrRegex") || Ba.call(this), T ? this._erasAbbrRegex : this._erasRegex;
          }, gi.erasNameRegex = function(T) {
            return m(this, "_erasNameRegex") || Ba.call(this), T ? this._erasNameRegex : this._erasRegex;
          }, gi.erasNarrowRegex = function(T) {
            return m(this, "_erasNarrowRegex") || Ba.call(this), T ? this._erasNarrowRegex : this._erasRegex;
          }, gi.months = function(T, j) {
            return T ? u(this._months) ? this._months[T.month()] : this._months[(this._months.isFormat || dn).test(j) ? "format" : "standalone"][T.month()] : u(this._months) ? this._months : this._months.standalone;
          }, gi.monthsShort = function(T, j) {
            return T ? u(this._monthsShort) ? this._monthsShort[T.month()] : this._monthsShort[dn.test(j) ? "format" : "standalone"][T.month()] : u(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
          }, gi.monthsParse = function(T, j, ut) {
            var wt, Ut, oe;
            if (this._monthsParseExact) return ui.call(this, T, j, ut);
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), wt = 0; wt < 12; wt++)
              if (Ut = P([2e3, wt]), ut && !this._longMonthsParse[wt] && (this._longMonthsParse[wt] = new RegExp("^" + this.months(Ut, "").replace(".", "") + "$", "i"), this._shortMonthsParse[wt] = new RegExp("^" + this.monthsShort(Ut, "").replace(".", "") + "$", "i")), ut || this._monthsParse[wt] || (oe = "^" + this.months(Ut, "") + "|^" + this.monthsShort(Ut, ""), this._monthsParse[wt] = new RegExp(oe.replace(".", ""), "i")), ut && j === "MMMM" && this._longMonthsParse[wt].test(T) || ut && j === "MMM" && this._shortMonthsParse[wt].test(T) || !ut && this._monthsParse[wt].test(T)) return wt;
          }, gi.monthsRegex = function(T) {
            return this._monthsParseExact ? (m(this, "_monthsRegex") || ai.call(this), T ? this._monthsStrictRegex : this._monthsRegex) : (m(this, "_monthsRegex") || (this._monthsRegex = $n), this._monthsStrictRegex && T ? this._monthsStrictRegex : this._monthsRegex);
          }, gi.monthsShortRegex = function(T) {
            return this._monthsParseExact ? (m(this, "_monthsRegex") || ai.call(this), T ? this._monthsShortStrictRegex : this._monthsShortRegex) : (m(this, "_monthsShortRegex") || (this._monthsShortRegex = Yn), this._monthsShortStrictRegex && T ? this._monthsShortStrictRegex : this._monthsShortRegex);
          }, gi.week = function(T) {
            return Ri(T, this._week.dow, this._week.doy).week;
          }, gi.firstDayOfYear = function() {
            return this._week.doy;
          }, gi.firstDayOfWeek = function() {
            return this._week.dow;
          }, gi.weekdays = function(T, j) {
            var ut = u(this._weekdays) ? this._weekdays : this._weekdays[T && T !== !0 && this._weekdays.isFormat.test(j) ? "format" : "standalone"];
            return T === !0 ? $i(ut, this._week.dow) : T ? ut[T.day()] : ut;
          }, gi.weekdaysMin = function(T) {
            return T === !0 ? $i(this._weekdaysMin, this._week.dow) : T ? this._weekdaysMin[T.day()] : this._weekdaysMin;
          }, gi.weekdaysShort = function(T) {
            return T === !0 ? $i(this._weekdaysShort, this._week.dow) : T ? this._weekdaysShort[T.day()] : this._weekdaysShort;
          }, gi.weekdaysParse = function(T, j, ut) {
            var wt, Ut, oe;
            if (this._weekdaysParseExact) return Xe.call(this, T, j, ut);
            for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), wt = 0; wt < 7; wt++)
              if (Ut = P([2e3, 1]).day(wt), ut && !this._fullWeekdaysParse[wt] && (this._fullWeekdaysParse[wt] = new RegExp("^" + this.weekdays(Ut, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[wt] = new RegExp("^" + this.weekdaysShort(Ut, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[wt] = new RegExp("^" + this.weekdaysMin(Ut, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[wt] || (oe = "^" + this.weekdays(Ut, "") + "|^" + this.weekdaysShort(Ut, "") + "|^" + this.weekdaysMin(Ut, ""), this._weekdaysParse[wt] = new RegExp(oe.replace(".", ""), "i")), ut && j === "dddd" && this._fullWeekdaysParse[wt].test(T) || ut && j === "ddd" && this._shortWeekdaysParse[wt].test(T) || ut && j === "dd" && this._minWeekdaysParse[wt].test(T) || !ut && this._weekdaysParse[wt].test(T)) return wt;
          }, gi.weekdaysRegex = function(T) {
            return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || fn.call(this), T ? this._weekdaysStrictRegex : this._weekdaysRegex) : (m(this, "_weekdaysRegex") || (this._weekdaysRegex = Ta), this._weekdaysStrictRegex && T ? this._weekdaysStrictRegex : this._weekdaysRegex);
          }, gi.weekdaysShortRegex = function(T) {
            return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || fn.call(this), T ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (m(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ia), this._weekdaysShortStrictRegex && T ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
          }, gi.weekdaysMinRegex = function(T) {
            return this._weekdaysParseExact ? (m(this, "_weekdaysRegex") || fn.call(this), T ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (m(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = wa), this._weekdaysMinStrictRegex && T ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
          }, gi.isPM = function(T) {
            return (T + "").toLowerCase().charAt(0) === "p";
          }, gi.meridiem = function(T, j, ut) {
            return T > 11 ? ut ? "pm" : "PM" : ut ? "am" : "AM";
          }, Hi("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(T) {
            var j = T % 10;
            return T + (Gn(T % 100 / 10) === 1 ? "th" : j === 1 ? "st" : j === 2 ? "nd" : j === 3 ? "rd" : "th");
          } }), o.lang = It("moment.lang is deprecated. Use moment.locale instead.", Hi), o.langData = It("moment.langData is deprecated. Use moment.localeData instead.", qi);
          var Wr = Math.abs;
          function Po(T, j, ut, wt) {
            var Ut = lr(j, ut);
            return T._milliseconds += wt * Ut._milliseconds, T._days += wt * Ut._days, T._months += wt * Ut._months, T._bubble();
          }
          function io(T) {
            return T < 0 ? Math.floor(T) : Math.ceil(T);
          }
          function zo(T) {
            return 4800 * T / 146097;
          }
          function vs(T) {
            return 146097 * T / 4800;
          }
          function Nr(T) {
            return function() {
              return this.as(T);
            };
          }
          var ro = Nr("ms"), Ha = Nr("s"), Ul = Nr("m"), Oo = Nr("h"), jl = Nr("d"), Yo = Nr("w"), Bl = Nr("M"), Hl = Nr("Q"), ql = Nr("y"), ao = ro;
          function ka(T) {
            return function() {
              return this.isValid() ? this._data[T] : NaN;
            };
          }
          var Fo = ka("milliseconds"), Gl = ka("seconds"), us = ka("minutes"), so = ka("hours"), Uo = ka("days"), Ts = ka("months"), jo = ka("years"), Kr = Math.round, xa = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
          function Vl(T, j, ut, wt, Ut) {
            return Ut.relativeTime(j || 1, !!ut, T, wt);
          }
          var ws = Math.abs;
          function fa(T) {
            return (T > 0) - (T < 0) || +T;
          }
          function As() {
            if (!this.isValid()) return this.localeData().invalidDate();
            var T, j, ut, wt, Ut, oe, _e, en, Ne = ws(this._milliseconds) / 1e3, xn = ws(this._days), ti = ws(this._months), ni = this.asSeconds();
            return ni ? (T = Ai(Ne / 60), j = Ai(T / 60), Ne %= 60, T %= 60, ut = Ai(ti / 12), ti %= 12, wt = Ne ? Ne.toFixed(3).replace(/\.?0+$/, "") : "", Ut = ni < 0 ? "-" : "", oe = fa(this._months) !== fa(ni) ? "-" : "", _e = fa(this._days) !== fa(ni) ? "-" : "", en = fa(this._milliseconds) !== fa(ni) ? "-" : "", Ut + "P" + (ut ? oe + ut + "Y" : "") + (ti ? oe + ti + "M" : "") + (xn ? _e + xn + "D" : "") + (j || T || Ne ? "T" : "") + (j ? en + j + "H" : "") + (T ? en + T + "M" : "") + (Ne ? en + wt + "S" : "")) : "P0D";
          }
          var ci = Sa.prototype;
          return ci.isValid = function() {
            return this._isValid;
          }, ci.abs = function() {
            var T = this._data;
            return this._milliseconds = Wr(this._milliseconds), this._days = Wr(this._days), this._months = Wr(this._months), T.milliseconds = Wr(T.milliseconds), T.seconds = Wr(T.seconds), T.minutes = Wr(T.minutes), T.hours = Wr(T.hours), T.months = Wr(T.months), T.years = Wr(T.years), this;
          }, ci.add = function(T, j) {
            return Po(this, T, j, 1);
          }, ci.subtract = function(T, j) {
            return Po(this, T, j, -1);
          }, ci.as = function(T) {
            if (!this.isValid()) return NaN;
            var j, ut, wt = this._milliseconds;
            if ((T = Yt(T)) === "month" || T === "quarter" || T === "year") switch (j = this._days + wt / 864e5, ut = this._months + zo(j), T) {
              case "month":
                return ut;
              case "quarter":
                return ut / 3;
              case "year":
                return ut / 12;
            }
            else switch (j = this._days + Math.round(vs(this._months)), T) {
              case "week":
                return j / 7 + wt / 6048e5;
              case "day":
                return j + wt / 864e5;
              case "hour":
                return 24 * j + wt / 36e5;
              case "minute":
                return 1440 * j + wt / 6e4;
              case "second":
                return 86400 * j + wt / 1e3;
              case "millisecond":
                return Math.floor(864e5 * j) + wt;
              default:
                throw new Error("Unknown unit " + T);
            }
          }, ci.asMilliseconds = ro, ci.asSeconds = Ha, ci.asMinutes = Ul, ci.asHours = Oo, ci.asDays = jl, ci.asWeeks = Yo, ci.asMonths = Bl, ci.asQuarters = Hl, ci.asYears = ql, ci.valueOf = ao, ci._bubble = function() {
            var T, j, ut, wt, Ut, oe = this._milliseconds, _e = this._days, en = this._months, Ne = this._data;
            return oe >= 0 && _e >= 0 && en >= 0 || oe <= 0 && _e <= 0 && en <= 0 || (oe += 864e5 * io(vs(en) + _e), _e = 0, en = 0), Ne.milliseconds = oe % 1e3, T = Ai(oe / 1e3), Ne.seconds = T % 60, j = Ai(T / 60), Ne.minutes = j % 60, ut = Ai(j / 60), Ne.hours = ut % 24, _e += Ai(ut / 24), en += Ut = Ai(zo(_e)), _e -= io(vs(Ut)), wt = Ai(en / 12), en %= 12, Ne.days = _e, Ne.months = en, Ne.years = wt, this;
          }, ci.clone = function() {
            return lr(this);
          }, ci.get = function(T) {
            return T = Yt(T), this.isValid() ? this[T + "s"]() : NaN;
          }, ci.milliseconds = Fo, ci.seconds = Gl, ci.minutes = us, ci.hours = so, ci.days = Uo, ci.weeks = function() {
            return Ai(this.days() / 7);
          }, ci.months = Ts, ci.years = jo, ci.humanize = function(T, j) {
            if (!this.isValid()) return this.localeData().invalidDate();
            var ut, wt, Ut = !1, oe = xa;
            return typeof T == "object" && (j = T, T = !1), typeof T == "boolean" && (Ut = T), typeof j == "object" && (oe = Object.assign({}, xa, j), j.s != null && j.ss == null && (oe.ss = j.s - 1)), wt = function(_e, en, Ne, xn) {
              var ti = lr(_e).abs(), ni = Kr(ti.as("s")), yi = Kr(ti.as("m")), Ni = Kr(ti.as("h")), Wi = Kr(ti.as("d")), Pr = Kr(ti.as("M")), pr = Kr(ti.as("w")), oo = Kr(ti.as("y")), ma = ni <= Ne.ss && ["s", ni] || ni < Ne.s && ["ss", ni] || yi <= 1 && ["m"] || yi < Ne.m && ["mm", yi] || Ni <= 1 && ["h"] || Ni < Ne.h && ["hh", Ni] || Wi <= 1 && ["d"] || Wi < Ne.d && ["dd", Wi];
              return Ne.w != null && (ma = ma || pr <= 1 && ["w"] || pr < Ne.w && ["ww", pr]), (ma = ma || Pr <= 1 && ["M"] || Pr < Ne.M && ["MM", Pr] || oo <= 1 && ["y"] || ["yy", oo])[2] = en, ma[3] = +_e > 0, ma[4] = xn, Vl.apply(null, ma);
            }(this, !Ut, oe, ut = this.localeData()), Ut && (wt = ut.pastFuture(+this, wt)), ut.postformat(wt);
          }, ci.toISOString = As, ci.toString = As, ci.toJSON = As, ci.locale = pi, ci.localeData = Ti, ci.toIsoString = It("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", As), ci.lang = Bn, me("X", 0, 0, "unix"), me("x", 0, 0, "valueOf"), je("x", Jt), je("X", /[+-]?\d+(\.\d{1,3})?/), Ae("X", function(T, j, ut) {
            ut._d = new Date(1e3 * parseFloat(T));
          }), Ae("x", function(T, j, ut) {
            ut._d = new Date(Gn(T));
          }), o.version = "2.30.1", A = vi, o.fn = mn, o.min = function() {
            return Qi("isBefore", [].slice.call(arguments, 0));
          }, o.max = function() {
            return Qi("isAfter", [].slice.call(arguments, 0));
          }, o.now = function() {
            return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
          }, o.utc = P, o.unix = function(T) {
            return vi(1e3 * T);
          }, o.months = function(T, j) {
            return no(T, j, "months");
          }, o.isDate = d, o.locale = Hi, o.invalid = dt, o.duration = lr, o.isMoment = I, o.weekdays = function(T, j, ut) {
            return Es(T, j, ut, "weekdays");
          }, o.parseZone = function() {
            return vi.apply(null, arguments).parseZone();
          }, o.localeData = qi, o.isDuration = mr, o.monthsShort = function(T, j) {
            return no(T, j, "monthsShort");
          }, o.weekdaysMin = function(T, j, ut) {
            return Es(T, j, ut, "weekdaysMin");
          }, o.defineLocale = Zi, o.updateLocale = function(T, j) {
            if (j != null) {
              var ut, wt, Ut = Zn;
              zn[T] != null && zn[T].parentLocale != null ? zn[T].set(qe(zn[T]._config, j)) : ((wt = Yi(T)) != null && (Ut = wt._config), j = qe(Ut, j), wt == null && (j.abbr = T), (ut = new zt(j)).parentLocale = zn[T], zn[T] = ut), Hi(T);
            } else zn[T] != null && (zn[T].parentLocale != null ? (zn[T] = zn[T].parentLocale, T === Hi() && Hi(T)) : zn[T] != null && delete zn[T]);
            return zn[T];
          }, o.locales = function() {
            return et(zn);
          }, o.weekdaysShort = function(T, j, ut) {
            return Es(T, j, ut, "weekdaysShort");
          }, o.normalizeUnits = Yt, o.relativeTimeRounding = function(T) {
            return T === void 0 ? Kr : typeof T == "function" && (Kr = T, !0);
          }, o.relativeTimeThreshold = function(T, j) {
            return xa[T] !== void 0 && (j === void 0 ? xa[T] : (xa[T] = j, T === "s" && (xa.ss = j - 1), !0));
          }, o.calendarFormat = function(T, j) {
            var ut = T.diff(j, "days", !0);
            return ut < -6 ? "sameElse" : ut < -1 ? "lastWeek" : ut < 0 ? "lastDay" : ut < 1 ? "sameDay" : ut < 2 ? "nextDay" : ut < 7 ? "nextWeek" : "sameElse";
          }, o.prototype = mn, o.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, o;
        }();
      }, 3282: function(L) {
        function h(l) {
          if (typeof l != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(l));
        }
        function b(l, o) {
          for (var u, g = "", m = 0, S = -1, e = 0, n = 0; n <= l.length; ++n) {
            if (n < l.length) u = l.charCodeAt(n);
            else {
              if (u === 47) break;
              u = 47;
            }
            if (u === 47) {
              if (!(S === n - 1 || e === 1)) if (S !== n - 1 && e === 2) {
                if (g.length < 2 || m !== 2 || g.charCodeAt(g.length - 1) !== 46 || g.charCodeAt(g.length - 2) !== 46) {
                  if (g.length > 2) {
                    var d = g.lastIndexOf("/");
                    if (d !== g.length - 1) {
                      d === -1 ? (g = "", m = 0) : m = (g = g.slice(0, d)).length - 1 - g.lastIndexOf("/"), S = n, e = 0;
                      continue;
                    }
                  } else if (g.length === 2 || g.length === 1) {
                    g = "", m = 0, S = n, e = 0;
                    continue;
                  }
                }
                o && (g.length > 0 ? g += "/.." : g = "..", m = 2);
              } else g.length > 0 ? g += "/" + l.slice(S + 1, n) : g = l.slice(S + 1, n), m = n - S - 1;
              S = n, e = 0;
            } else u === 46 && e !== -1 ? ++e : e = -1;
          }
          return g;
        }
        var A = { resolve: function() {
          for (var l, o = "", u = !1, g = arguments.length - 1; g >= -1 && !u; g--) {
            var m;
            g >= 0 ? m = arguments[g] : (l === void 0 && (l = process.cwd()), m = l), h(m), m.length !== 0 && (o = m + "/" + o, u = m.charCodeAt(0) === 47);
          }
          return o = b(o, !u), u ? o.length > 0 ? "/" + o : "/" : o.length > 0 ? o : ".";
        }, normalize: function(l) {
          if (h(l), l.length === 0) return ".";
          var o = l.charCodeAt(0) === 47, u = l.charCodeAt(l.length - 1) === 47;
          return (l = b(l, !o)).length !== 0 || o || (l = "."), l.length > 0 && u && (l += "/"), o ? "/" + l : l;
        }, isAbsolute: function(l) {
          return h(l), l.length > 0 && l.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0) return ".";
          for (var l, o = 0; o < arguments.length; ++o) {
            var u = arguments[o];
            h(u), u.length > 0 && (l === void 0 ? l = u : l += "/" + u);
          }
          return l === void 0 ? "." : A.normalize(l);
        }, relative: function(l, o) {
          if (h(l), h(o), l === o || (l = A.resolve(l)) === (o = A.resolve(o))) return "";
          for (var u = 1; u < l.length && l.charCodeAt(u) === 47; ++u) ;
          for (var g = l.length, m = g - u, S = 1; S < o.length && o.charCodeAt(S) === 47; ++S) ;
          for (var e = o.length - S, n = m < e ? m : e, d = -1, _ = 0; _ <= n; ++_) {
            if (_ === n) {
              if (e > n) {
                if (o.charCodeAt(S + _) === 47) return o.slice(S + _ + 1);
                if (_ === 0) return o.slice(S + _);
              } else m > n && (l.charCodeAt(u + _) === 47 ? d = _ : _ === 0 && (d = 0));
              break;
            }
            var p = l.charCodeAt(u + _);
            if (p !== o.charCodeAt(S + _)) break;
            p === 47 && (d = _);
          }
          var P = "";
          for (_ = u + d + 1; _ <= g; ++_) _ !== g && l.charCodeAt(_) !== 47 || (P.length === 0 ? P += ".." : P += "/..");
          return P.length > 0 ? P + o.slice(S + d) : (S += d, o.charCodeAt(S) === 47 && ++S, o.slice(S));
        }, _makeLong: function(l) {
          return l;
        }, dirname: function(l) {
          if (h(l), l.length === 0) return ".";
          for (var o = l.charCodeAt(0), u = o === 47, g = -1, m = !0, S = l.length - 1; S >= 1; --S) if ((o = l.charCodeAt(S)) === 47) {
            if (!m) {
              g = S;
              break;
            }
          } else m = !1;
          return g === -1 ? u ? "/" : "." : u && g === 1 ? "//" : l.slice(0, g);
        }, basename: function(l, o) {
          if (o !== void 0 && typeof o != "string") throw new TypeError('"ext" argument must be a string');
          h(l);
          var u, g = 0, m = -1, S = !0;
          if (o !== void 0 && o.length > 0 && o.length <= l.length) {
            if (o.length === l.length && o === l) return "";
            var e = o.length - 1, n = -1;
            for (u = l.length - 1; u >= 0; --u) {
              var d = l.charCodeAt(u);
              if (d === 47) {
                if (!S) {
                  g = u + 1;
                  break;
                }
              } else n === -1 && (S = !1, n = u + 1), e >= 0 && (d === o.charCodeAt(e) ? --e == -1 && (m = u) : (e = -1, m = n));
            }
            return g === m ? m = n : m === -1 && (m = l.length), l.slice(g, m);
          }
          for (u = l.length - 1; u >= 0; --u) if (l.charCodeAt(u) === 47) {
            if (!S) {
              g = u + 1;
              break;
            }
          } else m === -1 && (S = !1, m = u + 1);
          return m === -1 ? "" : l.slice(g, m);
        }, extname: function(l) {
          h(l);
          for (var o = -1, u = 0, g = -1, m = !0, S = 0, e = l.length - 1; e >= 0; --e) {
            var n = l.charCodeAt(e);
            if (n !== 47) g === -1 && (m = !1, g = e + 1), n === 46 ? o === -1 ? o = e : S !== 1 && (S = 1) : o !== -1 && (S = -1);
            else if (!m) {
              u = e + 1;
              break;
            }
          }
          return o === -1 || g === -1 || S === 0 || S === 1 && o === g - 1 && o === u + 1 ? "" : l.slice(o, g);
        }, format: function(l) {
          if (l === null || typeof l != "object") throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof l);
          return function(o, u) {
            var g = u.dir || u.root, m = u.base || (u.name || "") + (u.ext || "");
            return g ? g === u.root ? g + m : g + "/" + m : m;
          }(0, l);
        }, parse: function(l) {
          h(l);
          var o = { root: "", dir: "", base: "", ext: "", name: "" };
          if (l.length === 0) return o;
          var u, g = l.charCodeAt(0), m = g === 47;
          m ? (o.root = "/", u = 1) : u = 0;
          for (var S = -1, e = 0, n = -1, d = !0, _ = l.length - 1, p = 0; _ >= u; --_) if ((g = l.charCodeAt(_)) !== 47) n === -1 && (d = !1, n = _ + 1), g === 46 ? S === -1 ? S = _ : p !== 1 && (p = 1) : S !== -1 && (p = -1);
          else if (!d) {
            e = _ + 1;
            break;
          }
          return S === -1 || n === -1 || p === 0 || p === 1 && S === n - 1 && S === e + 1 ? n !== -1 && (o.base = o.name = e === 0 && m ? l.slice(1, n) : l.slice(e, n)) : (e === 0 && m ? (o.name = l.slice(1, S), o.base = l.slice(1, n)) : (o.name = l.slice(e, S), o.base = l.slice(e, n)), o.ext = l.slice(S, n)), e > 0 ? o.dir = l.slice(0, e - 1) : m && (o.dir = "/"), o;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        A.posix = A, L.exports = A;
      }, 3515: function(L, h, b) {
        L.exports = l;
        var A = b(9826).EventEmitter;
        function l() {
          A.call(this);
        }
        b(7523)(l, A), l.Readable = b(2762), l.Writable = b(3726), l.Duplex = b(884), l.Transform = b(6756), l.PassThrough = b(1390), l.finished = b(2896), l.pipeline = b(8460), l.Stream = l, l.prototype.pipe = function(o, u) {
          var g = this;
          function m(P) {
            o.writable && o.write(P) === !1 && g.pause && g.pause();
          }
          function S() {
            g.readable && g.resume && g.resume();
          }
          g.on("data", m), o.on("drain", S), o._isStdio || u && u.end === !1 || (g.on("end", n), g.on("close", d));
          var e = !1;
          function n() {
            e || (e = !0, o.end());
          }
          function d() {
            e || (e = !0, typeof o.destroy == "function" && o.destroy());
          }
          function _(P) {
            if (p(), A.listenerCount(this, "error") === 0) throw P;
          }
          function p() {
            g.removeListener("data", m), o.removeListener("drain", S), g.removeListener("end", n), g.removeListener("close", d), g.removeListener("error", _), o.removeListener("error", _), g.removeListener("end", p), g.removeListener("close", p), o.removeListener("close", p);
          }
          return g.on("error", _), o.on("error", _), g.on("end", p), g.on("close", p), o.on("close", p), o.emit("pipe", g), o;
        };
      }, 1602: function(L) {
        var h = {};
        function b(l, o, u) {
          u || (u = Error);
          var g = function(m) {
            var S, e;
            function n(d, _, p) {
              return m.call(this, function(P, $, ot) {
                return typeof o == "string" ? o : o(P, $, ot);
              }(d, _, p)) || this;
            }
            return e = m, (S = n).prototype = Object.create(e.prototype), S.prototype.constructor = S, S.__proto__ = e, n;
          }(u);
          g.prototype.name = u.name, g.prototype.code = l, h[l] = g;
        }
        function A(l, o) {
          if (Array.isArray(l)) {
            var u = l.length;
            return l = l.map(function(g) {
              return String(g);
            }), u > 2 ? "one of ".concat(o, " ").concat(l.slice(0, u - 1).join(", "), ", or ") + l[u - 1] : u === 2 ? "one of ".concat(o, " ").concat(l[0], " or ").concat(l[1]) : "of ".concat(o, " ").concat(l[0]);
          }
          return "of ".concat(o, " ").concat(String(l));
        }
        b("ERR_INVALID_OPT_VALUE", function(l, o) {
          return 'The value "' + o + '" is invalid for option "' + l + '"';
        }, TypeError), b("ERR_INVALID_ARG_TYPE", function(l, o, u) {
          var g, m, S, e, n;
          if (typeof o == "string" && (m = "not ", o.substr(0, 4) === m) ? (g = "must not be", o = o.replace(/^not /, "")) : g = "must be", function(_, p, P) {
            return (P === void 0 || P > _.length) && (P = _.length), _.substring(P - 9, P) === p;
          }(l, " argument")) S = "The ".concat(l, " ").concat(g, " ").concat(A(o, "type"));
          else {
            var d = (typeof n != "number" && (n = 0), n + 1 > (e = l).length || e.indexOf(".", n) === -1 ? "argument" : "property");
            S = 'The "'.concat(l, '" ').concat(d, " ").concat(g, " ").concat(A(o, "type"));
          }
          return S + ". Received type ".concat(typeof u);
        }, TypeError), b("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), b("ERR_METHOD_NOT_IMPLEMENTED", function(l) {
          return "The " + l + " method is not implemented";
        }), b("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), b("ERR_STREAM_DESTROYED", function(l) {
          return "Cannot call " + l + " after a stream was destroyed";
        }), b("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), b("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), b("ERR_STREAM_WRITE_AFTER_END", "write after end"), b("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), b("ERR_UNKNOWN_ENCODING", function(l) {
          return "Unknown encoding: " + l;
        }, TypeError), b("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), L.exports.F = h;
      }, 884: function(L, h, b) {
        var A = Object.keys || function(d) {
          var _ = [];
          for (var p in d) _.push(p);
          return _;
        };
        L.exports = S;
        var l = b(2762), o = b(3726);
        b(7523)(S, l);
        for (var u = A(o.prototype), g = 0; g < u.length; g++) {
          var m = u[g];
          S.prototype[m] || (S.prototype[m] = o.prototype[m]);
        }
        function S(d) {
          if (!(this instanceof S)) return new S(d);
          l.call(this, d), o.call(this, d), this.allowHalfOpen = !0, d && (d.readable === !1 && (this.readable = !1), d.writable === !1 && (this.writable = !1), d.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", e)));
        }
        function e() {
          this._writableState.ended || process.nextTick(n, this);
        }
        function n(d) {
          d.end();
        }
        Object.defineProperty(S.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), Object.defineProperty(S.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(S.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(S.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
        }, set: function(d) {
          this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = d, this._writableState.destroyed = d);
        } });
      }, 1390: function(L, h, b) {
        L.exports = l;
        var A = b(6756);
        function l(o) {
          if (!(this instanceof l)) return new l(o);
          A.call(this, o);
        }
        b(7523)(l, A), l.prototype._transform = function(o, u, g) {
          g(null, o);
        };
      }, 2762: function(L, h, b) {
        var A;
        L.exports = pt, pt.ReadableState = I, b(9826).EventEmitter;
        var l, o = function(Yt, Ht) {
          return Yt.listeners(Ht).length;
        }, u = b(2611), g = b(44).Buffer, m = (b.g !== void 0 ? b.g : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
        }, S = b(7199);
        l = S && S.debuglog ? S.debuglog("stream") : function() {
        };
        var e, n, d, _ = b(3791), p = b(2410), P = b(1749).getHighWaterMark, $ = b(1602).F, ot = $.ERR_INVALID_ARG_TYPE, dt = $.ERR_STREAM_PUSH_AFTER_EOF, xt = $.ERR_METHOD_NOT_IMPLEMENTED, Nt = $.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        b(7523)(pt, u);
        var jt = p.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
        function I(Yt, Ht, Me) {
          A = A || b(884), Yt = Yt || {}, typeof Me != "boolean" && (Me = Ht instanceof A), this.objectMode = !!Yt.objectMode, Me && (this.objectMode = this.objectMode || !!Yt.readableObjectMode), this.highWaterMark = P(this, Yt, "readableHighWaterMark", Me), this.buffer = new _(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Yt.emitClose !== !1, this.autoDestroy = !!Yt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Yt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Yt.encoding && (e || (e = b(748).I), this.decoder = new e(Yt.encoding), this.encoding = Yt.encoding);
        }
        function pt(Yt) {
          if (A = A || b(884), !(this instanceof pt)) return new pt(Yt);
          var Ht = this instanceof A;
          this._readableState = new I(Yt, this, Ht), this.readable = !0, Yt && (typeof Yt.read == "function" && (this._read = Yt.read), typeof Yt.destroy == "function" && (this._destroy = Yt.destroy)), u.call(this);
        }
        function It(Yt, Ht, Me, X, Q) {
          l("readableAddChunk", Ht);
          var C, U = Yt._readableState;
          if (Ht === null) U.reading = !1, function(gt, rt) {
            if (l("onEofChunk"), !rt.ended) {
              if (rt.decoder) {
                var Ft = rt.decoder.end();
                Ft && Ft.length && (rt.buffer.push(Ft), rt.length += rt.objectMode ? 1 : Ft.length);
              }
              rt.ended = !0, rt.sync ? St(gt) : (rt.needReadable = !1, rt.emittedReadable || (rt.emittedReadable = !0, qe(gt)));
            }
          }(Yt, U);
          else if (Q || (C = function(gt, rt) {
            var Ft, ne;
            return ne = rt, g.isBuffer(ne) || ne instanceof m || typeof rt == "string" || rt === void 0 || gt.objectMode || (Ft = new ot("chunk", ["string", "Buffer", "Uint8Array"], rt)), Ft;
          }(U, Ht)), C) jt(Yt, C);
          else if (U.objectMode || Ht && Ht.length > 0) if (typeof Ht == "string" || U.objectMode || Object.getPrototypeOf(Ht) === g.prototype || (Ht = function(gt) {
            return g.from(gt);
          }(Ht)), X) U.endEmitted ? jt(Yt, new Nt()) : et(Yt, U, Ht, !0);
          else if (U.ended) jt(Yt, new dt());
          else {
            if (U.destroyed) return !1;
            U.reading = !1, U.decoder && !Me ? (Ht = U.decoder.write(Ht), U.objectMode || Ht.length !== 0 ? et(Yt, U, Ht, !1) : zt(Yt, U)) : et(Yt, U, Ht, !1);
          }
          else X || (U.reading = !1, zt(Yt, U));
          return !U.ended && (U.length < U.highWaterMark || U.length === 0);
        }
        function et(Yt, Ht, Me, X) {
          Ht.flowing && Ht.length === 0 && !Ht.sync ? (Ht.awaitDrain = 0, Yt.emit("data", Me)) : (Ht.length += Ht.objectMode ? 1 : Me.length, X ? Ht.buffer.unshift(Me) : Ht.buffer.push(Me), Ht.needReadable && St(Yt)), zt(Yt, Ht);
        }
        Object.defineProperty(pt.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._readableState !== void 0 && this._readableState.destroyed;
        }, set: function(Yt) {
          this._readableState && (this._readableState.destroyed = Yt);
        } }), pt.prototype.destroy = p.destroy, pt.prototype._undestroy = p.undestroy, pt.prototype._destroy = function(Yt, Ht) {
          Ht(Yt);
        }, pt.prototype.push = function(Yt, Ht) {
          var Me, X = this._readableState;
          return X.objectMode ? Me = !0 : typeof Yt == "string" && ((Ht = Ht || X.defaultEncoding) !== X.encoding && (Yt = g.from(Yt, Ht), Ht = ""), Me = !0), It(this, Yt, Ht, !1, Me);
        }, pt.prototype.unshift = function(Yt) {
          return It(this, Yt, null, !0, !1);
        }, pt.prototype.isPaused = function() {
          return this._readableState.flowing === !1;
        }, pt.prototype.setEncoding = function(Yt) {
          e || (e = b(748).I);
          var Ht = new e(Yt);
          this._readableState.decoder = Ht, this._readableState.encoding = this._readableState.decoder.encoding;
          for (var Me = this._readableState.buffer.head, X = ""; Me !== null; ) X += Ht.write(Me.data), Me = Me.next;
          return this._readableState.buffer.clear(), X !== "" && this._readableState.buffer.push(X), this._readableState.length = X.length, this;
        };
        var Dt = 1073741824;
        function ae(Yt, Ht) {
          return Yt <= 0 || Ht.length === 0 && Ht.ended ? 0 : Ht.objectMode ? 1 : Yt != Yt ? Ht.flowing && Ht.length ? Ht.buffer.head.data.length : Ht.length : (Yt > Ht.highWaterMark && (Ht.highWaterMark = function(Me) {
            return Me >= Dt ? Me = Dt : (Me--, Me |= Me >>> 1, Me |= Me >>> 2, Me |= Me >>> 4, Me |= Me >>> 8, Me |= Me >>> 16, Me++), Me;
          }(Yt)), Yt <= Ht.length ? Yt : Ht.ended ? Ht.length : (Ht.needReadable = !0, 0));
        }
        function St(Yt) {
          var Ht = Yt._readableState;
          l("emitReadable", Ht.needReadable, Ht.emittedReadable), Ht.needReadable = !1, Ht.emittedReadable || (l("emitReadable", Ht.flowing), Ht.emittedReadable = !0, process.nextTick(qe, Yt));
        }
        function qe(Yt) {
          var Ht = Yt._readableState;
          l("emitReadable_", Ht.destroyed, Ht.length, Ht.ended), Ht.destroyed || !Ht.length && !Ht.ended || (Yt.emit("readable"), Ht.emittedReadable = !1), Ht.needReadable = !Ht.flowing && !Ht.ended && Ht.length <= Ht.highWaterMark, Ze(Yt);
        }
        function zt(Yt, Ht) {
          Ht.readingMore || (Ht.readingMore = !0, process.nextTick(Ct, Yt, Ht));
        }
        function Ct(Yt, Ht) {
          for (; !Ht.reading && !Ht.ended && (Ht.length < Ht.highWaterMark || Ht.flowing && Ht.length === 0); ) {
            var Me = Ht.length;
            if (l("maybeReadMore read 0"), Yt.read(0), Me === Ht.length) break;
          }
          Ht.readingMore = !1;
        }
        function de(Yt) {
          var Ht = Yt._readableState;
          Ht.readableListening = Yt.listenerCount("readable") > 0, Ht.resumeScheduled && !Ht.paused ? Ht.flowing = !0 : Yt.listenerCount("data") > 0 && Yt.resume();
        }
        function ze(Yt) {
          l("readable nexttick read 0"), Yt.read(0);
        }
        function le(Yt, Ht) {
          l("resume", Ht.reading), Ht.reading || Yt.read(0), Ht.resumeScheduled = !1, Yt.emit("resume"), Ze(Yt), Ht.flowing && !Ht.reading && Yt.read(0);
        }
        function Ze(Yt) {
          var Ht = Yt._readableState;
          for (l("flow", Ht.flowing); Ht.flowing && Yt.read() !== null; ) ;
        }
        function me(Yt, Ht) {
          return Ht.length === 0 ? null : (Ht.objectMode ? Me = Ht.buffer.shift() : !Yt || Yt >= Ht.length ? (Me = Ht.decoder ? Ht.buffer.join("") : Ht.buffer.length === 1 ? Ht.buffer.first() : Ht.buffer.concat(Ht.length), Ht.buffer.clear()) : Me = Ht.buffer.consume(Yt, Ht.decoder), Me);
          var Me;
        }
        function bn(Yt) {
          var Ht = Yt._readableState;
          l("endReadable", Ht.endEmitted), Ht.endEmitted || (Ht.ended = !0, process.nextTick(pn, Ht, Yt));
        }
        function pn(Yt, Ht) {
          if (l("endReadableNT", Yt.endEmitted, Yt.length), !Yt.endEmitted && Yt.length === 0 && (Yt.endEmitted = !0, Ht.readable = !1, Ht.emit("end"), Yt.autoDestroy)) {
            var Me = Ht._writableState;
            (!Me || Me.autoDestroy && Me.finished) && Ht.destroy();
          }
        }
        function wn(Yt, Ht) {
          for (var Me = 0, X = Yt.length; Me < X; Me++) if (Yt[Me] === Ht) return Me;
          return -1;
        }
        pt.prototype.read = function(Yt) {
          l("read", Yt), Yt = parseInt(Yt, 10);
          var Ht = this._readableState, Me = Yt;
          if (Yt !== 0 && (Ht.emittedReadable = !1), Yt === 0 && Ht.needReadable && ((Ht.highWaterMark !== 0 ? Ht.length >= Ht.highWaterMark : Ht.length > 0) || Ht.ended)) return l("read: emitReadable", Ht.length, Ht.ended), Ht.length === 0 && Ht.ended ? bn(this) : St(this), null;
          if ((Yt = ae(Yt, Ht)) === 0 && Ht.ended) return Ht.length === 0 && bn(this), null;
          var X, Q = Ht.needReadable;
          return l("need readable", Q), (Ht.length === 0 || Ht.length - Yt < Ht.highWaterMark) && l("length less than watermark", Q = !0), Ht.ended || Ht.reading ? l("reading or ended", Q = !1) : Q && (l("do read"), Ht.reading = !0, Ht.sync = !0, Ht.length === 0 && (Ht.needReadable = !0), this._read(Ht.highWaterMark), Ht.sync = !1, Ht.reading || (Yt = ae(Me, Ht))), (X = Yt > 0 ? me(Yt, Ht) : null) === null ? (Ht.needReadable = Ht.length <= Ht.highWaterMark, Yt = 0) : (Ht.length -= Yt, Ht.awaitDrain = 0), Ht.length === 0 && (Ht.ended || (Ht.needReadable = !0), Me !== Yt && Ht.ended && bn(this)), X !== null && this.emit("data", X), X;
        }, pt.prototype._read = function(Yt) {
          jt(this, new xt("_read()"));
        }, pt.prototype.pipe = function(Yt, Ht) {
          var Me = this, X = this._readableState;
          switch (X.pipesCount) {
            case 0:
              X.pipes = Yt;
              break;
            case 1:
              X.pipes = [X.pipes, Yt];
              break;
            default:
              X.pipes.push(Yt);
          }
          X.pipesCount += 1, l("pipe count=%d opts=%j", X.pipesCount, Ht);
          var Q = Ht && Ht.end === !1 || Yt === process.stdout || Yt === process.stderr ? Xt : C;
          function C() {
            l("onend"), Yt.end();
          }
          X.endEmitted ? process.nextTick(Q) : Me.once("end", Q), Yt.on("unpipe", function qt(Gt, se) {
            l("onunpipe"), Gt === Me && se && se.hasUnpiped === !1 && (se.hasUnpiped = !0, l("cleanup"), Yt.removeListener("close", ne), Yt.removeListener("finish", Vt), Yt.removeListener("drain", U), Yt.removeListener("error", Ft), Yt.removeListener("unpipe", qt), Me.removeListener("end", C), Me.removeListener("end", Xt), Me.removeListener("data", rt), gt = !0, !X.awaitDrain || Yt._writableState && !Yt._writableState.needDrain || U());
          });
          var U = /* @__PURE__ */ function(qt) {
            return function() {
              var Gt = qt._readableState;
              l("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && o(qt, "data") && (Gt.flowing = !0, Ze(qt));
            };
          }(Me);
          Yt.on("drain", U);
          var gt = !1;
          function rt(qt) {
            l("ondata");
            var Gt = Yt.write(qt);
            l("dest.write", Gt), Gt === !1 && ((X.pipesCount === 1 && X.pipes === Yt || X.pipesCount > 1 && wn(X.pipes, Yt) !== -1) && !gt && (l("false write response, pause", X.awaitDrain), X.awaitDrain++), Me.pause());
          }
          function Ft(qt) {
            l("onerror", qt), Xt(), Yt.removeListener("error", Ft), o(Yt, "error") === 0 && jt(Yt, qt);
          }
          function ne() {
            Yt.removeListener("finish", Vt), Xt();
          }
          function Vt() {
            l("onfinish"), Yt.removeListener("close", ne), Xt();
          }
          function Xt() {
            l("unpipe"), Me.unpipe(Yt);
          }
          return Me.on("data", rt), function(qt, Gt, se) {
            if (typeof qt.prependListener == "function") return qt.prependListener(Gt, se);
            qt._events && qt._events[Gt] ? Array.isArray(qt._events[Gt]) ? qt._events[Gt].unshift(se) : qt._events[Gt] = [se, qt._events[Gt]] : qt.on(Gt, se);
          }(Yt, "error", Ft), Yt.once("close", ne), Yt.once("finish", Vt), Yt.emit("pipe", Me), X.flowing || (l("pipe resume"), Me.resume()), Yt;
        }, pt.prototype.unpipe = function(Yt) {
          var Ht = this._readableState, Me = { hasUnpiped: !1 };
          if (Ht.pipesCount === 0) return this;
          if (Ht.pipesCount === 1) return Yt && Yt !== Ht.pipes || (Yt || (Yt = Ht.pipes), Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1, Yt && Yt.emit("unpipe", this, Me)), this;
          if (!Yt) {
            var X = Ht.pipes, Q = Ht.pipesCount;
            Ht.pipes = null, Ht.pipesCount = 0, Ht.flowing = !1;
            for (var C = 0; C < Q; C++) X[C].emit("unpipe", this, { hasUnpiped: !1 });
            return this;
          }
          var U = wn(Ht.pipes, Yt);
          return U === -1 || (Ht.pipes.splice(U, 1), Ht.pipesCount -= 1, Ht.pipesCount === 1 && (Ht.pipes = Ht.pipes[0]), Yt.emit("unpipe", this, Me)), this;
        }, pt.prototype.on = function(Yt, Ht) {
          var Me = u.prototype.on.call(this, Yt, Ht), X = this._readableState;
          return Yt === "data" ? (X.readableListening = this.listenerCount("readable") > 0, X.flowing !== !1 && this.resume()) : Yt === "readable" && (X.endEmitted || X.readableListening || (X.readableListening = X.needReadable = !0, X.flowing = !1, X.emittedReadable = !1, l("on readable", X.length, X.reading), X.length ? St(this) : X.reading || process.nextTick(ze, this))), Me;
        }, pt.prototype.addListener = pt.prototype.on, pt.prototype.removeListener = function(Yt, Ht) {
          var Me = u.prototype.removeListener.call(this, Yt, Ht);
          return Yt === "readable" && process.nextTick(de, this), Me;
        }, pt.prototype.removeAllListeners = function(Yt) {
          var Ht = u.prototype.removeAllListeners.apply(this, arguments);
          return Yt !== "readable" && Yt !== void 0 || process.nextTick(de, this), Ht;
        }, pt.prototype.resume = function() {
          var Yt = this._readableState;
          return Yt.flowing || (l("resume"), Yt.flowing = !Yt.readableListening, function(Ht, Me) {
            Me.resumeScheduled || (Me.resumeScheduled = !0, process.nextTick(le, Ht, Me));
          }(this, Yt)), Yt.paused = !1, this;
        }, pt.prototype.pause = function() {
          return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
        }, pt.prototype.wrap = function(Yt) {
          var Ht = this, Me = this._readableState, X = !1;
          for (var Q in Yt.on("end", function() {
            if (l("wrapped end"), Me.decoder && !Me.ended) {
              var U = Me.decoder.end();
              U && U.length && Ht.push(U);
            }
            Ht.push(null);
          }), Yt.on("data", function(U) {
            l("wrapped data"), Me.decoder && (U = Me.decoder.write(U)), Me.objectMode && U == null || (Me.objectMode || U && U.length) && (Ht.push(U) || (X = !0, Yt.pause()));
          }), Yt) this[Q] === void 0 && typeof Yt[Q] == "function" && (this[Q] = /* @__PURE__ */ function(U) {
            return function() {
              return Yt[U].apply(Yt, arguments);
            };
          }(Q));
          for (var C = 0; C < q.length; C++) Yt.on(q[C], this.emit.bind(this, q[C]));
          return this._read = function(U) {
            l("wrapped _read", U), X && (X = !1, Yt.resume());
          }, this;
        }, typeof Symbol == "function" && (pt.prototype[Symbol.asyncIterator] = function() {
          return n === void 0 && (n = b(5857)), n(this);
        }), Object.defineProperty(pt.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
          return this._readableState.highWaterMark;
        } }), Object.defineProperty(pt.prototype, "readableBuffer", { enumerable: !1, get: function() {
          return this._readableState && this._readableState.buffer;
        } }), Object.defineProperty(pt.prototype, "readableFlowing", { enumerable: !1, get: function() {
          return this._readableState.flowing;
        }, set: function(Yt) {
          this._readableState && (this._readableState.flowing = Yt);
        } }), pt._fromList = me, Object.defineProperty(pt.prototype, "readableLength", { enumerable: !1, get: function() {
          return this._readableState.length;
        } }), typeof Symbol == "function" && (pt.from = function(Yt, Ht) {
          return d === void 0 && (d = b(3411)), d(pt, Yt, Ht);
        });
      }, 6756: function(L, h, b) {
        L.exports = e;
        var A = b(1602).F, l = A.ERR_METHOD_NOT_IMPLEMENTED, o = A.ERR_MULTIPLE_CALLBACK, u = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, g = A.ERR_TRANSFORM_WITH_LENGTH_0, m = b(884);
        function S(_, p) {
          var P = this._transformState;
          P.transforming = !1;
          var $ = P.writecb;
          if ($ === null) return this.emit("error", new o());
          P.writechunk = null, P.writecb = null, p != null && this.push(p), $(_);
          var ot = this._readableState;
          ot.reading = !1, (ot.needReadable || ot.length < ot.highWaterMark) && this._read(ot.highWaterMark);
        }
        function e(_) {
          if (!(this instanceof e)) return new e(_);
          m.call(this, _), this._transformState = { afterTransform: S.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, _ && (typeof _.transform == "function" && (this._transform = _.transform), typeof _.flush == "function" && (this._flush = _.flush)), this.on("prefinish", n);
        }
        function n() {
          var _ = this;
          typeof this._flush != "function" || this._readableState.destroyed ? d(this, null, null) : this._flush(function(p, P) {
            d(_, p, P);
          });
        }
        function d(_, p, P) {
          if (p) return _.emit("error", p);
          if (P != null && _.push(P), _._writableState.length) throw new g();
          if (_._transformState.transforming) throw new u();
          return _.push(null);
        }
        b(7523)(e, m), e.prototype.push = function(_, p) {
          return this._transformState.needTransform = !1, m.prototype.push.call(this, _, p);
        }, e.prototype._transform = function(_, p, P) {
          P(new l("_transform()"));
        }, e.prototype._write = function(_, p, P) {
          var $ = this._transformState;
          if ($.writecb = P, $.writechunk = _, $.writeencoding = p, !$.transforming) {
            var ot = this._readableState;
            ($.needTransform || ot.needReadable || ot.length < ot.highWaterMark) && this._read(ot.highWaterMark);
          }
        }, e.prototype._read = function(_) {
          var p = this._transformState;
          p.writechunk === null || p.transforming ? p.needTransform = !0 : (p.transforming = !0, this._transform(p.writechunk, p.writeencoding, p.afterTransform));
        }, e.prototype._destroy = function(_, p) {
          m.prototype._destroy.call(this, _, function(P) {
            p(P);
          });
        };
      }, 3726: function(L, h, b) {
        function A(zt) {
          var Ct = this;
          this.next = null, this.entry = null, this.finish = function() {
            (function(de, ze) {
              var le = de.entry;
              for (de.entry = null; le; ) {
                var Ze = le.callback;
                ze.pendingcb--, Ze(void 0), le = le.next;
              }
              ze.corkedRequestsFree.next = de;
            })(Ct, zt);
          };
        }
        var l;
        L.exports = pt, pt.WritableState = I;
        var o, u = { deprecate: b(9e3) }, g = b(2611), m = b(44).Buffer, S = (b.g !== void 0 ? b.g : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
        }, e = b(2410), n = b(1749).getHighWaterMark, d = b(1602).F, _ = d.ERR_INVALID_ARG_TYPE, p = d.ERR_METHOD_NOT_IMPLEMENTED, P = d.ERR_MULTIPLE_CALLBACK, $ = d.ERR_STREAM_CANNOT_PIPE, ot = d.ERR_STREAM_DESTROYED, dt = d.ERR_STREAM_NULL_VALUES, xt = d.ERR_STREAM_WRITE_AFTER_END, Nt = d.ERR_UNKNOWN_ENCODING, jt = e.errorOrDestroy;
        function q() {
        }
        function I(zt, Ct, de) {
          l = l || b(884), zt = zt || {}, typeof de != "boolean" && (de = Ct instanceof l), this.objectMode = !!zt.objectMode, de && (this.objectMode = this.objectMode || !!zt.writableObjectMode), this.highWaterMark = n(this, zt, "writableHighWaterMark", de), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var ze = zt.decodeStrings === !1;
          this.decodeStrings = !ze, this.defaultEncoding = zt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(le) {
            (function(Ze, me) {
              var bn = Ze._writableState, pn = bn.sync, wn = bn.writecb;
              if (typeof wn != "function") throw new P();
              if (function(Ht) {
                Ht.writing = !1, Ht.writecb = null, Ht.length -= Ht.writelen, Ht.writelen = 0;
              }(bn), me) (function(Ht, Me, X, Q, C) {
                --Me.pendingcb, X ? (process.nextTick(C, Q), process.nextTick(qe, Ht, Me), Ht._writableState.errorEmitted = !0, jt(Ht, Q)) : (C(Q), Ht._writableState.errorEmitted = !0, jt(Ht, Q), qe(Ht, Me));
              })(Ze, bn, pn, me, wn);
              else {
                var Yt = ae(bn) || Ze.destroyed;
                Yt || bn.corked || bn.bufferProcessing || !bn.bufferedRequest || Dt(Ze, bn), pn ? process.nextTick(et, Ze, bn, Yt, wn) : et(Ze, bn, Yt, wn);
              }
            })(Ct, le);
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = zt.emitClose !== !1, this.autoDestroy = !!zt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
        }
        function pt(zt) {
          var Ct = this instanceof (l = l || b(884));
          if (!Ct && !o.call(pt, this)) return new pt(zt);
          this._writableState = new I(zt, this, Ct), this.writable = !0, zt && (typeof zt.write == "function" && (this._write = zt.write), typeof zt.writev == "function" && (this._writev = zt.writev), typeof zt.destroy == "function" && (this._destroy = zt.destroy), typeof zt.final == "function" && (this._final = zt.final)), g.call(this);
        }
        function It(zt, Ct, de, ze, le, Ze, me) {
          Ct.writelen = ze, Ct.writecb = me, Ct.writing = !0, Ct.sync = !0, Ct.destroyed ? Ct.onwrite(new ot("write")) : de ? zt._writev(le, Ct.onwrite) : zt._write(le, Ze, Ct.onwrite), Ct.sync = !1;
        }
        function et(zt, Ct, de, ze) {
          de || function(le, Ze) {
            Ze.length === 0 && Ze.needDrain && (Ze.needDrain = !1, le.emit("drain"));
          }(zt, Ct), Ct.pendingcb--, ze(), qe(zt, Ct);
        }
        function Dt(zt, Ct) {
          Ct.bufferProcessing = !0;
          var de = Ct.bufferedRequest;
          if (zt._writev && de && de.next) {
            var ze = Ct.bufferedRequestCount, le = new Array(ze), Ze = Ct.corkedRequestsFree;
            Ze.entry = de;
            for (var me = 0, bn = !0; de; ) le[me] = de, de.isBuf || (bn = !1), de = de.next, me += 1;
            le.allBuffers = bn, It(zt, Ct, !0, Ct.length, le, "", Ze.finish), Ct.pendingcb++, Ct.lastBufferedRequest = null, Ze.next ? (Ct.corkedRequestsFree = Ze.next, Ze.next = null) : Ct.corkedRequestsFree = new A(Ct), Ct.bufferedRequestCount = 0;
          } else {
            for (; de; ) {
              var pn = de.chunk, wn = de.encoding, Yt = de.callback;
              if (It(zt, Ct, !1, Ct.objectMode ? 1 : pn.length, pn, wn, Yt), de = de.next, Ct.bufferedRequestCount--, Ct.writing) break;
            }
            de === null && (Ct.lastBufferedRequest = null);
          }
          Ct.bufferedRequest = de, Ct.bufferProcessing = !1;
        }
        function ae(zt) {
          return zt.ending && zt.length === 0 && zt.bufferedRequest === null && !zt.finished && !zt.writing;
        }
        function St(zt, Ct) {
          zt._final(function(de) {
            Ct.pendingcb--, de && jt(zt, de), Ct.prefinished = !0, zt.emit("prefinish"), qe(zt, Ct);
          });
        }
        function qe(zt, Ct) {
          var de = ae(Ct);
          if (de && (function(le, Ze) {
            Ze.prefinished || Ze.finalCalled || (typeof le._final != "function" || Ze.destroyed ? (Ze.prefinished = !0, le.emit("prefinish")) : (Ze.pendingcb++, Ze.finalCalled = !0, process.nextTick(St, le, Ze)));
          }(zt, Ct), Ct.pendingcb === 0 && (Ct.finished = !0, zt.emit("finish"), Ct.autoDestroy))) {
            var ze = zt._readableState;
            (!ze || ze.autoDestroy && ze.endEmitted) && zt.destroy();
          }
          return de;
        }
        b(7523)(pt, g), I.prototype.getBuffer = function() {
          for (var zt = this.bufferedRequest, Ct = []; zt; ) Ct.push(zt), zt = zt.next;
          return Ct;
        }, function() {
          try {
            Object.defineProperty(I.prototype, "buffer", { get: u.deprecate(function() {
              return this.getBuffer();
            }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
          } catch {
          }
        }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (o = Function.prototype[Symbol.hasInstance], Object.defineProperty(pt, Symbol.hasInstance, { value: function(zt) {
          return !!o.call(this, zt) || this === pt && zt && zt._writableState instanceof I;
        } })) : o = function(zt) {
          return zt instanceof this;
        }, pt.prototype.pipe = function() {
          jt(this, new $());
        }, pt.prototype.write = function(zt, Ct, de) {
          var ze, le = this._writableState, Ze = !1, me = !le.objectMode && (ze = zt, m.isBuffer(ze) || ze instanceof S);
          return me && !m.isBuffer(zt) && (zt = function(bn) {
            return m.from(bn);
          }(zt)), typeof Ct == "function" && (de = Ct, Ct = null), me ? Ct = "buffer" : Ct || (Ct = le.defaultEncoding), typeof de != "function" && (de = q), le.ending ? function(bn, pn) {
            var wn = new xt();
            jt(bn, wn), process.nextTick(pn, wn);
          }(this, de) : (me || function(bn, pn, wn, Yt) {
            var Ht;
            return wn === null ? Ht = new dt() : typeof wn == "string" || pn.objectMode || (Ht = new _("chunk", ["string", "Buffer"], wn)), !Ht || (jt(bn, Ht), process.nextTick(Yt, Ht), !1);
          }(this, le, zt, de)) && (le.pendingcb++, Ze = function(bn, pn, wn, Yt, Ht, Me) {
            if (!wn) {
              var X = function(gt, rt, Ft) {
                return gt.objectMode || gt.decodeStrings === !1 || typeof rt != "string" || (rt = m.from(rt, Ft)), rt;
              }(pn, Yt, Ht);
              Yt !== X && (wn = !0, Ht = "buffer", Yt = X);
            }
            var Q = pn.objectMode ? 1 : Yt.length;
            pn.length += Q;
            var C = pn.length < pn.highWaterMark;
            if (C || (pn.needDrain = !0), pn.writing || pn.corked) {
              var U = pn.lastBufferedRequest;
              pn.lastBufferedRequest = { chunk: Yt, encoding: Ht, isBuf: wn, callback: Me, next: null }, U ? U.next = pn.lastBufferedRequest : pn.bufferedRequest = pn.lastBufferedRequest, pn.bufferedRequestCount += 1;
            } else It(bn, pn, !1, Q, Yt, Ht, Me);
            return C;
          }(this, le, me, zt, Ct, de)), Ze;
        }, pt.prototype.cork = function() {
          this._writableState.corked++;
        }, pt.prototype.uncork = function() {
          var zt = this._writableState;
          zt.corked && (zt.corked--, zt.writing || zt.corked || zt.bufferProcessing || !zt.bufferedRequest || Dt(this, zt));
        }, pt.prototype.setDefaultEncoding = function(zt) {
          if (typeof zt == "string" && (zt = zt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((zt + "").toLowerCase()) > -1)) throw new Nt(zt);
          return this._writableState.defaultEncoding = zt, this;
        }, Object.defineProperty(pt.prototype, "writableBuffer", { enumerable: !1, get: function() {
          return this._writableState && this._writableState.getBuffer();
        } }), Object.defineProperty(pt.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
          return this._writableState.highWaterMark;
        } }), pt.prototype._write = function(zt, Ct, de) {
          de(new p("_write()"));
        }, pt.prototype._writev = null, pt.prototype.end = function(zt, Ct, de) {
          var ze = this._writableState;
          return typeof zt == "function" ? (de = zt, zt = null, Ct = null) : typeof Ct == "function" && (de = Ct, Ct = null), zt != null && this.write(zt, Ct), ze.corked && (ze.corked = 1, this.uncork()), ze.ending || function(le, Ze, me) {
            Ze.ending = !0, qe(le, Ze), me && (Ze.finished ? process.nextTick(me) : le.once("finish", me)), Ze.ended = !0, le.writable = !1;
          }(this, ze, de), this;
        }, Object.defineProperty(pt.prototype, "writableLength", { enumerable: !1, get: function() {
          return this._writableState.length;
        } }), Object.defineProperty(pt.prototype, "destroyed", { enumerable: !1, get: function() {
          return this._writableState !== void 0 && this._writableState.destroyed;
        }, set: function(zt) {
          this._writableState && (this._writableState.destroyed = zt);
        } }), pt.prototype.destroy = e.destroy, pt.prototype._undestroy = e.undestroy, pt.prototype._destroy = function(zt, Ct) {
          Ct(zt);
        };
      }, 5857: function(L, h, b) {
        var A;
        function l(dt, xt, Nt) {
          return (xt = function(jt) {
            var q = function(I) {
              if (typeof I != "object" || I === null) return I;
              var pt = I[Symbol.toPrimitive];
              if (pt !== void 0) {
                var It = pt.call(I, "string");
                if (typeof It != "object") return It;
                throw new TypeError("@@toPrimitive must return a primitive value.");
              }
              return String(I);
            }(jt);
            return typeof q == "symbol" ? q : String(q);
          }(xt)) in dt ? Object.defineProperty(dt, xt, { value: Nt, enumerable: !0, configurable: !0, writable: !0 }) : dt[xt] = Nt, dt;
        }
        var o = b(2896), u = Symbol("lastResolve"), g = Symbol("lastReject"), m = Symbol("error"), S = Symbol("ended"), e = Symbol("lastPromise"), n = Symbol("handlePromise"), d = Symbol("stream");
        function _(dt, xt) {
          return { value: dt, done: xt };
        }
        function p(dt) {
          var xt = dt[u];
          if (xt !== null) {
            var Nt = dt[d].read();
            Nt !== null && (dt[e] = null, dt[u] = null, dt[g] = null, xt(_(Nt, !1)));
          }
        }
        function P(dt) {
          process.nextTick(p, dt);
        }
        var $ = Object.getPrototypeOf(function() {
        }), ot = Object.setPrototypeOf((l(A = { get stream() {
          return this[d];
        }, next: function() {
          var dt = this, xt = this[m];
          if (xt !== null) return Promise.reject(xt);
          if (this[S]) return Promise.resolve(_(void 0, !0));
          if (this[d].destroyed) return new Promise(function(I, pt) {
            process.nextTick(function() {
              dt[m] ? pt(dt[m]) : I(_(void 0, !0));
            });
          });
          var Nt, jt = this[e];
          if (jt) Nt = new Promise(/* @__PURE__ */ function(I, pt) {
            return function(It, et) {
              I.then(function() {
                pt[S] ? It(_(void 0, !0)) : pt[n](It, et);
              }, et);
            };
          }(jt, this));
          else {
            var q = this[d].read();
            if (q !== null) return Promise.resolve(_(q, !1));
            Nt = new Promise(this[n]);
          }
          return this[e] = Nt, Nt;
        } }, Symbol.asyncIterator, function() {
          return this;
        }), l(A, "return", function() {
          var dt = this;
          return new Promise(function(xt, Nt) {
            dt[d].destroy(null, function(jt) {
              jt ? Nt(jt) : xt(_(void 0, !0));
            });
          });
        }), A), $);
        L.exports = function(dt) {
          var xt, Nt = Object.create(ot, (l(xt = {}, d, { value: dt, writable: !0 }), l(xt, u, { value: null, writable: !0 }), l(xt, g, { value: null, writable: !0 }), l(xt, m, { value: null, writable: !0 }), l(xt, S, { value: dt._readableState.endEmitted, writable: !0 }), l(xt, n, { value: function(jt, q) {
            var I = Nt[d].read();
            I ? (Nt[e] = null, Nt[u] = null, Nt[g] = null, jt(_(I, !1))) : (Nt[u] = jt, Nt[g] = q);
          }, writable: !0 }), xt));
          return Nt[e] = null, o(dt, function(jt) {
            if (jt && jt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              var q = Nt[g];
              return q !== null && (Nt[e] = null, Nt[u] = null, Nt[g] = null, q(jt)), void (Nt[m] = jt);
            }
            var I = Nt[u];
            I !== null && (Nt[e] = null, Nt[u] = null, Nt[g] = null, I(_(void 0, !0))), Nt[S] = !0;
          }), dt.on("readable", P.bind(null, Nt)), Nt;
        };
      }, 3791: function(L, h, b) {
        function A(n, d) {
          var _ = Object.keys(n);
          if (Object.getOwnPropertySymbols) {
            var p = Object.getOwnPropertySymbols(n);
            d && (p = p.filter(function(P) {
              return Object.getOwnPropertyDescriptor(n, P).enumerable;
            })), _.push.apply(_, p);
          }
          return _;
        }
        function l(n) {
          for (var d = 1; d < arguments.length; d++) {
            var _ = arguments[d] != null ? arguments[d] : {};
            d % 2 ? A(Object(_), !0).forEach(function(p) {
              o(n, p, _[p]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(_)) : A(Object(_)).forEach(function(p) {
              Object.defineProperty(n, p, Object.getOwnPropertyDescriptor(_, p));
            });
          }
          return n;
        }
        function o(n, d, _) {
          return (d = g(d)) in n ? Object.defineProperty(n, d, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : n[d] = _, n;
        }
        function u(n, d) {
          for (var _ = 0; _ < d.length; _++) {
            var p = d[_];
            p.enumerable = p.enumerable || !1, p.configurable = !0, "value" in p && (p.writable = !0), Object.defineProperty(n, g(p.key), p);
          }
        }
        function g(n) {
          var d = function(_) {
            if (typeof _ != "object" || _ === null) return _;
            var p = _[Symbol.toPrimitive];
            if (p !== void 0) {
              var P = p.call(_, "string");
              if (typeof P != "object") return P;
              throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return String(_);
          }(n);
          return typeof d == "symbol" ? d : String(d);
        }
        var m = b(44).Buffer, S = b(3779).inspect, e = S && S.custom || "inspect";
        L.exports = function() {
          function n() {
            (function(p, P) {
              if (!(p instanceof P)) throw new TypeError("Cannot call a class as a function");
            })(this, n), this.head = null, this.tail = null, this.length = 0;
          }
          var d, _;
          return d = n, (_ = [{ key: "push", value: function(p) {
            var P = { data: p, next: null };
            this.length > 0 ? this.tail.next = P : this.head = P, this.tail = P, ++this.length;
          } }, { key: "unshift", value: function(p) {
            var P = { data: p, next: this.head };
            this.length === 0 && (this.tail = P), this.head = P, ++this.length;
          } }, { key: "shift", value: function() {
            if (this.length !== 0) {
              var p = this.head.data;
              return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, p;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(p) {
            if (this.length === 0) return "";
            for (var P = this.head, $ = "" + P.data; P = P.next; ) $ += p + P.data;
            return $;
          } }, { key: "concat", value: function(p) {
            if (this.length === 0) return m.alloc(0);
            for (var P, $, ot, dt = m.allocUnsafe(p >>> 0), xt = this.head, Nt = 0; xt; ) P = xt.data, $ = dt, ot = Nt, m.prototype.copy.call(P, $, ot), Nt += xt.data.length, xt = xt.next;
            return dt;
          } }, { key: "consume", value: function(p, P) {
            var $;
            return p < this.head.data.length ? ($ = this.head.data.slice(0, p), this.head.data = this.head.data.slice(p)) : $ = p === this.head.data.length ? this.shift() : P ? this._getString(p) : this._getBuffer(p), $;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(p) {
            var P = this.head, $ = 1, ot = P.data;
            for (p -= ot.length; P = P.next; ) {
              var dt = P.data, xt = p > dt.length ? dt.length : p;
              if (xt === dt.length ? ot += dt : ot += dt.slice(0, p), (p -= xt) == 0) {
                xt === dt.length ? (++$, P.next ? this.head = P.next : this.head = this.tail = null) : (this.head = P, P.data = dt.slice(xt));
                break;
              }
              ++$;
            }
            return this.length -= $, ot;
          } }, { key: "_getBuffer", value: function(p) {
            var P = m.allocUnsafe(p), $ = this.head, ot = 1;
            for ($.data.copy(P), p -= $.data.length; $ = $.next; ) {
              var dt = $.data, xt = p > dt.length ? dt.length : p;
              if (dt.copy(P, P.length - p, 0, xt), (p -= xt) == 0) {
                xt === dt.length ? (++ot, $.next ? this.head = $.next : this.head = this.tail = null) : (this.head = $, $.data = dt.slice(xt));
                break;
              }
              ++ot;
            }
            return this.length -= ot, P;
          } }, { key: e, value: function(p, P) {
            return S(this, l(l({}, P), {}, { depth: 0, customInspect: !1 }));
          } }]) && u(d.prototype, _), Object.defineProperty(d, "prototype", { writable: !1 }), n;
        }();
      }, 2410: function(L) {
        function h(l, o) {
          A(l, o), b(l);
        }
        function b(l) {
          l._writableState && !l._writableState.emitClose || l._readableState && !l._readableState.emitClose || l.emit("close");
        }
        function A(l, o) {
          l.emit("error", o);
        }
        L.exports = { destroy: function(l, o) {
          var u = this, g = this._readableState && this._readableState.destroyed, m = this._writableState && this._writableState.destroyed;
          return g || m ? (o ? o(l) : l && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(A, this, l)) : process.nextTick(A, this, l)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(l || null, function(S) {
            !o && S ? u._writableState ? u._writableState.errorEmitted ? process.nextTick(b, u) : (u._writableState.errorEmitted = !0, process.nextTick(h, u, S)) : process.nextTick(h, u, S) : o ? (process.nextTick(b, u), o(S)) : process.nextTick(b, u);
          }), this);
        }, undestroy: function() {
          this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
        }, errorOrDestroy: function(l, o) {
          var u = l._readableState, g = l._writableState;
          u && u.autoDestroy || g && g.autoDestroy ? l.destroy(o) : l.emit("error", o);
        } };
      }, 2896: function(L, h, b) {
        var A = b(1602).F.ERR_STREAM_PREMATURE_CLOSE;
        function l() {
        }
        L.exports = function o(u, g, m) {
          if (typeof g == "function") return o(u, null, g);
          g || (g = {}), m = /* @__PURE__ */ function(xt) {
            var Nt = !1;
            return function() {
              if (!Nt) {
                Nt = !0;
                for (var jt = arguments.length, q = new Array(jt), I = 0; I < jt; I++) q[I] = arguments[I];
                xt.apply(this, q);
              }
            };
          }(m || l);
          var S = g.readable || g.readable !== !1 && u.readable, e = g.writable || g.writable !== !1 && u.writable, n = function() {
            u.writable || _();
          }, d = u._writableState && u._writableState.finished, _ = function() {
            e = !1, d = !0, S || m.call(u);
          }, p = u._readableState && u._readableState.endEmitted, P = function() {
            S = !1, p = !0, e || m.call(u);
          }, $ = function(xt) {
            m.call(u, xt);
          }, ot = function() {
            var xt;
            return S && !p ? (u._readableState && u._readableState.ended || (xt = new A()), m.call(u, xt)) : e && !d ? (u._writableState && u._writableState.ended || (xt = new A()), m.call(u, xt)) : void 0;
          }, dt = function() {
            u.req.on("finish", _);
          };
          return function(xt) {
            return xt.setHeader && typeof xt.abort == "function";
          }(u) ? (u.on("complete", _), u.on("abort", ot), u.req ? dt() : u.on("request", dt)) : e && !u._writableState && (u.on("end", n), u.on("close", n)), u.on("end", P), u.on("finish", _), g.error !== !1 && u.on("error", $), u.on("close", ot), function() {
            u.removeListener("complete", _), u.removeListener("abort", ot), u.removeListener("request", dt), u.req && u.req.removeListener("finish", _), u.removeListener("end", n), u.removeListener("close", n), u.removeListener("finish", _), u.removeListener("end", P), u.removeListener("error", $), u.removeListener("close", ot);
          };
        };
      }, 3411: function(L) {
        L.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, 8460: function(L, h, b) {
        var A, l = b(1602).F, o = l.ERR_MISSING_ARGS, u = l.ERR_STREAM_DESTROYED;
        function g(e) {
          if (e) throw e;
        }
        function m(e) {
          e();
        }
        function S(e, n) {
          return e.pipe(n);
        }
        L.exports = function() {
          for (var e = arguments.length, n = new Array(e), d = 0; d < e; d++) n[d] = arguments[d];
          var _, p = function($) {
            return $.length ? typeof $[$.length - 1] != "function" ? g : $.pop() : g;
          }(n);
          if (Array.isArray(n[0]) && (n = n[0]), n.length < 2) throw new o("streams");
          var P = n.map(function($, ot) {
            var dt = ot < n.length - 1;
            return function(xt, Nt, jt, q) {
              q = /* @__PURE__ */ function(It) {
                var et = !1;
                return function() {
                  et || (et = !0, It.apply(void 0, arguments));
                };
              }(q);
              var I = !1;
              xt.on("close", function() {
                I = !0;
              }), A === void 0 && (A = b(2896)), A(xt, { readable: Nt, writable: jt }, function(It) {
                if (It) return q(It);
                I = !0, q();
              });
              var pt = !1;
              return function(It) {
                if (!I && !pt) return pt = !0, function(et) {
                  return et.setHeader && typeof et.abort == "function";
                }(xt) ? xt.abort() : typeof xt.destroy == "function" ? xt.destroy() : void q(It || new u("pipe"));
              };
            }($, dt, ot > 0, function(xt) {
              _ || (_ = xt), xt && P.forEach(m), dt || (P.forEach(m), p(_));
            });
          });
          return n.reduce(S);
        };
      }, 1749: function(L, h, b) {
        var A = b(1602).F.ERR_INVALID_OPT_VALUE;
        L.exports = { getHighWaterMark: function(l, o, u, g) {
          var m = function(S, e, n) {
            return S.highWaterMark != null ? S.highWaterMark : e ? S[n] : null;
          }(o, g, u);
          if (m != null) {
            if (!isFinite(m) || Math.floor(m) !== m || m < 0) throw new A(g ? u : "highWaterMark", m);
            return Math.floor(m);
          }
          return l.objectMode ? 16 : 16384;
        } };
      }, 2611: function(L, h, b) {
        L.exports = b(9826).EventEmitter;
      }, 748: function(L, h, b) {
        var A = b(4598).Buffer, l = A.isEncoding || function(p) {
          switch ((p = "" + p) && p.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return !0;
            default:
              return !1;
          }
        };
        function o(p) {
          var P;
          switch (this.encoding = function($) {
            var ot = function(dt) {
              if (!dt) return "utf8";
              for (var xt; ; ) switch (dt) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return dt;
                default:
                  if (xt) return;
                  dt = ("" + dt).toLowerCase(), xt = !0;
              }
            }($);
            if (typeof ot != "string" && (A.isEncoding === l || !l($))) throw new Error("Unknown encoding: " + $);
            return ot || $;
          }(p), this.encoding) {
            case "utf16le":
              this.text = m, this.end = S, P = 4;
              break;
            case "utf8":
              this.fillLast = g, P = 4;
              break;
            case "base64":
              this.text = e, this.end = n, P = 3;
              break;
            default:
              return this.write = d, void (this.end = _);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(P);
        }
        function u(p) {
          return p <= 127 ? 0 : p >> 5 == 6 ? 2 : p >> 4 == 14 ? 3 : p >> 3 == 30 ? 4 : p >> 6 == 2 ? -1 : -2;
        }
        function g(p) {
          var P = this.lastTotal - this.lastNeed, $ = function(ot, dt) {
            if ((192 & dt[0]) != 128) return ot.lastNeed = 0, "�";
            if (ot.lastNeed > 1 && dt.length > 1) {
              if ((192 & dt[1]) != 128) return ot.lastNeed = 1, "�";
              if (ot.lastNeed > 2 && dt.length > 2 && (192 & dt[2]) != 128) return ot.lastNeed = 2, "�";
            }
          }(this, p);
          return $ !== void 0 ? $ : this.lastNeed <= p.length ? (p.copy(this.lastChar, P, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (p.copy(this.lastChar, P, 0, p.length), void (this.lastNeed -= p.length));
        }
        function m(p, P) {
          if ((p.length - P) % 2 == 0) {
            var $ = p.toString("utf16le", P);
            if ($) {
              var ot = $.charCodeAt($.length - 1);
              if (ot >= 55296 && ot <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1], $.slice(0, -1);
            }
            return $;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = p[p.length - 1], p.toString("utf16le", P, p.length - 1);
        }
        function S(p) {
          var P = p && p.length ? this.write(p) : "";
          if (this.lastNeed) {
            var $ = this.lastTotal - this.lastNeed;
            return P + this.lastChar.toString("utf16le", 0, $);
          }
          return P;
        }
        function e(p, P) {
          var $ = (p.length - P) % 3;
          return $ === 0 ? p.toString("base64", P) : (this.lastNeed = 3 - $, this.lastTotal = 3, $ === 1 ? this.lastChar[0] = p[p.length - 1] : (this.lastChar[0] = p[p.length - 2], this.lastChar[1] = p[p.length - 1]), p.toString("base64", P, p.length - $));
        }
        function n(p) {
          var P = p && p.length ? this.write(p) : "";
          return this.lastNeed ? P + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : P;
        }
        function d(p) {
          return p.toString(this.encoding);
        }
        function _(p) {
          return p && p.length ? this.write(p) : "";
        }
        h.I = o, o.prototype.write = function(p) {
          if (p.length === 0) return "";
          var P, $;
          if (this.lastNeed) {
            if ((P = this.fillLast(p)) === void 0) return "";
            $ = this.lastNeed, this.lastNeed = 0;
          } else $ = 0;
          return $ < p.length ? P ? P + this.text(p, $) : this.text(p, $) : P || "";
        }, o.prototype.end = function(p) {
          var P = p && p.length ? this.write(p) : "";
          return this.lastNeed ? P + "�" : P;
        }, o.prototype.text = function(p, P) {
          var $ = function(dt, xt, Nt) {
            var jt = xt.length - 1;
            if (jt < Nt) return 0;
            var q = u(xt[jt]);
            return q >= 0 ? (q > 0 && (dt.lastNeed = q - 1), q) : --jt < Nt || q === -2 ? 0 : (q = u(xt[jt])) >= 0 ? (q > 0 && (dt.lastNeed = q - 2), q) : --jt < Nt || q === -2 ? 0 : (q = u(xt[jt])) >= 0 ? (q > 0 && (q === 2 ? q = 0 : dt.lastNeed = q - 3), q) : 0;
          }(this, p, P);
          if (!this.lastNeed) return p.toString("utf8", P);
          this.lastTotal = $;
          var ot = p.length - ($ - this.lastNeed);
          return p.copy(this.lastChar, 0, ot), p.toString("utf8", P, ot);
        }, o.prototype.fillLast = function(p) {
          if (this.lastNeed <= p.length) return p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          p.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, p.length), this.lastNeed -= p.length;
        };
      }, 4598: function(L, h, b) {
        var A = b(44), l = A.Buffer;
        function o(g, m) {
          for (var S in g) m[S] = g[S];
        }
        function u(g, m, S) {
          return l(g, m, S);
        }
        l.from && l.alloc && l.allocUnsafe && l.allocUnsafeSlow ? L.exports = A : (o(A, h), h.Buffer = u), o(l, u), u.from = function(g, m, S) {
          if (typeof g == "number") throw new TypeError("Argument must not be a number");
          return l(g, m, S);
        }, u.alloc = function(g, m, S) {
          if (typeof g != "number") throw new TypeError("Argument must be a number");
          var e = l(g);
          return m !== void 0 ? typeof S == "string" ? e.fill(m, S) : e.fill(m) : e.fill(0), e;
        }, u.allocUnsafe = function(g) {
          if (typeof g != "number") throw new TypeError("Argument must be a number");
          return l(g);
        }, u.allocUnsafeSlow = function(g) {
          if (typeof g != "number") throw new TypeError("Argument must be a number");
          return A.SlowBuffer(g);
        };
      }, 8571: function(L, h, b) {
        var A;
        (function(l, o) {
          var u = "function", g = "undefined", m = "object", S = "string", e = "major", n = "model", d = "name", _ = "type", p = "vendor", P = "version", $ = "architecture", ot = "console", dt = "mobile", xt = "tablet", Nt = "smarttv", jt = "wearable", q = "embedded", I = "Amazon", pt = "Apple", It = "ASUS", et = "BlackBerry", Dt = "Browser", ae = "Chrome", St = "Firefox", qe = "Google", zt = "Huawei", Ct = "LG", de = "Microsoft", ze = "Motorola", le = "Opera", Ze = "Samsung", me = "Sharp", bn = "Sony", pn = "Xiaomi", wn = "Zebra", Yt = "Facebook", Ht = "Chromium OS", Me = "Mac OS", X = function(Gt) {
            for (var se = {}, Jt = 0; Jt < Gt.length; Jt++) se[Gt[Jt].toUpperCase()] = Gt[Jt];
            return se;
          }, Q = function(Gt, se) {
            return typeof Gt === S && C(se).indexOf(C(Gt)) !== -1;
          }, C = function(Gt) {
            return Gt.toLowerCase();
          }, U = function(Gt, se) {
            if (typeof Gt === S) return Gt = Gt.replace(/^\s\s*/, ""), typeof se === g ? Gt : Gt.substring(0, 500);
          }, gt = function(Gt, se) {
            for (var Jt, he, an, Fe, ke, ce, je = 0; je < se.length && !ke; ) {
              var ii = se[je], Wn = se[je + 1];
              for (Jt = he = 0; Jt < ii.length && !ke && ii[Jt]; ) if (ke = ii[Jt++].exec(Gt)) for (an = 0; an < Wn.length; an++) ce = ke[++he], typeof (Fe = Wn[an]) === m && Fe.length > 0 ? Fe.length === 2 ? typeof Fe[1] == u ? this[Fe[0]] = Fe[1].call(this, ce) : this[Fe[0]] = Fe[1] : Fe.length === 3 ? typeof Fe[1] !== u || Fe[1].exec && Fe[1].test ? this[Fe[0]] = ce ? ce.replace(Fe[1], Fe[2]) : o : this[Fe[0]] = ce ? Fe[1].call(this, ce, Fe[2]) : o : Fe.length === 4 && (this[Fe[0]] = ce ? Fe[3].call(this, ce.replace(Fe[1], Fe[2])) : o) : this[Fe] = ce || o;
              je += 2;
            }
          }, rt = function(Gt, se) {
            for (var Jt in se) if (typeof se[Jt] === m && se[Jt].length > 0) {
              for (var he = 0; he < se[Jt].length; he++) if (Q(se[Jt][he], Gt)) return Jt === "?" ? o : Jt;
            } else if (Q(se[Jt], Gt)) return Jt === "?" ? o : Jt;
            return Gt;
          }, Ft = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ne = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [P, [d, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [P, [d, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [d, P], [/opios[\/ ]+([\w\.]+)/i], [P, [d, le + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [P, [d, le + " GX"]], [/\bopr\/([\w\.]+)/i], [P, [d, le]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [P, [d, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [d, P], [/\bddg\/([\w\.]+)/i], [P, [d, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [P, [d, "UC" + Dt]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [P, [d, "WeChat"]], [/konqueror\/([\w\.]+)/i], [P, [d, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [P, [d, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [P, [d, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [P, [d, "Smart Lenovo " + Dt]], [/(avast|avg)\/([\w\.]+)/i], [[d, /(.+)/, "$1 Secure " + Dt], P], [/\bfocus\/([\w\.]+)/i], [P, [d, St + " Focus"]], [/\bopt\/([\w\.]+)/i], [P, [d, le + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [P, [d, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [P, [d, "Dolphin"]], [/coast\/([\w\.]+)/i], [P, [d, le + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [P, [d, "MIUI " + Dt]], [/fxios\/([-\w\.]+)/i], [P, [d, St]], [/\bqihu|(qi?ho?o?|360)browser/i], [[d, "360 " + Dt]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[d, /(.+)/, "$1 " + Dt], P], [/samsungbrowser\/([\w\.]+)/i], [P, [d, Ze + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[d, /_/g, " "], P], [/metasr[\/ ]?([\d\.]+)/i], [P, [d, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[d, "Sogou Mobile"], P], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [d, P], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [d], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[d, Yt], P], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [d, P], [/\bgsa\/([\w\.]+) .*safari\//i], [P, [d, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [P, [d, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [P, [d, ae + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[d, ae + " WebView"], P], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [P, [d, "Android " + Dt]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [d, P], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [P, [d, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [P, d], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [d, [P, rt, { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }]], [/(webkit|khtml)\/([\w\.]+)/i], [d, P], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[d, "Netscape"], P], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [P, [d, St + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [d, P], [/(cobalt)\/([\w\.]+)/i], [d, [P, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[$, "amd64"]], [/(ia32(?=;))/i], [[$, C]], [/((?:i[346]|x)86)[;\)]/i], [[$, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[$, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[$, "armhf"]], [/windows (ce|mobile); ppc;/i], [[$, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[$, /ower/, "", C]], [/(sun4\w)[;\)]/i], [[$, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[$, C]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [n, [p, Ze], [_, xt]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [n, [p, Ze], [_, dt]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [n, [p, pt], [_, dt]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [n, [p, pt], [_, xt]], [/(macintosh);/i], [n, [p, pt]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [n, [p, me], [_, dt]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [n, [p, zt], [_, xt]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [n, [p, zt], [_, dt]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[n, /_/g, " "], [p, pn], [_, dt]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[n, /_/g, " "], [p, pn], [_, xt]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [n, [p, "OPPO"], [_, dt]], [/\b(opd2\d{3}a?) bui/i], [n, [p, "OPPO"], [_, xt]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [n, [p, "Vivo"], [_, dt]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [n, [p, "Realme"], [_, dt]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [n, [p, ze], [_, dt]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [n, [p, ze], [_, xt]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [n, [p, Ct], [_, xt]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [n, [p, Ct], [_, dt]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [n, [p, "Lenovo"], [_, xt]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[n, /_/g, " "], [p, "Nokia"], [_, dt]], [/(pixel c)\b/i], [n, [p, qe], [_, xt]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [n, [p, qe], [_, dt]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [n, [p, bn], [_, dt]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[n, "Xperia Tablet"], [p, bn], [_, xt]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [n, [p, "OnePlus"], [_, dt]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [n, [p, I], [_, xt]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[n, /(.+)/g, "Fire Phone $1"], [p, I], [_, dt]], [/(playbook);[-\w\),; ]+(rim)/i], [n, p, [_, xt]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [n, [p, et], [_, dt]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [n, [p, It], [_, xt]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [n, [p, It], [_, dt]], [/(nexus 9)/i], [n, [p, "HTC"], [_, xt]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [p, [n, /_/g, " "], [_, dt]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [n, [p, "Acer"], [_, xt]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [n, [p, "Meizu"], [_, dt]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [n, [p, "Ulefone"], [_, dt]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [p, n, [_, dt]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [p, n, [_, xt]], [/(surface duo)/i], [n, [p, de], [_, xt]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [n, [p, "Fairphone"], [_, dt]], [/(u304aa)/i], [n, [p, "AT&T"], [_, dt]], [/\bsie-(\w*)/i], [n, [p, "Siemens"], [_, dt]], [/\b(rct\w+) b/i], [n, [p, "RCA"], [_, xt]], [/\b(venue[\d ]{2,7}) b/i], [n, [p, "Dell"], [_, xt]], [/\b(q(?:mv|ta)\w+) b/i], [n, [p, "Verizon"], [_, xt]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [n, [p, "Barnes & Noble"], [_, xt]], [/\b(tm\d{3}\w+) b/i], [n, [p, "NuVision"], [_, xt]], [/\b(k88) b/i], [n, [p, "ZTE"], [_, xt]], [/\b(nx\d{3}j) b/i], [n, [p, "ZTE"], [_, dt]], [/\b(gen\d{3}) b.+49h/i], [n, [p, "Swiss"], [_, dt]], [/\b(zur\d{3}) b/i], [n, [p, "Swiss"], [_, xt]], [/\b((zeki)?tb.*\b) b/i], [n, [p, "Zeki"], [_, xt]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[p, "Dragon Touch"], n, [_, xt]], [/\b(ns-?\w{0,9}) b/i], [n, [p, "Insignia"], [_, xt]], [/\b((nxa|next)-?\w{0,9}) b/i], [n, [p, "NextBook"], [_, xt]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[p, "Voice"], n, [_, dt]], [/\b(lvtel\-)?(v1[12]) b/i], [[p, "LvTel"], n, [_, dt]], [/\b(ph-1) /i], [n, [p, "Essential"], [_, dt]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [n, [p, "Envizen"], [_, xt]], [/\b(trio[-\w\. ]+) b/i], [n, [p, "MachSpeed"], [_, xt]], [/\btu_(1491) b/i], [n, [p, "Rotor"], [_, xt]], [/(shield[\w ]+) b/i], [n, [p, "Nvidia"], [_, xt]], [/(sprint) (\w+)/i], [p, n, [_, dt]], [/(kin\.[onetw]{3})/i], [[n, /\./g, " "], [p, de], [_, dt]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [n, [p, wn], [_, xt]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [n, [p, wn], [_, dt]], [/smart-tv.+(samsung)/i], [p, [_, Nt]], [/hbbtv.+maple;(\d+)/i], [[n, /^/, "SmartTV"], [p, Ze], [_, Nt]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[p, Ct], [_, Nt]], [/(apple) ?tv/i], [p, [n, pt + " TV"], [_, Nt]], [/crkey/i], [[n, ae + "cast"], [p, qe], [_, Nt]], [/droid.+aft(\w+)( bui|\))/i], [n, [p, I], [_, Nt]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [n, [p, me], [_, Nt]], [/(bravia[\w ]+)( bui|\))/i], [n, [p, bn], [_, Nt]], [/(mitv-\w{5}) bui/i], [n, [p, pn], [_, Nt]], [/Hbbtv.*(technisat) (.*);/i], [p, n, [_, Nt]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[p, U], [n, U], [_, Nt]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[_, Nt]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [p, n, [_, ot]], [/droid.+; (shield) bui/i], [n, [p, "Nvidia"], [_, ot]], [/(playstation [345portablevi]+)/i], [n, [p, bn], [_, ot]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [n, [p, de], [_, ot]], [/((pebble))app/i], [p, n, [_, jt]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [n, [p, pt], [_, jt]], [/droid.+; (glass) \d/i], [n, [p, qe], [_, jt]], [/droid.+; (wt63?0{2,3})\)/i], [n, [p, wn], [_, jt]], [/(quest( \d| pro)?)/i], [n, [p, Yt], [_, jt]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [p, [_, q]], [/(aeobc)\b/i], [n, [p, I], [_, q]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [n, [_, dt]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [n, [_, xt]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[_, xt]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[_, dt]], [/(android[-\w\. ]{0,9});.+buil/i], [n, [p, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [P, [d, "EdgeHTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [P, [d, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [d, P], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [P, d]], os: [[/microsoft (windows) (vista|xp)/i], [d, P], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [d, [P, rt, Ft]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[P, rt, Ft], [d, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[P, /_/g, "."], [d, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[d, Me], [P, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [P, d], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [d, P], [/\(bb(10);/i], [P, [d, et]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [P, [d, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [P, [d, St + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [P, [d, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [P, [d, "watchOS"]], [/crkey\/([\d\.]+)/i], [P, [d, ae + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[d, Ht], P], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [d, P], [/(sunos) ?([\w\.\d]*)/i], [[d, "Solaris"], P], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [d, P]] }, Vt = function(Gt, se) {
            if (typeof Gt === m && (se = Gt, Gt = o), !(this instanceof Vt)) return new Vt(Gt, se).getResult();
            var Jt = typeof l !== g && l.navigator ? l.navigator : o, he = Gt || (Jt && Jt.userAgent ? Jt.userAgent : ""), an = Jt && Jt.userAgentData ? Jt.userAgentData : o, Fe = se ? function(ce, je) {
              var ii = {};
              for (var Wn in ce) je[Wn] && je[Wn].length % 2 == 0 ? ii[Wn] = je[Wn].concat(ce[Wn]) : ii[Wn] = ce[Wn];
              return ii;
            }(ne, se) : ne, ke = Jt && Jt.userAgent == he;
            return this.getBrowser = function() {
              var ce, je = {};
              return je[d] = o, je[P] = o, gt.call(je, he, Fe.browser), je[e] = typeof (ce = je[P]) === S ? ce.replace(/[^\d\.]/g, "").split(".")[0] : o, ke && Jt && Jt.brave && typeof Jt.brave.isBrave == u && (je[d] = "Brave"), je;
            }, this.getCPU = function() {
              var ce = {};
              return ce[$] = o, gt.call(ce, he, Fe.cpu), ce;
            }, this.getDevice = function() {
              var ce = {};
              return ce[p] = o, ce[n] = o, ce[_] = o, gt.call(ce, he, Fe.device), ke && !ce[_] && an && an.mobile && (ce[_] = dt), ke && ce[n] == "Macintosh" && Jt && typeof Jt.standalone !== g && Jt.maxTouchPoints && Jt.maxTouchPoints > 2 && (ce[n] = "iPad", ce[_] = xt), ce;
            }, this.getEngine = function() {
              var ce = {};
              return ce[d] = o, ce[P] = o, gt.call(ce, he, Fe.engine), ce;
            }, this.getOS = function() {
              var ce = {};
              return ce[d] = o, ce[P] = o, gt.call(ce, he, Fe.os), ke && !ce[d] && an && an.platform && an.platform != "Unknown" && (ce[d] = an.platform.replace(/chrome os/i, Ht).replace(/macos/i, Me)), ce;
            }, this.getResult = function() {
              return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
            }, this.getUA = function() {
              return he;
            }, this.setUA = function(ce) {
              return he = typeof ce === S && ce.length > 500 ? U(ce, 500) : ce, this;
            }, this.setUA(he), this;
          };
          Vt.VERSION = "1.0.38", Vt.BROWSER = X([d, P, e]), Vt.CPU = X([$]), Vt.DEVICE = X([n, p, _, ot, dt, Nt, xt, jt, q]), Vt.ENGINE = Vt.OS = X([d, P]), typeof h !== g ? (L.exports && (h = L.exports = Vt), h.UAParser = Vt) : b.amdO ? (A = (function() {
            return Vt;
          }).call(h, b, h, L)) === o || (L.exports = A) : typeof l !== g && (l.UAParser = Vt);
          var Xt = typeof l !== g && (l.jQuery || l.Zepto);
          if (Xt && !Xt.ua) {
            var qt = new Vt();
            Xt.ua = qt.getResult(), Xt.ua.get = function() {
              return qt.getUA();
            }, Xt.ua.set = function(Gt) {
              qt.setUA(Gt);
              var se = qt.getResult();
              for (var Jt in se) Xt.ua[Jt] = se[Jt];
            };
          }
        })(typeof window == "object" ? window : this);
      }, 9e3: function(L, h, b) {
        function A(l) {
          try {
            if (!b.g.localStorage) return !1;
          } catch {
            return !1;
          }
          var o = b.g.localStorage[l];
          return o != null && String(o).toLowerCase() === "true";
        }
        L.exports = function(l, o) {
          if (A("noDeprecation")) return l;
          var u = !1;
          return function() {
            if (!u) {
              if (A("throwDeprecation")) throw new Error(o);
              A("traceDeprecation") ? console.trace(o) : console.warn(o), u = !0;
            }
            return l.apply(this, arguments);
          };
        };
      }, 3779: function() {
      }, 7199: function() {
      }, 5393: function(L, h, b) {
        var A = b(6161), l = b(138), o = b(649), u = b(8986), g = typeof window < "u" && window || Zh, m = g.dashjs;
        m || (m = g.dashjs = {}), m.MediaPlayer = A.A, m.FactoryMaker = l.A, m.Debug = o.A, m.Version = (0, u.i)();
      }, 649: function(L, h, b) {
        var A = b(8850), l = b(3621), o = b(138);
        function u(m) {
          m = m || {};
          const S = this.context, e = (0, A.A)(S).getInstance(), n = m.settings, d = [];
          let _, p, P, $;
          function ot(pt) {
            return pt && pt.bind ? pt.bind(window.console) : window.console.log.bind(window.console);
          }
          function dt() {
            for (var pt = arguments.length, It = new Array(pt), et = 0; et < pt; et++) It[et] = arguments[et];
            I(1, this, ...It);
          }
          function xt() {
            for (var pt = arguments.length, It = new Array(pt), et = 0; et < pt; et++) It[et] = arguments[et];
            I(2, this, ...It);
          }
          function Nt() {
            for (var pt = arguments.length, It = new Array(pt), et = 0; et < pt; et++) It[et] = arguments[et];
            I(3, this, ...It);
          }
          function jt() {
            for (var pt = arguments.length, It = new Array(pt), et = 0; et < pt; et++) It[et] = arguments[et];
            I(4, this, ...It);
          }
          function q() {
            for (var pt = arguments.length, It = new Array(pt), et = 0; et < pt; et++) It[et] = arguments[et];
            I(5, this, ...It);
          }
          function I(pt, It) {
            let et = "", Dt = null;
            p && (Dt = (/* @__PURE__ */ new Date()).getTime(), et += "[" + (Dt - $) + "]"), P && It && It.getClassName && (et += "[" + It.getClassName() + "]", It.getType && (et += "[" + It.getType() + "]")), et.length > 0 && (et += " ");
            for (var ae = arguments.length, St = new Array(ae > 2 ? ae - 2 : 0), qe = 2; qe < ae; qe++) St[qe - 2] = arguments[qe];
            Array.apply(null, St).forEach(function(zt) {
              et += zt + " ";
            }), d[pt] && n && n.get().debug.logLevel >= pt && d[pt](et), n && n.get().debug.dispatchEvent && e.trigger(l.A.LOG, { message: et, level: pt });
          }
          return _ = { getLogger: function(pt) {
            return { fatal: dt.bind(pt), error: xt.bind(pt), warn: Nt.bind(pt), info: jt.bind(pt), debug: q.bind(pt) };
          }, setLogTimestampVisible: function(pt) {
            p = pt;
          }, setCalleeNameVisible: function(pt) {
            P = pt;
          } }, p = !0, P = !0, $ = (/* @__PURE__ */ new Date()).getTime(), typeof window < "u" && window.console && (d[1] = ot(window.console.error), d[2] = ot(window.console.error), d[3] = ot(window.console.warn), d[4] = ot(window.console.info), d[5] = ot(window.console.debug)), _;
        }
        u.__dashjs_factory_name = "Debug";
        const g = o.A.getSingletonFactory(u);
        g.LOG_LEVEL_NONE = 0, g.LOG_LEVEL_FATAL = 1, g.LOG_LEVEL_ERROR = 2, g.LOG_LEVEL_WARNING = 3, g.LOG_LEVEL_INFO = 4, g.LOG_LEVEL_DEBUG = 5, o.A.updateSingletonFactory(u.__dashjs_factory_name, g), h.A = g;
      }, 8850: function(L, h, b) {
        var A = b(138), l = b(1191);
        function o() {
          let g = {};
          function m(d, _, p) {
            let P = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, $ = arguments.length > 4 && arguments[4] !== void 0 && arguments[4];
            if (!d) throw new Error("event type cannot be null or undefined");
            if (!_ || typeof _ != "function") throw new Error("listener must be a function: " + _);
            let ot = P.priority || 0;
            if (e(d, _, p) >= 0) return;
            g[d] = g[d] || [];
            const dt = { callback: _, scope: p, priority: ot, executeOnlyOnce: $ };
            p && p.getStreamId && (dt.streamId = p.getStreamId()), p && p.getType && (dt.mediaType = p.getType()), P && P.mode && (dt.mode = P.mode), g[d].some((xt, Nt) => {
              if (xt && ot > xt.priority) return g[d].splice(Nt, 0, dt), !0;
            }) || g[d].push(dt);
          }
          function S(d, _, p) {
            if (!d || !_ || !g[d]) return;
            const P = e(d, _, p);
            P < 0 || (g[d][P] = null);
          }
          function e(d, _, p) {
            let P = -1;
            return g[d] && g[d].some(($, ot) => {
              if ($ && $.callback === _ && (!p || p === $.scope)) return P = ot, !0;
            }), P;
          }
          return { on: function(d, _, p) {
            m(d, _, p, arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {});
          }, once: function(d, _, p) {
            m(d, _, p, arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, !0);
          }, off: S, trigger: function(d) {
            let _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (!d || !g[d]) return;
            if (_ = _ || {}, _.hasOwnProperty("type")) throw new Error("'type' is a reserved word for event dispatching");
            _.type = d, p.streamId && (_.streamId = p.streamId), p.mediaType && (_.mediaType = p.mediaType);
            const P = [];
            g[d].filter(($) => !(!$ || p.streamId && $.streamId && $.streamId !== p.streamId || p.mediaType && $.mediaType && $.mediaType !== p.mediaType || p.mode && $.mode && $.mode !== p.mode || !$.mode && p.mode && p.mode === l.A.EVENT_MODE_ON_RECEIVE)).forEach(($) => {
              $ && $.callback.call($.scope, _), $.executeOnlyOnce && P.push($);
            }), P.forEach(($) => {
              S(d, $.callback, $.scope);
            });
          }, reset: function() {
            g = {};
          } };
        }
        o.__dashjs_factory_name = "EventBus";
        const u = A.A.getSingletonFactory(o);
        u.EVENT_PRIORITY_LOW = 0, u.EVENT_PRIORITY_HIGH = 5e3, A.A.updateSingletonFactory(o.__dashjs_factory_name, u), h.A = u;
      }, 138: function(L, h) {
        const b = function() {
          let A, l = [];
          const o = {}, u = {};
          function g(n, d) {
            for (const _ in l) {
              const p = l[_];
              if (p.context === n && p.name === d) return p.instance;
            }
            return null;
          }
          function m(n, d) {
            return d[n];
          }
          function S(n, d, _) {
            n in _ && (_[n] = d);
          }
          function e(n, d, _) {
            let p;
            const P = n.__dashjs_factory_name, $ = d[P];
            if ($) {
              let ot = $.instance;
              if (!$.override) return ot.apply({ context: d, factory: A }, _);
              p = n.apply({ context: d }, _), ot = ot.apply({ context: d, factory: A, parent: p }, _);
              for (const dt in ot) p.hasOwnProperty(dt) && (p[dt] = ot[dt]);
            } else p = n.apply({ context: d }, _);
            return p.getClassName = function() {
              return P;
            }, p;
          }
          return A = { extend: function(n, d, _, p) {
            !p[n] && d && (p[n] = { instance: d, override: _ });
          }, getSingletonInstance: g, setSingletonInstance: function(n, d, _) {
            for (const p in l) {
              const P = l[p];
              if (P.context === n && P.name === d) return void (l[p].instance = _);
            }
            l.push({ name: d, context: n, instance: _ });
          }, deleteSingletonInstances: function(n) {
            l = l.filter((d) => d.context !== n);
          }, getSingletonFactory: function(n) {
            let d = m(n.__dashjs_factory_name, o);
            return d || (d = function(_) {
              let p;
              return _ === void 0 && (_ = {}), { getInstance: function() {
                return p || (p = g(_, n.__dashjs_factory_name)), p || (p = e(n, _, arguments), l.push({ name: n.__dashjs_factory_name, context: _, instance: p })), p;
              } };
            }, o[n.__dashjs_factory_name] = d), d;
          }, getSingletonFactoryByName: function(n) {
            return m(n, o);
          }, updateSingletonFactory: function(n, d) {
            S(n, d, o);
          }, getClassFactory: function(n) {
            let d = m(n.__dashjs_factory_name, u);
            return d || (d = function(_) {
              return _ === void 0 && (_ = {}), { create: function() {
                return e(n, _, arguments);
              } };
            }, u[n.__dashjs_factory_name] = d), d;
          }, getClassFactoryByName: function(n) {
            return m(n, u);
          }, updateClassFactory: function(n, d) {
            S(n, d, u);
          } }, A;
        }();
        h.A = b;
      }, 8261: function(L, h, b) {
        var A = b(138), l = b(7263), o = b(649), u = b(5212), g = b(7568), m = b(8850), S = b(3621);
        function e() {
          let d;
          const _ = this.context, p = (0, m.A)(_).getInstance(), P = { "streaming.delay.liveDelay": S.A.SETTING_UPDATED_LIVE_DELAY, "streaming.delay.liveDelayFragmentCount": S.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, "streaming.liveCatchup.enabled": S.A.SETTING_UPDATED_CATCHUP_ENABLED, "streaming.liveCatchup.playbackRate.min": S.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, "streaming.liveCatchup.playbackRate.max": S.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, "streaming.abr.rules.throughputRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.bolaRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.insufficientBufferRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.switchHistoryRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.droppedFramesRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.abandonRequestsRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.l2ARule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.rules.loLPRule.active": S.A.SETTING_UPDATED_ABR_ACTIVE_RULES, "streaming.abr.maxBitrate.video": S.A.SETTING_UPDATED_MAX_BITRATE, "streaming.abr.maxBitrate.audio": S.A.SETTING_UPDATED_MAX_BITRATE, "streaming.abr.minBitrate.video": S.A.SETTING_UPDATED_MIN_BITRATE, "streaming.abr.minBitrate.audio": S.A.SETTING_UPDATED_MIN_BITRATE }, $ = { debug: { logLevel: o.A.LOG_LEVEL_WARNING, dispatchEvent: !1 }, streaming: { abandonLoadTimeout: 1e4, wallclockTimeUpdateInterval: 100, manifestUpdateRetryInterval: 100, liveUpdateTimeThresholdInMilliseconds: 0, cacheInitSegments: !1, applyServiceDescription: !0, applyProducerReferenceTime: !0, applyContentSteering: !0, enableManifestDurationMismatchFix: !0, parseInbandPrft: !1, enableManifestTimescaleMismatchFix: !1, capabilities: { filterUnsupportedEssentialProperties: !0, supportedEssentialProperties: [{ schemeIdUri: u.A.FONT_DOWNLOAD_DVB_SCHEME }, { schemeIdUri: u.A.COLOUR_PRIMARIES_SCHEME_ID_URI, value: /1|5|6|7/ }, { schemeIdUri: u.A.URL_QUERY_INFO_SCHEME }, { schemeIdUri: u.A.EXT_URL_QUERY_INFO_SCHEME }, { schemeIdUri: u.A.MATRIX_COEFFICIENTS_SCHEME_ID_URI, value: /0|1|5|6/ }, { schemeIdUri: u.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI, value: /1|6|13|14|15/ }, ...u.A.THUMBNAILS_SCHEME_ID_URIS.map((xt) => ({ schemeIdUri: xt }))], useMediaCapabilitiesApi: !0, filterVideoColorimetryEssentialProperties: !1, filterHDRMetadataFormatEssentialProperties: !1 }, events: { eventControllerRefreshDelay: 100, deleteEventMessageDataAfterEventStarted: !0 }, timeShiftBuffer: { calcFromSegmentTimeline: !1, fallbackToSegmentTimeline: !0 }, metrics: { maxListDepth: 100 }, delay: { liveDelayFragmentCount: NaN, liveDelay: NaN, useSuggestedPresentationDelay: !0 }, protection: { keepProtectionMediaKeys: !1, ignoreEmeEncryptedEvent: !1, detectPlayreadyMessageFormat: !0, ignoreKeyStatuses: !1 }, buffer: { enableSeekDecorrelationFix: !1, fastSwitchEnabled: null, flushBufferAtTrackSwitch: !1, reuseExistingSourceBuffers: !0, bufferPruningInterval: 10, bufferToKeep: 20, bufferTimeAtTopQuality: 30, bufferTimeAtTopQualityLongForm: 60, initialBufferLevel: NaN, bufferTimeDefault: 18, longFormContentDurationThreshold: 600, stallThreshold: 0.3, useAppendWindow: !0, setStallState: !0, avoidCurrentTimeRangePruning: !1, useChangeType: !0, mediaSourceDurationInfinity: !0, resetSourceBuffersForTrackSwitch: !1, syntheticStallEvents: { enabled: !1, ignoreReadyState: !1 } }, gaps: { jumpGaps: !0, jumpLargeGaps: !0, smallGapLimit: 1.5, threshold: 0.3, enableSeekFix: !0, enableStallFix: !1, stallSeek: 0.1 }, utcSynchronization: { enabled: !0, useManifestDateHeaderTimeSource: !0, backgroundAttempts: 2, timeBetweenSyncAttempts: 30, maximumTimeBetweenSyncAttempts: 600, minimumTimeBetweenSyncAttempts: 2, timeBetweenSyncAttemptsAdjustmentFactor: 2, maximumAllowedDrift: 100, enableBackgroundSyncAfterSegmentDownloadError: !0, defaultTimingSource: { scheme: "urn:mpeg:dash:utc:http-xsdate:2014", value: "https://time.akamai.com/?iso&ms" } }, scheduling: { defaultTimeout: 500, lowLatencyTimeout: 0, scheduleWhilePaused: !0 }, text: { defaultEnabled: !0, dispatchForManualRendering: !1, extendSegmentedCues: !0, imsc: { displayForcedOnlyMode: !1, enableRollUp: !0 }, webvtt: { customRenderingEnabled: !1 } }, liveCatchup: { maxDrift: NaN, playbackRate: { min: NaN, max: NaN }, playbackBufferMin: 0.5, enabled: null, mode: u.A.LIVE_CATCHUP_MODE_DEFAULT }, lastBitrateCachingInfo: { enabled: !0, ttl: 36e4 }, lastMediaSettingsCachingInfo: { enabled: !0, ttl: 36e4 }, saveLastMediaSettingsForCurrentStreamingSession: !0, cacheLoadThresholds: { video: 10, audio: 5 }, trackSwitchMode: { audio: u.A.TRACK_SWITCH_MODE_ALWAYS_REPLACE, video: u.A.TRACK_SWITCH_MODE_NEVER_REPLACE, mesh: u.A.TRACK_SWITCH_MODE_NEVER_REPLACE }, selectionModeForInitialTrack: u.A.TRACK_SELECTION_MODE_HIGHEST_SELECTION_PRIORITY, fragmentRequestTimeout: 2e4, fragmentRequestProgressTimeout: -1, manifestRequestTimeout: 1e4, retryIntervals: { [g.G.MPD_TYPE]: 500, [g.G.XLINK_EXPANSION_TYPE]: 500, [g.G.MEDIA_SEGMENT_TYPE]: 1e3, [g.G.INIT_SEGMENT_TYPE]: 1e3, [g.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 1e3, [g.G.INDEX_SEGMENT_TYPE]: 1e3, [g.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE]: 1e3, [g.G.LICENSE]: 1e3, [g.G.OTHER_TYPE]: 1e3, lowLatencyReductionFactor: 10 }, retryAttempts: { [g.G.MPD_TYPE]: 3, [g.G.XLINK_EXPANSION_TYPE]: 1, [g.G.MEDIA_SEGMENT_TYPE]: 3, [g.G.INIT_SEGMENT_TYPE]: 3, [g.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: 3, [g.G.INDEX_SEGMENT_TYPE]: 3, [g.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE]: 3, [g.G.LICENSE]: 3, [g.G.OTHER_TYPE]: 3, lowLatencyMultiplyFactor: 5 }, abr: { limitBitrateByPortal: !1, usePixelRatioInLimitBitrateByPortal: !1, enableSupplementalPropertyAdaptationSetSwitching: !0, rules: { throughputRule: { active: !0 }, bolaRule: { active: !0 }, insufficientBufferRule: { active: !0, parameters: { throughputSafetyFactor: 0.7, segmentIgnoreCount: 2 } }, switchHistoryRule: { active: !0, parameters: { sampleSize: 8, switchPercentageThreshold: 0.075 } }, droppedFramesRule: { active: !1, parameters: { minimumSampleSize: 375, droppedFramesPercentageThreshold: 0.15 } }, abandonRequestsRule: { active: !0, parameters: { abandonDurationMultiplier: 1.8, minSegmentDownloadTimeThresholdInMs: 500, minThroughputSamplesThreshold: 6 } }, l2ARule: { active: !1 }, loLPRule: { active: !1 } }, throughput: { averageCalculationMode: u.A.THROUGHPUT_CALCULATION_MODES.EWMA, lowLatencyDownloadTimeCalculationMode: u.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING, useResourceTimingApi: !0, useNetworkInformationApi: { xhr: !1, fetch: !1 }, useDeadTimeLatency: !0, bandwidthSafetyFactor: 0.9, sampleSettings: { live: 3, vod: 4, enableSampleSizeAdjustment: !0, decreaseScale: 0.7, increaseScale: 1.3, maxMeasurementsToKeep: 20, averageLatencySampleAmount: 4 }, ewma: { throughputSlowHalfLifeSeconds: 8, throughputFastHalfLifeSeconds: 3, latencySlowHalfLifeCount: 2, latencyFastHalfLifeCount: 1, weightDownloadTimeMultiplicationFactor: 15e-4 } }, maxBitrate: { audio: -1, video: -1, mesh: -1 }, minBitrate: { audio: -1, video: -1, mesh: -1 }, initialBitrate: { audio: -1, video: -1, mesh: 0 }, autoSwitchBitrate: { audio: !0, video: !0, mesh: !1 } }, cmcd: { applyParametersFromMpd: !0, enabled: !1, sid: null, cid: null, rtp: null, rtpSafetyFactor: 5, mode: u.A.CMCD_MODE_QUERY, enabledKeys: u.A.CMCD_AVAILABLE_KEYS, includeInRequests: ["segment", "mpd"], version: 1 }, cmsd: { enabled: !1, abr: { applyMb: !1, etpWeightRatio: 0 } }, defaultSchemeIdUri: { viewpoint: "", audioChannelConfiguration: "urn:mpeg:mpegB:cicp:ChannelConfiguration", role: "urn:mpeg:dash:role:2011", accessibility: "urn:mpeg:dash:role:2011" } }, errors: { recoverAttempts: { mediaErrorDecode: 5 } } };
          let ot = l.A.clone($);
          function dt(xt, Nt, jt) {
            for (let q in xt) xt.hasOwnProperty(q) && (Nt.hasOwnProperty(q) ? typeof xt[q] != "object" || xt[q] instanceof RegExp || xt[q] instanceof Array || xt[q] === null ? (Nt[q] = l.A.clone(xt[q]), P[jt + q] && p.trigger(P[jt + q])) : dt(xt[q], Nt[q], jt.slice() + q + ".") : console.error("Settings parameter " + jt + q + " is not supported"));
          }
          return d = { get: function() {
            return ot;
          }, update: function(xt) {
            typeof xt == "object" && dt(xt, ot, "");
          }, reset: function() {
            ot = l.A.clone($);
          } }, d;
        }
        e.__dashjs_factory_name = "Settings";
        let n = A.A.getSingletonFactory(e);
        h.A = n;
      }, 7263: function(L, h, b) {
        var A = b(3282), l = b(8571), o = b(5212);
        class u {
          static mixin(m, S, e) {
            let n, d = {};
            if (m) for (let _ in S) S.hasOwnProperty(_) && (n = S[_], _ in m && (m[_] === n || _ in d && d[_] === n) || (typeof m[_] == "object" && m[_] !== null ? m[_] = u.mixin(m[_], n, e) : m[_] = e(n)));
            return m;
          }
          static clone(m) {
            if (!m || typeof m != "object") return m;
            if (m instanceof RegExp) return new RegExp(m);
            let S;
            if (m instanceof Array) {
              S = [];
              for (let e = 0, n = m.length; e < n; ++e) e in m && S.push(u.clone(m[e]));
            } else S = {};
            return u.mixin(S, m, u.clone);
          }
          static addAdditionalQueryParameterToUrl(m, S) {
            try {
              if (!S || S.length === 0) return m;
              let e = m;
              return S.forEach((n) => {
                let { key: d, value: _ } = n;
                const p = e.includes("?") ? "&" : "?";
                e += `${p}${encodeURIComponent(d)}=${encodeURIComponent(_)}`;
              }), e;
            } catch {
              return m;
            }
          }
          static removeQueryParameterFromUrl(m, S) {
            if (!m || !S) return m;
            const e = new URL(m), n = new URLSearchParams(e.search);
            return n && n.size !== 0 ? (n.delete(S), e.search = n.toString(), e.toString()) : m;
          }
          static parseHttpHeaders(m) {
            let S = {};
            if (!m) return S;
            let e = m.trim().split(`\r
`);
            for (let n = 0, d = e.length; n < d; n++) {
              let _ = e[n], p = _.indexOf(": ");
              p > 0 && (S[_.substring(0, p)] = _.substring(p + 2));
            }
            return S;
          }
          static parseQueryParams(m) {
            const S = [], e = new URLSearchParams(m);
            for (const [n, d] of e.entries()) S.push({ key: decodeURIComponent(n), value: decodeURIComponent(d) });
            return S;
          }
          static generateUuid() {
            let m = (/* @__PURE__ */ new Date()).getTime();
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(S) {
              const e = (m + 16 * Math.random()) % 16 | 0;
              return m = Math.floor(m / 16), (S == "x" ? e : 3 & e | 8).toString(16);
            });
          }
          static generateHashCode(m) {
            let S = 0;
            if (m.length === 0) return S;
            for (let e = 0; e < m.length; e++) S = (S << 5) - S + m.charCodeAt(e), S |= 0;
            return S;
          }
          static getRelativeUrl(m, S) {
            try {
              const e = new URL(m), n = new URL(S);
              if (e.protocol = n.protocol, e.origin !== n.origin) return S;
              let d = A.relative(e.pathname.substr(0, e.pathname.lastIndexOf("/")), n.pathname.substr(0, n.pathname.lastIndexOf("/")));
              const _ = d.length === 0 ? 1 : 0;
              return d += n.pathname.substr(n.pathname.lastIndexOf("/") + _, n.pathname.length - 1), n.pathname.length < d.length ? n.pathname : d;
            } catch {
              return S;
            }
          }
          static getHostFromUrl(m) {
            try {
              return new URL(m).host;
            } catch {
              return null;
            }
          }
          static parseUserAgent() {
            let m = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            try {
              const S = m === null && typeof navigator < "u" ? navigator.userAgent.toLowerCase() : "";
              return (0, l.UAParser)(S);
            } catch {
              return {};
            }
          }
          static stringHasProtocol(m) {
            return /(http(s?)):\/\//i.test(m);
          }
          static bufferSourceToDataView(m) {
            return u.toDataView(m, DataView);
          }
          static bufferSourceToInt8(m) {
            return u.toDataView(m, Uint8Array);
          }
          static bufferSourceToHex(m) {
            const S = u.bufferSourceToInt8(m);
            let e = "";
            for (let n of S) n = n.toString(16), n.length === 1 && (n = "0" + n), e += n;
            return e;
          }
          static toDataView(m, S) {
            const e = u.getArrayBuffer(m);
            let n = 1;
            "BYTES_PER_ELEMENT" in DataView && (n = DataView.BYTES_PER_ELEMENT);
            const d = ((m.byteOffset || 0) + m.byteLength) / n, _ = (m.byteOffset || 0) / n, p = Math.floor(Math.max(0, Math.min(_, d)));
            return new S(e, p, Math.floor(Math.min(p + Math.max(1 / 0, 0), d)) - p);
          }
          static getArrayBuffer(m) {
            return m instanceof ArrayBuffer ? m : m.buffer;
          }
          static getCodecFamily(m) {
            const { base: S, profile: e } = u._getCodecParts(m);
            switch (S) {
              case "mp4a":
                switch (e) {
                  case "69":
                  case "6b":
                  case "40.34":
                    return o.A.CODEC_FAMILIES.MP3;
                  case "66":
                  case "67":
                  case "68":
                  case "40.2":
                  case "40.02":
                  case "40.5":
                  case "40.05":
                  case "40.29":
                  case "40.42":
                    return o.A.CODEC_FAMILIES.AAC;
                  case "a5":
                    return o.A.CODEC_FAMILIES.AC3;
                  case "e6":
                    return o.A.CODEC_FAMILIES.EC3;
                  case "b2":
                    return o.A.CODEC_FAMILIES.DTSX;
                  case "a9":
                    return o.A.CODEC_FAMILIES.DTSC;
                }
                break;
              case "avc1":
              case "avc3":
                return o.A.CODEC_FAMILIES.AVC;
              case "hvc1":
              case "hvc3":
                return o.A.CODEC_FAMILIES.HEVC;
              default:
                return S;
            }
            return S;
          }
          static _getCodecParts(m) {
            const [S, ...e] = m.split(".");
            return { base: S, profile: e.join(".") };
          }
        }
        h.A = u;
      }, 8986: function(L, h, b) {
        b.d(h, { i: function() {
          return l;
        } });
        const A = "5.0.1";
        function l() {
          return A;
        }
      }, 8748: function(L, h) {
        h.A = class {
          extend(b, A) {
            if (!b) return;
            let l = !!A && A.override, o = !!A && A.publicOnly;
            for (const u in b) !b.hasOwnProperty(u) || this[u] && !l || o && b[u].indexOf("public_") === -1 || (this[u] = b[u]);
          }
        };
      }, 5734: function(L, h, b) {
        var A = b(7252);
        class l extends A.A {
          constructor() {
            super(), this.ATTEMPT_BACKGROUND_SYNC = "attemptBackgroundSync", this.BUFFERING_COMPLETED = "bufferingCompleted", this.BUFFER_CLEARED = "bufferCleared", this.BYTES_APPENDED_END_FRAGMENT = "bytesAppendedEndFragment", this.BUFFER_REPLACEMENT_STARTED = "bufferReplacementStarted", this.CHECK_FOR_EXISTENCE_COMPLETED = "checkForExistenceCompleted", this.CMSD_STATIC_HEADER = "cmsdStaticHeader", this.CURRENT_TRACK_CHANGED = "currentTrackChanged", this.DATA_UPDATE_COMPLETED = "dataUpdateCompleted", this.INBAND_EVENTS = "inbandEvents", this.INITIAL_STREAM_SWITCH = "initialStreamSwitch", this.INIT_FRAGMENT_LOADED = "initFragmentLoaded", this.INIT_FRAGMENT_NEEDED = "initFragmentNeeded", this.INTERNAL_MANIFEST_LOADED = "internalManifestLoaded", this.ORIGINAL_MANIFEST_LOADED = "originalManifestLoaded", this.LOADING_COMPLETED = "loadingCompleted", this.LOADING_PROGRESS = "loadingProgress", this.LOADING_DATA_PROGRESS = "loadingDataProgress", this.LOADING_ABANDONED = "loadingAborted", this.MANIFEST_UPDATED = "manifestUpdated", this.MEDIA_FRAGMENT_LOADED = "mediaFragmentLoaded", this.MEDIA_FRAGMENT_NEEDED = "mediaFragmentNeeded", this.MEDIAINFO_UPDATED = "mediaInfoUpdated", this.QUOTA_EXCEEDED = "quotaExceeded", this.SEGMENT_LOCATION_BLACKLIST_ADD = "segmentLocationBlacklistAdd", this.SEGMENT_LOCATION_BLACKLIST_CHANGED = "segmentLocationBlacklistChanged", this.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD = "serviceLocationBlacklistAdd", this.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED = "serviceLocationBlacklistChanged", this.SERVICE_LOCATION_LOCATION_BLACKLIST_ADD = "serviceLocationLocationBlacklistAdd", this.SERVICE_LOCATION_LOCATION_BLACKLIST_CHANGED = "serviceLocationLocationBlacklistChanged", this.SET_FRAGMENTED_TEXT_AFTER_DISABLED = "setFragmentedTextAfterDisabled", this.SET_NON_FRAGMENTED_TEXT = "setNonFragmentedText", this.SOURCE_BUFFER_ERROR = "sourceBufferError", this.STREAMS_COMPOSED = "streamsComposed", this.STREAM_BUFFERING_COMPLETED = "streamBufferingCompleted", this.STREAM_REQUESTING_COMPLETED = "streamRequestingCompleted", this.TEXT_TRACKS_QUEUE_INITIALIZED = "textTracksQueueInitialized", this.TIME_SYNCHRONIZATION_COMPLETED = "timeSynchronizationComplete", this.UPDATE_TIME_SYNC_OFFSET = "updateTimeSyncOffset", this.URL_RESOLUTION_FAILED = "urlResolutionFailed", this.VIDEO_CHUNK_RECEIVED = "videoChunkReceived", this.WALLCLOCK_TIME_UPDATED = "wallclockTimeUpdated", this.XLINK_ELEMENT_LOADED = "xlinkElementLoaded", this.XLINK_READY = "xlinkReady", this.SEEK_TARGET = "seekTarget", this.SETTING_UPDATED_LIVE_DELAY = "settingUpdatedLiveDelay", this.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT = "settingUpdatedLiveDelayFragmentCount", this.SETTING_UPDATED_CATCHUP_ENABLED = "settingUpdatedCatchupEnabled", this.SETTING_UPDATED_PLAYBACK_RATE_MIN = "settingUpdatedPlaybackRateMin", this.SETTING_UPDATED_PLAYBACK_RATE_MAX = "settingUpdatedPlaybackRateMax", this.SETTING_UPDATED_ABR_ACTIVE_RULES = "settingUpdatedAbrActiveRules", this.SETTING_UPDATED_MAX_BITRATE = "settingUpdatedMaxBitrate", this.SETTING_UPDATED_MIN_BITRATE = "settingUpdatedMinBitrate";
          }
        }
        h.A = l;
      }, 3621: function(L, h, b) {
        var A = b(5734);
        class l extends A.A {
        }
        let o = new l();
        h.A = o;
      }, 7252: function(L, h) {
        h.A = class {
          extend(b, A) {
            if (!b) return;
            let l = !!A && A.override, o = !!A && A.publicOnly;
            for (const u in b) !b.hasOwnProperty(u) || this[u] && !l || o && b[u].indexOf("public_") === -1 || (this[u] = b[u]);
          }
        };
      }, 8854: function(L, h) {
        h.A = { ACCESSIBILITY: "Accessibility", ADAPTATION_SET: "AdaptationSet", ADAPTATION_SETS: "adaptationSets", ADAPTATION_SET_SWITCHING_SCHEME_ID_URI: "urn:mpeg:dash:adaptation-set-switching:2016", ADD: "add", ASSET_IDENTIFIER: "AssetIdentifier", AUDIO_CHANNEL_CONFIGURATION: "AudioChannelConfiguration", AUDIO_SAMPLING_RATE: "audioSamplingRate", AVAILABILITY_END_TIME: "availabilityEndTime", AVAILABILITY_START_TIME: "availabilityStartTime", AVAILABILITY_TIME_COMPLETE: "availabilityTimeComplete", AVAILABILITY_TIME_OFFSET: "availabilityTimeOffset", BANDWITH: "bandwidth", BASE_URL: "BaseURL", BITSTREAM_SWITCHING: "BitstreamSwitching", BITSTREAM_SWITCHING_MINUS: "bitstreamSwitching", BYTE_RANGE: "byteRange", CAPTION: "caption", CENC_DEFAULT_KID: "cenc:default_KID", CLIENT_DATA_REPORTING: "ClientDataReporting", CLIENT_REQUIREMENT: "clientRequirement", CMCD_PARAMETERS: "CMCDParameters", CODECS: "codecs", CODEC_PRIVATE_DATA: "codecPrivateData", CODING_DEPENDENCY: "codingDependency", CONTENT_COMPONENT: "ContentComponent", CONTENT_PROTECTION: "ContentProtection", CONTENT_STEERING: "ContentSteering", CONTENT_STEERING_RESPONSE: { VERSION: "VERSION", TTL: "TTL", RELOAD_URI: "RELOAD-URI", PATHWAY_PRIORITY: "PATHWAY-PRIORITY", PATHWAY_CLONES: "PATHWAY-CLONES", BASE_ID: "BASE-ID", ID: "ID", URI_REPLACEMENT: "URI-REPLACEMENT", HOST: "HOST", PARAMS: "PARAMS" }, CONTENT_TYPE: "contentType", DEFAULT_SERVICE_LOCATION: "defaultServiceLocation", DEPENDENCY_ID: "dependencyId", DURATION: "duration", DVB_PRIORITY: "dvb:priority", DVB_WEIGHT: "dvb:weight", DVB_URL: "dvb:url", DVB_MIMETYPE: "dvb:mimeType", DVB_FONTFAMILY: "dvb:fontFamily", DYNAMIC: "dynamic", ESSENTIAL_PROPERTY: "EssentialProperty", EVENT: "Event", EVENT_STREAM: "EventStream", FORCED_SUBTITLE: "forced-subtitle", FRAMERATE: "frameRate", FRAME_PACKING: "FramePacking", GROUP_LABEL: "GroupLabel", HEIGHT: "height", ID: "id", INBAND: "inband", INBAND_EVENT_STREAM: "InbandEventStream", INDEX: "index", INDEX_RANGE: "indexRange", INITIALIZATION: "Initialization", INITIALIZATION_MINUS: "initialization", LA_URL: "Laurl", LA_URL_LOWER_CASE: "laurl", LABEL: "Label", LANG: "lang", LOCATION: "Location", MAIN: "main", MAXIMUM_SAP_PERIOD: "maximumSAPPeriod", MAX_PLAYOUT_RATE: "maxPlayoutRate", MAX_SEGMENT_DURATION: "maxSegmentDuration", MAX_SUBSEGMENT_DURATION: "maxSubsegmentDuration", MEDIA: "media", MEDIA_PRESENTATION_DURATION: "mediaPresentationDuration", MEDIA_RANGE: "mediaRange", MEDIA_STREAM_STRUCTURE_ID: "mediaStreamStructureId", METRICS: "Metrics", METRICS_MINUS: "metrics", MIME_TYPE: "mimeType", MINIMUM_UPDATE_PERIOD: "minimumUpdatePeriod", MIN_BUFFER_TIME: "minBufferTime", MP4_PROTECTION_SCHEME: "urn:mpeg:dash:mp4protection:2011", MPD: "MPD", MPD_TYPE: "mpd", MPD_PATCH_TYPE: "mpdpatch", ORIGINAL_MPD_ID: "mpdId", ORIGINAL_PUBLISH_TIME: "originalPublishTime", PATCH_LOCATION: "PatchLocation", PERIOD: "Period", PRESENTATION_TIME: "presentationTime", PRESENTATION_TIME_OFFSET: "presentationTimeOffset", PRO: "pro", PRODUCER_REFERENCE_TIME: "ProducerReferenceTime", PRODUCER_REFERENCE_TIME_TYPE: { ENCODER: "encoder", CAPTURED: "captured", APPLICATION: "application" }, PROFILES: "profiles", PSSH: "pssh", PUBLISH_TIME: "publishTime", QUALITY_RANKING: "qualityRanking", QUERY_BEFORE_START: "queryBeforeStart", QUERY_PART: "$querypart$", RANGE: "range", RATING: "Rating", REF: "ref", REF_ID: "refId", REMOVE: "remove", REPLACE: "replace", REPORTING: "Reporting", REPRESENTATION: "Representation", REPRESENTATION_INDEX: "RepresentationIndex", ROBUSTNESS: "robustness", ROLE: "Role", S: "S", SAR: "sar", SCAN_TYPE: "scanType", SEGMENT_ALIGNMENT: "segmentAlignment", SEGMENT_BASE: "SegmentBase", SEGMENT_LIST: "SegmentList", SEGMENT_PROFILES: "segmentProfiles", SEGMENT_TEMPLATE: "SegmentTemplate", SEGMENT_TIMELINE: "SegmentTimeline", SEGMENT_TYPE: "segment", SEGMENT_URL: "SegmentURL", SERVICE_DESCRIPTION: "ServiceDescription", SERVICE_DESCRIPTION_LATENCY: "Latency", SERVICE_DESCRIPTION_OPERATING_BANDWIDTH: "OperatingBandwidth", SERVICE_DESCRIPTION_OPERATING_QUALITY: "OperatingQuality", SERVICE_DESCRIPTION_PLAYBACK_RATE: "PlaybackRate", SERVICE_DESCRIPTION_SCOPE: "Scope", SERVICE_LOCATION: "serviceLocation", SERVICE_LOCATIONS: "serviceLocations", SOURCE_URL: "sourceURL", START: "start", START_NUMBER: "startNumber", START_WITH_SAP: "startWithSAP", STATIC: "static", STEERING_TYPE: "steering", SUBSET: "Subset", SUBTITLE: "subtitle", SUB_REPRESENTATION: "SubRepresentation", SUB_SEGMENT_ALIGNMENT: "subsegmentAlignment", SUGGESTED_PRESENTATION_DELAY: "suggestedPresentationDelay", SUPPLEMENTAL_PROPERTY: "SupplementalProperty", SUPPLEMENTAL_CODECS: "scte214:supplementalCodecs", TIMESCALE: "timescale", TIMESHIFT_BUFFER_DEPTH: "timeShiftBufferDepth", TTL: "ttl", TYPE: "type", UTC_TIMING: "UTCTiming", VALUE: "value", VIEWPOINT: "Viewpoint", WALL_CLOCK_TIME: "wallClockTime", WIDTH: "width" };
      }, 5717: function(L, h) {
        h.A = class {
          constructor() {
            this.schemeIdUri = "", this.value = "";
          }
        };
      }, 6161: function(L, h, b) {
        b.d(h, { A: function() {
          return vg;
        } });
        class A {
          constructor() {
            this.time = null, this.verboseLevel = 0;
          }
          log(f, E) {
            if (this.verboseLevel >= f) {
              const v = typeof E == "function" ? E() : E;
              console.log(`${this.time} [${f}] ${v}`);
            }
          }
        }
        class l {
          constructor() {
            this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
          }
          reset() {
            this.foreground = "white", this.underline = !1, this.italics = !1, this.background = "black", this.flash = !1;
          }
          setStyles(f) {
            const E = ["foreground", "underline", "italics", "background", "flash"];
            for (let v = 0; v < E.length; v++) {
              const M = E[v];
              Object.prototype.hasOwnProperty.call(f, M) && (this[M] = f[M]);
            }
          }
          isDefault() {
            return this.foreground === "white" && !this.underline && !this.italics && this.background === "black" && !this.flash;
          }
          equals(f) {
            return this.foreground === f.foreground && this.underline === f.underline && this.italics === f.italics && this.background === f.background && this.flash === f.flash;
          }
          copy(f) {
            this.foreground = f.foreground, this.underline = f.underline, this.italics = f.italics, this.background = f.background, this.flash = f.flash;
          }
        }
        class o {
          constructor() {
            this.uchar = " ", this.penState = new l();
          }
          reset() {
            this.uchar = " ", this.penState.reset();
          }
          setChar(f, E) {
            this.uchar = f, this.penState.copy(E);
          }
          setPenState(f) {
            this.penState.copy(f);
          }
          equals(f) {
            return this.uchar === f.uchar && this.penState.equals(f.penState);
          }
          copy(f) {
            this.uchar = f.uchar, this.penState.copy(f.penState);
          }
          isEmpty() {
            return this.uchar === " " && this.penState.isDefault();
          }
        }
        const u = 100, g = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }, m = function(y) {
          return String.fromCharCode(g[y] || y);
        };
        class S {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new A();
            this.chars = [], this.cueStartTime = null, this.pos = 0, this.currPenState = new l();
            for (let E = 0; E < u; E++) this.chars.push(new o());
            this.logger = f;
          }
          equals(f) {
            for (let E = 0; E < u; E++) if (!this.chars[E].equals(f.chars[E])) return !1;
            return !0;
          }
          copy(f) {
            for (let E = 0; E < u; E++) this.chars[E].copy(f.chars[E]);
          }
          isEmpty() {
            let f = !0;
            for (let E = 0; E < u; E++) if (!this.chars[E].isEmpty()) {
              f = !1;
              break;
            }
            return f;
          }
          setCursor(f) {
            this.pos !== f && (this.pos = f), this.pos < 0 ? (this.logger.log(3, "Negative cursor position " + this.pos), this.pos = 0) : this.pos > u && (this.logger.log(3, "Too large cursor position " + this.pos), this.pos = u);
          }
          moveCursor(f) {
            const E = this.pos + f;
            if (f > 1) for (let v = this.pos + 1; v < E + 1; v++) this.chars[v].setPenState(this.currPenState);
            this.setCursor(E);
          }
          backSpace() {
            this.moveCursor(-1), this.chars[this.pos].setChar(" ", this.currPenState);
          }
          insertChar(f) {
            f >= 144 && this.backSpace();
            const E = m(f);
            this.pos >= u ? this.logger.log(0, () => "Cannot insert " + f.toString(16) + " (" + E + ") at position " + this.pos + ". Skipping it!") : (this.chars[this.pos].setChar(E, this.currPenState), this.moveCursor(1));
          }
          clearFromPos(f) {
            let E;
            for (E = f; E < u; E++) this.chars[E].reset();
          }
          clear() {
            this.clearFromPos(0), this.pos = 0, this.currPenState.reset();
          }
          clearToEndOfRow() {
            this.clearFromPos(this.pos);
          }
          getTextString() {
            const f = [];
            let E = !0;
            for (let v = 0; v < u; v++) {
              const M = this.chars[v].uchar;
              M !== " " && (E = !1), f.push(M);
            }
            return E ? "" : f.join("");
          }
          setPenStyles(f) {
            this.currPenState.setStyles(f), this.chars[this.pos].setPenState(this.currPenState);
          }
        }
        const e = 15;
        class n {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new A();
            this.rows = [], this.currRow = 14, this.nrRollUpRows = null, this.lastOutputScreen = null;
            for (let E = 0; E < e; E++) this.rows.push(new S(f));
            this.logger = f;
          }
          reset() {
            for (let f = 0; f < e; f++) this.rows[f].clear();
            this.currRow = 14;
          }
          equals(f) {
            let E = !0;
            for (let v = 0; v < e; v++) if (!this.rows[v].equals(f.rows[v])) {
              E = !1;
              break;
            }
            return E;
          }
          copy(f) {
            for (let E = 0; E < e; E++) this.rows[E].copy(f.rows[E]);
          }
          isEmpty() {
            let f = !0;
            for (let E = 0; E < e; E++) if (!this.rows[E].isEmpty()) {
              f = !1;
              break;
            }
            return f;
          }
          backSpace() {
            this.rows[this.currRow].backSpace();
          }
          clearToEndOfRow() {
            this.rows[this.currRow].clearToEndOfRow();
          }
          insertChar(f) {
            this.rows[this.currRow].insertChar(f);
          }
          setPen(f) {
            this.rows[this.currRow].setPenStyles(f);
          }
          moveCursor(f) {
            this.rows[this.currRow].moveCursor(f);
          }
          setCursor(f) {
            this.logger.log(2, "setCursor: " + f), this.rows[this.currRow].setCursor(f);
          }
          setPAC(f) {
            this.logger.log(2, () => "pacData = " + JSON.stringify(f));
            let E = f.row - 1;
            if (this.nrRollUpRows && E < this.nrRollUpRows - 1 && (E = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== E) {
              for (let O = 0; O < e; O++) this.rows[O].clear();
              const x = this.currRow + 1 - this.nrRollUpRows, z = this.lastOutputScreen;
              if (z) {
                const O = z.rows[x].cueStartTime, k = this.logger.time;
                if (O !== null && k !== null && O < k) for (let H = 0; H < this.nrRollUpRows; H++) this.rows[E - this.nrRollUpRows + H + 1].copy(z.rows[x + H]);
              }
            }
            this.currRow = E;
            const v = this.rows[this.currRow];
            if (f.indent !== null) {
              const x = f.indent, z = Math.max(x - 1, 0);
              v.setCursor(f.indent), f.color = v.chars[z].penState.foreground;
            }
            const M = { foreground: f.color, underline: f.underline, italics: f.italics, background: "black", flash: !1 };
            this.setPen(M);
          }
          setBkgData(f) {
            this.logger.log(2, () => "bkgData = " + JSON.stringify(f)), this.backSpace(), this.setPen(f), this.insertChar(32);
          }
          setRollUpRows(f) {
            this.nrRollUpRows = f;
          }
          rollUp() {
            if (this.nrRollUpRows === null) return void this.logger.log(3, "roll_up but nrRollUpRows not set yet");
            this.logger.log(1, () => this.getDisplayText());
            const f = this.currRow + 1 - this.nrRollUpRows, E = this.rows.splice(f, 1)[0];
            E.clear(), this.rows.splice(this.currRow, 0, E), this.logger.log(2, "Rolling up");
          }
          getDisplayText(f) {
            f = f || !1;
            const E = [];
            let v = "", M = -1;
            for (let x = 0; x < e; x++) {
              const z = this.rows[x].getTextString();
              z && (M = x + 1, f ? E.push("Row " + M + ": '" + z + "'") : E.push(z.trim()));
            }
            return E.length > 0 && (v = f ? "[" + E.join(" | ") + "]" : E.join(`
`)), v;
          }
          getTextAndFormat() {
            return this.rows;
          }
        }
        class d {
          constructor(f, E) {
            let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new A();
            this.chNr = f, this.outputFilter = E, this.mode = null, this.displayedMemory = new n(v), this.nonDisplayedMemory = new n(v), this.lastOutputScreen = new n(v), this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = v, this.logger.log(2, "new Cea608Channel(" + this.chNr + ")");
          }
          reset() {
            var f, E;
            this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), (E = (f = this.outputFilter) === null || f === void 0 ? void 0 : f.reset) === null || E === void 0 || E.call(f), this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;
          }
          setPAC(f) {
            this.writeScreen.setPAC(f);
          }
          setBkgData(f) {
            this.writeScreen.setBkgData(f);
          }
          setMode(f) {
            f !== this.mode && (this.mode = f, this.logger.log(2, () => "MODE=" + f), this.mode === "MODE_POP-ON" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== "MODE_ROLL-UP" && (this.displayedMemory.setRollUpRows(null), this.nonDisplayedMemory.setRollUpRows(null)), this.mode = f);
          }
          insertChars(f) {
            for (let v = 0; v < f.length; v++) this.writeScreen.insertChar(f[v]);
            const E = this.writeScreen === this.displayedMemory ? "DISP" : "NON_DISP";
            this.logger.log(2, () => E + ": " + this.writeScreen.getDisplayText(!0)), this.mode !== "MODE_PAINT-ON" && this.mode !== "MODE_ROLL-UP" || (this.logger.log(1, () => "DISPLAYED: " + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());
          }
          ccRCL() {
            this.logger.log(2, "RCL - Resume Caption Loading"), this.setMode("MODE_POP-ON");
          }
          ccBS() {
            this.logger.log(2, "BS - BackSpace"), this.mode !== "MODE_TEXT" && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate());
          }
          ccAOF() {
          }
          ccAON() {
          }
          ccDER() {
            this.logger.log(2, "DER- Delete to End of Row"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();
          }
          ccRU(f) {
            this.logger.log(2, "RU(" + f + ") - Roll Up"), this.writeScreen = this.displayedMemory, this.setMode("MODE_ROLL-UP"), this.writeScreen.setRollUpRows(f);
          }
          ccFON() {
            this.logger.log(2, "FON - Flash On"), this.writeScreen.setPen({ flash: !0 });
          }
          ccRDC() {
            this.logger.log(2, "RDC - Resume Direct Captioning"), this.setMode("MODE_PAINT-ON");
          }
          ccTR() {
            this.logger.log(2, "TR"), this.setMode("MODE_TEXT");
          }
          ccRTD() {
            this.logger.log(2, "RTD"), this.setMode("MODE_TEXT");
          }
          ccEDM() {
            this.logger.log(2, "EDM - Erase Displayed Memory"), this.displayedMemory.reset(), this.outputDataUpdate(!0);
          }
          ccCR() {
            this.logger.log(2, "CR - Carriage Return"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);
          }
          ccENM() {
            this.logger.log(2, "ENM - Erase Non-displayed Memory"), this.nonDisplayedMemory.reset();
          }
          ccEOC() {
            if (this.logger.log(2, "EOC - End Of Caption"), this.mode === "MODE_POP-ON") {
              const f = this.displayedMemory;
              this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = f, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () => "DISP: " + this.displayedMemory.getDisplayText());
            }
            this.outputDataUpdate(!0);
          }
          ccTO(f) {
            this.logger.log(2, "TO(" + f + ") - Tab Offset"), this.writeScreen.moveCursor(f);
          }
          ccMIDROW(f) {
            const E = { flash: !1 };
            if (E.underline = f % 2 == 1, E.italics = f >= 46, E.italics) E.foreground = "white";
            else {
              const v = Math.floor(f / 2) - 16, M = ["white", "green", "blue", "cyan", "red", "yellow", "magenta"];
              E.foreground = M[v];
            }
            this.logger.log(2, "MIDROW: " + JSON.stringify(E)), this.writeScreen.setPen(E);
          }
          outputDataUpdate() {
            let f = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            const E = this.logger.time;
            E !== null && this.outputFilter && (this.cueStartTime !== null || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, E, this.lastOutputScreen), f && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : E) : this.cueStartTime = E, this.lastOutputScreen.copy(this.displayedMemory));
          }
          cueSplitAtTime(f) {
            this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, f, this.displayedMemory), this.cueStartTime = f));
          }
        }
        const _ = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "black", "transparent"];
        function p(y, f, E) {
          return E.a === y && E.b === f;
        }
        const P = function(y) {
          const f = [];
          for (let E = 0; E < y.length; E++) f.push(y[E].toString(16));
          return f;
        }, $ = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }, ot = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }, dt = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }, xt = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 };
        function Nt(y, f, E) {
          E.a = y, E.b = f;
        }
        class jt {
          constructor(f, E, v) {
            this.currentChannel = 0, this.cmdHistory = { a: null, b: null }, this.lastTime = null;
            const M = this.logger = new A();
            this.channels = [null, new d(f, E, M), new d(f + 1, v, M)];
          }
          addData(f, E) {
            this.lastTime = f, this.logger.time = f;
            for (let v = 0; v < E.length; v += 2) {
              const M = 127 & E[v], x = 127 & E[v + 1];
              let z = !1, O = null;
              if (this.lastTime !== null && (f = this.lastTime + 0.5 * v * 1001 / 3e4, this.logger.time = f), M === 0 && x === 0) continue;
              this.logger.log(3, () => "[" + P([E[v], E[v + 1]]) + "] -> (" + P([M, x]) + ")");
              const k = this.cmdHistory;
              if (M >= 16 && M <= 31) {
                if (p(M, x, k)) {
                  Nt(null, null, k), this.logger.log(3, () => "Repeated command (" + P([M, x]) + ") is dropped");
                  continue;
                }
                Nt(M, x, this.cmdHistory), z = this.parseCmd(M, x), z || (z = this.parseMidrow(M, x)), z || (z = this.parsePAC(M, x)), z || (z = this.parseBackgroundAttributes(M, x));
              } else Nt(null, null, k);
              if (!z && (O = this.parseChars(M, x), O.length)) {
                const H = this.currentChannel;
                H && H > 0 ? this.channels[H].insertChars(O) : this.logger.log(2, "No channel found yet. TEXT-MODE?");
              }
              z || O || this.logger.log(2, () => "Couldn't parse cleaned data " + P([M, x]) + " orig: " + P([E[v], E[v + 1]]));
            }
          }
          parseCmd(f, E) {
            if (!((f === 20 || f === 28 || f === 21 || f === 29) && E >= 32 && E <= 47 || (f === 23 || f === 31) && E >= 33 && E <= 35)) return !1;
            const v = f === 20 || f === 21 || f === 23 ? 1 : 2, M = this.channels[v];
            return f === 20 || f === 21 || f === 28 || f === 29 ? E === 32 ? M.ccRCL() : E === 33 ? M.ccBS() : E === 34 ? M.ccAOF() : E === 35 ? M.ccAON() : E === 36 ? M.ccDER() : E === 37 ? M.ccRU(2) : E === 38 ? M.ccRU(3) : E === 39 ? M.ccRU(4) : E === 40 ? M.ccFON() : E === 41 ? M.ccRDC() : E === 42 ? M.ccTR() : E === 43 ? M.ccRTD() : E === 44 ? M.ccEDM() : E === 45 ? M.ccCR() : E === 46 ? M.ccENM() : E === 47 && M.ccEOC() : M.ccTO(E - 32), this.currentChannel = v, !0;
          }
          parseMidrow(f, E) {
            let v = 0;
            if ((f === 17 || f === 25) && E >= 32 && E <= 47) {
              if (v = f === 17 ? 1 : 2, v !== this.currentChannel) return this.logger.log(0, "Mismatch channel in midrow parsing"), !1;
              const M = this.channels[v];
              return !!M && (M.ccMIDROW(E), this.logger.log(3, () => "MIDROW (" + P([f, E]) + ")"), !0);
            }
            return !1;
          }
          parsePAC(f, E) {
            let v;
            if (!((f >= 17 && f <= 23 || f >= 25 && f <= 31) && E >= 64 && E <= 127 || (f === 16 || f === 24) && E >= 64 && E <= 95)) return !1;
            const M = f <= 23 ? 1 : 2;
            v = E >= 64 && E <= 95 ? M === 1 ? dt[f] : xt[f] : M === 1 ? $[f] : ot[f];
            const x = this.channels[M];
            return !!x && (x.setPAC(this.interpretPAC(v, E)), this.currentChannel = M, !0);
          }
          interpretPAC(f, E) {
            let v;
            const M = { color: null, italics: !1, indent: null, underline: !1, row: f };
            return v = E > 95 ? E - 96 : E - 64, M.underline = !(1 & ~v), v <= 13 ? M.color = ["white", "green", "blue", "cyan", "red", "yellow", "magenta", "white"][Math.floor(v / 2)] : v <= 15 ? (M.italics = !0, M.color = "white") : M.indent = 4 * Math.floor((v - 16) / 2), M;
          }
          parseChars(f, E) {
            let v, M = [], x = null;
            if (f >= 25 ? (v = 2, x = f - 8) : (v = 1, x = f), x >= 17 && x <= 19) {
              let z;
              z = x === 17 ? E + 80 : x === 18 ? E + 112 : E + 144, this.logger.log(2, () => "Special char '" + m(z) + "' in channel " + v), M = [z];
            } else f >= 32 && f <= 127 && (M = E === 0 ? [f] : [f, E]);
            return M && this.logger.log(3, () => "Char codes =  " + P(M).join(",")), M;
          }
          parseBackgroundAttributes(f, E) {
            if (!((f === 16 || f === 24) && E >= 32 && E <= 47 || (f === 23 || f === 31) && E >= 45 && E <= 47)) return !1;
            let v;
            const M = {};
            f === 16 || f === 24 ? (v = Math.floor((E - 32) / 2), M.background = _[v], E % 2 == 1 && (M.background = M.background + "_semi")) : E === 45 ? M.background = "transparent" : (M.foreground = "black", E === 47 && (M.underline = !0));
            const x = f <= 23 ? 1 : 2;
            return this.channels[x].setBkgData(M), !0;
          }
          reset() {
            for (let f = 0; f < Object.keys(this.channels).length; f++) {
              const E = this.channels[f];
              E && E.reset();
            }
            Nt(null, null, this.cmdHistory);
          }
          cueSplitAtTime(f) {
            for (let E = 0; E < this.channels.length; E++) {
              const v = this.channels[E];
              v && v.cueSplitAtTime(f);
            }
          }
        }
        var q = b(5212), I = b(8854), pt = { TCP_CONNECTION: "TcpList", HTTP_REQUEST: "HttpList", TRACK_SWITCH: "RepSwitchList", BUFFER_LEVEL: "BufferLevel", BUFFER_LOADED: "bufferLoaded", ABANDON_LOAD: "abandonload", ALLOW_LOAD: "allowload", BUFFER_EMPTY: "bufferStalled", BUFFER_STATE: "BufferState", DVR_INFO: "DVRInfo", DROPPED_FRAMES: "DroppedFrames", SCHEDULING_INFO: "SchedulingInfo", REQUESTS_QUEUE: "RequestsQueue", MANIFEST_UPDATE: "ManifestUpdate", MANIFEST_UPDATE_STREAM_INFO: "ManifestUpdatePeriodInfo", MANIFEST_UPDATE_TRACK_INFO: "ManifestUpdateRepresentationInfo", PLAY_LIST: "PlayList", DVB_ERRORS: "DVBErrors", HTTP_REQUEST_DVB_REPORTING_TYPE: "DVBReporting" }, It = b(8850), et = b(3621), Dt = b(138), ae = b(649), St = b(1191);
        function qe() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft, bt;
          function _t() {
            W(), it = !1, D = 0, N = 0, st = 0, K = !1, ht = !0, At = !1, ft = !1, Z = NaN, at = NaN, k && (f.off(et.A.DATA_UPDATE_COMPLETED, Ue, E), f.off(et.A.MANIFEST_UPDATED, We, E), f.off(et.A.STREAMS_COMPOSED, ln, E), f.off(St.A.PLAYBACK_ENDED, Pe, E), f.off(St.A.STREAM_INITIALIZING, ie, E), f.off(St.A.REPRESENTATION_SWITCH, Le, E), f.off(St.A.BUFFER_LEVEL_STATE_CHANGED, cn, E), fe(), k.removeEventListener("canplay", Ye), k.removeEventListener("canplaythrough", on), k.removeEventListener("play", Nn), k.removeEventListener("waiting", Qe), k.removeEventListener("playing", hn), k.removeEventListener("pause", Sn), k.removeEventListener("error", nn), k.removeEventListener("seeking", jn), k.removeEventListener("seeked", Ln), k.removeEventListener("timeupdate", Rn), k.removeEventListener("progress", $t), k.removeEventListener("ratechange", be), k.removeEventListener("loadedmetadata", ge), k.removeEventListener("loadeddata", Te), k.removeEventListener("stalled", gn), k.removeEventListener("ended", ee), k.removeEventListener("volumechange", De)), B = null, k = null, Y = null, J = null;
          }
          function vt() {
            return parseFloat((Pt(arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) - nt()).toFixed(5));
          }
          function Pt(ye) {
            const Rt = ye || Y;
            return Rt.start + Rt.duration;
          }
          function Ot() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            Y && k && k.getElement() ? (ye && J && yt(nt()), k.play()) : it = !0;
          }
          function W() {
            Y && k && k.pause();
          }
          function tt(ye) {
            let Rt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Wt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2], Ee = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
            Y && k && k.getElement() && ye !== (isNaN(Z) ? k.getTime() : Z) && (F = Wt === !0, F || (Z = ye), v.info("Requesting seek to time: " + ye + (F ? " (internal)" : "")), J && Ee && yt(ye), k.setCurrentTime(ye, Rt));
          }
          function Tt() {
            if (!Y || !k || !J) return;
            const ye = M && M.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO, Rt = z.getCurrentDVRInfo(ye);
            return Rt && Rt.range ? Rt.range.end : 0;
          }
          function yt(ye) {
            const Rt = new Date(H.getClientReferenceTime()), Wt = O.getRegularPeriods()[0];
            D = H.calcPresentationTimeFromWallTime(Rt, Wt) - ye;
          }
          function nt() {
            return Y && k ? k.getTime() : null;
          }
          function ct() {
            return Y && k ? k.isPaused() : null;
          }
          function V() {
            return Y && k ? k.isSeeking() : null;
          }
          function mt() {
            return Y && k ? k.isStalled() : null;
          }
          function Mt() {
            return Y && k ? k.getPlaybackRate() : null;
          }
          function Lt() {
            return Y && k ? k.getEnded() : null;
          }
          function Bt() {
            return J;
          }
          function Qt() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
            if (ct() || !J || k.getReadyState() === 0 || V() || K) return;
            ye || (ye = M.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO);
            const Rt = nt(), Wt = function(Ee, te) {
              const Ie = z.getCurrentDVRInfo(te), rn = Ie ? Ie.range : null;
              let Tn;
              return rn ? (Tn = Ee > rn.end ? Math.max(rn.end - D, rn.start) : Ee > 0 && Ee + 0.25 < rn.start && Math.abs(Ee - rn.start) < 31536e4 ? At ? Math.max(rn.end - D, rn.start) : rn.start : Ee, Tn) : NaN;
            }(Rt, ye);
            !isNaN(Wt) && Wt !== Rt && !V() && (mt() || G || k.getReadyState() === 1) && (v.debug(`UpdateCurrentTime: Seek to actual time: ${Wt} from currentTime: ${Rt}`), tt(Wt, !1, !1));
          }
          function Zt() {
            B === null && (B = setInterval(() => {
              (function() {
                if (f.trigger(et.A.WALLCLOCK_TIME_UPDATED, { isDynamic: J, time: /* @__PURE__ */ new Date() }), Bt()) {
                  const ye = Date.now();
                  (isNaN(at) || ye > at + bt.get().streaming.liveUpdateTimeThresholdInMilliseconds) && (M.addDVRMetric(), ct() ? function() {
                    const Rt = Date.now();
                    (!lt || Rt > lt + 500) && (lt = Rt, Rn());
                  }() : Qt(), at = ye);
                }
              })();
            }, bt.get().streaming.wallclockTimeUpdateInterval));
          }
          function fe() {
            clearInterval(B), B = null;
          }
          function Ue(ye) {
            const Rt = ye.currentRepresentation, Wt = Rt ? Rt.mediaInfo.streamInfo : null;
            Wt !== null && Y.id === Wt.id && (Y = Wt);
          }
          function Ye() {
            f.trigger(et.A.CAN_PLAY);
          }
          function on() {
            f.trigger(et.A.CAN_PLAY_THROUGH);
          }
          function cn(ye) {
            ye.streamId === M.getActiveStreamInfo().id && (G = ye.state === pt.BUFFER_EMPTY, bt.get().streaming.buffer.setStallState && k.setStallState(ye.mediaType, ye.state === pt.BUFFER_EMPTY));
          }
          function Nn() {
            v.info("Native video element event: play"), Qt(), Zt(), f.trigger(et.A.PLAYBACK_STARTED, { startTime: nt() });
          }
          function Qe() {
            v.info("Native video element event: waiting"), f.trigger(et.A.PLAYBACK_WAITING, { playingTime: nt() });
          }
          function hn() {
            v.info("Native video element event: playing"), F = !1, f.trigger(et.A.PLAYBACK_PLAYING, { playingTime: nt() });
          }
          function Sn() {
            v.info("Native video element event: pause"), f.trigger(et.A.PLAYBACK_PAUSED, { ended: Lt() });
          }
          function jn() {
            if (F) return;
            let ye = nt();
            isNaN(Z) || Z === ye || (ye = Z), Z = NaN, v.info("Seeking to: " + ye), Zt(), f.trigger(et.A.PLAYBACK_SEEKING, { seekTime: ye, streamId: Y.id });
          }
          function Ln() {
            v.info("Native video element event: seeked"), F = !1, f.trigger(et.A.PLAYBACK_SEEKED);
          }
          function Rn() {
            Y && f.trigger(et.A.PLAYBACK_TIME_UPDATED, { timeToEnd: vt(), time: nt(), streamId: Y.id });
          }
          function $t() {
            f.trigger(et.A.PLAYBACK_PROGRESS, { streamId: Y.id });
          }
          function be() {
            const ye = Mt();
            v.info("Native video element event: ratechange: ", ye), f.trigger(et.A.PLAYBACK_RATE_CHANGED, { playbackRate: ye });
          }
          function ge() {
            v.info("Native video element event: loadedmetadata"), f.trigger(et.A.PLAYBACK_METADATA_LOADED), Zt();
          }
          function Te() {
            v.info("Native video element event: loadeddata"), f.trigger(et.A.PLAYBACK_LOADED_DATA);
          }
          function ee() {
            v.info("Native video element event: ended"), W(), fe();
            const ye = M ? M.getActiveStreamInfo() : null;
            ye && f.trigger(et.A.PLAYBACK_ENDED, { isLast: ye.isLast });
          }
          function De() {
            f.trigger(et.A.PLAYBACK_VOLUME_CHANGED);
          }
          function Pe(ye) {
            if (B && ye.isLast) {
              v.info("onPlaybackEnded -- PLAYBACK_ENDED but native video element didn't fire ended");
              const Rt = ye.seekTime ? ye.seekTime : Pt();
              k.setCurrentTime(Rt), W(), fe();
            }
          }
          function nn(ye) {
            const Rt = ye.target || ye.srcElement;
            f.trigger(et.A.PLAYBACK_ERROR, { error: Rt.error });
          }
          function sn() {
            J = !1;
          }
          function gn(ye) {
            f.trigger(et.A.PLAYBACK_STALLED, { e: ye });
          }
          function ie(ye) {
            var Rt;
            (Rt = ye.mediaInfo) && Rt.supplementalProperties && Rt.supplementalProperties.find((Wt) => Wt.schemeIdUri === q.A.SUPPLEMENTAL_PROPERTY_DVB_LL_SCHEME) && (v.debug("Low Latency critical SupplementalProperty set: Enabling low Latency"), At = !0);
          }
          function Le(ye) {
            const Rt = M.getActiveStreamInfo();
            ye && Rt && ye.currentRepresentation && ye.streamId && ye.streamId === Rt.id && ye.mediaType && (ye.mediaType === q.A.VIDEO || ye.mediaType === q.A.AUDIO || ye.mediaType === q.A.MESH) && (ht = ye.currentRepresentation.availabilityTimeComplete, At = !ht, At && !ft && (ft = !0));
          }
          function We() {
            K = !0;
          }
          function ln() {
            K = !1;
          }
          return E = { computeAndSetLiveDelay: function(ye, Rt) {
            let Wt, Ee, te;
            const Ie = !isNaN(ye) && isFinite(ye) ? ye : NaN;
            let rn = O.getSuggestedPresentationDelay();
            const Tn = x.getServiceDescriptionSettings();
            return Wt = isNaN(bt.get().streaming.delay.liveDelay) ? bt.get().streaming.delay.liveDelayFragmentCount === null || isNaN(bt.get().streaming.delay.liveDelayFragmentCount) || isNaN(Ie) ? Tn && !isNaN(Tn.liveDelay) && Tn.liveDelay > 0 ? Tn.liveDelay : bt.get().streaming.delay.useSuggestedPresentationDelay === !0 && rn !== null && !isNaN(rn) && rn > 0 ? rn : isNaN(Ie) ? Rt && !isNaN(Rt.minBufferTime) ? 4 * Rt.minBufferTime : 4 * Y.manifestInfo.minBufferTime : 4 * Ie : Ie * bt.get().streaming.delay.liveDelayFragmentCount : bt.get().streaming.delay.liveDelay, te = O.getAvailabilityStartTime(), te !== null && (st = te), Ee = Rt && Rt.dvrWindowSize > 0 ? Math.min(Wt, Rt.dvrWindowSize) : Wt, D = Ee, N = Ee, Ee;
          }, getAvailabilityStartTime: function() {
            return st;
          }, getBufferLevel: function() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, Rt = null;
            return M.getActiveStreamProcessors().forEach((Wt) => {
              if (!ye || ye.length === 0 || ye.indexOf(Wt.getType()) === -1) {
                const Ee = Wt.getBufferLevel();
                Rt = Rt === null ? Ee : Math.min(Rt, Ee);
              }
            }), Rt;
          }, getCurrentLiveLatency: function() {
            if (!J || isNaN(st)) return NaN;
            let ye = nt();
            if (isNaN(ye) || ye === 0) return 0;
            const Rt = (/* @__PURE__ */ new Date()).getTime() + 1e3 * H.getClientTimeOffset();
            return Math.max(((Rt - st - 1e3 * ye) / 1e3).toFixed(3), 0);
          }, getEnded: Lt, getInitialCatchupModeActivated: function() {
            return ft;
          }, getIsDynamic: Bt, getIsManifestUpdateInProgress: function() {
            return K;
          }, getLiveDelay: function() {
            return D;
          }, getLowLatencyModeEnabled: function() {
            return At;
          }, getOriginalLiveDelay: function() {
            return N;
          }, getPlaybackRate: Mt, getPlaybackStalled: function() {
            return G;
          }, getPlayedRanges: function() {
            return Y && k ? k.getPlayedRanges() : null;
          }, getStreamController: function() {
            return M;
          }, getStreamEndTime: Pt, getTime: nt, getTimeToStreamEnd: vt, initialize: function(ye, Rt) {
            Y = ye, Rt !== !0 && (k.addEventListener("canplay", Ye), k.addEventListener("canplaythrough", on), k.addEventListener("play", Nn), k.addEventListener("waiting", Qe), k.addEventListener("playing", hn), k.addEventListener("pause", Sn), k.addEventListener("error", nn), k.addEventListener("seeking", jn), k.addEventListener("seeked", Ln), k.addEventListener("timeupdate", Rn), k.addEventListener("progress", $t), k.addEventListener("ratechange", be), k.addEventListener("loadedmetadata", ge), k.addEventListener("loadeddata", Te), k.addEventListener("stalled", gn), k.addEventListener("ended", ee), k.addEventListener("volumechange", De), J = Y.manifestInfo.isDynamic, G = !1, F = !1, f.on(et.A.DATA_UPDATE_COMPLETED, Ue, E), f.on(et.A.MANIFEST_UPDATED, We, E), f.on(et.A.STREAMS_COMPOSED, ln, E), f.on(St.A.PLAYBACK_ENDED, Pe, E, { priority: It.A.EVENT_PRIORITY_HIGH }), f.on(St.A.STREAM_INITIALIZING, ie, E), f.on(St.A.REPRESENTATION_SWITCH, Le, E), f.on(St.A.BUFFER_LEVEL_STATE_CHANGED, cn, E), f.on(St.A.DYNAMIC_TO_STATIC, sn, E), it && (it = !1, Ot()));
          }, isPaused: ct, isProgressing: function() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 500;
            return new Promise((Rt) => {
              let Wt = -1, Ee = null;
              const te = (rn) => {
                clearTimeout(Ee), Ee = null, f.off(St.A.PLAYBACK_TIME_UPDATED, Ie, E), Rt(rn);
              }, Ie = (rn) => {
                Wt < 0 ? Wt = rn.time : rn.time > Wt + 0.1 && te(!0);
              };
              Ee = setTimeout(() => {
                te(!1);
              }, ye), f.on(St.A.PLAYBACK_TIME_UPDATED, Ie, E);
            });
          }, isSeeking: V, isStalled: mt, pause: W, play: Ot, reset: _t, seek: tt, seekToCurrentLive: function() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], Rt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Wt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const Ee = Tt();
            Ee !== 0 && tt(Ee - D, ye, Rt, Wt);
          }, seekToOriginalLive: function() {
            let ye = arguments.length > 0 && arguments[0] !== void 0 && arguments[0], Rt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1], Wt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const Ee = Tt();
            Ee !== 0 && (D = N, tt(Ee - D, ye, Rt, Wt));
          }, setConfig: function(ye) {
            ye && (ye.streamController && (M = ye.streamController), ye.serviceDescriptionController && (x = ye.serviceDescriptionController), ye.dashMetrics && (z = ye.dashMetrics), ye.adapter && (O = ye.adapter), ye.videoModel && (k = ye.videoModel), ye.timelineConverter && (H = ye.timelineConverter), ye.settings && (bt = ye.settings));
          }, updateCurrentTime: Qt }, v = (0, ae.A)(y).getInstance().getLogger(E), _t(), E;
        }
        qe.__dashjs_factory_name = "PlaybackController";
        var zt = Dt.A.getSingletonFactory(qe), Ct = b(7568);
        class de {
          constructor(f) {
            this.action = de.ACTION_DOWNLOAD, this.availabilityEndTime = null, this.availabilityStartTime = null, this.bandwidth = NaN, this.bytesLoaded = NaN, this.bytesTotal = NaN, this.delayLoadingTime = NaN, this.duration = NaN, this.endDate = null, this.firstByteDate = null, this.index = NaN, this.mediaStartTime = NaN, this.mediaType = null, this.quality = NaN, this.range = null, this.representation = null, this.responseType = "arraybuffer", this.serviceLocation = null, this.startDate = null, this.startTime = NaN, this.timescale = NaN, this.type = null, this.url = f || null, this.wallStartTime = null;
          }
          isInitializationRequest() {
            return this.type && this.type === Ct.G.INIT_SEGMENT_TYPE;
          }
          setInfo(f) {
            this.type = f && f.init ? Ct.G.INIT_SEGMENT_TYPE : Ct.G.MEDIA_SEGMENT_TYPE, this.url = f && f.url ? f.url : null, this.range = f && f.range ? f.range.start + "-" + f.range.end : null, this.mediaType = f && f.mediaType ? f.mediaType : null, this.representation = f && f.representation ? f.representation : null;
          }
        }
        de.ACTION_DOWNLOAD = "download", de.ACTION_COMPLETE = "complete";
        var ze = de;
        const le = "loading", Ze = "executed", me = "failed";
        function bn(y) {
          const f = (y = y || {}).eventBus, E = y.events, v = y.dashMetrics, M = y.fragmentLoader, x = y.debug, z = y.streamInfo, O = y.type;
          let k, H, B, D;
          function N(F) {
            return !!F && function(G) {
              let K = !1;
              return G.some((ft) => {
                if (bt = F, _t = ft, !isNaN(bt.index) && bt.startTime === _t.startTime && bt.adaptationIndex === _t.adaptationIndex && bt.type === _t.type || function(vt, Pt) {
                  return vt.representation.id === Pt.representation.id;
                }(F, ft) || function(vt, Pt) {
                  return vt.action === ze.ACTION_COMPLETE && vt.action === Pt.action;
                }(F, ft)) return K = !0, K;
                var bt, _t;
              }), K;
            }(B);
          }
          function Y(F) {
            return isNaN(F.duration) ? 0.25 : Math.min(F.duration / 8, 0.5);
          }
          function J(F) {
            B = B.filter((G) => {
              const K = Y(G);
              return isNaN(G.startTime) || F !== void 0 && G.startTime >= F - K;
            });
          }
          function it(F, G) {
            G <= F + 0.5 || (B = B.filter((K) => {
              const ft = Y(K);
              return isNaN(K.startTime) || K.startTime >= G - ft || isNaN(K.duration) || K.startTime + K.duration <= F + ft;
            }));
          }
          function lt(F, G, K) {
            for (let ft = F.length - 1; ft >= 0; ft--) {
              const bt = F[ft], _t = bt.startTime, vt = _t + bt.duration;
              if (K = isNaN(K) ? Y(bt) : K, !isNaN(_t) && !isNaN(vt) && G + K >= _t && G - K < vt || isNaN(_t) && isNaN(G)) return bt;
            }
            return null;
          }
          function at(F, G) {
            v.addSchedulingInfo(F, G), v.addRequestsQueue(F.mediaType, D, B);
          }
          function st(F) {
            F.sender === M && (D.splice(D.indexOf(F.request), 1), F.response && !F.error && B.push(F.request), at(F.request, F.error ? me : Ze), f.trigger(E.FRAGMENT_LOADING_COMPLETED, { request: F.request, response: F.response, error: F.error, sender: this }, { streamId: z.id, mediaType: O }));
          }
          function ht(F) {
            F.sender === M && f.trigger(E.FRAGMENT_LOADING_PROGRESS, { request: F.request, response: F.response, error: F.error, sender: this }, { streamId: z.id, mediaType: O });
          }
          function At(F) {
            F.sender === M && f.trigger(E.FRAGMENT_LOADING_ABANDONED, { request: F.request }, { streamId: z.id, mediaType: O });
          }
          function Z() {
            B = [], D = [], M && M.resetInitialSettings();
          }
          return k = { abortRequests: function() {
            H.debug("abort requests"), M.abort(), D = [];
          }, executeRequest: function(F) {
            F.action === ze.ACTION_DOWNLOAD ? (at(F, le), D.push(F), function(G) {
              f.trigger(E.FRAGMENT_LOADING_STARTED, { request: G }, { streamId: z.id, mediaType: O }), M.load(G);
            }(F)) : H.warn("Unknown request action.");
          }, getRequests: function(F) {
            const G = F ? F.state instanceof Array ? F.state : [F.state] : [];
            let K = [];
            return G.forEach((ft) => {
              const bt = function(_t) {
                let vt;
                switch (_t) {
                  case le:
                    vt = D;
                    break;
                  case Ze:
                    vt = B;
                    break;
                  default:
                    vt = [];
                }
                return vt;
              }(ft);
              K = K.concat(function(_t, vt) {
                return vt.hasOwnProperty("time") ? [lt(_t, vt.time, vt.threshold)] : _t.filter((Pt) => {
                  for (const Ot in vt) if (Ot !== "state" && vt.hasOwnProperty(Ot) && Pt[Ot] != vt[Ot]) return !1;
                  return !0;
                });
              }(bt, F));
            }), K;
          }, getStreamId: function() {
            return z.id;
          }, getType: function() {
            return O;
          }, isFragmentLoaded: N, isFragmentLoadedOrPending: function(F) {
            let G, K = !1, ft = 0;
            if (K = N(F), !K) for (ft = 0; ft < D.length; ft++) G = D[ft], F.url === G.url && F.startTime === G.startTime && (K = !0);
            return K;
          }, removeExecutedRequestsAfterTime: function(F) {
            B = B.filter((G) => isNaN(G.startTime) || F !== void 0 && G.startTime < F);
          }, removeExecutedRequestsBeforeTime: J, reset: function() {
            f.off(E.LOADING_COMPLETED, st, this), f.off(E.LOADING_DATA_PROGRESS, ht, this), f.off(E.LOADING_ABANDONED, At, this), M && M.reset(), Z();
          }, resetInitialSettings: Z, syncExecutedRequestsWithBufferedRange: function(F, G) {
            if (!F || F.length === 0) return void J();
            let K = 0;
            for (let ft = 0, bt = F.length; ft < bt; ft++) it(K, F.start(ft)), K = F.end(ft);
            G > 0 && it(K, G);
          } }, H = x.getLogger(k), Z(), f.on(E.LOADING_COMPLETED, st, k), f.on(E.LOADING_DATA_PROGRESS, ht, k), f.on(E.LOADING_ABANDONED, At, k), k;
        }
        bn.__dashjs_factory_name = "FragmentModel";
        const pn = Dt.A.getClassFactory(bn);
        pn.FRAGMENT_MODEL_LOADING = le, pn.FRAGMENT_MODEL_EXECUTED = Ze, pn.FRAGMENT_MODEL_CANCELED = "canceled", pn.FRAGMENT_MODEL_FAILED = me, Dt.A.updateClassFactory(bn.__dashjs_factory_name, pn);
        var wn = pn, Yt = b(1944), Ht = b(8748);
        class Me extends Ht.A {
          constructor() {
            super(), this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE = 10, this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE = 11, this.XLINK_LOADER_LOADING_FAILURE_ERROR_CODE = 12, this.SEGMENT_BASE_LOADER_ERROR_CODE = 15, this.TIME_SYNC_FAILED_ERROR_CODE = 16, this.FRAGMENT_LOADER_LOADING_FAILURE_ERROR_CODE = 17, this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_CODE = 18, this.URL_RESOLUTION_FAILED_GENERIC_ERROR_CODE = 19, this.APPEND_ERROR_CODE = 20, this.REMOVE_ERROR_CODE = 21, this.DATA_UPDATE_FAILED_ERROR_CODE = 22, this.CAPABILITY_MEDIASOURCE_ERROR_CODE = 23, this.CAPABILITY_MEDIAKEYS_ERROR_CODE = 24, this.DOWNLOAD_ERROR_ID_MANIFEST_CODE = 25, this.DOWNLOAD_ERROR_ID_SIDX_CODE = 26, this.DOWNLOAD_ERROR_ID_CONTENT_CODE = 27, this.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE = 28, this.DOWNLOAD_ERROR_ID_XLINK_CODE = 29, this.MANIFEST_ERROR_ID_PARSE_CODE = 31, this.MANIFEST_ERROR_ID_NOSTREAMS_CODE = 32, this.TIMED_TEXT_ERROR_ID_PARSE_CODE = 33, this.MANIFEST_ERROR_ID_MULTIPLEXED_CODE = 34, this.MEDIASOURCE_TYPE_UNSUPPORTED_CODE = 35, this.NO_SUPPORTED_KEY_IDS = 36, this.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE = "parsing failed for ", this.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE = "Failed loading manifest: ", this.XLINK_LOADER_LOADING_FAILURE_ERROR_MESSAGE = "Failed loading Xlink element: ", this.SEGMENTS_UPDATE_FAILED_ERROR_MESSAGE = "Segments update failed", this.SEGMENTS_UNAVAILABLE_ERROR_MESSAGE = "no segments are available yet", this.SEGMENT_BASE_LOADER_ERROR_MESSAGE = "error loading segment ranges from sidx", this.TIME_SYNC_FAILED_ERROR_MESSAGE = "Failed to synchronize client and server time", this.FRAGMENT_LOADER_NULL_REQUEST_ERROR_MESSAGE = "request is null", this.URL_RESOLUTION_FAILED_GENERIC_ERROR_MESSAGE = "Failed to resolve a valid URL", this.APPEND_ERROR_MESSAGE = "chunk is not defined", this.REMOVE_ERROR_MESSAGE = "Removing data from the SourceBuffer", this.DATA_UPDATE_FAILED_ERROR_MESSAGE = "Data update failed", this.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE = "mediasource is not supported", this.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE = "mediakeys is not supported", this.TIMED_TEXT_ERROR_MESSAGE_PARSE = "parsing error :", this.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE = "Error creating source buffer of type : ", this.NO_SUPPORTED_KEY_IDS_MESSAGE = "All possible Adaptation Sets have an invalid key status";
          }
        }
        var X = new Me(), Q = b(8261);
        function C(y) {
          const f = this.context, E = (0, Q.A)(f).getInstance(), v = y.textController, M = y.eventBus;
          let x, z, O, k, H, B, D = [], N = [], Y = !1, J = y.mediaSource, it = null;
          function lt(_t) {
            return _t.mimeType + ';codecs="' + _t.codecs + '"';
          }
          function at(_t) {
            return k = v.getTextSourceBuffer(_t), Promise.resolve();
          }
          function st() {
            if (typeof k.addEventListener == "function") try {
              k.addEventListener("updateend", K, !1), k.addEventListener("error", ft, !1), k.addEventListener("abort", ft, !1);
            } catch {
              B = setInterval(K, 50);
            }
            else B = setInterval(K, 50);
          }
          function ht() {
            try {
              typeof k.removeEventListener == "function" && (k.removeEventListener("updateend", K, !1), k.removeEventListener("error", ft, !1), k.removeEventListener("abort", ft, !1)), clearInterval(B);
            } catch (_t) {
              O.error(_t);
            }
          }
          function At(_t) {
            return new Promise((vt) => {
              k && E.get().streaming.buffer.useAppendWindow ? bt(() => {
                try {
                  if (!k) return void vt();
                  let Pt = J.duration, Ot = 0;
                  _t && !isNaN(_t.start) && !isNaN(_t.duration) && isFinite(_t.duration) && (Pt = _t.start + _t.duration), _t && !isNaN(_t.start) && (Ot = _t.start), k.appendWindowEnd === Pt && k.appendWindowStart === Ot || (k.appendWindowStart = 0, k.appendWindowEnd = Pt + 0.01, k.appendWindowStart = Math.max(Ot - 0.1, 0), O.debug(`Updated append window for ${H.type}. Set start to ${k.appendWindowStart} and end to ${k.appendWindowEnd}`)), vt();
                } catch {
                  O.warn("Failed to set append window"), vt();
                }
              }) : vt();
            });
          }
          function Z(_t) {
            return new Promise((vt) => {
              k ? bt(() => {
                try {
                  k.timestampOffset === _t || isNaN(_t) || (k.timestampOffset = _t, O.debug(`Set MSE timestamp offset to ${_t}`)), vt();
                } catch {
                  vt();
                }
              }) : vt();
            });
          }
          function F() {
            if (!Y && N.length > 0) {
              Y = !0;
              const _t = N[0];
              N.splice(0, 1);
              const vt = function() {
                Y = !1, N.length > 0 && F.call(this), _t && _t.data && _t.data.segmentType && _t.data.segmentType !== Ct.G.INIT_SEGMENT_TYPE && delete _t.data.bytes, _t.promise.resolve({ chunk: _t.data });
              };
              try {
                if (it = _t.request, _t.data.bytes.byteLength === 0) vt.call(this);
                else {
                  try {
                    O.debug(`Appending ${_t.data.segmentType} from period ${_t.data.streamId} to buffer. Request URL: ${_t.request.url}, Representation: ID: ${_t.data.representation.id}, bitrate: ${_t.data.representation.bitrateInKbit}`);
                  } catch {
                  }
                  k.appendBuffer ? k.appendBuffer(_t.data.bytes) : k.append(_t.data.bytes, _t.data), bt(vt.bind(this));
                }
              } catch (Pt) {
                O.fatal('SourceBuffer append failed "' + Pt + '"'), N.length > 0 ? F() : Y = !1, delete _t.data.bytes, _t.promise.reject({ chunk: _t.data, error: new Yt.A(Pt.code, Pt.message) });
              }
            }
          }
          function G() {
            D.length > 0 && !k.updating && (D.shift()(), G());
          }
          function K() {
            k.updating || G();
          }
          function ft(_t) {
            const vt = _t.target || {};
            (function(Pt, Ot) {
              let W = Ot || {};
              M.trigger(Pt, W, { streamId: H.streamInfo.id, mediaType: z });
            })(et.A.SOURCE_BUFFER_ERROR, { error: vt, lastRequestAppended: it });
          }
          function bt(_t) {
            try {
              D.push(_t), k.updating || G();
            } catch (vt) {
              O.error(vt);
            }
          }
          return x = { abort: function() {
            return new Promise((_t) => {
              try {
                N = [], J.readyState === "open" ? bt(() => {
                  try {
                    k && k.abort(), _t();
                  } catch {
                    _t();
                  }
                }) : (k && k.setTextTrack && J.readyState === "ended" && k.abort(), _t());
              } catch {
                _t();
              }
            });
          }, abortBeforeAppend: function() {
            return new Promise((_t) => {
              bt(() => {
                const vt = k.appendWindowStart, Pt = k.appendWindowEnd;
                k && (k.abort(), k.appendWindowStart = vt, k.appendWindowEnd = Pt), _t();
              });
            });
          }, append: function(_t) {
            let vt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return new Promise((Pt, Ot) => {
              _t ? (N.push({ data: _t, promise: { resolve: Pt, reject: Ot }, request: vt }), bt(F.bind(this))) : Ot({ chunk: _t, error: new Yt.A(X.APPEND_ERROR_CODE, X.APPEND_ERROR_MESSAGE) });
            });
          }, changeType: function(_t) {
            const vt = lt(_t);
            return new Promise((Pt) => {
              bt(() => {
                k.changeType && (O.debug(`Changing SourceBuffer codec to ${vt}`), k.changeType(vt)), Pt();
              });
            });
          }, getAllBufferRanges: function() {
            try {
              return k.buffered;
            } catch (_t) {
              return O.error("getAllBufferRanges exception: " + _t.message), null;
            }
          }, getBuffer: function() {
            return k;
          }, getType: function() {
            return z;
          }, initializeForFirstUse: function(_t, vt) {
            H = _t;
            const Pt = _t.streamInfo;
            z = H.type;
            const Ot = vt ? lt(vt) : _t.codec;
            try {
              if (Ot.match(/application\/mp4;\s*codecs="(stpp|wvtt).*"/i)) return at(Pt);
              k = J.addSourceBuffer(Ot), st();
              const W = [];
              return W.push(At(H.streamInfo)), vt && vt.mseTimeOffset !== void 0 && W.push(Z(vt.mseTimeOffset)), Promise.all(W);
            } catch (W) {
              return H.type == q.A.TEXT && !H.isFragmented || Ot.indexOf('codecs="stpp') !== -1 || Ot.indexOf('codecs="vtt') !== -1 || Ot.indexOf("text/vtt") !== -1 ? at(Pt) : Promise.reject(W);
            }
          }, initializeForStreamSwitch: function(_t, vt, Pt) {
            H = _t, z = H.type, function(Ot) {
              k = Ot.getBuffer();
            }(Pt), st();
          }, remove: function(_t) {
            return new Promise((vt, Pt) => {
              const Ot = _t.start, W = _t.end;
              Ot >= 0 && W > Ot ? bt(function() {
                try {
                  k.remove(Ot, W), bt(function() {
                    vt({ from: Ot, to: W, unintended: !1 }), _t.resolve && _t.resolve();
                  });
                } catch (tt) {
                  Pt({ from: Ot, to: W, unintended: !1, error: new Yt.A(X.REMOVE_ERROR_CODE, X.REMOVE_ERROR_MESSAGE) }), _t.reject && _t.reject(tt);
                }
              }) : vt();
            });
          }, removeEventListeners: ht, reset: function() {
            if (k) {
              try {
                D = [], ht(), Y = !1, N = [], k.getClassName && k.getClassName() === "TextSourceBuffer" || (O.debug("Removing sourcebuffer from media source"), J.removeSourceBuffer(k));
              } catch {
              }
              k = null;
            }
            it = null;
          }, updateAppendWindow: At, updateTimestampOffset: Z }, O = (0, ae.A)(f).getInstance().getLogger(x), x;
        }
        C.__dashjs_factory_name = "SourceBufferSink";
        var U = Dt.A.getClassFactory(C);
        function gt(y) {
          const f = this.context;
          let E, v, M, x = [], z = y;
          function O(k, H) {
            return x = x.filter((B) => !((isNaN(H) || B.start < H) && (isNaN(k) || B.end > k))), Promise.resolve();
          }
          return E = { getAllBufferRanges: function() {
            let k = [];
            for (let B = 0; B < x.length; B++) {
              let D = x[B];
              k.length === 0 || D.start > k[k.length - 1].end ? k.push({ start: D.start, end: D.end }) : k[k.length - 1].end = D.end;
            }
            const H = { start: function(B) {
              return k[B].start;
            }, end: function(B) {
              return k[B].end;
            } };
            return Object.defineProperty(H, "length", { get: function() {
              return k.length;
            } }), H;
          }, append: function(k) {
            return k.segmentType !== "InitializationSegment" ? (x.push(k), x.sort(function(H, B) {
              return H.start - B.start;
            }), M = null) : M = k, v.debug("PreBufferSink appended chunk s: " + k.start + "; e: " + k.end), z && z({ chunk: k }), Promise.resolve();
          }, remove: O, abort: function() {
            return Promise.resolve();
          }, discharge: function(k, H) {
            const B = function(D, N) {
              return x.filter((Y) => (isNaN(N) || Y.start < N) && (isNaN(D) || Y.end > D));
            }(k, H);
            return M && (B.push(M), M = null), O(k, H), B;
          }, reset: function() {
            x = [], M = null, z = null;
          }, updateTimestampOffset: function() {
            return Promise.resolve();
          }, waitForUpdateEnd: function(k) {
            k();
          }, getBuffer: function() {
            return this;
          } }, v = (0, ae.A)(f).getInstance().getLogger(E), E;
        }
        gt.__dashjs_factory_name = "PreBufferSink";
        var rt = Dt.A.getClassFactory(gt);
        function Ft() {
          let y = {};
          return { save: function(f) {
            const E = f.streamId, v = f.representation.id;
            y[E] = y[E] || {}, y[E][v] = f;
          }, extract: function(f, E) {
            return y && y[f] && y[f][E] ? y[f][E] : null;
          }, reset: function() {
            y = {};
          } };
        }
        Ft.__dashjs_factory_name = "InitCache";
        var ne = Dt.A.getSingletonFactory(Ft);
        const Vt = 0.01, Xt = "BufferController";
        function qt(y) {
          const f = (y = y || {}).capabilities, E = this.context, v = (0, It.A)(E).getInstance(), M = y.fragmentModel, x = y.playbackController, z = y.representationController, O = y.settings, k = y.streamInfo, H = y.textController, B = y.type;
          let D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft, bt, _t, vt, Pt, Ot, W;
          function tt(ie) {
            let Le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            return new Promise((We, ln) => {
              lt = ie, ht && Le && typeof ht.discharge == "function" ? (At = ht, Tt(Le).then(() => {
                We();
              }).catch((ye) => {
                ln(ye);
              })) : We();
            });
          }
          function Tt(ie) {
            let Le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], We = arguments.length > 2 ? arguments[2] : void 0;
            return new Promise((ln, ye) => {
              vt && ie ? lt ? (Z = !1, function(Rt, Wt, Ee) {
                return new Promise((te) => {
                  ht = U(E).create({ mediaSource: lt, textController: H, eventBus: v }), function(Ie, rn, Tn) {
                    const Un = z.getCurrentRepresentation();
                    return rn && rn[B] && (B === q.A.VIDEO || B === q.A.AUDIO || B === q.A.MESH) ? function(Cn, wi, Ui, zr) {
                      ht.initializeForStreamSwitch(Cn, wi, Ui[B]);
                      const Ji = [];
                      return Ji.push(ht.abortBeforeAppend()), Ji.push(be()), Ji.push(Lt(wi, zr)), wi && wi.mseTimeOffset !== void 0 && Ji.push($t(wi)), Promise.allSettled(Ji);
                    }(Ie, Un, rn, Tn) : function(Cn, wi) {
                      return ht.initializeForFirstUse(Cn, wi);
                    }(Ie, Un);
                  }(Rt, Wt, Ee).then(() => $t(z.getCurrentRepresentation())).then(() => {
                    te(ht);
                  }).catch((Ie) => {
                    N.warn("Caught error on create SourceBuffer: " + Ie), te(ht);
                  });
                });
              }(ie, Le, We).then((Rt) => {
                ln(Rt);
              }).catch((Rt) => {
                ye(Rt);
              })) : (Z = !0, function() {
                return new Promise((Rt, Wt) => {
                  ht = rt(E).create(mt.bind(this)), $t(z.getCurrentRepresentation()).then(() => {
                    Rt(ht);
                  }).catch(() => {
                    Wt();
                  });
                });
              }().then((Rt) => {
                ln(Rt);
              }).catch((Rt) => {
                ye(Rt);
              })) : ln(null);
            });
          }
          function yt(ie) {
            O.get().streaming.cacheInitSegments && (N.info("Init fragment finished loading saving to", B + "'s init cache"), vt.save(ie.chunk)), N.debug("Append Init fragment", B, " with representationId:", ie.chunk.representation.id, " and quality:", ie.chunk.quality, ", data size:", ie.chunk.bytes.byteLength), ct(ie.chunk);
          }
          function nt(ie) {
            ct(ie.chunk, ie.request);
          }
          function ct(ie) {
            let Le = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            ht && (ht.append(ie, Le).then((We) => {
              mt(We);
            }).catch((We) => {
              mt(We);
            }), ie.representation.mediaInfo.type === q.A.VIDEO && sn(et.A.VIDEO_CHUNK_RECEIVED, { chunk: ie }));
          }
          function V(ie) {
            if (ie && ie.length > 0) for (let Le = 0, We = ie.length; Le < We; Le++) N.debug("Buffered range: " + ie.start(Le) + " - " + ie.end(Le) + ", currentTime = ", x.getTime());
          }
          function mt(ie) {
            if (ie.error) return ie.error.code === 22 && function() {
              if (_t = !0, it = 0.8 * De(), N.warn("Quota exceeded, Critical Buffer: " + it), it > 0) {
                const ln = Math.max(0.2 * it, 1), ye = it - ln, Rt = Math.min(O.get().streaming.buffer.bufferTimeAtTopQuality, 0.9 * ye), Wt = Math.min(O.get().streaming.buffer.bufferTimeAtTopQualityLongForm, 0.9 * ye), Ee = { streaming: { buffer: { bufferToKeep: parseFloat(ln.toFixed(5)), bufferTimeAtTopQuality: parseFloat(Rt.toFixed(5)), bufferTimeAtTopQualityLongForm: parseFloat(Wt.toFixed(5)) } } };
                O.update(Ee);
              }
            }(), void (ie.error.code !== 22 && nn() || (N.warn("Clearing playback buffer to overcome quota exceed situation"), sn(et.A.QUOTA_EXCEEDED, { criticalBufferLevel: it, quotaExceededTime: ie.chunk.start }), jn(Sn())));
            if (!ht || (on(), _t = !1, K = ie.chunk, !K || !K.endFragment)) return;
            K && !isNaN(K.index) && (at = Math.max(K.index, at), cn());
            const Le = ht.getAllBufferRanges();
            K.segmentType === Ct.G.MEDIA_SEGMENT_TYPE && (V(Le), Zt(), function() {
              if (isNaN(W) || Z) return;
              if (B !== q.A.AUDIO && B !== q.A.VIDEO && B !== q.A.MESH) return void (W = NaN);
              const ln = x.getTime(), ye = Ye(ln, 0), Rt = Ye(W, 0);
              if (ye && Rt && ye.start === Rt.start) return void (W = NaN);
              const Wt = z.getCurrentRepresentation().segmentDuration, Ee = Ye(W, Wt);
              Ee && (O.get().streaming.buffer.enableSeekDecorrelationFix && Math.abs(ln - W) > Wt ? W <= Ee.end && x.seek(Math.max(W, Ee.start), !1, !0) : ln < Ee.start && x.seek(Ee.start, !1, !0));
            }());
            let We = !1;
            F && (F.indexOf(K) > 0 && (We = !0), F = null), K && !We && sn(et.A.BYTES_APPENDED_END_FRAGMENT, { startTime: K.start, index: K.index, bufferedRanges: Le, segmentType: K.segmentType, mediaType: B, representationId: K.representation.id });
          }
          function Mt(ie, Le) {
            const We = [];
            return We.push($t(ie)), We.push(ht ? ht.abort() : Promise.resolve()), We.push(Lt(ie, Le)), Promise.allSettled(We);
          }
          function Lt(ie, Le) {
            return ie && Le ? ie && Le && ie.mimeType === Le.mimeType && ie.codecFamily === Le.codecFamily ? (N.debug(`Switching to new codec ${ie.codecs} without changeType as previous codec ${Le.codecs} is compatible.`), Promise.resolve()) : O.get().streaming.buffer.useChangeType && f.supportsChangeType() ? (N.debug(`Using changeType() to switch from codec ${Le.codecs} to ${ie.codecs}`), ht.changeType(ie)) : (N.debug("changeType() not available"), Promise.resolve()) : (N.warn("BufferController._changeCodec() is missing the information about the Representations. Doing nothing"), Promise.resolve());
          }
          function Bt() {
            return new Promise((ie, Le) => {
              let We = Qt();
              if (!We || We.length === 0) return Zt(), void ie();
              jn(We).then(() => {
                ie();
              }).catch((ln) => {
                Le(ln);
              });
            });
          }
          function Qt(ie) {
            const Le = [], We = ht.getAllBufferRanges();
            if (!We || We.length === 0) return Le;
            if (!ie && ie !== 0 || isNaN(ie)) Le.push({ start: We.start(0), end: We.end(We.length - 1) + 0.5 });
            else {
              const ln = function(Rt, Wt) {
                const Ee = O.get().streaming.buffer.bufferToKeep, te = Wt.start(0);
                if (Rt - te > Ee) {
                  let Ie = Math.max(0, Rt - Ee);
                  const rn = M.getRequests({ state: wn.FRAGMENT_MODEL_EXECUTED, time: Rt, threshold: Vt })[0];
                  if (rn && (Ie = Math.min(rn.startTime, Ie)), Ie > 0) return { start: te, end: Ie };
                }
                return null;
              }(ie, We), ye = function(Rt, Wt) {
                const Ee = Wt.end(Wt.length - 1) + 0.5, te = Pe(Rt), Ie = k.manifestInfo.duration >= O.get().streaming.buffer.longFormContentDurationThreshold ? O.get().streaming.buffer.bufferTimeAtTopQualityLongForm : O.get().streaming.buffer.bufferTimeAtTopQuality;
                let rn = isNaN(te) ? Rt : Math.min(te, Rt + Ie);
                if (rn >= Wt.end(Wt.length - 1)) return null;
                const Tn = M.getRequests({ state: wn.FRAGMENT_MODEL_EXECUTED, time: Rt, threshold: Vt })[0];
                if (Tn && (rn = Math.max(Tn.startTime + Tn.duration, rn)), O.get().streaming.buffer.avoidCurrentTimeRangePruning) {
                  for (let Un = 0; Un < Wt.length; Un++) if (Wt.start(Un) <= Rt && Rt <= Wt.end(Un) && Wt.start(Un) <= rn && rn <= Wt.end(Un)) {
                    let Cn = rn;
                    rn = Un + 1 < Wt.length ? Wt.start(Un + 1) : Wt.end(Un) + 1, N.debug("Buffered range [" + Wt.start(Un) + ", " + Wt.end(Un) + "] overlaps with targetTime " + Rt + " and range to be pruned [" + Cn + ", " + Ee + "], using [" + rn + ", " + Ee + "] instead" + (rn < Ee ? "" : " (no actual pruning)"));
                    break;
                  }
                }
                return rn < Wt.end(Wt.length - 1) ? { start: rn, end: Ee } : null;
              }(ie, We);
              ln && Le.push(ln), ye && Le.push(ye);
            }
            return Le;
          }
          function Zt() {
            (!Ot || B === q.A.TEXT && H.isTextEnabled()) && on();
          }
          function fe() {
            Nn();
          }
          function Ue() {
            Nn(), W = NaN;
          }
          function Ye(ie, Le) {
            if (!ht) return null;
            const We = ht.getAllBufferRanges();
            let ln, ye, Rt = 0, Wt = 0, Ee = null, te = null, Ie = 0;
            const rn = isNaN(Le) ? 0.15 : Le;
            if (We != null) {
              for (ye = 0, ln = We.length; ye < ln; ye++) if (Rt = We.start(ye), Wt = We.end(ye), Ee === null) Ie = Math.abs(Rt - ie), (ie >= Rt && ie < Wt || Ie <= rn) && (Ee = Rt, te = Wt);
              else {
                if (Ie = Rt - te, !(Ie <= rn)) break;
                te = Wt;
              }
              if (Ee !== null) return { start: Ee, end: te };
            }
            return null;
          }
          function on() {
            if (x) {
              let ie = x.getTime() || 0;
              Z && (ie = isNaN(W) ? 0 : W);
              const Le = O.get().streaming.gaps.jumpGaps && !isNaN(O.get().streaming.gaps.smallGapLimit) ? O.get().streaming.gaps.smallGapLimit : NaN;
              J = Math.max(function(We, ln) {
                let ye, Rt;
                return O.get().streaming.gaps.jumpGaps && (ln = O.get().streaming.gaps.smallGapLimit), ye = Ye(We, ln), Rt = ye === null ? 0 : ye.end - We, Rt;
              }(ie, Le), 0), sn(et.A.BUFFER_LEVEL_UPDATED, { mediaType: B, bufferLevel: J }), Nn();
            }
          }
          function cn() {
            const ie = at >= st - 1, Le = x.getTimeToStreamEnd(k) - J < 1e-5;
            !ie && !Le || Y || (ee(!0), N.debug(`checkIfBufferingCompleted trigger BUFFERING_COMPLETED for stream id ${k.id} and type ${B}`));
          }
          function Nn() {
            B !== q.A.AUDIO && B !== q.A.VIDEO && B !== q.A.MESH || ((!x.getLowLatencyModeEnabled() && J < O.get().streaming.buffer.stallThreshold || J === 0) && !Y ? Qe(pt.BUFFER_EMPTY) : (Y || J >= O.get().streaming.buffer.stallThreshold || x.getLowLatencyModeEnabled() && J > 0) && Qe(pt.BUFFER_LOADED));
          }
          function Qe(ie) {
            G === ie || ie === pt.BUFFER_EMPTY && x.getTime() === 0 || B === q.A.TEXT && !H.isTextEnabled() || (G = ie, sn(et.A.BUFFER_LEVEL_STATE_CHANGED, { state: ie }), sn(ie === pt.BUFFER_LOADED ? et.A.BUFFER_LOADED : et.A.BUFFER_EMPTY), N.debug(ie === pt.BUFFER_LOADED ? "Got enough buffer to start" : "Waiting for more buffer before starting playback"));
          }
          function hn() {
            ht && B !== q.A.TEXT && (Y || jn(Sn()));
          }
          function Sn() {
            const ie = [], Le = ht.getAllBufferRanges();
            if (!Le || Le.length === 0) return ie;
            const We = x.getTime();
            let ln = Math.max(0, We - O.get().streaming.buffer.bufferToKeep);
            const ye = M.getRequests({ state: wn.FRAGMENT_MODEL_EXECUTED, time: We, threshold: Vt })[0];
            if (ye) ln = Math.min(ye.startTime, ln);
            else if (We === 0 && x.getIsDynamic()) return [];
            if (Le.start(0) <= ln) {
              const Rt = { start: 0, end: ln };
              for (let Wt = 0; Wt < Le.length && Le.end(Wt) <= ln; Wt++) Rt.end = Le.end(Wt);
              Rt.start < Rt.end && ie.push(Rt);
            }
            return ie;
          }
          function jn(ie) {
            return new Promise((Le, We) => {
              if (!ie || !ht || ie.length === 0) return on(), void Le();
              const ln = [];
              ie.forEach((ye) => {
                ln.push(function(Rt) {
                  return new Promise((Wt, Ee) => {
                    Rt.resolve = Wt, Rt.reject = Ee, Pt.push(Rt);
                  });
                }(ye));
              }), bt || Ln(), Promise.all(ln).then(() => {
                Le();
              }).catch((ye) => {
                We(ye);
              });
            });
          }
          function Ln() {
            try {
              if (Pt.length === 0 || !ht) return N.debug("Nothing to prune, halt pruning"), Pt = [], void (bt = !1);
              const ie = ht.getBuffer();
              if (!ie || !ie.buffered || ie.buffered.length === 0) return N.debug("SourceBuffer is empty (or does not exist), halt pruning"), Pt = [], void (bt = !1);
              const Le = Pt.shift();
              N.debug(`${B}: Removing buffer from: ${Le.start} to ${Le.end}`), bt = !0, x.getTime() < Le.end && ee(!1), ht.remove(Le).then((We) => {
                Rn(We);
              }).catch((We) => {
                Rn(We);
              });
            } catch {
              bt = !1;
            }
          }
          function Rn(ie) {
            N.debug("onRemoved buffer from:", ie.from, "to", ie.to), ht && (V(ht.getAllBufferRanges()), Pt.length === 0 && (bt = !1, on()), ie.unintended && (N.warn("Detected unintended removal from:", ie.from, "to", ie.to, "setting streamprocessor time to", ie.from), sn(et.A.SEEK_TARGET, { time: ie.from })), bt ? Ln() : (Ot ? Ot = !1 : on(), sn(et.A.BUFFER_CLEARED, { from: ie.from, to: ie.to, unintended: ie.unintended, hasEnoughSpaceToAppend: nn(), quotaExceeded: _t })));
          }
          function $t(ie) {
            return new Promise((Le) => {
              ie && ie.mseTimeOffset !== void 0 && ht && ht.updateTimestampOffset ? ht.updateTimestampOffset(ie.mseTimeOffset).then(() => {
                Le();
              }).catch(() => {
                Le();
              }) : Le();
            });
          }
          function be() {
            return ht && !Y ? ht.updateAppendWindow(k) : Promise.resolve();
          }
          function ge() {
            ft++, ft * (O.get().streaming.wallclockTimeUpdateInterval / 1e3) >= O.get().streaming.buffer.bufferPruningInterval && (ft = 0, hn());
          }
          function Te() {
            Nn();
          }
          function ee(ie) {
            Y = ie, Y ? sn(et.A.BUFFERING_COMPLETED) : st = Number.POSITIVE_INFINITY;
          }
          function De() {
            try {
              const ie = ht.getAllBufferRanges();
              let Le, We, ln = 0;
              if (!ie) return ln;
              for (We = 0, Le = ie.length; We < Le; We++) ln += ie.end(We) - ie.start(We);
              return ln;
            } catch {
              return 0;
            }
          }
          function Pe(ie) {
            try {
              let Le = ie;
              const We = ht.getAllBufferRanges();
              if (!We || We.length === 0) return NaN;
              let ln = 0;
              for (; Le === ie && ln < We.length; ) {
                const ye = We.start(ln), Rt = We.end(ln);
                Le >= ye && Le <= Rt && (Le = Rt), ln += 1;
              }
              return Le === ie ? NaN : Le;
            } catch {
              return NaN;
            }
          }
          function nn() {
            const ie = De();
            return isNaN(ie) || ie < it;
          }
          function sn(ie, Le) {
            let We = Le || {};
            v.trigger(ie, We, { streamId: k.id, mediaType: B });
          }
          function gn(ie, Le) {
            if (it = Number.POSITIVE_INFINITY, G = void 0, st = Number.POSITIVE_INFINITY, at = 0, K = null, Y = !1, bt = !1, _t = !1, J = 0, ft = 0, Pt = [], W = NaN, Z = !1, ht) {
              let We = ht;
              ht = null, ie || (Le ? We.removeEventListeners() : We.abort().then(() => {
                We.reset(Le), We = null;
              }));
            }
            Ot = !1;
          }
          return D = { appendInitSegmentFromCache: function(ie) {
            const Le = vt.extract(k.id, ie);
            return !!Le && (N.info("Append Init fragment", B, " with representationId:", Le.representation.id, " and quality:", Le.quality, ", data size:", Le.bytes.byteLength), ct(Le), !0);
          }, clearBuffers: jn, createBufferSink: Tt, dischargePreBuffer: function() {
            if (ht && At && typeof At.discharge == "function") {
              const ie = At.getAllBufferRanges();
              if (ie.length > 0) {
                let ln = "Beginning " + B + "PreBuffer discharge, adding buffer for:";
                for (let ye = 0; ye < ie.length; ye++) ln += " start: " + ie.start(ye) + ", end: " + ie.end(ye) + ";";
                N.debug(ln);
              } else N.debug("PreBuffer discharge requested, but there were no media segments in the PreBuffer.");
              F = [];
              let Le = At.discharge(), We = null;
              for (let ln = 0; ln < Le.length; ln++) {
                const ye = Le[ln];
                if (ye.segmentType !== Ct.G.INIT_SEGMENT_TYPE) {
                  const Rt = vt.extract(ye.streamId, ye.representation.id);
                  Rt && We !== Rt && (F.push(Rt), ht.append(Rt), We = Rt);
                }
                F.push(ye), ht.append(ye);
              }
              At.reset(), At = null;
            }
          }, getAllRangesWithSafetyFactor: Qt, getBuffer: function() {
            return ht;
          }, getBufferControllerType: function() {
            return Xt;
          }, getBufferLevel: function() {
            return J;
          }, getContinuousBufferTimeForTargetTime: Pe, getIsBufferingCompleted: function() {
            return Y;
          }, getIsPruningInProgress: function() {
            return bt;
          }, getMediaSource: function() {
            return lt;
          }, getRangeAt: Ye, getStreamId: function() {
            return k.id;
          }, getType: function() {
            return B;
          }, hasBufferAtTime: function(ie) {
            try {
              const Le = ht.getAllBufferRanges();
              if (!Le || Le.length === 0) return !1;
              let We = 0;
              for (; We < Le.length; ) {
                const ln = Le.start(We), ye = Le.end(We);
                if (ie >= ln && ie <= ye) return !0;
                We += 1;
              }
              return !1;
            } catch (Le) {
              return N.error(Le), !1;
            }
          }, initialize: function(ie) {
            tt(ie), v.on(et.A.INIT_FRAGMENT_LOADED, yt, D), v.on(et.A.MEDIA_FRAGMENT_LOADED, nt, D), v.on(et.A.WALLCLOCK_TIME_UPDATED, ge, D), v.on(St.A.PLAYBACK_PLAYING, Ue, D), v.on(St.A.PLAYBACK_PROGRESS, Zt, D), v.on(St.A.PLAYBACK_TIME_UPDATED, Zt, D), v.on(St.A.PLAYBACK_RATE_CHANGED, Te, D), v.on(St.A.PLAYBACK_STALLED, fe, D);
          }, prepareForAbandonQualitySwitch: function(ie, Le) {
            return Mt(ie, Le);
          }, prepareForDefaultQualitySwitch: function(ie, Le) {
            return Mt(ie, Le);
          }, prepareForFastQualitySwitch: function(ie, Le) {
            return Mt(ie, Le);
          }, prepareForForceReplacementQualitySwitch: function(ie, Le) {
            return new Promise((We) => {
              const ln = [];
              ln.push(ht.abort()), ln.push(be()), ln.push(Bt()), ln.push($t(ie)), ln.push(Lt(ie, Le)), Promise.allSettled(ln).then(() => {
                ee(!1), We();
              });
            });
          }, prepareForNonReplacementTrackSwitch: function(ie, Le) {
            return new Promise((We) => {
              const ln = [];
              ln.push(be()), ln.push(Lt(ie, Le)), Promise.allSettled(ln).then(() => {
                We();
              });
            });
          }, prepareForPlaybackSeek: function() {
            return Y && ee(!1), ht.abort();
          }, prepareForReplacementTrackSwitch: function(ie, Le) {
            return new Promise((We) => {
              const ln = [];
              ln.push(ht.abort()), ln.push(be()), ln.push(Lt(ie, Le)), ln.push(Bt()), ln.push($t(ie)), Promise.allSettled(ln).then(() => {
                ee(!1), We();
              });
            });
          }, pruneAllSafely: Bt, pruneBuffer: hn, reset: function(ie, Le) {
            v.off(et.A.INIT_FRAGMENT_LOADED, yt, this), v.off(et.A.MEDIA_FRAGMENT_LOADED, nt, this), v.off(et.A.WALLCLOCK_TIME_UPDATED, ge, this), v.off(St.A.PLAYBACK_PLAYING, Ue, this), v.off(St.A.PLAYBACK_PROGRESS, Zt, this), v.off(St.A.PLAYBACK_TIME_UPDATED, Zt, this), v.off(St.A.PLAYBACK_RATE_CHANGED, Te, this), v.off(St.A.PLAYBACK_STALLED, fe, this), gn(ie, Le);
          }, segmentRequestingCompleted: function(ie) {
            isNaN(ie) || (st = ie, cn());
          }, setIsBufferingCompleted: ee, setMediaSource: tt, setSeekTarget: function(ie) {
            W = ie;
          }, updateAppendWindow: be, updateBufferTimestampOffset: $t }, N = (0, ae.A)(E).getInstance().getLogger(D), vt = ne(E).getInstance(), gn(), D;
        }
        qt.__dashjs_factory_name = Xt;
        var Gt = Dt.A.getClassFactory(qt);
        const se = "NotFragmentedTextBufferController";
        function Jt(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance(), v = y.textController, M = y.errHandler, x = y.streamInfo, z = y.type;
          let O, k, H, B, D, N;
          function Y(lt) {
            B = lt;
          }
          function J(lt) {
            k !== lt && (k = lt, k && function(at) {
              let st = {};
              E.trigger(at, st, { streamId: x.id, mediaType: z });
            }(et.A.BUFFERING_COMPLETED));
          }
          function it(lt) {
            lt.chunk.bytes && !k && (N.save(lt.chunk), D.append(lt.chunk), J(!0));
          }
          return O = { initialize: function(lt) {
            Y(lt);
          }, getStreamId: function() {
            return x.id;
          }, getType: function() {
            return z;
          }, getBufferControllerType: function() {
            return se;
          }, createBufferSink: function(lt) {
            return new Promise((at, st) => {
              try {
                D = U(f).create({ mediaSource: B, textController: v, eventBus: E }), D.initializeForFirstUse(lt), H || (D.getBuffer() && typeof D.getBuffer().initialize == "function" && D.getBuffer().initialize(), H = !0), at(D);
              } catch (ht) {
                M.error(new Yt.A(X.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, X.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + z)), st(ht);
              }
            });
          }, dischargePreBuffer: function() {
          }, getBuffer: function() {
            return D;
          }, getBufferLevel: function() {
            return 0;
          }, getRangeAt: function() {
            return null;
          }, pruneBuffer: function() {
          }, hasBufferAtTime: function() {
            return !0;
          }, getAllRangesWithSafetyFactor: function() {
            return [];
          }, getContinuousBufferTimeForTargetTime: function() {
            return Number.POSITIVE_INFINITY;
          }, setMediaSource: Y, getMediaSource: function() {
            return B;
          }, appendInitSegmentFromCache: function(lt) {
            return N.extract(x.id, lt) !== null;
          }, getIsBufferingCompleted: function() {
            return k;
          }, setIsBufferingCompleted: J, getIsPruningInProgress: function() {
            return !1;
          }, reset: function(lt) {
            E.off(et.A.INIT_FRAGMENT_LOADED, it, O), !lt && D && (D.abort(), D.reset(), D = null);
          }, clearBuffers: function() {
            return Promise.resolve();
          }, prepareForPlaybackSeek: function() {
            return Promise.resolve();
          }, prepareForReplacementTrackSwitch: function() {
            return k = !1, Promise.resolve();
          }, setSeekTarget: function() {
          }, updateAppendWindow: function() {
            return Promise.resolve();
          }, pruneAllSafely: function() {
            return Promise.resolve();
          }, updateBufferTimestampOffset: function() {
            return Promise.resolve();
          }, segmentRequestingCompleted: function() {
          } }, H = !1, B = null, k = !1, N = ne(f).getInstance(), E.on(et.A.INIT_FRAGMENT_LOADED, it, O), O;
        }
        Jt.__dashjs_factory_name = se;
        var he = Dt.A.getClassFactory(Jt);
        function an(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance(), v = y.dashMetrics, M = y.mediaPlayerModel, x = y.fragmentModel, z = y.abrController, O = y.playbackController, k = y.textController, H = y.type, B = y.bufferController, D = y.representationController, N = y.settings;
          let Y, J, it, lt, at, st, ht, At, Z, F, G, K;
          function ft() {
            G = !0;
          }
          function bt() {
            G = !1;
          }
          function _t(V) {
            if (B.getIsBufferingCompleted()) return;
            vt();
            const mt = isNaN(V) ? 0 : V;
            at = setTimeout(Pt, mt);
          }
          function vt() {
            at && (clearTimeout(at), at = null);
          }
          function Pt() {
            try {
              if (function() {
                try {
                  return H === q.A.TEXT && !k.isTextEnabled() || O.isPaused() && (!O.getStreamController().getInitialPlayback() || !O.getStreamController().getAutoPlay()) && !N.get().streaming.scheduling.scheduleWhilePaused;
                } catch {
                  return !1;
                }
              }()) return void vt();
              if (function() {
                try {
                  return !!G && D.getCurrentRepresentation() && (At == null || Z || function() {
                    const V = D.getCurrentRepresentation();
                    if (!H || !V) return !0;
                    let mt = V && V.segmentDuration && !isNaN(V.segmentDuration) ? V.segmentDuration : 0;
                    const Mt = v.getCurrentBufferLevel(H), Lt = Ot();
                    return (Lt <= mt || O.getLowLatencyModeEnabled() || H === q.A.AUDIO && st) && (mt = 0), Mt + mt < Lt;
                  }());
                } catch {
                  return !1;
                }
              }()) {
                let V = !1;
                K && (V = z.checkPlaybackQuality(H, J.id)), V || function() {
                  const mt = D.getCurrentRepresentation();
                  F || mt.id !== At || Z ? (Z ? (it.debug("Switch track for " + H + ", representation id = " + mt.id), Z = !1) : it.debug("Quality has changed, get init request for representationid = " + mt.id), H === q.A.MESH && (K = !1, F = !1, window.initMesh = !0), E.trigger(et.A.INIT_FRAGMENT_NEEDED, { representationId: mt.id, sender: Y }, { streamId: J.id, mediaType: H }), K = !1, F = !1) : (it.debug(`Media segment needed for ${H} and stream id ${J.id}`), E.trigger(et.A.MEDIA_FRAGMENT_NEEDED, {}, { streamId: J.id, mediaType: H }), K = !0);
                }();
              } else _t(O.getLowLatencyModeEnabled() ? N.get().streaming.scheduling.lowLatencyTimeout : N.get().streaming.scheduling.defaultTimeout);
            } catch {
              _t(O.getLowLatencyModeEnabled() ? N.get().streaming.scheduling.lowLatencyTimeout : N.get().streaming.scheduling.defaultTimeout);
            }
          }
          function Ot() {
            let V = NaN;
            const mt = D.getCurrentRepresentation();
            return H && mt && (V = H === q.A.TEXT ? function() {
              try {
                if (k.isTextEnabled()) {
                  const Mt = D.getCurrentRepresentation();
                  if (isNaN(Mt.fragmentDuration)) {
                    const Lt = v.getCurrentSchedulingInfo(pt.SCHEDULING_INFO);
                    return Lt ? Lt.duration : 0;
                  }
                  return Mt.fragmentDuration;
                }
                return 0;
              } catch {
                return 0;
              }
            }() : H === q.A.AUDIO && st ? function() {
              try {
                const Mt = v.getCurrentBufferLevel(q.A.VIDEO), Lt = D.getCurrentRepresentation();
                return isNaN(Lt.fragmentDuration) ? Mt + 1 : Math.max(Mt + 1, Lt.fragmentDuration);
              } catch {
                return 0;
              }
            }() : function() {
              try {
                const Mt = D.getCurrentRepresentation(), Lt = Mt.mediaInfo.streamInfo;
                return z.isPlayingAtTopQuality(Mt) ? Lt.manifestInfo.duration >= N.get().streaming.buffer.longFormContentDurationThreshold ? N.get().streaming.buffer.bufferTimeAtTopQualityLongForm : N.get().streaming.buffer.bufferTimeAtTopQuality : M.getBufferTimeDefaultUnadjusted();
              } catch {
                return M.getBufferTimeDefaultUnadjusted();
              }
            }()), V;
          }
          function W() {
            tt(!0);
          }
          function tt(V) {
            if (O && x) {
              const mt = x.getRequests({ state: wn.FRAGMENT_MODEL_EXECUTED, time: O.getTime(), threshold: 0 })[0];
              mt && O.getTime() >= mt.startTime && ((!ht.representation || mt.representation.mediaInfo.type === ht.representation.mediaInfo.type && mt.representation.mediaInfo.index !== ht.representation.mediaInfo.index) && V && (it.debug(`Track change rendered for streamId ${J.id} and type ${H}`), E.trigger(et.A.TRACK_CHANGE_RENDERED, { mediaType: H, oldMediaInfo: ht && ht.representation && ht.representation.mediaInfo ? ht.representation.mediaInfo : null, newMediaInfo: mt.representation.mediaInfo, streamId: J.id })), ht.representation && mt.representation.id === ht.representation.id || !V || (it.debug(`Quality change rendered for streamId ${J.id} and type ${H}`), E.trigger(et.A.QUALITY_CHANGE_RENDERED, { mediaType: H, oldRepresentation: ht.representation ? ht.representation : null, newRepresentation: mt.representation, streamId: J.id })), ht.representation = mt.representation);
            }
          }
          function Tt() {
            x.abortRequests(), vt();
          }
          function yt() {
            N.get().streaming.scheduling.scheduleWhilePaused || _t();
          }
          function nt(V) {
            v.updatePlayListTraceMetrics({ playbackspeed: V.playbackRate.toString() });
          }
          function ct() {
            K = !0, lt = 0, At = null, ht = { representation: null }, Z = !1, F = !1, G = !0;
          }
          return Y = { clearScheduleTimer: vt, getBufferTarget: Ot, getPlaybackController: function() {
            return O;
          }, getStreamId: function() {
            return J.id;
          }, getSwitchTrack: function() {
            return Z;
          }, getTimeToLoadDelay: function() {
            return lt;
          }, getType: function() {
            return H;
          }, initialize: function(V) {
            st = V, E.on(et.A.URL_RESOLUTION_FAILED, Tt, Y), E.on(St.A.PLAYBACK_STARTED, yt, Y), E.on(St.A.PLAYBACK_RATE_CHANGED, nt, Y), E.on(St.A.PLAYBACK_TIME_UPDATED, W, Y), E.on(St.A.MANAGED_MEDIA_SOURCE_START_STREAMING, ft, Y), E.on(St.A.MANAGED_MEDIA_SOURCE_END_STREAMING, bt, Y);
          }, reset: function() {
            E.off(et.A.URL_RESOLUTION_FAILED, Tt, Y), E.off(St.A.PLAYBACK_STARTED, yt, Y), E.off(St.A.PLAYBACK_RATE_CHANGED, nt, Y), E.off(St.A.PLAYBACK_TIME_UPDATED, W, Y), E.off(St.A.MANAGED_MEDIA_SOURCE_START_STREAMING, ft, Y), E.off(St.A.MANAGED_MEDIA_SOURCE_END_STREAMING, bt, Y), vt(), tt(!1), ct(), J = null;
          }, setCheckPlaybackQuality: function(V) {
            K = V;
          }, setInitSegmentRequired: function(V) {
            F = V;
          }, setLastInitializedRepresentationId: function(V) {
            At = V;
          }, setSwitchTrack: function(V) {
            Z = V;
          }, setTimeToLoadDelay: function(V) {
            lt = V;
          }, startScheduleTimer: _t }, it = (0, ae.A)(f).getInstance().getLogger(Y), ct(), J = y.streamInfo, Y;
        }
        an.__dashjs_factory_name = "ScheduleController";
        var Fe = Dt.A.getClassFactory(an), ke = class {
          constructor() {
            this.availabilityEndTime = NaN, this.availabilityStartTime = NaN, this.duration = NaN, this.index = null, this.indexRange = null, this.media = null, this.mediaRange = null, this.mediaStartTime = NaN, this.presentationStartTime = NaN, this.replacementNumber = NaN, this.replacementTime = null, this.representation = null, this.wallStartTime = NaN;
          }
        };
        function ce(y, f) {
          for (; y.length < f; ) y = "0" + y;
          return y;
        }
        function je(y) {
          return y && y.split("$$").join("$");
        }
        function ii(y, f) {
          if (!f || !y || y.indexOf("$RepresentationID$") === -1) return y;
          let E = f.toString();
          return y.split("$RepresentationID$").join(E);
        }
        function Wn(y, f, E) {
          let v, M, x, z, O, k;
          const H = f.length;
          if (!y) return y;
          for (; ; ) {
            if (v = y.indexOf("$" + f), v < 0 || (M = y.indexOf("$", v + H), M < 0)) return y;
            if (x = y.indexOf("%0", v + H), x > v && x < M) switch (z = y.charAt(M - 1), O = parseInt(y.substring(x + 2, M - 1), 10), z) {
              case "d":
              case "i":
              case "u":
                k = ce(E.toString(), O);
                break;
              case "x":
                k = ce(E.toString(16), O);
                break;
              case "X":
                k = ce(E.toString(16), O).toUpperCase();
                break;
              case "o":
                k = ce(E.toString(8), O);
                break;
              default:
                return y;
            }
            else k = E;
            y = y.substring(0, v) + k + y.substring(M + 1);
          }
        }
        function Ai(y, f, E, v, M, x, z, O) {
          let k = new ke();
          var H;
          return k.representation = y, k.duration = f, k.presentationStartTime = E, k.mediaStartTime = v, k.availabilityStartTime = M.calcAvailabilityStartTimeFromPresentationTime(x, y, z), k.availabilityEndTime = M.calcAvailabilityEndTimeFromPresentationTime(x + f, y, z), k.wallStartTime = M.calcWallTimeForSegment(k, z), k.replacementNumber = (H = O, k.representation.startNumber + H), k.index = O, k;
        }
        function Gn(y, f, E, v) {
          const M = f.adaptation.period;
          if (isFinite(M.duration) && M.start + M.duration <= E.presentationStartTime) return !1;
          if (v) {
            if (f.availabilityTimeOffset === "INF") return !0;
            const x = y.getClientReferenceTime();
            return E.availabilityStartTime.getTime() <= x && (!isFinite(E.availabilityEndTime) || E.availabilityEndTime.getTime() >= x);
          }
          return !0;
        }
        function Di(y, f, E, v) {
          let M, x, z;
          M = E.segmentDuration, isNaN(M) && (M = E.adaptation.period.duration), x = parseFloat((E.adaptation.period.start + v * M).toFixed(5)), z = parseFloat((x + M).toFixed(5));
          const O = Ai(E, M, x, y.calcMediaTimeFromPresentationTime(x, E), y, z, f, v);
          return Gn(y, E, O, f) ? O : null;
        }
        function Ae(y, f, E, v, M, x, z, O, k, H) {
          const B = v / x, D = M / x;
          let N, Y, J;
          return N = y.calcPresentationTimeFromMediaTime(B, E), Y = N + D, J = Ai(E, D, N, B, y, Y, f, k), Gn(y, E, J, f) ? (J.replacementTime = H || v, z = Wn(z, "Number", J.replacementNumber), z = Wn(z, "Time", J.replacementTime), J.media = z, J.mediaRange = O, J) : null;
        }
        function Ke(y) {
          const f = (y = y || {}).eventBus, E = y.events, v = y.abrController, M = y.dashMetrics, x = y.playbackController, z = y.timelineConverter, O = y.type, k = y.streamInfo, H = y.segmentsController, B = y.isDynamic;
          let D, N, Y;
          function J() {
            return O;
          }
          function it() {
            return Y;
          }
          function lt() {
            Y = null, N = [];
          }
          function at(F) {
            return new Promise((G, K) => {
              const ft = F.hasInitialization(), bt = F.hasSegments(), _t = [];
              _t.push(H.updateInitData(F, ft)), _t.push(H.updateSegmentData(F, bt)), Promise.all(_t).then((vt) => {
                var Pt;
                vt[0] && !vt[0].error && (F = function(Ot, W) {
                  return W && !W.error && W.representation ? W.representation : Ot;
                }(F, vt[0])), vt[1] && !vt[1].error && (F = function(Ot, W) {
                  if (!W || W.error) return;
                  const tt = W.segments, Tt = [];
                  let yt, nt, ct, V, mt = 0;
                  for (yt = 0, nt = tt ? tt.length : 0; yt < nt; yt++) ct = tt[yt], V = Ae(z, B, Ot, ct.startTime, ct.duration, ct.timescale, ct.media, ct.mediaRange, mt), V && (Tt.push(V), V = null, mt++);
                  return Tt.length > 0 && (Ot.segments = Tt), Ot;
                }(F, vt[1])), F.fragmentDuration = F.segmentDuration ? F.segmentDuration : F.segments && F.segments.length > 0 ? F.segments[0].duration : NaN, (Pt = F).mediaFinishedInformation = H.getMediaFinishedInformation(Pt), function(Ot) {
                  let W, tt = M.getCurrentManifestUpdate(), Tt = !1;
                  if (tt) {
                    for (let yt = 0; yt < tt.representationInfo.length; yt++) if (W = tt.representationInfo[yt], W.index === Ot.index && W.mediaType === J()) {
                      Tt = !0;
                      break;
                    }
                    Tt || M.addManifestUpdateRepresentationInfo(Ot, J());
                  }
                }(F), G();
              }).catch((vt) => {
                K(vt);
              });
            });
          }
          function st(F) {
            if (!N || N.length === 0) return null;
            const G = N.filter((K) => K.id === F);
            return G.length > 0 ? G[0] : null;
          }
          function ht(F) {
            f.trigger(E.DATA_UPDATE_COMPLETED, { currentRepresentation: Y, error: F }, { streamId: k.id, mediaType: O });
          }
          function At(F) {
            Y && Y.id === F.id || function(G) {
              (function() {
                if (!(v && M && x && z)) throw new Error(q.A.MISSING_CONFIG_ERROR);
              })();
              const K = /* @__PURE__ */ new Date(), ft = 1e3 * x.getTime();
              G && M.addRepresentationSwitch(G.adaptation.type, K, ft, G.id), f.trigger(St.A.REPRESENTATION_SWITCH, { mediaType: O, streamId: k.id, currentRepresentation: G }, { streamId: k.id, mediaType: O });
            }(F), Y = F;
          }
          function Z(F) {
            if (F.newDuration) {
              const G = it();
              G && G.adaptation.period && (G.adaptation.period.duration = F.newDuration);
            }
          }
          return D = { getCurrentRepresentation: it, getRepresentationById: st, getStreamId: function() {
            return k.id;
          }, getType: J, prepareQualityChange: function(F) {
            const G = N.filter((K) => K.id === F.id);
            G.length > 0 && At(G[0]);
          }, reset: function() {
            f.off(St.A.MANIFEST_VALIDITY_CHANGED, Z, D), lt();
          }, updateData: function(F, G, K) {
            return new Promise((ft, bt) => {
              if (N = F, At(st(K)), O !== q.A.VIDEO && O !== q.A.AUDIO && O !== q.A.MESH && (O !== q.A.TEXT || !G)) return ht(), void ft();
              const _t = [];
              for (let vt = 0, Pt = N.length; vt < Pt; vt++) {
                const Ot = N[vt];
                _t.push(at(Ot));
              }
              Promise.all(_t).then(() => {
                (function() {
                  v.setPlaybackQuality(O, k, Y);
                  const vt = M.getCurrentDVRInfo(O);
                  vt && M.updateManifestUpdateInfo({ latency: vt.range.end - x.getTime() }), ht();
                })(), ft();
              }).catch((vt) => {
                bt(vt);
              });
            });
          } }, lt(), f.on(St.A.MANIFEST_VALIDITY_CHANGED, Z, D), D;
        }
        Ke.__dashjs_factory_name = "RepresentationController";
        var Re = Dt.A.getClassFactory(Ke), pe = b(656);
        function Ce(y) {
          const f = (y = y || {}).eventBus, E = y.debug, v = y.urlUtils, M = y.type, x = y.streamInfo, z = y.segmentsController, O = y.timelineConverter, k = y.baseURLController;
          let H, B, D, N, Y;
          function J() {
            return M;
          }
          function it() {
            D = null;
          }
          function lt(Z, F, G) {
            const K = k.resolve(G.path);
            let ft, bt, _t = {};
            return K && F !== K.url && v.isRelative(F) ? (ft = K.url, bt = K.serviceLocation, _t = K.queryParams, F && (ft = v.resolve(F, ft))) : ft = F, !v.isRelative(ft) && (Z.url = ft, Z.serviceLocation = bt, Z.queryParams = _t, !0);
          }
          function at(Z, F) {
            if (F == null) return null;
            const G = new ze(), K = F.representation, ft = K.bandwidth;
            let bt = F.media;
            return bt = Wn(bt, "Number", F.replacementNumber), bt = Wn(bt, "Time", F.replacementTime), bt = Wn(bt, "Bandwidth", ft), bt = ii(bt, K.id), bt = je(bt), G.mediaType = J(), G.bandwidth = K.bandwidth, G.type = Ct.G.MEDIA_SEGMENT_TYPE, G.range = F.mediaRange, G.startTime = F.presentationStartTime, G.mediaStartTime = F.mediaStartTime, G.duration = F.duration, G.timescale = K.timescale, G.availabilityStartTime = F.availabilityStartTime, G.availabilityEndTime = F.availabilityEndTime, G.availabilityTimeComplete = K.availabilityTimeComplete, G.wallStartTime = F.wallStartTime, G.index = F.index, G.adaptationIndex = K.adaptation.index, G.representation = K, lt(G, bt, K) ? G : void 0;
          }
          function st(Z, F, G) {
            let K = null;
            if (!F || !F.segmentInfoType) return K;
            const ft = z.getSegmentByTime(F, G);
            return ft && (D = ft, B.debug("Index for time " + G + " is " + ft.index), K = at(0, ft)), K;
          }
          function ht(Z, F, G) {
            let K = null;
            const ft = z.getSegmentByIndex(F, G, D ? D.mediaStartTime : -1);
            if (ft) K = at(0, ft), D = ft;
            else {
              if (N && !Y) return B.debug(J() + " No segment found at index: " + G + ". Wait for next loop"), null;
              Y = !0;
            }
            return K;
          }
          function At() {
            B.debug("Dynamic stream complete"), Y = !0;
          }
          return H = { getCurrentIndex: function() {
            return D ? D.index : -1;
          }, getInitRequest: function(Z, F) {
            return F ? function(G, K, ft) {
              const bt = new ze(), _t = K.adaptation.period, vt = _t.start;
              if (bt.mediaType = ft, bt.type = Ct.G.INIT_SEGMENT_TYPE, bt.range = K.range, bt.availabilityStartTime = O.calcAvailabilityStartTimeFromPresentationTime(vt, K, N), bt.availabilityEndTime = O.calcAvailabilityEndTimeFromPresentationTime(vt + _t.duration, K, N), bt.representation = K, lt(bt, K.initialization, K)) return bt.url = Wn(bt.url, "Bandwidth", K.bandwidth), bt;
            }(0, F, J()) : null;
          }, getNextSegmentRequest: function(Z, F) {
            return F && F.segmentInfoType ? ht(0, F, D ? D.index + 1 : 0) : null;
          }, getNextSegmentRequestIdempotent: function(Z, F) {
            let G = null, K = D ? D.index + 1 : 0;
            const ft = z.getSegmentByIndex(F, K, D ? D.mediaStartTime : -1);
            return ft ? (G = at(0, ft), G) : null;
          }, getSegmentRequestForTime: st, getStreamId: function() {
            return x.id;
          }, getStreamInfo: function() {
            return x;
          }, getType: J, getValidTimeAheadOfTargetTime: function(Z, F, G, K) {
            try {
              if (isNaN(Z) || !F || !G) return NaN;
              if (Z < 0 && (Z = 0), isNaN(K) && (K = 0.5), st(0, G, Z)) return Z;
              if (G.adaptation.period.start + G.adaptation.period.duration < Z) return NaN;
              const ft = isFinite(G.adaptation.period.duration) ? G.adaptation.period.start + G.adaptation.period.duration : Z + 30;
              let bt = Math.min(Z + K, ft), _t = NaN, vt = null;
              for (; bt <= ft; ) {
                let Pt = null;
                if (bt <= ft && (Pt = st(0, G, bt)), Pt) {
                  _t = bt, vt = Pt;
                  break;
                }
                bt += K;
              }
              if (vt) {
                const Pt = vt.startTime + vt.duration;
                return Z > vt.startTime && Pt - Z > K ? Z : !isNaN(vt.startTime) && Z < vt.startTime && _t > vt.startTime ? vt.startTime + 1e-3 : Math.min(Pt - K, _t);
              }
              return _t;
            } catch {
              return NaN;
            }
          }, initialize: function(Z) {
            N = Z, Y = !1, z.initialize(Z);
          }, isLastSegmentRequested: function(Z, F) {
            return !Z || !D ? !1 : Y ? !0 : !isFinite(Z.adaptation.period.duration) || D.presentationStartTime + D.duration > F ? !1 : Z.mediaFinishedInformation && !isNaN(Z.mediaFinishedInformation.numberOfSegments) && !isNaN(D.index) && D.index >= Z.mediaFinishedInformation.numberOfSegments - 1 && (!N || Z.segmentInfoType === I.A.SEGMENT_TEMPLATE || N && Z.segmentInfoType === I.A.SEGMENT_LIST && Z.adaptation.period.nextPeriodId) ? !0 : !!(N && Z.adaptation.period.nextPeriodId && Z.segmentInfoType === I.A.SEGMENT_TIMELINE && Z.mediaFinishedInformation && !isNaN(Z.mediaFinishedInformation.mediaTimeOfLastSignaledSegment) && D && !isNaN(D.mediaStartTime) && !isNaN(D.duration) && D.mediaStartTime + D.duration >= Z.mediaFinishedInformation.mediaTimeOfLastSignaledSegment - 0.05);
          }, repeatSegmentRequest: function(Z, F) {
            return F && F.segmentInfoType ? ht(0, F, D ? D.index : 0) : null;
          }, reset: function() {
            it(), f.off(St.A.DYNAMIC_TO_STATIC, At, H);
          } }, B = E.getLogger(H), it(), f.on(St.A.DYNAMIC_TO_STATIC, At, H), H;
        }
        Ce.__dashjs_factory_name = "DashHandler";
        var He = Dt.A.getClassFactory(Ce);
        function Je() {
          let y;
          const f = /^[a-z][a-z0-9+\-_.]*:/i, E = /^https?:\/\//i, v = /^https:\/\//i, M = /^([a-z][a-z0-9+\-_.]*:\/\/[^\/]+)\/?/i, x = (Y, J) => {
            try {
              return new window.URL(Y, J).toString();
            } catch {
              return Y;
            }
          }, z = (Y, J) => {
            let it = O;
            if (!J || !B(Y)) return Y;
            D(Y) && (it = k), N(Y) && (it = H);
            const lt = it(J), at = lt.charAt(lt.length - 1) !== "/" && Y.charAt(0) !== "/" ? "/" : "";
            return [lt, Y].join(at);
          };
          function O(Y) {
            const J = Y.indexOf("/"), it = Y.lastIndexOf("/");
            return J !== -1 ? it === J + 1 ? Y : (Y.indexOf("?") !== -1 && (Y = Y.substring(0, Y.indexOf("?"))), Y.substring(0, it + 1)) : "";
          }
          function k(Y) {
            const J = Y.match(M);
            return J ? J[1] : "";
          }
          function H(Y) {
            const J = Y.match(f);
            return J ? J[0] : "";
          }
          function B(Y) {
            return !f.test(Y);
          }
          function D(Y) {
            return B(Y) && Y.charAt(0) === "/";
          }
          function N(Y) {
            return Y.indexOf("//") === 0;
          }
          return function() {
            try {
              new window.URL("x", "http://y"), y = x;
            } catch {
            } finally {
              y = y || z;
            }
          }(), { parseBaseUrl: O, parseOrigin: k, parseScheme: H, isRelative: B, isPathAbsolute: D, isSchemeRelative: N, isHTTPURL: function(Y) {
            return E.test(Y);
          }, isHTTPS: function(Y) {
            return v.test(Y);
          }, removeHostname: function(Y) {
            return /^(?:\w+\:\/\/)?([^\/]+)(.*)$/.exec(Y)[2].substring(1);
          }, resolve: function(Y, J) {
            return y(Y, J);
          } };
        }
        Je.__dashjs_factory_name = "DefaultURLUtils";
        var tn = Dt.A.getSingletonFactory(Je);
        function xe() {
          let y, f, E = [];
          const v = this.context;
          function M(x, z, O) {
            let k = function(H) {
              let B;
              for (B = 0; B < E.length; B++) if (E[B].regex.test(H)) return E[B].utils;
              return f;
            }(O || z);
            return k && typeof k[x] == "function" ? k[x](z, O) : f[x](z, O);
          }
          return f = tn(v).getInstance(), y = { registerUrlRegex: function(x, z) {
            E.push({ regex: x, utils: z });
          }, parseBaseUrl: function(x) {
            return M("parseBaseUrl", x);
          }, parseOrigin: function(x) {
            return M("parseOrigin", x);
          }, parseScheme: function(x) {
            return M("parseScheme", x);
          }, isRelative: function(x) {
            return M("isRelative", x);
          }, isPathAbsolute: function(x) {
            return M("isPathAbsolute", x);
          }, isSchemeRelative: function(x) {
            return M("isSchemeRelative", x);
          }, isHTTPURL: function(x) {
            return M("isHTTPURL", x);
          }, isHTTPS: function(x) {
            return M("isHTTPS", x);
          }, removeHostname: function(x) {
            return M("removeHostname", x);
          }, resolve: function(x, z) {
            return M("resolve", x, z);
          } }, y;
        }
        xe.__dashjs_factory_name = "URLUtils";
        var Se = Dt.A.getSingletonFactory(xe);
        class $e {
          constructor() {
            this.start = null, this.mstart = null, this.starttype = null, this.trace = [];
          }
        }
        $e.INITIAL_PLAYOUT_START_REASON = "initial_playout", $e.SEEK_START_REASON = "seek", $e.RESUME_FROM_PAUSE_START_REASON = "resume", $e.METRICS_COLLECTION_START_REASON = "metrics_collection_start";
        class kn {
          constructor() {
            this.representationid = null, this.subreplevel = null, this.start = null, this.mstart = null, this.duration = null, this.playbackspeed = null, this.stopreason = null;
          }
        }
        function Ge(y, f) {
          const E = (y = y || {}).timelineConverter, v = y.dashMetrics;
          let M;
          function x() {
            if (!E) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function z(k, H) {
            const B = k.adaptation.period.mpd.manifest.Period[k.adaptation.period.index].AdaptationSet[k.adaptation.index].Representation[k.index].SegmentTemplate || k.adaptation.period.mpd.manifest.Period[k.adaptation.period.index].AdaptationSet[k.adaptation.index].Representation[k.index].SegmentList, D = B.SegmentTimeline, N = B.SegmentURL;
            let Y, J, it, lt, at, st, ht, At = 0, Z = -1;
            ht = k.timescale, Y = D.S;
            let F = !1;
            for (it = 0, lt = Y.length; it < lt && !F; it++) for (J = Y[it], st = 0, J.hasOwnProperty("r") && (st = J.r), J.hasOwnProperty("t") && (At = J.t), st < 0 && (st = O(k, Y[it + 1], J, ht, At / ht)), at = 0; at <= st && !F; at++) Z++, F = H(At, B, N, J, ht, Z, it), F && (k.segmentDuration = J.d / ht), At += J.d;
          }
          function O(k, H, B, D, N) {
            let Y;
            if (H && H.hasOwnProperty("t")) Y = H.t / D;
            else try {
              let J = 0;
              if (isNaN(k.adaptation.period.start) || isNaN(k.adaptation.period.duration) || !isFinite(k.adaptation.period.duration)) {
                const it = v.getCurrentDVRInfo();
                J = isNaN(it.end) ? 0 : it.end;
              } else J = k.adaptation.period.start + k.adaptation.period.duration;
              Y = E.calcMediaTimeFromPresentationTime(J, k), k.segmentDuration = B.d / D;
            } catch {
              Y = 0;
            }
            return Math.max(Math.ceil((Y - N) / (B.d / D)) - 1, 0);
          }
          return M = { getSegmentByIndex: function(k, H, B) {
            if (x(), !k) return null;
            let D = null, N = !1;
            return z(k, function(Y, J, it, lt, at, st, ht) {
              if (N || B < 0) {
                let At = J.media, Z = lt.mediaRange;
                return it && (At = it[ht].media || "", Z = it[ht].mediaRange), D = Ae(E, f, k, Y, lt.d, at, At, Z, st, lt.tManifest), !0;
              }
              return Y >= B * at - 0.5 * lt.d && (N = !0), !1;
            }), D;
          }, getSegmentByTime: function(k, H) {
            if (x(), !k) return null;
            H === void 0 && (H = null);
            let B = null;
            const D = E.calcMediaTimeFromPresentationTime(H, k);
            return z(k, function(N, Y, J, it, lt, at, st) {
              const ht = parseFloat((D * lt).toPrecision(15));
              if (ht < N + it.d && ht >= N) {
                let At = Y.media, Z = it.mediaRange;
                return J && (At = J[st].media || "", Z = J[st].mediaRange), B = Ae(E, f, k, N, it.d, lt, At, Z, at, it.tManifest), !0;
              }
              return !1;
            }), B;
          }, getMediaFinishedInformation: function(k) {
            if (!k) return 0;
            const H = (k.adaptation.period.mpd.manifest.Period[k.adaptation.period.index].AdaptationSet[k.adaptation.index].Representation[k.index].SegmentTemplate || k.adaptation.period.mpd.manifest.Period[k.adaptation.period.index].AdaptationSet[k.adaptation.index].Representation[k.index].SegmentList).SegmentTimeline;
            let B, D, N, Y, J, it, lt, at = 0, st = 0, ht = 0;
            for (lt = k.timescale, B = H.S, Y = B.length, N = 0; N < Y; N++) for (D = B[N], it = 0, D.hasOwnProperty("r") && (it = D.r), D.hasOwnProperty("t") && (at = D.t, st = at / lt), it < 0 && (it = O(k, B[N + 1], D, lt, st)), J = 0; J <= it; J++) ht++, at += D.d, st = at / lt;
            return { numberOfSegments: ht, mediaTimeOfLastSignaledSegment: st };
          } }, M;
        }
        kn.REPRESENTATION_SWITCH_STOP_REASON = "representation_switch", kn.REBUFFERING_REASON = "rebuffering", kn.USER_REQUEST_STOP_REASON = "user_request", kn.END_OF_PERIOD_STOP_REASON = "end_of_period", kn.END_OF_CONTENT_STOP_REASON = "end_of_content", kn.METRICS_COLLECTION_STOP_REASON = "metrics_collection_end", kn.FAILURE_STOP_REASON = "failure", Ge.__dashjs_factory_name = "TimelineSegmentsGetter";
        var En = Dt.A.getClassFactory(Ge);
        function An(y, f) {
          const E = (y = y || {}).timelineConverter;
          let v;
          function M() {
            if (!E || !E.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function x(z, O) {
            if (M(), !z) return null;
            const k = z.adaptation.period.mpd.manifest.Period[z.adaptation.period.index].AdaptationSet[z.adaptation.index].Representation[z.index].SegmentTemplate;
            O = Math.max(O, 0);
            const H = Di(E, f, z, O);
            if (H) {
              H.replacementTime = Math.round(O * z.segmentDuration * z.timescale, 10);
              let B = k.media;
              B = Wn(B, "Number", H.replacementNumber), B = Wn(B, "Time", H.replacementTime), H.media = B;
            }
            return H;
          }
          return v = { getSegmentByIndex: x, getSegmentByTime: function(z, O) {
            if (M(), !z) return null;
            const k = z.segmentDuration;
            if (isNaN(k)) return null;
            let H = E.calcPeriodRelativeTimeFromMpdRelativeTime(z, O);
            return x(z, Math.floor(H / k));
          }, getMediaFinishedInformation: function(z) {
            const O = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            if (!z) return O;
            const k = z.segmentDuration;
            return isNaN(k) ? O.numberOfSegments = 1 : O.numberOfSegments = Math.ceil(z.adaptation.period.duration / k), O;
          } }, v;
        }
        An.__dashjs_factory_name = "TemplateSegmentsGetter";
        var Dn = Dt.A.getClassFactory(An);
        function In(y, f) {
          const E = (y = y || {}).timelineConverter;
          let v;
          function M() {
            if (!E || !E.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function x(z, O) {
            if (M(), !z) return null;
            const k = z.adaptation.period.mpd.manifest.Period[z.adaptation.period.index].AdaptationSet[z.adaptation.index].Representation[z.index].SegmentList, H = k.SegmentURL.length, B = z && !isNaN(z.startNumber) ? z.startNumber : 1, D = Math.max(B - 1, 0), N = Math.max(O - D, 0);
            let Y = null;
            if (N < H) {
              const J = k.SegmentURL[N];
              Y = Di(E, f, z, O), Y && (Y.replacementTime = (B + O - 1) * z.segmentDuration, Y.media = J.media ? J.media : "", Y.mediaRange = J.mediaRange, Y.indexRange = J.indexRange);
            }
            return Y;
          }
          return v = { getSegmentByIndex: x, getSegmentByTime: function(z, O) {
            if (M(), !z) return null;
            const k = z.segmentDuration;
            if (isNaN(k)) return null;
            const H = E.calcPeriodRelativeTimeFromMpdRelativeTime(z, O);
            return x(z, Math.floor(H / k));
          }, getMediaFinishedInformation: function(z) {
            const O = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            if (!z) return O;
            const k = z.adaptation.period.mpd.manifest.Period[z.adaptation.period.index].AdaptationSet[z.adaptation.index].Representation[z.index].SegmentList, H = z && !isNaN(z.startNumber) ? z.startNumber : 1, B = Math.max(H - 1, 0);
            return O.numberOfSegments = B + k.SegmentURL.length, O;
          } }, v;
        }
        In.__dashjs_factory_name = "ListSegmentsGetter";
        var Kn = Dt.A.getClassFactory(In);
        function vn(y) {
          const f = (y = y || {}).timelineConverter;
          let E;
          function v() {
            if (!f || !f.hasOwnProperty("calcPeriodRelativeTimeFromMpdRelativeTime")) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function M(x, z) {
            if (v(), !x) return null;
            const O = x.segments ? x.segments.length : -1;
            let k;
            if (z < O && (k = x.segments[z], k && k.index === z)) return k;
            for (let H = 0; H < O; H++) if (k = x.segments[H], k && k.index === z) return k;
            return null;
          }
          return E = { getSegmentByIndex: M, getSegmentByTime: function(x, z) {
            v();
            const O = function(k, H) {
              if (!k) return -1;
              const B = k.segments, D = B ? B.length : null;
              let N, Y, J, it, lt, at = -1;
              if (B && D > 0) {
                for (lt = 0; lt < D; lt++) if (Y = B[lt], J = Y.presentationStartTime, it = Y.duration, N = it / 2, H + N >= J && H - N < J + it) {
                  at = Y.index;
                  break;
                }
              }
              return at;
            }(x, z);
            return M(x, O);
          }, getMediaFinishedInformation: function(x) {
            const z = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
            return x && x.segments && (z.numberOfSegments = x.segments.length), z;
          } }, E;
        }
        vn.__dashjs_factory_name = "SegmentBaseGetter";
        var ve = Dt.A.getClassFactory(vn);
        function ue(y) {
          y = y || {};
          const f = this.context, E = y.dashConstants, v = y.type, M = y.segmentBaseController;
          let x, z;
          function O(k) {
            return k ? k.segments ? z[E.SEGMENT_BASE] : z[k.segmentInfoType] : null;
          }
          return x = { initialize: function(k) {
            z[E.SEGMENT_TIMELINE] = En(f).create(y, k), z[E.SEGMENT_TEMPLATE] = Dn(f).create(y, k), z[E.SEGMENT_LIST] = Kn(f).create(y, k), z[E.SEGMENT_BASE] = ve(f).create(y, k);
          }, updateInitData: function(k, H) {
            return H ? Promise.resolve() : M.getSegmentBaseInitSegment({ representation: k, mediaType: v });
          }, updateSegmentData: function(k, H) {
            return H ? Promise.resolve() : M.getSegmentList({ mimeType: k.mimeType, representation: k, mediaType: v });
          }, getSegmentByIndex: function(k, H, B) {
            const D = O(k);
            return D ? D.getSegmentByIndex(k, H, B) : null;
          }, getSegmentByTime: function(k, H) {
            const B = O(k);
            return B ? B.getSegmentByTime(k, H) : null;
          }, getMediaFinishedInformation: function(k) {
            const H = O(k);
            return H ? H.getMediaFinishedInformation(k) : { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN };
          } }, z = {}, x;
        }
        ue.__dashjs_factory_name = "SegmentsController";
        var Be = Dt.A.getClassFactory(ue);
        function dn() {
          let y;
          return y = { ntpToUTC: function(f) {
            const E = new Date(Date.UTC(1900, 0, 1, 0, 0, 0));
            return new Date(E.getTime() + f).getTime();
          } }, y;
        }
        dn.__dashjs_factory_name = "TimeUtils";
        var Yn = Dt.A.getSingletonFactory(dn), $n = class {
          constructor(y) {
            this.newMediaInfo = y.newMediaInfo, this.previouslySelectedRepresentation = y.previouslySelectedRepresentation, this.newRepresentation = y.newRepresentation;
          }
        };
        function ui(y) {
          y = y || {};
          let f, E, v, M, x, z, O, k, H, B, D, N, Y, J, it, lt, at = this.context, st = (0, It.A)(at).getInstance(), ht = y.abrController, At = y.adapter, Z = y.boxParser, F = y.capabilities, G = y.dashMetrics, K = y.errHandler, ft = y.fragmentModel, bt = y.manifestModel, _t = y.mediaController, vt = y.mediaPlayerModel, Pt = y.mimeType, Ot = y.playbackController, W = y.segmentBlacklistController, tt = y.settings, Tt = y.streamInfo, yt = y.textController, nt = y.timelineConverter, ct = y.type;
          function V() {
            return Tt.id;
          }
          function mt() {
            return ct;
          }
          function Mt() {
            k = [], v = null, E = 0, it = !1, J = !1, B = !1, lt = !1, Nn();
          }
          function Lt(te) {
            return !isNaN(te) && !isNaN(Tt.duration) && isFinite(Tt.duration) && te >= Tt.start + Tt.duration;
          }
          function Bt(te) {
            let Ie = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            if (te.sender) {
              if (Ot.getIsManifestUpdateInProgress()) fe();
              else if ((!v.isText || yt.isTextEnabled()) && f && te.representationId && !f.appendInitSegmentFromCache(te.representationId)) {
                const rn = D.getCurrentRepresentation();
                if (rn.range === 0) return void Qt();
                const Tn = M ? M.getInitRequest(v, rn) : null;
                Tn ? ft.executeRequest(Tn) : Ie && (N.setInitSegmentRequired(!0), fe());
              }
            }
          }
          function Qt(te) {
            let Ie = !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1];
            if (Ot.getIsManifestUpdateInProgress() || f.getIsPruningInProgress()) return void fe();
            let rn = function() {
              let Tn;
              if (isNaN(E) || mt() === q.A.TEXT && !yt.isTextEnabled()) return null;
              if (M) {
                const Un = ie();
                Tn = it ? M.getSegmentRequestForTime(v, Un, E) : J ? M.repeatSegmentRequest(v, Un) : M.getNextSegmentRequest(v, Un);
              }
              return Tn;
            }();
            rn ? (it = !1, J = !1, function(Tn) {
              isNaN(Tn.startTime + Tn.duration) || (E = Tn.startTime + Tn.duration), Tn.delayLoadingTime = (/* @__PURE__ */ new Date()).getTime() + N.getTimeToLoadDelay(), N.setTimeToLoadDelay(0), function(Un) {
                let Cn = Un.url;
                return Un.range && (Cn = Cn.concat("_", Un.range)), W.contains(Cn);
              }(Tn) ? (O.warn(`Fragment request url ${Tn.url} for stream id ${Tt.id} and media type ${ct} is on the ignore list and will be skipped`), fe()) : (O.debug(`Next fragment request url for stream id ${Tt.id} and media type ${ct} is ${Tn.url} with request range ${Tn.range}`), ft.executeRequest(Tn));
            }(rn)) : function(Tn) {
              const Un = D.getCurrentRepresentation();
              try {
                if (tt.get().streaming.gaps.enableSeekFix && (it || Ot.getTime() === 0)) {
                  let Cn;
                  if (z ? z && Un.segmentInfoType === I.A.SEGMENT_TIMELINE && (Cn = M.getValidTimeAheadOfTargetTime(E, v, Un, tt.get().streaming.gaps.threshold)) : (Cn = M.getValidTimeAheadOfTargetTime(E, v, Un, tt.get().streaming.gaps.threshold), isNaN(Cn) && E >= Un.adaptation.period.mpd.mediaPresentationDuration - Un.segmentDuration && (Cn = E - 0.1)), !isNaN(Cn) && Cn !== E) return void (Ot.isSeeking() || Ot.getTime() === 0 ? (O.warn(`Adjusting playback time ${Cn} because of gap in the manifest. Seeking by ${Cn - E}`), Ot.seek(Cn, !1, !1)) : (O.warn(`Adjusting buffering time ${Cn} because of gap in the manifest. Adjusting time by ${Cn - E}`), Ee(Cn), Tn && fe()));
                }
              } catch (Cn) {
                O.error(Cn);
              }
              Zt() || Tn && fe();
            }(Ie);
          }
          function Zt() {
            const te = D.getCurrentRepresentation(), Ie = M.isLastSegmentRequested(te, E);
            if (Ie) {
              const rn = M.getCurrentIndex();
              O.debug(`Segment requesting for stream ${Tt.id} has finished`), st.trigger(et.A.STREAM_REQUESTING_COMPLETED, { segmentIndex: rn }, { streamId: Tt.id, mediaType: ct }), f.segmentRequestingCompleted(rn), gn();
            }
            return Ie;
          }
          function fe() {
            N.startScheduleTimer(Ot.getLowLatencyModeEnabled() ? tt.get().streaming.scheduling.lowLatencyTimeout : tt.get().streaming.scheduling.defaultTimeout);
          }
          function Ue(te) {
            G.addBufferState(ct, te.state, N.getBufferTarget()), te.state !== pt.BUFFER_EMPTY || Ot.isSeeking() || (O.info("Buffer is empty! Stalling!"), G.pushPlayListTraceMetrics(/* @__PURE__ */ new Date(), kn.REBUFFERING_REASON));
          }
          function Ye(te) {
            ft.syncExecutedRequestsWithBufferedRange(f.getBuffer().getAllBufferRanges(), Tt.duration), te.quotaExceeded && te.from > Ot.getTime() && Ee(te.from), te.hasEnoughSpaceToAppend && te.quotaExceeded && N.startScheduleTimer();
          }
          function on(te) {
            if (!te || !te.lastRequestAppended || !te.lastRequestAppended.url) return;
            let Ie = te.lastRequestAppended.url;
            te.lastRequestAppended.range && (Ie = Ie.concat("_", te.lastRequestAppended.range)), O.warn(`Blacklisting segment with url ${Ie}`), W.add(Ie);
          }
          function cn(te) {
            if (O.debug(`Appended bytes for ${te.mediaType} and stream id ${te.streamId}`), te.segmentType === Ct.G.INIT_SEGMENT_TYPE) {
              const Ie = te.representationId;
              N.setLastInitializedRepresentationId(Ie), O.info("[" + ct + "] lastInitializedRepresentationId changed to " + Ie);
            }
            H && H.enabled ? $t(H.newRepresentation, H.oldRepresentation) : lt || N.startScheduleTimer(0);
          }
          function Nn() {
            H = { newRepresentation: null, oldRepresentation: null, enabled: !1 };
          }
          function Qe(te) {
            return new Promise((Ie) => {
              if (!D) return Promise.resolve();
              let rn = null;
              var Tn;
              rn = te.newRepresentation ? { selectedRepresentation: (Tn = te).newRepresentation, currentMediaInfo: Tn.newMediaInfo } : v !== null && At.areMediaInfosEqual(v, te.newMediaInfo) ? function(Cn) {
                return { currentMediaInfo: Cn.newMediaInfo, selectedRepresentation: D.getCurrentRepresentation() };
              }(te) : function(Cn) {
                let wi = NaN;
                return wi = !tt.get().streaming.abr.autoSwitchBitrate[Cn.newMediaInfo.type] && Cn.previouslySelectedRepresentation ? Cn.previouslySelectedRepresentation.bitrateInKbit : ht.getInitialBitrateFor(ct), { selectedRepresentation: ht.getOptimalRepresentationForBitrate(Cn.newMediaInfo, wi, !1), currentMediaInfo: Cn.newMediaInfo };
              }(te), hn(rn.currentMediaInfo), st.trigger();
              const Un = ht.getPossibleVoRepresentations(v, !1);
              return D.updateData(Un, v.isFragmented, rn.selectedRepresentation.id).then(() => {
                (function() {
                  const Cn = D.getCurrentRepresentation();
                  f.getIsBufferingCompleted() || f.updateBufferTimestampOffset(Cn);
                })(), Ie();
              }).catch((Cn) => {
                O.error(Cn), Ie();
              });
            });
          }
          function hn(te) {
            At.areMediaInfosEqual(v, te) || st.trigger(St.A.NEW_TRACK_SELECTED, { value: te }), v = te, ht.handleNewMediaInfo(v), st.trigger(et.A.MEDIAINFO_UPDATED, { mediaType: ct, streamId: Tt.id, currentMediaInfo: v });
          }
          function Sn(te) {
            const Ie = te.newRepresentation, rn = te.oldRepresentation;
            Ie && rn || O.warn("_handleDifferentSwitchTypes() is missing the target representations"), te.reason && te.reason.forceReplace ? function(Tn, Un) {
              ft.abortRequests(), st.trigger(et.A.BUFFER_REPLACEMENT_STARTED, { mediaType: ct, streamId: Tt.id }, { mediaType: ct, streamId: Tt.id }), N.setCheckPlaybackQuality(!1), f.prepareForForceReplacementQualitySwitch(Tn, Un).then(() => {
                jn();
              }).catch(() => {
                jn();
              });
            }(Ie, rn) : te && te.reason && te.reason.forceAbandon ? function(Tn, Un) {
              f.prepareForAbandonQualitySwitch(Tn, Un).then(() => {
                Ln();
              }).catch(() => {
                Ln();
              });
            }(Ie, rn) : vt.getFastSwitchEnabled() ? function(Tn, Un) {
              const Cn = Ot.getTime();
              let wi = 1.5 * (isNaN(Tn.fragmentDuration) ? 1 : Tn.fragmentDuration);
              const Ui = ft.getRequests({ state: wn.FRAGMENT_MODEL_EXECUTED, time: Cn + wi, threshold: 0 })[0];
              if (Ui && !v.isText) {
                const zr = f.getBufferLevel(), Ji = ht.getAbandonmentStateFor(Tt.id, ct);
                Ui.bandwidth < Tn.bandwidth && zr >= wi && Ji === pt.ALLOW_LOAD ? f.prepareForFastQualitySwitch(Tn, Un).then(() => {
                  Rn(Cn, wi);
                }).catch(() => {
                  Rn(Cn, wi);
                }) : $t(Tn, Un);
              } else $t(Tn, Un);
            }(Ie, rn) : $t(Ie, rn), G.pushPlayListTraceMetrics(/* @__PURE__ */ new Date(), kn.REPRESENTATION_SWITCH_STOP_REASON), G.createPlaylistTraceMetrics(Ie.id, 1e3 * Ot.getTime(), Ot.getPlaybackRate());
          }
          function jn() {
            ye(), Nn(), B = !1;
          }
          function Ln() {
            ft.abortRequests(), J = !0, N.setCheckPlaybackQuality(!1), N.startScheduleTimer(), B = !1;
          }
          function Rn(te, Ie) {
            ft.abortRequests(), Ee(te + Ie), N.setCheckPlaybackQuality(!1), N.startScheduleTimer(), B = !1;
          }
          function $t(te, Ie) {
            const rn = ft.getRequests({ state: wn.FRAGMENT_MODEL_LOADING });
            if (rn && rn.length > 0) return O.debug("Preparing for default quality switch: Waiting for ongoing segment request to be finished before applying switch."), H.newRepresentation = te, H.oldRepresentation = Ie, void (H.enabled = !0);
            f.prepareForDefaultQualitySwitch(te, Ie).then(() => {
              be();
            }).catch(() => {
              be();
            });
          }
          function be() {
            N.setCheckPlaybackQuality(!1), v.segmentAlignment || v.subSegmentAlignment ? N.startScheduleTimer() : Rt(), Nn(), B = !1;
          }
          function ge(te) {
            O.info("onFragmentLoadingAbandoned request: " + te.request.url + " has been aborted"), Ot.isSeeking() || N.getSwitchTrack() || B || (O.info("onFragmentLoadingAbandoned request: " + te.request.url + " has to be downloaded again, origin is not seeking process or switch track call"), te.request && te.request.isInitializationRequest() ? N.setInitSegmentRequired(!0) : Ee(te.request.startTime + te.request.duration / 2), N.startScheduleTimer(0));
          }
          function Te(te) {
            O.info("OnFragmentLoadingCompleted for stream id " + Tt.id + " and media type " + ct + " - Url:", te.request ? te.request.url : "undefined", te.request.range ? ", Range:" + te.request.range : ""), v.isText && N.startScheduleTimer(0), te.error && te.request.serviceLocation && function(Ie) {
              O.info("Fragment loading completed with an error"), Ie && Ie.request && Ie.request.type && (Ie.request.type === Ct.G.INIT_SEGMENT_TYPE ? Bt({ representationId: Ie.request.representation.id, sender: {} }, !1) : Ie.request.type === Ct.G.MEDIA_SEGMENT_TYPE && (Ee(Ie.request.startTime + Ie.request.duration / 2), Qt({}, !1)));
            }(te);
          }
          function ee() {
            Ee(Ot.getTime()), sn().startScheduleTimer();
          }
          function De(te) {
            const Ie = te.currentTrackInfo;
            if (!Ie) return;
            const rn = k.find((Tn) => Tn.index === Ie.index && Tn.lang === Ie.lang);
            rn && Qe(new $n({ newMediaInfo: rn })).then(() => {
              f.setIsBufferingCompleted(!1), Ee(Ot.getTime()), N.setInitSegmentRequired(!0), N.startScheduleTimer();
            });
          }
          function Pe(te) {
            Ee(te.quotaExceededTime), gn();
          }
          function nn() {
            return f ? f.getBuffer() : null;
          }
          function sn() {
            return N;
          }
          function gn() {
            N && N.clearScheduleTimer();
          }
          function ie() {
            let te, Ie = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN;
            return isNaN(Ie) ? te = D ? D.getCurrentRepresentation() : null : ((0, pe.zQ)(Ie), te = D ? D.getRepresentationById(Ie) : null), te;
          }
          function Le() {
            return !!f && f.getIsBufferingCompleted();
          }
          function We(te) {
            if (!tt.get().streaming.enableManifestTimescaleMismatchFix) return;
            const Ie = te.chunk, rn = Ie.bytes, Tn = ie(Ie.representation.id);
            Tn && (Tn.timescale = Z.getMediaTimescaleFromMoov(rn));
          }
          function ln(te) {
            const Ie = te.chunk, rn = Ie.bytes, Tn = ie(Ie.representation.id);
            if (Tn) {
              let Un;
              if (tt.get().streaming.parseInbandPrft && te.request.type === Ct.G.MEDIA_SEGMENT_TYPE) {
                Un = Un || Z.parse(rn);
                const Ui = function(zr, Ji) {
                  const Wa = zr.getBoxes("prft"), cs = [];
                  return Wa.forEach((Ds) => {
                    cs.push(function(Xr, _a) {
                      let Ar = "unknown";
                      switch (Xr.flags) {
                        case 0:
                          Ar = I.A.PRODUCER_REFERENCE_TIME_TYPE.ENCODER;
                          break;
                        case 16:
                          Ar = I.A.PRODUCER_REFERENCE_TIME_TYPE.APPLICATION;
                          break;
                        case 24:
                          Ar = I.A.PRODUCER_REFERENCE_TIME_TYPE.CAPTURED;
                      }
                      let Qr = 1e3 * Xr.ntp_timestamp_sec + Xr.ntp_timestamp_frac / 2 ** 32 * 1e3;
                      return Qr = Yn(at).getInstance().ntpToUTC(Qr), { type: Ar, ntpTimestamp: Qr, mediaTime: Xr.media_time / _a };
                    }(Ds, Ji));
                  }), cs;
                }(Un, Tn.timescale);
                Ui && Ui.length && st.trigger(St.A.INBAND_PRFT, { data: Ui }, { streamId: Tt.id, mediaType: ct });
              }
              const Cn = At.getEventsFor(Tn.mediaInfo, null, Tt), wi = At.getEventsFor(Tn, Tn, Tt);
              if (Cn && Cn.length > 0 || wi && wi.length > 0) {
                const Ui = te.request;
                Un = Un || Z.parse(rn);
                const zr = function(Ji, Wa, cs, Ds) {
                  try {
                    const Xr = {}, _a = [], Ar = cs.concat(Ds);
                    for (let Or = 0, Rs = Ar.length; Or < Rs; Or++) Xr[Ar[Or].schemeIdUri + "/" + Ar[Or].value] = Ar[Or];
                    const Qr = Ji.getBoxes("emsg");
                    if (!Qr || Qr.length === 0) return _a;
                    const Ka = Ji.getBox("sidx"), el = !Ka || isNaN(Ka.earliest_presentation_time) || isNaN(Ka.timescale) ? Wa && !isNaN(Wa.mediaStartTime) ? Wa.mediaStartTime : 0 : Ka.earliest_presentation_time / Ka.timescale, $a = Math.max(el, 0), Is = D.getCurrentRepresentation();
                    for (let Or = 0, Rs = Qr.length; Or < Rs; Or++) {
                      const hs = At.getEvent(Qr[Or], Xr, $a, Is);
                      hs && _a.push(hs);
                    }
                    return _a;
                  } catch {
                    return [];
                  }
                }(Un, Ui, Cn, wi);
                st.trigger(et.A.INBAND_EVENTS, { events: zr }, { streamId: Tt.id });
              }
            }
          }
          function ye() {
            const te = Ot.getTime();
            tt.get().streaming.buffer.flushBufferAtTrackSwitch && Ot.seek(te + 1e-3, !1, !0), Ee(te), f.setSeekTarget(te), N.startScheduleTimer();
          }
          function Rt() {
            const te = Ot.getTime(), Ie = f.getContinuousBufferTimeForTargetTime(te);
            Ee(isNaN(Ie) ? te : Ie), N.startScheduleTimer();
          }
          function Wt(te) {
            te && !isNaN(te.time) && (Ee(te.time), f.setSeekTarget(te.time));
          }
          function Ee(te) {
            E = te, it = !0;
          }
          return x = { checkAndHandleCompletedBuffering: Zt, clearScheduleTimer: gn, createBufferSinks: function(te, Ie) {
            const rn = nn();
            return rn ? Promise.resolve(rn) : f ? f.createBufferSink(v, te, Ie) : Promise.resolve(null);
          }, dischargePreBuffer: function() {
            f.dischargePreBuffer();
          }, finalisePlayList: function(te, Ie) {
            G.pushPlayListTraceMetrics(te, Ie);
          }, getAllMediaInfos: function() {
            return k;
          }, getBuffer: nn, getBufferController: function() {
            return f;
          }, getBufferLevel: function() {
            return f ? f.getBufferLevel() : 0;
          }, getFragmentModel: function() {
            return ft;
          }, getMediaInfo: function() {
            return v;
          }, getMediaSource: function() {
            return f.getMediaSource();
          }, getRepresentation: ie, getRepresentationController: function() {
            return D;
          }, getScheduleController: sn, getStreamId: V, getStreamInfo: function() {
            return Tt;
          }, getType: mt, initialize: function(te, Ie, rn) {
            Y = Be(at).create({ events: et.A, eventBus: st, streamInfo: Tt, timelineConverter: nt, dashConstants: I.A, segmentBaseController: y.segmentBaseController, type: ct }), M = He(at).create({ streamInfo: Tt, type: ct, timelineConverter: nt, dashMetrics: G, mediaPlayerModel: vt, baseURLController: y.baseURLController, errHandler: K, segmentsController: Y, settings: tt, boxParser: Z, events: et.A, eventBus: st, errors: X, debug: (0, ae.A)(at).getInstance(), dashConstants: I.A, constants: q.A, urlUtils: Se(at).getInstance() }), z = Tt.manifestInfo.isDynamic, M.initialize(z), ht.registerStreamType(ct, x), D = Re(at).create({ streamInfo: Tt, type: ct, abrController: ht, dashMetrics: G, playbackController: Ot, timelineConverter: nt, dashConstants: I.A, events: et.A, eventBus: st, errors: X, isDynamic: z, adapter: At, segmentsController: Y }), f = function(Tn, Un) {
              let Cn = null;
              return Tn ? (Cn = Tn !== q.A.TEXT || Un ? Gt(at).create({ abrController: ht, capabilities: F, errHandler: K, fragmentModel: ft, manifestModel: bt, mediaController: _t, mediaPlayerModel: vt, playbackController: Ot, representationController: D, settings: tt, streamInfo: Tt, textController: yt, type: Tn }) : he(at).create({ errHandler: K, fragmentModel: ft, mimeType: Pt, settings: tt, streamInfo: Tt, textController: yt, type: Tn }), Cn) : (K.error(new Yt.A(X.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, X.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + "not properly defined")), null);
            }(ct, rn), f && f.initialize(te), N = Fe(at).create({ streamInfo: Tt, type: ct, mimeType: Pt, adapter: At, dashMetrics: G, mediaPlayerModel: vt, fragmentModel: ft, abrController: ht, playbackController: Ot, textController: yt, mediaController: _t, bufferController: f, representationController: D, settings: tt }), N.initialize(Ie), E = 0, it = !1, J = !1;
          }, isBufferingCompleted: Le, prepareInnerPeriodPlaybackSeeking: function(te) {
            return new Promise((Ie) => {
              if (f.hasBufferAtTime(te.seekTime)) return f.pruneBuffer(), Lt(f.getContinuousBufferTimeForTargetTime(te.seekTime)) && f.setIsBufferingCompleted(!0), void Ie();
              gn(), ft.abortRequests(), f.prepareForPlaybackSeek().then(() => {
                const rn = f.getAllRangesWithSafetyFactor(te.seekTime);
                return f.clearBuffers(rn);
              }).then(() => {
                const rn = f.getContinuousBufferTimeForTargetTime(te.seekTime);
                if (Lt(rn)) f.setIsBufferingCompleted(!0), Ie();
                else {
                  const Tn = isNaN(rn) ? te.seekTime : rn;
                  Ee(Tn), f.setSeekTarget(Tn);
                  const Un = [];
                  Un.push(f.updateAppendWindow());
                  const Cn = ie();
                  Un.push(f.updateBufferTimestampOffset(Cn)), Promise.all(Un).then(() => {
                    N.setInitSegmentRequired(!0), N.setCheckPlaybackQuality(!1), N.startScheduleTimer(), Ie();
                  });
                }
              }).catch((rn) => {
                O.error(rn);
              });
            });
          }, prepareOuterPeriodPlaybackSeeking: function() {
            return new Promise((te, Ie) => {
              try {
                gn(), ft.abortRequests(), f.prepareForPlaybackSeek().then(() => f.pruneAllSafely()).then(() => {
                  te();
                });
              } catch (rn) {
                Ie(rn);
              }
            });
          }, prepareQualityChange: function(te) {
            te.newRepresentation && (H && H.enabled && O.warn(`Canceling queued representation switch to ${H.newRepresentation.id} for ${ct}`), te.isAdaptationSetSwitch ? (O.debug(`Preparing quality switch to different AdaptationSet for type ${ct}`), function(Ie) {
              const rn = Ie.newRepresentation;
              B = !0, gn(), N.setSwitchTrack(!0);
              const Tn = rn.mediaInfo;
              hn(Tn), Qe(new $n({ newMediaInfo: Tn, newRepresentation: rn })).then(() => {
                Sn(Ie);
              });
            }(te)) : (O.debug(`Preparing quality within the same AdaptationSet for type ${ct}`), function(Ie) {
              const rn = Ie.newRepresentation;
              B = !0, gn(), D.prepareQualityChange(rn), Sn(Ie);
            }(te)));
          }, prepareTrackSwitch: function(te) {
            let Ie = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            return new Promise((rn) => {
              O.debug(`Preparing track switch for type ${ct}`);
              const Tn = ct === q.A.TEXT || Ie || tt.get().streaming.trackSwitchMode[ct] === q.A.TRACK_SWITCH_MODE_ALWAYS_REPLACE && Ot.getTimeToStreamEnd(Tt) > tt.get().streaming.buffer.stallThreshold;
              f.getIsBufferingCompleted() && !Tn ? function(Un) {
                return new Promise((Cn) => {
                  const wi = D.getCurrentRepresentation();
                  f.prepareForNonReplacementTrackSwitch(wi, Un).then(() => {
                    st.trigger(et.A.BUFFERING_COMPLETED, {}, { streamId: Tt.id, mediaType: ct }), Cn();
                  }).catch(() => {
                    st.trigger(et.A.BUFFERING_COMPLETED, {}, { streamId: Tt.id, mediaType: ct }), Cn();
                  });
                });
              }(te).then(() => {
                rn();
              }) : (N.setSwitchTrack(!0), Tn ? function(Un) {
                return new Promise((Cn) => {
                  st.trigger(et.A.BUFFER_REPLACEMENT_STARTED, { mediaType: ct, streamId: Tt.id }, { mediaType: ct, streamId: Tt.id }), ft.abortRequests();
                  const wi = ie();
                  f.prepareForReplacementTrackSwitch(wi, Un).then(() => {
                    ye(), Cn();
                  }).catch(() => {
                    ye(), Cn();
                  });
                });
              }(te).then(() => {
                rn();
              }) : function(Un) {
                return new Promise((Cn) => {
                  const wi = () => {
                    const Ui = ft.getRequests({ state: wn.FRAGMENT_MODEL_LOADING });
                    if (Ui && Ui.length !== 0) st.once(St.A.FRAGMENT_LOADING_COMPLETED, wi, x);
                    else {
                      const zr = ie();
                      f.prepareForNonReplacementTrackSwitch(zr, Un).then(() => {
                        Rt(), Cn();
                      }).catch((Ji) => {
                        O.error(Ji), Rt(), Cn();
                      });
                    }
                  };
                  wi();
                });
              }(te).then(() => {
                rn();
              }));
            });
          }, probeNextRequest: function() {
            const te = ie();
            return M.getNextSegmentRequestIdempotent(v, te);
          }, reset: function(te, Ie) {
            M && M.reset(), f && (f.reset(te, Ie), f = null), N && (N.reset(), N = null), D && (D.reset(), D = null), Y && (Y = null), ht && ht.unRegisterStreamType(V(), ct), st.off(et.A.INIT_FRAGMENT_NEEDED, Bt, x), st.off(et.A.MEDIA_FRAGMENT_NEEDED, Qt, x), st.off(et.A.INIT_FRAGMENT_LOADED, We, x), st.off(et.A.MEDIA_FRAGMENT_LOADED, ln, x), st.off(et.A.BUFFER_LEVEL_STATE_CHANGED, Ue, x), st.off(et.A.BUFFER_CLEARED, Ye, x), st.off(et.A.SEEK_TARGET, Wt, x), st.off(et.A.FRAGMENT_LOADING_ABANDONED, ge, x), st.off(et.A.FRAGMENT_LOADING_COMPLETED, Te, x), st.off(et.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, ee, x), st.off(et.A.SET_NON_FRAGMENTED_TEXT, De, x), st.off(et.A.QUOTA_EXCEEDED, Pe, x), st.off(et.A.SOURCE_BUFFER_ERROR, on, x), st.off(et.A.BYTES_APPENDED_END_FRAGMENT, cn, x), Mt(), ct = null, Tt = null;
          }, selectMediaInfo: Qe, setExplicitBufferingTime: Ee, setMediaInfoArray: function(te) {
            k = te;
          }, setMediaSource: function(te) {
            return f.setMediaSource(te, v);
          }, setTrackSwitchInProgress: function(te) {
            lt = te;
          }, updateStreamInfo: function(te) {
            return Tt = te, Le() ? Promise.resolve() : f.updateAppendWindow();
          } }, O = (0, ae.A)(at).getInstance().getLogger(x), Mt(), st.on(et.A.INIT_FRAGMENT_NEEDED, Bt, x), st.on(et.A.MEDIA_FRAGMENT_NEEDED, Qt, x), st.on(et.A.INIT_FRAGMENT_LOADED, We, x), st.on(et.A.MEDIA_FRAGMENT_LOADED, ln, x), st.on(et.A.BUFFER_LEVEL_STATE_CHANGED, Ue, x), st.on(et.A.BUFFER_CLEARED, Ye, x), st.on(et.A.SEEK_TARGET, Wt, x), st.on(et.A.FRAGMENT_LOADING_ABANDONED, ge, x), st.on(et.A.FRAGMENT_LOADING_COMPLETED, Te, x), st.on(et.A.QUOTA_EXCEEDED, Pe, x), st.on(et.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, ee, x), st.on(et.A.SET_NON_FRAGMENTED_TEXT, De, x), st.on(et.A.SOURCE_BUFFER_ERROR, on, x), st.on(et.A.BYTES_APPENDED_END_FRAGMENT, cn, x), x;
        }
        ui.__dashjs_factory_name = "StreamProcessor";
        var Ii = Dt.A.getClassFactory(ui), Ei = class {
          constructor() {
            this.streamId = null, this.segmentType = null, this.quality = NaN, this.index = NaN, this.bytes = null, this.start = NaN, this.end = NaN, this.duration = NaN, this.representation = null, this.endFragment = null;
          }
        }, ai = b(7263);
        function Mi() {
          let y, f;
          function E() {
            f && (f.onloadend = f.onerror = f.onprogress = f.onload = null, f.abort(), f = null);
          }
          return y = { load: function(v, M) {
            if (f = null, f = new XMLHttpRequest(), f.open(v.method, v.url, !0), v.responseType && (f.responseType = v.responseType), v.headers) for (let x in v.headers) {
              let z = v.headers[x];
              z && f.setRequestHeader(x, z);
            }
            return f.withCredentials = v.credentials === "include", f.timeout = v.timeout, f.onload = function() {
              M.url = this.responseURL, M.status = this.status, M.statusText = this.statusText, M.headers = ai.A.parseHttpHeaders(this.getAllResponseHeaders()), M.data = this.response;
            }, f.onloadend = v.customData.onloadend, f.onprogress = v.customData.onprogress, f.onabort = v.customData.onabort, f.ontimeout = v.customData.ontimeout, f.send(), v.customData.abort = E.bind(this), !0;
          }, abort: E, getXhr: function() {
            return f;
          }, reset: function() {
            E(), y = null;
          }, resetInitialSettings: function() {
            E();
          } }, y;
        }
        Mi.__dashjs_factory_name = "XHRLoader";
        var Oi = Dt.A.getClassFactory(Mi);
        function Bi() {
          const y = this.context, f = (0, Q.A)(y).getInstance();
          let E, v, M;
          function x(D, N, Y) {
            D.customData.reader.read().then(Y).catch(function() {
              z(D);
            });
          }
          function z(D) {
            D.customData.onloadend && D.customData.onloadend();
          }
          function O() {
            return typeof performance < "u" && typeof performance.now == "function" ? performance.now() : Date.now();
          }
          function k() {
            if (this.customData.abortController) this.customData.abortController.abort();
            else if (this.customData.reader) try {
              this.customData.reader.cancel(), this.onabort();
            } catch {
            }
          }
          function H(D, N) {
            try {
              if ((D = D.filter((Y) => Y.bytes > N / 4 / D.length)).length > 1) {
                let Y = 0;
                const J = (D[D.length - 1].timestamp - D[0].timestamp) / D.length;
                return D.forEach((it, lt) => {
                  const at = D[lt + 1];
                  if (at) {
                    const st = at.timestamp - it.timestamp;
                    Y += st < J ? st : 0;
                  }
                }), Y;
              }
              return null;
            } catch {
              return null;
            }
          }
          function B(D, N) {
            return 8 * D / N;
          }
          return M = (0, ae.A)(y).getInstance().getLogger(E), E = { abort: k, calculateDownloadedTime: H, load: function(D, N) {
            const Y = function(lt) {
              const at = new Headers();
              if (lt.headers) for (let st in lt.headers) {
                let ht = lt.headers[st];
                ht && at.append(st, ht);
              }
              return at;
            }(D), J = function(lt) {
              let at;
              return typeof window.AbortController == "function" && (at = new AbortController(), lt.customData.abortController = at, at.signal.onabort = lt.customData.onabort), lt.customData.abort = k.bind(lt), at;
            }(D), it = function(lt, at, st) {
              return new Request(lt.url, { method: lt.method, headers: at, credentials: lt.credentials, signal: st ? st.signal : void 0 });
            }(D, Y, J);
            fetch(it).then((lt) => {
              (function(at, st, ht) {
                (function(Ot, W) {
                  Ot.status = W.status, Ot.statusText = W.statusText, Ot.url = W.url;
                  const tt = {};
                  for (const Tt of W.headers.keys()) tt[Tt] = W.headers.get(Tt);
                  Ot.headers = tt;
                })(ht, at), at.ok || st.customData.onloadend();
                let At = 0, Z = !1, F = new Uint8Array(), G = 0;
                st.customData.reader = at.body.getReader();
                let K = [], ft = [], bt = [], _t = !0;
                const vt = f.get().streaming.abr.throughput.lowLatencyDownloadTimeCalculationMode, Pt = (Ot) => {
                  let { value: W, done: tt } = Ot;
                  tt ? function() {
                    if (F) {
                      const Tt = function() {
                        let yt = null;
                        return vt === q.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING ? yt = function() {
                          const nt = function(ct, V) {
                            try {
                              let mt, Mt;
                              if (mt = ct.slice(0, -1), Mt = V.slice(0, -1), mt.length !== Mt.length && M.warn(`[FetchLoader] Moof and Mdat data arrays have different lengths. Moof: ${mt.length}, Mdat: ${Mt.length}`), mt.length <= 1) return null;
                              let Lt = [], Bt = 0, Qt = 0;
                              for (let Zt = 0; Zt < mt.length; Zt++) if (mt[Zt] && Mt[Zt]) {
                                let fe = Mt[Zt].timestamp - mt[Zt].timestamp;
                                if (fe > 1) {
                                  const Ue = B(Mt[Zt].bytes, fe);
                                  Lt.push(Ue), Qt = 0;
                                } else {
                                  Qt === 0 && (Qt = mt[Zt].timestamp, Bt = 0);
                                  let Ue = Mt[Zt].timestamp - Qt;
                                  if (Ue > 1) {
                                    Bt += Mt[Zt].bytes;
                                    const Ye = B(Bt, Ue);
                                    Lt.push(Ye), Qt = 0;
                                  } else Bt += Mt[Zt].bytes;
                                }
                              }
                              return Lt.length > 0 ? Lt.reduce((Zt, fe) => Zt + fe, 0) / Lt.length : null;
                            } catch {
                              return null;
                            }
                          }(ft, bt);
                          return nt ? 8 * At / nt : null;
                        }() : vt === q.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.DOWNLOADED_DATA && (yt = H(K, At)), yt;
                      }();
                      st.customData.onprogress({ loaded: At, total: At, lengthComputable: !0, time: Tt }), ht.data = F.buffer;
                    }
                    st.customData.onloadend();
                  }() : (W && W.length > 0 && function(Tt) {
                    F = function(nt, ct) {
                      if (nt.length === 0) return ct;
                      const V = new Uint8Array(nt.length + ct.length);
                      return V.set(nt), V.set(ct, nt.length), V;
                    }(F, Tt), At += Tt.length, K.push({ timestamp: O(), bytes: Tt.length }), vt === q.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING && _t && v.findLastTopIsoBoxCompleted(["moof"], F, G).found && (_t = !1, ft.push({ timestamp: O() }));
                    const yt = v.findLastTopIsoBoxCompleted(["moov", "mdat"], F, G);
                    yt.found ? function(nt) {
                      const ct = function(V) {
                        let mt;
                        return V === F.length ? (mt = F, F = new Uint8Array()) : (mt = new Uint8Array(F.subarray(0, V)), F = F.subarray(V)), mt;
                      }(nt.startOffsetOfLastFoundTargetBox + nt.sizeOfLastFoundTargetBox);
                      vt !== q.A.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING || _t || (_t = !0, bt.push({ timestamp: O(), bytes: ct.length })), st.customData.onprogress({ data: ct.buffer, lengthComputable: !1, noTrace: !0 }), G = 0;
                    }(yt) : function(nt) {
                      G = nt.startOffsetOfLastCompletedBox + nt.sizeOfLastCompletedBox, Z || (st.customData.onprogress({ lengthComputable: !1, noTrace: !0 }), Z = !0);
                    }(yt);
                  }(W), x(st, 0, Pt));
                };
                x(st, 0, Pt);
              })(lt, D, N);
            }).catch(() => {
              z(D);
            });
          }, reset: function() {
          }, setConfig: function(D) {
            v = D.boxParser;
          } }, E;
        }
        Bi.__dashjs_factory_name = "FetchLoader";
        var dr = Dt.A.getClassFactory(Bi), Ri = b(913), Ci = class {
          constructor() {
            this.period = null, this.index = -1, this.type = null;
          }
        };
        class $i {
          constructor(f, E, v, M) {
            this.url = f || "", this.serviceLocation = E || f || "", this.dvbPriority = v || 1, this.dvbWeight = M || 1, this.availabilityTimeOffset = 0, this.availabilityTimeComplete = !0, this.queryParams = {};
          }
        }
        $i.DEFAULT_DVB_PRIORITY = 1, $i.DEFAULT_DVB_WEIGHT = 1;
        var qr = $i, ji = class {
          constructor() {
            this.schemeIdUri = null, this.value = null, this.id = null;
          }
          init(y) {
            y && (this.schemeIdUri = y.schemeIdUri ? y.schemeIdUri : null, this.value = y.value ? y.value.toString() : null, this.id = y.id ? y.id : null, y[I.A.DVB_URL] && (this.dvbUrl = y[I.A.DVB_URL]), y[I.A.DVB_MIMETYPE] && (this.dvbMimeType = y[I.A.DVB_MIMETYPE]), y[I.A.DVB_FONTFAMILY] && (this.dvbFontFamily = y[I.A.DVB_FONTFAMILY]));
          }
          inArray(y) {
            return !!y && y.some((f) => this.schemeIdUri === f.schemeIdUri && (this.value ? this.value.toString().match(f.value) : "".match(f.value)));
          }
        }, va = class extends ji {
          constructor() {
            super(), this.version = null, this.sessionID = null, this.contentID = null, this.mode = null, this.keys = null, this.includeInRequests = null;
          }
          init(y) {
            super.init(y), y && (this.version = y.version, this.sessionID = y.sessionID, this.contentID = y.contentID, this.mode = y.mode ?? "query", this.keys = y.keys ? y.keys.split(" ") : null, this.includeInRequests = y.includeInRequests ? y.includeInRequests.split(" ") : ["segment"], this.schemeIdUri = y.schemeIdUri);
          }
        }, Ta = class {
          constructor() {
            this.adaptationSets = null, this.adaptationSetsArray = [], this.cmcdParameters = null, this.serviceLocations = null, this.serviceLocationsArray = [];
          }
        }, ia = class extends ji {
          constructor() {
            super(), this.ref = null, this.refId = null, this.robustness = null, this.keyId = null, this.cencDefaultKid = null, this.pssh = null, this.pro = null, this.laUrl = null;
          }
          init(y) {
            super.init(y), y && (this.ref = y.hasOwnProperty(I.A.REF) ? y[I.A.REF] : null, this.refId = y.hasOwnProperty(I.A.REF_ID) ? y[I.A.REF_ID] : null, this.robustness = y.hasOwnProperty(I.A.ROBUSTNESS) ? y[I.A.ROBUSTNESS] : null, this.cencDefaultKid = y.hasOwnProperty(I.A.CENC_DEFAULT_KID) ? y[I.A.CENC_DEFAULT_KID] : null, this.pssh = y.hasOwnProperty(I.A.PSSH) ? y[I.A.PSSH] : null, this.pro = y.hasOwnProperty(I.A.PRO) ? y[I.A.PRO] : null, this.laUrl = y.hasOwnProperty(I.A.LA_URL) ? y[I.A.LA_URL] : y.hasOwnProperty(I.A.LA_URL_LOWER_CASE) ? y[I.A.LA_URL_LOWER_CASE] : null);
          }
          mergeAttributesFromReference(y) {
            ["schemeIdUri", "value", "id", "robustness", "cencDefaultKid", "pro", "pssh", "laUrl"].forEach((f) => {
              this[f] === null && (this[f] = y[f]);
            });
          }
        }, wa = class {
          constructor() {
            this.defaultServiceLocation = null, this.defaultServiceLocationArray = [], this.queryBeforeStart = !1, this.serverUrl = null, this.clientRequirement = !0;
          }
        }, Xe = class {
          constructor() {
            this.type = "", this.duration = NaN, this.presentationTime = NaN, this.id = NaN, this.messageData = "", this.eventStream = null, this.presentationTimeDelta = NaN, this.parsedMessageData = null;
          }
        }, fn = class {
          constructor() {
            this.adaptionSet = null, this.representation = null, this.period = null, this.timescale = 1, this.value = "", this.schemeIdUri = "", this.presentationTimeOffset = 0;
          }
        }, Fn = class {
          constructor() {
            this.availabilityEndTime = Number.POSITIVE_INFINITY, this.availabilityStartTime = null, this.manifest = null, this.maxSegmentDuration = Number.POSITIVE_INFINITY, this.mediaPresentationDuration = NaN, this.minimumUpdatePeriod = NaN, this.publishTime = null, this.suggestedPresentationDelay = 0, this.timeShiftBufferDepth = Number.POSITIVE_INFINITY;
          }
        }, Xn = class {
          constructor(y, f) {
            this.url = y || "", this.serviceLocation = f || null, this.queryParams = {};
          }
        }, di = b(7393), xi = class {
          constructor(y, f, E) {
            this.url = y || "", this.serviceLocation = f || null, this.ttl = E || NaN, this.queryParams = {};
          }
        };
        class oi {
          constructor() {
            this.id = null, this.index = -1, this.duration = NaN, this.start = NaN, this.mpd = null, this.nextPeriodId = null, this.isEncrypted = !1;
          }
        }
        oi.DEFAULT_ID = "defaultId";
        var Zn = oi, zn = class {
          constructor() {
            this.id = null, this.inband = !1, this.type = "encoder", this.applicationScheme = null, this.wallClockTime = null, this.presentationTime = NaN, this.UTCTiming = null;
          }
        }, Qn = class {
          constructor() {
            this.absoluteIndex = NaN, this.adaptation = null, this.availabilityTimeComplete = !0, this.availabilityTimeOffset = 0, this.bandwidth = NaN, this.bitrateInKbit = NaN, this.bitsPerPixel = NaN, this.codecFamily = null, this.codecPrivateData = null, this.codecs = null, this.essentialProperties = [], this.fragmentDuration = null, this.frameRate = null, this.height = NaN, this.id = null, this.indexRange = null, this.initialization = null, this.maxPlayoutRate = NaN, this.mediaFinishedInformation = { numberOfSegments: 0, mediaTimeOfLastSignaledSegment: NaN }, this.mediaInfo = null, this.mimeType = null, this.mseTimeOffset = NaN, this.pixelsPerSecond = NaN, this.presentationTimeOffset = 0, this.qualityRanking = NaN, this.range = null, this.scanType = null, this.segments = null, this.segmentDuration = NaN, this.segmentInfoType = null, this.supplementalProperties = [], this.startNumber = 1, this.timescale = 1, this.width = NaN;
          }
          hasInitialization() {
            return this.initialization !== null || this.range !== null;
          }
          hasSegments() {
            return this.segmentInfoType !== I.A.BASE_URL && this.segmentInfoType !== I.A.SEGMENT_BASE && !this.indexRange;
          }
        }, mi = b(5717), cr = b(7840);
        function Yi(y) {
          return y && y.includes("P") ? cr.duration(y).asSeconds() : y;
        }
        function Hi() {
          let y, f, E, v;
          const M = this.context, x = Se(M).getInstance(), z = Number.isInteger || function(W) {
            return typeof W == "number" && isFinite(W) && Math.floor(W) === W;
          };
          function O(W, tt) {
            if (!W) throw new Error("adaptation is not defined");
            if (!tt) throw new Error("type is not defined");
            if (W.Representation && W.Representation.length) {
              const yt = F(W.Representation[0]);
              if (yt && yt.some((nt) => q.A.THUMBNAILS_SCHEME_ID_URIS.indexOf(nt.schemeIdUri) >= 0)) return tt === q.A.IMAGE;
            }
            if (W.ContentComponent && W.ContentComponent.length > 0) {
              if (W.ContentComponent.length > 1) return tt === q.A.MUXED;
              if (W.ContentComponent[0].contentType === tt) return !0;
            }
            const Tt = tt === q.A.TEXT ? new RegExp("(ttml|vtt|wvtt|stpp)") : new RegExp(tt);
            if (W.Representation && W.Representation.length) {
              const yt = W.Representation[0].codecs;
              if (Tt.test(yt)) return !0;
            }
            if (W.hasOwnProperty(I.A.MIME_TYPE)) return Tt.test(W.mimeType);
            if (W.Representation) {
              let yt;
              for (let nt = 0; nt < W.Representation.length; nt++) if (yt = W.Representation[nt], yt.hasOwnProperty(I.A.MIME_TYPE)) return Tt.test(yt.mimeType);
            }
            return !1;
          }
          function k(W) {
            if (!W) throw new Error("adaptation is not defined");
            if (W.hasOwnProperty(I.A.SEGMENT_TEMPLATE) || W.hasOwnProperty(I.A.SEGMENT_TIMELINE) || W.hasOwnProperty(I.A.SEGMENT_LIST) || W.hasOwnProperty(I.A.SEGMENT_BASE)) return !0;
            if (W.Representation && W.Representation.length > 0) {
              const tt = W.Representation[0];
              if (tt.hasOwnProperty(I.A.SEGMENT_TEMPLATE) || tt.hasOwnProperty(I.A.SEGMENT_TIMELINE) || tt.hasOwnProperty(I.A.SEGMENT_LIST) || tt.hasOwnProperty(I.A.SEGMENT_BASE)) return !0;
            }
            return !1;
          }
          function H(W) {
            return O(W, q.A.MESH);
          }
          function B(W) {
            return O(W, q.A.VIDEO);
          }
          function D(W) {
            return O(W, q.A.TEXT);
          }
          function N(W) {
            return O(W, q.A.IMAGE);
          }
          function Y(W) {
            return W && W.Representation && W.Representation.sort((tt, Tt) => tt.bandwidth - Tt.bandwidth), W;
          }
          function J(W, tt) {
            return W && W.Period && z(tt) && W.Period[tt] ? W.Period[tt].AdaptationSet : [];
          }
          function it(W) {
            return W && W.Period ? W.Period : [];
          }
          function lt(W) {
            const tt = at(W);
            return tt && tt.length > 0;
          }
          function at(W) {
            let tt = [];
            if (!W) return tt;
            const Tt = st(W);
            return tt = tt.concat(Tt), W.hasOwnProperty(I.A.ADAPTATION_SET) && W[I.A.ADAPTATION_SET].length > 0 && W[I.A.ADAPTATION_SET].forEach((yt) => {
              const nt = st(yt);
              tt = tt.concat(nt);
            }), tt;
          }
          function st(W) {
            return W && W.hasOwnProperty(I.A.CONTENT_PROTECTION) && W.ContentProtection.length !== 0 ? W[I.A.CONTENT_PROTECTION].map((tt) => {
              const Tt = new ia();
              return Tt.init(tt), Tt;
            }) : [];
          }
          function ht(W) {
            let tt = !1;
            return W && W.hasOwnProperty("type") && (tt = W.type === I.A.DYNAMIC), tt;
          }
          function At(W, tt) {
            return tt && tt.hasOwnProperty(W) && tt[W].length ? tt[W].map((Tt) => {
              const yt = new ji();
              return yt.init(Tt), yt;
            }) : [];
          }
          function Z(W, tt) {
            if (!tt) return [];
            let Tt = function(yt, nt) {
              if (!nt || !nt.length) return [];
              let ct = nt[0][yt] || [];
              return ct.length === 0 ? [] : nt.length === 1 ? ct : ct.filter((V) => nt.slice(1).every((mt) => mt.hasOwnProperty(yt) && mt[yt].some((Mt) => Mt.schemeIdUri === V.schemeIdUri && Mt.value === V.value)));
            }(W, tt[I.A.REPRESENTATION]);
            return tt.hasOwnProperty(W) && tt[W].length && Tt.push(...tt[W]), Tt.map((yt) => {
              const nt = new ji();
              return nt.init(yt), nt;
            });
          }
          function F(W) {
            return At(I.A.ESSENTIAL_PROPERTY, W);
          }
          function G(W) {
            return At(I.A.SUPPLEMENTAL_PROPERTY, W);
          }
          function K(W) {
            if (!W || !W.S) return NaN;
            let tt = W.S[0], Tt = W.S[1];
            return tt.hasOwnProperty("d") ? tt.d : Tt.t - tt.t;
          }
          function ft(W) {
            const tt = W.presentationTimeOffset;
            return W.adaptation.period.start - tt;
          }
          function bt(W, tt) {
            if (!W) throw new Error("Period cannot be null or undefined");
            let Tt = Zn.DEFAULT_ID + "_" + tt;
            return W.hasOwnProperty(I.A.ID) && W.id.toString().length > 0 && W.id !== "__proto__" && (Tt = W.id.toString()), Tt;
          }
          function _t(W, tt, Tt) {
            const yt = [];
            let nt;
            if (!W) return yt;
            for (nt = 0; nt < W.length; nt++) {
              const ct = new fn();
              if (ct.timescale = 1, ct.representation = tt, !W[nt].hasOwnProperty(q.A.SCHEME_ID_URI)) throw new Error("Invalid EventStream. SchemeIdUri has to be set");
              ct.schemeIdUri = W[nt].schemeIdUri, W[nt].hasOwnProperty(I.A.TIMESCALE) && (ct.timescale = W[nt].timescale), W[nt].hasOwnProperty(I.A.VALUE) && (ct.value = W[nt].value), yt.push(ct), ct.period = Tt;
            }
            return yt;
          }
          function vt(W) {
            const tt = [], Tt = W.BaseURL || [W.baseUri];
            let yt = !1;
            return Tt.some((nt) => {
              if (nt) {
                const ct = new qr();
                let V = nt.__text || nt;
                return x.isRelative(V) && (yt = !0, W.baseUri && (V = x.resolve(V, W.baseUri))), ct.url = V, nt.hasOwnProperty(I.A.SERVICE_LOCATION) && nt.serviceLocation.length ? ct.serviceLocation = nt.serviceLocation : ct.serviceLocation = V, nt.hasOwnProperty(I.A.DVB_PRIORITY) && (ct.dvbPriority = nt[I.A.DVB_PRIORITY]), nt.hasOwnProperty(I.A.DVB_WEIGHT) && (ct.dvbWeight = nt[I.A.DVB_WEIGHT]), nt.hasOwnProperty(I.A.AVAILABILITY_TIME_OFFSET) && (ct.availabilityTimeOffset = `${Yi(nt[I.A.AVAILABILITY_TIME_OFFSET]) || 4}`), nt.hasOwnProperty(I.A.AVAILABILITY_TIME_COMPLETE) && (ct.availabilityTimeComplete = nt[I.A.AVAILABILITY_TIME_COMPLETE] !== "false"), tt.push(ct), yt;
              }
            }), tt;
          }
          function Pt(W) {
            const tt = new wa();
            return tt.serverUrl = W.__text, W.hasOwnProperty(I.A.DEFAULT_SERVICE_LOCATION) && (tt.defaultServiceLocation = W[I.A.DEFAULT_SERVICE_LOCATION], tt.defaultServiceLocationArray = tt.defaultServiceLocation.split(" ")), W.hasOwnProperty(I.A.QUERY_BEFORE_START) && (tt.queryBeforeStart = W[I.A.QUERY_BEFORE_START].toLowerCase() === "true"), W.hasOwnProperty(I.A.CLIENT_REQUIREMENT) && (tt.clientRequirement = W[I.A.CLIENT_REQUIREMENT].toLowerCase() !== "false"), tt;
          }
          function Ot(W) {
            const tt = new Ta();
            return W.hasOwnProperty(I.A.CMCD_PARAMETERS) && W[I.A.CMCD_PARAMETERS].schemeIdUri === q.A.CTA_5004_2023_SCHEME && (tt.cmcdParameters = new va(), tt.cmcdParameters.init(W[I.A.CMCD_PARAMETERS])), W.hasOwnProperty(I.A.SERVICE_LOCATIONS) && W[I.A.SERVICE_LOCATIONS] !== "" && (tt.serviceLocations = W[I.A.SERVICE_LOCATIONS], tt.serviceLocationsArray = tt.serviceLocations.toString().split(" ")), W.hasOwnProperty(I.A.ADAPTATION_SETS) && W[I.A.ADAPTATION_SETS] !== "" && (tt.adaptationSets = W[I.A.ADAPTATION_SETS], tt.adaptationSetsArray = tt.adaptationSets.toString().split(" ")), tt;
          }
          return y = { getAccessibilityForAdaptation: function(W) {
            return W && W.hasOwnProperty(I.A.ACCESSIBILITY) && W[I.A.ACCESSIBILITY].length ? W[I.A.ACCESSIBILITY].map((tt) => {
              const Tt = new ji();
              return Tt.init(tt), Tt;
            }) : [];
          }, getAdaptationForId: function(W, tt, Tt) {
            const yt = J(tt, Tt);
            let nt, ct;
            for (nt = 0, ct = yt.length; nt < ct; nt++) if (yt[nt].hasOwnProperty(I.A.ID) && yt[nt].id === W) return yt[nt];
            return null;
          }, getAdaptationForIndex: function(W, tt, Tt) {
            const yt = J(tt, Tt);
            return yt.length > 0 && z(W) ? yt[W] : null;
          }, getAdaptationsForPeriod: function(W) {
            const tt = W && z(W.index) ? W.mpd.manifest.Period[W.index] : null, Tt = [];
            let yt, nt, ct;
            if (tt && tt.AdaptationSet) for (ct = 0; ct < tt.AdaptationSet.length; ct++) nt = tt.AdaptationSet[ct], yt = new Ci(), nt.hasOwnProperty(I.A.ID) && (yt.id = nt.id), yt.index = ct, yt.period = W, O(nt, q.A.MUXED) ? yt.type = q.A.MUXED : O(nt, q.A.AUDIO) ? yt.type = q.A.AUDIO : B(nt) ? yt.type = q.A.VIDEO : D(nt) ? yt.type = q.A.TEXT : N(nt) ? yt.type = q.A.IMAGE : H(nt) ? yt.type = q.A.MESH : f.warn("Unknown Adaptation stream type"), Tt.push(yt);
            return Tt;
          }, getAdaptationsForType: function(W, tt, Tt) {
            const yt = J(W, tt);
            let nt, ct;
            const V = [];
            for (nt = 0, ct = yt.length; nt < ct; nt++) O(yt[nt], Tt) && V.push(Y(yt[nt]));
            return V;
          }, getAudioChannelConfigurationForAdaptation: function(W) {
            return W && W.hasOwnProperty(I.A.AUDIO_CHANNEL_CONFIGURATION) && W[I.A.AUDIO_CHANNEL_CONFIGURATION].length ? W[I.A.AUDIO_CHANNEL_CONFIGURATION].map((tt) => {
              const Tt = new ji();
              return Tt.init(tt), Tt;
            }) : [];
          }, getAudioChannelConfigurationForRepresentation: function(W) {
            return W && W.hasOwnProperty(I.A.AUDIO_CHANNEL_CONFIGURATION) && W[I.A.AUDIO_CHANNEL_CONFIGURATION].length ? W[I.A.AUDIO_CHANNEL_CONFIGURATION].map((tt) => {
              const Tt = new ji();
              return Tt.init(tt), Tt;
            }) : [];
          }, getAvailabilityStartTime: function(W) {
            return W && W.hasOwnProperty(I.A.AVAILABILITY_START_TIME) && W.availabilityStartTime !== null ? W.availabilityStartTime.getTime() : null;
          }, getBandwidth: function(W) {
            return W && W.bandwidth ? W.bandwidth : NaN;
          }, getBaseURLsFromElement: vt, getBitrateListForAdaptation: function(W) {
            const tt = Y(W);
            return (tt && tt.Representation ? tt.Representation : []).map((Tt) => ({ bandwidth: Tt.bandwidth, width: Tt.width || 0, height: Tt.height || 0, scanType: Tt.scanType || null, id: Tt.id || null }));
          }, getCodec: function(W, tt, Tt) {
            let yt = null;
            if (W && W.Representation && W.Representation.length > 0) {
              const nt = z(tt) && tt >= 0 && tt < W.Representation.length ? W.Representation[tt] : W.Representation[0];
              nt && (yt = nt.mimeType + ';codecs="' + nt.codecs + '"', Tt && nt.width !== void 0 && (yt += ';width="' + nt.width + '";height="' + nt.height + '"'));
            }
            return yt && (yt = yt.replace(/\sprofiles=[^;]*/g, "")), yt;
          }, getCombinedEssentialPropertiesForAdaptationSet: function(W) {
            return Z(I.A.ESSENTIAL_PROPERTY, W);
          }, getCombinedSupplementalPropertiesForAdaptationSet: function(W) {
            return Z(I.A.SUPPLEMENTAL_PROPERTY, W);
          }, getContentProtectionByAdaptation: function(W) {
            return st(W);
          }, getContentProtectionByManifest: function(W) {
            let tt = [];
            if (!W) return tt;
            const Tt = st(W);
            return tt = tt.concat(Tt), W.hasOwnProperty(I.A.PERIOD) && W[I.A.PERIOD].length > 0 && W[I.A.PERIOD].forEach((yt) => {
              const nt = at(yt);
              tt = tt.concat(nt);
            }), tt;
          }, getContentProtectionByPeriod: at, getContentSteering: function(W) {
            if (W && W.hasOwnProperty(I.A.CONTENT_STEERING)) return Pt(W[I.A.CONTENT_STEERING][0]);
          }, getDuration: function(W) {
            let tt;
            return tt = W && W.hasOwnProperty(I.A.MEDIA_PRESENTATION_DURATION) ? W.mediaPresentationDuration : W && W.type == "dynamic" ? Number.POSITIVE_INFINITY : Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, tt;
          }, getEssentialPropertiesForAdaptationSet: function(W) {
            return At(I.A.ESSENTIAL_PROPERTY, W);
          }, getEssentialPropertiesForRepresentation: F, getEventStreamForAdaptationSet: function(W, tt, Tt) {
            let yt, nt, ct;
            return W && W.Period && tt && tt.period && z(tt.period.index) && (nt = W.Period[tt.period.index], nt && nt.AdaptationSet && z(tt.index) && (ct = nt.AdaptationSet[tt.index], ct && (yt = ct.InbandEventStream))), _t(yt, null, Tt);
          }, getEventStreamForRepresentation: function(W, tt, Tt) {
            let yt, nt, ct, V;
            return W && W.Period && tt && tt.adaptation && tt.adaptation.period && z(tt.adaptation.period.index) && (nt = W.Period[tt.adaptation.period.index], nt && nt.AdaptationSet && z(tt.adaptation.index) && (ct = nt.AdaptationSet[tt.adaptation.index], ct && ct.Representation && z(tt.index) && (V = ct.Representation[tt.index], V && (yt = V.InbandEventStream)))), _t(yt, tt, Tt);
          }, getEventsForPeriod: function(W) {
            const tt = W && W.mpd && W.mpd.manifest ? W.mpd.manifest : null, Tt = tt ? tt.Period : null, yt = Tt && W && z(W.index) ? Tt[W.index].EventStream : null, nt = [];
            let ct, V;
            if (yt) for (ct = 0; ct < yt.length; ct++) {
              const mt = new fn();
              if (mt.period = W, mt.timescale = 1, !yt[ct].hasOwnProperty(q.A.SCHEME_ID_URI)) throw new Error("Invalid EventStream. SchemeIdUri has to be set");
              for (mt.schemeIdUri = yt[ct][q.A.SCHEME_ID_URI], yt[ct].hasOwnProperty(I.A.TIMESCALE) && (mt.timescale = yt[ct][I.A.TIMESCALE]), yt[ct].hasOwnProperty(I.A.VALUE) && (mt.value = yt[ct][I.A.VALUE]), yt[ct].hasOwnProperty(I.A.PRESENTATION_TIME_OFFSET) && (mt.presentationTimeOffset = yt[ct][I.A.PRESENTATION_TIME_OFFSET]), V = 0; yt[ct].Event && V < yt[ct].Event.length; V++) {
                const Mt = yt[ct].Event[V], Lt = new Xe();
                Lt.presentationTime = 0, Lt.eventStream = mt, Mt.hasOwnProperty(I.A.PRESENTATION_TIME) && (Lt.presentationTime = Mt.presentationTime);
                const Bt = mt.presentationTimeOffset ? mt.presentationTimeOffset / mt.timescale : 0;
                Lt.calculatedPresentationTime = Lt.presentationTime / mt.timescale + W.start - Bt, Mt.hasOwnProperty(I.A.DURATION) && (Lt.duration = Mt.duration / mt.timescale), Mt.hasOwnProperty(I.A.ID) ? Lt.id = parseInt(Mt.id) : Lt.id = null, Mt.Signal && Mt.Signal.Binary ? Lt.messageData = v.decodeArray(Mt.Signal.Binary.toString()) : Lt.messageData = Mt.messageData || Mt.__cdata || Mt.__text, nt.push(Lt);
              }
            }
            return nt;
          }, getId: function(W) {
            return W && W[I.A.ID] || null;
          }, getIndexForAdaptation: function(W, tt, Tt) {
            if (!W) return -1;
            const yt = J(tt, Tt);
            for (let nt = 0; nt < yt.length; nt++) if ((0, di.A)(M).getInstance().areEqual(yt[nt], W)) return nt;
            return -1;
          }, getIsDynamic: ht, getIsFragmented: k, getIsText: D, getIsTypeOf: O, getLabelsForAdaptation: function(W) {
            if (!W || !W.Label) return [];
            const tt = [];
            for (let Tt = 0; Tt < W.Label.length; Tt++) tt.push({ lang: W.Label[Tt].lang, text: W.Label[Tt].__text || W.Label[Tt] });
            return tt;
          }, getLanguageForAdaptation: function(W) {
            let tt = "";
            return W && W.hasOwnProperty(I.A.LANG) && (tt = W.lang), tt;
          }, getLocation: function(W) {
            return W && W.hasOwnProperty(I.A.LOCATION) ? W[I.A.LOCATION].map((tt) => {
              const Tt = tt.__text || tt, yt = tt.hasOwnProperty(I.A.SERVICE_LOCATION) ? tt[I.A.SERVICE_LOCATION] : null;
              return new Xn(Tt, yt);
            }) : [];
          }, getManifestUpdatePeriod: function(W) {
            let tt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, Tt = NaN;
            return W && W.hasOwnProperty(I.A.MINIMUM_UPDATE_PERIOD) && (Tt = W.minimumUpdatePeriod), isNaN(Tt) ? Tt : Math.max(Tt - tt, 1);
          }, getMimeType: function(W) {
            return W && W.Representation && W.Representation.length > 0 ? W.Representation[0].mimeType : null;
          }, getMpd: function(W) {
            const tt = new Fn();
            return W && (tt.manifest = W, W.hasOwnProperty(I.A.AVAILABILITY_START_TIME) ? tt.availabilityStartTime = new Date(W.availabilityStartTime.getTime()) : W.loadedTime && (tt.availabilityStartTime = new Date(W.loadedTime.getTime())), W.hasOwnProperty(I.A.AVAILABILITY_END_TIME) && (tt.availabilityEndTime = new Date(W.availabilityEndTime.getTime())), W.hasOwnProperty(I.A.MINIMUM_UPDATE_PERIOD) && (tt.minimumUpdatePeriod = W.minimumUpdatePeriod), W.hasOwnProperty(I.A.MEDIA_PRESENTATION_DURATION) && (tt.mediaPresentationDuration = W.mediaPresentationDuration), W.hasOwnProperty(I.A.SUGGESTED_PRESENTATION_DELAY) && (tt.suggestedPresentationDelay = W.suggestedPresentationDelay), W.hasOwnProperty(I.A.TIMESHIFT_BUFFER_DEPTH) && (tt.timeShiftBufferDepth = W.timeShiftBufferDepth), W.hasOwnProperty(I.A.MAX_SEGMENT_DURATION) && (tt.maxSegmentDuration = W.maxSegmentDuration), W.hasOwnProperty(I.A.PUBLISH_TIME) && (tt.publishTime = new Date(W.publishTime))), tt;
          }, getPatchLocation: function(W) {
            return W && W.hasOwnProperty(I.A.PATCH_LOCATION) ? W[I.A.PATCH_LOCATION].map((tt) => {
              const Tt = tt.__text || tt, yt = tt.hasOwnProperty(I.A.SERVICE_LOCATION) ? tt[I.A.SERVICE_LOCATION] : null;
              let nt = tt.hasOwnProperty(I.A.TTL) ? 1e3 * parseFloat(tt[I.A.TTL]) : NaN;
              return new xi(Tt, yt, nt);
            }) : [];
          }, getProducerReferenceTimesForAdaptation: function(W) {
            const tt = W && W.hasOwnProperty(I.A.PRODUCER_REFERENCE_TIME) ? W[I.A.PRODUCER_REFERENCE_TIME] : [];
            (W && W.hasOwnProperty(I.A.REPRESENTATION) ? W[I.A.REPRESENTATION] : []).forEach((yt) => {
              yt.hasOwnProperty(I.A.PRODUCER_REFERENCE_TIME) && tt.push(...yt[I.A.PRODUCER_REFERENCE_TIME]);
            });
            const Tt = [];
            return tt.forEach((yt) => {
              const nt = new zn();
              yt.hasOwnProperty(I.A.ID) && (nt[I.A.ID] = parseInt(yt[I.A.ID]), yt.hasOwnProperty(I.A.WALL_CLOCK_TIME) && (nt[I.A.WALL_CLOCK_TIME] = yt[I.A.WALL_CLOCK_TIME], yt.hasOwnProperty(I.A.PRESENTATION_TIME) && (nt[I.A.PRESENTATION_TIME] = yt[I.A.PRESENTATION_TIME], yt.hasOwnProperty(I.A.INBAND) && (nt[I.A.INBAND] = yt[I.A.INBAND] !== "false"), yt.hasOwnProperty(I.A.TYPE) && (nt[I.A.TYPE] = yt[I.A.TYPE]), Tt.push(nt))));
            }), Tt;
          }, getPublishTime: function(W) {
            return W && W.hasOwnProperty(I.A.PUBLISH_TIME) ? new Date(W[I.A.PUBLISH_TIME]) : null;
          }, getRealPeriodForIndex: function(W, tt) {
            const Tt = it(tt);
            return Tt.length > 0 && z(W) ? Tt[W] : null;
          }, getRealPeriods: it, getRegularPeriods: function(W) {
            const tt = !!W && ht(W.manifest), Tt = [];
            let yt, nt, ct = null, V = null, mt = null, Mt = null;
            for (nt = 0, yt = W && W.manifest && W.manifest.Period ? W.manifest.Period.length : 0; nt < yt; nt++) V = W.manifest.Period[nt], V.hasOwnProperty(I.A.START) ? (Mt = new Zn(), Mt.start = V.start) : ct !== null && ct.hasOwnProperty(I.A.DURATION) && mt !== null ? (Mt = new Zn(), Mt.start = parseFloat((mt.start + mt.duration).toFixed(5))) : nt !== 0 || tt || (Mt = new Zn(), Mt.start = 0), mt !== null && isNaN(mt.duration) && (Mt !== null ? mt.duration = parseFloat((Mt.start - mt.start).toFixed(5)) : f.warn("First period duration could not be calculated because lack of start and duration period properties. This will cause timing issues during playback")), Mt !== null && (Mt.id = bt(V, nt), Mt.index = nt, Mt.mpd = W, Mt.isEncrypted = lt(V), V.hasOwnProperty(I.A.DURATION) && (Mt.duration = V.duration), mt && (mt.nextPeriodId = Mt.id), Tt.push(Mt), ct = V, mt = Mt), V = null, Mt = null;
            return Tt.length === 0 || mt !== null && isNaN(mt.duration) && (mt.duration = parseFloat((function(Lt) {
              (function() {
                if (!E || !E.hasOwnProperty("error")) throw new Error(q.A.MISSING_CONFIG_ERROR);
              })();
              const Bt = ht(Lt.mpd.manifest);
              let Qt;
              return Lt.mpd.manifest.mediaPresentationDuration ? Qt = Lt.mpd.manifest.mediaPresentationDuration : Lt.duration ? Qt = Lt.duration : Bt ? Qt = Number.POSITIVE_INFINITY : E.error(new Yt.A(X.MANIFEST_ERROR_ID_PARSE_CODE, "Must have @mediaPresentationDuration on MPD or an explicit @duration on the last period.", Lt)), Qt;
            }(mt) - mt.start).toFixed(5))), Tt;
          }, getRepresentationCount: function(W) {
            return W && W.Representation ? W.Representation.length : 0;
          }, getRepresentationFor: function(W, tt) {
            return tt && tt.Representation && tt.Representation.length > 0 && z(W) ? tt.Representation[W] : null;
          }, getRepresentationSortFunction: function() {
            return (W, tt) => W.bandwidth - tt.bandwidth;
          }, getRepresentationsForAdaptation: function(W, tt) {
            const Tt = [], yt = function(V) {
              if (V && V.period && z(V.period.index)) {
                const mt = V.period.mpd.manifest.Period[V.period.index];
                if (mt && mt.AdaptationSet && z(V.index)) return Y(mt.AdaptationSet[V.index]);
              }
            }(W);
            let nt, ct;
            if (yt && yt.Representation) {
              if (W && W.period && z(W.period.index)) {
                const V = vt(W.period.mpd.manifest);
                V && (ct = V[0]);
              }
              for (let V = 0, mt = yt.Representation.length; V < mt; ++V) {
                const Mt = yt.Representation[V], Lt = new Qn();
                if (Lt.index = V, Lt.adaptation = W, Lt.mediaInfo = tt, Mt.hasOwnProperty(I.A.ID) && (Lt.id = Mt.id), Mt.hasOwnProperty(I.A.CODECS) && (Lt.codecs = Mt.codecs, Lt.codecFamily = ai.A.getCodecFamily(Lt.codecs)), Mt.hasOwnProperty(I.A.MIME_TYPE) && (Lt.mimeType = Mt[I.A.MIME_TYPE]), Mt.hasOwnProperty(I.A.CODEC_PRIVATE_DATA) && (Lt.codecPrivateData = Mt.codecPrivateData), Mt.hasOwnProperty(I.A.BANDWITH) && (Lt.bandwidth = Mt.bandwidth, Lt.bitrateInKbit = Mt.bandwidth / 1e3), Mt.hasOwnProperty(I.A.WIDTH) && (Lt.width = Mt.width), Mt.hasOwnProperty(I.A.HEIGHT) && (Lt.height = Mt.height), Mt.hasOwnProperty(I.A.SCAN_TYPE) && (Lt.scanType = Mt.scanType), Mt.hasOwnProperty(I.A.FRAMERATE)) {
                  const Bt = Mt[I.A.FRAMERATE];
                  if (isNaN(Bt) && Bt.includes("/")) {
                    const Qt = Bt.split("/");
                    if (Qt.length === 2) {
                      const Zt = parseFloat(Qt[0]), fe = parseFloat(Qt[1]);
                      isNaN(Zt) || isNaN(fe) || fe === 0 || (Lt.frameRate = Zt / fe);
                    }
                  } else Lt.frameRate = Bt;
                }
                if (Mt.hasOwnProperty(I.A.QUALITY_RANKING) && (Lt.qualityRanking = Mt[I.A.QUALITY_RANKING]), Mt.hasOwnProperty(I.A.MAX_PLAYOUT_RATE) && (Lt.maxPlayoutRate = Mt.maxPlayoutRate), Mt.hasOwnProperty(I.A.SEGMENT_BASE) ? (nt = Mt.SegmentBase, Lt.segmentInfoType = I.A.SEGMENT_BASE) : Mt.hasOwnProperty(I.A.SEGMENT_LIST) ? (nt = Mt.SegmentList, nt.hasOwnProperty(I.A.SEGMENT_TIMELINE) ? Lt.segmentInfoType = I.A.SEGMENT_TIMELINE : Lt.segmentInfoType = I.A.SEGMENT_LIST) : Mt.hasOwnProperty(I.A.SEGMENT_TEMPLATE) ? (nt = Mt.SegmentTemplate, nt.hasOwnProperty(I.A.SEGMENT_TIMELINE) ? Lt.segmentInfoType = I.A.SEGMENT_TIMELINE : Lt.segmentInfoType = I.A.SEGMENT_TEMPLATE, nt.hasOwnProperty(I.A.INITIALIZATION_MINUS) && (Lt.initialization = nt.initialization.split("$Bandwidth$").join(Mt.bandwidth).split("$RepresentationID$").join(Mt.id))) : Lt.segmentInfoType = I.A.BASE_URL, Lt.essentialProperties = F(Mt), Lt.supplementalProperties = G(Mt), nt) {
                  if (nt.hasOwnProperty(I.A.INITIALIZATION)) {
                    const Bt = nt.Initialization;
                    Bt.hasOwnProperty(I.A.SOURCE_URL) && (Lt.initialization = Bt.sourceURL), Bt.hasOwnProperty(I.A.RANGE) && (Lt.range = Bt.range);
                  } else D(yt) && k(yt) && yt.mimeType && yt.mimeType.indexOf("application/mp4") === -1 && (Lt.range = 0);
                  nt.hasOwnProperty(I.A.TIMESCALE) && (Lt.timescale = nt.timescale), nt.hasOwnProperty(I.A.DURATION) ? Lt.segmentDuration = nt.duration / Lt.timescale : Mt.hasOwnProperty(I.A.SEGMENT_TEMPLATE) && (nt = Mt.SegmentTemplate, nt.hasOwnProperty(I.A.SEGMENT_TIMELINE) && (Lt.segmentDuration = K(nt.SegmentTimeline) / Lt.timescale)), nt.hasOwnProperty(I.A.MEDIA) && (Lt.media = nt.media), nt.hasOwnProperty(I.A.START_NUMBER) && (Lt.startNumber = parseInt(nt.startNumber)), nt.hasOwnProperty(I.A.INDEX_RANGE) && (Lt.indexRange = nt.indexRange), nt.hasOwnProperty(I.A.PRESENTATION_TIME_OFFSET) && (Lt.presentationTimeOffset = nt.presentationTimeOffset / Lt.timescale), nt.hasOwnProperty(I.A.AVAILABILITY_TIME_OFFSET) ? Lt.availabilityTimeOffset = Yi(nt.availabilityTimeOffset) : ct && ct.availabilityTimeOffset !== void 0 && (Lt.availabilityTimeOffset = Yi(ct.availabilityTimeOffset)), nt.hasOwnProperty(I.A.AVAILABILITY_TIME_COMPLETE) ? Lt.availabilityTimeComplete = nt.availabilityTimeComplete !== "false" : ct && ct.availabilityTimeComplete !== void 0 && (Lt.availabilityTimeComplete = ct.availabilityTimeComplete);
                }
                Lt.mseTimeOffset = ft(Lt), Lt.path = [W.period.index, W.index, V], isNaN(Lt.width) || isNaN(Lt.height) || isNaN(Lt.frameRate) || (Lt.pixelsPerSecond = Math.max(1, Lt.width * Lt.height * Lt.frameRate), isNaN(Lt.bandwidth) || (Lt.bitsPerPixel = Lt.bandwidth / Lt.pixelsPerSecond)), Tt.push(Lt);
              }
            }
            return Tt;
          }, getRolesForAdaptation: function(W) {
            return W && W.hasOwnProperty(I.A.ROLE) && W[I.A.ROLE].length ? W[I.A.ROLE].map((tt) => {
              const Tt = new ji();
              return Tt.init(tt), Tt;
            }) : [];
          }, getSegmentAlignment: function(W) {
            return !(!W || !W.hasOwnProperty(I.A.SEGMENT_ALIGNMENT)) && W[I.A.SEGMENT_ALIGNMENT] === "true";
          }, getSelectionPriority: function(W) {
            try {
              const tt = W && W.selectionPriority !== void 0 ? parseInt(W.selectionPriority) : 1;
              return isNaN(tt) ? 1 : tt;
            } catch {
              return 1;
            }
          }, getServiceDescriptions: function(W) {
            const tt = [];
            if (W && W.hasOwnProperty(I.A.SERVICE_DESCRIPTION)) for (const Tt of W.ServiceDescription) {
              let yt = null, nt = null, ct = null, V = null, mt = null, Mt = null, Lt = null, Bt = null;
              for (const Qt in Tt) if (Tt.hasOwnProperty(Qt)) if (Qt === I.A.ID) yt = Tt[Qt];
              else if (Qt === I.A.SERVICE_DESCRIPTION_SCOPE) nt = Tt[Qt].schemeIdUri;
              else if (Qt === I.A.SERVICE_DESCRIPTION_LATENCY) ct = { target: parseInt(Tt[Qt].target), max: parseInt(Tt[Qt].max), min: parseInt(Tt[Qt].min), referenceId: parseInt(Tt[Qt].referenceId) };
              else if (Qt === I.A.SERVICE_DESCRIPTION_PLAYBACK_RATE) V = { max: parseFloat(Tt[Qt].max), min: parseFloat(Tt[Qt].min) };
              else if (Qt === I.A.SERVICE_DESCRIPTION_OPERATING_QUALITY) mt = { mediaType: Tt[Qt].mediaType, max: parseInt(Tt[Qt].max), min: parseInt(Tt[Qt].min), target: parseInt(Tt[Qt].target), type: Tt[Qt].type, maxQualityDifference: parseInt(Tt[Qt].maxQualityDifference) };
              else if (Qt === I.A.SERVICE_DESCRIPTION_OPERATING_BANDWIDTH) Mt = { mediaType: Tt[Qt].mediaType, max: parseInt(Tt[Qt].max), min: parseInt(Tt[Qt].min), target: parseInt(Tt[Qt].target) };
              else if (Qt === I.A.CONTENT_STEERING) {
                let Zt = Tt[Qt];
                Zt = Array.isArray(Zt) ? Zt.at(Zt.length - 1) : Zt, Lt = Pt(Zt);
              } else Qt === I.A.CLIENT_DATA_REPORTING && (Bt = Ot(Tt[Qt]));
              tt.push({ id: yt, schemeIdUri: nt, latency: ct, playbackRate: V, operatingQuality: mt, operatingBandwidth: Mt, contentSteering: Lt, clientDataReporting: Bt });
            }
            return tt;
          }, getSubSegmentAlignment: function(W) {
            return !(!W || !W.hasOwnProperty(I.A.SUB_SEGMENT_ALIGNMENT)) && W[I.A.SUB_SEGMENT_ALIGNMENT] === "true";
          }, getSuggestedPresentationDelay: function(W) {
            return W && W.hasOwnProperty(I.A.SUGGESTED_PRESENTATION_DELAY) ? W.suggestedPresentationDelay : null;
          }, getSupplementalPropertiesForAdaptationSet: function(W) {
            return At(I.A.SUPPLEMENTAL_PROPERTY, W);
          }, getSupplementalPropertiesForRepresentation: G, getUTCTimingSources: function(W) {
            const tt = ht(W), Tt = !!W && W.hasOwnProperty(I.A.AVAILABILITY_START_TIME), yt = W ? W.UTCTiming : null, nt = [];
            return (tt || Tt) && yt && yt.forEach(function(ct) {
              const V = new mi.A();
              ct.hasOwnProperty(q.A.SCHEME_ID_URI) && (V.schemeIdUri = ct.schemeIdUri, ct.hasOwnProperty(I.A.VALUE) && (V.value = ct.value.toString(), nt.push(V)));
            }), nt;
          }, getViewpointForAdaptation: function(W) {
            return W && W.hasOwnProperty(I.A.VIEWPOINT) && W[I.A.VIEWPOINT].length ? W[I.A.VIEWPOINT].map((tt) => {
              const Tt = new ji();
              return Tt.init(tt), Tt;
            }) : [];
          }, hasProfile: function(W, tt) {
            let Tt = !1;
            return W && W.profiles && W.profiles.length > 0 && (Tt = W.profiles.indexOf(tt) !== -1), Tt;
          }, isPeriodEncrypted: lt, setConfig: function(W) {
            W && (W.errHandler && (E = W.errHandler), W.BASE64 && (v = W.BASE64));
          } }, f = (0, ae.A)(M).getInstance().getLogger(y), y;
        }
        Hi.__dashjs_factory_name = "DashManifestModel";
        var Zi = Dt.A.getSingletonFactory(Hi);
        const qi = { MANIFEST: "m", AUDIO: "a", VIDEO: "v", MUXED: "av", INIT: "i", CAPTION: "c", TIMED_TEXT: "tt", KEY: "k", OTHER: "o" }, Fi = qi, ra = "v", Gr = "l", ss = "d", sr = "s";
        class Vi {
          constructor(f, E) {
            Array.isArray(f) && (f = f.map((v) => v instanceof Vi ? v : new Vi(v))), this.value = f, this.params = E;
          }
        }
        const Dr = "Dict";
        function Fa(y, f, E, v) {
          return new Error(`failed to ${y} "${M = f, Array.isArray(M) ? JSON.stringify(M) : M instanceof Map ? "Map{}" : M instanceof Set ? "Set{}" : typeof M == "object" ? JSON.stringify(M) : String(M)}" as ${E}`, { cause: v });
          var M;
        }
        function tr(y, f, E) {
          return Fa("serialize", y, f, E);
        }
        class aa {
          constructor(f) {
            this.description = f;
          }
        }
        const Aa = "Bare Item", Ir = "Boolean", or = "Byte Sequence", hi = "Integer";
        function hr(y) {
          return y < -999999999999999 || 999999999999999 < y;
        }
        function vr(y) {
          if (hr(y)) throw tr(y, hi);
          return y.toString();
        }
        function fr(y, f) {
          if (y < 0) return -fr(-y, f);
          const E = Math.pow(10, f);
          if (Math.abs(y * E % 1 - 0.5) < Number.EPSILON) {
            const v = Math.floor(y * E);
            return (v % 2 == 0 ? v : v + 1) / E;
          }
          return Math.round(y * E) / E;
        }
        const vi = "Decimal";
        function Xi(y) {
          const f = fr(y, 3);
          if (Math.floor(Math.abs(f)).toString().length > 12) throw tr(y, vi);
          const E = f.toString();
          return E.includes(".") ? E : `${E}.0`;
        }
        const Rr = "String", Qi = /[\x00-\x1f\x7f]+/;
        function Tr(y) {
          return y.description || y.toString().slice(7, -1);
        }
        const Sa = "Token";
        function mr(y) {
          const f = Tr(y);
          if (/^([a-zA-Z*])([!#$%&'*+\-.^_`|~\w:/]*)$/.test(f) === !1) throw tr(f, Sa);
          return f;
        }
        function sa(y) {
          switch (typeof y) {
            case "number":
              if (!Number.isFinite(y)) throw tr(y, Aa);
              return Number.isInteger(y) ? vr(y) : Xi(y);
            case "string":
              return function(f) {
                if (Qi.test(f)) throw tr(f, Rr);
                return `"${f.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
              }(y);
            case "symbol":
              return mr(y);
            case "boolean":
              return function(f) {
                if (typeof f != "boolean") throw tr(f, Ir);
                return f ? "?1" : "?0";
              }(y);
            case "object":
              if (y instanceof Date) return function(f) {
                return `@${vr(f.getTime() / 1e3)}`;
              }(y);
              if (y instanceof Uint8Array) return function(f) {
                if (ArrayBuffer.isView(f) === !1) throw tr(f, or);
                return `:${E = f, btoa(String.fromCharCode(...E))}:`;
                var E;
              }(y);
              if (y instanceof aa) return mr(y);
            default:
              throw tr(y, Aa);
          }
        }
        const Ua = "Key";
        function oa(y) {
          if (/^[a-z*][a-z0-9\-_.*]*$/.test(y) === !1) throw tr(y, Ua);
          return y;
        }
        function Vr(y) {
          return y == null ? "" : Object.entries(y).map((f) => {
            let [E, v] = f;
            return v === !0 ? `;${oa(E)}` : `;${oa(E)}=${sa(v)}`;
          }).join("");
        }
        function la(y) {
          return y instanceof Vi ? `${sa(y.value)}${Vr(y.params)}` : sa(y);
        }
        const Cr = (y) => Math.round(y), Ma = (y) => 100 * Cr(y / 100), Zs = { br: Cr, d: Cr, bl: Ma, dl: Ma, mtp: Ma, nor: (y, f) => (f != null && f.baseUrl && (y = function(E, v) {
          const M = new URL(E), x = new URL(v);
          if (M.origin !== x.origin) return E;
          const z = M.pathname.split("/").slice(1), O = x.pathname.split("/").slice(1, -1);
          for (; z[0] === O[0]; ) z.shift(), O.shift();
          for (; O.length; ) O.shift(), z.unshift("..");
          return z.join("/");
        }(y, f.baseUrl)), encodeURIComponent(y)), rtp: Ma, tb: Cr };
        function ys(y) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return y ? function(E, v) {
            return function(M) {
              let x = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : { whitespace: !0 };
              if (typeof M != "object") throw tr(M, Dr);
              const z = M instanceof Map ? M.entries() : Object.entries(M), O = x != null && x.whitespace ? " " : "";
              return Array.from(z).map((k) => {
                let [H, B] = k;
                B instanceof Vi == 0 && (B = new Vi(B));
                let D = oa(H);
                var N;
                return B.value === !0 ? D += Vr(B.params) : (D += "=", Array.isArray(B.value) ? D += `(${(N = B).value.map(la).join(" ")})${Vr(N.params)}` : D += la(B)), D;
              }).join(`,${O}`);
            }(E, v);
          }(function(E, v) {
            const M = {};
            if (E == null || typeof E != "object") return M;
            const x = Object.keys(E).sort(), z = Object.assign({}, Zs, v == null ? void 0 : v.formatters), O = v == null ? void 0 : v.filter;
            return x.forEach((k) => {
              if (O != null && O(k)) return;
              let H = E[k];
              const B = z[k];
              B && (H = B(H, v)), k === "v" && H === 1 || k == "pr" && H === 1 || function(D) {
                return typeof D == "number" ? Number.isFinite(D) : D != null && D !== "" && D !== !1;
              }(H) && (/* @__PURE__ */ function(D) {
                return D === "ot" || D === "sf" || D === "st";
              }(k) && typeof H == "string" && (H = new aa(H)), M[k] = H);
            }), M;
          }(y, f), Object.assign({ whitespace: !1 }, f)) : "";
        }
        const lr = "CMCD-Object", kt = "CMCD-Request", Kt = "CMCD-Session", we = "CMCD-Status", Oe = { [lr]: ["br", "d", "ot", "tb"], [kt]: ["bl", "dl", "mtp", "nor", "nrr", "su"], [Kt]: ["cid", "pr", "sf", "sid", "st", "v"], [we]: ["bs", "rtp"] }, yn = "segment";
        function Hn() {
          let y, f, E, v, M, x, z, O, k, H, B, D, N, Y, J, it, lt = this.context, at = (0, It.A)(lt).getInstance(), st = (0, Q.A)(lt).getInstance(), ht = (0, ae.A)(lt).getInstance();
          function At() {
            v = { pr: 1, nor: null, st: null, sf: null, sid: `${ai.A.generateUuid()}`, cid: null }, N = {}, D = {}, Y = {}, B = void 0, J = void 0, it = !1, K();
          }
          function Z() {
            K();
          }
          function F() {
            J || (J = Date.now());
          }
          function G() {
            J && !v.msd && (v.msd = Date.now() - J);
          }
          function K() {
            if (!z) return;
            const V = z.getStreamController();
            if (!V || typeof V.getActiveStream != "function") return;
            const mt = V.getActiveStream();
            mt && (H = mt.getStreamProcessors());
          }
          function ft(V) {
            try {
              const mt = _t(), Mt = mt.version ? mt.keys : st.get().streaming.cmcd.enabledKeys;
              return Object.keys(V).filter((Lt) => Mt.includes(Lt)).reduce((Lt, Bt) => (Lt[Bt] = V[Bt], Lt), {});
            } catch {
              return V;
            }
          }
          function bt() {
            const V = _t();
            return function(mt) {
              if (Object.keys(mt).length) {
                if (parseInt(mt.version) !== 1) return E.error("version parameter must be defined in 1."), !1;
                if (!mt.keys) return E.error("keys parameter must be defined."), !1;
              }
              const Mt = mt.version, Lt = st.get().streaming.cmcd && st.get().streaming.cmcd.enabled;
              return Mt || Lt;
            }(V) && function(mt) {
              let Mt = st.get().streaming.cmcd.includeInRequests;
              mt.version && (Mt = mt.includeInRequests ?? [yn]);
              const Lt = q.A.CMCD_AVAILABLE_REQUESTS, Bt = Mt.filter((Qt) => !Lt.includes(Qt));
              return Bt.length === Mt.length ? (E.error("None of the request types are supported."), !1) : (Bt.map((Qt) => {
                E.warn(`request type ${Qt} is not supported.`);
              }), !0);
            }(V) && function(mt) {
              const Mt = q.A.CMCD_AVAILABLE_KEYS, Lt = q.A.CMCD_V2_AVAILABLE_KEYS, Bt = mt.version ? mt.keys : st.get().streaming.cmcd.enabledKeys, Qt = st.get().streaming.cmcd.version, Zt = Bt.filter((fe) => !(Mt.includes(fe) || Qt === 2 && Lt.includes(fe)));
              return Zt.length === Bt.length && Bt.length > 0 ? (E.error(`None of the keys are implemented for CMCD version ${Qt}.`), !1) : (Zt.map((fe) => {
                E.warn(`key parameter ${fe} is not implemented for CMCD version ${Qt}.`);
              }), !0);
            }(V);
          }
          function _t() {
            let V = {};
            if (O) {
              const mt = O.getServiceDescriptionSettings();
              st.get().streaming.cmcd.applyParametersFromMpd && mt.clientDataReporting && mt.clientDataReporting.cmcdParameters && (V = mt.clientDataReporting.cmcdParameters);
            }
            return V;
          }
          function vt(V) {
            try {
              let Mt = null;
              if (V.type, (mt = V.mediaType) !== q.A.VIDEO && mt !== q.A.AUDIO && mt !== q.A.MESH || B && B != q.A.AUDIO || (B = mt), function(Lt) {
                const Bt = _t();
                let Qt = st.get().streaming.cmcd.includeInRequests;
                Bt.version && (Qt = Bt.includeInRequests ? Bt.includeInRequests : [yn]);
                const Zt = { [Ct.G.INIT_SEGMENT_TYPE]: "segment", [Ct.G.MEDIA_SEGMENT_TYPE]: "segment", [Ct.G.XLINK_EXPANSION_TYPE]: "xlink", [Ct.G.MPD_TYPE]: "mpd", [Ct.G.CONTENT_STEERING_TYPE]: "steering", [Ct.G.OTHER_TYPE]: "other" };
                return Qt.some((fe) => Zt[Lt] === fe);
              }(V.type)) {
                if (V.type === Ct.G.MPD_TYPE) return function() {
                  const Lt = W();
                  return Lt.ot = Fi.MANIFEST, Lt;
                }();
                if (V.type === Ct.G.MEDIA_SEGMENT_TYPE) return Ot(V.mediaType), Pt(V, V.mediaType);
                if (V.type === Ct.G.INIT_SEGMENT_TYPE) return function() {
                  const Lt = W();
                  return Lt.ot = Fi.INIT, Lt.su = !0, Lt;
                }();
                if (V.type === Ct.G.OTHER_TYPE || V.type === Ct.G.XLINK_EXPANSION_TYPE) return function() {
                  const Lt = W();
                  return Lt.ot = Fi.OTHER, Lt;
                }();
                if (V.type === Ct.G.LICENSE) return function() {
                  const Lt = W();
                  return Lt.ot = Fi.KEY, Lt;
                }();
                if (V.type === Ct.G.CONTENT_STEERING_TYPE) return function(Lt) {
                  const Bt = B ? Pt(Lt, B) : W();
                  return Bt.ot = Fi.OTHER, Bt;
                }(V);
              }
              return Mt;
            } catch {
              return null;
            }
            var mt;
          }
          function Pt(V, mt) {
            var Qe;
            Ot(mt);
            const Mt = W(), Lt = function(hn) {
              try {
                return parseInt(hn.bandwidth / 1e3);
              } catch {
                return null;
              }
            }(V), Bt = function(hn) {
              try {
                return isNaN(hn.duration) ? NaN : Math.round(1e3 * hn.duration);
              } catch {
                return null;
              }
            }(V), Qt = function(hn) {
              try {
                return 100 * parseInt(k.getSafeAverageThroughput(hn) / 100);
              } catch {
                return null;
              }
            }(mt), Zt = function(hn) {
              try {
                const Sn = v.pr, jn = x.getCurrentBufferLevel(hn);
                return isNaN(Sn) || isNaN(jn) ? null : 100 * parseInt(jn / Sn * 10);
              } catch {
                return null;
              }
            }(mt), fe = tt(mt), Ue = function(hn) {
              try {
                const Sn = M.getPossibleVoRepresentationsFilteredBySettings(hn).map((jn) => jn.bitrateInKbit);
                return Math.max(...Sn);
              } catch {
                return null;
              }
            }((Qe = V.representation) == null ? void 0 : Qe.mediaInfo), Ye = v.pr, on = function(hn) {
              if (H && H.length !== 0) {
                for (let Sn of H) if (Sn.getType() === hn) return Sn.probeNextRequest();
              }
            }(mt);
            let cn;
            mt === q.A.VIDEO && (cn = Fi.VIDEO), mt === q.A.AUDIO && (cn = Fi.AUDIO), mt === q.A.MESH && (cn = Fi.OTHER), mt === q.A.TEXT && (cn = V.representation.mediaInfo.mimeType === "application/mp4" ? Fi.TIMED_TEXT : Fi.CAPTION);
            let Nn = st.get().streaming.cmcd.rtp;
            return Nn || (Nn = function(hn) {
              try {
                let Sn = z.getPlaybackRate();
                Sn || (Sn = 1);
                let { bandwidth: jn, mediaType: Ln, representation: Rn, duration: $t } = hn;
                if (!Rn.mediaInfo) return NaN;
                let be = tt(Ln);
                be === 0 && (be = 500);
                let ge = jn * $t / 1e3 / (be / Sn / 1e3), Te = st.get().streaming.cmcd.rtpSafetyFactor && !isNaN(st.get().streaming.cmcd.rtpSafetyFactor) ? st.get().streaming.cmcd.rtpSafetyFactor : 5;
                return 100 * (parseInt(ge * Te / 100) + 1);
              } catch {
                return NaN;
              }
            }(V)), isNaN(Nn) || (Mt.rtp = Nn), on && (V.url !== on.url ? Mt.nor = encodeURIComponent(ai.A.getRelativeUrl(V.url, on.url)) : on.range && (Mt.nrr = on.range)), Lt && (Mt.br = Lt), cn && (Mt.ot = cn), isNaN(Bt) || (Mt.d = Bt), isNaN(Qt) || (Mt.mtp = Qt), isNaN(Zt) || (Mt.dl = Zt), isNaN(fe) || (Mt.bl = fe), isNaN(Ue) || (Mt.tb = Ue), isNaN(Ye) || Ye === 1 || (Mt.pr = Ye), N[mt] && (Mt.bs = !0, N[mt] = !1), !D[mt] && Y[mt] || (Mt.su = !0, D[mt] = !1, Y[mt] = !0), Mt;
          }
          function Ot(V) {
            Y.hasOwnProperty(V) || (Y[V] = !1), D.hasOwnProperty(V) || (D[V] = !1), N.hasOwnProperty(V) || (N[V] = !1);
          }
          function W() {
            const V = _t(), mt = {};
            let Mt = st.get().streaming.cmcd.cid ? st.get().streaming.cmcd.cid : v.cid;
            if (Mt = V.contentID ? V.contentID : Mt, mt.v = st.get().streaming.cmcd.version ?? 1, mt.sid = st.get().streaming.cmcd.sid ? st.get().streaming.cmcd.sid : v.sid, mt.sid = V.sessionID ? V.sessionID : mt.sid, mt.sid = `${mt.sid}`, Mt && (mt.cid = `${Mt}`), isNaN(v.pr) || v.pr === 1 || v.pr === null || (mt.pr = v.pr), v.st && (mt.st = v.st), v.sf && (mt.sf = v.sf), mt.v === 2) {
              let Lt = 1e3 * z.getCurrentLiveLatency();
              isNaN(Lt) || (mt.ltc = Lt);
              const Bt = v.msd;
              it || isNaN(Bt) || (mt.msd = Bt, it = !0);
            }
            return mt;
          }
          function tt(V) {
            try {
              const mt = x.getCurrentBufferLevel(V);
              return isNaN(mt) ? null : 100 * parseInt(10 * mt);
            } catch {
              return null;
            }
          }
          function Tt(V) {
            try {
              v.pr = V.playbackRate;
            } catch {
            }
          }
          function yt(V) {
            try {
              const mt = y.getIsDynamic(V.data) ? Gr : ra, Mt = V.protocol && V.protocol === "MSS" ? sr : ss;
              v.st = `${mt}`, v.sf = `${Mt}`;
            } catch {
            }
          }
          function nt(V) {
            try {
              V.state && V.mediaType && V.state === St.A.BUFFER_EMPTY && (N[V.mediaType] || (N[V.mediaType] = !0), D[V.mediaType] || (D[V.mediaType] = !0));
            } catch {
            }
          }
          function ct() {
            for (let V in N) N.hasOwnProperty(V) && (N[V] = !0);
            for (let V in D) D.hasOwnProperty(V) && (D[V] = !0);
          }
          return f = { getCmcdData: vt, getQueryParameter: function(V) {
            try {
              if (bt()) {
                const mt = vt(V), Mt = ys(ft(mt));
                return at.trigger(Ri.A.CMCD_DATA_GENERATED, { url: V.url, mediaType: V.mediaType, cmcdData: mt, cmcdString: Mt }), { key: "CMCD", value: Mt };
              }
              return null;
            } catch {
              return null;
            }
          }, getHeaderParameters: function(V) {
            try {
              if (bt()) {
                const mt = vt(V), Mt = function(Lt) {
                  let Bt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                  const Qt = {};
                  if (!Lt) return Qt;
                  const Zt = Object.entries(Lt), fe = Object.entries(Oe).concat(Object.entries((Bt == null ? void 0 : Bt.customHeaderMap) || {})), Ue = Zt.reduce((Ye, on) => {
                    var cn, Nn;
                    const [Qe, hn] = on, Sn = ((cn = fe.find((jn) => jn[1].includes(Qe))) === null || cn === void 0 ? void 0 : cn[0]) || kt;
                    return (Nn = Ye[Sn]) !== null && Nn !== void 0 || (Ye[Sn] = {}), Ye[Sn][Qe] = hn, Ye;
                  }, {});
                  return Object.entries(Ue).reduce((Ye, on) => {
                    let [cn, Nn] = on;
                    return Ye[cn] = ys(Nn, Bt), Ye;
                  }, Qt);
                }(ft(mt), st.get().streaming.cmcd.version === 1 ? {} : { customHeaderMap: { [kt]: ["ltc"], [Kt]: ["msd"] } });
                return at.trigger(Ri.A.CMCD_DATA_GENERATED, { url: V.url, mediaType: V.mediaType, cmcdData: mt, headers: Mt }), Mt;
              }
              return null;
            } catch {
              return null;
            }
          }, getCmcdParametersFromManifest: _t, setConfig: function(V) {
            V && (V.abrController && (M = V.abrController), V.dashMetrics && (x = V.dashMetrics), V.throughputController && (k = V.throughputController), V.playbackController && (z = V.playbackController), V.serviceDescriptionController && (O = V.serviceDescriptionController));
          }, reset: function() {
            at.off(St.A.PLAYBACK_RATE_CHANGED, Tt, this), at.off(St.A.MANIFEST_LOADED, yt, this), at.off(St.A.BUFFER_LEVEL_STATE_CHANGED, nt, f), at.off(St.A.PLAYBACK_SEEKED, ct, f), at.off(St.A.PLAYBACK_STARTED, F, f), at.off(St.A.PLAYBACK_PLAYING, G, f), At();
          }, initialize: function(V) {
            at.on(St.A.PLAYBACK_RATE_CHANGED, Tt, f), at.on(St.A.MANIFEST_LOADED, yt, f), at.on(St.A.BUFFER_LEVEL_STATE_CHANGED, nt, f), at.on(St.A.PLAYBACK_SEEKED, ct, f), at.on(St.A.PERIOD_SWITCH_COMPLETED, Z, f), V ? at.on(St.A.MANIFEST_LOADING_STARTED, F, f) : at.on(St.A.PLAYBACK_STARTED, F, f), at.on(St.A.PLAYBACK_PLAYING, G, f);
          }, isCmcdEnabled: bt }, y = Zi(lt).getInstance(), E = ht.getLogger(f), At(), f;
        }
        Hn.__dashjs_factory_name = "CmcdModel";
        var Pn = Dt.A.getSingletonFactory(Hn);
        const Vn = "CMSD-Dynamic", ri = "CMSD-Static", pi = qi;
        function Bn(y, f, E) {
          return Fa("parse", y, f, E);
        }
        const Ti = "List";
        function ei(y, f) {
          return { value: y, src: f };
        }
        const Si = "Inner List", Pi = "Date", ua = `${hi} or ${vi}`;
        function wr(y) {
          let f, E = 1, v = "";
          const M = Bn(y, ua);
          if (y[0] === "-" && (E = -1, y = y.substring(1)), y.length <= 0) throw M;
          const x = /^(\d+)?/g, z = x.exec(y);
          if (z[0].length === 0) throw M;
          if (v += z[1], (y = y.substring(x.lastIndex))[0] === ".") {
            if (v.length > 12) throw M;
            const O = /^(\.\d+)?/g, k = O.exec(y);
            if (y = y.substring(O.lastIndex), k[0].length === 0 || k[1].length > 4 || (v += k[1], v.length > 16)) throw M;
            f = parseFloat(v) * E;
          } else {
            if (v.length > 15) throw M;
            if (f = parseInt(v) * E, hr(f)) throw Bn(v, ua);
          }
          return ei(f, y);
        }
        function ja(y, f) {
          const E = y[0];
          if (E === '"') return function(v) {
            let M = "", x = 0;
            if (v[x] !== '"') throw Bn(v, Rr);
            for (x++; v.length > x; ) {
              if (v[x] === "\\") {
                if (v.length <= x + 1 || (x++, v[x] !== '"' && v[x] !== "\\")) throw Bn(v, Rr);
                M += v[x];
              } else {
                if (v[x] === '"') return ei(M, v.substring(++x));
                if (Qi.test(v[x])) throw Bn(v, Rr);
                M += v[x];
              }
              x++;
            }
            throw Bn(v, Rr);
          }(y);
          if (/^[-0-9]/.test(E)) return wr(y);
          if (E === "?") return function(v) {
            let M = 0;
            if (v[M] !== "?") throw Bn(v, Ir);
            if (M++, v[M] === "1") return ei(!0, v.substring(++M));
            if (v[M] === "0") return ei(!1, v.substring(++M));
            throw Bn(v, Ir);
          }(y);
          if (E === ":") return function(v) {
            if (v[0] !== ":" || (v = v.substring(1)).includes(":") === !1) throw Bn(v, or);
            const M = /(^.*?)(:)/g, x = M.exec(v)[1];
            return v = v.substring(M.lastIndex), ei(new Uint8Array([...atob(x)].map((z) => z.charCodeAt(0))), v);
          }(y);
          if (/^[a-zA-Z*]/.test(E)) return function(v, M) {
            if (/^[a-zA-Z*]$/.test(v[0]) === !1) throw Bn(v, Sa);
            const x = /^([!#$%&'*+\-.^_`|~\w:/]+)/g, z = x.exec(v)[1];
            return v = v.substring(x.lastIndex), ei(Symbol.for(z), v);
          }(y);
          if (E === "@") return function(v) {
            let M = 0;
            if (v[M] !== "@") throw Bn(v, Pi);
            M++;
            const x = wr(v.substring(M));
            if (Number.isInteger(x.value) === !1) throw Bn(v, Pi);
            return ei(new Date(1e3 * x.value), x.src);
          }(y);
          throw Bn(y, Aa);
        }
        function os(y) {
          let f = 0;
          if (/^[a-z*]$/.test(y[f]) === !1) throw Bn(y, Ua);
          let E = "";
          for (; y.length > f; ) {
            if (/^[a-z0-9_\-.*]$/.test(y[f]) === !1) return ei(E, y.substring(f));
            E += y[f], f++;
          }
          return ei(E, y.substring(f));
        }
        function da(y, f) {
          let E;
          for (; y.length > 0 && y[0] === ";"; ) {
            const v = os(y = y.substring(1).trim()), M = v.value;
            let x = !0;
            if ((y = v.src)[0] === "=") {
              const z = ja(y = y.substring(1));
              x = z.value, y = z.src;
            }
            E == null && (E = {}), E[M] = x;
          }
          return ei(E, y);
        }
        function Ba(y, f) {
          const E = ja(y), v = da(y = E.src);
          return y = v.src, ei(new Vi(E.value, v.value), y);
        }
        function ca(y, f) {
          return y[0] === "(" ? function(E, v) {
            if (E[0] !== "(") throw Bn(E, Si);
            E = E.substring(1);
            const M = [];
            for (; E.length > 0; ) {
              if ((E = E.trim())[0] === ")") {
                const z = da(E = E.substring(1));
                return ei(new Vi(M, z.value), z.src);
              }
              const x = Ba(E);
              if (M.push(x.value), (E = x.src)[0] !== " " && E[0] !== ")") throw Bn(E, Si);
            }
            throw Bn(E, Si);
          }(y) : Ba(y);
        }
        const bs = ri.toLowerCase(), Fl = Vn.toLowerCase(), Io = ["mb", "st", "sf", "v"], to = "stream", ha = { video: pi.VIDEO, audio: pi.AUDIO, text: pi.TIMED_TEXT, stream: to };
        function eo() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x;
          function z() {
            M = {}, x = {};
          }
          function O(N) {
            N && Object.keys(N).forEach((Y) => {
              Io.includes(Y) || delete N[Y];
            });
          }
          function k(N) {
            try {
              return (Y = N) ? Object.entries(function(J, it) {
                try {
                  const { src: lt, value: at } = function(st, ht) {
                    const At = {};
                    for (; st.length > 0; ) {
                      let Z;
                      const F = os(st), G = F.value;
                      if ((st = F.src)[0] === "=") {
                        const K = ca(st.substring(1), ht);
                        Z = K.value, st = K.src;
                      } else {
                        const K = da(st, ht);
                        Z = new Vi(!0, K.value), st = K.src;
                      }
                      if (At[G] = Z, (st = st.trim()).length === 0) return ei(At, st);
                      if (st[0] !== "," || (st = st.substring(1).trim()).length === 0 || st[0] === ",") throw Bn(st, Dr);
                    }
                    return ei(At, st);
                  }(J.trim(), it);
                  if (lt !== "") throw Bn(lt, Dr);
                  return at;
                } catch (lt) {
                  throw Bn(J, Dr, lt);
                }
              }(Y)).reduce((J, it) => {
                let [lt, at] = it;
                const { value: st } = at;
                return J[lt] = typeof st == "symbol" ? Tr(st) : st, J;
              }, {}) : {};
            } catch (J) {
              v.error("Failed to parse CMSD-Static response header value:", J);
            }
            var Y;
          }
          function H(N) {
            try {
              const J = (Y = N) ? function(lt, at) {
                try {
                  const { src: st, value: ht } = function(At, Z) {
                    const F = [];
                    for (; At.length > 0; ) {
                      const G = ca(At, Z);
                      if (F.push(G.value), (At = G.src.trim()).length === 0) return ei(F, At);
                      if (At[0] !== "," || (At = At.substring(1).trim()).length === 0 || At[0] === ",") throw Bn(At, Ti);
                    }
                    return ei(F, At);
                  }(lt.trim(), at);
                  if (st !== "") throw Bn(st, Ti);
                  return ht;
                } catch (st) {
                  throw Bn(lt, Ti, st);
                }
              }(Y) : [], it = J[J.length - 1];
              return (it == null ? void 0 : it.params) || {};
            } catch (J) {
              return v.error("Failed to parse CMSD-Dynamic response header value:", J), {};
            }
            var Y;
          }
          function B(N) {
            return ha[N] || pi.OTHER;
          }
          function D(N, Y, J) {
            const it = N === ri ? M : x, lt = it[Y] || {}, at = it[to] || {};
            return lt[J] || at[J];
          }
          return E = { setConfig: function() {
          }, initialize: function() {
          }, reset: function() {
            z();
          }, parseResponseHeaders: function(N, Y) {
            let J = null, it = null;
            for (const at in N) {
              const st = N[at];
              switch (at) {
                case bs:
                  J = k(st), f.trigger(et.A.CMSD_STATIC_HEADER, J);
                  break;
                case Fl:
                  it || (it = H(st));
              }
            }
            let lt = to;
            return J && J.ot ? lt = J.ot : Y && (lt = B(Y)), O(M[lt]), O(x[lt]), J && (M[lt] = Object.assign(M[lt] || {}, J)), it && (x[lt] = Object.assign(x[lt] || {}, it)), { static: J, dynamic: it };
          }, getMaxBitrate: function(N) {
            let Y = B(N);
            return D(Vn, Y, "mb") || -1;
          }, getEstimatedThroughput: function(N) {
            let Y = B(N);
            return D(Vn, Y, "etp") || null;
          }, getResponseDelay: function(N) {
            let Y = B(N);
            return D(Vn, Y, "rd") || null;
          }, getRoundTripTime: function(N) {
            let Y = B(N);
            return D(Vn, Y, "rtt") || null;
          } }, v = (0, ae.A)(y).getInstance().getLogger(E), z(), E;
        }
        eo.__dashjs_factory_name = "CmsdModel";
        var Ro = Dt.A.getSingletonFactory(eo), Co = b(1926);
        function mn() {
          let y, f;
          function E() {
            f = {};
          }
          return y = { reset: function() {
            E();
          }, processResponseHeaders: function(v) {
            if (!(v && v.headers && v.request && v.request.url)) return;
            const M = v.headers[q.A.COMMON_ACCESS_TOKEN_HEADER];
            if (M) {
              const x = ai.A.getHostFromUrl(v.request.url);
              x && (f[x] = M);
            }
          }, getCommonAccessTokenForUrl: function(v) {
            if (!v) return null;
            const M = ai.A.getHostFromUrl(v);
            return M ? f[M] ? f[M] : null : void 0;
          } }, E(), y;
        }
        mn.__dashjs_factory_name = "CommonAccessTokenController";
        var No = Dt.A.getSingletonFactory(mn);
        function gi() {
          let y, f;
          return y = { setConfig: function(E) {
            E && E.serviceDescriptionController && (f = E.serviceDescriptionController);
          }, isAdaptationsIncluded: function(E) {
            var M;
            const { adaptationSetsArray: v } = ((M = f == null ? void 0 : f.getServiceDescriptionSettings()) == null ? void 0 : M.clientDataReporting) ?? {};
            return !v || (v == null ? void 0 : v.length) === 0 || v.includes(E);
          }, isServiceLocationIncluded: function(E, v) {
            var x;
            if (E === Ct.G.CONTENT_STEERING_TYPE) return !0;
            const { serviceLocationsArray: M } = ((x = f == null ? void 0 : f.getServiceDescriptionSettings()) == null ? void 0 : x.clientDataReporting) ?? {};
            return !M || (M == null ? void 0 : M.length) === 0 || M.includes(v);
          } }, y;
        }
        gi.__dashjs_factory_name = "ClientDataReportingController";
        var ls = Dt.A.getSingletonFactory(gi);
        function no() {
          let y, f, E;
          const v = this.context;
          function M(x, z, O, k, H) {
            var D;
            const B = function(N, Y) {
              let J = [];
              return J = Y === I.A.PERIOD ? N[I.A.SUPPLEMENTAL_PROPERTY] || [] : [...N[I.A.ESSENTIAL_PROPERTY] || [], ...N[I.A.SUPPLEMENTAL_PROPERTY] || []], J.find((it) => it.schemeIdUri === q.A.URL_QUERY_INFO_SCHEME && it.UrlQueryInfo || it.schemeIdUri === q.A.EXT_URL_QUERY_INFO_SCHEME && it.ExtUrlQueryInfo);
            }(z, H);
            (function(N, Y, J, it) {
              J.initialQueryString = "";
              let lt = "";
              const at = (N == null ? void 0 : N.ExtUrlQueryInfo) || (N == null ? void 0 : N.UrlQueryInfo);
              lt = at && at.queryString ? Y && Y.length > 0 ? Y + "&" + at.queryString : at.queryString : Y, (at == null ? void 0 : at.useMPDUrlQuery) === "true" && it && (lt = lt ? lt + "&" + it : it), J.initialQueryString = lt;
            })(B, k.initialQueryString, x, O), function(N, Y, J) {
              var lt, at;
              if (!N) return void (Y.finalQueryString = J);
              const it = ((lt = N == null ? void 0 : N.ExtUrlQueryInfo) == null ? void 0 : lt.queryTemplate) || ((at = N == null ? void 0 : N.UrlQueryInfo) == null ? void 0 : at.queryTemplate) || "";
              Y.finalQueryString = it === I.A.QUERY_PART ? Y == null ? void 0 : Y.initialQueryString : "";
            }(B, x, k.finalQueryString), x.sameOriginOnly = (D = B == null ? void 0 : B.ExtUrlQueryInfo) == null ? void 0 : D.sameOriginOnly, x.queryParams = ai.A.parseQueryParams(x == null ? void 0 : x.finalQueryString), x.includeInRequests = function(N, Y) {
              var J;
              return N ? (J = N.ExtUrlQueryInfo) != null && J.includeInRequests ? N.ExtUrlQueryInfo.includeInRequests.split(" ") : [I.A.SEGMENT_TYPE] : Y;
            }(B, k.includeInRequests);
          }
          return f = (0, ae.A)(v).getInstance().getLogger(y), y = { getFinalQueryString: function(x) {
            try {
              if (!E) return null;
              if (x.type === Ct.G.MEDIA_SEGMENT_TYPE || x.type === Ct.G.INIT_SEGMENT_TYPE) {
                const z = x.representation;
                if (!z) return null;
                const O = z.adaptation, k = O.period, H = E.period[k.index].adaptation[O.index].representation[z.index], B = new URL(x.url), D = !H.sameOriginOnly || E.origin === B.origin;
                if (H.includeInRequests.includes(I.A.SEGMENT_TYPE) && D) return H.queryParams;
              } else if (x.type === Ct.G.MPD_TYPE) {
                if ([I.A.MPD_TYPE, I.A.MPD_PATCH_TYPE].some((z) => E.includeInRequests.includes(z))) return E.queryParams;
              } else if (x.type === Ct.G.CONTENT_STEERING_TYPE && E.includeInRequests.includes(I.A.STEERING_TYPE)) return E.queryParams;
            } catch (z) {
              return f.error(z), null;
            }
          }, createFinalQueryStrings: function(x) {
            E = { origin: new URL(x.url).origin, period: [] };
            const z = x.url.split("?")[1];
            M(E, x, z, { initialQueryString: "", includeInRequests: [] }, I.A.MPD), x.Period.forEach((O) => {
              const k = { adaptation: [] };
              M(k, O, z, E, I.A.PERIOD), O.AdaptationSet.forEach((H) => {
                const B = { representation: [] };
                M(B, H, z, k, I.A.ADAPTATION_SET), H.Representation.forEach((D) => {
                  const N = {};
                  M(N, D, z, B, I.A.REPRESENTATION), B.representation.push(N);
                }), k.adaptation.push(B);
              }), E.period.push(k);
            });
          } }, y;
        }
        no.__dashjs_factory_name = "ExtUrlQueryInfoController";
        var Es = Dt.A.getSingletonFactory(no), Wr = class {
          constructor(y) {
            this.url = y.url, this.method = y.method, this.responseType = y.responseType !== void 0 ? y.responseType : null, this.headers = y.headers !== void 0 ? y.headers : {}, this.credentials = y.credentials !== void 0 ? y.credentials : null, this.mode = y.mode !== void 0 ? y.mode : null, this.timeout = y.timeout !== void 0 ? y.timeout : 0, this.cmcd = y.cmcd !== void 0 ? y.cmcd : null, this.customData = y.customData !== void 0 ? y.customData : null;
          }
        }, Po = class {
          constructor(y) {
            this.request = y.request, this.url = y.url !== void 0 ? y.url : null, this.redirected = y.redirected !== void 0 && y.redirected, this.status = y.status !== void 0 ? y.status : null, this.statusText = y.statusText !== void 0 ? y.statusText : "", this.type = y.type !== void 0 ? y.type : "", this.headers = y.headers !== void 0 ? y.headers : {}, this.data = y.data !== void 0 ? y.data : null, this.resourceTiming = y.resourceTiming !== void 0 ? y.resourceTiming : null;
          }
        };
        function io(y) {
          y = y || {};
          const f = this.context, E = y.errHandler, v = y.dashMetrics, M = y.mediaPlayerModel, x = y.boxParser, z = y.errors, O = y.requestTimeout || 0, k = (0, It.A)(f).getInstance(), H = (0, Q.A)(f).getInstance();
          let B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G;
          function K(ft, bt) {
            const _t = function() {
              W();
            }, vt = function(Qe) {
              const hn = /* @__PURE__ */ new Date();
              mt && (mt = !1, (!Qe.lengthComputable || Qe.lengthComputable && Qe.total !== Qe.loaded) && (ct.firstByteDate = hn, fe.resourceTiming.responseStart = hn.getTime())), Qe.lengthComputable && (ct.bytesLoaded = fe.length = Qe.loaded, ct.bytesTotal = fe.resourceTiming.encodedBodySize = Qe.total, fe.length = Qe.total, fe.resourceTiming.encodedBodySize = Qe.loaded), Qe.noTrace || (V.push({ s: Lt, d: Qe.time ? Qe.time : hn.getTime() - Lt.getTime(), b: [Qe.loaded ? Qe.loaded - Bt : 0], t: Qe.throughput }), ct.traces = V, Lt = hn, Bt = Qe.loaded), Qt && (clearTimeout(Qt), Qt = null), H.get().streaming.fragmentRequestProgressTimeout > 0 && (Qt = setTimeout(function() {
                G.warn("Abort request " + Zt.url + " due to progress timeout"), Ye.abort(Zt), _t();
              }, H.get().streaming.fragmentRequestProgressTimeout)), ft.progress && Qe && ft.progress(Qe);
            }, Pt = function() {
              W(!0);
            }, Ot = function(Qe) {
              let hn;
              if (Qe.lengthComputable) {
                let Sn = Qe.loaded / Qe.total * 100;
                hn = "Request timeout: loaded: " + Qe.loaded + ", out of: " + Qe.total + " : " + Sn.toFixed(3) + "% Completed";
              } else hn = "Request timeout: non-computable download size";
              G.warn(hn);
            }, W = function() {
              let Qe = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
              D.indexOf(Zt) !== -1 && D.splice(D.indexOf(Zt), 1), Qt && (clearTimeout(Qt), Qt = null), At.processResponseHeaders(fe), tt(), Tt(), function(hn) {
                const Sn = ht.getResponseInterceptors();
                return Sn ? Sn.reduce((jn, Ln) => jn.then((Rn) => Ln(Rn)), Promise.resolve(hn)) : Promise.resolve(hn);
              }(fe).then((hn) => {
                if (fe = hn, function(Sn, jn, Ln) {
                  const Rn = Sn.customData.request, $t = H.get().streaming.cmsd && H.get().streaming.cmsd.enabled ? lt.parseResponseHeaders(jn.headers, Rn.mediaType) : null;
                  v.addHttpRequest(Rn, jn.url, jn.status, jn.headers, Ln, $t);
                }(Zt, fe, V), Qe) ft.abort && ft.abort(ct);
                else if (ct.type === Ct.G.MPD_TYPE && (v.addManifestUpdate(ct), k.trigger(et.A.MANIFEST_LOADING_FINISHED, { requestObject: ct })), fe.status >= 200 && fe.status <= 299 && fe.data) ft.success && ft.success(fe.data, fe.statusText, fe.url), ft.complete && ft.complete(ct, fe.statusText);
                else {
                  try {
                    fe.status === 404 && H.get().streaming.utcSynchronization.enableBackgroundSyncAfterSegmentDownloadError && ct.type === Ct.G.MEDIA_SEGMENT_TYPE && M.getRetryAttemptsForType(Ct.G.MEDIA_SEGMENT_TYPE) === bt && k.trigger(et.A.ATTEMPT_BACKGROUND_SYNC);
                  } catch {
                  }
                  nt();
                }
              });
            }, tt = function() {
              ct.startDate = Mt, ct.endDate = /* @__PURE__ */ new Date(), ct.firstByteDate = ct.firstByteDate || Mt;
            }, Tt = function() {
              fe.resourceTiming.responseEnd = Date.now(), function(Qe, hn) {
                if (!H.get().streaming.abr.throughput.useResourceTimingApi || typeof performance > "u" || Qe.range) return;
                const Sn = performance.getEntriesByType("resource");
                if (Sn === void 0 || Sn.length <= 0) return;
                let jn = 0, Ln = null;
                for (; jn < Sn.length; ) {
                  if (Sn[jn].name === Qe.url) {
                    Ln = Sn[jn];
                    break;
                  }
                  jn += 1;
                }
                (function(Rn) {
                  return Rn && !isNaN(Rn.responseStart) && Rn.responseStart > 0 && !isNaN(Rn.responseEnd) && Rn.responseEnd > 0 && !isNaN(Rn.transferSize) && Rn.transferSize > 0;
                })(Ln) && (Qe.customData.request.resourceTimingValues = Ln, hn.resourceTiming.startTime = Ln.startTime, hn.resourceTiming.encodedBodySize = Ln.encodedBodySize, hn.resourceTiming.responseStart = Ln.startTime, hn.resourceTiming.responseEnd = Ln.responseEnd, hn.resourceTiming.duration = Ln.duration);
              }(Zt, fe);
            }, yt = function(Qe, hn, Sn) {
              return new Promise((jn) => {
                (function(Ln) {
                  const Rn = ht.getRequestInterceptors();
                  return Rn ? Rn.reduce(($t, be) => $t.then((ge) => be(ge)), Promise.resolve(Ln)) : Promise.resolve(Ln);
                })(hn).then((Ln) => {
                  (hn = Ln).customData.onloadend = _t, hn.customData.onprogress = vt, hn.customData.onabort = Pt, hn.customData.ontimeout = Ot, Sn.resourceTiming.startTime = Date.now(), Qe.load(hn, Sn), jn();
                });
              });
            }, nt = function() {
              if (bt > 0) {
                bt--;
                let Qe = { config: ft };
                Y.push(Qe), Qe.timeout = setTimeout(function() {
                  Y.indexOf(Qe) !== -1 && (Y.splice(Y.indexOf(Qe), 1), K(ft, bt));
                }, M.getRetryIntervalsForType(ct.type));
              } else {
                if (ct.type === Ct.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE) return;
                E.error(new Yt.A(J[ct.type], ct.url + " is not available", { request: ct, response: fe })), ft.error && ft.error(ct, "error", fe.statusText, fe), ft.complete && ft.complete(ct, fe.statusText);
              }
            }, ct = ft.request, V = [];
            let mt, Mt, Lt, Bt, Qt, Zt, fe;
            if (ct.bytesLoaded = NaN, ct.bytesTotal = NaN, ct.firstByteDate = null, ct.traces = [], mt = !0, Mt = /* @__PURE__ */ new Date(), Lt = Mt, Bt = 0, Qt = null, !v || !E) throw new Error("config object is not correct or missing");
            const Ue = function(Qe) {
              let hn, Sn;
              return Qe.hasOwnProperty("availabilityTimeComplete") && Qe.availabilityTimeComplete === !1 && window.fetch && Qe.responseType === "arraybuffer" && Qe.type === Ct.G.MEDIA_SEGMENT_TYPE ? (st || (st = dr(f).create(), st.setConfig({ dashMetrics: v, boxParser: x })), hn = st, Sn = q.A.FILE_LOADER_TYPES.FETCH) : (at || (at = Oi(f).create()), hn = at, Sn = q.A.FILE_LOADER_TYPES.XHR), { loader: hn, fileLoaderType: Sn };
            }(ct), Ye = Ue.loader;
            var on;
            ct.fileLoaderType = Ue.fileLoaderType, ct.headers = {}, function(Qe) {
              var jn, Ln;
              const hn = Qe == null ? void 0 : Qe.serviceLocation, Sn = (Ln = (jn = Qe == null ? void 0 : Qe.mediaInfo) == null ? void 0 : jn.id) == null ? void 0 : Ln.toString();
              if (Z.isServiceLocationIncluded(Qe.type, hn) && Z.isAdaptationsIncluded(Sn) && it.isCmcdEnabled()) {
                const Rn = it.getCmcdParametersFromManifest(), $t = Rn.mode ? Rn.mode : H.get().streaming.cmcd.mode;
                if ($t === q.A.CMCD_MODE_QUERY) {
                  Qe.url = ai.A.removeQueryParameterFromUrl(Qe.url, q.A.CMCD_QUERY_KEY);
                  const be = function(ge) {
                    try {
                      const Te = [], ee = it.getQueryParameter(ge);
                      return ee && Te.push(ee), Te;
                    } catch {
                      return [];
                    }
                  }(Qe);
                  Qe.url = ai.A.addAdditionalQueryParameterToUrl(Qe.url, be);
                } else $t === q.A.CMCD_MODE_HEADER && (Qe.headers = Object.assign(Qe.headers, it.getHeaderParameters(Qe)));
              }
            }(on = ct), function(Qe) {
              let hn = F.getFinalQueryString(Qe);
              hn && (Qe.url = ai.A.addAdditionalQueryParameterToUrl(Qe.url, hn));
            }(on), function(Qe) {
              if (Qe.queryParams) {
                const hn = Object.keys(Qe.queryParams).map((Sn) => ({ key: Sn, value: Qe.queryParams[Sn] }));
                Qe.url = ai.A.addAdditionalQueryParameterToUrl(Qe.url, hn);
              }
            }(on), function(Qe) {
              const hn = At.getCommonAccessTokenForUrl(Qe.url);
              hn && (Qe.headers[q.A.COMMON_ACCESS_TOKEN_HEADER] = hn);
            }(on), ct.range && (ct.headers.Range = "bytes=" + ct.range);
            const cn = ht.getXHRWithCredentialsForType(ct.type);
            Zt = new Wr({ url: ct.url, method: Ct.G.GET, responseType: ct.responseType, headers: ct.headers, credentials: cn ? "include" : "omit", timeout: O, cmcd: it.getCmcdData(ct), customData: { request: ct } }), fe = new Po({ request: Zt, resourceTiming: { startTime: Date.now(), encodedBodySize: 0 }, status: 0 });
            let Nn = (/* @__PURE__ */ new Date()).getTime();
            if (isNaN(ct.delayLoadingTime) || Nn >= ct.delayLoadingTime) return D.push(Zt), yt(Ye, Zt, fe);
            {
              let Qe = { httpRequest: Zt, httpResponse: fe };
              return N.push(Qe), Qe.delayTimeout = setTimeout(function() {
                if (N.indexOf(Qe) !== -1) {
                  N.splice(N.indexOf(Qe), 1);
                  try {
                    Mt = /* @__PURE__ */ new Date(), Lt = Mt, D.push(Qe.httpRequest), yt(Ye, Qe.httpRequest, Qe.httpResponse);
                  } catch {
                    Qe.httpRequest.onloadend();
                  }
                }
              }, ct.delayLoadingTime - Nn), Promise.resolve();
            }
          }
          return B = { abort: function() {
            Y.forEach((ft) => {
              clearTimeout(ft.timeout), ft.config.request && ft.config.abort && ft.config.abort(ft.config.request);
            }), Y = [], N.forEach((ft) => clearTimeout(ft.delayTimeout)), N = [], D.forEach((ft) => {
              const bt = ft.customData;
              bt && (bt.request && bt.request.type === Ct.G.MSS_FRAGMENT_INFO_SEGMENT_TYPE || (bt.onloadend = bt.onprogress = void 0, bt.abort && bt.abort()));
            }), D = [];
          }, load: function(ft) {
            return ft.request ? K(ft, M.getRetryAttemptsForType(ft.request.type)) : (ft.error && ft.error(ft.request, "error"), Promise.resolve());
          }, reset: function() {
            D = [], N = [], Y = [], at && at.reset(), st && st.reset(), at = null, st = null;
          }, resetInitialSettings: function() {
            at && at.resetInitialSettings();
          }, setConfig: function(ft) {
            ft && (ft.commonAccessTokenController && (At = ft.commonAccessTokenController), ft.extUrlQueryInfoController && (F = ft.extUrlQueryInfoController));
          } }, G = (0, ae.A)(f).getInstance().getLogger(B), D = [], N = [], Y = [], it = Pn(f).getInstance(), Z = ls(f).getInstance(), lt = Ro(f).getInstance(), ht = (0, Co.A)(f).getInstance(), At = No(f).getInstance(), F = Es(f).getInstance(), J = { [Ct.G.MPD_TYPE]: z.DOWNLOAD_ERROR_ID_MANIFEST_CODE, [Ct.G.XLINK_EXPANSION_TYPE]: z.DOWNLOAD_ERROR_ID_XLINK_CODE, [Ct.G.INIT_SEGMENT_TYPE]: z.DOWNLOAD_ERROR_ID_INITIALIZATION_CODE, [Ct.G.MEDIA_SEGMENT_TYPE]: z.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ct.G.INDEX_SEGMENT_TYPE]: z.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ct.G.BITSTREAM_SWITCHING_SEGMENT_TYPE]: z.DOWNLOAD_ERROR_ID_CONTENT_CODE, [Ct.G.OTHER_TYPE]: z.DOWNLOAD_ERROR_ID_CONTENT_CODE }, B;
        }
        io.__dashjs_factory_name = "HTTPLoader";
        var zo = Dt.A.getClassFactory(io);
        function vs() {
          let y, f;
          function E() {
            f = {};
          }
          function v() {
            E();
          }
          return v(), y = { getLoader: function(M) {
            for (var x in f) if (f.hasOwnProperty(x) && M.startsWith(x)) return f[x];
            return zo;
          }, registerLoader: function(M, x) {
            f[M] = x;
          }, unregisterLoader: function(M) {
            f[M] && delete f[M];
          }, unregisterAllLoader: E, reset: v }, y;
        }
        vs.__dashjs_factory_name = "SchemeLoaderFactory";
        var Nr = Dt.A.getSingletonFactory(vs);
        function ro(y) {
          y = y || {};
          const f = this.context;
          let E, v, M;
          return v = Nr(f).getInstance(), E = { abort: function() {
            M && M.abort();
          }, load: function(x) {
            M || (M = v.getLoader(x && x.request ? x.request.url : null)(f).create({ errHandler: y.errHandler, mediaPlayerModel: y.mediaPlayerModel, dashMetrics: y.dashMetrics, boxParser: y.boxParser ? y.boxParser : null, constants: y.constants ? y.constants : null, dashConstants: y.dashConstants ? y.dashConstants : null, urlUtils: y.urlUtils ? y.urlUtils : null, requestTimeout: isNaN(y.requestTimeout) ? 0 : y.requestTimeout, errors: y.errors })), M.load(x);
          }, reset: function() {
            v && (v.reset(), v = null), M && typeof M.reset == "function" && M.reset(), M = null;
          }, resetInitialSettings: function() {
            M && typeof M.resetInitialSettings == "function" && M.resetInitialSettings();
          } }, E;
        }
        ro.__dashjs_factory_name = "URLLoader";
        var Ha = Dt.A.getClassFactory(ro), Ul = class extends ze {
          constructor(y) {
            super(y), this.checkForExistenceOnly = !0;
          }
        };
        function Oo(y) {
          y = y || {};
          const f = this.context, E = y.eventBus, v = y.events, M = y.urlUtils, x = y.errors, z = y.streamId;
          let O, k;
          return O = { abort: function() {
            k && k.abort();
          }, checkForExistence: function(H) {
            const B = function(D) {
              E.trigger(v.CHECK_FOR_EXISTENCE_COMPLETED, { request: H, exists: D });
            };
            if (H) {
              let D = new Ul(H.url);
              k.load({ request: D, success: function() {
                B(!0);
              }, error: function() {
                B(!1);
              } });
            } else B(!1);
          }, load: function(H) {
            const B = function(D, N) {
              E.trigger(v.LOADING_COMPLETED, { request: H, response: D || null, error: N || null, sender: O });
            };
            H ? k.load({ request: H, progress: function(D) {
              E.trigger(v.LOADING_PROGRESS, { request: H, stream: D.stream, streamId: z }), D.data && E.trigger(v.LOADING_DATA_PROGRESS, { request: H, response: D.data || null, error: null, sender: O });
            }, success: function(D) {
              B(D);
            }, error: function(D, N, Y) {
              B(void 0, new Yt.A(x.FRAGMENT_LOADER_LOADING_FAILURE_ERROR_CODE, Y, N));
            }, abort: function(D) {
              D && E.trigger(v.LOADING_ABANDONED, { mediaType: D.mediaType, request: D, sender: O });
            } }) : B(void 0, new Yt.A(x.FRAGMENT_LOADER_NULL_REQUEST_ERROR_CODE, x.FRAGMENT_LOADER_NULL_REQUEST_ERROR_MESSAGE));
          }, reset: function() {
            k && (k.abort(), k.reset(), k = null);
          }, resetInitialSettings: function() {
            k && k.resetInitialSettings();
          } }, k = Ha(f).create({ errHandler: y.errHandler, errors: x, dashMetrics: y.dashMetrics, mediaPlayerModel: y.mediaPlayerModel, urlUtils: M, constants: q.A, boxParser: y.boxParser, dashConstants: y.dashConstants, requestTimeout: y.settings.get().streaming.fragmentRequestTimeout }), O;
        }
        Oo.__dashjs_factory_name = "FragmentLoader";
        var jl = Dt.A.getClassFactory(Oo);
        function Yo(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance(), v = y.errHandler, M = y.mediaPlayerModel, x = y.dashMetrics, z = (0, ae.A)(f).getInstance(), O = y.streamInfo;
          let k, H, B;
          function D() {
            return O.id;
          }
          function N() {
            for (let J in B) B[J].reset();
            B = {};
          }
          function Y(J) {
            if (!J.sender) return;
            const it = J.request, lt = J.response, at = it.isInitializationRequest(), st = it.representation.mediaInfo.streamInfo;
            if (J.error && (it.mediaType === q.A.AUDIO || it.mediaType === q.A.VIDEO || it.mediaType === q.A.MESH || it.mediaType === q.A.TEXT && it.representation.mediaInfo.isFragmented) && E.trigger(et.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD, { entry: J.request.serviceLocation }), !lt || !st) return void H.warn("No " + it.mediaType + " bytes to push or stream is inactive.");
            const ht = function(At, Z, F, G) {
              const K = new Ei();
              return K.streamId = F, K.segmentType = Z.type, K.start = Z.startTime, K.duration = Z.duration, K.end = K.start + K.duration, K.bytes = At, K.index = Z.index, K.quality = Z.quality, K.representation = Z.representation, K.endFragment = G, K;
            }(lt, it, O.id, J.type !== et.A.FRAGMENT_LOADING_PROGRESS);
            E.trigger(at ? et.A.INIT_FRAGMENT_LOADED : et.A.MEDIA_FRAGMENT_LOADED, { chunk: ht, request: it }, { streamId: st.id, mediaType: it.mediaType });
          }
          return k = { getStreamId: D, getModel: function(J) {
            let it = B[J];
            return it || (it = wn(f).create({ streamInfo: O, type: J, dashMetrics: x, fragmentLoader: jl(f).create({ dashMetrics: x, mediaPlayerModel: M, errHandler: v, settings: y.settings, boxParser: y.boxParser, eventBus: E, events: et.A, errors: X, dashConstants: y.dashConstants, urlUtils: y.urlUtils, streamId: D() }), debug: z, eventBus: E, events: et.A }), B[J] = it), it;
          }, reset: function() {
            E.off(St.A.FRAGMENT_LOADING_COMPLETED, Y, this), E.off(St.A.FRAGMENT_LOADING_PROGRESS, Y, this), N();
          } }, H = z.getLogger(k), N(), E.on(St.A.FRAGMENT_LOADING_COMPLETED, Y, k), E.on(St.A.FRAGMENT_LOADING_PROGRESS, Y, k), k;
        }
        Yo.__dashjs_factory_name = "FragmentController";
        var Bl = Dt.A.getClassFactory(Yo), Hl = class {
          constructor() {
            this.url = null, this.width = null, this.height = null, this.x = null, this.y = null;
          }
        }, ql = class {
          constructor() {
            this.bitrate = 0, this.width = 0, this.height = 0, this.tilesHor = 0, this.tilesVert = 0, this.widthPerTile = 0, this.heightPerTile = 0, this.startNumber = 0, this.segmentDuration = 0, this.timescale = 0, this.templateUrl = "", this.id = "";
          }
        };
        class ao {
          constructor(f) {
            if (this.offset = f._offset, this.type = f.type, this.size = f.size, this.boxes = [], f.boxes) for (let E = 0; E < f.boxes.length; E++) this.boxes.push(new ao(f.boxes[E]));
            switch (this.isComplete = !0, f.type) {
              case "sidx":
                if (this.timescale = f.timescale, this.earliest_presentation_time = f.earliest_presentation_time, this.first_offset = f.first_offset, this.references = f.references, f.references) {
                  this.references = [];
                  for (let E = 0; E < f.references.length; E++) {
                    let v = { reference_type: f.references[E].reference_type, referenced_size: f.references[E].referenced_size, subsegment_duration: f.references[E].subsegment_duration };
                    this.references.push(v);
                  }
                }
                break;
              case "emsg":
                this.id = f.id, this.version = f.version === 1 ? 1 : 0, this.value = f.value, this.timescale = f.timescale, this.scheme_id_uri = f.scheme_id_uri, this.presentation_time_delta = f.version === 1 ? f.presentation_time : f.presentation_time_delta, this.event_duration = f.event_duration, this.message_data = f.message_data;
                break;
              case "mdhd":
                this.timescale = f.timescale;
                break;
              case "mfhd":
                this.sequence_number = f.sequence_number;
                break;
              case "subs":
                this.entry_count = f.entry_count, this.entries = f.entries;
                break;
              case "tfhd":
                this.base_data_offset = f.base_data_offset, this.sample_description_index = f.sample_description_index, this.default_sample_duration = f.default_sample_duration, this.default_sample_size = f.default_sample_size, this.default_sample_flags = f.default_sample_flags, this.flags = f.flags;
                break;
              case "tfdt":
                this.version = f.version, this.baseMediaDecodeTime = f.baseMediaDecodeTime, this.flags = f.flags;
                break;
              case "trun":
                if (this.sample_count = f.sample_count, this.first_sample_flags = f.first_sample_flags, this.data_offset = f.data_offset, this.flags = f.flags, this.samples = f.samples, f.samples) {
                  this.samples = [];
                  for (let E = 0, v = f.samples.length; E < v; E++) {
                    let M = { sample_size: f.samples[E].sample_size, sample_duration: f.samples[E].sample_duration, sample_composition_time_offset: f.samples[E].sample_composition_time_offset };
                    this.samples.push(M);
                  }
                }
                break;
              case "prft":
                this.version = f.version, this.reference_track_ID = f.reference_track_ID, this.ntp_timestamp_sec = f.ntp_timestamp_sec, this.ntp_timestamp_frac = f.ntp_timestamp_frac, this.media_time = f.media_time, this.flags = f.flags;
            }
          }
          getChildBox(f) {
            for (let E = 0; E < this.boxes.length; E++) if (this.boxes[E].type === f) return this.boxes[E];
          }
          getChildBoxes(f) {
            let E = [];
            for (let v = 0; v < this.boxes.length; v++) this.boxes[v].type === f && E.push(this.boxes[v]);
            return E;
          }
        }
        var ka = ao;
        function Fo() {
          let y, f;
          function E(M) {
            let x = [];
            if (!M || !f || typeof f.fetchAll != "function") return x;
            let z, O = f.fetchAll(M);
            for (let k = 0, H = O.length; k < H; k++) z = v(O[k]), z && x.push(z);
            return x;
          }
          function v(M) {
            if (!M) return null;
            let x = new ka(M);
            return M.hasOwnProperty("_incomplete") && (x.isComplete = !M._incomplete), x;
          }
          return y = { getBox: function(M) {
            return M && f && f.boxes && f.boxes.length !== 0 && typeof f.fetch == "function" ? v(f.fetch(M)) : null;
          }, getBoxes: E, setData: function(M) {
            f = M;
          }, getLastBox: function() {
            if (!f || !f.boxes || !f.boxes.length) return null;
            let M = E(f.boxes[f.boxes.length - 1].type);
            return M.length > 0 ? M[M.length - 1] : null;
          } }, y;
        }
        Fo.__dashjs_factory_name = "IsoFile";
        var Gl = Dt.A.getClassFactory(Fo), us = b(6877), so = class {
          constructor(y) {
            let { found: f, sizeOfLastCompletedBox: E, sizeOfLastFoundTargetBox: v, startOffsetOfLastCompletedBox: M, startOffsetOfLastFoundTargetBox: x, typeOfLastCompletedBox: z, typeOfLastTargetBox: O } = y;
            this.found = f !== void 0 && f, this.sizeOfLastCompletedBox = E !== void 0 ? E : 0, this.sizeOfLastFoundTargetBox = v !== void 0 ? v : 0, this.startOffsetOfLastCompletedBox = M !== void 0 ? M : 0, this.startOffsetOfLastFoundTargetBox = x !== void 0 ? x : 0, this.typeOfLastCompletedBox = z !== void 0 ? z : null, this.typeOfLastTargetBox = O !== void 0 ? O : null;
          }
        };
        function Uo() {
          let y, f, E = this.context;
          function v(z) {
            if (!z) return null;
            z.fileStart === void 0 && (z.fileStart = 0);
            let O = us.parseBuffer(z), k = Gl(E).create();
            return k.setData(O), k;
          }
          function M(z, O) {
            return z[O + 3] >>> 0 | z[O + 2] << 8 >>> 0 | z[O + 1] << 16 >>> 0 | z[O] << 24 >>> 0;
          }
          function x(z, O) {
            return String.fromCharCode(z[O++]) + String.fromCharCode(z[O++]) + String.fromCharCode(z[O++]) + String.fromCharCode(z[O]);
          }
          return f = { findInitRange: function(z) {
            let O, k, H = null;
            const B = v(z);
            if (!B) return H;
            const D = B.getBox("ftyp"), N = B.getBox("moov");
            return y.debug("Searching for initialization."), N && N.isComplete && (O = D ? D.offset : N.offset, k = N.offset + N.size - 1, H = O + "-" + k, y.debug("Found the initialization.  Range: " + H)), H;
          }, findLastTopIsoBoxCompleted: function(z, O, k) {
            if (k === void 0 && (k = 0), !O || k + 8 >= O.byteLength) return new so({ found: !1 });
            const H = O instanceof ArrayBuffer ? new Uint8Array(O) : O;
            let B, D = 0, N = 0, Y = null;
            for (; k < H.byteLength; ) {
              const J = M(H, k), it = x(H, k + 4);
              if (J === 0) break;
              k + J <= H.byteLength && (z.indexOf(it) >= 0 ? B = new so({ found: !0, startOffsetOfLastFoundTargetBox: k, sizeOfLastFoundTargetBox: J, typeOfLastTargetBox: it }) : (D = k, N = J, Y = it)), k += J;
            }
            return B || new so({ found: !1, startOffsetOfLastCompletedBox: D, sizeOfLastCompletedBox: N, typeOfLastCompletedBox: Y });
          }, getMediaTimescaleFromMoov: function(z) {
            let O = v(z), k = O ? O.getBox("mdhd") : void 0;
            return k ? k.timescale : NaN;
          }, getSamplesInfo: function(z) {
            if (!z || z.byteLength === 0) return { sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN };
            let O, k, H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K = v(z), ft = K.getBoxes("moof"), bt = K.getBoxes("mfhd");
            F = K.getBoxes("moof").length, Z = bt[bt.length - 1].sequence_number, H = 0, N = [];
            let _t = -1, vt = -1;
            for (at = 0; at < ft.length; at++) {
              let Pt = ft[at], Ot = Pt.getChildBoxes("traf");
              for (it = 0; it < Ot.length; it++) {
                let W = Ot[it], tt = W.getChildBox("tfhd"), Tt = W.getChildBox("tfdt");
                D = Tt.baseMediaDecodeTime;
                let yt = W.getChildBoxes("trun"), nt = W.getChildBoxes("subs");
                for (lt = 0; lt < yt.length; lt++) {
                  let ct = yt[lt];
                  for (H = ct.sample_count, At = (tt.base_data_offset || 0) + (ct.data_offset || 0), J = 0; J < H; J++) {
                    Y = ct.samples[J], O = Y.sample_duration !== void 0 ? Y.sample_duration : tt.default_sample_duration, B = Y.sample_size !== void 0 ? Y.sample_size : tt.default_sample_size, k = Y.sample_composition_time_offset !== void 0 ? Y.sample_composition_time_offset : 0;
                    let V = { dts: D, cts: D + k, duration: O, offset: Pt.offset + At, size: B, subSizes: [B] };
                    if (nt) for (st = 0; st < nt.length; st++) {
                      let mt = nt[st];
                      if (_t < mt.entry_count - 1 && J > vt && (_t++, vt += mt.entries[_t].sample_delta), J == vt) {
                        V.subSizes = [];
                        let Mt = mt.entries[_t];
                        for (ht = 0; ht < Mt.subsample_count; ht++) V.subSizes.push(Mt.subsamples[ht].subsample_size);
                      }
                    }
                    N.push(V), At += B, D += O;
                  }
                }
                G = D - Tt.baseMediaDecodeTime;
              }
            }
            return { sampleList: N, lastSequenceNumber: Z, totalDuration: G, numSequences: F };
          }, parse: v }, y = (0, ae.A)(E).getInstance().getLogger(f), f;
        }
        Uo.__dashjs_factory_name = "BoxParser";
        var Ts = Dt.A.getSingletonFactory(Uo);
        function jo(y) {
          const f = this.context, E = y.adapter, v = y.baseURLController, M = y.streamInfo, x = y.timelineConverter, z = y.debug, O = y.eventBus, k = y.events, H = y.dashConstants, B = Se(f).getInstance();
          let D, N, Y, J, it, lt, at, st, ht;
          function At(F, G) {
            const K = new ql();
            K.id = F.id, K.bitrate = F.bandwidth, K.width = F.width, K.height = F.height, K.tilesHor = 1, K.tilesVert = 1, F.essentialProperties && F.essentialProperties.forEach((ft) => {
              if (q.A.THUMBNAILS_SCHEME_ID_URIS.indexOf(ft.schemeIdUri) >= 0 && ft.value) {
                const bt = ft.value.split("x");
                bt.length !== 2 || isNaN(bt[0]) || isNaN(bt[1]) || (K.tilesHor = parseInt(bt[0], 10), K.tilesVert = parseInt(bt[1], 10));
              }
            }), G ? at.updateSegmentData(F).then((ft) => {
              (function(bt, _t, vt) {
                let Pt = [];
                const Ot = function(W, tt) {
                  const Tt = [];
                  let yt, nt, ct, V, mt = 0;
                  for (yt = 0, nt = W.segments.length; yt < nt; yt++) ct = W.segments[yt], V = Ae(x, E.getIsDynamic(), tt, ct.startTime, ct.duration, ct.timescale, ct.media, ct.mediaRange, mt), V && (Tt.push(V), V = null, mt++);
                  return Tt;
                }(vt, _t);
                _t.segments = Ot, _t.fragmentDuration = _t.segmentDuration || (_t.segments && _t.segments.length > 0 ? _t.segments[0].duration : NaN), bt.segmentDuration = _t.segments[0].duration, bt.readThumbnail = function(W, tt) {
                  let Tt = null;
                  Pt.some((yt) => {
                    if (yt.start <= W && yt.end > W) return Tt = yt.url, !0;
                  }), Tt ? tt(Tt) : _t.segments.some((yt) => {
                    if (yt.mediaStartTime <= W && yt.mediaStartTime + yt.duration > W) {
                      const nt = v.resolve(_t.path);
                      return st.load({ method: "get", url: nt.url, request: { range: yt.mediaRange, responseType: "arraybuffer" }, onload: function(ct) {
                        let V = ht.getSamplesInfo(ct.target.response), mt = new Blob([ct.target.response.slice(V.sampleList[0].offset, V.sampleList[0].offset + V.sampleList[0].size)], { type: "image/jpeg" }), Mt = window.URL.createObjectURL(mt);
                        Pt.push({ start: yt.mediaStartTime, end: yt.mediaStartTime + yt.duration, url: Mt }), tt && tt(Mt);
                      } }), !0;
                    }
                  });
                };
              })(K, F, ft);
            }) : (K.startNumber = F.startNumber, K.segmentDuration = F.segmentDuration, K.timescale = F.timescale, K.templateUrl = function(ft) {
              const bt = B.isRelative(ft.media) ? B.resolve(ft.media, v.resolve(ft.path).url) : ft.media;
              return bt ? ii(bt, ft.id) : "";
            }(F)), K.tilesHor > 0 && K.tilesVert > 0 && (K.widthPerTile = K.width / K.tilesHor, K.heightPerTile = K.height / K.tilesVert, N.push(K));
          }
          function Z() {
            N = [], Y = [], it = -1, lt = null, J && (J.reset(), J = null);
          }
          return D = { addTracks: function() {
            if (!M || !E || (lt = E.getMediaInfoForType(M, q.A.IMAGE), !lt)) return;
            const F = E.getVoRepresentations(lt);
            F && F.length > 0 && F.forEach((G) => {
              (G.segmentInfoType === I.A.SEGMENT_TEMPLATE && G.segmentDuration > 0 && G.media || G.segmentInfoType === I.A.SEGMENT_TIMELINE) && At(G), G.segmentInfoType === I.A.SEGMENT_BASE && At(G, !0), Y.push(G);
            }), N.length > 0 && N.sort((G, K) => G.bitrate - K.bitrate);
          }, getCurrentTrack: function() {
            return it < 0 ? null : N[it];
          }, getCurrentTrackIndex: function() {
            return it;
          }, getRepresentations: function() {
            return Y;
          }, getThumbnailRequestForTime: function(F) {
            let G;
            const K = E.getVoRepresentations(lt);
            for (let ft = 0; ft < K.length; ft++) if (N[it].id === K[ft].id) {
              G = K[ft];
              break;
            }
            return J.getSegmentRequestForTime(lt, G, F);
          }, getTracks: function() {
            return N;
          }, reset: Z, setTrackById: function(F) {
            if (!N || N.length === 0) return;
            const G = N.findIndex((K) => K.id === F);
            G !== -1 && (it = G);
          }, setTrackByIndex: function(F) {
            N && N.length !== 0 && (F >= N.length && (F = N.length - 1), it = F);
          } }, Z(), st = Oi(f).create({}), ht = Ts(f).getInstance(), at = Be(f).create({ events: k, eventBus: O, streamInfo: M, timelineConverter: x, dashConstants: H, dashMetrics: y.dashMetrics, segmentBaseController: y.segmentBaseController, type: q.A.IMAGE }), J = He(f).create({ streamInfo: M, type: q.A.IMAGE, timelineConverter: x, segmentsController: at, baseURLController: v, debug: z, eventBus: O, events: k, dashConstants: H, urlUtils: B }), J.initialize(!!E && E.getIsDynamic()), D;
        }
        jo.__dashjs_factory_name = "ThumbnailTracks";
        var Kr = Dt.A.getClassFactory(jo);
        function xa(y) {
          const f = this.context, E = y.streamInfo;
          let v, M;
          function x(O) {
            M.setTrackByIndex(O);
          }
          function z() {
            M && M.reset();
          }
          return v = { getCurrentTrack: function() {
            return M.getCurrentTrack();
          }, getCurrentTrackIndex: function() {
            return M.getCurrentTrackIndex();
          }, getPossibleVoRepresentations: function() {
            return M.getRepresentations();
          }, getStreamId: function() {
            return E.id;
          }, initialize: function() {
            M.addTracks();
            const O = M.getTracks();
            O && O.length > 0 && x(0);
          }, provide: function(O, k) {
            if (typeof k != "function") return;
            const H = M.getCurrentTrack();
            let B, D;
            if (!H || H.segmentDuration <= 0 || O == null) return void k(null);
            D = M.getThumbnailRequestForTime(O), D && (H.segmentDuration = D.duration), B = O % H.segmentDuration;
            const N = Math.floor(B * H.tilesHor * H.tilesVert / H.segmentDuration), Y = new Hl();
            if (Y.width = Math.floor(H.widthPerTile), Y.height = Math.floor(H.heightPerTile), Y.x = Math.floor(N % H.tilesHor) * H.widthPerTile, Y.y = Math.floor(N / H.tilesHor) * H.heightPerTile, "readThumbnail" in H) return H.readThumbnail(O, (J) => {
              Y.url = J, k(Y);
            });
            if (D) Y.url = D.url, H.segmentDuration = NaN;
            else {
              const J = Math.floor(O / H.segmentDuration);
              Y.url = function(it, lt) {
                const at = lt + it.startNumber;
                let st = Wn(it.templateUrl, "Number", at);
                return st = Wn(st, "Time", (at - 1) * it.segmentDuration * it.timescale), st = Wn(st, "Bandwidth", it.bandwidth), je(st);
              }(H, J);
            }
            k(Y);
          }, reset: z, setTrackByIndex: x, setTrackById: function(O) {
            M.setTrackById(O);
          } }, z(), M = Kr(f).create({ streamInfo: E, adapter: y.adapter, baseURLController: y.baseURLController, timelineConverter: y.timelineConverter, debug: y.debug, eventBus: y.eventBus, events: y.events, dashConstants: y.dashConstants, dashMetrics: y.dashMetrics, segmentBaseController: y.segmentBaseController }), v;
        }
        xa.__dashjs_factory_name = "ThumbnailController";
        var Vl = Dt.A.getClassFactory(xa);
        function ws(y) {
          let f;
          y = y || {};
          let E = [];
          const v = (0, It.A)(this.context).getInstance(), M = y.updateEventName, x = y.addBlacklistEventName;
          function z(k) {
            E.indexOf(k) === -1 && (E.push(k), v.trigger(M, { entry: k }));
          }
          function O(k) {
            z(k.entry);
          }
          return f = { add: z, remove: function(k) {
            const H = E.indexOf(k);
            H !== -1 && E.splice(H, 1);
          }, contains: function(k) {
            return !!(E.length && k && k.length) && E.indexOf(k) !== -1;
          }, reset: function() {
            x && v.off(x, O, f), E = [];
          } }, x && v.on(x, O, f), f;
        }
        ws.__dashjs_factory_name = "BlackListController";
        var fa = Dt.A.getClassFactory(ws);
        const As = [q.A.MESH, q.A.VIDEO, q.A.AUDIO, q.A.TEXT, q.A.MUXED, q.A.IMAGE];
        function ci(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance(), v = Se(f).getInstance(), M = y.manifestModel, x = y.mediaPlayerModel, z = y.dashMetrics, O = y.manifestUpdater, k = y.adapter, H = y.timelineConverter, B = y.capabilities, D = y.errHandler, N = y.abrController, Y = y.playbackController, J = y.throughputController, it = y.eventController, lt = y.mediaController, at = y.protectionController, st = y.textController, ht = y.videoModel;
          let At = y.streamInfo;
          const Z = y.settings;
          let F, G, K, ft, bt, _t, vt, Pt, Ot, W, tt, Tt, yt, nt, ct, V;
          function mt(ee, De, Pe) {
            return new Promise((nn, sn) => {
              Ye(), cn();
              let gn = ht.getElement();
              const ie = [];
              As.forEach((Le) => {
                if ((Le !== q.A.TEXT || ee) && (Le !== q.A.VIDEO || !gn || gn && /^VIDEO$/i.test(gn.nodeName))) {
                  const We = Pe.find((ln) => ln.mediaInfo.type === Le);
                  ie.push(Mt(Le, ee, We));
                }
              }), Promise.all(ie).then(() => {
                return Le = De, new Promise((We) => {
                  const ln = {}, ye = K.map((Rt) => {
                    const Wt = Rt.getRepresentation();
                    return Rt.createBufferSinks(Le, Wt);
                  });
                  Promise.all(ye).then((Rt) => {
                    Rt.forEach((Wt) => {
                      Wt && (ln[Wt.getType()] = Wt);
                    }), We(ln);
                  }).catch(() => {
                    We(ln);
                  });
                });
                var Le;
              }).then((Le) => {
                if (K.length === 0) {
                  const We = "No streams to play.";
                  D.error(new Yt.A(X.MANIFEST_ERROR_ID_NOSTREAMS_CODE, We, M.getValue())), G.fatal(We);
                } else be();
                ee && st.createTracks(At), nn(Le);
              }).catch((Le) => {
                sn(Le);
              });
            });
          }
          function Mt(ee, De, Pe) {
            let nn, sn = k.getAllMediaInfoForType(At, ee), gn = [], ie = null;
            if (!sn || sn.length === 0) return G.info("No " + ee + " data."), Promise.resolve();
            ee === q.A.VIDEO && (vt = !0), ee === q.A.AUDIO && (Pt = !0);
            for (let We = 0, ln = sn.length; We < ln; We++) ie = sn[We], ee === q.A.TEXT && ie.isEmbedded && (st.addEmbeddedTrack(At, ie), gn.push(ie)), Lt(ie) && lt.addTrack(ie);
            if (gn.length > 0 && (lt.setInitialMediaSettingsForType(ee, At), st.addMediaInfosToBuffer(At, ee, gn)), sn = sn.filter((We) => !We.isEmbedded), sn.length === 0) return Promise.resolve();
            if (ee === q.A.IMAGE) return W = Vl(f).create({ streamInfo: At, adapter: k, baseURLController: y.baseURLController, timelineConverter: y.timelineConverter, debug: nt, eventBus: E, events: et.A, dashConstants: I.A, dashMetrics: y.dashMetrics, segmentBaseController: y.segmentBaseController }), W.initialize(), Promise.resolve();
            E.trigger(et.A.STREAM_INITIALIZING, { streamInfo: At, mediaInfo: ie }), lt.setInitialMediaSettingsForType(ee, At);
            let Le = function(We, ln) {
              const ye = We && We.length > 0 ? We[0] : null;
              let Rt = Ot.getModel(ye ? ye.type : null);
              const Wt = ye ? ye.type : null, Ee = ye ? ye.mimeType : null, te = ye ? ye.isFragmented : null;
              let Ie = Ii(f).create({ abrController: N, adapter: k, baseURLController: y.baseURLController, boxParser: yt, capabilities: B, dashMetrics: y.dashMetrics, errHandler: D, fragmentModel: Rt, manifestModel: M, mediaController: lt, mediaPlayerModel: x, mimeType: Ee, playbackController: Y, segmentBaseController: y.segmentBaseController, segmentBlacklistController: tt, settings: Z, streamInfo: At, textController: st, throughputController: J, timelineConverter: H, type: Wt });
              return Ie.initialize(ln, vt, te), K.push(Ie), Ie.setMediaInfoArray(We), Wt === q.A.TEXT && st.addMediaInfosToBuffer(At, Wt, We, Rt), Ie;
            }(sn, De);
            if (nn = lt.getCurrentTrackFor(ee, At.id), nn) {
              const We = ee === q.A.TEXT && nn.isEmbedded ? sn[0] : nn, ln = new $n({ newMediaInfo: We, previouslySelectedRepresentation: Pe });
              return Le.selectMediaInfo(ln);
            }
            return Promise.resolve();
          }
          function Lt(ee) {
            const De = ee ? ee.type : null;
            let Pe;
            return !(De !== q.A.MESH && (De === q.A.MUXED ? (Pe = "Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines", G.fatal(Pe), D.error(new Yt.A(X.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, Pe, M.getValue())), 1) : De !== q.A.TEXT && De !== q.A.IMAGE && ee.contentProtection && ee.contentProtection.length > 0 && !B.supportsEncryptedMedia() && (D.error(new Yt.A(X.CAPABILITY_MEDIAKEYS_ERROR_CODE, X.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE)), 1)));
          }
          function Bt(ee) {
            let De = K ? K.length : 0;
            for (let Pe = 0; Pe < De; Pe++) {
              let nn = K[Pe].getFragmentModel();
              nn.abortRequests(), nn.resetInitialSettings(), K[Pe].reset(!1, ee);
            }
            st && st.deactivateStream(At), W && (W.reset(), W = null), K = [], bt = !1, _t = !1, ge(!1), Zt(!1), E.trigger(et.A.STREAM_DEACTIVATED, { streamInfo: At });
          }
          function Qt(ee) {
            Bt(ee), ft = !1, vt = !1, Pt = !1, ct = !1, V = [];
          }
          function Zt(ee) {
            ct = ee;
          }
          function fe() {
            return At ? At.start : NaN;
          }
          function Ue() {
            return At ? At.id : null;
          }
          function Ye() {
            if (!ht || !N) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function on(ee) {
            ee.error && (D.error(ee.error), G.fatal(ee.error.message));
          }
          function cn() {
            if (it) {
              const ee = k.getEventsFor(At);
              ee && ee.length > 0 && it.addInlineEvents(ee, At.id);
            }
          }
          function Nn(ee) {
            let De = Qe(ee);
            return De ? De.getMediaInfo() : null;
          }
          function Qe(ee) {
            return ee ? K.find((De) => De.getType() === ee) : null;
          }
          function hn() {
            let ee = Rn();
            const De = ee.length;
            if (De !== 0) {
              for (let Pe = 0; Pe < De; Pe++) if (!ee[Pe].isBufferingCompleted() && (ee[Pe].getType() === q.A.AUDIO || ee[Pe].getType() === q.A.VIDEO || ee[Pe].getType() === q.A.MESH)) return void G.debug("onBufferingCompleted - One streamProcessor has finished but", ee[Pe].getType(), "one is not buffering completed");
              G.debug("onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED"), _t = !0, E.trigger(et.A.STREAM_BUFFERING_COMPLETED, { streamInfo: At }, { streamInfo: At });
            } else G.warn("onBufferingCompleted - can't trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined");
          }
          function Sn(ee) {
            it && it.addInbandEvents(ee.events, At.id);
          }
          function jn(ee) {
            return ee && ee.type ? Ln(ee.type) : null;
          }
          function Ln(ee) {
            return ee ? Rn().filter(function(De) {
              return De.getType() === ee;
            })[0] : null;
          }
          function Rn() {
            let ee, De, Pe = [];
            for (let nn = 0; nn < K.length; nn++) De = K[nn], ee = De.getType(), ee !== q.A.AUDIO && ee !== q.A.VIDEO && ee !== q.A.TEXT && ee !== q.A.MESH || Pe.push(De);
            return Pe;
          }
          function $t() {
            const ee = K.length;
            for (let De = 0; De < ee && K[De]; De++) K[De].getScheduleController().startScheduleTimer();
          }
          function be() {
            const ee = K.length;
            if (at) {
              at.clearMediaInfoArray();
              for (let De = 0; De < ee && K[De]; De++) {
                const Pe = K[De].getType(), nn = K[De].getMediaInfo();
                if (Pe === q.A.AUDIO || Pe === q.A.VIDEO || Pe === q.A.MESH || Pe === q.A.TEXT && nn && nn.isFragmented) {
                  let sn = K[De].getMediaInfo();
                  sn && at.initializeForMedia(sn);
                }
              }
              at.handleKeySystemFromManifest();
            }
            ft || (ft = !0, ht.waitForReadyState(q.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, () => {
              E.trigger(et.A.STREAM_INITIALIZED, { streamInfo: At });
            }));
          }
          function ge(ee) {
            Tt = ee;
          }
          function Te() {
            return Tt;
          }
          return F = { activate: function(ee, De) {
            let Pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            return new Promise((nn, sn) => {
              if (!bt) return Te() ? (bt = !0, E.trigger(et.A.STREAM_ACTIVATED, { streamInfo: At }), void nn(De)) : void function(gn, ie) {
                return mt(gn, ie, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []);
              }(ee, De, Pe).then((gn) => {
                bt = !0, Pe && Pe.length > 0 && $t(), E.trigger(et.A.STREAM_ACTIVATED, { streamInfo: At }), nn(gn);
              }).catch((gn) => {
                sn(gn);
              });
              nn(De);
            });
          }, checkAndHandleCompletedBuffering: function() {
            _t || K.forEach((ee) => {
              ee.checkAndHandleCompletedBuffering();
            });
          }, deactivate: Bt, getAdapter: function() {
            return k;
          }, getCurrentMediaInfoForType: function(ee) {
            const De = Ln(ee);
            return De ? De.getMediaInfo() : null;
          }, getCurrentRepresentationForType: function(ee) {
            const De = Ln(ee);
            return De ? De.getRepresentation() : null;
          }, getDuration: function() {
            return At ? At.duration : NaN;
          }, getHasAudioTrack: function() {
            return Pt;
          }, getHasFinishedBuffering: function() {
            return _t;
          }, getHasVideoTrack: function() {
            return vt;
          }, getId: Ue, getIsActive: function() {
            return bt;
          }, getIsEndedEventSignaled: function() {
            return ct;
          }, getPreloaded: Te, getRepresentationForTypeById: function(ee, De) {
            let Pe;
            if (ee === q.A.IMAGE) {
              if (!W) return null;
              Pe = W.getPossibleVoRepresentations();
            } else
              Pe = function(gn) {
                let ie = Qe(gn);
                return ie ? ie.getAllMediaInfos() : [];
              }(ee).flatMap((gn) => N.getPossibleVoRepresentationsFilteredBySettings(gn, !0));
            if (!Pe || Pe.length === 0) return null;
            const nn = Pe.filter((sn) => sn.id === De);
            return nn && nn.length > 0 ? nn[0] : null;
          }, getRepresentationForTypeByIndex: function(ee, De) {
            let Pe;
            if (ee === q.A.IMAGE) {
              if (!W) return null;
              Pe = W.getPossibleVoRepresentations();
            } else {
              const nn = Nn(ee);
              Pe = N.getPossibleVoRepresentationsFilteredBySettings(nn, !0);
            }
            return Pe[De = Math.max(Math.min(De, Pe.length - 1), 0)];
          }, getRepresentationsByType: function(ee) {
            if (Ye(), ee === q.A.IMAGE) return W ? W.getPossibleVoRepresentations() : [];
            const De = Nn(ee);
            return N.getPossibleVoRepresentationsFilteredBySettings(De, !0);
          }, getStartTime: fe, getStreamId: function() {
            return At ? At.id : null;
          }, getStreamInfo: function() {
            return At;
          }, getStreamProcessors: Rn, getThumbnailController: function() {
            return W;
          }, initialize: function() {
            E.on(et.A.BUFFERING_COMPLETED, hn, F), E.on(et.A.INBAND_EVENTS, Sn, F), at && (E.on(et.A.KEY_ERROR, on, F), E.on(et.A.SERVER_CERTIFICATE_UPDATED, on, F), E.on(et.A.LICENSE_REQUEST_COMPLETE, on, F), E.on(et.A.KEY_SYSTEM_SELECTED, on, F), E.on(et.A.KEY_SESSION_CREATED, on, F)), st.initializeForStream(At), E.trigger(et.A.STREAM_UPDATED, { streamInfo: At });
          }, initializeForTextWithMediaSource: function(ee) {
            return new Promise((De, Pe) => {
              Mt(q.A.TEXT, ee, null).then(() => function() {
                const nn = Ln(q.A.TEXT);
                return nn ? nn.createBufferSinks() : Promise.resolve();
              }()).then(() => {
                st.createTracks(At), De();
              }).catch((nn) => {
                Pe(nn);
              });
            });
          }, prepareQualityChange: function(ee) {
            const De = Ln(ee.mediaType);
            De && De.prepareQualityChange(ee);
          }, prepareTrackChange: function(ee) {
            if (!bt || !At) return;
            _t = !1;
            let De = ee.newMediaInfo, Pe = M.getValue(), nn = jn(De);
            if (!nn) return;
            let sn = Y.getTime();
            if (G.info("Stream -  Process track changed at current time " + sn), Pe.refreshManifestOnSwitchTrack) V.push(ee), O.getIsUpdating() || (G.debug("Stream -  Refreshing manifest for switch track"), O.refreshManifest());
            else {
              nn.clearScheduleTimer(), nn.setTrackSwitchInProgress(!0);
              const gn = nn.getRepresentation();
              nn.selectMediaInfo(new $n({ newMediaInfo: De })).then(() => {
                const ie = !!(ee && ee.options && ee.options.hasOwnProperty("replaceBuffer")) && ee.options.replaceBuffer;
                return nn.prepareTrackSwitch(gn, ie);
              }).then(() => {
                nn.setTrackSwitchInProgress(!1);
              });
            }
          }, reset: function(ee) {
            Ot && (Ot.reset(), Ot = null), N && At && N.clearDataForStream(At.id), tt && (tt.reset(), tt = null), st && At && st.clearDataForStream(At.id), lt && At && lt.clearDataForStream(At.id), Qt(ee), At = null, E.off(et.A.BUFFERING_COMPLETED, hn, F), E.off(et.A.INBAND_EVENTS, Sn, F), at && (E.off(et.A.KEY_ERROR, on, F), E.off(et.A.SERVER_CERTIFICATE_UPDATED, on, F), E.off(et.A.LICENSE_REQUEST_COMPLETE, on, F), E.off(et.A.KEY_SYSTEM_SELECTED, on, F), E.off(et.A.KEY_SESSION_CREATED, on, F));
          }, setIsEndedEventSignaled: Zt, setMediaSource: function(ee) {
            return new Promise((De, Pe) => {
              const nn = [];
              for (let sn = 0; sn < K.length; ) Lt(K[sn].getMediaInfo()) ? (nn.push(K[sn].setMediaSource(ee)), sn++) : (K[sn].reset(), K.splice(sn, 1));
              Promise.all(nn).then(() => {
                for (let sn = 0; sn < K.length; sn++) K[sn].dischargePreBuffer();
                if (K.length === 0) {
                  const sn = "No streams to play.";
                  D.error(new Yt.A(X.MANIFEST_ERROR_ID_NOSTREAMS_CODE, sn + "nostreams", M.getValue())), G.fatal(sn);
                }
                De();
              }).catch((sn) => {
                G.error(sn), Pe(sn);
              });
            });
          }, startPreloading: function(ee, De) {
            let Pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
            return new Promise((nn, sn) => {
              Te() ? sn() : (G.info(`[startPreloading] Preloading next stream with id ${Ue()}`), ge(!0), mt(ee, De, Pe).then(() => {
                for (let gn = 0; gn < K.length && K[gn]; gn++) K[gn].setExplicitBufferingTime(fe()), K[gn].getScheduleController().startScheduleTimer();
                nn();
              }).catch(() => {
                ge(!1), sn();
              }));
            });
          }, startScheduleControllers: $t, triggerProtectionError: function(ee) {
            on(ee);
          }, updateData: function(ee) {
            return new Promise((De) => {
              At = ee, it && cn();
              let Pe, nn = [];
              for (let sn = 0, gn = K.length; sn < gn; sn++) {
                let ie = K[sn];
                const Le = ie.getMediaInfo();
                nn.push(ie.updateStreamInfo(At));
                let We = k.getAllMediaInfoForType(At, ie.getType());
                if (We = We.filter((ln) => !ln.isEmbedded), ie.setMediaInfoArray(We), We) for (let ln = 0; ln < We.length; ln++) k.areMediaInfosEqual(Le, We[ln]) && nn.push(ie.selectMediaInfo(new $n({ newMediaInfo: We[ln] })));
              }
              Promise.all(nn).then(() => {
                let sn = [];
                for (; V.length > 0; ) {
                  let gn = V.pop(), ie = gn.newMediaInfo;
                  if (Pe = jn(gn.oldMediaInfo), !Pe) return;
                  const Le = Pe.getRepresentation();
                  Pe.setTrackSwitchInProgress(!0), sn.push(Pe.prepareTrackSwitch(Le)), sn.push(Pe.selectMediaInfo(new $n({ newMediaInfo: ie })));
                }
                return Promise.all(sn);
              }).then(() => {
                be(), Pe && Pe.setTrackSwitchInProgress(!1), E.trigger(et.A.STREAM_UPDATED, { streamInfo: At }), De();
              }).catch((sn) => {
                D.error(sn);
              });
            });
          } }, function() {
            try {
              nt = (0, ae.A)(f).getInstance(), G = nt.getLogger(F), Qt(), yt = Ts(f).getInstance(), tt = fa(f).create({ updateEventName: et.A.SEGMENT_LOCATION_BLACKLIST_CHANGED, addBlacklistEventName: et.A.SEGMENT_LOCATION_BLACKLIST_ADD }), Ot = Bl(f).create({ streamInfo: At, mediaPlayerModel: x, dashMetrics: z, errHandler: D, settings: Z, boxParser: yt, dashConstants: I.A, urlUtils: v });
            } catch (ee) {
              throw ee;
            }
          }(), F;
        }
        ci.__dashjs_factory_name = "Stream";
        var T = Dt.A.getClassFactory(ci), j = class {
          constructor(y) {
            this.url = y || null, this.type = Ct.G.CONTENT_STEERING_TYPE, this.responseType = "json";
          }
        }, ut = class {
          constructor() {
            this.version = null, this.ttl = 300, this.reloadUri = null, this.pathwayPriority = [], this.pathwayClones = [];
          }
        };
        function wt() {
          const y = this.context, f = Se(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D, N, Y, J, it, lt;
          function at(vt) {
            At(vt, "baseUrl");
          }
          function st(vt) {
            At(vt, "location");
          }
          function ht(vt) {
            var Pt, Ot;
            vt && vt.throughputValues && vt.throughputValues.serviceLocation && (Pt = vt.throughputValues.serviceLocation, Ot = vt.throughputValues, z[Pt] || (z[Pt] = []), z[Pt].push(Ot), z[Pt].length > 4 && z[Pt].shift());
          }
          function At(vt, Pt) {
            if (vt && vt.request && vt.request.serviceLocation) {
              const Ot = vt.request.serviceLocation;
              x[Pt].all.indexOf(Ot) === -1 && x[Pt].all.push(Ot), x[Pt].current = Ot;
            }
          }
          function Z() {
            const vt = N.getValue();
            let Pt = lt.getContentSteering(vt);
            return Pt || (Pt = Y.getServiceDescriptionSettings().contentSteering), Pt;
          }
          function F() {
            return new Promise((vt) => {
              try {
                const Pt = Z();
                if (!Pt || !Pt.serverUrl) return void vt();
                const Ot = function(tt) {
                  let Tt = tt.serverUrl;
                  M && M.reloadUri && (Tt = f.isRelative(M.reloadUri) ? f.resolve(M.reloadUri, tt.serverUrl) : M.reloadUri);
                  const yt = [], nt = x.baseUrl.all.concat(x.location.all);
                  if (nt.length > 0) {
                    const ct = nt.map((Mt) => {
                      const Lt = function(Bt) {
                        if (!Bt || !z[Bt] || z[Bt].length === 0) return -1;
                        const Qt = J.getArithmeticMean(z[Bt], z[Bt].length, !0);
                        return parseInt(1e3 * Qt);
                      }(Mt);
                      return { serviceLocation: Mt, throughput: Lt };
                    });
                    ct.sort((Mt, Lt) => Lt.throughput - Mt.throughput);
                    let V = "", mt = "";
                    ct.forEach((Mt, Lt) => {
                      Lt !== 0 && (V = `${V},`, Mt.throughput > -1 && (mt = `${mt},`)), V = `${V}${Mt.serviceLocation}`, Mt.throughput > -1 && (mt = `${mt}${Mt.throughput}`);
                    }), yt.push({ key: "_DASH_pathway", value: `"${V}"` }), yt.push({ key: "_DASH_throughput", value: mt });
                  }
                  return Tt = ai.A.addAdditionalQueryParameterToUrl(Tt, yt), Tt;
                }(Pt), W = new j(Ot);
                k.load({ request: W, success: (tt) => {
                  (function(Tt) {
                    Tt && Tt[I.A.CONTENT_STEERING_RESPONSE.VERSION] && parseInt(Tt[I.A.CONTENT_STEERING_RESPONSE.VERSION]) === 1 && (M = new ut(), M.version = Tt[I.A.CONTENT_STEERING_RESPONSE.VERSION], Tt[I.A.CONTENT_STEERING_RESPONSE.TTL] && !isNaN(Tt[I.A.CONTENT_STEERING_RESPONSE.TTL]) && (M.ttl = Tt[I.A.CONTENT_STEERING_RESPONSE.TTL]), Tt[I.A.CONTENT_STEERING_RESPONSE.RELOAD_URI] && (M.reloadUri = Tt[I.A.CONTENT_STEERING_RESPONSE.RELOAD_URI]), Tt[I.A.CONTENT_STEERING_RESPONSE.PATHWAY_PRIORITY] && (M.pathwayPriority = Tt[I.A.CONTENT_STEERING_RESPONSE.PATHWAY_PRIORITY]), Tt[I.A.CONTENT_STEERING_RESPONSE.PATHWAY_CLONES] && (M.pathwayClones = Tt[I.A.CONTENT_STEERING_RESPONSE.PATHWAY_CLONES], M.pathwayClones = M.pathwayClones.filter((yt) => function(nt) {
                      return nt[I.A.CONTENT_STEERING_RESPONSE.BASE_ID] && nt[I.A.CONTENT_STEERING_RESPONSE.ID] && nt[I.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT] && nt[I.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][I.A.CONTENT_STEERING_RESPONSE.HOST];
                    }(yt))), ft());
                  })(tt), it.trigger(St.A.CONTENT_STEERING_REQUEST_COMPLETED, { currentSteeringResponseData: M, url: Ot }), vt();
                }, error: (tt, Tt, yt, nt) => {
                  (function(ct, V) {
                    try {
                      switch (v.warn("Error fetching data from content steering server", ct), V.status) {
                        case 410:
                          break;
                        case 429:
                          const mt = V && V.getResponseHeader ? V.getResponseHeader("retry-after") : null;
                          mt !== null && (M || (M = {}), M.ttl = parseInt(mt)), ft();
                          break;
                        default:
                          ft();
                      }
                    } catch (mt) {
                      v.error(mt);
                    }
                  })(tt, nt), vt(tt);
                }, complete: () => {
                  x.baseUrl.all = G(x.baseUrl), x.location.all = G(x.location);
                } });
              } catch (Pt) {
                vt(Pt);
              }
            });
          }
          function G(vt) {
            return vt.all && vt.all.length !== 0 && vt.current ? vt.all.filter((Pt) => Pt === vt.current) : [];
          }
          function K(vt) {
            try {
              const Pt = [];
              return vt && vt.length !== 0 && M && M.pathwayClones && M.pathwayClones.length !== 0 && M.pathwayClones.forEach((Ot) => {
                let W = vt.filter((Tt) => Ot[I.A.CONTENT_STEERING_RESPONSE.BASE_ID] === Tt.serviceLocation), tt = null;
                if (W && W.length > 0 && (tt = W[0]), tt) {
                  const Tt = new URL(tt.url);
                  let yt = Ot[I.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][I.A.CONTENT_STEERING_RESPONSE.HOST];
                  yt = ai.A.stringHasProtocol(yt) ? yt : `${Tt.protocol}//${yt}`;
                  const nt = { synthesizedUrl: `${yt}${Tt.pathname}`, serviceLocation: Ot[I.A.CONTENT_STEERING_RESPONSE.ID], queryParams: Ot[I.A.CONTENT_STEERING_RESPONSE.URI_REPLACEMENT][I.A.CONTENT_STEERING_RESPONSE.PARAMS], reference: tt };
                  Pt.push(nt);
                }
              }), Pt;
            } catch (Pt) {
              return v.error(Pt), [];
            }
          }
          function ft() {
            M && M.ttl && !isNaN(M.ttl) && (O && clearTimeout(O), O = setTimeout(() => {
              F();
            }, 1e3 * M.ttl));
          }
          function bt() {
            O && clearTimeout(O), O = null;
          }
          function _t() {
            M = null, z = {}, x = { baseUrl: { current: null, all: [] }, location: { current: null, all: [] } }, bt();
          }
          return E = { reset: function() {
            _t(), it.off(St.A.FRAGMENT_LOADING_STARTED, at, E), it.off(St.A.MANIFEST_LOADING_STARTED, st, E), it.off(St.A.THROUGHPUT_MEASUREMENT_STORED, ht, E);
          }, setConfig: function(vt) {
            vt && (vt.adapter && (lt = vt.adapter), vt.errHandler && (H = vt.errHandler), vt.dashMetrics && (B = vt.dashMetrics), vt.mediaPlayerModel && (D = vt.mediaPlayerModel), vt.manifestModel && (N = vt.manifestModel), vt.serviceDescriptionController && (Y = vt.serviceDescriptionController), vt.throughputController && (J = vt.throughputController), vt.eventBus && (it = vt.eventBus));
          }, loadSteeringData: F, getCurrentSteeringResponseData: function() {
            return M;
          }, shouldQueryBeforeStart: function() {
            const vt = Z();
            return !!vt && vt.queryBeforeStart;
          }, getSteeringDataFromManifest: Z, stopSteeringRequestTimer: bt, getSynthesizedBaseUrlElements: function(vt) {
            try {
              return K(vt).map((Pt) => {
                const Ot = new qr(Pt.synthesizedUrl, Pt.serviceLocation);
                return Ot.queryParams = Pt.queryParams, Ot.dvbPriority = Pt.reference.dvbPriority, Ot.dvbWeight = Pt.reference.dvbWeight, Ot.availabilityTimeOffset = Pt.reference.availabilityTimeOffset, Ot.availabilityTimeComplete = Pt.reference.availabilityTimeComplete, Ot;
              });
            } catch (Pt) {
              return v.error(Pt), [];
            }
          }, getSynthesizedLocationElements: function(vt) {
            try {
              return K(vt).map((Pt) => {
                const Ot = new Xn(Pt.synthesizedUrl, Pt.serviceLocation);
                return Ot.queryParams = Pt.queryParams, Ot;
              });
            } catch (Pt) {
              return v.error(Pt), [];
            }
          }, initialize: function() {
            k = Ha(y).create({ errHandler: H, dashMetrics: B, mediaPlayerModel: D, errors: X }), it.on(St.A.FRAGMENT_LOADING_STARTED, at, E), it.on(St.A.MANIFEST_LOADING_STARTED, st, E), it.on(St.A.THROUGHPUT_MEASUREMENT_STORED, ht, E);
          } }, v = (0, ae.A)(y).getInstance().getLogger(E), _t(), E;
        }
        wt.__dashjs_factory_name = "ContentSteeringController";
        var Ut = Dt.A.getSingletonFactory(wt);
        function oe() {
          const y = this.context, f = (0, Q.A)(y).getInstance();
          let E, v, M;
          return E = { select: function(x) {
            if (!x || x.length === 0) return null;
            let z = null;
            return f.get().streaming.applyContentSteering && (z = function(O) {
              const k = M.getCurrentSteeringResponseData();
              return k && k.pathwayPriority && k.pathwayPriority.length > 0 ? function() {
                let H = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], D = 0, N = null;
                for (; D < H.length; ) {
                  const Y = H[D], J = B.findIndex((it) => it.serviceLocation && it.serviceLocation === Y);
                  if (J !== -1 && !v.contains(B[J].serviceLocation)) {
                    N = B[J];
                    break;
                  }
                  D += 1;
                }
                return N;
              }(k.pathwayPriority, O) : null;
            }(x)), z || (z = function(O) {
              return O[0];
            }(x)), z;
          }, setConfig: function(x) {
            x.blacklistController && (v = x.blacklistController), x.contentSteeringController && (M = x.contentSteeringController);
          }, reset: function() {
            v.reset();
          } }, v = fa(y).create({ updateEventName: et.A.SERVICE_LOCATION_LOCATION_BLACKLIST_CHANGED, addBlacklistEventName: et.A.SERVICE_LOCATION_LOCATION_BLACKLIST_ADD }), M = Ut(y).getInstance(), E;
        }
        oe.__dashjs_factory_name = "LocationSelector";
        var _e = Dt.A.getClassFactory(oe);
        function en() {
          const y = this.context, f = (0, It.A)(y).getInstance(), E = Se(y).getInstance();
          let v, M, x, z, O, k, H, B, D, N, Y, J, it, lt;
          function at() {
            x = NaN, H = !1, O = !0, k = !1, st();
          }
          function st() {
            z !== null && (clearTimeout(z), z = null);
          }
          function ht(_t) {
            st(), k || (isNaN(_t) && !isNaN(x) && (_t = 1e3 * x), isNaN(_t) || (M.debug("Refresh manifest in " + _t + " milliseconds."), z = setTimeout(F, _t)));
          }
          function At() {
            let _t = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            H = !0;
            const vt = D.getValue();
            let Pt = vt.url;
            Pt && (Pt = ai.A.removeQueryParameterFromUrl(Pt, q.A.CMCD_QUERY_KEY));
            let Ot = null;
            const W = Y.getPatchLocation(vt), tt = N.select(W);
            let Tt = null;
            if (tt && !_t) Pt = tt.url, Ot = tt.serviceLocation, Tt = tt.queryParams;
            else {
              const yt = function(ct) {
                const V = Y.getLocation(ct), mt = it.getSynthesizedLocationElements(V);
                return V.concat(mt);
              }(vt), nt = N.select(yt);
              nt && (Pt = nt.url, Ot = nt.serviceLocation, Tt = nt.queryParams);
            }
            E.isRelative(Pt) && (Pt = E.resolve(Pt, vt.url)), B.load(Pt, Ot, Tt);
          }
          function Z(_t) {
            if (_t) {
              if (Y.getIsPatch(_t)) {
                let Ot = _t;
                _t = D.getValue();
                let W = Y.isPatchValid(_t, Ot), tt = W;
                if (W) {
                  let Tt = Y.getPublishTime(_t);
                  Y.applyPatchToManifest(_t, Ot);
                  let yt = Y.getPublishTime(_t);
                  tt = Tt.getTime() !== yt.getTime();
                }
                if (!tt) return M.debug("Patch provided is invalid, performing full manifest refresh"), void At(!0);
                _t.loadedTime = /* @__PURE__ */ new Date();
              }
            } else (_t = D.getValue()).loadedTime = /* @__PURE__ */ new Date();
            if (D.getValue() && D.getValue().type === I.A.DYNAMIC && _t.type === I.A.STATIC) return f.trigger(et.A.DYNAMIC_TO_STATIC), H = !1, void (k = !0);
            D.setValue(_t);
            const vt = /* @__PURE__ */ new Date(), Pt = (vt.getTime() - _t.loadedTime.getTime()) / 1e3;
            x = Y.getManifestUpdatePeriod(_t, Pt), 1e3 * x > 2147483647 && (x = 2147483647e-3), f.trigger(et.A.MANIFEST_UPDATED, { manifest: _t }), M.info("Manifest has been refreshed at " + vt + "[" + vt.getTime() / 1e3 + "] "), O || ht();
          }
          function F() {
            O || (H ? ht(lt.get().streaming.manifestUpdateRetryInterval) : At());
          }
          function G(_t) {
            _t.error ? _t.error.code === X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE && J.error(_t.error) : Z(_t.manifest);
          }
          function K() {
            O = !1, ht();
          }
          function ft() {
            O = !lt.get().streaming.scheduling.scheduleWhilePaused, O && st();
          }
          function bt() {
            H = !1;
          }
          return v = { initialize: function() {
            at(), f.on(et.A.STREAMS_COMPOSED, bt, this), f.on(St.A.PLAYBACK_STARTED, K, this), f.on(St.A.PLAYBACK_PAUSED, ft, this), f.on(et.A.INTERNAL_MANIFEST_LOADED, G, this);
          }, setManifest: function(_t) {
            Z(_t);
          }, refreshManifest: At, getIsUpdating: function() {
            return H;
          }, setConfig: function(_t) {
            _t && (_t.manifestModel && (D = _t.manifestModel), _t.adapter && (Y = _t.adapter), _t.manifestLoader && (B = _t.manifestLoader), _t.errHandler && (J = _t.errHandler), _t.locationSelector && (N = _t.locationSelector), _t.settings && (lt = _t.settings), _t.contentSteeringController && (it = _t.contentSteeringController));
          }, reset: function() {
            f.off(St.A.PLAYBACK_STARTED, K, this), f.off(St.A.PLAYBACK_PAUSED, ft, this), f.off(et.A.STREAMS_COMPOSED, bt, this), f.off(et.A.INTERNAL_MANIFEST_LOADED, G, this), at();
          } }, M = (0, ae.A)(y).getInstance().getLogger(v), N = _e(y).create(), v;
        }
        en.__dashjs_factory_name = "ManifestUpdater";
        var Ne = Dt.A.getClassFactory(en);
        function xn() {
          const y = this.context, f = (0, It.A)(y).getInstance(), E = Se(y).getInstance();
          let v, M, x, z, O, k, H, B, D, N, Y, J, it, lt, at, st;
          function ht() {
            B = [], D = [], N = null, Y = null, it = null, J = NaN, x = !1, z = !1, lt = O.get().streaming.utcSynchronization.timeBetweenSyncAttempts;
          }
          function At() {
            O.get().streaming.utcSynchronization.enabled && !x && !z && it && it.value && it.schemeIdUri && !isNaN(J) && !isNaN(O.get().streaming.utcSynchronization.backgroundAttempts) && (Y && (Date.now() - Y) / 1e3 < 30 || (B = [], z = !0, Z(isNaN(O.get().streaming.utcSynchronization.backgroundAttempts) ? 2 : O.get().streaming.utcSynchronization.backgroundAttempts)));
          }
          function Z(nt) {
            try {
              if (nt <= 0) return void Tt();
              const ct = Date.now();
              k[it.schemeIdUri](it.value, function(V) {
                const mt = Date.now(), Mt = G(ct, mt, V);
                B.push(Mt), Z(nt - 1);
              }, function() {
                Tt();
              });
            } catch {
              Tt();
            }
          }
          function F() {
            let nt = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || 0;
            if (!D || D.length === 0 || nt >= D.length) return void K();
            let ct = D[nt];
            if (ct) if (k.hasOwnProperty(ct.schemeIdUri)) {
              const V = (/* @__PURE__ */ new Date()).getTime();
              k[ct.schemeIdUri](ct.value, function(mt) {
                const Mt = (/* @__PURE__ */ new Date()).getTime(), Lt = G(V, Mt, mt);
                it = ct, K(Lt);
              }, function() {
                F(nt + 1);
              });
            } else F(nt + 1);
            else K();
          }
          function G(nt, ct, V) {
            return V - (ct - (ct - nt) / 2);
          }
          function K() {
            let nt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN, ct = isNaN(nt);
            ct && O.get().streaming.utcSynchronization.useManifestDateHeaderTimeSource ? function() {
              let V = H.getLatestMPDRequestHeaderValueByID("Date"), mt = V !== null ? new Date(V).getTime() : Number.NaN;
              isNaN(mt) ? tt(!0) : tt(!1, mt - Date.now());
            }() : tt(ct, nt);
          }
          function ft(nt) {
            let ct = Date.parse(nt);
            return isNaN(ct) && (ct = function(V) {
              let mt, Mt, Lt = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+\-])([0-9]{2})([0-9]{2}))?/.exec(V);
              return mt = Date.UTC(parseInt(Lt[1], 10), parseInt(Lt[2], 10) - 1, parseInt(Lt[3], 10), parseInt(Lt[4], 10), parseInt(Lt[5], 10), Lt[6] && (parseInt(Lt[6], 10) || 0), Lt[7] && 1e3 * parseFloat(Lt[7]) || 0), Lt[9] && Lt[10] && (Mt = 60 * parseInt(Lt[9], 10) + parseInt(Lt[10], 10), mt += (Lt[8] === "+" ? -1 : 1) * Mt * 60 * 1e3), new Date(mt).getTime();
            }(nt)), ct;
          }
          function bt(nt) {
            return Date.parse(nt);
          }
          function _t(nt) {
            return Date.parse(nt);
          }
          function vt(nt, ct, V) {
            V();
          }
          function Pt(nt, ct, V) {
            let mt = ft(nt);
            isNaN(mt) ? V() : ct(mt);
          }
          function Ot(nt, ct, V, mt, Mt) {
            let Lt, Bt, Qt = !1, Zt = new XMLHttpRequest(), fe = Mt ? Ct.G.HEAD : Ct.G.GET, Ue = ct.match(/\S+/g);
            if (ct = Ue.shift(), Lt = function() {
              Qt || (Qt = !0, Ue.length ? Ot(nt, Ue.join(" "), V, mt, Mt) : mt());
            }, Bt = function() {
              let Ye, on;
              Zt.status === 200 && (Ye = Mt ? Zt.getResponseHeader("Date") : Zt.response, on = nt(Ye), isNaN(on) || (V(on), Qt = !0));
            }, E.isRelative(ct)) {
              const Ye = st.resolve();
              Ye && (ct = E.resolve(ct, Ye.url));
            }
            Zt.open(fe, ct), Zt.timeout = 5e3, Zt.onload = Bt, Zt.onloadend = Lt, Zt.send();
          }
          function W(nt, ct, V) {
            Ot(_t, nt, ct, V, !0);
          }
          function tt(nt, ct) {
            if (isNaN(J) || isNaN(ct) || nt || function(V) {
              try {
                const mt = yt(V), Mt = isNaN(lt) ? 30 : lt, Lt = isNaN(O.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor) ? 2 : O.get().streaming.utcSynchronization.timeBetweenSyncAttemptsAdjustmentFactor, Bt = isNaN(O.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts) ? 600 : O.get().streaming.utcSynchronization.maximumTimeBetweenSyncAttempts, Qt = isNaN(O.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts) ? 2 : O.get().streaming.utcSynchronization.minimumTimeBetweenSyncAttempts;
                let Zt;
                mt ? (Zt = Math.min(Mt * Lt, Bt), M.debug(`Increasing timeBetweenSyncAttempts to ${Zt}`)) : (Zt = Math.max(Mt / Lt, Qt), M.debug(`Decreasing timeBetweenSyncAttempts to ${Zt}`)), lt = Zt;
              } catch {
              }
            }(ct), !nt && !isNaN(ct)) {
              N = Date.now(), x = !1;
              const V = isNaN(J);
              J = ct, V && At(), M.debug(`Completed UTC sync. Setting client - server offset to ${ct}`);
            }
            nt && (it = null, x = !1, at.error(new Yt.A(X.TIME_SYNC_FAILED_ERROR_CODE, X.TIME_SYNC_FAILED_ERROR_MESSAGE))), f.trigger(et.A.UPDATE_TIME_SYNC_OFFSET, { offset: ct }), f.trigger(et.A.TIME_SYNCHRONIZATION_COMPLETED);
          }
          function Tt() {
            if (!B || B.length === 0) return;
            const nt = B.reduce((ct, V) => ct + V, 0) / B.length;
            yt(nt) ? M.debug("Completed background UTC sync. Offset is within allowed threshold and is not adjusted.") : (M.debug(`Completed background UTC sync. Setting client - server offset to ${nt}`), J = nt, f.trigger(et.A.UPDATE_TIME_SYNC_OFFSET, { offset: J })), z = !1, Y = Date.now();
          }
          function yt(nt) {
            try {
              if (isNaN(J)) return !0;
              const ct = O.get().streaming.utcSynchronization.maximumAllowedDrift && !isNaN(O.get().streaming.utcSynchronization.maximumAllowedDrift) ? O.get().streaming.utcSynchronization.maximumAllowedDrift : 100;
              return nt >= J - ct && nt <= J + ct;
            } catch {
              return !0;
            }
          }
          return v = { initialize: function() {
            ht(), k = { "urn:mpeg:dash:utc:http-head:2014": W, "urn:mpeg:dash:utc:http-xsdate:2014": Ot.bind(null, ft), "urn:mpeg:dash:utc:http-iso:2014": Ot.bind(null, bt), "urn:mpeg:dash:utc:direct:2014": Pt, "urn:mpeg:dash:utc:http-head:2012": W, "urn:mpeg:dash:utc:http-xsdate:2012": Ot.bind(null, ft), "urn:mpeg:dash:utc:http-iso:2012": Ot.bind(null, bt), "urn:mpeg:dash:utc:direct:2012": Pt, "urn:mpeg:dash:utc:http-ntp:2014": vt, "urn:mpeg:dash:utc:ntp:2014": vt, "urn:mpeg:dash:utc:sntp:2014": vt };
          }, attemptSync: function(nt, ct) {
            D = nt, x || (function(V) {
              try {
                if (!V || !O.get().streaming.utcSynchronization.enabled) return !1;
                const mt = isNaN(lt) ? 30 : lt;
                return !(N && mt && !isNaN(mt)) || (Date.now() - N) / 1e3 >= mt;
              } catch {
                return !0;
              }
            }(ct) ? (x = !0, F()) : f.trigger(et.A.TIME_SYNCHRONIZATION_COMPLETED));
          }, setConfig: function(nt) {
            nt && (nt.dashMetrics && (H = nt.dashMetrics), nt.baseURLController && (st = nt.baseURLController), nt.errHandler && (at = nt.errHandler), nt.settings && (O = nt.settings));
          }, reset: function() {
            ht(), f.off(et.A.ATTEMPT_BACKGROUND_SYNC, At, v);
          } }, M = (0, ae.A)(y).getInstance().getLogger(v), f.on(et.A.ATTEMPT_BACKGROUND_SYNC, At, v), v;
        }
        xn.__dashjs_factory_name = "TimeSyncController";
        const ti = Dt.A.getSingletonFactory(xn);
        ti.HTTP_TIMEOUT_MS = 5e3, Dt.A.updateSingletonFactory(xn.__dashjs_factory_name, ti);
        var ni = ti;
        function yi() {
          let y, f, E, v, M;
          const x = this.context, z = (0, It.A)(x).getInstance();
          return y = { attachMediaSource: function(O) {
            let k = window.URL.createObjectURL(f);
            return O.setSource(k), v === "managedMediaSource" && (O.setDisableRemotePlayback(!0), f.addEventListener("startstreaming", () => {
              z.trigger(St.A.MANAGED_MEDIA_SOURCE_START_STREAMING);
            }), f.addEventListener("endstreaming", () => {
              z.trigger(St.A.MANAGED_MEDIA_SOURCE_END_STREAMING);
            })), k;
          }, createMediaSource: function() {
            let O = "WebKitMediaSource" in window, k = "MediaSource" in window;
            return "ManagedMediaSource" in window ? (f = new ManagedMediaSource(), v = "managedMediaSource", M.info("Created ManagedMediaSource")) : k ? (f = new MediaSource(), v = "mediaSource", M.info("Created MediaSource")) : O && (f = new WebKitMediaSource(), M.info("Created WebkitMediaSource")), f;
          }, detachMediaSource: function(O) {
            O.setSource(null);
          }, setConfig: function(O) {
            O && O.settings && (E = O.settings);
          }, setDuration: function O(k) {
            f && f.readyState === "open" && (k === null && isNaN(k) || f.duration !== k && (k !== 1 / 0 || E.get().streaming.buffer.mediaSourceDurationInfinity || (k = Math.pow(2, 32)), function(H) {
              let B = H.sourceBuffers;
              for (let D = 0; D < B.length; D++) if (B[D].updating) return !0;
              return !1;
            }(f) ? setTimeout(O.bind(null, k), 50) : (M.info("Set MediaSource duration:" + k), f.duration = k)));
          }, setSeekable: function(O, k) {
            f && typeof f.setLiveSeekableRange == "function" && typeof f.clearLiveSeekableRange == "function" && f.readyState === "open" && O >= 0 && O < k && (f.clearLiveSeekableRange(), f.setLiveSeekableRange(O, k));
          }, signalEndOfStream: function(O) {
            if (!O || O.readyState !== "open") return;
            let k = O.sourceBuffers;
            for (let H = 0; H < k.length; H++)
              if (k[H].updating || k[H].buffered.length === 0) return;
            M.info("call to mediaSource endOfStream"), O.endOfStream();
          } }, M = (0, ae.A)(x).getInstance().getLogger(y), y;
        }
        yi.__dashjs_factory_name = "MediaSourceController";
        var Ni = Dt.A.getSingletonFactory(yi);
        function Wi() {
          const y = "urn:mpeg:dash:event:2012", E = "urn:mpeg:dash:event:callback:2015", x = "discarded", z = "updated", O = "added", k = this.context, H = (0, It.A)(k).getInstance();
          let B, D, N, Y, J, it, lt, at, st, ht, At;
          function Z() {
            if (!lt || !at) throw new Error("setConfig function has to be called previously");
          }
          function F() {
            At = !1, N = {}, Y = {}, J = null, ht = !1, it = Date.now() / 1e3;
          }
          function G() {
            try {
              if (!ht) {
                ht = !0;
                const tt = at.getTime();
                let Tt = tt - it;
                Tt = it > 0 ? Math.max(0, Tt) : 0, K(Y, Tt, tt), K(N, Tt, tt), ft(Y), ft(N), it = tt, ht = !1;
              }
            } catch (tt) {
              ht = !1, D.error(tt);
            }
          }
          function K(tt, Tt, yt) {
            try {
              Pt(tt, function(ct) {
                if (ct !== void 0) {
                  const V = isNaN(ct.duration) ? 0 : ct.duration;
                  ct.calculatedPresentationTime <= yt && ct.calculatedPresentationTime + Tt + V >= yt ? W(ct, St.A.EVENT_MODE_ON_START) : (Ot(yt, V + Tt, ct.calculatedPresentationTime) || function(mt) {
                    try {
                      const Mt = mt.eventStream.period.start + mt.eventStream.period.duration;
                      return mt.calculatedPresentationTime > Mt;
                    } catch (Mt) {
                      return D.error(Mt), !1;
                    }
                  }(ct)) && (D.debug(`Removing event ${ct.id} from period ${ct.eventStream.period.id} as it is expired or invalid`), function(mt, Mt) {
                    try {
                      const Lt = Mt.eventStream.schemeIdUri, Bt = Mt.eventStream.period.id, Qt = Mt.eventStream.value, Zt = Mt.id;
                      mt[Bt][Lt] = mt[Bt][Lt].filter((fe) => Qt && fe.eventStream.value && fe.eventStream.value !== Qt || fe.id !== Zt), mt[Bt][Lt].length === 0 && delete mt[Bt][Lt];
                    } catch (Lt) {
                      D.error(Lt);
                    }
                  }(tt, ct));
                }
              });
            } catch (nt) {
              D.error(nt);
            }
          }
          function ft(tt) {
            try {
              for (const Tt in tt) tt.hasOwnProperty(Tt) && Object.keys(tt[Tt]).length === 0 && delete tt[Tt];
            } catch (Tt) {
              D.error(Tt);
            }
          }
          function bt(tt, Tt) {
            let yt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            const nt = tt.eventStream.schemeIdUri, ct = tt.eventStream.value, V = tt.id;
            let mt = x;
            Tt[nt] || (Tt[nt] = []);
            const Mt = Tt[nt].findIndex((Lt) => (!ct || Lt.eventStream.value && Lt.eventStream.value === ct) && Lt.id === V);
            if (Mt === -1) Tt[nt].push(tt), tt.triggeredReceivedEvent = !1, tt.triggeredStartEvent = !1, mt = O;
            else if (yt) {
              const Lt = Tt[nt][Mt];
              tt.triggeredReceivedEvent = Lt.triggeredReceivedEvent, tt.triggeredStartEvent = Lt.triggeredStartEvent, Tt[nt][Mt] = tt, mt = z;
            }
            return mt;
          }
          function _t(tt) {
            try {
              if (tt.eventStream.value == 1) {
                const Tt = tt.calculatedPresentationTime;
                let yt;
                yt = tt.calculatedPresentationTime == 4294967295 ? NaN : tt.calculatedPresentationTime + tt.duration, H.trigger(St.A.MANIFEST_VALIDITY_CHANGED, { id: tt.id, validUntil: Tt, newDuration: yt, newManifestValidAfter: NaN }, { mode: St.A.EVENT_MODE_ON_START });
              }
            } catch (Tt) {
              D.error(Tt);
            }
          }
          function vt(tt) {
            try {
              const Tt = at.getTime();
              Pt(tt, function(yt) {
                const nt = yt.eventStream && yt.eventStream.period && !isNaN(yt.eventStream.period.duration) ? yt.eventStream.period.duration : NaN, ct = yt.eventStream && yt.eventStream.period && !isNaN(yt.eventStream.period.start) ? yt.eventStream.period.start : NaN;
                if (isNaN(nt) || isNaN(ct)) return;
                const V = yt.calculatedPresentationTime;
                Math.abs(V - Tt) < 300 && W(yt, St.A.EVENT_MODE_ON_START);
              });
            } catch (Tt) {
              D.error(Tt);
            }
          }
          function Pt(tt, Tt) {
            try {
              if (tt) {
                const yt = Object.keys(tt);
                for (let nt = 0; nt < yt.length; nt++) {
                  const ct = tt[yt[nt]], V = Object.keys(ct);
                  for (let mt = 0; mt < V.length; mt++) ct[V[mt]].forEach((Mt) => {
                    Mt !== void 0 && Tt(Mt);
                  });
                }
              }
            } catch (yt) {
              D.error(yt);
            }
          }
          function Ot(tt, Tt, yt) {
            try {
              return tt - Tt > yt;
            } catch (nt) {
              return D.error(nt), !1;
            }
          }
          function W(tt, Tt) {
            try {
              const yt = at.getTime(), nt = tt.id;
              if (Tt === St.A.EVENT_MODE_ON_RECEIVE && !tt.triggeredReceivedEvent) return D.debug(`Received event ${nt}`), tt.triggeredReceivedEvent = !0, void H.trigger(tt.eventStream.schemeIdUri, { event: JSON.parse(JSON.stringify(tt)) }, { mode: Tt });
              tt.triggeredStartEvent || (tt.eventStream.schemeIdUri === y && tt.eventStream.value == 1 ? tt.duration === 0 && tt.presentationTimeDelta === 0 || (D.debug(`Starting manifest refresh event ${nt} at ${yt}`), function() {
                try {
                  Z(), lt.refreshManifest();
                } catch (ct) {
                  D.error(ct);
                }
              }()) : tt.eventStream.schemeIdUri === E && tt.eventStream.value == 1 ? (D.debug(`Starting callback event ${nt} at ${yt}`), function(ct) {
                try {
                  Oi(k).create({}).load({ method: "get", url: ct, request: { responseType: "arraybuffer" } });
                } catch (V) {
                  D.error(V);
                }
              }(tt.messageData)) : (D.debug(`Starting event ${nt} from period ${tt.eventStream.period.id} at ${yt}`), H.trigger(tt.eventStream.schemeIdUri, { event: JSON.parse(JSON.stringify(tt)) }, { mode: Tt }), st.get().streaming.events.deleteEventMessageDataAfterEventStarted && (delete tt.messageData, delete tt.parsedMessageData)), tt.triggeredStartEvent = !0);
            } catch (yt) {
              D.error(yt);
            }
          }
          return B = { addInlineEvents: function(tt, Tt) {
            try {
              if (Z(), N[Tt] || (N[Tt] = {}), tt) for (let yt = 0; yt < tt.length; yt++) {
                let nt = tt[yt];
                if (!Ot(at.getTime(), isNaN(nt.duration) ? 0 : nt.duration, nt.calculatedPresentationTime)) {
                  let ct = bt(nt, N[Tt], !0);
                  ct === O ? (D.debug(`Added inline event with id ${nt.id} from period ${Tt}`), W(nt, St.A.EVENT_MODE_ON_RECEIVE)) : ct === z && D.debug(`Updated inline event with id ${nt.id} from period ${Tt}`);
                }
              }
            } catch (yt) {
              throw yt;
            }
          }, addInbandEvents: function(tt, Tt) {
            try {
              Z(), Y[Tt] || (Y[Tt] = {});
              for (let yt = 0; yt < tt.length; yt++) {
                let nt = tt[yt];
                Ot(at.getTime(), isNaN(nt.duration) ? 0 : nt.duration, nt.calculatedPresentationTime) || (bt(nt, Y[Tt], !1) === O ? (nt.eventStream.schemeIdUri === y && _t(nt), D.debug(`Added inband event with id ${nt.id} from period ${Tt}`), W(nt, St.A.EVENT_MODE_ON_RECEIVE)) : D.debug(`Inband event with scheme_id_uri ${nt.eventStream.schemeIdUri}, value ${nt.eventStream.value}, period id ${Tt} and event id ${nt.id} was ignored because it has been added before.`));
              }
              G();
            } catch (yt) {
              throw yt;
            }
          }, getInbandEvents: function() {
            return Y;
          }, getInlineEvents: function() {
            return N;
          }, start: function() {
            try {
              Z(), D.debug("Start Event Controller");
              const tt = st.get().streaming.events.eventControllerRefreshDelay;
              At || isNaN(tt) || (At = !0, J = setInterval(G, tt));
            } catch (tt) {
              throw tt;
            }
          }, setConfig: function(tt) {
            try {
              if (!tt) return;
              tt.manifestUpdater && (lt = tt.manifestUpdater), tt.playbackController && (at = tt.playbackController), tt.settings && (st = tt.settings);
            } catch (Tt) {
              throw Tt;
            }
          }, reset: function() {
            (function() {
              try {
                J !== null && At && (clearInterval(J), J = null, At = !1, function() {
                  try {
                    vt(Y), vt(N);
                  } catch (tt) {
                    D.error(tt);
                  }
                }());
              } catch (tt) {
                throw tt;
              }
            })(), F();
          } }, D = (0, ae.A)(k).getInstance().getLogger(B), F(), B;
        }
        Wi.__dashjs_factory_name = "EventController";
        var Pr = Dt.A.getSingletonFactory(Wi), pr = { LEVELS: { SUGGESTION: "Suggestion", WARNING: "Warning", ERROR: "Error" }, EVENTS: { NO_UTC_TIMING_ELEMENT: { key: "NO_UTC_TIMING_ELEMENT", message: "No UTCTiming element is present in the manifest. You may experience playback failures. For a detailed validation use https://conformance.dashif.org/" }, NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE: { key: "NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE", message: 'SMPTE 2052-1:2013 defines the attribute name as "imageType" and does not define "imagetype"' }, INVALID_DVR_WINDOW: { key: "INVALID_DVR_WINDOW", message: "No valid segment found when applying a specification compliant DVR window calculation. Using SegmentTimeline entries as a fallback." } } }, oo = b(445), ma = b(1923);
        function dd() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft, bt, _t, vt, Pt, Ot, W, tt, Tt, yt, nt, ct, V, mt, Mt, Lt, Bt, Qt, Zt, fe, Ue, Ye, on, cn, Nn, Qe;
          function hn() {
            if (!(O && O.hasOwnProperty("load") && G && G.hasOwnProperty("initialize") && G.hasOwnProperty("reset") && G.hasOwnProperty("getClientTimeOffset") && k && F && B && ct)) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          function Sn() {
            (function() {
              try {
                const re = H.getStreamsInfo();
                if (!ft && re.length === 0) throw new Error("There are no periods in the MPD");
                ft && re.length > 0 && B.updateManifestUpdateInfo({ currentTime: ct.getTime(), buffered: nt.getBufferRange(), presentationStartTime: re[0].start, clientTimeOffset: G.getClientTimeOffset() }), K.length > 0 && function(_n) {
                  _n.length !== 0 ? K = K.filter((Mn) => {
                    const qn = _n.filter((si) => si.id === Mn.getId()).length > 0 || Mn.getId() === ft.getId();
                    return qn || (v.debug(`Removing stream ${Mn.getId()}`), Mn.reset(!0), Mn = null), qn;
                  }) : v.warn("No periods included in the current manifest. Skipping the filtering of outdated stream objects.");
                }(re);
                const Ve = [];
                for (let _n = 0, Mn = re.length; _n < Mn; _n++) {
                  const qn = re[_n];
                  Ve.push(Ln(qn)), B.addManifestUpdateStreamInfo(qn);
                }
                Promise.all(Ve).then(() => new Promise((_n, Mn) => {
                  ft ? _n() : Rn(re, _n, Mn);
                })).then(() => {
                  f.trigger(et.A.STREAMS_COMPOSED), rn();
                }).catch((_n) => {
                  throw _n;
                });
              } catch (re) {
                F.error(new Yt.A(X.MANIFEST_ERROR_ID_NOSTREAMS_CODE, re.message + " nostreamscomposed", k.getValue())), Tt = !0, hs();
              }
            })();
          }
          function jn() {
            on = !0;
          }
          function Ln(re) {
            let Ve = Is(re.id);
            return Ve ? Ve.updateData(re) : (Ve = T(y).create({ manifestModel: k, mediaPlayerModel: mt, dashMetrics: B, manifestUpdater: z, adapter: H, timelineConverter: G, capabilities: M, capabilitiesFilter: x, errHandler: F, baseURLController: J, segmentBaseController: it, textController: _t, abrController: at, playbackController: ct, throughputController: st, eventController: At, mediaController: ht, protectionController: bt, videoModel: nt, streamInfo: re, settings: Ye }), K.push(Ve), Ve.initialize(), Promise.resolve());
          }
          function Rn(re, Ve, _n) {
            try {
              We();
              const Mn = B.getCurrentDVRInfo().range;
              if (Mn.end < Mn.start) {
                cn && clearTimeout(cn);
                const si = Math.min(1e3 * (-1 * (Mn.end - Mn.start) + 2), 2147483647);
                return v.debug(`Waiting for ${si} ms before playback can start`), f.trigger(et.A.AST_IN_FUTURE, { delay: si }), void (cn = setTimeout(() => {
                  Rn(re, Ve, _n);
                }, si));
              }
              Ye.get().streaming.applyProducerReferenceTime && V.calculateProducerReferenceTimeOffsets(re);
              const qn = re[0].manifestInfo;
              if (Ye.get().streaming.applyServiceDescription && V.applyServiceDescription(qn), H.getIsDynamic()) {
                const si = Wa(0, qn);
                ct.computeAndSetLiveDelay(si, qn);
              }
              (Ye.get().streaming.applyContentSteering && Y.shouldQueryBeforeStart() ? Y.loadSteeringData() : Promise.resolve()).then(() => {
                const si = k.getValue();
                si && J.update(si), $t(), Ve();
              }).catch((si) => {
                v.error(si), $t(), Ve();
              });
            } catch (Mn) {
              _n(Mn);
            }
          }
          function $t() {
            const re = function() {
              let Mn;
              if (H.getIsDynamic()) {
                const qn = B.getCurrentDVRInfo();
                Mn = (qn && qn.range ? qn.range.end : 0) - ct.getOriginalLiveDelay();
                const si = qn ? qn.range : null;
                if (si) {
                  if (isNaN(Nn) && Nn.toString().indexOf("posix:") === -1) {
                    const _r = Ui(!0);
                    isNaN(_r) || (v.info(`Start time from URI parameters: ${_r}`), Mn = Math.min(Mn, _r));
                  } else {
                    v.info(`Start time provided by the app: ${Nn}`);
                    const _r = zr(!0, Nn);
                    isNaN(_r) || (Mn = Math.min(Mn, _r));
                  }
                  const zi = Ye.get().streaming.timeShiftBuffer.calcFromSegmentTimeline ? 0.1 : 0;
                  Mn = Math.max(Mn, si.start + zi);
                }
              } else if (Mn = nl()[0].getStreamInfo().start, isNaN(Nn)) {
                const qn = Ui(!1);
                isNaN(qn) || (v.info(`Start time from URI parameters: ${qn}`), Mn = Math.max(Mn, qn));
              } else {
                v.info(`Start time provided by the app: ${Nn}`);
                const qn = zr(!1, Nn);
                isNaN(qn) || (Mn = Math.max(Mn, qn));
              }
              return Mn;
            }();
            let Ve = Le(re);
            const _n = Ve !== null ? Ve : K[0];
            f.trigger(et.A.INITIAL_STREAM_SWITCH, { startTime: re }), be(_n, null, re), Zt || (Zt = setInterval(function() {
              !W && ct.getTimeToStreamEnd() <= 0 && !ct.isSeeking() && f.trigger(et.A.PLAYBACK_ENDED, { isLast: $a().isLast });
            }, 200));
          }
          function be(re, Ve, _n) {
            try {
              if (W || !re || Ve === re && re.getIsActive()) return;
              W = !0, f.trigger(et.A.PERIOD_SWITCH_STARTED, { fromStreamInfo: Ve ? Ve.getStreamInfo() : null, toStreamInfo: re.getStreamInfo() });
              let Mn = !1, qn = [];
              ft = re, Ve && (Mn = gn(re, Ve), qn = ee(Ve), Ve.deactivate(Mn)), _n = isNaN(_n) ? !Mn && Ve ? re.getStreamInfo().start : NaN : _n, v.info(`Switch to stream ${re.getId()}. Seektime is ${_n}, current playback time is ${ct.getTime()}. Seamless period switch is set to ${Mn}`), Ue = Ue.filter((si) => si.getId() !== ft.getId()), ct.initialize($a(), !!Ve), nt.getElement() ? ge({ seekTime: _n, keepBuffers: Mn, streamActivated: !1, representationsFromPreviousPeriod: qn }) : Te({ seekTime: _n, keepBuffers: Mn });
            } catch {
              W = !1;
            }
          }
          function ge(re) {
            let Ve;
            function _n() {
              if (!yt || yt.readyState !== "open") return;
              v.debug("MediaSource is open!"), window.URL.revokeObjectURL(Ve), yt.removeEventListener("sourceopen", _n), yt.removeEventListener("webkitsourceopen", _n), wi();
              const qn = B.getCurrentDVRInfo();
              D.setSeekable(qn.range.start, qn.range.end), re.streamActivated ? (isNaN(re.seekTime) || ct.seek(re.seekTime, !0, !0), ft.setMediaSource(yt).then(() => {
                ft.initializeForTextWithMediaSource(yt);
              })) : Te(re);
            }
            function Mn() {
              yt.addEventListener("sourceopen", _n, !1), yt.addEventListener("webkitsourceopen", _n, !1), Ve = D.attachMediaSource(nt), v.debug("MediaSource attached to element.  Waiting on open...");
            }
            yt ? re.keepBuffers ? Te(re) : (D.detachMediaSource(nt), Mn()) : (yt = D.createMediaSource(), Mn());
          }
          function Te(re) {
            const Ve = re.representationsFromPreviousPeriod || [];
            ft.activate(yt, re.keepBuffers ? fe : void 0, Ve).then((_n) => {
              _n && (fe = _n), isNaN(re.seekTime) || (f.trigger(et.A.SEEK_TARGET, { time: re.seekTime }, { streamId: ft.getId() }), ct.seek(re.seekTime, !1, !0), ft.startScheduleControllers()), W = !1, f.trigger(et.A.PERIOD_SWITCH_COMPLETED, { toStreamInfo: $a() });
            });
          }
          function ee(re) {
            return (re ? re.getStreamProcessors() : []).map((Ve) => Ve.getRepresentation());
          }
          function De(re) {
            const Ve = Le(re.seekTime);
            Ve && Ve !== ft ? Ve && Ve !== ft && (Pe(), function(_n, Mn) {
              const qn = _n && !isNaN(_n.seekTime) ? _n.seekTime : NaN, si = ft.getStreamProcessors().map((zi) => zi.prepareOuterPeriodPlaybackSeeking(_n));
              Promise.all(si).then(() => {
                be(Mn, ft, qn);
              }).catch((zi) => {
                F.error(zi);
              });
            }(re, Ve)) : (Pe(), function(_n) {
              ft.getStreamProcessors().forEach((Mn) => Mn.prepareInnerPeriodPlaybackSeeking(_n)), _a(kn.USER_REQUEST_STOP_REASON);
            }(re)), Ar($e.SEEK_START_REASON);
          }
          function Pe() {
            nn();
          }
          function nn() {
            Ue && Ue.length > 0 && (Ue.forEach((re) => {
              re.deactivate(!0);
            }), Ue = []);
          }
          function sn(re) {
            if (re.newMediaInfo.streamInfo.id === ft.getId()) {
              if (nn(), Ye.get().streaming.buffer.resetSourceBuffersForTrackSwitch && re.oldMediaInfo && re.oldMediaInfo.codec !== re.newMediaInfo.codec) {
                const Ve = ct.getTime();
                return ft.deactivate(!1), void ge({ seekTime: Ve, keepBuffers: !1, streamActivated: !1 });
              }
              ft.prepareTrackChange(re);
            }
          }
          function gn(re, Ve) {
            try {
              return Ye.get().streaming.buffer.reuseExistingSourceBuffers && (M.isProtectionCompatible(Ve.getStreamInfo(), re.getStreamInfo()) || on) && M.supportsChangeType() && Ye.get().streaming.buffer.useChangeType;
            } catch {
              return !1;
            }
          }
          function ie(re) {
            let Ve = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (yt && !re.getPreloaded() && gn(re, Ve)) {
              const _n = ee(Ve);
              re.startPreloading(yt, fe, _n).then(() => {
                Ue.push(re);
              });
            }
          }
          function Le(re) {
            if (isNaN(re)) return null;
            const Ve = K.length;
            for (let _n = 0; _n < Ve; _n++) {
              const Mn = K[_n];
              if (re < parseFloat((Mn.getStartTime() + Mn.getDuration()).toFixed(5))) return Mn;
            }
            return null;
          }
          function We() {
            try {
              const re = H.getIsDynamic(), Ve = H.getStreamsInfo()[0].manifestInfo, _n = ct.getTime(), Mn = G.calcTimeShiftBufferWindow(K, re), qn = Un();
              if (Mn.start === void 0 || Mn.end === void 0) return;
              qn && qn.length !== 0 ? qn.forEach((si) => {
                B.addDVRInfo(si.getType(), _n, Ve, Mn);
              }) : B.addDVRInfo(q.A.VIDEO, _n, Ve, Mn);
            } catch {
            }
          }
          function ln(re) {
            if (Bt && Ot) {
              const Ve = mt.getInitialBufferLevel(), _n = [q.A.TEXT];
              (isNaN(Ve) || Ve <= ct.getBufferLevel(_n) || H.getIsDynamic() && Ve > ct.getLiveDelay()) && (Bt = !1, Ar($e.INITIAL_PLAYOUT_START_REASON), ct.play());
            }
            re && re.mediaType && B.addBufferLevel(re.mediaType, /* @__PURE__ */ new Date(), 1e3 * re.bufferLevel);
          }
          function ye(re) {
            re.streamInfo.id === ft.getId() && nn(), Is(re.streamInfo.id).prepareQualityChange(re);
          }
          function Rt() {
            if (H.getIsDynamic() && ct.getOriginalLiveDelay() !== 0 && ft) {
              const re = H.getStreamsInfo();
              if (re.length > 0) {
                const Ve = re[0].manifestInfo, _n = Wa(0, Ve);
                ct.computeAndSetLiveDelay(_n, Ve);
              }
            }
          }
          function Wt() {
            if (Ds()) {
              const re = nt.getPlaybackQuality();
              re && B.addDroppedFrames(re);
            }
          }
          function Ee() {
            v.debug("[onPlaybackStarted]"), !Bt && Lt && Ar($e.RESUME_FROM_PAUSE_START_REASON), Bt && (Bt = !1), Qt && (Qt = !1, Ye.get().streaming.applyContentSteering && !Y.shouldQueryBeforeStart() && Y.loadSteeringData()), Lt = !1;
          }
          function te(re) {
            v.debug("[onPlaybackPaused]"), re.ended || (Lt = !0, _a(kn.USER_REQUEST_STOP_REASON));
          }
          function Ie(re) {
            v.debug(`Stream with id ${re.streamInfo.id} finished buffering`);
            const Ve = re.streamInfo.isLast;
            yt && Ve ? (v.info("[onStreamBufferingCompleted] calls signalEndOfStream of mediaSourceController."), D.signalEndOfStream(yt)) : rn();
          }
          function rn() {
            if (!ft) return;
            if (!ft.getHasFinishedBuffering()) return void ft.checkAndHandleCompletedBuffering();
            const re = function() {
              let _n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
              try {
                const Mn = _n || ft || null;
                if (Mn) {
                  const qn = Mn.getStreamInfo();
                  return K.filter(function(si) {
                    const zi = si.getStreamInfo();
                    return zi.start > qn.start && qn.id !== zi.id;
                  });
                }
              } catch {
                return [];
              }
            }(ft);
            let Ve = 0;
            for (; Ve < re.length; ) {
              const _n = re[Ve], Mn = Ve === 0 ? ft : re[Ve - 1];
              !_n.getPreloaded() && Mn.getHasFinishedBuffering() && yt && ie(_n, Mn), Ve += 1;
            }
          }
          function Tn() {
            Zt && (clearInterval(Zt), Zt = null);
          }
          function Un() {
            return ft ? ft.getStreamProcessors() : [];
          }
          function Cn(re) {
            if (ft && !ft.getIsEndedEventSignaled()) {
              ft.setIsEndedEventSignaled(!0);
              const Ve = function() {
                const _n = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null) || ft || null;
                if (!_n) return null;
                const Mn = _n.getStreamInfo(), qn = Mn.start;
                let si = 0, zi = -1, _r = NaN;
                for (; si < K.length; ) {
                  const Hc = K[si].getStreamInfo(), lu = Hc.start - qn;
                  lu > 0 && (isNaN(_r) || lu < _r) && Mn.id !== Hc.id && (_r = lu, zi = si), si += 1;
                }
                return zi >= 0 ? K[zi] : null;
              }();
              Ve ? (v.debug(`StreamController onEnded, found next stream with id ${Ve.getStreamInfo().id}. Switching from ${ft.getStreamInfo().id} to ${Ve.getStreamInfo().id}`), be(Ve, ft, NaN)) : (v.debug("StreamController no next stream found"), ft.setIsEndedEventSignaled(!1)), _a(Ve ? kn.END_OF_PERIOD_STOP_REASON : kn.END_OF_CONTENT_STOP_REASON);
            }
            re && re.isLast && (Tn(), Y.stopSteeringRequestTimer());
          }
          function wi(re) {
            const Ve = re || $a().manifestInfo.duration;
            D.setDuration(Ve);
          }
          function Ui(re) {
            const Ve = lt.getURIFragmentData();
            if (!Ve || !Ve.t) return NaN;
            const _n = nl()[0].getStreamInfo().start;
            return Ve.t = Ve.t.split(",")[0], Ji(re, Ve.t, _n);
          }
          function zr(re, Ve) {
            let _n = 0;
            return re || (_n = nl()[0].getStreamInfo().start), Ji(re, Ve, _n);
          }
          function Ji(re, Ve, _n) {
            const Mn = H.getRegularPeriods()[0], qn = Ve.toString(), si = qn.indexOf("posix:") !== -1 ? qn.substring(6) === "now" ? Date.now() / 1e3 : parseFloat(qn.substring(6)) : NaN;
            return re && !isNaN(si) ? G.calcPresentationTimeFromWallTime(new Date(1e3 * si), Mn) : parseFloat(qn) + _n;
          }
          function Wa(re, Ve) {
            try {
              let _n = NaN;
              return Ve && !isNaN(Ve.maxFragmentDuration) && isFinite(Ve.maxFragmentDuration) ? Ve.maxFragmentDuration : isFinite(_n) ? _n : NaN;
            } catch {
              return NaN;
            }
          }
          function cs(re) {
            if (re.error) Tt = !0, hs();
            else {
              v.info("Manifest updated... updating data system wide.");
              const Ve = re.manifest;
              H.updatePeriods(Ve), x.filterUnsupportedFeatures(Ve).then(() => {
                J.initialize(Ve);
                let _n = H.getUTCTimingSources();
                !H.getIsDynamic() || _n && _n.length !== 0 || f.trigger(St.A.CONFORMANCE_VIOLATION, { level: pr.LEVELS.WARNING, event: pr.EVENTS.NO_UTC_TIMING_ELEMENT });
                let Mn = H.getIsDynamic() ? _n.concat(Mt.getUTCTimingSources()) : _n;
                N.attemptSync(Mn, H.getIsDynamic()), Pt.createFinalQueryStrings(Ve);
              });
            }
          }
          function Ds() {
            return !!ft && ft.getHasVideoTrack();
          }
          function Xr() {
            return !!ft && ft.getHasAudioTrack();
          }
          function _a(re, Ve) {
            Ve = Ve || /* @__PURE__ */ new Date(), Un().forEach((_n) => {
              _n.finalisePlayList(Ve, re);
            }), B.addPlayList();
          }
          function Ar(re) {
            B.createPlaylistMetrics(1e3 * ct.getTime(), re);
          }
          function Qr(re) {
            bt.updateKeyStatusesMap(re), function() {
              const Ve = Un();
              let _n = !1;
              Ve.forEach((Mn) => {
                const qn = Mn.getMediaInfo();
                !qn || M.areKeyIdsUsable(qn) ? qn && M.areKeyIdsExpired(qn) && function(si) {
                  const zi = Is(si.getStreamId());
                  zi && zi.triggerProtectionError({ error: new Yt.A(ma.A.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE, ma.A.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE) });
                }(Mn) : (_n = !0, function(si) {
                  const zi = si.getAllMediaInfos().filter((_r) => M.areKeyIdsUsable(_r));
                  if (zi && zi.length !== 0) ht.setTrack(zi[0], { replaceBuffer: !0 });
                  else {
                    const _r = si.getType();
                    F.error(new Yt.A(X.NO_SUPPORTED_KEY_IDS, `Type: ${_r}: ${X.NO_SUPPORTED_KEY_IDS_MESSAGE}`));
                  }
                }(Mn));
              }), _n && (ct.getTime() === 0 ? f.once(St.A.FRAGMENT_LOADING_COMPLETED, () => {
                Ka();
              }, E) : ct.isProgressing(500).then((Mn) => {
                Mn || Ka();
              }));
            }();
          }
          function Ka() {
            const re = ct.getTime();
            ct.seek(re + 0.01, !1, !1);
          }
          function el(re) {
            if (!re.error) return;
            let Ve;
            switch (re.error.code) {
              case 1:
                Ve = "MEDIA_ERR_ABORTED";
                break;
              case 2:
                Ve = "MEDIA_ERR_NETWORK";
                break;
              case 3:
                Ve = "MEDIA_ERR_DECODE", Qe.counts.mediaErrorDecode += 1;
                break;
              case 4:
                Ve = "MEDIA_ERR_SRC_NOT_SUPPORTED";
                break;
              case 5:
                Ve = "MEDIA_ERR_ENCRYPTED";
                break;
              default:
                Ve = "UNKNOWN";
            }
            Ve === "MEDIA_ERR_DECODE" && Ye.get().errors.recoverAttempts.mediaErrorDecode >= Qe.counts.mediaErrorDecode ? function() {
              v.error("A MEDIA_ERR_DECODE occured: Resetting the MediaSource");
              const _n = ct.getTime();
              ft.deactivate(!1), v.info(`MediaSource has been resetted. Resuming playback from time ${_n}`), ge({ seekTime: _n, keepBuffers: !1, streamActivated: !1 });
            }() : (tt = !0, re.error.message && (Ve += " (" + re.error.message + ")"), re.error.msExtendedCode && (Ve += " (0x" + (re.error.msExtendedCode >>> 0).toString(16).toUpperCase() + ")"), v.fatal("Video Element Error: " + Ve), re.error && v.fatal(re.error), F.error(new Yt.A(re.error.code, Ve)), hs());
          }
          function $a() {
            return ft ? ft.getStreamInfo() : null;
          }
          function Is(re) {
            for (let Ve = 0, _n = K.length; Ve < _n; Ve++) if (K[Ve].getId() === re) return K[Ve];
            return null;
          }
          function Or(re) {
            isNaN(re.newDuration) || wi(re.newDuration);
          }
          function Rs() {
            K = [], Nn = NaN, bt = null, W = !1, ft = null, tt = !1, Tt = !1, Bt = !0, Qt = !0, Lt = !1, Ot = !0, Zt = null, on = !1, Ue = [], cn = null, Qe = { counts: { mediaErrorDecode: 0 } };
          }
          function hs() {
            hn(), N.reset(), _a(tt || Tt ? kn.FAILURE_STOP_REASON : kn.USER_REQUEST_STOP_REASON);
            for (let re = 0, Ve = K ? K.length : 0; re < Ve; re++) K[re].reset(tt);
            f.off(St.A.PLAYBACK_TIME_UPDATED, Wt, E), f.off(St.A.PLAYBACK_SEEKING, De, E), f.off(St.A.PLAYBACK_ERROR, el, E), f.off(St.A.PLAYBACK_STARTED, Ee, E), f.off(St.A.PLAYBACK_PAUSED, te, E), f.off(St.A.PLAYBACK_ENDED, Cn, E), f.off(St.A.METRIC_ADDED, Bc, E), f.off(St.A.MANIFEST_VALIDITY_CHANGED, Or, E), f.off(St.A.BUFFER_LEVEL_UPDATED, ln, E), f.off(St.A.QUALITY_CHANGE_REQUESTED, ye, E), et.A.KEY_SESSION_UPDATED && f.off(et.A.KEY_SESSION_UPDATED, jn, E), f.off(et.A.MANIFEST_UPDATED, cs, E), f.off(et.A.STREAM_BUFFERING_COMPLETED, Ie, E), f.off(et.A.TIME_SYNCHRONIZATION_COMPLETED, Sn, E), f.off(et.A.CURRENT_TRACK_CHANGED, sn, E), f.off(et.A.SETTING_UPDATED_LIVE_DELAY, Rt, E), f.off(et.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, Rt, E), f.off(oo.A.INTERNAL_KEY_STATUSES_CHANGED, Qr, E), J.reset(), z.reset(), At.reset(), B.clearAllCurrentMetrics(), k.setValue(null), O.reset(), G.reset(), Z.reset(), yt && (D.detachMediaSource(nt), yt = null), nt = null, bt && (bt = null, vt = null, k.getValue() && f.trigger(et.A.PROTECTION_DESTROYED, { data: k.getValue().url })), Tn(), f.trigger(et.A.STREAM_TEARDOWN_COMPLETE), Rs();
          }
          function Bc(re) {
            if (re.metric === pt.DVR_INFO) {
              const Ve = Xr() ? q.A.AUDIO : q.A.VIDEO;
              re.mediaType === Ve && D.setSeekable(re.value.range.start, re.value.range.end);
            }
          }
          function nl() {
            return K;
          }
          return E = { addDVRMetric: We, getActiveStream: function() {
            return ft;
          }, getActiveStreamInfo: $a, getActiveStreamProcessors: Un, getAutoPlay: function() {
            return Ot;
          }, getHasMediaOrInitialisationError: function() {
            return tt || Tt;
          }, getInitialPlayback: function() {
            return Bt;
          }, getIsStreamSwitchInProgress: function() {
            return W;
          }, getStreamById: Is, getStreamForTime: Le, getStreams: nl, getTimeRelativeToStreamId: function(re, Ve) {
            let _n = null, Mn = 0, qn = 0, si = null;
            for (let zi = 0; zi < K.length; zi++) {
              if (_n = K[zi], qn = _n.getStartTime(), si = _n.getDuration(), Number.isFinite(qn) && (Mn = qn), _n.getId() === Ve) return re - Mn;
              Number.isFinite(si) && (Mn += si);
            }
            return null;
          }, hasAudioTrack: Xr, hasVideoTrack: Ds, initialize: function(re, Ve) {
            hn(), Ot = re, vt = Ve, G.initialize(), z = Ne(y).create(), z.setConfig({ manifestModel: k, adapter: H, manifestLoader: O, errHandler: F, settings: Ye, contentSteeringController: Y }), z.initialize(), At = Pr(y).getInstance(), At.setConfig({ manifestUpdater: z, playbackController: ct, settings: Ye }), At.start(), Pt = Es(y).getInstance(), N.setConfig({ dashMetrics: B, baseURLController: J, errHandler: F, settings: Ye }), N.initialize(), D.setConfig({ settings: Ye }), bt && (f.trigger(et.A.PROTECTION_CREATED, { controller: bt }), bt.setMediaElement(nt.getElement()), vt && bt.setProtectionData(vt)), f.on(St.A.PLAYBACK_TIME_UPDATED, Wt, E), f.on(St.A.PLAYBACK_SEEKING, De, E), f.on(St.A.PLAYBACK_ERROR, el, E), f.on(St.A.PLAYBACK_STARTED, Ee, E), f.on(St.A.PLAYBACK_PAUSED, te, E), f.on(St.A.PLAYBACK_ENDED, Cn, E), f.on(St.A.METRIC_ADDED, Bc, E), f.on(St.A.MANIFEST_VALIDITY_CHANGED, Or, E), f.on(St.A.BUFFER_LEVEL_UPDATED, ln, E), f.on(St.A.QUALITY_CHANGE_REQUESTED, ye, E), et.A.KEY_SESSION_UPDATED && f.on(et.A.KEY_SESSION_UPDATED, jn, E), f.on(et.A.MANIFEST_UPDATED, cs, E), f.on(et.A.STREAM_BUFFERING_COMPLETED, Ie, E), f.on(et.A.TIME_SYNCHRONIZATION_COMPLETED, Sn, E), f.on(et.A.CURRENT_TRACK_CHANGED, sn, E), f.on(et.A.SETTING_UPDATED_LIVE_DELAY, Rt, E), f.on(et.A.SETTING_UPDATED_LIVE_DELAY_FRAGMENT_COUNT, Rt, E), f.on(oo.A.INTERNAL_KEY_STATUSES_CHANGED, Qr, E);
          }, load: function(re) {
            let Ve = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            hn(), Nn = Ve, O.load(re);
          }, loadWithManifest: function(re) {
            let Ve = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            (function() {
              if (!z || !z.hasOwnProperty("setManifest")) throw new Error("initialize function has to be called previously");
            })(), Nn = Ve, z.setManifest(re);
          }, refreshManifest: function() {
            z.getIsUpdating() || z.refreshManifest();
          }, reset: hs, setConfig: function(re) {
            re && (re.capabilities && (M = re.capabilities), re.capabilitiesFilter && (x = re.capabilitiesFilter), re.manifestLoader && (O = re.manifestLoader), re.manifestModel && (k = re.manifestModel), re.mediaPlayerModel && (mt = re.mediaPlayerModel), re.customParametersModel && (Mt = re.customParametersModel), re.protectionController && (bt = re.protectionController), re.adapter && (H = re.adapter), re.dashMetrics && (B = re.dashMetrics), re.errHandler && (F = re.errHandler), re.timelineConverter && (G = re.timelineConverter), re.videoModel && (nt = re.videoModel), re.playbackController && (ct = re.playbackController), re.throughputController && (st = re.throughputController), re.serviceDescriptionController && (V = re.serviceDescriptionController), re.contentSteeringController && (Y = re.contentSteeringController), re.textController && (_t = re.textController), re.abrController && (at = re.abrController), re.mediaController && (ht = re.mediaController), re.settings && (Ye = re.settings), re.baseURLController && (J = re.baseURLController), re.uriFragmentModel && (lt = re.uriFragmentModel), re.segmentBaseController && (it = re.segmentBaseController), re.manifestUpdater && (z = re.manifestUpdater));
          }, setProtectionData: function(re) {
            vt = re, bt && bt.setProtectionData(vt);
          }, switchToVideoElement: function(re) {
            ft && (ct.initialize($a()), ge({ seekTime: re, keepBuffers: !1, streamActivated: !0 }));
          } }, v = (0, ae.A)(y).getInstance().getLogger(E), N = ni(y).getInstance(), D = Ni(y).getInstance(), Z = ne(y).getInstance(), Rs(), E;
        }
        dd.__dashjs_factory_name = "StreamController";
        var cd = Dt.A.getSingletonFactory(dd);
        function hd() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D, N, Y;
          function J() {
            Y.debug("Stopping the gap controller"), z && (clearInterval(z), z = null), function() {
              f.off(et.A.WALLCLOCK_TIME_UPDATED, ht, this), f.off(et.A.INITIAL_STREAM_SWITCH, st, this), f.off(et.A.PLAYBACK_SEEKING, it, this), f.off(et.A.BUFFER_REPLACEMENT_STARTED, lt, E), f.off(et.A.TRACK_CHANGE_RENDERED, at, E);
            }(), z = null, O = NaN, x = 0, D = null, N = {};
          }
          function it() {
            D && (clearTimeout(D), D = null);
          }
          function lt(F) {
            try {
              if (F.streamId !== H.getActiveStreamInfo().id || F.mediaType !== q.A.VIDEO && F.mediaType !== q.A.AUDIO && F.mediaType !== q.A.MESH) return;
              F.streamId === H.getActiveStreamInfo().id && (N[F.mediaType] = !0);
            } catch (G) {
              Y.error(G);
            }
          }
          function at(F) {
            F && F.mediaType && (N[F.mediaType] = !1);
          }
          function st() {
            z || function() {
              try {
                z || (Y.debug("Starting the gap controller"), z = setInterval(() => {
                  At() && Z(k.getTime());
                }, 100));
              } catch {
              }
            }();
          }
          function ht() {
            if (At(M.get().streaming.gaps.enableSeekFix) && (x++, x >= 10)) {
              const F = k.getTime();
              v === F ? Z(F, !0) : (v = F, O = NaN), x = 0;
            }
          }
          function At() {
            let F = arguments.length > 0 && arguments[0] !== void 0 && arguments[0];
            if (!H.getActiveStream()) return !1;
            const G = Object.keys(N).some((ft) => N[ft]), K = !!F && function() {
              const ft = H.getActiveStream(), bt = parseFloat((ft.getStartTime() + ft.getDuration()).toFixed(5));
              return k.getTime() + M.get().streaming.gaps.threshold >= bt;
            }();
            return !G && M.get().streaming.gaps.jumpGaps && H.getActiveStreamProcessors().length > 0 && (!k.isSeeking() || K) && !k.isPaused() && !H.getIsStreamSwitchInProgress() && !H.getHasMediaOrInitialisationError();
          }
          function Z(F) {
            let G = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            const K = M.get().streaming.gaps.enableStallFix, ft = M.get().streaming.gaps.stallSeek, bt = M.get().streaming.gaps.smallGapLimit, _t = M.get().streaming.gaps.jumpLargeGaps, vt = B.getBufferRange();
            let Pt, Ot = NaN, W = !1;
            if (Pt = function(Tt, yt) {
              try {
                if (!Tt || Tt.length <= 1 && yt > 0) return NaN;
                let nt = NaN, ct = 0;
                for (; isNaN(nt) && ct < Tt.length; ) {
                  const V = ct > 0 ? Tt.end(ct - 1) : 0;
                  yt < Tt.start(ct) && V - yt < M.get().streaming.gaps.threshold && (nt = ct), ct += 1;
                }
                return nt;
              } catch {
                return null;
              }
            }(vt, F), !isNaN(Pt)) {
              const Tt = vt.start(Pt), yt = Tt - F;
              yt > 0 && (yt <= bt || _t) && (Ot = Tt);
            }
            const tt = k.getTimeToStreamEnd();
            if (isNaN(Ot) && G && isFinite(tt) && !isNaN(tt) && tt < bt && (Ot = parseFloat(k.getStreamEndTime().toFixed(5)), W = !0), K && isNaN(Ot) && G && isNaN(Pt) && function(Tt, yt) {
              for (let nt = 0, ct = Tt.length; nt < ct; nt++) if (yt >= Tt.start(nt) && yt <= Tt.end(nt)) return !0;
              return !1;
            }(vt, F) && (ft === 0 ? (Y.warn("Toggle play pause to break stall"), B.pause(), B.play()) : (Y.warn(`Jumping ${ft}s to break stall`), Ot = F + ft)), Ot > 0 && O !== Ot && Ot > F && !D) {
              const Tt = Ot - F;
              if (W) {
                const yt = H.getStreamForTime(Ot), nt = yt && !!yt.getPreloaded();
                Y.warn(`Jumping to end of stream because of gap from ${F} to ${Ot}. Gap duration: ${Tt}`), k.seek(Ot, !0, nt);
              } else {
                const yt = k.getIsDynamic(), nt = Pt > 0 ? vt.end(Pt - 1) : F, ct = yt ? 1e3 * Math.max(0, Tt - 0.1) : 0;
                D = window.setTimeout(() => {
                  k.seek(Ot, !0, !0), Y.warn(`Jumping gap occuring in period ${H.getActiveStream().getStreamId()} starting at ${nt} and ending at ${Ot}. Jumping by: ${Ot - nt}`), D = null;
                }, ct);
              }
              O = Ot;
            }
          }
          return E = { reset: J, setConfig: function(F) {
            F && (F.settings && (M = F.settings), F.playbackController && (k = F.playbackController), F.streamController && (H = F.streamController), F.videoModel && (B = F.videoModel));
          }, initialize: function() {
            (function() {
              f.on(et.A.WALLCLOCK_TIME_UPDATED, ht, this), f.on(et.A.INITIAL_STREAM_SWITCH, st, this), f.on(et.A.PLAYBACK_SEEKING, it, this), f.on(et.A.BUFFER_REPLACEMENT_STARTED, lt, E), f.on(et.A.TRACK_CHANGE_RENDERED, at, E);
            })();
          } }, Y = (0, ae.A)(y).getInstance().getLogger(E), J(), E;
        }
        hd.__dashjs_factory_name = "GapController";
        var Mm = Dt.A.getSingletonFactory(hd);
        function fd() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D;
          function N() {
            v = !1;
            const Z = ai.A.parseUserAgent();
            M = Z && Z.browser && Z.browser.name && Z.browser.name.toLowerCase() === "safari";
          }
          function Y() {
            v = !1;
          }
          function J(Z) {
            if (Z.streamId !== O.getActiveStreamInfo().id || !B) return;
            const F = k.getLiveDelay();
            k.getBufferLevel() > F / 2 && (B = !1);
          }
          function it(Z) {
            Z.streamId === O.getActiveStreamInfo().id && (B = Z.state === pt.BUFFER_EMPTY);
          }
          function lt() {
            H.getCatchupModeEnabled() || x.setPlaybackRate(1);
          }
          function at() {
            k.getIsDynamic() && H.getCatchupModeEnabled() && (H.getCatchupPlaybackRates().max > 0 || H.getCatchupPlaybackRates().min < 0) && !k.isPaused() && !k.isSeeking() && function() {
              try {
                return !k.getTime() > 0 || v ? !1 : ht() === q.A.LIVE_CATCHUP_MODE_LOLP ? function(Z, F) {
                  try {
                    return Math.abs(st()) > 0 || Z < F;
                  } catch {
                    return !1;
                  }
                }(k.getBufferLevel(), z.get().streaming.liveCatchup.playbackBufferMin) : function() {
                  try {
                    return Math.abs(st()) > 0;
                  } catch {
                    return !1;
                  }
                }();
              } catch {
                return !1;
              }
            }() && function() {
              if (!v && x) {
                let Z;
                const F = x.getPlaybackRate(), G = H.getCatchupPlaybackRates(), K = k.getBufferLevel(), ft = st(), bt = H.getCatchupMaxDrift();
                if (!isNaN(bt) && bt > 0 && ft > bt) D.info("[CatchupController]: Low Latency catchup mechanism. Latency too high, doing a seek to live point"), v = !0, k.seekToCurrentLive(!0, !1);
                else {
                  const _t = k.getCurrentLiveLatency(), vt = k.getLiveDelay();
                  Z = ht() === q.A.LIVE_CATCHUP_MODE_LOLP ? function(Ot, W, tt, Tt, yt) {
                    let nt;
                    if (yt < Tt) {
                      const ct = Math.abs(Ot.min), V = 5 * (yt - Tt);
                      nt = 1 - ct + 2 * ct / (1 + Math.pow(Math.E, -V)), D.debug("[LoL+ playback control_buffer-based] bufferLevel: " + yt + ", newRate: " + nt);
                    } else {
                      if (Math.abs(W - tt) <= 0.02 * tt) nt = 1;
                      else {
                        const V = W - tt, mt = V < 0 ? Math.abs(Ot.min) : Ot.max, Mt = 5 * V;
                        nt = 1 - mt + 2 * mt / (1 + Math.pow(Math.E, -Mt));
                      }
                      D.debug("[LoL+ playback control_latency-based] latency: " + W + ", newRate: " + nt);
                    }
                    return nt;
                  }(G, _t, vt, z.get().streaming.liveCatchup.playbackBufferMin, K) : function(Ot, W, tt, Tt) {
                    if (B) return 1;
                    const yt = W - tt, nt = yt < 0 ? Math.abs(Ot.min) : Ot.max, ct = 5 * yt;
                    let V = 1 - nt + 2 * nt / (1 + Math.pow(Math.E, -ct));
                    return k.getPlaybackStalled() && Tt <= tt / 2 && yt > 0 && (V = 1), V;
                  }(G, _t, vt, K);
                  const Pt = M ? 0.25 : 0.02 / (0.5 / G.max);
                  (Z && Math.abs(F - Z) >= Pt || Z == 1) && (D.debug(`[CatchupController]: Setting playback rate to ${Z}`), x.setPlaybackRate(Z));
                }
              }
            }();
          }
          function st() {
            return k.getCurrentLiveLatency() - k.getLiveDelay();
          }
          function ht() {
            const Z = z.get().streaming.liveCatchup.playbackBufferMin;
            return z.get().streaming.liveCatchup.mode !== q.A.LIVE_CATCHUP_MODE_LOLP || Z === null || isNaN(Z) ? q.A.LIVE_CATCHUP_MODE_DEFAULT : q.A.LIVE_CATCHUP_MODE_LOLP;
          }
          function At() {
            H.getCatchupPlaybackRates(!0);
          }
          return E = { reset: function() {
            f.off(St.A.BUFFER_LEVEL_UPDATED, J, E), f.off(St.A.BUFFER_LEVEL_STATE_CHANGED, it, E), f.off(St.A.PLAYBACK_PROGRESS, at, E), f.off(St.A.PLAYBACK_TIME_UPDATED, at, E), f.off(St.A.PLAYBACK_SEEKED, Y, E), f.off(et.A.SETTING_UPDATED_CATCHUP_ENABLED, lt, E), f.off(et.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, At, E), f.off(et.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, At, E), f.off(St.A.STREAM_INITIALIZED, At, E), N(), x.setPlaybackRate(1, !0);
          }, setConfig: function(Z) {
            Z && (Z.settings && (z = Z.settings), Z.videoModel && (x = Z.videoModel), Z.streamController && (O = Z.streamController), Z.playbackController && (k = Z.playbackController), Z.mediaPlayerModel && (H = Z.mediaPlayerModel));
          }, initialize: function() {
            f.on(St.A.BUFFER_LEVEL_UPDATED, J, E), f.on(St.A.BUFFER_LEVEL_STATE_CHANGED, it, E), f.on(St.A.PLAYBACK_PROGRESS, at, E), f.on(St.A.PLAYBACK_TIME_UPDATED, at, E), f.on(St.A.PLAYBACK_SEEKED, Y, E), f.on(et.A.SETTING_UPDATED_CATCHUP_ENABLED, lt, E), f.on(et.A.SETTING_UPDATED_PLAYBACK_RATE_MIN, At, E), f.on(et.A.SETTING_UPDATED_PLAYBACK_RATE_MAX, At, E), f.on(St.A.STREAM_INITIALIZED, At, E), At();
          } }, D = (0, ae.A)(y).getInstance().getLogger(E), N(), E;
        }
        fd.__dashjs_factory_name = "CatchupController";
        var km = Dt.A.getSingletonFactory(fd);
        const xm = [q.A.SERVICE_DESCRIPTION_DVB_LL_SCHEME], md = "video", pd = "audio";
        function gd() {
          const y = this.context;
          let f, E, v, M, x;
          function z() {
            E = { liveDelay: NaN, liveCatchup: { maxDrift: NaN, playbackRate: { min: NaN, max: NaN } }, minBitrate: {}, maxBitrate: {}, initialBitrate: {}, contentSteering: null, clientDataReporting: null }, v = [];
          }
          function O(k, H, B) {
            try {
              E[k][H] = B / 1e3;
            } catch (D) {
              M.error(D);
            }
          }
          return f = { getServiceDescriptionSettings: function() {
            return E;
          }, getProducerReferenceTimeOffsets: function() {
            return v;
          }, calculateProducerReferenceTimeOffsets: function(k) {
            try {
              let H = [];
              if (k && k.length > 0) {
                const B = [q.A.VIDEO, q.A.AUDIO, q.A.MESH, q.A.TEXT], D = x.getAvailabilityStartTime() / 1e3;
                k.forEach((N) => {
                  const Y = B.reduce((J, it) => J.concat(x.getAllMediaInfoForType(N, it)), []).reduce((J, it) => (x.getProducerReferenceTimes(N, it).forEach((lt) => {
                    const at = x.getVoRepresentations(it);
                    if (at && at.length > 0 && at[0].adaptation && at[0].segmentInfoType === I.A.SEGMENT_TEMPLATE) {
                      const st = at[0], ht = new Date(lt[I.A.WALL_CLOCK_TIME]).getTime() / 1e3 - (lt[I.A.PRESENTATION_TIME] / st[I.A.TIMESCALE] - st[I.A.PRESENTATION_TIME_OFFSET] + N.start), At = D - ht;
                      J.push({ id: lt[I.A.ID], to: At });
                    }
                  }), J), []);
                  H = H.concat(Y);
                });
              }
              v = H;
            } catch (H) {
              M.error(H), v = [];
            }
          }, applyServiceDescription: function(k) {
            if (!k || !k.serviceDescriptions) return;
            const H = k.serviceDescriptions.filter((N) => xm.includes(N.schemeIdUri)), B = k.serviceDescriptions.filter((N) => N.schemeIdUri == null);
            let D = H.length > 0 ? H[H.length - 1] : B[B.length - 1];
            D && (D.latency && D.latency.target > 0 && function(N) {
              let Y;
              if (N.schemeIdUri, q.A.SERVICE_DESCRIPTION_DVB_LL_SCHEME, Y = function(J) {
                return { liveDelay: J.latency.target / 1e3, maxDrift: !isNaN(J.latency.max) && J.latency.max > J.latency.target ? (J.latency.max - J.latency.target + 500) / 1e3 : NaN, referenceId: J.latency.referenceId || NaN };
              }(N), v.length > 0) {
                let { to: J, id: it } = function(lt) {
                  let at, st = 0, ht = v.filter((At) => At.id === lt.referenceId);
                  return ht.length === 0 ? (st = v.length > 0 ? v[0].to : 0, at = v[0].id || NaN) : (st = ht[0].to || 0, at = ht[0].id || NaN), { to: st, id: at };
                }(Y);
                E.liveDelay = Y.liveDelay - J, E.liveCatchup.maxDrift = Y.maxDrift, M.debug(`
                Found latency properties coming from service description. Applied time offset of ${J} from ProducerReferenceTime element with id ${it}.
                Live Delay: ${Y.liveDelay - J}, Live catchup max drift: ${Y.maxDrift}
            `);
              } else E.liveDelay = Y.liveDelay, E.liveCatchup.maxDrift = Y.maxDrift, M.debug(`Found latency properties coming from service description: Live Delay: ${Y.liveDelay}, Live catchup max drift: ${Y.maxDrift}`);
            }(D), D.playbackRate && function(N) {
              const Y = N.playbackRate.min ? Math.round(1e3 * (N.playbackRate.min - 1)) / 1e3 : NaN, J = N.playbackRate.max ? Math.round(1e3 * (N.playbackRate.max - 1)) / 1e3 : NaN;
              E.liveCatchup.playbackRate.min = Y, E.liveCatchup.playbackRate.max = J, M.debug(`Found latency properties coming from service description: Live catchup min playback rate: ${Y}`), M.debug(`Found latency properties coming from service description: Live catchup max playback rate: ${J}`);
            }(D), D.operatingQuality, D.operatingBandwidth && function(N) {
              if (!N || !N.operatingBandwidth || !N.operatingBandwidth.mediaType || N.operatingBandwidth.mediaType === "all") return;
              const Y = {};
              Y.minBandwidth = N.operatingBandwidth.min, Y.maxBandwidth = N.operatingBandwidth.max, Y.targetBandwidth = N.operatingBandwidth.target;
              const J = [];
              N.operatingBandwidth.mediaType === md || N.operatingBandwidth.mediaType === pd ? J.push(N.operatingBandwidth.mediaType) : N.operatingBandwidth.mediaType === "any" && (J.push(pd), J.push(md), J.push("mesh")), J.forEach((it) => {
                isNaN(Y.minBandwidth) || O("minBitrate", it, Y.minBandwidth), isNaN(Y.maxBandwidth) || O("maxBitrate", it, Y.maxBandwidth), isNaN(Y.targetBandwidth) || O("initialBitrate", it, Y.targetBandwidth);
              });
            }(D), D.contentSteering && function(N) {
              E.contentSteering = N.contentSteering;
            }(D), D.clientDataReporting && function(N) {
              E.clientDataReporting = N.clientDataReporting;
            }(D));
          }, reset: function() {
            z();
          }, setConfig: function(k) {
            k && k.adapter && (x = k.adapter);
          } }, M = (0, ae.A)(y).getInstance().getLogger(f), z(), f;
        }
        gd.__dashjs_factory_name = "ServiceDescriptionController";
        var Lm = Dt.A.getSingletonFactory(gd);
        function ds() {
          let y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, f = [];
          if (y.irregular) return y.irregular;
          if (y.regular) return y.regular;
          if (y.language) {
            f = f.concat(y.language, y.extendedLanguageSubtags || [], y.script || [], y.region || [], y.variants || []);
            const E = y.extensions || [];
            let v = -1;
            for (; ++v < E.length; ) {
              const M = E[v];
              M.singleton && M.extensions && M.extensions.length > 0 && f.push(M.singleton, ...M.extensions);
            }
          }
          return y.privateuse && y.privateuse.length > 0 && f.push("x", ...y.privateuse), f.join("-");
        }
        function gr(y) {
          const f = typeof y == "string" ? y.charCodeAt(0) : y;
          return f >= 97 && f <= 122 || f >= 65 && f <= 90;
        }
        function Ss(y) {
          const f = typeof y == "string" ? y.charCodeAt(0) : y;
          return f >= 48 && f <= 57;
        }
        function qa(y) {
          return gr(y) || Ss(y);
        }
        const Dm = ["art-lojban", "cel-gaulish", "no-bok", "no-nyn", "zh-guoyu", "zh-hakka", "zh-min", "zh-min-nan", "zh-xiang"], _d = { "en-gb-oed": "en-GB-oxendict", "i-ami": "ami", "i-bnn": "bnn", "i-default": null, "i-enochian": null, "i-hak": "hak", "i-klingon": "tlh", "i-lux": "lb", "i-mingo": null, "i-navajo": "nv", "i-pwn": "pwn", "i-tao": "tao", "i-tay": "tay", "i-tsu": "tsu", "sgn-be-fr": "sfb", "sgn-be-nl": "vgt", "sgn-ch-de": "sgg", "art-lojban": "jbo", "cel-gaulish": null, "no-bok": "nb", "no-nyn": "nn", "zh-guoyu": "cmn", "zh-hakka": "hak", "zh-min": null, "zh-min-nan": "nan", "zh-xiang": "hsn" }, Im = {}.hasOwnProperty;
        function Ga(y) {
          let f = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          const E = { language: null, extendedLanguageSubtags: [], script: null, region: null, variants: [], extensions: [], privateuse: [], irregular: null, regular: null }, v = String(y), M = v.toLowerCase();
          let x = 0;
          if (y == null) throw new Error("Expected string, got `" + y + "`");
          if (Im.call(_d, M)) {
            const O = _d[M];
            return f.normalize !== void 0 && f.normalize !== null && !f.normalize || typeof O != "string" ? (E[Dm.includes(M) ? "regular" : "irregular"] = v, E) : Ga(O);
          }
          for (; gr(M.charCodeAt(x)) && x < 9; ) x++;
          if (x > 1 && x < 9) {
            if (E.language = v.slice(0, x), x < 4) {
              let O = 0;
              for (; M.charCodeAt(x) === 45 && gr(M.charCodeAt(x + 1)) && gr(M.charCodeAt(x + 2)) && gr(M.charCodeAt(x + 3)) && !gr(M.charCodeAt(x + 4)); ) {
                if (O > 2) return z(x, 3, "Too many extended language subtags, expected at most 3 subtags");
                E.extendedLanguageSubtags.push(v.slice(x + 1, x + 4)), x += 4, O++;
              }
            }
            for (M.charCodeAt(x) === 45 && gr(M.charCodeAt(x + 1)) && gr(M.charCodeAt(x + 2)) && gr(M.charCodeAt(x + 3)) && gr(M.charCodeAt(x + 4)) && !gr(M.charCodeAt(x + 5)) && (E.script = v.slice(x + 1, x + 5), x += 5), M.charCodeAt(x) === 45 && (gr(M.charCodeAt(x + 1)) && gr(M.charCodeAt(x + 2)) && !gr(M.charCodeAt(x + 3)) ? (E.region = v.slice(x + 1, x + 3), x += 3) : Ss(M.charCodeAt(x + 1)) && Ss(M.charCodeAt(x + 2)) && Ss(M.charCodeAt(x + 3)) && !Ss(M.charCodeAt(x + 4)) && (E.region = v.slice(x + 1, x + 4), x += 4)); M.charCodeAt(x) === 45; ) {
              const O = x + 1;
              let k = O;
              for (; qa(M.charCodeAt(k)); ) {
                if (k - O > 7) return z(k, 1, "Too long variant, expected at most 8 characters");
                k++;
              }
              if (!(k - O > 4 || k - O > 3 && Ss(M.charCodeAt(O)))) break;
              E.variants.push(v.slice(O, k)), x = k;
            }
            for (; M.charCodeAt(x) === 45 && M.charCodeAt(x + 1) !== 120 && qa(M.charCodeAt(x + 1)) && M.charCodeAt(x + 2) === 45 && qa(M.charCodeAt(x + 3)); ) {
              let O = x + 2, k = 0;
              for (; M.charCodeAt(O) === 45 && qa(M.charCodeAt(O + 1)) && qa(M.charCodeAt(O + 2)); ) {
                const H = O + 1;
                for (O = H + 2, k++; qa(M.charCodeAt(O)); ) {
                  if (O - H > 7) return z(O, 2, "Too long extension, expected at most 8 characters");
                  O++;
                }
              }
              if (!k) return z(O, 4, "Empty extension, extensions must have at least 2 characters of content");
              E.extensions.push({ singleton: v.charAt(x + 1), extensions: v.slice(x + 3, O).split("-") }), x = O;
            }
          } else x = 0;
          if (x === 0 && M.charCodeAt(x) === 120 || M.charCodeAt(x) === 45 && M.charCodeAt(x + 1) === 120) {
            x = x ? x + 2 : 1;
            let O = x;
            for (; M.charCodeAt(O) === 45 && qa(M.charCodeAt(O + 1)); ) {
              const k = x + 1;
              for (O = k; qa(M.charCodeAt(O)); ) {
                if (O - k > 7) return z(O, 5, "Too long private-use area, expected at most 8 characters");
                O++;
              }
              E.privateuse.push(v.slice(x + 1, O)), x = O;
            }
          }
          return x !== v.length ? z(x, 6, "Found superfluous content after tag") : E;
          function z(O, k, H) {
            return f.warning && f.warning(H, k, O), f.forgiving ? E : { language: null, extendedLanguageSubtags: [], script: null, region: null, variants: [], extensions: [], privateuse: [], irregular: null, regular: null };
          }
        }
        function Rm(y, f) {
          return function(E, v) {
            let M = yd(E, "tag");
            const x = yd(v ?? "*", "range"), z = [];
            let O = -1;
            for (; ++O < x.length; ) {
              const k = x[O].toLowerCase();
              if (!f && k === "*") continue;
              let H = -1;
              const B = [];
              for (; ++H < M.length; ) if (y(M[H].toLowerCase(), k)) {
                if (!f) return M[H];
                z.push(M[H]);
              } else B.push(M[H]);
              M = B;
            }
            return f ? z : void 0;
          };
        }
        const Wl = Rm(function(y, f) {
          const E = y.split("-"), v = f.split("-");
          let M = 0, x = 0;
          if (v[x] !== "*" && E[M] !== v[x]) return !1;
          for (M++, x++; x < v.length; ) if (v[x] !== "*") {
            if (!E[M]) return !1;
            if (E[M] !== v[x]) {
              if (E[M].length === 1) return !1;
              M++;
            } else M++, x++;
          } else x++;
          return !0;
        }, !0);
        function yd(y, f) {
          const E = y && typeof y == "string" ? [y] : y;
          if (!E || typeof E != "object" || !("length" in E)) throw new Error("Invalid " + f + " `" + E + "`, expected non-empty string");
          return E;
        }
        const Kl = [{ from: "in", to: "id" }, { from: "iw", to: "he" }, { from: "ji", to: "yi" }, { from: "jw", to: "jv" }, { from: "mo", to: "ro" }, { from: "scc", to: "sr" }, { from: "scr", to: "hr" }, { from: "aam", to: "aas" }, { from: "adp", to: "dz" }, { from: "aue", to: "ktz" }, { from: "ayx", to: "nun" }, { from: "bgm", to: "bcg" }, { from: "bjd", to: "drl" }, { from: "ccq", to: "rki" }, { from: "cjr", to: "mom" }, { from: "cka", to: "cmr" }, { from: "cmk", to: "xch" }, { from: "coy", to: "pij" }, { from: "cqu", to: "quh" }, { from: "drh", to: "mn" }, { from: "drw", to: "fa-af" }, { from: "gav", to: "dev" }, { from: "gfx", to: "vaj" }, { from: "ggn", to: "gvr" }, { from: "gti", to: "nyc" }, { from: "guv", to: "duz" }, { from: "hrr", to: "jal" }, { from: "ibi", to: "opa" }, { from: "ilw", to: "gal" }, { from: "jeg", to: "oyb" }, { from: "kgc", to: "tdf" }, { from: "kgh", to: "kml" }, { from: "koj", to: "kwv" }, { from: "krm", to: "bmf" }, { from: "ktr", to: "dtp" }, { from: "kvs", to: "gdj" }, { from: "kwq", to: "yam" }, { from: "kxe", to: "tvd" }, { from: "kzj", to: "dtp" }, { from: "kzt", to: "dtp" }, { from: "lii", to: "raq" }, { from: "lmm", to: "rmx" }, { from: "meg", to: "cir" }, { from: "mst", to: "mry" }, { from: "mwj", to: "vaj" }, { from: "myt", to: "mry" }, { from: "nad", to: "xny" }, { from: "ncp", to: "kdz" }, { from: "nnx", to: "ngv" }, { from: "nts", to: "pij" }, { from: "oun", to: "vaj" }, { from: "pcr", to: "adx" }, { from: "pmc", to: "huw" }, { from: "pmu", to: "phr" }, { from: "ppa", to: "bfy" }, { from: "ppr", to: "lcq" }, { from: "pry", to: "prt" }, { from: "puz", to: "pub" }, { from: "sca", to: "hle" }, { from: "skk", to: "oyb" }, { from: "tdu", to: "dtp" }, { from: "thc", to: "tpo" }, { from: "thx", to: "oyb" }, { from: "tie", to: "ras" }, { from: "tkk", to: "twm" }, { from: "tlw", to: "weo" }, { from: "tmp", to: "tyj" }, { from: "tne", to: "kak" }, { from: "tnf", to: "fa-af" }, { from: "tsf", to: "taj" }, { from: "uok", to: "ema" }, { from: "xba", to: "cax" }, { from: "xia", to: "acn" }, { from: "xkh", to: "waw" }, { from: "xsj", to: "suj" }, { from: "ybd", to: "rki" }, { from: "yma", to: "lrr" }, { from: "ymt", to: "mtm" }, { from: "yos", to: "zom" }, { from: "yuu", to: "yug" }, { from: "asd", to: "snz" }, { from: "dit", to: "dif" }, { from: "llo", to: "ngt" }, { from: "myd", to: "aog" }, { from: "nns", to: "nbr" }, { from: "agp", to: "apf" }, { from: "ais", to: "ami" }, { from: "ajt", to: "aeb" }, { from: "baz", to: "nvo" }, { from: "bhk", to: "fbl" }, { from: "bic", to: "bir" }, { from: "bjq", to: "bzc" }, { from: "bkb", to: "ebk" }, { from: "blg", to: "iba" }, { from: "btb", to: "beb" }, { from: "daf", to: "dnj" }, { from: "dap", to: "njz" }, { from: "djl", to: "dze" }, { from: "dkl", to: "aqd" }, { from: "drr", to: "kzk" }, { from: "dud", to: "uth" }, { from: "duj", to: "dwu" }, { from: "dwl", to: "dbt" }, { from: "elp", to: "amq" }, { from: "gbc", to: "wny" }, { from: "ggo", to: "esg" }, { from: "ggr", to: "gtu" }, { from: "gio", to: "aou" }, { from: "gli", to: "kzk" }, { from: "ill", to: "ilm" }, { from: "izi", to: "eza" }, { from: "jar", to: "jgk" }, { from: "kdv", to: "zkd" }, { from: "kgd", to: "ncq" }, { from: "kpp", to: "jkm" }, { from: "kxl", to: "kru" }, { from: "kzh", to: "dgl" }, { from: "lak", to: "ksp" }, { from: "leg", to: "enl" }, { from: "mgx", to: "jbk" }, { from: "mnt", to: "wnn" }, { from: "mof", to: "xnt" }, { from: "mwd", to: "dmw" }, { from: "nbf", to: "nru" }, { from: "nbx", to: "ekc" }, { from: "nln", to: "azd" }, { from: "nlr", to: "nrk" }, { from: "noo", to: "dtd" }, { from: "nxu", to: "bpp" }, { from: "pat", to: "kxr" }, { from: "rmr", to: "emx" }, { from: "sap", to: "aqt" }, { from: "sgl", to: "isk" }, { from: "smd", to: "kmb" }, { from: "snb", to: "iba" }, { from: "sul", to: "sgd" }, { from: "sum", to: "ulw" }, { from: "tgg", to: "bjp" }, { from: "thw", to: "ola" }, { from: "tid", to: "itd" }, { from: "unp", to: "wro" }, { from: "wgw", to: "wgb" }, { from: "wit", to: "nol" }, { from: "wiw", to: "nwo" }, { from: "xrq", to: "dmw" }, { from: "yen", to: "ynq" }, { from: "yiy", to: "yrm" }, { from: "zir", to: "scv" }, { from: "sgn-br", to: "bzs" }, { from: "sgn-co", to: "csn" }, { from: "sgn-de", to: "gsg" }, { from: "sgn-dk", to: "dsl" }, { from: "sgn-fr", to: "fsl" }, { from: "sgn-gb", to: "bfi" }, { from: "sgn-gr", to: "gss" }, { from: "sgn-ie", to: "isg" }, { from: "sgn-it", to: "ise" }, { from: "sgn-jp", to: "jsl" }, { from: "sgn-mx", to: "mfs" }, { from: "sgn-ni", to: "ncs" }, { from: "sgn-nl", to: "dse" }, { from: "sgn-no", to: "nsi" }, { from: "sgn-pt", to: "psr" }, { from: "sgn-se", to: "swl" }, { from: "sgn-us", to: "ase" }, { from: "sgn-za", to: "sfs" }, { from: "sgn-es", to: "ssp" }, { from: "zh-cmn", to: "zh" }, { from: "zh-cmn-hans", to: "zh-hans" }, { from: "zh-cmn-hant", to: "zh-hant" }, { from: "zh-gan", to: "gan" }, { from: "zh-wuu", to: "wuu" }, { from: "zh-yue", to: "yue" }, { from: "no-bokmal", to: "nb" }, { from: "no-nynorsk", to: "nn" }, { from: "aa-saaho", to: "ssy" }, { from: "sh", to: "sr-latn" }, { from: "cnr", to: "sr-me" }, { from: "tl", to: "fil" }, { from: "aju", to: "jrb" }, { from: "als", to: "sq" }, { from: "arb", to: "ar" }, { from: "ayr", to: "ay" }, { from: "azj", to: "az" }, { from: "bcc", to: "bal" }, { from: "bcl", to: "bik" }, { from: "bxk", to: "luy" }, { from: "bxr", to: "bua" }, { from: "cld", to: "syr" }, { from: "cmn", to: "zh" }, { from: "cwd", to: "cr" }, { from: "dgo", to: "doi" }, { from: "dhd", to: "mwr" }, { from: "dik", to: "din" }, { from: "diq", to: "zza" }, { from: "lbk", to: "bnc" }, { from: "ekk", to: "et" }, { from: "emk", to: "man" }, { from: "esk", to: "ik" }, { from: "fat", to: "ak" }, { from: "fuc", to: "ff" }, { from: "gaz", to: "om" }, { from: "gbo", to: "grb" }, { from: "gno", to: "gon" }, { from: "gug", to: "gn" }, { from: "gya", to: "gba" }, { from: "hdn", to: "hai" }, { from: "hea", to: "hmn" }, { from: "ike", to: "iu" }, { from: "kmr", to: "ku" }, { from: "knc", to: "kr" }, { from: "kng", to: "kg" }, { from: "knn", to: "kok" }, { from: "kpv", to: "kv" }, { from: "lvs", to: "lv" }, { from: "mhr", to: "chm" }, { from: "mup", to: "raj" }, { from: "khk", to: "mn" }, { from: "npi", to: "ne" }, { from: "ojg", to: "oj" }, { from: "ory", to: "or" }, { from: "pbu", to: "ps" }, { from: "pes", to: "fa" }, { from: "plt", to: "mg" }, { from: "pnb", to: "lah" }, { from: "quz", to: "qu" }, { from: "rmy", to: "rom" }, { from: "spy", to: "kln" }, { from: "src", to: "sc" }, { from: "swh", to: "sw" }, { from: "ttq", to: "tmh" }, { from: "tw", to: "ak" }, { from: "umu", to: "del" }, { from: "uzn", to: "uz" }, { from: "xpe", to: "kpe" }, { from: "xsl", to: "den" }, { from: "ydd", to: "yi" }, { from: "zai", to: "zap" }, { from: "zsm", to: "ms" }, { from: "zyb", to: "za" }, { from: "him", to: "srx" }, { from: "mnk", to: "man" }, { from: "bh", to: "bho" }, { from: "prs", to: "fa-af" }, { from: "swc", to: "sw-cd" }, { from: "aar", to: "aa" }, { from: "abk", to: "ab" }, { from: "ave", to: "ae" }, { from: "afr", to: "af" }, { from: "aka", to: "ak" }, { from: "amh", to: "am" }, { from: "arg", to: "an" }, { from: "ara", to: "ar" }, { from: "asm", to: "as" }, { from: "ava", to: "av" }, { from: "aym", to: "ay" }, { from: "aze", to: "az" }, { from: "bak", to: "ba" }, { from: "bel", to: "be" }, { from: "bul", to: "bg" }, { from: "bih", to: "bho" }, { from: "bis", to: "bi" }, { from: "bam", to: "bm" }, { from: "ben", to: "bn" }, { from: "bod", to: "bo" }, { from: "bre", to: "br" }, { from: "bos", to: "bs" }, { from: "cat", to: "ca" }, { from: "che", to: "ce" }, { from: "cha", to: "ch" }, { from: "cos", to: "co" }, { from: "cre", to: "cr" }, { from: "ces", to: "cs" }, { from: "chu", to: "cu" }, { from: "chv", to: "cv" }, { from: "cym", to: "cy" }, { from: "dan", to: "da" }, { from: "deu", to: "de" }, { from: "div", to: "dv" }, { from: "dzo", to: "dz" }, { from: "ewe", to: "ee" }, { from: "ell", to: "el" }, { from: "eng", to: "en" }, { from: "epo", to: "eo" }, { from: "spa", to: "es" }, { from: "est", to: "et" }, { from: "eus", to: "eu" }, { from: "fas", to: "fa" }, { from: "ful", to: "ff" }, { from: "fin", to: "fi" }, { from: "fij", to: "fj" }, { from: "fao", to: "fo" }, { from: "fra", to: "fr" }, { from: "fry", to: "fy" }, { from: "gle", to: "ga" }, { from: "gla", to: "gd" }, { from: "glg", to: "gl" }, { from: "grn", to: "gn" }, { from: "guj", to: "gu" }, { from: "glv", to: "gv" }, { from: "hau", to: "ha" }, { from: "heb", to: "he" }, { from: "hin", to: "hi" }, { from: "hmo", to: "ho" }, { from: "hrv", to: "hr" }, { from: "hat", to: "ht" }, { from: "hun", to: "hu" }, { from: "hye", to: "hy" }, { from: "her", to: "hz" }, { from: "ina", to: "ia" }, { from: "ind", to: "id" }, { from: "ile", to: "ie" }, { from: "ibo", to: "ig" }, { from: "iii", to: "ii" }, { from: "ipk", to: "ik" }, { from: "ido", to: "io" }, { from: "isl", to: "is" }, { from: "ita", to: "it" }, { from: "iku", to: "iu" }, { from: "jpn", to: "ja" }, { from: "jav", to: "jv" }, { from: "kat", to: "ka" }, { from: "kon", to: "kg" }, { from: "kik", to: "ki" }, { from: "kua", to: "kj" }, { from: "kaz", to: "kk" }, { from: "kal", to: "kl" }, { from: "khm", to: "km" }, { from: "kan", to: "kn" }, { from: "kor", to: "ko" }, { from: "kau", to: "kr" }, { from: "kas", to: "ks" }, { from: "kur", to: "ku" }, { from: "kom", to: "kv" }, { from: "cor", to: "kw" }, { from: "kir", to: "ky" }, { from: "lat", to: "la" }, { from: "ltz", to: "lb" }, { from: "lug", to: "lg" }, { from: "lim", to: "li" }, { from: "lin", to: "ln" }, { from: "lao", to: "lo" }, { from: "lit", to: "lt" }, { from: "lub", to: "lu" }, { from: "lav", to: "lv" }, { from: "mlg", to: "mg" }, { from: "mah", to: "mh" }, { from: "mri", to: "mi" }, { from: "mkd", to: "mk" }, { from: "mal", to: "ml" }, { from: "mon", to: "mn" }, { from: "mol", to: "ro" }, { from: "mar", to: "mr" }, { from: "msa", to: "ms" }, { from: "mlt", to: "mt" }, { from: "mya", to: "my" }, { from: "nau", to: "na" }, { from: "nob", to: "nb" }, { from: "nde", to: "nd" }, { from: "nep", to: "ne" }, { from: "ndo", to: "ng" }, { from: "nld", to: "nl" }, { from: "nno", to: "nn" }, { from: "nor", to: "no" }, { from: "nbl", to: "nr" }, { from: "nav", to: "nv" }, { from: "nya", to: "ny" }, { from: "oci", to: "oc" }, { from: "oji", to: "oj" }, { from: "orm", to: "om" }, { from: "ori", to: "or" }, { from: "oss", to: "os" }, { from: "pan", to: "pa" }, { from: "pli", to: "pi" }, { from: "pol", to: "pl" }, { from: "pus", to: "ps" }, { from: "por", to: "pt" }, { from: "que", to: "qu" }, { from: "roh", to: "rm" }, { from: "run", to: "rn" }, { from: "ron", to: "ro" }, { from: "rus", to: "ru" }, { from: "kin", to: "rw" }, { from: "san", to: "sa" }, { from: "srd", to: "sc" }, { from: "snd", to: "sd" }, { from: "sme", to: "se" }, { from: "sag", to: "sg" }, { from: "hbs", to: "sr-latn" }, { from: "sin", to: "si" }, { from: "slk", to: "sk" }, { from: "slv", to: "sl" }, { from: "smo", to: "sm" }, { from: "sna", to: "sn" }, { from: "som", to: "so" }, { from: "sqi", to: "sq" }, { from: "srp", to: "sr" }, { from: "ssw", to: "ss" }, { from: "sot", to: "st" }, { from: "sun", to: "su" }, { from: "swe", to: "sv" }, { from: "swa", to: "sw" }, { from: "tam", to: "ta" }, { from: "tel", to: "te" }, { from: "tgk", to: "tg" }, { from: "tha", to: "th" }, { from: "tir", to: "ti" }, { from: "tuk", to: "tk" }, { from: "tgl", to: "fil" }, { from: "tsn", to: "tn" }, { from: "ton", to: "to" }, { from: "tur", to: "tr" }, { from: "tso", to: "ts" }, { from: "tat", to: "tt" }, { from: "twi", to: "ak" }, { from: "tah", to: "ty" }, { from: "uig", to: "ug" }, { from: "ukr", to: "uk" }, { from: "urd", to: "ur" }, { from: "uzb", to: "uz" }, { from: "ven", to: "ve" }, { from: "vie", to: "vi" }, { from: "vol", to: "vo" }, { from: "wln", to: "wa" }, { from: "wol", to: "wo" }, { from: "xho", to: "xh" }, { from: "yid", to: "yi" }, { from: "yor", to: "yo" }, { from: "zha", to: "za" }, { from: "zho", to: "zh" }, { from: "zul", to: "zu" }, { from: "alb", to: "sq" }, { from: "arm", to: "hy" }, { from: "baq", to: "eu" }, { from: "bur", to: "my" }, { from: "chi", to: "zh" }, { from: "cze", to: "cs" }, { from: "dut", to: "nl" }, { from: "fre", to: "fr" }, { from: "geo", to: "ka" }, { from: "ger", to: "de" }, { from: "gre", to: "el" }, { from: "ice", to: "is" }, { from: "mac", to: "mk" }, { from: "mao", to: "mi" }, { from: "may", to: "ms" }, { from: "per", to: "fa" }, { from: "rum", to: "ro" }, { from: "slo", to: "sk" }, { from: "tib", to: "bo" }, { from: "wel", to: "cy" }, { from: "und-aaland", to: "und-ax" }, { from: "hy-arevmda", to: "hyw" }, { from: "und-arevmda", to: "und" }, { from: "und-arevela", to: "und" }, { from: "und-lojban", to: "und" }, { from: "und-saaho", to: "und" }, { from: "und-bokmal", to: "und" }, { from: "und-nynorsk", to: "und" }, { from: "und-hakka", to: "und" }, { from: "und-xiang", to: "und" }, { from: "und-hepburn-heploc", to: "und-alalc97" }], lo = [{ from: { field: "script", value: "qaai" }, to: { field: "script", value: "zinh" } }, { from: { field: "region", value: "bu" }, to: { field: "region", value: "mm" } }, { from: { field: "region", value: "ct" }, to: { field: "region", value: "ki" } }, { from: { field: "region", value: "dd" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "dy" }, to: { field: "region", value: "bj" } }, { from: { field: "region", value: "fx" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "hv" }, to: { field: "region", value: "bf" } }, { from: { field: "region", value: "jt" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "mi" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "nh" }, to: { field: "region", value: "vu" } }, { from: { field: "region", value: "nq" }, to: { field: "region", value: "aq" } }, { from: { field: "region", value: "pu" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "pz" }, to: { field: "region", value: "pa" } }, { from: { field: "region", value: "qu" }, to: { field: "region", value: "eu" } }, { from: { field: "region", value: "rh" }, to: { field: "region", value: "zw" } }, { from: { field: "region", value: "tp" }, to: { field: "region", value: "tl" } }, { from: { field: "region", value: "uk" }, to: { field: "region", value: "gb" } }, { from: { field: "region", value: "vd" }, to: { field: "region", value: "vn" } }, { from: { field: "region", value: "wk" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "yd" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "zr" }, to: { field: "region", value: "cd" } }, { from: { field: "region", value: "230" }, to: { field: "region", value: "et" } }, { from: { field: "region", value: "280" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "736" }, to: { field: "region", value: "sd" } }, { from: { field: "region", value: "886" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "958" }, to: { field: "region", value: "aa" } }, { from: { field: "region", value: "020" }, to: { field: "region", value: "ad" } }, { from: { field: "region", value: "784" }, to: { field: "region", value: "ae" } }, { from: { field: "region", value: "004" }, to: { field: "region", value: "af" } }, { from: { field: "region", value: "028" }, to: { field: "region", value: "ag" } }, { from: { field: "region", value: "660" }, to: { field: "region", value: "ai" } }, { from: { field: "region", value: "008" }, to: { field: "region", value: "al" } }, { from: { field: "region", value: "051" }, to: { field: "region", value: "am" } }, { from: { field: "region", value: "024" }, to: { field: "region", value: "ao" } }, { from: { field: "region", value: "010" }, to: { field: "region", value: "aq" } }, { from: { field: "region", value: "032" }, to: { field: "region", value: "ar" } }, { from: { field: "region", value: "016" }, to: { field: "region", value: "as" } }, { from: { field: "region", value: "040" }, to: { field: "region", value: "at" } }, { from: { field: "region", value: "036" }, to: { field: "region", value: "au" } }, { from: { field: "region", value: "533" }, to: { field: "region", value: "aw" } }, { from: { field: "region", value: "248" }, to: { field: "region", value: "ax" } }, { from: { field: "region", value: "031" }, to: { field: "region", value: "az" } }, { from: { field: "region", value: "070" }, to: { field: "region", value: "ba" } }, { from: { field: "region", value: "052" }, to: { field: "region", value: "bb" } }, { from: { field: "region", value: "050" }, to: { field: "region", value: "bd" } }, { from: { field: "region", value: "056" }, to: { field: "region", value: "be" } }, { from: { field: "region", value: "854" }, to: { field: "region", value: "bf" } }, { from: { field: "region", value: "100" }, to: { field: "region", value: "bg" } }, { from: { field: "region", value: "048" }, to: { field: "region", value: "bh" } }, { from: { field: "region", value: "108" }, to: { field: "region", value: "bi" } }, { from: { field: "region", value: "204" }, to: { field: "region", value: "bj" } }, { from: { field: "region", value: "652" }, to: { field: "region", value: "bl" } }, { from: { field: "region", value: "060" }, to: { field: "region", value: "bm" } }, { from: { field: "region", value: "096" }, to: { field: "region", value: "bn" } }, { from: { field: "region", value: "068" }, to: { field: "region", value: "bo" } }, { from: { field: "region", value: "535" }, to: { field: "region", value: "bq" } }, { from: { field: "region", value: "076" }, to: { field: "region", value: "br" } }, { from: { field: "region", value: "044" }, to: { field: "region", value: "bs" } }, { from: { field: "region", value: "064" }, to: { field: "region", value: "bt" } }, { from: { field: "region", value: "104" }, to: { field: "region", value: "mm" } }, { from: { field: "region", value: "074" }, to: { field: "region", value: "bv" } }, { from: { field: "region", value: "072" }, to: { field: "region", value: "bw" } }, { from: { field: "region", value: "112" }, to: { field: "region", value: "by" } }, { from: { field: "region", value: "084" }, to: { field: "region", value: "bz" } }, { from: { field: "region", value: "124" }, to: { field: "region", value: "ca" } }, { from: { field: "region", value: "166" }, to: { field: "region", value: "cc" } }, { from: { field: "region", value: "180" }, to: { field: "region", value: "cd" } }, { from: { field: "region", value: "140" }, to: { field: "region", value: "cf" } }, { from: { field: "region", value: "178" }, to: { field: "region", value: "cg" } }, { from: { field: "region", value: "756" }, to: { field: "region", value: "ch" } }, { from: { field: "region", value: "384" }, to: { field: "region", value: "ci" } }, { from: { field: "region", value: "184" }, to: { field: "region", value: "ck" } }, { from: { field: "region", value: "152" }, to: { field: "region", value: "cl" } }, { from: { field: "region", value: "120" }, to: { field: "region", value: "cm" } }, { from: { field: "region", value: "156" }, to: { field: "region", value: "cn" } }, { from: { field: "region", value: "170" }, to: { field: "region", value: "co" } }, { from: { field: "region", value: "188" }, to: { field: "region", value: "cr" } }, { from: { field: "region", value: "192" }, to: { field: "region", value: "cu" } }, { from: { field: "region", value: "132" }, to: { field: "region", value: "cv" } }, { from: { field: "region", value: "531" }, to: { field: "region", value: "cw" } }, { from: { field: "region", value: "162" }, to: { field: "region", value: "cx" } }, { from: { field: "region", value: "196" }, to: { field: "region", value: "cy" } }, { from: { field: "region", value: "203" }, to: { field: "region", value: "cz" } }, { from: { field: "region", value: "278" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "276" }, to: { field: "region", value: "de" } }, { from: { field: "region", value: "262" }, to: { field: "region", value: "dj" } }, { from: { field: "region", value: "208" }, to: { field: "region", value: "dk" } }, { from: { field: "region", value: "212" }, to: { field: "region", value: "dm" } }, { from: { field: "region", value: "214" }, to: { field: "region", value: "do" } }, { from: { field: "region", value: "012" }, to: { field: "region", value: "dz" } }, { from: { field: "region", value: "218" }, to: { field: "region", value: "ec" } }, { from: { field: "region", value: "233" }, to: { field: "region", value: "ee" } }, { from: { field: "region", value: "818" }, to: { field: "region", value: "eg" } }, { from: { field: "region", value: "732" }, to: { field: "region", value: "eh" } }, { from: { field: "region", value: "232" }, to: { field: "region", value: "er" } }, { from: { field: "region", value: "724" }, to: { field: "region", value: "es" } }, { from: { field: "region", value: "231" }, to: { field: "region", value: "et" } }, { from: { field: "region", value: "246" }, to: { field: "region", value: "fi" } }, { from: { field: "region", value: "242" }, to: { field: "region", value: "fj" } }, { from: { field: "region", value: "238" }, to: { field: "region", value: "fk" } }, { from: { field: "region", value: "583" }, to: { field: "region", value: "fm" } }, { from: { field: "region", value: "234" }, to: { field: "region", value: "fo" } }, { from: { field: "region", value: "250" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "249" }, to: { field: "region", value: "fr" } }, { from: { field: "region", value: "266" }, to: { field: "region", value: "ga" } }, { from: { field: "region", value: "826" }, to: { field: "region", value: "gb" } }, { from: { field: "region", value: "308" }, to: { field: "region", value: "gd" } }, { from: { field: "region", value: "268" }, to: { field: "region", value: "ge" } }, { from: { field: "region", value: "254" }, to: { field: "region", value: "gf" } }, { from: { field: "region", value: "831" }, to: { field: "region", value: "gg" } }, { from: { field: "region", value: "288" }, to: { field: "region", value: "gh" } }, { from: { field: "region", value: "292" }, to: { field: "region", value: "gi" } }, { from: { field: "region", value: "304" }, to: { field: "region", value: "gl" } }, { from: { field: "region", value: "270" }, to: { field: "region", value: "gm" } }, { from: { field: "region", value: "324" }, to: { field: "region", value: "gn" } }, { from: { field: "region", value: "312" }, to: { field: "region", value: "gp" } }, { from: { field: "region", value: "226" }, to: { field: "region", value: "gq" } }, { from: { field: "region", value: "300" }, to: { field: "region", value: "gr" } }, { from: { field: "region", value: "239" }, to: { field: "region", value: "gs" } }, { from: { field: "region", value: "320" }, to: { field: "region", value: "gt" } }, { from: { field: "region", value: "316" }, to: { field: "region", value: "gu" } }, { from: { field: "region", value: "624" }, to: { field: "region", value: "gw" } }, { from: { field: "region", value: "328" }, to: { field: "region", value: "gy" } }, { from: { field: "region", value: "344" }, to: { field: "region", value: "hk" } }, { from: { field: "region", value: "334" }, to: { field: "region", value: "hm" } }, { from: { field: "region", value: "340" }, to: { field: "region", value: "hn" } }, { from: { field: "region", value: "191" }, to: { field: "region", value: "hr" } }, { from: { field: "region", value: "332" }, to: { field: "region", value: "ht" } }, { from: { field: "region", value: "348" }, to: { field: "region", value: "hu" } }, { from: { field: "region", value: "360" }, to: { field: "region", value: "id" } }, { from: { field: "region", value: "372" }, to: { field: "region", value: "ie" } }, { from: { field: "region", value: "376" }, to: { field: "region", value: "il" } }, { from: { field: "region", value: "833" }, to: { field: "region", value: "im" } }, { from: { field: "region", value: "356" }, to: { field: "region", value: "in" } }, { from: { field: "region", value: "086" }, to: { field: "region", value: "io" } }, { from: { field: "region", value: "368" }, to: { field: "region", value: "iq" } }, { from: { field: "region", value: "364" }, to: { field: "region", value: "ir" } }, { from: { field: "region", value: "352" }, to: { field: "region", value: "is" } }, { from: { field: "region", value: "380" }, to: { field: "region", value: "it" } }, { from: { field: "region", value: "832" }, to: { field: "region", value: "je" } }, { from: { field: "region", value: "388" }, to: { field: "region", value: "jm" } }, { from: { field: "region", value: "400" }, to: { field: "region", value: "jo" } }, { from: { field: "region", value: "392" }, to: { field: "region", value: "jp" } }, { from: { field: "region", value: "404" }, to: { field: "region", value: "ke" } }, { from: { field: "region", value: "417" }, to: { field: "region", value: "kg" } }, { from: { field: "region", value: "116" }, to: { field: "region", value: "kh" } }, { from: { field: "region", value: "296" }, to: { field: "region", value: "ki" } }, { from: { field: "region", value: "174" }, to: { field: "region", value: "km" } }, { from: { field: "region", value: "659" }, to: { field: "region", value: "kn" } }, { from: { field: "region", value: "408" }, to: { field: "region", value: "kp" } }, { from: { field: "region", value: "410" }, to: { field: "region", value: "kr" } }, { from: { field: "region", value: "414" }, to: { field: "region", value: "kw" } }, { from: { field: "region", value: "136" }, to: { field: "region", value: "ky" } }, { from: { field: "region", value: "398" }, to: { field: "region", value: "kz" } }, { from: { field: "region", value: "418" }, to: { field: "region", value: "la" } }, { from: { field: "region", value: "422" }, to: { field: "region", value: "lb" } }, { from: { field: "region", value: "662" }, to: { field: "region", value: "lc" } }, { from: { field: "region", value: "438" }, to: { field: "region", value: "li" } }, { from: { field: "region", value: "144" }, to: { field: "region", value: "lk" } }, { from: { field: "region", value: "430" }, to: { field: "region", value: "lr" } }, { from: { field: "region", value: "426" }, to: { field: "region", value: "ls" } }, { from: { field: "region", value: "440" }, to: { field: "region", value: "lt" } }, { from: { field: "region", value: "442" }, to: { field: "region", value: "lu" } }, { from: { field: "region", value: "428" }, to: { field: "region", value: "lv" } }, { from: { field: "region", value: "434" }, to: { field: "region", value: "ly" } }, { from: { field: "region", value: "504" }, to: { field: "region", value: "ma" } }, { from: { field: "region", value: "492" }, to: { field: "region", value: "mc" } }, { from: { field: "region", value: "498" }, to: { field: "region", value: "md" } }, { from: { field: "region", value: "499" }, to: { field: "region", value: "me" } }, { from: { field: "region", value: "663" }, to: { field: "region", value: "mf" } }, { from: { field: "region", value: "450" }, to: { field: "region", value: "mg" } }, { from: { field: "region", value: "584" }, to: { field: "region", value: "mh" } }, { from: { field: "region", value: "807" }, to: { field: "region", value: "mk" } }, { from: { field: "region", value: "466" }, to: { field: "region", value: "ml" } }, { from: { field: "region", value: "496" }, to: { field: "region", value: "mn" } }, { from: { field: "region", value: "446" }, to: { field: "region", value: "mo" } }, { from: { field: "region", value: "580" }, to: { field: "region", value: "mp" } }, { from: { field: "region", value: "474" }, to: { field: "region", value: "mq" } }, { from: { field: "region", value: "478" }, to: { field: "region", value: "mr" } }, { from: { field: "region", value: "500" }, to: { field: "region", value: "ms" } }, { from: { field: "region", value: "470" }, to: { field: "region", value: "mt" } }, { from: { field: "region", value: "480" }, to: { field: "region", value: "mu" } }, { from: { field: "region", value: "462" }, to: { field: "region", value: "mv" } }, { from: { field: "region", value: "454" }, to: { field: "region", value: "mw" } }, { from: { field: "region", value: "484" }, to: { field: "region", value: "mx" } }, { from: { field: "region", value: "458" }, to: { field: "region", value: "my" } }, { from: { field: "region", value: "508" }, to: { field: "region", value: "mz" } }, { from: { field: "region", value: "516" }, to: { field: "region", value: "na" } }, { from: { field: "region", value: "540" }, to: { field: "region", value: "nc" } }, { from: { field: "region", value: "562" }, to: { field: "region", value: "ne" } }, { from: { field: "region", value: "574" }, to: { field: "region", value: "nf" } }, { from: { field: "region", value: "566" }, to: { field: "region", value: "ng" } }, { from: { field: "region", value: "558" }, to: { field: "region", value: "ni" } }, { from: { field: "region", value: "528" }, to: { field: "region", value: "nl" } }, { from: { field: "region", value: "578" }, to: { field: "region", value: "no" } }, { from: { field: "region", value: "524" }, to: { field: "region", value: "np" } }, { from: { field: "region", value: "520" }, to: { field: "region", value: "nr" } }, { from: { field: "region", value: "570" }, to: { field: "region", value: "nu" } }, { from: { field: "region", value: "554" }, to: { field: "region", value: "nz" } }, { from: { field: "region", value: "512" }, to: { field: "region", value: "om" } }, { from: { field: "region", value: "591" }, to: { field: "region", value: "pa" } }, { from: { field: "region", value: "604" }, to: { field: "region", value: "pe" } }, { from: { field: "region", value: "258" }, to: { field: "region", value: "pf" } }, { from: { field: "region", value: "598" }, to: { field: "region", value: "pg" } }, { from: { field: "region", value: "608" }, to: { field: "region", value: "ph" } }, { from: { field: "region", value: "586" }, to: { field: "region", value: "pk" } }, { from: { field: "region", value: "616" }, to: { field: "region", value: "pl" } }, { from: { field: "region", value: "666" }, to: { field: "region", value: "pm" } }, { from: { field: "region", value: "612" }, to: { field: "region", value: "pn" } }, { from: { field: "region", value: "630" }, to: { field: "region", value: "pr" } }, { from: { field: "region", value: "275" }, to: { field: "region", value: "ps" } }, { from: { field: "region", value: "620" }, to: { field: "region", value: "pt" } }, { from: { field: "region", value: "585" }, to: { field: "region", value: "pw" } }, { from: { field: "region", value: "600" }, to: { field: "region", value: "py" } }, { from: { field: "region", value: "634" }, to: { field: "region", value: "qa" } }, { from: { field: "region", value: "959" }, to: { field: "region", value: "qm" } }, { from: { field: "region", value: "960" }, to: { field: "region", value: "qn" } }, { from: { field: "region", value: "962" }, to: { field: "region", value: "qp" } }, { from: { field: "region", value: "963" }, to: { field: "region", value: "qq" } }, { from: { field: "region", value: "964" }, to: { field: "region", value: "qr" } }, { from: { field: "region", value: "965" }, to: { field: "region", value: "qs" } }, { from: { field: "region", value: "966" }, to: { field: "region", value: "qt" } }, { from: { field: "region", value: "967" }, to: { field: "region", value: "eu" } }, { from: { field: "region", value: "968" }, to: { field: "region", value: "qv" } }, { from: { field: "region", value: "969" }, to: { field: "region", value: "qw" } }, { from: { field: "region", value: "970" }, to: { field: "region", value: "qx" } }, { from: { field: "region", value: "971" }, to: { field: "region", value: "qy" } }, { from: { field: "region", value: "972" }, to: { field: "region", value: "qz" } }, { from: { field: "region", value: "638" }, to: { field: "region", value: "re" } }, { from: { field: "region", value: "642" }, to: { field: "region", value: "ro" } }, { from: { field: "region", value: "688" }, to: { field: "region", value: "rs" } }, { from: { field: "region", value: "643" }, to: { field: "region", value: "ru" } }, { from: { field: "region", value: "646" }, to: { field: "region", value: "rw" } }, { from: { field: "region", value: "682" }, to: { field: "region", value: "sa" } }, { from: { field: "region", value: "090" }, to: { field: "region", value: "sb" } }, { from: { field: "region", value: "690" }, to: { field: "region", value: "sc" } }, { from: { field: "region", value: "729" }, to: { field: "region", value: "sd" } }, { from: { field: "region", value: "752" }, to: { field: "region", value: "se" } }, { from: { field: "region", value: "702" }, to: { field: "region", value: "sg" } }, { from: { field: "region", value: "654" }, to: { field: "region", value: "sh" } }, { from: { field: "region", value: "705" }, to: { field: "region", value: "si" } }, { from: { field: "region", value: "744" }, to: { field: "region", value: "sj" } }, { from: { field: "region", value: "703" }, to: { field: "region", value: "sk" } }, { from: { field: "region", value: "694" }, to: { field: "region", value: "sl" } }, { from: { field: "region", value: "674" }, to: { field: "region", value: "sm" } }, { from: { field: "region", value: "686" }, to: { field: "region", value: "sn" } }, { from: { field: "region", value: "706" }, to: { field: "region", value: "so" } }, { from: { field: "region", value: "740" }, to: { field: "region", value: "sr" } }, { from: { field: "region", value: "728" }, to: { field: "region", value: "ss" } }, { from: { field: "region", value: "678" }, to: { field: "region", value: "st" } }, { from: { field: "region", value: "222" }, to: { field: "region", value: "sv" } }, { from: { field: "region", value: "534" }, to: { field: "region", value: "sx" } }, { from: { field: "region", value: "760" }, to: { field: "region", value: "sy" } }, { from: { field: "region", value: "748" }, to: { field: "region", value: "sz" } }, { from: { field: "region", value: "796" }, to: { field: "region", value: "tc" } }, { from: { field: "region", value: "148" }, to: { field: "region", value: "td" } }, { from: { field: "region", value: "260" }, to: { field: "region", value: "tf" } }, { from: { field: "region", value: "768" }, to: { field: "region", value: "tg" } }, { from: { field: "region", value: "764" }, to: { field: "region", value: "th" } }, { from: { field: "region", value: "762" }, to: { field: "region", value: "tj" } }, { from: { field: "region", value: "772" }, to: { field: "region", value: "tk" } }, { from: { field: "region", value: "626" }, to: { field: "region", value: "tl" } }, { from: { field: "region", value: "795" }, to: { field: "region", value: "tm" } }, { from: { field: "region", value: "788" }, to: { field: "region", value: "tn" } }, { from: { field: "region", value: "776" }, to: { field: "region", value: "to" } }, { from: { field: "region", value: "792" }, to: { field: "region", value: "tr" } }, { from: { field: "region", value: "780" }, to: { field: "region", value: "tt" } }, { from: { field: "region", value: "798" }, to: { field: "region", value: "tv" } }, { from: { field: "region", value: "158" }, to: { field: "region", value: "tw" } }, { from: { field: "region", value: "834" }, to: { field: "region", value: "tz" } }, { from: { field: "region", value: "804" }, to: { field: "region", value: "ua" } }, { from: { field: "region", value: "800" }, to: { field: "region", value: "ug" } }, { from: { field: "region", value: "581" }, to: { field: "region", value: "um" } }, { from: { field: "region", value: "840" }, to: { field: "region", value: "us" } }, { from: { field: "region", value: "858" }, to: { field: "region", value: "uy" } }, { from: { field: "region", value: "860" }, to: { field: "region", value: "uz" } }, { from: { field: "region", value: "336" }, to: { field: "region", value: "va" } }, { from: { field: "region", value: "670" }, to: { field: "region", value: "vc" } }, { from: { field: "region", value: "862" }, to: { field: "region", value: "ve" } }, { from: { field: "region", value: "092" }, to: { field: "region", value: "vg" } }, { from: { field: "region", value: "850" }, to: { field: "region", value: "vi" } }, { from: { field: "region", value: "704" }, to: { field: "region", value: "vn" } }, { from: { field: "region", value: "548" }, to: { field: "region", value: "vu" } }, { from: { field: "region", value: "876" }, to: { field: "region", value: "wf" } }, { from: { field: "region", value: "882" }, to: { field: "region", value: "ws" } }, { from: { field: "region", value: "973" }, to: { field: "region", value: "xa" } }, { from: { field: "region", value: "974" }, to: { field: "region", value: "xb" } }, { from: { field: "region", value: "975" }, to: { field: "region", value: "xc" } }, { from: { field: "region", value: "976" }, to: { field: "region", value: "xd" } }, { from: { field: "region", value: "977" }, to: { field: "region", value: "xe" } }, { from: { field: "region", value: "978" }, to: { field: "region", value: "xf" } }, { from: { field: "region", value: "979" }, to: { field: "region", value: "xg" } }, { from: { field: "region", value: "980" }, to: { field: "region", value: "xh" } }, { from: { field: "region", value: "981" }, to: { field: "region", value: "xi" } }, { from: { field: "region", value: "982" }, to: { field: "region", value: "xj" } }, { from: { field: "region", value: "983" }, to: { field: "region", value: "xk" } }, { from: { field: "region", value: "984" }, to: { field: "region", value: "xl" } }, { from: { field: "region", value: "985" }, to: { field: "region", value: "xm" } }, { from: { field: "region", value: "986" }, to: { field: "region", value: "xn" } }, { from: { field: "region", value: "987" }, to: { field: "region", value: "xo" } }, { from: { field: "region", value: "988" }, to: { field: "region", value: "xp" } }, { from: { field: "region", value: "989" }, to: { field: "region", value: "xq" } }, { from: { field: "region", value: "990" }, to: { field: "region", value: "xr" } }, { from: { field: "region", value: "991" }, to: { field: "region", value: "xs" } }, { from: { field: "region", value: "992" }, to: { field: "region", value: "xt" } }, { from: { field: "region", value: "993" }, to: { field: "region", value: "xu" } }, { from: { field: "region", value: "994" }, to: { field: "region", value: "xv" } }, { from: { field: "region", value: "995" }, to: { field: "region", value: "xw" } }, { from: { field: "region", value: "996" }, to: { field: "region", value: "xx" } }, { from: { field: "region", value: "997" }, to: { field: "region", value: "xy" } }, { from: { field: "region", value: "998" }, to: { field: "region", value: "xz" } }, { from: { field: "region", value: "720" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "887" }, to: { field: "region", value: "ye" } }, { from: { field: "region", value: "175" }, to: { field: "region", value: "yt" } }, { from: { field: "region", value: "710" }, to: { field: "region", value: "za" } }, { from: { field: "region", value: "894" }, to: { field: "region", value: "zm" } }, { from: { field: "region", value: "716" }, to: { field: "region", value: "zw" } }, { from: { field: "region", value: "999" }, to: { field: "region", value: "zz" } }, { from: { field: "variants", value: "polytoni" }, to: { field: "variants", value: "polyton" } }, { from: { field: "variants", value: "heploc" }, to: { field: "variants", value: "alalc97" } }], $l = { region: { 172: ["ru", "am", "az", "by", "ge", "kg", "kz", "md", "tj", "tm", "ua", "uz"], 200: ["cz", "sk"], 530: ["cw", "sx", "bq"], 532: ["cw", "sx", "bq"], 536: ["sa", "iq"], 582: ["fm", "mh", "mp", "pw"], 810: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], 830: ["je", "gg"], 890: ["rs", "me", "si", "hr", "mk", "ba"], 891: ["rs", "me"], an: ["cw", "sx", "bq"], cs: ["rs", "me"], fq: ["aq", "tf"], nt: ["sa", "iq"], pc: ["fm", "mh", "mp", "pw"], su: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], yu: ["rs", "me"], "062": ["034", "143"], ant: ["cw", "sx", "bq"], scg: ["rs", "me"], ntz: ["sa", "iq"], sun: ["ru", "am", "az", "by", "ee", "ge", "kz", "kg", "lv", "lt", "md", "tj", "tm", "ua", "uz"], yug: ["rs", "me"] } }, Bo = { aa: "aa-latn-et", aaa: "aaa-latn-ng", aab: "aab-latn-ng", aac: "aac-latn-pg", aad: "aad-latn-pg", aae: "aae-latn-it", "aae-grek": "aae-grek-it", aaf: "aaf-mlym-in", "aaf-arab": "aaf-arab-in", aag: "aag-latn-pg", aah: "aah-latn-pg", aai: "aai-latn-zz", aak: "aak-latn-zz", aal: "aal-latn-cm", aan: "aan-latn-br", aao: "aao-arab-dz", aap: "aap-latn-br", aaq: "aaq-latn-us", aas: "aas-latn-tz", aat: "aat-grek-gr", aau: "aau-latn-zz", aaw: "aaw-latn-pg", aax: "aax-latn-id", aaz: "aaz-latn-id", ab: "ab-cyrl-ge", aba: "aba-latn-ci", abb: "abb-latn-cm", abc: "abc-latn-ph", abd: "abd-latn-ph", abe: "abe-latn-ca", abf: "abf-latn-my", abg: "abg-latn-pg", abh: "abh-arab-tj", abi: "abi-latn-zz", abl: "abl-rjng-id", "abl-latn": "abl-latn-id", abm: "abm-latn-ng", abn: "abn-latn-ng", abo: "abo-latn-ng", abp: "abp-latn-ph", abq: "abq-cyrl-zz", abr: "abr-latn-gh", abs: "abs-latn-id", abt: "abt-latn-zz", abu: "abu-latn-ci", abv: "abv-arab-bh", abw: "abw-latn-pg", abx: "abx-latn-ph", aby: "aby-latn-zz", abz: "abz-latn-id", aca: "aca-latn-co", acb: "acb-latn-ng", acd: "acd-latn-zz", ace: "ace-latn-id", acf: "acf-latn-lc", ach: "ach-latn-ug", acm: "acm-arab-iq", acn: "acn-latn-cn", acp: "acp-latn-ng", acq: "acq-arab-ye", acr: "acr-latn-gt", acs: "acs-latn-br", act: "act-latn-nl", acu: "acu-latn-ec", acv: "acv-latn-us", acw: "acw-arab-sa", acx: "acx-arab-om", acy: "acy-latn-cy", "acy-arab": "acy-arab-cy", "acy-grek": "acy-grek-cy", acz: "acz-latn-sd", ada: "ada-latn-gh", adb: "adb-latn-tl", add: "add-latn-cm", ade: "ade-latn-zz", adf: "adf-arab-om", adg: "adg-latn-au", adh: "adh-latn-ug", adi: "adi-latn-in", "adi-tibt": "adi-tibt-cn", adj: "adj-latn-zz", adl: "adl-latn-in", adn: "adn-latn-id", ado: "ado-latn-pg", adp: "adp-tibt-bt", adq: "adq-latn-gh", adr: "adr-latn-id", adt: "adt-latn-au", adu: "adu-latn-ng", adw: "adw-latn-br", adx: "adx-tibt-cn", ady: "ady-cyrl-ru", adz: "adz-latn-zz", ae: "ae-avst-ir", aea: "aea-latn-au", aeb: "aeb-arab-tn", aec: "aec-arab-eg", aee: "aee-arab-af", aek: "aek-latn-nc", ael: "ael-latn-cm", aem: "aem-latn-vn", aeq: "aeq-arab-pk", aer: "aer-latn-au", aeu: "aeu-latn-cn", aew: "aew-latn-pg", aey: "aey-latn-zz", aez: "aez-latn-pg", af: "af-latn-za", afb: "afb-arab-kw", afd: "afd-latn-pg", afe: "afe-latn-ng", afh: "afh-latn-gh", afi: "afi-latn-pg", afk: "afk-latn-pg", afn: "afn-latn-ng", afo: "afo-latn-ng", afp: "afp-latn-pg", afs: "afs-latn-mx", afu: "afu-latn-gh", afz: "afz-latn-id", aga: "aga-latn-pe", agb: "agb-latn-ng", agc: "agc-latn-zz", agd: "agd-latn-zz", age: "age-latn-pg", agf: "agf-latn-id", agg: "agg-latn-zz", agh: "agh-latn-cd", agi: "agi-deva-in", agj: "agj-ethi-et", "agj-arab": "agj-arab-et", agk: "agk-latn-ph", agl: "agl-latn-pg", agm: "agm-latn-zz", agn: "agn-latn-ph", ago: "ago-latn-zz", agq: "agq-latn-cm", agr: "agr-latn-pe", ags: "ags-latn-cm", agt: "agt-latn-ph", agu: "agu-latn-gt", agv: "agv-latn-ph", agw: "agw-latn-sb", agx: "agx-cyrl-ru", agy: "agy-latn-ph", agz: "agz-latn-ph", aha: "aha-latn-zz", ahb: "ahb-latn-vu", ahg: "ahg-ethi-et", ahh: "ahh-latn-id", ahi: "ahi-latn-ci", ahk: "ahk-latn-mm", "ahk-mymr": "ahk-mymr-mm", "ahk-th": "ahk-latn-th", "ahk-thai": "ahk-thai-th", ahl: "ahl-latn-zz", ahm: "ahm-latn-ci", ahn: "ahn-latn-ng", aho: "aho-ahom-in", ahp: "ahp-latn-ci", ahr: "ahr-deva-in", ahs: "ahs-latn-ng", aht: "aht-latn-us", aia: "aia-latn-sb", aib: "aib-arab-cn", aic: "aic-latn-pg", aid: "aid-latn-au", aie: "aie-latn-pg", aif: "aif-latn-pg", aig: "aig-latn-ag", aij: "aij-hebr-il", aik: "aik-latn-ng", ail: "ail-latn-pg", aim: "aim-latn-in", ain: "ain-kana-jp", "ain-latn": "ain-latn-jp", aio: "aio-mymr-in", aip: "aip-latn-id", aiq: "aiq-arab-af", air: "air-latn-id", ait: "ait-latn-br", aiw: "aiw-latn-et", "aiw-arab": "aiw-arab-et", "aiw-ethi": "aiw-ethi-et", aix: "aix-latn-pg", aiy: "aiy-latn-cf", aja: "aja-latn-ss", ajg: "ajg-latn-zz", aji: "aji-latn-nc", ajn: "ajn-latn-au", ajp: "ajp-arab-jo", ajt: "ajt-arab-tn", ajw: "ajw-latn-ng", ajz: "ajz-latn-in", ak: "ak-latn-gh", akb: "akb-latn-id", "akb-batk": "akb-batk-id", akc: "akc-latn-id", akd: "akd-latn-ng", ake: "ake-latn-gy", akf: "akf-latn-ng", akg: "akg-latn-id", akh: "akh-latn-pg", aki: "aki-latn-pg", akk: "akk-xsux-iq", akl: "akl-latn-ph", ako: "ako-latn-sr", akp: "akp-latn-gh", akq: "akq-latn-pg", akr: "akr-latn-vu", aks: "aks-latn-tg", akt: "akt-latn-pg", aku: "aku-latn-cm", akv: "akv-cyrl-ru", akw: "akw-latn-cg", akz: "akz-latn-us", ala: "ala-latn-zz", alc: "alc-latn-cl", ald: "ald-latn-ci", ale: "ale-latn-us", alf: "alf-latn-ng", alh: "alh-latn-au", ali: "ali-latn-zz", alj: "alj-latn-ph", alk: "alk-laoo-la", all: "all-mlym-in", alm: "alm-latn-vu", aln: "aln-latn-xk", alo: "alo-latn-id", alp: "alp-latn-id", alq: "alq-latn-ca", alr: "alr-cyrl-ru", alt: "alt-cyrl-ru", alu: "alu-latn-sb", alw: "alw-ethi-et", alx: "alx-latn-pg", aly: "aly-latn-au", alz: "alz-latn-cd", am: "am-ethi-et", ama: "ama-latn-br", amb: "amb-latn-ng", amc: "amc-latn-pe", ame: "ame-latn-pe", amf: "amf-latn-et", "amf-ethi": "amf-ethi-et", amg: "amg-latn-au", ami: "ami-latn-tw", amj: "amj-latn-td", amk: "amk-latn-id", amm: "amm-latn-zz", amn: "amn-latn-zz", amo: "amo-latn-ng", amp: "amp-latn-zz", amq: "amq-latn-id", amr: "amr-latn-pe", ams: "ams-jpan-jp", amt: "amt-latn-pg", amu: "amu-latn-mx", amv: "amv-latn-id", amw: "amw-syrc-sy", "amw-arab": "amw-arab-sy", "amw-armi": "amw-armi-sy", "amw-latn": "amw-latn-sy", amx: "amx-latn-au", amy: "amy-latn-au", amz: "amz-latn-au", an: "an-latn-es", ana: "ana-latn-co", anb: "anb-latn-pe", anc: "anc-latn-zz", and: "and-latn-id", ane: "ane-latn-nc", anf: "anf-latn-gh", ang: "ang-latn-gb", anh: "anh-latn-pg", ani: "ani-cyrl-ru", anj: "anj-latn-pg", ank: "ank-latn-zz", anl: "anl-latn-mm", anm: "anm-latn-in", ann: "ann-latn-ng", ano: "ano-latn-co", anp: "anp-deva-in", anr: "anr-deva-in", ans: "ans-latn-co", ant: "ant-latn-au", anu: "anu-ethi-et", "anu-arab": "anu-arab-ss", "anu-latn": "anu-latn-ss", anv: "anv-latn-cm", anw: "anw-latn-ng", anx: "anx-latn-pg", any: "any-latn-zz", anz: "anz-latn-pg", aoa: "aoa-latn-st", aob: "aob-latn-pg", aoc: "aoc-latn-ve", aod: "aod-latn-pg", aoe: "aoe-latn-pg", aof: "aof-latn-pg", aog: "aog-latn-pg", aoi: "aoi-latn-au", aoj: "aoj-latn-zz", aok: "aok-latn-nc", aol: "aol-latn-id", aom: "aom-latn-zz", aon: "aon-latn-pg", aor: "aor-latn-vu", aos: "aos-latn-id", aot: "aot-beng-bd", "aot-latn": "aot-latn-in", aox: "aox-latn-gy", aoz: "aoz-latn-id", apb: "apb-latn-sb", apc: "apc-arab-sy", apd: "apd-arab-tg", ape: "ape-latn-zz", apf: "apf-latn-ph", apg: "apg-latn-id", aph: "aph-deva-np", api: "api-latn-br", apj: "apj-latn-us", apk: "apk-latn-us", apl: "apl-latn-us", apm: "apm-latn-us", apn: "apn-latn-br", apo: "apo-latn-pg", app: "app-latn-vu", apr: "apr-latn-zz", aps: "aps-latn-zz", apt: "apt-latn-in", apu: "apu-latn-br", apv: "apv-latn-br", apw: "apw-latn-us", apx: "apx-latn-id", apy: "apy-latn-br", apz: "apz-latn-zz", aqc: "aqc-cyrl-ru", aqd: "aqd-latn-ml", aqg: "aqg-latn-ng", aqk: "aqk-latn-ng", aqm: "aqm-latn-id", aqn: "aqn-latn-ph", aqr: "aqr-latn-nc", aqt: "aqt-latn-py", aqz: "aqz-latn-br", ar: "ar-arab-eg", arc: "arc-armi-ir", "arc-nbat": "arc-nbat-jo", "arc-palm": "arc-palm-sy", ard: "ard-latn-au", are: "are-latn-au", arh: "arh-latn-zz", ari: "ari-latn-us", arj: "arj-latn-br", ark: "ark-latn-br", arl: "arl-latn-pe", arn: "arn-latn-cl", aro: "aro-latn-bo", arp: "arp-latn-us", arq: "arq-arab-dz", arr: "arr-latn-br", ars: "ars-arab-sa", aru: "aru-latn-br", arw: "arw-latn-sr", arx: "arx-latn-br", ary: "ary-arab-ma", arz: "arz-arab-eg", as: "as-beng-in", asa: "asa-latn-tz", asb: "asb-latn-ca", asc: "asc-latn-id", ase: "ase-sgnw-us", asg: "asg-latn-zz", ash: "ash-latn-pe", asi: "asi-latn-id", asj: "asj-latn-cm", ask: "ask-arab-af", asl: "asl-latn-id", asn: "asn-latn-br", aso: "aso-latn-zz", ass: "ass-latn-cm", ast: "ast-latn-es", asu: "asu-latn-br", asv: "asv-latn-cd", asx: "asx-latn-pg", asy: "asy-latn-id", asz: "asz-latn-id", ata: "ata-latn-zz", atb: "atb-latn-cn", "atb-lisu": "atb-lisu-cn", atc: "atc-latn-pe", atd: "atd-latn-ph", ate: "ate-latn-pg", atg: "atg-latn-zz", ati: "ati-latn-ci", atj: "atj-latn-ca", atk: "atk-latn-ph", atl: "atl-latn-ph", atm: "atm-latn-ph", atn: "atn-arab-ir", ato: "ato-latn-cm", atp: "atp-latn-ph", atq: "atq-latn-id", atr: "atr-latn-br", ats: "ats-latn-us", att: "att-latn-ph", atu: "atu-latn-ss", atv: "atv-cyrl-ru", atw: "atw-latn-us", atx: "atx-latn-br", aty: "aty-latn-vu", atz: "atz-latn-ph", aua: "aua-latn-sb", auc: "auc-latn-ec", aud: "aud-latn-sb", aug: "aug-latn-bj", auh: "auh-latn-zm", aui: "aui-latn-pg", auj: "auj-arab-ly", "auj-latn": "auj-latn-ly", "auj-tfng": "auj-tfng-ly", auk: "auk-latn-pg", aul: "aul-latn-vu", aum: "aum-latn-ng", aun: "aun-latn-pg", auo: "auo-latn-ng", aup: "aup-latn-pg", auq: "auq-latn-id", aur: "aur-latn-pg", aut: "aut-latn-pf", auu: "auu-latn-id", auw: "auw-latn-id", auy: "auy-latn-zz", auz: "auz-arab-uz", av: "av-cyrl-ru", avb: "avb-latn-pg", avd: "avd-arab-ir", avi: "avi-latn-ci", avk: "avk-latn-001", avl: "avl-arab-zz", avm: "avm-latn-au", avn: "avn-latn-zz", avo: "avo-latn-br", avs: "avs-latn-pe", avt: "avt-latn-zz", avu: "avu-latn-zz", avv: "avv-latn-br", awa: "awa-deva-in", awb: "awb-latn-zz", awc: "awc-latn-ng", awe: "awe-latn-br", awg: "awg-latn-au", awh: "awh-latn-id", awi: "awi-latn-pg", awk: "awk-latn-au", awm: "awm-latn-pg", awn: "awn-ethi-et", awo: "awo-latn-zz", awr: "awr-latn-id", aws: "aws-latn-id", awt: "awt-latn-br", awu: "awu-latn-id", awv: "awv-latn-id", aww: "aww-latn-pg", awx: "awx-latn-zz", awy: "awy-latn-id", axb: "axb-latn-ar", axe: "axe-latn-au", axg: "axg-latn-br", axk: "axk-latn-cf", axl: "axl-latn-au", axm: "axm-armn-am", axx: "axx-latn-nc", ay: "ay-latn-bo", aya: "aya-latn-pg", ayb: "ayb-latn-zz", ayc: "ayc-latn-pe", ayd: "ayd-latn-au", aye: "aye-latn-ng", ayg: "ayg-latn-tg", ayh: "ayh-arab-ye", ayi: "ayi-latn-ng", ayk: "ayk-latn-ng", ayl: "ayl-arab-ly", ayn: "ayn-arab-ye", ayo: "ayo-latn-py", ayp: "ayp-arab-iq", ayq: "ayq-latn-pg", ays: "ays-latn-ph", ayt: "ayt-latn-ph", ayu: "ayu-latn-ng", ayz: "ayz-latn-id", az: "az-latn-az", "az-arab": "az-arab-ir", "az-iq": "az-arab-iq", "az-ir": "az-arab-ir", "az-ru": "az-cyrl-ru", azb: "azb-arab-ir", "azb-cyrl": "azb-cyrl-az", "azb-latn": "azb-latn-az", azd: "azd-latn-mx", azg: "azg-latn-mx", azm: "azm-latn-mx", azn: "azn-latn-mx", azo: "azo-latn-cm", azt: "azt-latn-ph", azz: "azz-latn-mx", ba: "ba-cyrl-ru", baa: "baa-latn-sb", bab: "bab-latn-gw", bac: "bac-latn-id", bae: "bae-latn-ve", baf: "baf-latn-cm", bag: "bag-latn-cm", bah: "bah-latn-bs", baj: "baj-latn-id", bal: "bal-arab-pk", ban: "ban-latn-id", bao: "bao-latn-co", bap: "bap-deva-np", bar: "bar-latn-at", bas: "bas-latn-cm", bau: "bau-latn-ng", bav: "bav-latn-zz", baw: "baw-latn-cm", bax: "bax-bamu-cm", bay: "bay-latn-id", bba: "bba-latn-zz", bbb: "bbb-latn-zz", bbc: "bbc-latn-id", bbd: "bbd-latn-zz", bbe: "bbe-latn-cd", bbf: "bbf-latn-pg", bbg: "bbg-latn-ga", bbi: "bbi-latn-cm", bbj: "bbj-latn-cm", bbk: "bbk-latn-cm", bbl: "bbl-geor-ge", bbm: "bbm-latn-cd", bbn: "bbn-latn-pg", bbo: "bbo-latn-bf", bbp: "bbp-latn-zz", bbq: "bbq-latn-cm", bbr: "bbr-latn-zz", bbs: "bbs-latn-ng", bbt: "bbt-latn-ng", bbu: "bbu-latn-ng", bbv: "bbv-latn-pg", bbw: "bbw-latn-cm", bbx: "bbx-latn-cm", bby: "bby-latn-cm", bca: "bca-latn-cn", "bca-hani": "bca-hani-cn", bcb: "bcb-latn-sn", bcd: "bcd-latn-id", bce: "bce-latn-cm", bcf: "bcf-latn-zz", bcg: "bcg-latn-gn", bch: "bch-latn-zz", bci: "bci-latn-ci", bcj: "bcj-latn-au", bck: "bck-latn-au", bcm: "bcm-latn-zz", bcn: "bcn-latn-zz", bco: "bco-latn-zz", bcp: "bcp-latn-cd", bcq: "bcq-ethi-zz", bcr: "bcr-latn-ca", bcs: "bcs-latn-ng", bct: "bct-latn-cd", bcu: "bcu-latn-zz", bcv: "bcv-latn-ng", bcw: "bcw-latn-cm", bcy: "bcy-latn-ng", bcz: "bcz-latn-sn", bda: "bda-latn-sn", bdb: "bdb-latn-id", bdc: "bdc-latn-co", bdd: "bdd-latn-zz", bde: "bde-latn-ng", bdf: "bdf-latn-pg", bdg: "bdg-latn-my", bdh: "bdh-latn-ss", bdi: "bdi-latn-sd", bdj: "bdj-latn-ss", bdk: "bdk-latn-az", bdl: "bdl-latn-id", bdm: "bdm-latn-td", bdn: "bdn-latn-cm", bdo: "bdo-latn-td", bdp: "bdp-latn-tz", bdq: "bdq-latn-vn", bdr: "bdr-latn-my", bds: "bds-latn-tz", bdt: "bdt-latn-cf", bdu: "bdu-latn-cm", bdv: "bdv-orya-in", bdw: "bdw-latn-id", bdx: "bdx-latn-id", bdy: "bdy-latn-au", bdz: "bdz-arab-pk", be: "be-cyrl-by", bea: "bea-latn-ca", "bea-cans": "bea-cans-ca", beb: "beb-latn-cm", bec: "bec-latn-cm", bed: "bed-latn-id", bee: "bee-deva-in", bef: "bef-latn-zz", beh: "beh-latn-zz", bei: "bei-latn-id", bej: "bej-arab-sd", bek: "bek-latn-pg", bem: "bem-latn-zm", beo: "beo-latn-pg", bep: "bep-latn-id", beq: "beq-latn-cg", bes: "bes-latn-td", bet: "bet-latn-zz", beu: "beu-latn-id", bev: "bev-latn-ci", bew: "bew-latn-id", bex: "bex-latn-zz", bey: "bey-latn-pg", bez: "bez-latn-tz", bfa: "bfa-latn-ss", "bfa-arab": "bfa-arab-ss", bfb: "bfb-deva-in", bfc: "bfc-latn-cn", bfd: "bfd-latn-cm", bfe: "bfe-latn-id", bff: "bff-latn-cf", bfg: "bfg-latn-id", bfh: "bfh-latn-pg", bfj: "bfj-latn-cm", bfl: "bfl-latn-cf", bfm: "bfm-latn-cm", bfn: "bfn-latn-tl", bfo: "bfo-latn-bf", bfp: "bfp-latn-cm", bfq: "bfq-taml-in", bfs: "bfs-latn-cn", "bfs-hani": "bfs-hani-cn", bft: "bft-arab-pk", bfu: "bfu-tibt-in", "bfu-takr": "bfu-takr-in", bfw: "bfw-orya-in", bfx: "bfx-latn-ph", bfy: "bfy-deva-in", bfz: "bfz-deva-in", bg: "bg-cyrl-bg", bga: "bga-latn-ng", bgb: "bgb-latn-id", bgc: "bgc-deva-in", bgd: "bgd-deva-in", bgf: "bgf-latn-cm", bgg: "bgg-latn-in", bgi: "bgi-latn-ph", bgj: "bgj-latn-cm", bgn: "bgn-arab-pk", bgo: "bgo-latn-gn", bgp: "bgp-arab-pk", bgq: "bgq-deva-in", bgr: "bgr-latn-in", bgs: "bgs-latn-ph", bgt: "bgt-latn-sb", bgu: "bgu-latn-ng", bgv: "bgv-latn-id", bgw: "bgw-deva-in", bgx: "bgx-grek-tr", bgy: "bgy-latn-id", bgz: "bgz-latn-id", bha: "bha-deva-in", bhb: "bhb-deva-in", bhc: "bhc-latn-id", bhd: "bhd-deva-in", "bhd-arab": "bhd-arab-in", "bhd-takr": "bhd-takr-in", bhe: "bhe-arab-pk", bhf: "bhf-latn-pg", bhg: "bhg-latn-zz", bhh: "bhh-cyrl-il", "bhh-hebr": "bhh-hebr-il", "bhh-latn": "bhh-latn-il", bhi: "bhi-deva-in", bhj: "bhj-deva-np", bhl: "bhl-latn-zz", bhm: "bhm-arab-om", bhn: "bhn-syrc-ge", bho: "bho-deva-in", bhp: "bhp-latn-id", bhq: "bhq-latn-id", bhr: "bhr-latn-mg", bhs: "bhs-latn-cm", bht: "bht-takr-in", "bht-deva": "bht-deva-in", "bht-latn": "bht-latn-in", bhu: "bhu-deva-in", bhv: "bhv-latn-id", bhw: "bhw-latn-id", bhy: "bhy-latn-zz", bhz: "bhz-latn-id", bi: "bi-latn-vu", bia: "bia-latn-au", bib: "bib-latn-zz", bid: "bid-latn-td", bie: "bie-latn-pg", bif: "bif-latn-gw", big: "big-latn-zz", bik: "bik-latn-ph", bil: "bil-latn-ng", bim: "bim-latn-zz", bin: "bin-latn-ng", bio: "bio-latn-zz", bip: "bip-latn-cd", biq: "biq-latn-zz", bir: "bir-latn-pg", bit: "bit-latn-pg", biu: "biu-latn-in", biv: "biv-latn-gh", biw: "biw-latn-cm", biy: "biy-deva-in", biz: "biz-latn-cd", bja: "bja-latn-cd", bjb: "bjb-latn-au", bjc: "bjc-latn-pg", bjf: "bjf-syrc-il", bjg: "bjg-latn-gw", bjh: "bjh-latn-zz", bji: "bji-ethi-zz", bjj: "bjj-deva-in", bjk: "bjk-latn-pg", bjl: "bjl-latn-pg", bjm: "bjm-arab-iq", bjn: "bjn-latn-id", bjo: "bjo-latn-zz", bjp: "bjp-latn-pg", bjr: "bjr-latn-zz", bjs: "bjs-latn-bb", bjt: "bjt-latn-sn", bju: "bju-latn-cm", bjv: "bjv-latn-td", bjw: "bjw-latn-ci", bjx: "bjx-latn-ph", bjy: "bjy-latn-au", bjz: "bjz-latn-zz", bka: "bka-latn-ng", bkc: "bkc-latn-zz", bkd: "bkd-latn-ph", bkf: "bkf-latn-cd", bkg: "bkg-latn-cf", bkh: "bkh-latn-cm", bki: "bki-latn-vu", bkj: "bkj-latn-cf", bkl: "bkl-latn-id", bkm: "bkm-latn-cm", bkn: "bkn-latn-id", bko: "bko-latn-cm", bkp: "bkp-latn-cd", bkq: "bkq-latn-zz", bkr: "bkr-latn-id", bks: "bks-latn-ph", bkt: "bkt-latn-cd", bku: "bku-latn-ph", bkv: "bkv-latn-zz", bkw: "bkw-latn-cg", bkx: "bkx-latn-tl", bky: "bky-latn-ng", bkz: "bkz-latn-id", bla: "bla-latn-ca", blb: "blb-latn-sb", blc: "blc-latn-ca", bld: "bld-latn-id", ble: "ble-latn-gw", blf: "blf-latn-id", blg: "blg-latn-my", blh: "blh-latn-lr", bli: "bli-latn-cd", blj: "blj-latn-id", blk: "blk-mymr-mm", blm: "blm-latn-ss", bln: "bln-latn-ph", blo: "blo-latn-bj", blp: "blp-latn-sb", blq: "blq-latn-pg", blr: "blr-latn-cn", "blr-tale": "blr-tale-cn", "blr-thai": "blr-thai-th", bls: "bls-latn-id", blt: "blt-tavt-vn", blv: "blv-latn-ao", blw: "blw-latn-ph", blx: "blx-latn-ph", bly: "bly-latn-bj", blz: "blz-latn-id", bm: "bm-latn-ml", bma: "bma-latn-ng", bmb: "bmb-latn-cd", bmc: "bmc-latn-pg", bmd: "bmd-latn-gn", bme: "bme-latn-cf", bmf: "bmf-latn-sl", bmg: "bmg-latn-cd", bmh: "bmh-latn-zz", bmi: "bmi-latn-td", bmj: "bmj-deva-np", bmk: "bmk-latn-zz", bml: "bml-latn-cd", bmm: "bmm-latn-mg", bmn: "bmn-latn-pg", bmo: "bmo-latn-cm", bmp: "bmp-latn-pg", bmq: "bmq-latn-ml", bmr: "bmr-latn-co", bms: "bms-latn-ne", bmu: "bmu-latn-zz", bmv: "bmv-latn-cm", bmw: "bmw-latn-cg", bmx: "bmx-latn-pg", bmz: "bmz-latn-pg", bn: "bn-beng-bd", bna: "bna-latn-id", bnb: "bnb-latn-my", bnc: "bnc-latn-ph", bnd: "bnd-latn-id", bne: "bne-latn-id", bnf: "bnf-latn-id", bng: "bng-latn-zz", bni: "bni-latn-cd", bnj: "bnj-latn-ph", bnk: "bnk-latn-vu", bnm: "bnm-latn-zz", bnn: "bnn-latn-tw", bno: "bno-latn-ph", bnp: "bnp-latn-zz", bnq: "bnq-latn-id", bnr: "bnr-latn-vu", bns: "bns-deva-in", bnu: "bnu-latn-id", bnv: "bnv-latn-id", bnw: "bnw-latn-pg", bnx: "bnx-latn-cd", bny: "bny-latn-my", bnz: "bnz-latn-cm", bo: "bo-tibt-cn", boa: "boa-latn-pe", bob: "bob-latn-ke", boe: "boe-latn-cm", bof: "bof-latn-bf", boh: "boh-latn-cd", boj: "boj-latn-zz", bok: "bok-latn-cg", bol: "bol-latn-ng", bom: "bom-latn-zz", bon: "bon-latn-zz", boo: "boo-latn-ml", bop: "bop-latn-pg", boq: "boq-latn-pg", bor: "bor-latn-br", bot: "bot-latn-ss", bou: "bou-latn-tz", bov: "bov-latn-gh", bow: "bow-latn-pg", box: "box-latn-bf", boy: "boy-latn-cf", boz: "boz-latn-ml", "boz-arab": "boz-arab-ml", bpa: "bpa-latn-vu", bpc: "bpc-latn-cm", bpd: "bpd-latn-cf", bpe: "bpe-latn-pg", bpg: "bpg-latn-id", bph: "bph-cyrl-ru", bpi: "bpi-latn-pg", bpj: "bpj-latn-cd", bpk: "bpk-latn-nc", bpl: "bpl-latn-au", bpm: "bpm-latn-pg", bpo: "bpo-latn-id", bpp: "bpp-latn-id", bpq: "bpq-latn-id", bpr: "bpr-latn-ph", bps: "bps-latn-ph", bpt: "bpt-latn-au", bpu: "bpu-latn-pg", bpv: "bpv-latn-id", bpw: "bpw-latn-pg", bpx: "bpx-deva-in", bpy: "bpy-beng-in", bpz: "bpz-latn-id", bqa: "bqa-latn-bj", bqb: "bqb-latn-id", bqc: "bqc-latn-zz", bqd: "bqd-latn-cm", bqf: "bqf-latn-gn", "bqf-arab": "bqf-arab-gn", bqg: "bqg-latn-tg", bqi: "bqi-arab-ir", bqj: "bqj-latn-sn", bqk: "bqk-latn-cf", bql: "bql-latn-pg", bqm: "bqm-latn-cm", bqo: "bqo-latn-cm", bqp: "bqp-latn-zz", bqq: "bqq-latn-id", bqr: "bqr-latn-id", bqs: "bqs-latn-pg", bqt: "bqt-latn-cm", bqu: "bqu-latn-cd", bqv: "bqv-latn-ci", bqw: "bqw-latn-ng", bqx: "bqx-latn-ng", bqz: "bqz-latn-cm", br: "br-latn-fr", bra: "bra-deva-in", brb: "brb-khmr-kh", "brb-laoo": "brb-laoo-la", "brb-latn": "brb-latn-vn", brc: "brc-latn-gy", brd: "brd-deva-np", brf: "brf-latn-cd", brg: "brg-latn-bo", brh: "brh-arab-pk", bri: "bri-latn-cm", brj: "brj-latn-vu", brk: "brk-arab-sd", brl: "brl-latn-bw", brm: "brm-latn-cd", brn: "brn-latn-cr", brp: "brp-latn-id", brq: "brq-latn-pg", brr: "brr-latn-sb", brs: "brs-latn-id", brt: "brt-latn-ng", bru: "bru-latn-vn", "bru-laoo": "bru-laoo-la", "bru-thai": "bru-thai-la", brv: "brv-laoo-la", brx: "brx-deva-in", bry: "bry-latn-pg", brz: "brz-latn-zz", bs: "bs-latn-ba", bsa: "bsa-latn-id", bsb: "bsb-latn-bn", bsc: "bsc-latn-sn", bse: "bse-latn-cm", bsf: "bsf-latn-ng", bsh: "bsh-arab-af", bsi: "bsi-latn-cm", bsj: "bsj-latn-zz", bsk: "bsk-arab-pk", "bsk-latn": "bsk-latn-pk", bsl: "bsl-latn-ng", bsm: "bsm-latn-id", bsn: "bsn-latn-co", bso: "bso-latn-td", bsp: "bsp-latn-gn", bsq: "bsq-bass-lr", bsr: "bsr-latn-ng", bss: "bss-latn-cm", bst: "bst-ethi-zz", bsu: "bsu-latn-id", bsv: "bsv-latn-gn", "bsv-arab": "bsv-arab-gn", bsw: "bsw-latn-et", "bsw-ethi": "bsw-ethi-et", bsx: "bsx-latn-ng", bsy: "bsy-latn-my", bta: "bta-latn-ng", btc: "btc-latn-cm", btd: "btd-batk-id", bte: "bte-latn-ng", btf: "btf-latn-td", btg: "btg-latn-ci", bth: "bth-latn-my", bti: "bti-latn-id", btj: "btj-latn-id", btm: "btm-batk-id", btn: "btn-latn-ph", bto: "bto-latn-ph", btp: "btp-latn-pg", btq: "btq-latn-my", btr: "btr-latn-vu", bts: "bts-latn-id", "bts-batk": "bts-batk-id", btt: "btt-latn-zz", btu: "btu-latn-ng", btv: "btv-deva-pk", btw: "btw-latn-ph", btx: "btx-latn-id", "btx-batk": "btx-batk-id", bty: "bty-latn-id", btz: "btz-latn-id", bua: "bua-cyrl-ru", bub: "bub-latn-td", buc: "buc-latn-yt", bud: "bud-latn-zz", bue: "bue-latn-ca", buf: "buf-latn-cd", bug: "bug-latn-id", buh: "buh-latn-cn", bui: "bui-latn-cg", buj: "buj-latn-ng", buk: "buk-latn-zz", bum: "bum-latn-cm", bun: "bun-latn-sl", buo: "buo-latn-zz", bup: "bup-latn-id", buq: "buq-latn-pg", bus: "bus-latn-zz", but: "but-latn-pg", buu: "buu-latn-zz", buv: "buv-latn-pg", buw: "buw-latn-ga", bux: "bux-latn-ng", buy: "buy-latn-sl", buz: "buz-latn-ng", bva: "bva-latn-td", bvb: "bvb-latn-gq", bvc: "bvc-latn-sb", bvd: "bvd-latn-sb", bve: "bve-latn-id", bvf: "bvf-latn-td", bvg: "bvg-latn-cm", bvh: "bvh-latn-ng", bvi: "bvi-latn-ss", bvj: "bvj-latn-ng", bvk: "bvk-latn-id", bvm: "bvm-latn-cm", bvn: "bvn-latn-pg", bvo: "bvo-latn-td", bvq: "bvq-latn-cf", bvr: "bvr-latn-au", bvt: "bvt-latn-id", bvu: "bvu-latn-id", bvv: "bvv-latn-ve", bvw: "bvw-latn-ng", bvx: "bvx-latn-cg", bvy: "bvy-latn-ph", bvz: "bvz-latn-id", bwa: "bwa-latn-nc", bwb: "bwb-latn-fj", bwc: "bwc-latn-zm", bwd: "bwd-latn-zz", bwe: "bwe-mymr-mm", "bwe-latn": "bwe-latn-mm", bwf: "bwf-latn-pg", bwg: "bwg-latn-mz", bwh: "bwh-latn-cm", bwi: "bwi-latn-ve", bwj: "bwj-latn-bf", bwk: "bwk-latn-pg", bwl: "bwl-latn-cd", bwm: "bwm-latn-pg", bwo: "bwo-latn-et", "bwo-ethi": "bwo-ethi-et", bwp: "bwp-latn-id", bwq: "bwq-latn-bf", bwr: "bwr-latn-zz", bws: "bws-latn-cd", bwt: "bwt-latn-cm", bwu: "bwu-latn-gh", bww: "bww-latn-cd", bwx: "bwx-latn-cn", bwy: "bwy-latn-bf", bwz: "bwz-latn-cg", bxa: "bxa-latn-sb", bxb: "bxb-latn-ss", bxc: "bxc-latn-gq", bxf: "bxf-latn-pg", bxg: "bxg-latn-cd", bxh: "bxh-latn-zz", bxi: "bxi-latn-au", bxj: "bxj-latn-au", bxl: "bxl-latn-bf", bxm: "bxm-cyrl-mn", "bxm-latn": "bxm-latn-mn", "bxm-mong": "bxm-mong-mn", bxn: "bxn-latn-au", bxo: "bxo-latn-ng", bxp: "bxp-latn-cm", bxq: "bxq-latn-ng", bxs: "bxs-latn-cm", bxu: "bxu-mong-cn", "bxu-cyrl": "bxu-cyrl-cn", "bxu-latn": "bxu-latn-cn", bxv: "bxv-latn-td", bxw: "bxw-latn-ml", bxz: "bxz-latn-pg", bya: "bya-latn-ph", byb: "byb-latn-cm", byc: "byc-latn-ng", byd: "byd-latn-id", bye: "bye-latn-zz", byf: "byf-latn-ng", byh: "byh-deva-np", byi: "byi-latn-cd", byj: "byj-latn-ng", byk: "byk-latn-cn", byl: "byl-latn-id", bym: "bym-latn-au", byn: "byn-ethi-er", byp: "byp-latn-ng", byr: "byr-latn-zz", bys: "bys-latn-zz", byv: "byv-latn-cm", byw: "byw-deva-np", byx: "byx-latn-zz", byz: "byz-latn-pg", bza: "bza-latn-zz", bzb: "bzb-latn-id", bzc: "bzc-latn-mg", bzd: "bzd-latn-cr", bze: "bze-latn-ml", bzf: "bzf-latn-zz", bzh: "bzh-latn-zz", bzi: "bzi-thai-th", bzj: "bzj-latn-bz", bzk: "bzk-latn-ni", bzl: "bzl-latn-id", bzm: "bzm-latn-cd", bzn: "bzn-latn-id", bzo: "bzo-latn-cd", bzp: "bzp-latn-id", bzq: "bzq-latn-id", bzr: "bzr-latn-au", bzt: "bzt-latn-001", bzu: "bzu-latn-id", bzv: "bzv-latn-cm", bzw: "bzw-latn-zz", bzx: "bzx-latn-ml", bzy: "bzy-latn-ng", bzz: "bzz-latn-ng", ca: "ca-latn-es", caa: "caa-latn-gt", cab: "cab-latn-hn", cac: "cac-latn-gt", cad: "cad-latn-us", cae: "cae-latn-sn", caf: "caf-latn-ca", "caf-cans": "caf-cans-ca", cag: "cag-latn-py", cah: "cah-latn-pe", caj: "caj-latn-ar", cak: "cak-latn-gt", cal: "cal-latn-mp", cam: "cam-latn-nc", can: "can-latn-zz", cao: "cao-latn-bo", cap: "cap-latn-bo", caq: "caq-latn-in", car: "car-latn-ve", cas: "cas-latn-bo", cav: "cav-latn-bo", caw: "caw-latn-bo", cax: "cax-latn-bo", cay: "cay-latn-ca", caz: "caz-latn-bo", cbb: "cbb-latn-co", cbc: "cbc-latn-co", cbd: "cbd-latn-co", cbg: "cbg-latn-co", cbi: "cbi-latn-ec", cbj: "cbj-latn-zz", cbk: "cbk-latn-ph", "cbk-brai": "cbk-brai-ph", cbl: "cbl-latn-mm", cbn: "cbn-thai-th", cbo: "cbo-latn-ng", cbq: "cbq-latn-ng", cbr: "cbr-latn-pe", cbs: "cbs-latn-pe", cbt: "cbt-latn-pe", cbu: "cbu-latn-pe", cbv: "cbv-latn-co", cbw: "cbw-latn-ph", cby: "cby-latn-co", ccc: "ccc-latn-pe", ccd: "ccd-latn-br", cce: "cce-latn-mz", ccg: "ccg-latn-ng", cch: "cch-latn-ng", ccj: "ccj-latn-gw", ccl: "ccl-latn-tz", ccm: "ccm-latn-my", cco: "cco-latn-mx", ccp: "ccp-cakm-bd", ccr: "ccr-latn-sv", cde: "cde-telu-in", cdf: "cdf-latn-in", "cdf-beng": "cdf-beng-in", cdh: "cdh-deva-in", "cdh-takr": "cdh-takr-in", cdi: "cdi-gujr-in", cdj: "cdj-deva-in", cdm: "cdm-deva-np", "cdm-latn": "cdm-latn-np", cdo: "cdo-hans-cn", "cdo-hant": "cdo-hant-cn", "cdo-latn": "cdo-latn-cn", cdr: "cdr-latn-ng", cdz: "cdz-beng-in", ce: "ce-cyrl-ru", cea: "cea-latn-us", ceb: "ceb-latn-ph", ceg: "ceg-latn-py", cek: "cek-latn-mm", cen: "cen-latn-ng", cet: "cet-latn-ng", cey: "cey-latn-mm", cfa: "cfa-latn-zz", cfd: "cfd-latn-ng", cfg: "cfg-latn-ng", cfm: "cfm-latn-mm", "cfm-beng": "cfm-beng-in", cga: "cga-latn-pg", cgc: "cgc-latn-ph", cgg: "cgg-latn-ug", cgk: "cgk-tibt-bt", ch: "ch-latn-gu", chb: "chb-latn-co", chd: "chd-latn-mx", chf: "chf-latn-mx", chg: "chg-arab-tm", chh: "chh-latn-us", chj: "chj-latn-mx", chk: "chk-latn-fm", chl: "chl-latn-us", chm: "chm-cyrl-ru", chn: "chn-latn-us", "chn-dupl": "chn-dupl-us", cho: "cho-latn-us", chp: "chp-latn-ca", chq: "chq-latn-mx", chr: "chr-cher-us", cht: "cht-latn-pe", chw: "chw-latn-mz", chx: "chx-deva-np", chy: "chy-latn-us", chz: "chz-latn-mx", cia: "cia-latn-id", "cia-arab": "cia-arab-id", "cia-hang": "cia-hang-id", cib: "cib-latn-bj", cic: "cic-latn-us", cie: "cie-latn-ng", cih: "cih-deva-in", cim: "cim-latn-it", cin: "cin-latn-br", cip: "cip-latn-mx", cir: "cir-latn-nc", ciw: "ciw-latn-us", "ciw-cans": "ciw-cans-us", ciy: "ciy-latn-ve", cja: "cja-arab-kh", cje: "cje-latn-vn", cjh: "cjh-latn-us", cji: "cji-cyrl-ru", cjk: "cjk-latn-ao", cjm: "cjm-cham-vn", cjn: "cjn-latn-pg", cjo: "cjo-latn-pe", cjp: "cjp-latn-cr", cjs: "cjs-latn-ru", "cjs-cyrl": "cjs-cyrl-ru", cjv: "cjv-latn-zz", cjy: "cjy-hans-cn", "cjy-hant": "cjy-hant-cn", ckb: "ckb-arab-iq", ckl: "ckl-latn-zz", ckm: "ckm-latn-hr", "ckm-glag": "ckm-glag-hr", ckn: "ckn-latn-mm", cko: "cko-latn-zz", ckq: "ckq-latn-td", ckr: "ckr-latn-pg", cks: "cks-latn-nc", ckt: "ckt-cyrl-ru", cku: "cku-latn-us", ckv: "ckv-latn-tw", ckx: "ckx-latn-cm", cky: "cky-latn-zz", ckz: "ckz-latn-gt", cla: "cla-latn-zz", clc: "clc-latn-ca", cle: "cle-latn-mx", clh: "clh-arab-pk", cli: "cli-latn-gh", clj: "clj-latn-mm", clk: "clk-latn-in", "clk-tibt": "clk-tibt-cn", cll: "cll-latn-gh", clm: "clm-latn-us", clo: "clo-latn-mx", clt: "clt-latn-mm", clu: "clu-latn-ph", clw: "clw-cyrl-ru", cly: "cly-latn-mx", cma: "cma-latn-vn", cme: "cme-latn-zz", cmg: "cmg-soyo-mn", cmi: "cmi-latn-co", cml: "cml-latn-id", cmo: "cmo-latn-vn", "cmo-kh": "cmo-latn-kh", "cmo-khmr": "cmo-khmr-kh", cmr: "cmr-latn-mm", cms: "cms-latn-it", cmt: "cmt-latn-za", cna: "cna-tibt-in", cnb: "cnb-latn-mm", cnc: "cnc-latn-vn", cng: "cng-latn-cn", cnh: "cnh-latn-mm", cni: "cni-latn-pe", cnk: "cnk-latn-mm", cnl: "cnl-latn-mx", cnp: "cnp-hans-cn", "cnp-hant": "cnp-hant-cn", cnq: "cnq-latn-cm", cns: "cns-latn-id", cnt: "cnt-latn-mx", cnw: "cnw-latn-mm", cnx: "cnx-latn-gb", co: "co-latn-fr", coa: "coa-latn-au", cob: "cob-latn-mx", coc: "coc-latn-mx", cod: "cod-latn-pe", coe: "coe-latn-co", cof: "cof-latn-ec", cog: "cog-thai-th", coh: "coh-latn-ke", coj: "coj-latn-mx", cok: "cok-latn-mx", col: "col-latn-us", com: "com-latn-us", coo: "coo-latn-ca", cop: "cop-copt-eg", coq: "coq-latn-us", cot: "cot-latn-pe", cou: "cou-latn-sn", cox: "cox-latn-pe", coz: "coz-latn-mx", cpa: "cpa-latn-mx", cpb: "cpb-latn-pe", cpc: "cpc-latn-pe", cpg: "cpg-grek-gr", cpi: "cpi-latn-nr", cpn: "cpn-latn-gh", cpo: "cpo-latn-bf", cps: "cps-latn-ph", cpu: "cpu-latn-pe", cpx: "cpx-latn-cn", cpy: "cpy-latn-pe", cqd: "cqd-latn-cn", cr: "cr-cans-ca", crb: "crb-latn-vc", crc: "crc-latn-vu", crd: "crd-latn-us", crf: "crf-latn-co", crg: "crg-latn-ca", crh: "crh-cyrl-ua", cri: "cri-latn-st", crj: "crj-cans-ca", "crj-latn": "crj-latn-ca", crk: "crk-cans-ca", crl: "crl-cans-ca", crm: "crm-cans-ca", crn: "crn-latn-mx", cro: "cro-latn-us", crq: "crq-latn-ar", crs: "crs-latn-sc", crt: "crt-latn-ar", crv: "crv-latn-in", crw: "crw-latn-vn", crx: "crx-latn-ca", "crx-cans": "crx-cans-ca", cry: "cry-latn-ng", crz: "crz-latn-us", cs: "cs-latn-cz", csa: "csa-latn-mx", csb: "csb-latn-pl", csh: "csh-mymr-mm", "csh-latn": "csh-latn-mm", csj: "csj-latn-mm", csk: "csk-latn-sn", csm: "csm-latn-us", cso: "cso-latn-mx", csp: "csp-hans-cn", "csp-hant": "csp-hant-cn", css: "css-latn-us", cst: "cst-latn-us", csv: "csv-latn-mm", csw: "csw-cans-ca", csy: "csy-latn-mm", csz: "csz-latn-us", cta: "cta-latn-mx", ctc: "ctc-latn-us", ctd: "ctd-pauc-mm", cte: "cte-latn-mx", ctg: "ctg-beng-bd", "ctg-arab": "ctg-arab-bd", "ctg-latn": "ctg-latn-bd", cth: "cth-latn-mm", ctl: "ctl-latn-mx", ctm: "ctm-latn-us", ctn: "ctn-deva-np", cto: "cto-latn-co", ctp: "ctp-latn-mx", cts: "cts-latn-ph", ctt: "ctt-taml-in", ctu: "ctu-latn-mx", ctz: "ctz-latn-mx", cu: "cu-cyrl-ru", "cu-glag": "cu-glag-bg", cua: "cua-latn-vn", cub: "cub-latn-co", cuc: "cuc-latn-mx", cuh: "cuh-latn-ke", cui: "cui-latn-co", cuj: "cuj-latn-pe", cuk: "cuk-latn-pa", cul: "cul-latn-br", cuo: "cuo-latn-ve", cup: "cup-latn-us", cut: "cut-latn-mx", cuu: "cuu-lana-cn", cuv: "cuv-latn-cm", cux: "cux-latn-mx", cv: "cv-cyrl-ru", cvg: "cvg-latn-in", "cvg-tibt": "cvg-tibt-in", cvn: "cvn-latn-mx", cwa: "cwa-latn-tz", cwb: "cwb-latn-mz", cwe: "cwe-latn-tz", cwg: "cwg-latn-my", cwt: "cwt-latn-sn", cy: "cy-latn-gb", cya: "cya-latn-mx", cyb: "cyb-latn-bo", cyo: "cyo-latn-ph", czh: "czh-hans-cn", "czh-hant": "czh-hant-cn", czk: "czk-hebr-cz", czn: "czn-latn-mx", czt: "czt-latn-mm", da: "da-latn-dk", daa: "daa-latn-td", dac: "dac-latn-pg", dad: "dad-latn-zz", dae: "dae-latn-cm", daf: "daf-latn-ci", dag: "dag-latn-zz", dah: "dah-latn-zz", dai: "dai-latn-td", daj: "daj-latn-sd", dak: "dak-latn-us", dal: "dal-latn-ke", dam: "dam-latn-ng", dao: "dao-latn-mm", daq: "daq-deva-in", dar: "dar-cyrl-ru", das: "das-latn-ci", dau: "dau-latn-td", dav: "dav-latn-ke", daw: "daw-latn-ph", dax: "dax-latn-au", daz: "daz-latn-id", dba: "dba-latn-ml", dbb: "dbb-latn-ng", dbd: "dbd-latn-zz", dbe: "dbe-latn-id", dbf: "dbf-latn-id", dbg: "dbg-latn-ml", dbi: "dbi-latn-ng", dbj: "dbj-latn-my", "dbj-arab": "dbj-arab-my", dbl: "dbl-latn-au", dbm: "dbm-latn-ng", dbn: "dbn-latn-id", dbo: "dbo-latn-ng", dbp: "dbp-latn-ng", dbq: "dbq-latn-zz", dbt: "dbt-latn-ml", dbu: "dbu-latn-ml", dbv: "dbv-latn-ng", dbw: "dbw-latn-ml", dby: "dby-latn-pg", dcc: "dcc-arab-in", dcr: "dcr-latn-vi", dda: "dda-latn-au", ddd: "ddd-latn-ss", dde: "dde-latn-cg", ddg: "ddg-latn-tl", ddi: "ddi-latn-pg", ddj: "ddj-latn-au", ddn: "ddn-latn-zz", ddo: "ddo-cyrl-ru", ddr: "ddr-latn-au", dds: "dds-latn-ml", ddw: "ddw-latn-id", de: "de-latn-de", dec: "dec-latn-sd", ded: "ded-latn-zz", dee: "dee-latn-lr", def: "def-arab-ir", deg: "deg-latn-ng", deh: "deh-arab-pk", dei: "dei-latn-id", dek: "dek-latn-cm", del: "del-latn-us", dem: "dem-latn-id", den: "den-latn-ca", deq: "deq-latn-cf", der: "der-beng-in", "der-latn": "der-latn-in", des: "des-latn-br", dev: "dev-latn-pg", dez: "dez-latn-cd", dga: "dga-latn-zz", dgb: "dgb-latn-ml", dgc: "dgc-latn-ph", dgd: "dgd-latn-bf", dge: "dge-latn-pg", dgg: "dgg-latn-pg", dgh: "dgh-latn-zz", dgi: "dgi-latn-zz", dgk: "dgk-latn-cf", dgl: "dgl-arab-zz", dgn: "dgn-latn-au", dgr: "dgr-latn-ca", dgs: "dgs-latn-bf", dgt: "dgt-latn-au", dgw: "dgw-latn-au", dgx: "dgx-latn-pg", dgz: "dgz-latn-zz", dhg: "dhg-latn-au", dhi: "dhi-deva-np", dhl: "dhl-latn-au", dhm: "dhm-latn-ao", dhn: "dhn-gujr-in", dho: "dho-deva-in", dhr: "dhr-latn-au", dhs: "dhs-latn-tz", dhu: "dhu-latn-au", dhv: "dhv-latn-nc", dhw: "dhw-deva-np", dhx: "dhx-latn-au", dia: "dia-latn-zz", dib: "dib-latn-ss", dic: "dic-latn-ci", did: "did-latn-ss", dif: "dif-latn-au", dig: "dig-latn-ke", dih: "dih-latn-mx", dii: "dii-latn-cm", dij: "dij-latn-id", dil: "dil-latn-sd", din: "din-latn-ss", "din-arab": "din-arab-ss", dio: "dio-latn-ng", dip: "dip-latn-ss", dir: "dir-latn-ng", dis: "dis-latn-in", "dis-beng": "dis-beng-in", diu: "diu-latn-na", diw: "diw-latn-ss", dix: "dix-latn-vu", diy: "diy-latn-id", diz: "diz-latn-cd", dja: "dja-latn-au", djb: "djb-latn-au", djc: "djc-latn-td", djd: "djd-latn-au", dje: "dje-latn-ne", djf: "djf-latn-au", dji: "dji-latn-au", djj: "djj-latn-au", djk: "djk-latn-sr", djm: "djm-latn-ml", djn: "djn-latn-au", djo: "djo-latn-id", djr: "djr-latn-au", dju: "dju-latn-pg", djw: "djw-latn-au", dka: "dka-tibt-bt", dkg: "dkg-latn-ng", dkk: "dkk-latn-id", dkr: "dkr-latn-my", dks: "dks-latn-ss", dkx: "dkx-latn-cm", dlg: "dlg-cyrl-ru", dlm: "dlm-latn-hr", dln: "dln-latn-in", dma: "dma-latn-ga", dmb: "dmb-latn-ml", dmc: "dmc-latn-pg", dmd: "dmd-latn-au", dme: "dme-latn-cm", dmf: "dmf-medf-ng", dmg: "dmg-latn-my", dmk: "dmk-arab-pk", dml: "dml-arab-pk", dmm: "dmm-latn-cm", dmo: "dmo-latn-cm", dmr: "dmr-latn-id", dms: "dms-latn-id", dmu: "dmu-latn-id", dmv: "dmv-latn-my", dmw: "dmw-latn-au", dmx: "dmx-latn-mz", dmy: "dmy-latn-id", dna: "dna-latn-id", dnd: "dnd-latn-pg", dne: "dne-latn-tz", dng: "dng-cyrl-kg", "dng-arab": "dng-arab-kg", dni: "dni-latn-id", dnj: "dnj-latn-ci", dnk: "dnk-latn-id", dnn: "dnn-latn-bf", dno: "dno-latn-cd", dnr: "dnr-latn-pg", dnt: "dnt-latn-id", dnu: "dnu-mymr-mm", dnv: "dnv-mymr-mm", dnw: "dnw-latn-id", dny: "dny-latn-br", doa: "doa-latn-pg", dob: "dob-latn-zz", doc: "doc-latn-cn", doe: "doe-latn-tz", dof: "dof-latn-pg", doh: "doh-latn-ng", doi: "doi-deva-in", dok: "dok-latn-id", dol: "dol-latn-pg", don: "don-latn-pg", doo: "doo-latn-cd", dop: "dop-latn-zz", dor: "dor-latn-sb", dos: "dos-latn-bf", dot: "dot-latn-ng", dov: "dov-latn-zw", dow: "dow-latn-zz", dox: "dox-ethi-et", doy: "doy-latn-gh", dpp: "dpp-latn-my", drc: "drc-latn-pt", dre: "dre-tibt-np", drg: "drg-latn-my", drh: "drh-mong-cn", dri: "dri-latn-zz", drl: "drl-latn-au", drn: "drn-latn-id", dro: "dro-latn-my", drq: "drq-deva-np", drs: "drs-ethi-zz", drt: "drt-latn-nl", dru: "dru-latn-tw", dry: "dry-deva-np", dsb: "dsb-latn-de", dsh: "dsh-latn-ke", dsi: "dsi-latn-td", dsn: "dsn-latn-id", dso: "dso-orya-in", dsq: "dsq-latn-ml", "dsq-arab": "dsq-arab-ml", dta: "dta-latn-cn", "dta-cyrl": "dta-cyrl-cn", "dta-hans": "dta-hans-cn", dtb: "dtb-latn-my", dtd: "dtd-latn-ca", dth: "dth-latn-au", dti: "dti-latn-ml", dtk: "dtk-latn-ml", dtm: "dtm-latn-ml", dto: "dto-latn-ml", dtp: "dtp-latn-my", dtr: "dtr-latn-my", dts: "dts-latn-zz", dtt: "dtt-latn-ml", dtu: "dtu-latn-ml", dty: "dty-deva-np", dua: "dua-latn-cm", dub: "dub-gujr-in", duc: "duc-latn-zz", dud: "dud-latn-zz", due: "due-latn-ph", duf: "duf-latn-nc", dug: "dug-latn-zz", duh: "duh-deva-in", "duh-gujr": "duh-gujr-in", dui: "dui-latn-pg", duk: "duk-latn-pg", dul: "dul-latn-ph", dum: "dum-latn-nl", dun: "dun-latn-id", duo: "duo-latn-ph", dup: "dup-latn-id", duq: "duq-latn-id", dur: "dur-latn-cm", dus: "dus-deva-np", duu: "duu-latn-cn", duv: "duv-latn-id", duw: "duw-latn-id", dux: "dux-latn-ml", duy: "duy-latn-ph", duz: "duz-latn-cm", dv: "dv-thaa-mv", dva: "dva-latn-zz", dwa: "dwa-latn-ng", dwk: "dwk-orya-in", dwr: "dwr-latn-et", "dwr-ethi": "dwr-ethi-et", dws: "dws-latn-001", dwu: "dwu-latn-au", dww: "dww-latn-zz", dwy: "dwy-latn-au", dwz: "dwz-deva-np", dya: "dya-latn-bf", dyb: "dyb-latn-au", dyd: "dyd-latn-au", dyg: "dyg-latn-ph", dyi: "dyi-latn-ci", dym: "dym-latn-ml", dyn: "dyn-latn-au", dyo: "dyo-latn-sn", dyu: "dyu-latn-bf", dyy: "dyy-latn-au", dz: "dz-tibt-bt", dza: "dza-latn-ng", dze: "dze-latn-au", dzg: "dzg-latn-zz", dzl: "dzl-tibt-bt", dzn: "dzn-latn-cd", eaa: "eaa-latn-au", ebc: "ebc-latn-id", ebg: "ebg-latn-ng", ebk: "ebk-latn-ph", ebo: "ebo-latn-cg", ebr: "ebr-latn-ci", ebu: "ebu-latn-ke", ecr: "ecr-grek-gr", ecy: "ecy-cprt-cy", ee: "ee-latn-gh", efa: "efa-latn-ng", efe: "efe-latn-cd", efi: "efi-latn-ng", ega: "ega-latn-ci", egl: "egl-latn-it", egm: "egm-latn-tz", ego: "ego-latn-ng", egy: "egy-egyp-eg", ehu: "ehu-latn-ng", eip: "eip-latn-id", eit: "eit-latn-pg", eiv: "eiv-latn-pg", eja: "eja-latn-gw", eka: "eka-latn-zz", eke: "eke-latn-ng", ekg: "ekg-latn-id", eki: "eki-latn-ng", ekl: "ekl-latn-bd", ekm: "ekm-latn-cm", eko: "eko-latn-mz", "eko-arab": "eko-arab-mz", ekp: "ekp-latn-ng", ekr: "ekr-latn-ng", eky: "eky-kali-mm", el: "el-grek-gr", ele: "ele-latn-pg", elk: "elk-latn-pg", elm: "elm-latn-ng", elo: "elo-latn-ke", elu: "elu-latn-pg", ema: "ema-latn-zz", emb: "emb-latn-id", eme: "eme-latn-gf", emg: "emg-deva-np", emi: "emi-latn-zz", emm: "emm-latn-mx", emn: "emn-latn-cm", emp: "emp-latn-pa", ems: "ems-latn-us", "ems-cyrl": "ems-cyrl-us", emu: "emu-deva-in", emw: "emw-latn-id", emx: "emx-latn-fr", emz: "emz-latn-cm", en: "en-latn-us", "en-shaw": "en-shaw-gb", ena: "ena-latn-pg", enb: "enb-latn-ke", enc: "enc-latn-vn", end: "end-latn-id", enf: "enf-cyrl-ru", enh: "enh-cyrl-ru", enl: "enl-latn-py", enm: "enm-latn-gb", enn: "enn-latn-zz", eno: "eno-latn-id", enq: "enq-latn-zz", enr: "enr-latn-id", env: "env-latn-ng", enw: "enw-latn-ng", enx: "enx-latn-py", eo: "eo-latn-001", eot: "eot-latn-ci", epi: "epi-latn-ng", era: "era-taml-in", erg: "erg-latn-vu", erh: "erh-latn-ng", eri: "eri-latn-zz", erk: "erk-latn-vu", err: "err-latn-au", ert: "ert-latn-id", erw: "erw-latn-id", es: "es-latn-es", ese: "ese-latn-bo", esg: "esg-gonm-in", esh: "esh-arab-ir", esi: "esi-latn-us", esm: "esm-latn-ci", ess: "ess-latn-us", "ess-cyrl": "ess-cyrl-us", esu: "esu-latn-us", esy: "esy-latn-ph", et: "et-latn-ee", etb: "etb-latn-ng", etn: "etn-latn-vu", eto: "eto-latn-cm", etr: "etr-latn-zz", ets: "ets-latn-ng", ett: "ett-ital-it", etu: "etu-latn-zz", etx: "etx-latn-zz", etz: "etz-latn-id", eu: "eu-latn-es", eve: "eve-cyrl-ru", evh: "evh-latn-ng", evn: "evn-cyrl-ru", "evn-latn": "evn-latn-cn", "evn-mong": "evn-mong-cn", ewo: "ewo-latn-cm", ext: "ext-latn-es", eya: "eya-latn-us", eyo: "eyo-latn-ke", eza: "eza-latn-zz", eze: "eze-latn-ng", fa: "fa-arab-ir", faa: "faa-latn-zz", fab: "fab-latn-zz", fad: "fad-latn-pg", faf: "faf-latn-sb", fag: "fag-latn-zz", fah: "fah-latn-ng", fai: "fai-latn-zz", faj: "faj-latn-pg", fak: "fak-latn-cm", fal: "fal-latn-cm", fam: "fam-latn-ng", fan: "fan-latn-gq", fap: "fap-latn-sn", far: "far-latn-sb", fau: "fau-latn-id", fax: "fax-latn-es", fay: "fay-arab-ir", faz: "faz-arab-ir", fbl: "fbl-latn-ph", fer: "fer-latn-ss", ff: "ff-latn-sn", "ff-adlm": "ff-adlm-gn", ffi: "ffi-latn-zz", ffm: "ffm-latn-ml", fgr: "fgr-latn-td", fi: "fi-latn-fi", fia: "fia-arab-sd", fie: "fie-latn-ng", fif: "fif-latn-sa", fil: "fil-latn-ph", fip: "fip-latn-tz", fir: "fir-latn-ng", fit: "fit-latn-se", fiw: "fiw-latn-pg", fj: "fj-latn-fj", fkk: "fkk-latn-ng", fkv: "fkv-latn-no", fla: "fla-latn-us", flh: "flh-latn-id", fli: "fli-latn-ng", fll: "fll-latn-cm", fln: "fln-latn-au", flr: "flr-latn-zz", fly: "fly-latn-za", fmp: "fmp-latn-zz", fmu: "fmu-deva-in", fnb: "fnb-latn-vu", fng: "fng-latn-za", fni: "fni-latn-td", fo: "fo-latn-fo", fod: "fod-latn-zz", foi: "foi-latn-pg", fom: "fom-latn-cd", fon: "fon-latn-bj", for: "for-latn-zz", fos: "fos-latn-tw", fpe: "fpe-latn-zz", fqs: "fqs-latn-zz", fr: "fr-latn-fr", frc: "frc-latn-us", frd: "frd-latn-id", frk: "frk-latn-de", frm: "frm-latn-fr", fro: "fro-latn-fr", frp: "frp-latn-fr", frq: "frq-latn-pg", frr: "frr-latn-de", frs: "frs-latn-de", frt: "frt-latn-vu", fub: "fub-arab-cm", fud: "fud-latn-wf", fue: "fue-latn-zz", fuf: "fuf-latn-gn", fuh: "fuh-latn-zz", fui: "fui-latn-td", fum: "fum-latn-ng", fun: "fun-latn-br", fuq: "fuq-latn-ne", fur: "fur-latn-it", fut: "fut-latn-vu", fuu: "fuu-latn-cd", fuv: "fuv-latn-ng", fuy: "fuy-latn-zz", fvr: "fvr-latn-sd", fwa: "fwa-latn-nc", fwe: "fwe-latn-na", fy: "fy-latn-nl", ga: "ga-latn-ie", gaa: "gaa-latn-gh", gab: "gab-latn-td", gac: "gac-latn-in", "gac-deva": "gac-deva-in", gad: "gad-latn-ph", gae: "gae-latn-ve", gaf: "gaf-latn-zz", gag: "gag-latn-md", gah: "gah-latn-zz", gai: "gai-latn-pg", gaj: "gaj-latn-zz", gak: "gak-latn-id", gal: "gal-latn-tl", gam: "gam-latn-zz", gan: "gan-hans-cn", gao: "gao-latn-pg", gap: "gap-latn-pg", gaq: "gaq-orya-in", gar: "gar-latn-pg", gas: "gas-gujr-in", gat: "gat-latn-pg", gau: "gau-telu-in", gaw: "gaw-latn-zz", gax: "gax-latn-et", "gax-ethi": "gax-ethi-et", gay: "gay-latn-id", gba: "gba-latn-zz", gbb: "gbb-latn-au", gbd: "gbd-latn-au", gbe: "gbe-latn-pg", gbf: "gbf-latn-zz", gbg: "gbg-latn-cf", gbh: "gbh-latn-bj", gbi: "gbi-latn-id", gbj: "gbj-orya-in", gbk: "gbk-deva-in", "gbk-takr": "gbk-takr-in", gbl: "gbl-gujr-in", "gbl-deva": "gbl-deva-in", gbm: "gbm-deva-in", gbn: "gbn-latn-ss", gbp: "gbp-latn-cf", gbq: "gbq-latn-cf", gbr: "gbr-latn-ng", gbs: "gbs-latn-bj", gbu: "gbu-latn-au", gbv: "gbv-latn-cf", gbw: "gbw-latn-au", gbx: "gbx-latn-bj", gby: "gby-latn-zz", gbz: "gbz-arab-ir", gcc: "gcc-latn-pg", gcd: "gcd-latn-au", gcf: "gcf-latn-gp", gcl: "gcl-latn-gd", gcn: "gcn-latn-pg", gcr: "gcr-latn-gf", gct: "gct-latn-ve", gd: "gd-latn-gb", gdb: "gdb-orya-in", "gdb-telu": "gdb-telu-in", gdc: "gdc-latn-au", gdd: "gdd-latn-pg", gde: "gde-latn-zz", gdf: "gdf-latn-ng", gdg: "gdg-latn-ph", gdh: "gdh-latn-au", gdi: "gdi-latn-cf", gdj: "gdj-latn-au", gdk: "gdk-latn-td", gdl: "gdl-latn-et", "gdl-ethi": "gdl-ethi-et", gdm: "gdm-latn-td", gdn: "gdn-latn-zz", gdo: "gdo-cyrl-ru", gdq: "gdq-latn-ye", gdr: "gdr-latn-zz", gdt: "gdt-latn-au", gdu: "gdu-latn-ng", gdx: "gdx-deva-in", gea: "gea-latn-ng", geb: "geb-latn-zz", gec: "gec-latn-lr", ged: "ged-latn-ng", gef: "gef-latn-id", geg: "geg-latn-ng", geh: "geh-latn-ca", gei: "gei-latn-id", gej: "gej-latn-zz", gek: "gek-latn-ng", gel: "gel-latn-zz", geq: "geq-latn-cf", ges: "ges-latn-id", gev: "gev-latn-ga", gew: "gew-latn-ng", gex: "gex-latn-so", gey: "gey-latn-cd", gez: "gez-ethi-et", gfk: "gfk-latn-zz", gga: "gga-latn-sb", ggb: "ggb-latn-lr", ggd: "ggd-latn-au", gge: "gge-latn-au", ggg: "ggg-arab-pk", ggk: "ggk-latn-au", ggl: "ggl-latn-pg", ggn: "ggn-deva-np", ggt: "ggt-latn-pg", ggu: "ggu-latn-ci", ggw: "ggw-latn-pg", gha: "gha-arab-ly", "gha-latn": "gha-latn-ly", "gha-tfng": "gha-tfng-ly", ghc: "ghc-latn-gb", ghe: "ghe-deva-np", ghk: "ghk-latn-mm", ghn: "ghn-latn-sb", ghr: "ghr-arab-pk", ghs: "ghs-latn-zz", ght: "ght-tibt-np", gia: "gia-latn-au", gib: "gib-latn-ng", gic: "gic-latn-za", gid: "gid-latn-cm", gie: "gie-latn-ci", gig: "gig-arab-pk", gih: "gih-latn-au", gil: "gil-latn-ki", gim: "gim-latn-zz", gin: "gin-cyrl-ru", gip: "gip-latn-pg", giq: "giq-latn-vn", gir: "gir-latn-vn", gis: "gis-latn-cm", git: "git-latn-ca", gix: "gix-latn-cd", giy: "giy-latn-au", giz: "giz-latn-cm", gjk: "gjk-arab-pk", gjm: "gjm-latn-au", gjn: "gjn-latn-zz", gjr: "gjr-latn-au", gju: "gju-arab-pk", gka: "gka-latn-pg", gkd: "gkd-latn-pg", gke: "gke-latn-cm", gkn: "gkn-latn-zz", gko: "gko-latn-au", gkp: "gkp-latn-zz", gku: "gku-latn-za", gl: "gl-latn-es", glb: "glb-latn-ng", glc: "glc-latn-td", gld: "gld-cyrl-ru", glh: "glh-arab-af", glj: "glj-latn-td", glk: "glk-arab-ir", gll: "gll-latn-au", glo: "glo-latn-ng", glr: "glr-latn-lr", glu: "glu-latn-td", glw: "glw-latn-ng", gma: "gma-latn-au", gmb: "gmb-latn-sb", gmd: "gmd-latn-ng", gmg: "gmg-latn-pg", gmh: "gmh-latn-de", gmm: "gmm-latn-zz", gmn: "gmn-latn-cm", gmr: "gmr-latn-au", gmu: "gmu-latn-pg", gmv: "gmv-ethi-zz", gmx: "gmx-latn-tz", gmy: "gmy-linb-gr", gmz: "gmz-latn-ng", gn: "gn-latn-py", gna: "gna-latn-bf", gnb: "gnb-latn-in", gnc: "gnc-latn-es", gnd: "gnd-latn-zz", gne: "gne-latn-ng", gng: "gng-latn-zz", gnh: "gnh-latn-ng", gni: "gni-latn-au", gnj: "gnj-latn-ci", gnk: "gnk-latn-bw", gnl: "gnl-latn-au", gnm: "gnm-latn-pg", gnn: "gnn-latn-au", gnq: "gnq-latn-my", gnr: "gnr-latn-au", gnt: "gnt-latn-pg", gnu: "gnu-latn-pg", gnw: "gnw-latn-bo", gnz: "gnz-latn-cf", goa: "goa-latn-ci", gob: "gob-latn-co", goc: "goc-latn-pg", god: "god-latn-zz", goe: "goe-tibt-bt", gof: "gof-ethi-zz", gog: "gog-latn-tz", goh: "goh-latn-de", goi: "goi-latn-zz", gok: "gok-deva-in", gol: "gol-latn-lr", gom: "gom-deva-in", gon: "gon-telu-in", goo: "goo-latn-fj", gop: "gop-latn-id", goq: "goq-latn-id", gor: "gor-latn-id", gos: "gos-latn-nl", got: "got-goth-ua", gou: "gou-latn-cm", gov: "gov-latn-ci", gow: "gow-latn-tz", gox: "gox-latn-cd", goy: "goy-latn-td", gpa: "gpa-latn-ng", gpe: "gpe-latn-gh", gpn: "gpn-latn-pg", gqa: "gqa-latn-ng", gqn: "gqn-latn-br", gqr: "gqr-latn-td", gra: "gra-deva-in", "gra-gujr": "gra-gujr-in", grb: "grb-latn-zz", grc: "grc-cprt-cy", "grc-linb": "grc-linb-gr", grd: "grd-latn-ng", grg: "grg-latn-pg", grh: "grh-latn-ng", gri: "gri-latn-sb", grj: "grj-latn-lr", grm: "grm-latn-my", grq: "grq-latn-pg", grs: "grs-latn-id", grt: "grt-beng-in", gru: "gru-ethi-et", "gru-latn": "gru-latn-et", grv: "grv-latn-lr", grw: "grw-latn-zz", grx: "grx-latn-pg", gry: "gry-latn-lr", grz: "grz-latn-pg", gsl: "gsl-latn-sn", gsn: "gsn-latn-pg", gso: "gso-latn-cf", gsp: "gsp-latn-pg", gsw: "gsw-latn-ch", gta: "gta-latn-br", gtu: "gtu-latn-au", gu: "gu-gujr-in", gua: "gua-latn-ng", gub: "gub-latn-br", guc: "guc-latn-co", gud: "gud-latn-zz", gue: "gue-latn-au", guf: "guf-latn-au", guh: "guh-latn-co", gui: "gui-latn-bo", guk: "guk-latn-et", "guk-ethi": "guk-ethi-et", gul: "gul-latn-us", gum: "gum-latn-co", gun: "gun-latn-br", guo: "guo-latn-co", gup: "gup-latn-au", guq: "guq-latn-py", gur: "gur-latn-gh", gut: "gut-latn-cr", guu: "guu-latn-ve", guw: "guw-latn-zz", gux: "gux-latn-zz", guz: "guz-latn-ke", gv: "gv-latn-im", gva: "gva-latn-py", gvc: "gvc-latn-br", gve: "gve-latn-pg", gvf: "gvf-latn-zz", gvj: "gvj-latn-br", gvl: "gvl-latn-td", gvm: "gvm-latn-ng", gvn: "gvn-latn-au", gvo: "gvo-latn-br", gvp: "gvp-latn-br", gvr: "gvr-deva-np", gvs: "gvs-latn-zz", gvy: "gvy-latn-au", gwa: "gwa-latn-ci", gwb: "gwb-latn-ng", gwc: "gwc-arab-zz", gwd: "gwd-latn-et", gwe: "gwe-latn-tz", gwf: "gwf-arab-pk", gwg: "gwg-latn-ng", gwi: "gwi-latn-ca", gwj: "gwj-latn-bw", gwm: "gwm-latn-au", gwn: "gwn-latn-ng", gwr: "gwr-latn-ug", gwt: "gwt-arab-zz", gwu: "gwu-latn-au", gww: "gww-latn-au", gwx: "gwx-latn-gh", gxx: "gxx-latn-ci", gyb: "gyb-latn-pg", gyd: "gyd-latn-au", gye: "gye-latn-ng", gyf: "gyf-latn-au", gyg: "gyg-latn-cf", gyi: "gyi-latn-zz", gyl: "gyl-latn-et", "gyl-ethi": "gyl-ethi-et", gym: "gym-latn-pa", gyn: "gyn-latn-gy", gyo: "gyo-deva-np", gyr: "gyr-latn-bo", gyy: "gyy-latn-au", gyz: "gyz-latn-ng", gza: "gza-latn-sd", gzi: "gzi-arab-ir", gzn: "gzn-latn-id", ha: "ha-latn-ng", "ha-cm": "ha-arab-cm", "ha-sd": "ha-arab-sd", haa: "haa-latn-us", hac: "hac-arab-ir", had: "had-latn-id", hae: "hae-latn-et", hag: "hag-latn-zz", hah: "hah-latn-pg", hai: "hai-latn-ca", haj: "haj-latn-in", "haj-beng": "haj-beng-in", hak: "hak-hans-cn", hal: "hal-latn-vn", ham: "ham-latn-zz", han: "han-latn-tz", hao: "hao-latn-pg", hap: "hap-latn-id", haq: "haq-latn-tz", har: "har-ethi-et", "har-arab": "har-arab-et", "har-latn": "har-latn-et", has: "has-latn-ca", hav: "hav-latn-cd", haw: "haw-latn-us", hax: "hax-latn-ca", hay: "hay-latn-tz", haz: "haz-arab-af", hba: "hba-latn-cd", hbb: "hbb-latn-zz", hbn: "hbn-latn-sd", hbo: "hbo-hebr-il", hbu: "hbu-latn-tl", hch: "hch-latn-mx", hdy: "hdy-ethi-zz", he: "he-hebr-il", hed: "hed-latn-td", heg: "heg-latn-id", heh: "heh-latn-tz", hei: "hei-latn-ca", hem: "hem-latn-cd", hgm: "hgm-latn-na", hgw: "hgw-latn-pg", hhi: "hhi-latn-pg", hhr: "hhr-latn-sn", hhy: "hhy-latn-zz", hi: "hi-deva-in", "hi-latn": "hi-latn-in", hia: "hia-latn-zz", hib: "hib-latn-pe", hid: "hid-latn-us", hif: "hif-latn-fj", hig: "hig-latn-zz", hih: "hih-latn-zz", hii: "hii-takr-in", "hii-deva": "hii-deva-in", hij: "hij-latn-cm", hik: "hik-latn-id", hil: "hil-latn-ph", hio: "hio-latn-bw", hir: "hir-latn-br", hit: "hit-xsux-tr", hiw: "hiw-latn-vu", hix: "hix-latn-br", hji: "hji-latn-id", hka: "hka-latn-tz", hke: "hke-latn-cd", hkh: "hkh-arab-in", "hkh-deva": "hkh-deva-in", "hkh-latn": "hkh-latn-in", hkk: "hkk-latn-pg", hla: "hla-latn-zz", hlb: "hlb-deva-in", hld: "hld-latn-vn", hlt: "hlt-latn-mm", hlu: "hlu-hluw-tr", hma: "hma-latn-cn", hmb: "hmb-latn-ml", hmd: "hmd-plrd-cn", hmf: "hmf-latn-vn", hmj: "hmj-bopo-cn", hmm: "hmm-latn-cn", hmn: "hmn-latn-cn", "hmn-bopo": "hmn-bopo-cn", "hmn-hmng": "hmn-hmng-cn", hmp: "hmp-latn-cn", hmq: "hmq-bopo-cn", hmr: "hmr-latn-in", hms: "hms-latn-cn", hmt: "hmt-latn-zz", hmu: "hmu-latn-id", hmv: "hmv-latn-vn", hmw: "hmw-latn-cn", hmy: "hmy-latn-cn", hmz: "hmz-latn-cn", "hmz-plrd": "hmz-plrd-cn", hna: "hna-latn-cm", hnd: "hnd-arab-pk", hne: "hne-deva-in", hng: "hng-latn-ao", hnh: "hnh-latn-bw", hni: "hni-latn-cn", hnj: "hnj-hmnp-us", "hnj-au": "hnj-laoo-au", "hnj-cn": "hnj-laoo-cn", "hnj-fr": "hnj-laoo-fr", "hnj-gf": "hnj-laoo-gf", "hnj-la": "hnj-laoo-la", "hnj-laoo": "hnj-laoo-la", "hnj-mm": "hnj-laoo-mm", "hnj-sr": "hnj-laoo-sr", "hnj-th": "hnj-laoo-th", "hnj-us": "hnj-hmnp-us", "hnj-vn": "hnj-laoo-vn", hnn: "hnn-latn-ph", hno: "hno-arab-pk", hns: "hns-latn-sr", ho: "ho-latn-pg", hoa: "hoa-latn-sb", hob: "hob-latn-pg", hoc: "hoc-deva-in", hod: "hod-latn-ng", hoe: "hoe-latn-ng", hoh: "hoh-arab-om", hoi: "hoi-latn-us", hoj: "hoj-deva-in", hol: "hol-latn-ao", hom: "hom-latn-ss", hoo: "hoo-latn-cd", hop: "hop-latn-us", hor: "hor-latn-td", hot: "hot-latn-zz", hov: "hov-latn-id", how: "how-hani-cn", hoy: "hoy-deva-in", hpo: "hpo-mymr-mm", hr: "hr-latn-hr", hra: "hra-latn-in", hrc: "hrc-latn-pg", hre: "hre-latn-vn", hrk: "hrk-latn-id", hrm: "hrm-latn-cn", "hrm-hmng": "hrm-hmng-cn", hro: "hro-latn-vn", hrp: "hrp-latn-au", hrt: "hrt-syrc-tr", hru: "hru-latn-in", hrw: "hrw-latn-pg", hrx: "hrx-latn-br", hrz: "hrz-arab-ir", hsb: "hsb-latn-de", hsn: "hsn-hans-cn", hss: "hss-arab-om", ht: "ht-latn-ht", hti: "hti-latn-id", hto: "hto-latn-co", hts: "hts-latn-tz", htu: "htu-latn-id", htx: "htx-xsux-tr", hu: "hu-latn-hu", hub: "hub-latn-pe", huc: "huc-latn-bw", hud: "hud-latn-id", hue: "hue-latn-mx", huf: "huf-latn-pg", hug: "hug-latn-pe", huh: "huh-latn-cl", hui: "hui-latn-zz", huk: "huk-latn-id", hul: "hul-latn-pg", hum: "hum-latn-cd", hup: "hup-latn-us", hur: "hur-latn-ca", hus: "hus-latn-mx", hut: "hut-deva-np", "hut-tibt": "hut-tibt-np", huu: "huu-latn-pe", huv: "huv-latn-mx", huw: "huw-latn-id", hux: "hux-latn-pe", huy: "huy-hebr-il", huz: "huz-cyrl-ru", hvc: "hvc-latn-ht", hve: "hve-latn-mx", hvk: "hvk-latn-nc", hvn: "hvn-latn-id", hvv: "hvv-latn-mx", hwa: "hwa-latn-ci", hwc: "hwc-latn-us", hwo: "hwo-latn-ng", hy: "hy-armn-am", hya: "hya-latn-cm", hyw: "hyw-armn-am", hz: "hz-latn-na", ia: "ia-latn-001", iai: "iai-latn-nc", ian: "ian-latn-zz", iar: "iar-latn-zz", iba: "iba-latn-my", ibb: "ibb-latn-ng", ibd: "ibd-latn-au", ibe: "ibe-latn-ng", ibg: "ibg-latn-ph", ibh: "ibh-latn-vn", ibl: "ibl-latn-ph", ibm: "ibm-latn-ng", ibn: "ibn-latn-ng", ibr: "ibr-latn-ng", ibu: "ibu-latn-id", iby: "iby-latn-zz", ica: "ica-latn-zz", ich: "ich-latn-zz", icr: "icr-latn-co", id: "id-latn-id", ida: "ida-latn-ke", idb: "idb-latn-in", idc: "idc-latn-ng", idd: "idd-latn-zz", ide: "ide-latn-ng", idi: "idi-latn-zz", idr: "idr-latn-ss", ids: "ids-latn-ng", idt: "idt-latn-tl", idu: "idu-latn-zz", ie: "ie-latn-001", ifa: "ifa-latn-ph", ifb: "ifb-latn-ph", ife: "ife-latn-tg", iff: "iff-latn-vu", ifk: "ifk-latn-ph", ifm: "ifm-latn-cg", ifu: "ifu-latn-ph", ify: "ify-latn-ph", ig: "ig-latn-ng", igb: "igb-latn-zz", ige: "ige-latn-zz", igg: "igg-latn-pg", igl: "igl-latn-ng", igm: "igm-latn-pg", ign: "ign-latn-bo", igo: "igo-latn-pg", igs: "igs-latn-001", "igs-grek": "igs-grek-001", igw: "igw-latn-ng", ihb: "ihb-latn-id", ihi: "ihi-latn-ng", ihp: "ihp-latn-id", ihw: "ihw-latn-au", ii: "ii-yiii-cn", iin: "iin-latn-au", ijc: "ijc-latn-ng", ije: "ije-latn-ng", ijj: "ijj-latn-zz", ijn: "ijn-latn-ng", ijs: "ijs-latn-ng", ik: "ik-latn-us", iki: "iki-latn-ng", ikk: "ikk-latn-zz", ikl: "ikl-latn-ng", iko: "iko-latn-ng", ikp: "ikp-latn-ng", ikr: "ikr-latn-au", ikt: "ikt-latn-ca", "ikt-cans": "ikt-cans-ca", ikv: "ikv-latn-ng", ikw: "ikw-latn-zz", ikx: "ikx-latn-zz", ikz: "ikz-latn-tz", ila: "ila-latn-id", ilb: "ilb-latn-zm", ilg: "ilg-latn-au", ili: "ili-latn-cn", "ili-arab": "ili-arab-cn", "ili-cyrl": "ili-cyrl-kz", ilk: "ilk-latn-ph", ilm: "ilm-latn-my", ilo: "ilo-latn-ph", ilp: "ilp-latn-ph", ilu: "ilu-latn-id", ilv: "ilv-latn-ng", imi: "imi-latn-pg", iml: "iml-latn-us", imn: "imn-latn-pg", imo: "imo-latn-zz", imr: "imr-latn-id", ims: "ims-latn-it", imt: "imt-latn-ss", imy: "imy-lyci-tr", in: "in-latn-id", inb: "inb-latn-co", ing: "ing-latn-us", inh: "inh-cyrl-ru", inj: "inj-latn-co", inn: "inn-latn-ph", ino: "ino-latn-pg", inp: "inp-latn-pe", int: "int-mymr-mm", io: "io-latn-001", ior: "ior-ethi-et", iou: "iou-latn-zz", iow: "iow-latn-us", ipi: "ipi-latn-pg", ipo: "ipo-latn-pg", iqu: "iqu-latn-pe", iqw: "iqw-latn-ng", ire: "ire-latn-id", irh: "irh-latn-id", iri: "iri-latn-zz", irk: "irk-latn-tz", irn: "irn-latn-br", iru: "iru-taml-in", "iru-mlym": "iru-mlym-in", irx: "irx-latn-id", iry: "iry-latn-ph", is: "is-latn-is", isa: "isa-latn-pg", isc: "isc-latn-pe", isd: "isd-latn-ph", ish: "ish-latn-ng", isi: "isi-latn-ng", isk: "isk-arab-af", "isk-cyrl": "isk-cyrl-tj", ism: "ism-latn-id", isn: "isn-latn-tz", iso: "iso-latn-ng", ist: "ist-latn-hr", isu: "isu-latn-cm", it: "it-latn-it", itb: "itb-latn-ph", itd: "itd-latn-id", ite: "ite-latn-bo", iti: "iti-latn-ph", itk: "itk-hebr-it", itl: "itl-cyrl-ru", itm: "itm-latn-ng", ito: "ito-latn-bo", itr: "itr-latn-pg", its: "its-latn-ng", itt: "itt-latn-ph", itv: "itv-latn-ph", itw: "itw-latn-ng", itx: "itx-latn-id", ity: "ity-latn-ph", itz: "itz-latn-gt", iu: "iu-cans-ca", ium: "ium-latn-cn", "ium-hani": "ium-hani-cn", "ium-laoo": "ium-laoo-la", "ium-thai": "ium-thai-th", ivb: "ivb-latn-ph", ivv: "ivv-latn-ph", iw: "iw-hebr-il", iwk: "iwk-latn-ph", iwm: "iwm-latn-zz", iwo: "iwo-latn-id", iws: "iws-latn-zz", ixc: "ixc-latn-mx", ixl: "ixl-latn-gt", iya: "iya-latn-ng", iyo: "iyo-latn-cm", iyx: "iyx-latn-cg", izh: "izh-latn-ru", izi: "izi-latn-zz", izr: "izr-latn-ng", izz: "izz-latn-ng", ja: "ja-jpan-jp", jaa: "jaa-latn-br", jab: "jab-latn-zz", jac: "jac-latn-gt", jad: "jad-arab-gn", jae: "jae-latn-pg", jaf: "jaf-latn-ng", jah: "jah-latn-my", jaj: "jaj-latn-sb", jak: "jak-latn-my", jal: "jal-latn-id", jam: "jam-latn-jm", jan: "jan-latn-au", jao: "jao-latn-au", jaq: "jaq-latn-id", jar: "jar-latn-zz", jas: "jas-latn-nc", jat: "jat-arab-af", jau: "jau-latn-id", jax: "jax-latn-id", jay: "jay-latn-au", jaz: "jaz-latn-nc", jbe: "jbe-hebr-il", jbi: "jbi-latn-au", jbj: "jbj-latn-id", jbk: "jbk-latn-pg", jbm: "jbm-latn-ng", jbn: "jbn-arab-ly", jbo: "jbo-latn-001", jbr: "jbr-latn-id", jbt: "jbt-latn-br", jbu: "jbu-latn-zz", jbw: "jbw-latn-au", jct: "jct-cyrl-ua", "jct-latn": "jct-latn-ua", jda: "jda-tibt-in", jdg: "jdg-arab-pk", jdt: "jdt-cyrl-ru", "jdt-hebr": "jdt-hebr-ru", "jdt-latn": "jdt-latn-az", jeb: "jeb-latn-pe", jee: "jee-deva-np", jeh: "jeh-latn-vn", "jeh-laoo": "jeh-laoo-la", jei: "jei-latn-id", jek: "jek-latn-ci", jel: "jel-latn-id", jen: "jen-latn-zz", jer: "jer-latn-ng", jet: "jet-latn-pg", jeu: "jeu-latn-td", jgb: "jgb-latn-cd", jge: "jge-geor-ge", "jge-hebr": "jge-hebr-il", jgk: "jgk-latn-zz", jgo: "jgo-latn-cm", jhi: "jhi-latn-my", ji: "ji-hebr-ua", jia: "jia-latn-cm", jib: "jib-latn-zz", jic: "jic-latn-hn", jid: "jid-latn-ng", jie: "jie-latn-ng", jig: "jig-latn-au", jil: "jil-latn-pg", jim: "jim-latn-cm", jit: "jit-latn-tz", jiu: "jiu-latn-cn", jiv: "jiv-latn-ec", jiy: "jiy-latn-cn", jje: "jje-hang-kr", jjr: "jjr-latn-ng", jka: "jka-latn-id", jkm: "jkm-mymr-mm", "jkm-brai": "jkm-brai-mm", "jkm-latn": "jkm-latn-mm", jko: "jko-latn-pg", jku: "jku-latn-ng", jle: "jle-latn-sd", jma: "jma-latn-pg", jmb: "jmb-latn-ng", jmc: "jmc-latn-tz", jmd: "jmd-latn-id", jmi: "jmi-latn-ng", jml: "jml-deva-np", jmn: "jmn-latn-mm", jmr: "jmr-latn-gh", jms: "jms-latn-ng", jmw: "jmw-latn-pg", jmx: "jmx-latn-mx", jna: "jna-takr-in", jnd: "jnd-arab-pk", jng: "jng-latn-au", jni: "jni-latn-ng", jnj: "jnj-latn-et", "jnj-ethi": "jnj-ethi-et", jnl: "jnl-deva-in", jns: "jns-deva-in", "jns-latn": "jns-latn-in", "jns-takr": "jns-takr-in", job: "job-latn-cd", jod: "jod-latn-ci", jog: "jog-arab-pk", jor: "jor-latn-bo", jow: "jow-latn-ml", jpa: "jpa-hebr-ps", jpr: "jpr-hebr-il", jqr: "jqr-latn-pe", jra: "jra-latn-zz", jrr: "jrr-latn-ng", jrt: "jrt-latn-ng", jru: "jru-latn-ve", jua: "jua-latn-br", jub: "jub-latn-ng", jud: "jud-latn-ci", juh: "juh-latn-ng", jui: "jui-latn-au", juk: "juk-latn-ng", jul: "jul-deva-np", jum: "jum-latn-sd", jun: "jun-orya-in", juo: "juo-latn-ng", jup: "jup-latn-br", jur: "jur-latn-br", jut: "jut-latn-dk", juu: "juu-latn-ng", juw: "juw-latn-ng", juy: "juy-orya-in", jv: "jv-latn-id", jvd: "jvd-latn-id", jvn: "jvn-latn-sr", jw: "jw-latn-id", jwi: "jwi-latn-gh", jya: "jya-tibt-cn", jye: "jye-hebr-il", jyy: "jyy-latn-td", ka: "ka-geor-ge", kaa: "kaa-cyrl-uz", kab: "kab-latn-dz", kac: "kac-latn-mm", kad: "kad-latn-zz", kag: "kag-latn-my", kah: "kah-latn-cf", kai: "kai-latn-zz", kaj: "kaj-latn-ng", kak: "kak-latn-ph", kam: "kam-latn-ke", kao: "kao-latn-ml", kap: "kap-cyrl-ru", kaq: "kaq-latn-pe", kav: "kav-latn-br", kaw: "kaw-kawi-id", kax: "kax-latn-id", kay: "kay-latn-br", kba: "kba-latn-au", kbb: "kbb-latn-br", kbc: "kbc-latn-br", kbd: "kbd-cyrl-ru", kbe: "kbe-latn-au", kbh: "kbh-latn-co", kbi: "kbi-latn-id", kbj: "kbj-latn-cd", kbk: "kbk-latn-pg", kbl: "kbl-latn-td", kbm: "kbm-latn-zz", kbn: "kbn-latn-cf", kbo: "kbo-latn-ss", kbp: "kbp-latn-zz", kbq: "kbq-latn-zz", kbr: "kbr-latn-et", "kbr-ethi": "kbr-ethi-et", kbs: "kbs-latn-ga", kbt: "kbt-latn-pg", kbu: "kbu-arab-pk", kbv: "kbv-latn-id", kbw: "kbw-latn-pg", kbx: "kbx-latn-zz", kby: "kby-arab-ne", kbz: "kbz-latn-ng", kca: "kca-cyrl-ru", kcb: "kcb-latn-pg", kcc: "kcc-latn-ng", kcd: "kcd-latn-id", kce: "kce-latn-ng", kcf: "kcf-latn-ng", kcg: "kcg-latn-ng", kch: "kch-latn-ng", kci: "kci-latn-ng", kcj: "kcj-latn-gw", kck: "kck-latn-zw", kcl: "kcl-latn-zz", kcm: "kcm-latn-cf", kcn: "kcn-latn-ug", kco: "kco-latn-pg", kcp: "kcp-latn-sd", kcq: "kcq-latn-ng", kcs: "kcs-latn-ng", kct: "kct-latn-zz", kcu: "kcu-latn-tz", kcv: "kcv-latn-cd", kcw: "kcw-latn-cd", kcz: "kcz-latn-tz", kda: "kda-latn-au", kdc: "kdc-latn-tz", kdd: "kdd-latn-au", kde: "kde-latn-tz", kdf: "kdf-latn-pg", kdg: "kdg-latn-cd", kdh: "kdh-latn-tg", kdi: "kdi-latn-ug", kdj: "kdj-latn-ug", kdk: "kdk-latn-nc", kdl: "kdl-latn-zz", kdm: "kdm-latn-ng", kdn: "kdn-latn-zw", kdp: "kdp-latn-ng", kdq: "kdq-beng-in", kdr: "kdr-latn-lt", "kdr-cyrl": "kdr-cyrl-ua", kdt: "kdt-thai-th", kdw: "kdw-latn-id", kdx: "kdx-latn-ng", kdy: "kdy-latn-id", kdz: "kdz-latn-cm", kea: "kea-latn-cv", keb: "keb-latn-ga", kec: "kec-latn-sd", ked: "ked-latn-tz", kee: "kee-latn-us", kef: "kef-latn-tg", keg: "keg-latn-sd", keh: "keh-latn-pg", kei: "kei-latn-id", kek: "kek-latn-gt", kel: "kel-latn-cd", kem: "kem-latn-tl", ken: "ken-latn-cm", keo: "keo-latn-ug", ker: "ker-latn-td", kes: "kes-latn-ng", ket: "ket-cyrl-ru", keu: "keu-latn-tg", kew: "kew-latn-pg", kex: "kex-deva-in", "kex-gujr": "kex-gujr-in", key: "key-telu-in", kez: "kez-latn-zz", kfa: "kfa-knda-in", kfb: "kfb-deva-in", kfc: "kfc-telu-in", kfd: "kfd-knda-in", kfe: "kfe-taml-in", kff: "kff-latn-in", "kff-deva": "kff-deva-in", "kff-orya": "kff-orya-in", "kff-telu": "kff-telu-in", kfh: "kfh-mlym-in", kfi: "kfi-taml-in", "kfi-knda": "kfi-knda-in", kfk: "kfk-deva-in", "kfk-takr": "kfk-takr-in", kfl: "kfl-latn-cm", kfm: "kfm-arab-ir", kfn: "kfn-latn-cm", kfo: "kfo-latn-ci", kfp: "kfp-deva-in", kfq: "kfq-deva-in", kfr: "kfr-deva-in", kfs: "kfs-deva-in", kfv: "kfv-latn-in", kfw: "kfw-latn-in", kfx: "kfx-deva-in", "kfx-takr": "kfx-takr-in", kfy: "kfy-deva-in", kfz: "kfz-latn-bf", kg: "kg-latn-cd", kga: "kga-latn-ci", kgb: "kgb-latn-id", kge: "kge-latn-id", kgf: "kgf-latn-zz", kgj: "kgj-deva-np", kgk: "kgk-latn-br", kgl: "kgl-latn-au", kgm: "kgm-latn-br", kgo: "kgo-latn-sd", kgp: "kgp-latn-br", kgq: "kgq-latn-id", kgr: "kgr-latn-id", kgs: "kgs-latn-au", kgt: "kgt-latn-ng", kgu: "kgu-latn-pg", kgv: "kgv-latn-id", kgw: "kgw-latn-id", kgx: "kgx-latn-id", kgy: "kgy-deva-np", kha: "kha-latn-in", khb: "khb-talu-cn", khc: "khc-latn-id", khd: "khd-latn-id", khe: "khe-latn-id", khf: "khf-thai-la", khg: "khg-tibt-cn", khh: "khh-latn-id", khj: "khj-latn-ng", khl: "khl-latn-pg", khn: "khn-deva-in", khp: "khp-latn-id", khq: "khq-latn-ml", khr: "khr-latn-in", "khr-deva": "khr-deva-in", khs: "khs-latn-zz", kht: "kht-mymr-in", khu: "khu-latn-ao", khv: "khv-cyrl-ru", khw: "khw-arab-pk", khx: "khx-latn-cd", khy: "khy-latn-cd", khz: "khz-latn-zz", ki: "ki-latn-ke", kia: "kia-latn-td", kib: "kib-latn-sd", kic: "kic-latn-us", kid: "kid-latn-cm", kie: "kie-latn-td", kif: "kif-deva-np", kig: "kig-latn-id", kih: "kih-latn-pg", kij: "kij-latn-zz", kil: "kil-latn-ng", kim: "kim-cyrl-ru", kio: "kio-latn-us", kip: "kip-deva-np", kiq: "kiq-latn-id", kis: "kis-latn-pg", kit: "kit-latn-pg", kiu: "kiu-latn-tr", kiv: "kiv-latn-tz", kiw: "kiw-latn-zz", kix: "kix-latn-in", kiy: "kiy-latn-id", kiz: "kiz-latn-tz", kj: "kj-latn-na", kja: "kja-latn-id", kjb: "kjb-latn-gt", kjc: "kjc-latn-id", kjd: "kjd-latn-zz", kje: "kje-latn-id", kjg: "kjg-laoo-la", kjh: "kjh-cyrl-ru", kji: "kji-latn-sb", kjj: "kjj-latn-az", kjk: "kjk-latn-id", kjl: "kjl-deva-np", kjm: "kjm-latn-vn", kjn: "kjn-latn-au", kjo: "kjo-deva-in", kjp: "kjp-mymr-mm", "kjp-thai": "kjp-thai-th", kjq: "kjq-latn-us", kjr: "kjr-latn-id", kjs: "kjs-latn-zz", kjt: "kjt-thai-th", kju: "kju-latn-us", kjx: "kjx-latn-pg", kjy: "kjy-latn-zz", kk: "kk-cyrl-kz", "kk-af": "kk-arab-af", "kk-arab": "kk-arab-cn", "kk-cn": "kk-arab-cn", "kk-ir": "kk-arab-ir", "kk-mn": "kk-arab-mn", kka: "kka-latn-ng", kkb: "kkb-latn-id", kkc: "kkc-latn-zz", kkd: "kkd-latn-ng", kke: "kke-latn-gn", "kke-arab": "kke-arab-gn", kkf: "kkf-tibt-in", kkg: "kkg-latn-ph", kkh: "kkh-lana-mm", kki: "kki-latn-tz", kkj: "kkj-latn-cm", kkk: "kkk-latn-sb", kkl: "kkl-latn-id", kkm: "kkm-latn-ng", kko: "kko-latn-sd", kkp: "kkp-latn-au", kkq: "kkq-latn-cd", kkr: "kkr-latn-ng", kks: "kks-latn-ng", kkt: "kkt-deva-np", kku: "kku-latn-ng", kkv: "kkv-latn-id", kkw: "kkw-latn-cg", kkx: "kkx-latn-id", kky: "kky-latn-au", kkz: "kkz-latn-ca", kl: "kl-latn-gl", kla: "kla-latn-us", klb: "klb-latn-mx", klc: "klc-latn-cm", kld: "kld-latn-au", kle: "kle-deva-np", klf: "klf-latn-td", klg: "klg-latn-ph", klh: "klh-latn-pg", kli: "kli-latn-id", klj: "klj-arab-ir", klk: "klk-latn-ng", kll: "kll-latn-ph", klm: "klm-latn-pg", kln: "kln-latn-ke", klo: "klo-latn-ng", klp: "klp-latn-pg", klq: "klq-latn-zz", klr: "klr-deva-np", kls: "kls-latn-pk", "kls-arab": "kls-arab-pk", klt: "klt-latn-zz", klu: "klu-latn-lr", klv: "klv-latn-vu", klw: "klw-latn-id", klx: "klx-latn-zz", kly: "kly-latn-id", klz: "klz-latn-id", km: "km-khmr-kh", kma: "kma-latn-gh", kmb: "kmb-latn-ao", kmc: "kmc-latn-cn", "kmc-hani": "kmc-hani-cn", kmd: "kmd-latn-ph", kme: "kme-latn-cm", kmf: "kmf-latn-pg", kmg: "kmg-latn-pg", kmh: "kmh-latn-zz", kmi: "kmi-latn-ng", kmj: "kmj-deva-in", kmk: "kmk-latn-ph", kml: "kml-latn-ph", kmm: "kmm-latn-in", kmn: "kmn-latn-pg", kmo: "kmo-latn-zz", kmp: "kmp-latn-cm", kmq: "kmq-latn-et", kms: "kms-latn-zz", kmt: "kmt-latn-id", kmu: "kmu-latn-zz", kmv: "kmv-latn-br", kmw: "kmw-latn-zz", kmx: "kmx-latn-pg", kmy: "kmy-latn-ng", kmz: "kmz-arab-ir", kn: "kn-knda-in", kna: "kna-latn-ng", knb: "knb-latn-ph", knd: "knd-latn-id", kne: "kne-latn-ph", knf: "knf-latn-gw", kni: "kni-latn-ng", knj: "knj-latn-gt", knk: "knk-latn-sl", "knk-arab": "knk-arab-sl", knl: "knl-latn-id", knm: "knm-latn-br", kno: "kno-latn-sl", knp: "knp-latn-zz", knq: "knq-latn-my", knr: "knr-latn-pg", kns: "kns-latn-my", "kns-thai": "kns-thai-th", knt: "knt-latn-br", knu: "knu-latn-gn", knv: "knv-latn-pg", knw: "knw-latn-na", knx: "knx-latn-id", kny: "kny-latn-cd", knz: "knz-latn-bf", ko: "ko-kore-kr", koa: "koa-latn-pg", koc: "koc-latn-ng", kod: "kod-latn-id", koe: "koe-latn-ss", kof: "kof-latn-ng", kog: "kog-latn-co", koh: "koh-latn-cg", koi: "koi-cyrl-ru", kok: "kok-deva-in", kol: "kol-latn-zz", koo: "koo-latn-ug", kop: "kop-latn-pg", koq: "koq-latn-ga", kos: "kos-latn-fm", kot: "kot-latn-cm", kou: "kou-latn-td", kov: "kov-latn-ng", kow: "kow-latn-ng", koy: "koy-latn-us", koz: "koz-latn-zz", kpa: "kpa-latn-ng", kpc: "kpc-latn-co", kpd: "kpd-latn-id", kpe: "kpe-latn-lr", kpf: "kpf-latn-zz", kpg: "kpg-latn-fm", kph: "kph-latn-gh", kpi: "kpi-latn-id", kpj: "kpj-latn-br", kpk: "kpk-latn-ng", kpl: "kpl-latn-cd", kpm: "kpm-latn-vn", kpn: "kpn-latn-br", kpo: "kpo-latn-zz", kpq: "kpq-latn-id", kpr: "kpr-latn-zz", kps: "kps-latn-id", kpt: "kpt-cyrl-ru", kpu: "kpu-latn-id", kpw: "kpw-latn-pg", kpx: "kpx-latn-zz", kpy: "kpy-cyrl-ru", kpz: "kpz-latn-ug", kqa: "kqa-latn-pg", kqb: "kqb-latn-zz", kqc: "kqc-latn-pg", kqd: "kqd-syrc-iq", kqe: "kqe-latn-ph", kqf: "kqf-latn-zz", kqg: "kqg-latn-bf", kqh: "kqh-latn-tz", kqi: "kqi-latn-pg", kqj: "kqj-latn-pg", kqk: "kqk-latn-bj", kql: "kql-latn-pg", kqm: "kqm-latn-ci", kqn: "kqn-latn-zm", kqo: "kqo-latn-lr", kqp: "kqp-latn-td", kqq: "kqq-latn-br", kqr: "kqr-latn-my", kqs: "kqs-latn-zz", kqt: "kqt-latn-my", kqu: "kqu-latn-za", kqv: "kqv-latn-id", kqw: "kqw-latn-pg", kqx: "kqx-latn-cm", kqy: "kqy-ethi-zz", kqz: "kqz-latn-za", kr: "kr-latn-zz", kra: "kra-deva-np", krb: "krb-latn-us", krc: "krc-cyrl-ru", krd: "krd-latn-tl", kre: "kre-latn-br", krf: "krf-latn-vu", krh: "krh-latn-ng", kri: "kri-latn-sl", krj: "krj-latn-ph", krk: "krk-cyrl-ru", krl: "krl-latn-ru", krn: "krn-latn-lr", krp: "krp-latn-ng", krr: "krr-khmr-kh", krs: "krs-latn-zz", krt: "krt-latn-ne", kru: "kru-deva-in", krv: "krv-khmr-kh", krw: "krw-latn-lr", krx: "krx-latn-sn", kry: "kry-latn-az", krz: "krz-latn-id", ks: "ks-arab-in", ksa: "ksa-latn-ng", ksb: "ksb-latn-tz", ksc: "ksc-latn-ph", ksd: "ksd-latn-zz", kse: "kse-latn-pg", ksf: "ksf-latn-cm", ksg: "ksg-latn-sb", ksh: "ksh-latn-de", ksi: "ksi-latn-pg", ksj: "ksj-latn-zz", ksk: "ksk-latn-us", ksl: "ksl-latn-pg", ksm: "ksm-latn-ng", ksn: "ksn-latn-ph", kso: "kso-latn-ng", ksp: "ksp-latn-cf", ksq: "ksq-latn-ng", ksr: "ksr-latn-zz", kss: "kss-latn-lr", kst: "kst-latn-bf", ksu: "ksu-mymr-in", ksv: "ksv-latn-cd", ksw: "ksw-mymr-mm", "ksw-latn": "ksw-latn-mm", ksx: "ksx-latn-id", ksz: "ksz-deva-in", kta: "kta-latn-vn", ktb: "ktb-ethi-zz", ktc: "ktc-latn-ng", ktd: "ktd-latn-au", ktf: "ktf-latn-cd", ktg: "ktg-latn-au", kth: "kth-latn-td", kti: "kti-latn-id", ktj: "ktj-latn-ci", ktk: "ktk-latn-pg", ktl: "ktl-arab-ir", ktm: "ktm-latn-zz", ktn: "ktn-latn-br", kto: "kto-latn-zz", ktp: "ktp-plrd-cn", ktq: "ktq-latn-ph", ktr: "ktr-latn-my", kts: "kts-latn-id", ktt: "ktt-latn-id", ktu: "ktu-latn-cd", ktv: "ktv-latn-vn", ktw: "ktw-latn-us", ktx: "ktx-latn-br", kty: "kty-latn-cd", ktz: "ktz-latn-na", ku: "ku-latn-tr", "ku-arab": "ku-arab-iq", "ku-lb": "ku-arab-lb", "ku-yezi": "ku-yezi-ge", kub: "kub-latn-zz", kuc: "kuc-latn-id", kud: "kud-latn-zz", kue: "kue-latn-zz", kuf: "kuf-laoo-la", kug: "kug-latn-ng", kuh: "kuh-latn-ng", kui: "kui-latn-br", kuj: "kuj-latn-zz", kuk: "kuk-latn-id", kul: "kul-latn-ng", kum: "kum-cyrl-ru", kun: "kun-latn-zz", kuo: "kuo-latn-pg", kup: "kup-latn-zz", kuq: "kuq-latn-br", kus: "kus-latn-zz", kut: "kut-latn-ca", kuu: "kuu-latn-us", kuv: "kuv-latn-id", kuw: "kuw-latn-cf", kux: "kux-latn-au", kuy: "kuy-latn-au", kuz: "kuz-latn-cl", kv: "kv-cyrl-ru", kva: "kva-cyrl-ru", kvb: "kvb-latn-id", kvc: "kvc-latn-pg", kvd: "kvd-latn-id", kve: "kve-latn-my", kvf: "kvf-latn-td", kvg: "kvg-latn-zz", kvh: "kvh-latn-id", kvi: "kvi-latn-td", kvj: "kvj-latn-cm", kvl: "kvl-latn-mm", kvm: "kvm-latn-cm", kvn: "kvn-latn-co", kvo: "kvo-latn-id", kvp: "kvp-latn-id", kvq: "kvq-mymr-mm", "kvq-latn": "kvq-latn-mm", kvr: "kvr-latn-id", kvt: "kvt-mymr-mm", kvv: "kvv-latn-id", kvw: "kvw-latn-id", kvx: "kvx-arab-pk", kvy: "kvy-kali-mm", kvz: "kvz-latn-id", kw: "kw-latn-gb", kwa: "kwa-latn-br", kwb: "kwb-latn-ng", kwc: "kwc-latn-cg", kwd: "kwd-latn-sb", kwe: "kwe-latn-id", kwf: "kwf-latn-sb", kwg: "kwg-latn-td", kwh: "kwh-latn-id", kwi: "kwi-latn-co", kwj: "kwj-latn-zz", kwk: "kwk-latn-ca", kwl: "kwl-latn-ng", kwm: "kwm-latn-na", kwn: "kwn-latn-na", kwo: "kwo-latn-zz", kwp: "kwp-latn-ci", kwq: "kwq-latn-zz", kwr: "kwr-latn-id", kws: "kws-latn-cd", kwt: "kwt-latn-id", kwu: "kwu-latn-cm", kwv: "kwv-latn-td", kww: "kww-latn-sr", kwy: "kwy-latn-cd", kwz: "kwz-latn-ao", kxa: "kxa-latn-zz", kxb: "kxb-latn-ci", kxc: "kxc-ethi-zz", kxd: "kxd-latn-bn", "kxd-arab": "kxd-arab-bn", kxe: "kxe-latn-zz", kxf: "kxf-mymr-mm", "kxf-latn": "kxf-latn-mm", kxi: "kxi-latn-my", kxj: "kxj-latn-td", kxk: "kxk-mymr-mm", kxl: "kxl-deva-in", kxm: "kxm-thai-th", kxn: "kxn-latn-my", kxo: "kxo-latn-br", kxp: "kxp-arab-pk", kxq: "kxq-latn-id", kxr: "kxr-latn-pg", kxt: "kxt-latn-pg", kxv: "kxv-orya-in", "kxv-latn": "kxv-latn-in", "kxv-telu": "kxv-telu-in", kxw: "kxw-latn-zz", kxx: "kxx-latn-cg", kxy: "kxy-latn-vn", kxz: "kxz-latn-zz", ky: "ky-cyrl-kg", "ky-arab": "ky-arab-cn", "ky-cn": "ky-arab-cn", "ky-latn": "ky-latn-tr", "ky-tr": "ky-latn-tr", kya: "kya-latn-tz", kyb: "kyb-latn-ph", kyc: "kyc-latn-pg", kyd: "kyd-latn-id", kye: "kye-latn-zz", kyf: "kyf-latn-ci", kyg: "kyg-latn-pg", kyh: "kyh-latn-us", kyi: "kyi-latn-my", kyj: "kyj-latn-ph", kyk: "kyk-latn-ph", kyl: "kyl-latn-us", kym: "kym-latn-cf", kyn: "kyn-latn-ph", kyo: "kyo-latn-id", kyq: "kyq-latn-td", kyr: "kyr-latn-br", kys: "kys-latn-my", kyt: "kyt-latn-id", kyu: "kyu-kali-mm", "kyu-latn": "kyu-latn-mm", "kyu-mymr": "kyu-mymr-mm", kyv: "kyv-deva-np", kyw: "kyw-deva-in", "kyw-beng": "kyw-beng-in", "kyw-orya": "kyw-orya-in", kyx: "kyx-latn-zz", kyy: "kyy-latn-pg", kyz: "kyz-latn-br", kza: "kza-latn-bf", kzb: "kzb-latn-id", kzc: "kzc-latn-ci", kzd: "kzd-latn-id", kze: "kze-latn-pg", kzf: "kzf-latn-id", kzh: "kzh-arab-zz", kzi: "kzi-latn-my", kzj: "kzj-latn-my", kzk: "kzk-latn-sb", kzl: "kzl-latn-id", kzm: "kzm-latn-id", kzn: "kzn-latn-mw", kzo: "kzo-latn-ga", kzp: "kzp-latn-id", kzr: "kzr-latn-zz", kzs: "kzs-latn-my", kzt: "kzt-latn-my", kzu: "kzu-latn-id", kzv: "kzv-latn-id", kzw: "kzw-latn-br", kzx: "kzx-latn-id", kzy: "kzy-latn-cd", kzz: "kzz-latn-id", la: "la-latn-va", laa: "laa-latn-ph", lab: "lab-lina-gr", lac: "lac-latn-mx", lad: "lad-hebr-il", lae: "lae-deva-in", "lae-tibt": "lae-tibt-in", lag: "lag-latn-tz", lah: "lah-arab-pk", lai: "lai-latn-mw", laj: "laj-latn-ug", lal: "lal-latn-cd", lam: "lam-latn-zm", lan: "lan-latn-ng", lap: "lap-latn-td", laq: "laq-latn-vn", lar: "lar-latn-gh", las: "las-latn-zz", lau: "lau-latn-id", law: "law-latn-id", lax: "lax-latn-in", "lax-beng": "lax-beng-in", laz: "laz-latn-pg", lb: "lb-latn-lu", lbb: "lbb-latn-pg", lbc: "lbc-lisu-cn", lbe: "lbe-cyrl-ru", lbf: "lbf-deva-in", "lbf-tibt": "lbf-tibt-cn", lbi: "lbi-latn-cm", lbj: "lbj-tibt-in", "lbj-arab": "lbj-arab-in", lbl: "lbl-latn-ph", lbm: "lbm-deva-in", lbn: "lbn-latn-la", "lbn-laoo": "lbn-laoo-la", lbo: "lbo-laoo-la", "lbo-latn": "lbo-latn-us", lbq: "lbq-latn-pg", lbr: "lbr-deva-np", lbt: "lbt-latn-vn", lbu: "lbu-latn-zz", lbv: "lbv-latn-pg", lbw: "lbw-latn-id", lbx: "lbx-latn-id", lby: "lby-latn-au", lbz: "lbz-latn-au", lcc: "lcc-latn-id", lcd: "lcd-latn-id", lce: "lce-latn-id", lcf: "lcf-latn-id", lch: "lch-latn-ao", lcl: "lcl-latn-id", lcm: "lcm-latn-zz", lcp: "lcp-thai-cn", lcq: "lcq-latn-id", lcs: "lcs-latn-id", lda: "lda-latn-ci", ldb: "ldb-latn-zz", ldd: "ldd-latn-ng", ldg: "ldg-latn-ng", ldh: "ldh-latn-ng", ldi: "ldi-latn-cg", ldj: "ldj-latn-ng", ldk: "ldk-latn-ng", ldl: "ldl-latn-ng", ldm: "ldm-latn-gn", ldn: "ldn-latn-001", ldo: "ldo-latn-ng", ldp: "ldp-latn-ng", ldq: "ldq-latn-ng", lea: "lea-latn-cd", leb: "leb-latn-zm", lec: "lec-latn-bo", led: "led-latn-zz", lee: "lee-latn-zz", lef: "lef-latn-gh", leh: "leh-latn-zm", lei: "lei-latn-pg", lej: "lej-latn-cd", lek: "lek-latn-pg", lel: "lel-latn-cd", lem: "lem-latn-zz", len: "len-latn-hn", leo: "leo-latn-cm", lep: "lep-lepc-in", leq: "leq-latn-zz", ler: "ler-latn-pg", les: "les-latn-cd", let: "let-latn-pg", leu: "leu-latn-zz", lev: "lev-latn-id", lew: "lew-latn-id", lex: "lex-latn-id", ley: "ley-latn-id", lez: "lez-cyrl-ru", lfa: "lfa-latn-cm", lfn: "lfn-latn-001", "lfn-cyrl": "lfn-cyrl-001", lg: "lg-latn-ug", lga: "lga-latn-sb", lgb: "lgb-latn-sb", lgg: "lgg-latn-zz", lgh: "lgh-latn-vn", lgi: "lgi-latn-id", lgk: "lgk-latn-vu", lgl: "lgl-latn-sb", lgm: "lgm-latn-cd", lgn: "lgn-latn-et", lgo: "lgo-latn-ss", lgq: "lgq-latn-gh", lgr: "lgr-latn-sb", lgt: "lgt-latn-pg", lgu: "lgu-latn-sb", lgz: "lgz-latn-cd", lha: "lha-latn-vn", lhh: "lhh-latn-id", lhi: "lhi-latn-cn", lhm: "lhm-deva-np", lhn: "lhn-latn-my", lhs: "lhs-syrc-sy", lht: "lht-latn-vu", lhu: "lhu-latn-cn", li: "li-latn-nl", lia: "lia-latn-zz", lib: "lib-latn-pg", lic: "lic-latn-cn", lid: "lid-latn-zz", lie: "lie-latn-cd", lif: "lif-deva-np", "lif-limb": "lif-limb-in", lig: "lig-latn-zz", lih: "lih-latn-zz", lij: "lij-latn-it", lik: "lik-latn-cd", lil: "lil-latn-ca", lio: "lio-latn-id", lip: "lip-latn-gh", liq: "liq-latn-et", lir: "lir-latn-lr", lis: "lis-lisu-cn", liu: "liu-latn-sd", liv: "liv-latn-lv", liw: "liw-latn-id", lix: "lix-latn-id", liy: "liy-latn-cf", liz: "liz-latn-cd", lja: "lja-latn-au", lje: "lje-latn-id", lji: "lji-latn-id", ljl: "ljl-latn-id", ljp: "ljp-latn-id", ljw: "ljw-latn-au", ljx: "ljx-latn-au", lka: "lka-latn-tl", lkb: "lkb-latn-ke", lkc: "lkc-latn-vn", lkd: "lkd-latn-br", lke: "lke-latn-ug", lkh: "lkh-tibt-bt", lki: "lki-arab-ir", lkj: "lkj-latn-my", lkl: "lkl-latn-pg", lkm: "lkm-latn-au", lkn: "lkn-latn-vu", lko: "lko-latn-ke", lkr: "lkr-latn-ss", lks: "lks-latn-ke", lkt: "lkt-latn-us", lku: "lku-latn-au", lky: "lky-latn-ss", lla: "lla-latn-ng", llb: "llb-latn-mz", llc: "llc-latn-gn", lld: "lld-latn-it", lle: "lle-latn-zz", llf: "llf-latn-pg", llg: "llg-latn-id", lli: "lli-latn-cg", llj: "llj-latn-au", llk: "llk-latn-my", lll: "lll-latn-pg", llm: "llm-latn-id", lln: "lln-latn-zz", llp: "llp-latn-vu", llq: "llq-latn-id", llu: "llu-latn-sb", llx: "llx-latn-fj", lma: "lma-latn-gn", lmb: "lmb-latn-vu", lmc: "lmc-latn-au", lmd: "lmd-latn-sd", lme: "lme-latn-td", lmf: "lmf-latn-id", lmg: "lmg-latn-pg", lmh: "lmh-deva-np", lmi: "lmi-latn-cd", lmj: "lmj-latn-id", lmk: "lmk-latn-in", "lmk-mymr": "lmk-mymr-in", lml: "lml-latn-vu", lmn: "lmn-telu-in", lmo: "lmo-latn-it", lmp: "lmp-latn-zz", lmq: "lmq-latn-id", lmr: "lmr-latn-id", lmu: "lmu-latn-vu", lmv: "lmv-latn-fj", lmw: "lmw-latn-us", lmx: "lmx-latn-cm", lmy: "lmy-latn-id", ln: "ln-latn-cd", lna: "lna-latn-cf", lnb: "lnb-latn-na", lnd: "lnd-latn-id", lnh: "lnh-latn-my", lni: "lni-latn-pg", lnj: "lnj-latn-au", lnl: "lnl-latn-cf", lnm: "lnm-latn-pg", lnn: "lnn-latn-vu", lns: "lns-latn-zz", lnu: "lnu-latn-zz", lnw: "lnw-latn-au", lnz: "lnz-latn-cd", lo: "lo-laoo-la", loa: "loa-latn-id", lob: "lob-latn-bf", loc: "loc-latn-ph", loe: "loe-latn-id", log: "log-latn-cd", loh: "loh-latn-ss", loi: "loi-latn-ci", loj: "loj-latn-zz", lok: "lok-latn-zz", lol: "lol-latn-cd", lom: "lom-latn-lr", lon: "lon-latn-mw", loo: "loo-latn-cd", lop: "lop-latn-ng", loq: "loq-latn-cd", lor: "lor-latn-zz", los: "los-latn-zz", lot: "lot-latn-ss", "lot-arab": "lot-arab-ss", lou: "lou-latn-us", low: "low-latn-my", lox: "lox-latn-id", loy: "loy-deva-np", "loy-tibt": "loy-tibt-np", loz: "loz-latn-zm", lpa: "lpa-latn-vu", lpe: "lpe-latn-id", lpn: "lpn-latn-mm", lpo: "lpo-plrd-cn", "lpo-lisu": "lpo-lisu-cn", lpx: "lpx-latn-ss", lqr: "lqr-latn-ss", lra: "lra-latn-my", lrc: "lrc-arab-ir", lrg: "lrg-latn-au", lri: "lri-latn-ke", lrk: "lrk-arab-pk", lrl: "lrl-arab-ir", lrm: "lrm-latn-ke", lrn: "lrn-latn-id", lro: "lro-latn-sd", lrt: "lrt-latn-id", lrv: "lrv-latn-vu", lrz: "lrz-latn-vu", lsa: "lsa-arab-ir", lsd: "lsd-hebr-il", lse: "lse-latn-cd", lsi: "lsi-latn-mm", lsm: "lsm-latn-ug", lsr: "lsr-latn-pg", lss: "lss-arab-pk", lt: "lt-latn-lt", ltg: "ltg-latn-lv", lth: "lth-latn-ug", lti: "lti-latn-id", ltn: "ltn-latn-br", lto: "lto-latn-ke", lts: "lts-latn-ke", ltu: "ltu-latn-id", lu: "lu-latn-cd", lua: "lua-latn-cd", luc: "luc-latn-ug", lud: "lud-latn-ru", lue: "lue-latn-zm", luf: "luf-latn-pg", lui: "lui-latn-us", luj: "luj-latn-cd", luk: "luk-tibt-bt", lul: "lul-latn-ss", lum: "lum-latn-ao", lun: "lun-latn-zm", luo: "luo-latn-ke", lup: "lup-latn-ga", luq: "luq-latn-cu", lur: "lur-latn-id", lus: "lus-latn-in", "lus-beng": "lus-beng-bd", "lus-brai": "lus-brai-in", lut: "lut-latn-us", luu: "luu-deva-np", luv: "luv-arab-om", luw: "luw-latn-cm", luy: "luy-latn-ke", luz: "luz-arab-ir", lv: "lv-latn-lv", lva: "lva-latn-tl", lvi: "lvi-latn-la", lvk: "lvk-latn-sb", lvu: "lvu-latn-id", lwa: "lwa-latn-cd", lwe: "lwe-latn-id", lwg: "lwg-latn-ke", lwh: "lwh-latn-vn", lwl: "lwl-thai-th", lwm: "lwm-thai-cn", lwo: "lwo-latn-ss", "lwo-za": "lwo-latn-za", lwt: "lwt-latn-id", lww: "lww-latn-vu", lxm: "lxm-latn-pg", lya: "lya-tibt-bt", lyn: "lyn-latn-zm", lzh: "lzh-hans-cn", lzl: "lzl-latn-vu", lzn: "lzn-latn-mm", lzz: "lzz-latn-tr", maa: "maa-latn-mx", mab: "mab-latn-mx", mad: "mad-latn-id", mae: "mae-latn-ng", maf: "maf-latn-cm", mag: "mag-deva-in", mai: "mai-deva-in", maj: "maj-latn-mx", mak: "mak-latn-id", mam: "mam-latn-gt", man: "man-latn-gm", "man-gn": "man-nkoo-gn", "man-nkoo": "man-nkoo-gn", maq: "maq-latn-mx", mas: "mas-latn-ke", mat: "mat-latn-mx", mau: "mau-latn-mx", mav: "mav-latn-br", maw: "maw-latn-zz", max: "max-latn-id", maz: "maz-latn-mx", mba: "mba-latn-ph", mbb: "mbb-latn-ph", mbc: "mbc-latn-br", mbd: "mbd-latn-ph", mbf: "mbf-latn-sg", mbh: "mbh-latn-zz", mbi: "mbi-latn-ph", mbj: "mbj-latn-br", mbk: "mbk-latn-pg", mbl: "mbl-latn-br", mbm: "mbm-latn-cg", mbn: "mbn-latn-co", mbo: "mbo-latn-zz", mbp: "mbp-latn-co", mbq: "mbq-latn-zz", mbr: "mbr-latn-co", mbs: "mbs-latn-ph", mbt: "mbt-latn-ph", mbu: "mbu-latn-zz", mbv: "mbv-latn-gn", mbw: "mbw-latn-zz", mbx: "mbx-latn-pg", mby: "mby-arab-pk", mbz: "mbz-latn-mx", mca: "mca-latn-py", mcb: "mcb-latn-pe", mcc: "mcc-latn-pg", mcd: "mcd-latn-pe", mce: "mce-latn-mx", mcf: "mcf-latn-pe", mcg: "mcg-latn-ve", mch: "mch-latn-ve", mci: "mci-latn-zz", mcj: "mcj-latn-ng", mck: "mck-latn-ao", mcl: "mcl-latn-co", mcm: "mcm-latn-my", mcn: "mcn-latn-td", mco: "mco-latn-mx", mcp: "mcp-latn-zz", mcq: "mcq-latn-zz", mcr: "mcr-latn-zz", mcs: "mcs-latn-cm", mct: "mct-latn-cm", mcu: "mcu-latn-zz", mcv: "mcv-latn-pg", mcw: "mcw-latn-td", mcx: "mcx-latn-cf", mcy: "mcy-latn-pg", mcz: "mcz-latn-pg", mda: "mda-latn-zz", mdb: "mdb-latn-pg", mdc: "mdc-latn-pg", mdd: "mdd-latn-cm", mde: "mde-arab-zz", mdf: "mdf-cyrl-ru", mdg: "mdg-latn-td", mdh: "mdh-latn-ph", mdi: "mdi-latn-cd", mdj: "mdj-latn-zz", mdk: "mdk-latn-cd", mdm: "mdm-latn-cd", mdn: "mdn-latn-cf", mdp: "mdp-latn-cd", mdq: "mdq-latn-cd", mdr: "mdr-latn-id", mds: "mds-latn-pg", mdt: "mdt-latn-cg", mdu: "mdu-latn-cg", mdv: "mdv-latn-mx", mdw: "mdw-latn-cg", mdx: "mdx-ethi-zz", mdy: "mdy-ethi-et", "mdy-latn": "mdy-latn-et", mdz: "mdz-latn-br", mea: "mea-latn-cm", meb: "meb-latn-pg", mec: "mec-latn-au", med: "med-latn-zz", mee: "mee-latn-zz", meh: "meh-latn-mx", mej: "mej-latn-id", mek: "mek-latn-zz", mel: "mel-latn-my", mem: "mem-latn-au", men: "men-latn-sl", meo: "meo-latn-my", "meo-arab": "meo-arab-my", mep: "mep-latn-au", meq: "meq-latn-cm", mer: "mer-latn-ke", mes: "mes-latn-td", met: "met-latn-zz", meu: "meu-latn-zz", mev: "mev-latn-lr", mew: "mew-latn-ng", mey: "mey-latn-mr", "mey-arab": "mey-arab-mr", mez: "mez-latn-us", mfa: "mfa-arab-th", mfb: "mfb-latn-id", mfc: "mfc-latn-cd", mfd: "mfd-latn-cm", mfe: "mfe-latn-mu", mff: "mff-latn-cm", mfg: "mfg-latn-gn", "mfg-arab": "mfg-arab-gn", mfh: "mfh-latn-cm", mfi: "mfi-arab-cm", "mfi-latn": "mfi-latn-cm", mfj: "mfj-latn-cm", mfk: "mfk-latn-cm", mfl: "mfl-latn-ng", mfm: "mfm-latn-ng", mfn: "mfn-latn-zz", mfo: "mfo-latn-zz", mfp: "mfp-latn-id", mfq: "mfq-latn-zz", mfr: "mfr-latn-au", mft: "mft-latn-pg", mfu: "mfu-latn-ao", mfv: "mfv-latn-gw", mfw: "mfw-latn-pg", mfx: "mfx-latn-et", "mfx-ethi": "mfx-ethi-et", mfy: "mfy-latn-mx", mfz: "mfz-latn-ss", mg: "mg-latn-mg", mgb: "mgb-latn-td", mgc: "mgc-latn-ss", mgd: "mgd-latn-ss", "mgd-arab": "mgd-arab-ss", mge: "mge-latn-td", mgf: "mgf-latn-id", mgg: "mgg-latn-cm", mgh: "mgh-latn-mz", mgi: "mgi-latn-ng", mgj: "mgj-latn-ng", mgk: "mgk-latn-id", mgl: "mgl-latn-zz", mgm: "mgm-latn-tl", mgn: "mgn-latn-cf", mgo: "mgo-latn-cm", mgp: "mgp-deva-np", mgq: "mgq-latn-tz", mgr: "mgr-latn-zm", mgs: "mgs-latn-tz", mgt: "mgt-latn-pg", mgu: "mgu-latn-pg", mgv: "mgv-latn-tz", mgw: "mgw-latn-tz", mgy: "mgy-latn-tz", mgz: "mgz-latn-tz", mh: "mh-latn-mh", mhb: "mhb-latn-ga", mhc: "mhc-latn-mx", mhd: "mhd-latn-tz", mhe: "mhe-latn-my", mhf: "mhf-latn-pg", mhg: "mhg-latn-au", mhi: "mhi-latn-zz", mhj: "mhj-arab-af", mhk: "mhk-latn-cm", mhl: "mhl-latn-zz", mhm: "mhm-latn-mz", mhn: "mhn-latn-it", mho: "mho-latn-zm", mhp: "mhp-latn-id", mhq: "mhq-latn-us", mhs: "mhs-latn-id", mht: "mht-latn-ve", mhu: "mhu-latn-in", mhw: "mhw-latn-bw", mhx: "mhx-latn-mm", mhy: "mhy-latn-id", mhz: "mhz-latn-id", mi: "mi-latn-nz", mia: "mia-latn-us", mib: "mib-latn-mx", mic: "mic-latn-ca", mid: "mid-mand-iq", mie: "mie-latn-mx", mif: "mif-latn-zz", mig: "mig-latn-mx", mih: "mih-latn-mx", mii: "mii-latn-mx", mij: "mij-latn-cm", mik: "mik-latn-us", mil: "mil-latn-mx", mim: "mim-latn-mx", min: "min-latn-id", mio: "mio-latn-mx", mip: "mip-latn-mx", miq: "miq-latn-ni", mir: "mir-latn-mx", mit: "mit-latn-mx", miu: "miu-latn-mx", miw: "miw-latn-zz", mix: "mix-latn-mx", miy: "miy-latn-mx", miz: "miz-latn-mx", mjb: "mjb-latn-tl", mjc: "mjc-latn-mx", mjd: "mjd-latn-us", mje: "mje-latn-td", mjg: "mjg-latn-cn", mjh: "mjh-latn-tz", mji: "mji-latn-cn", mjj: "mjj-latn-pg", mjk: "mjk-latn-pg", mjl: "mjl-deva-in", "mjl-takr": "mjl-takr-in", mjm: "mjm-latn-pg", mjn: "mjn-latn-pg", mjq: "mjq-mlym-in", mjr: "mjr-mlym-in", mjs: "mjs-latn-ng", mjt: "mjt-deva-in", "mjt-beng": "mjt-beng-bd", mju: "mju-telu-in", mjv: "mjv-mlym-in", mjw: "mjw-latn-in", mjx: "mjx-latn-bd", "mjx-beng": "mjx-beng-bd", mjy: "mjy-latn-us", mjz: "mjz-deva-np", mk: "mk-cyrl-mk", mka: "mka-latn-ci", mkb: "mkb-deva-in", mkc: "mkc-latn-pg", mke: "mke-deva-in", mkf: "mkf-latn-ng", mki: "mki-arab-zz", mkj: "mkj-latn-fm", mkk: "mkk-latn-cm", mkl: "mkl-latn-zz", mkm: "mkm-thai-th", mkn: "mkn-latn-id", mko: "mko-latn-ng", mkp: "mkp-latn-zz", mkr: "mkr-latn-pg", mks: "mks-latn-mx", mkt: "mkt-latn-nc", mku: "mku-latn-gn", mkv: "mkv-latn-vu", mkw: "mkw-latn-zz", mkx: "mkx-latn-ph", mky: "mky-latn-id", mkz: "mkz-latn-tl", ml: "ml-mlym-in", mla: "mla-latn-vu", mlb: "mlb-latn-cm", mlc: "mlc-latn-vn", mle: "mle-latn-zz", mlf: "mlf-thai-la", "mlf-latn": "mlf-latn-la", mlh: "mlh-latn-pg", mli: "mli-latn-id", mlj: "mlj-latn-td", mlk: "mlk-latn-ke", mll: "mll-latn-vu", mln: "mln-latn-sb", mlo: "mlo-latn-sn", mlp: "mlp-latn-zz", mlq: "mlq-latn-sn", "mlq-arab": "mlq-arab-sn", mlr: "mlr-latn-cm", mls: "mls-latn-sd", mlu: "mlu-latn-sb", mlv: "mlv-latn-vu", mlw: "mlw-latn-cm", mlx: "mlx-latn-vu", mlz: "mlz-latn-ph", mma: "mma-latn-ng", mmb: "mmb-latn-id", mmc: "mmc-latn-mx", mmd: "mmd-latn-cn", "mmd-hans": "mmd-hans-cn", "mmd-hant": "mmd-hant-cn", mme: "mme-latn-vu", mmf: "mmf-latn-ng", mmg: "mmg-latn-vu", mmh: "mmh-latn-br", mmi: "mmi-latn-pg", mmm: "mmm-latn-vu", mmn: "mmn-latn-ph", mmo: "mmo-latn-zz", mmp: "mmp-latn-pg", mmq: "mmq-latn-pg", mmr: "mmr-latn-cn", mmt: "mmt-latn-pg", mmu: "mmu-latn-zz", mmv: "mmv-latn-br", mmw: "mmw-latn-vu", mmx: "mmx-latn-zz", mmy: "mmy-latn-td", mmz: "mmz-latn-cd", mn: "mn-cyrl-mn", "mn-cn": "mn-mong-cn", "mn-mong": "mn-mong-cn", mna: "mna-latn-zz", mnb: "mnb-latn-id", mnd: "mnd-latn-br", mne: "mne-latn-td", mnf: "mnf-latn-zz", mng: "mng-latn-vn", mnh: "mnh-latn-cd", mni: "mni-beng-in", mnj: "mnj-arab-af", mnl: "mnl-latn-vu", mnm: "mnm-latn-pg", mnn: "mnn-latn-vn", mnp: "mnp-latn-cn", mnq: "mnq-latn-my", mnr: "mnr-latn-us", mns: "mns-cyrl-ru", mnu: "mnu-latn-id", mnv: "mnv-latn-sb", mnw: "mnw-mymr-mm", mnx: "mnx-latn-id", mny: "mny-latn-mz", mnz: "mnz-latn-id", mo: "mo-latn-ro", moa: "moa-latn-zz", moc: "moc-latn-ar", mod: "mod-latn-us", moe: "moe-latn-ca", mog: "mog-latn-id", moh: "moh-latn-ca", moi: "moi-latn-ng", moj: "moj-latn-cg", mok: "mok-latn-id", mom: "mom-latn-ni", moo: "moo-latn-vn", mop: "mop-latn-bz", moq: "moq-latn-id", mor: "mor-latn-sd", mos: "mos-latn-bf", mot: "mot-latn-co", mou: "mou-latn-td", mov: "mov-latn-us", mow: "mow-latn-cg", mox: "mox-latn-zz", moy: "moy-latn-et", "moy-ethi": "moy-ethi-et", moz: "moz-latn-td", mpa: "mpa-latn-tz", mpb: "mpb-latn-au", mpc: "mpc-latn-au", mpd: "mpd-latn-br", mpe: "mpe-latn-et", "mpe-ethi": "mpe-ethi-et", mpg: "mpg-latn-td", mph: "mph-latn-au", mpi: "mpi-latn-cm", mpj: "mpj-latn-au", mpk: "mpk-latn-td", mpl: "mpl-latn-pg", mpm: "mpm-latn-mx", mpn: "mpn-latn-pg", mpo: "mpo-latn-pg", mpp: "mpp-latn-zz", mpq: "mpq-latn-br", mpr: "mpr-latn-sb", mps: "mps-latn-zz", mpt: "mpt-latn-zz", mpu: "mpu-latn-br", mpv: "mpv-latn-pg", mpw: "mpw-latn-br", mpx: "mpx-latn-zz", mpy: "mpy-latn-id", mpz: "mpz-thai-th", mqa: "mqa-latn-id", mqb: "mqb-latn-cm", mqc: "mqc-latn-id", mqe: "mqe-latn-pg", mqf: "mqf-latn-id", mqg: "mqg-latn-id", mqh: "mqh-latn-mx", mqi: "mqi-latn-id", mqj: "mqj-latn-id", mqk: "mqk-latn-ph", mql: "mql-latn-zz", mqm: "mqm-latn-pf", mqn: "mqn-latn-id", mqo: "mqo-latn-id", mqp: "mqp-latn-id", mqq: "mqq-latn-my", mqr: "mqr-latn-id", mqs: "mqs-latn-id", mqu: "mqu-latn-ss", mqv: "mqv-latn-pg", mqw: "mqw-latn-pg", mqx: "mqx-latn-id", "mqx-bugi": "mqx-bugi-id", mqy: "mqy-latn-id", mqz: "mqz-latn-pg", mr: "mr-deva-in", mra: "mra-thai-th", mrb: "mrb-latn-vu", mrc: "mrc-latn-us", mrd: "mrd-deva-np", mrf: "mrf-latn-id", mrg: "mrg-latn-in", "mrg-beng": "mrg-beng-in", "mrg-deva": "mrg-deva-in", mrh: "mrh-latn-in", mrj: "mrj-cyrl-ru", mrk: "mrk-latn-nc", mrl: "mrl-latn-fm", mrm: "mrm-latn-vu", mrn: "mrn-latn-sb", mro: "mro-mroo-bd", mrp: "mrp-latn-vu", mrq: "mrq-latn-pf", mrr: "mrr-deva-in", mrs: "mrs-latn-vu", mrt: "mrt-latn-ng", mru: "mru-latn-cm", mrv: "mrv-latn-pf", mrw: "mrw-latn-ph", "mrw-arab": "mrw-arab-ph", mrx: "mrx-latn-id", mry: "mry-latn-ph", mrz: "mrz-latn-id", ms: "ms-latn-my", "ms-cc": "ms-arab-cc", msb: "msb-latn-ph", msc: "msc-latn-gn", mse: "mse-latn-td", msf: "msf-latn-id", msg: "msg-latn-id", msh: "msh-latn-mg", msi: "msi-latn-my", msj: "msj-latn-cd", msk: "msk-latn-ph", msl: "msl-latn-id", msm: "msm-latn-ph", msn: "msn-latn-vu", mso: "mso-latn-id", msp: "msp-latn-br", msq: "msq-latn-nc", mss: "mss-latn-id", msu: "msu-latn-pg", msv: "msv-latn-cm", msw: "msw-latn-gw", msx: "msx-latn-pg", msy: "msy-latn-pg", msz: "msz-latn-pg", mt: "mt-latn-mt", mta: "mta-latn-ph", mtb: "mtb-latn-ci", mtc: "mtc-latn-zz", mtd: "mtd-latn-id", mte: "mte-latn-sb", mtf: "mtf-latn-zz", mtg: "mtg-latn-id", mth: "mth-latn-id", mti: "mti-latn-zz", mtj: "mtj-latn-id", mtk: "mtk-latn-cm", mtl: "mtl-latn-ng", mtm: "mtm-cyrl-ru", mtn: "mtn-latn-ni", mto: "mto-latn-mx", mtp: "mtp-latn-bo", mtq: "mtq-latn-vn", mtr: "mtr-deva-in", mts: "mts-latn-pe", mtt: "mtt-latn-vu", mtu: "mtu-latn-mx", mtv: "mtv-latn-pg", mtw: "mtw-latn-ph", mtx: "mtx-latn-mx", mty: "mty-latn-pg", mua: "mua-latn-cm", mub: "mub-latn-td", muc: "muc-latn-cm", mud: "mud-cyrl-ru", mue: "mue-latn-ec", mug: "mug-latn-cm", muh: "muh-latn-ss", mui: "mui-latn-id", muj: "muj-latn-td", muk: "muk-tibt-np", mum: "mum-latn-pg", muo: "muo-latn-cm", muq: "muq-latn-cn", mur: "mur-latn-zz", mus: "mus-latn-us", mut: "mut-deva-in", muu: "muu-latn-ke", muv: "muv-taml-in", mux: "mux-latn-pg", muy: "muy-latn-cm", muz: "muz-ethi-et", "muz-latn": "muz-latn-et", mva: "mva-latn-zz", mvd: "mvd-latn-id", mvf: "mvf-mong-cn", "mvf-phag": "mvf-phag-cn", mvg: "mvg-latn-mx", mvh: "mvh-latn-td", mvk: "mvk-latn-pg", mvl: "mvl-latn-au", mvn: "mvn-latn-zz", mvo: "mvo-latn-sb", mvp: "mvp-latn-id", mvq: "mvq-latn-pg", mvr: "mvr-latn-id", mvs: "mvs-latn-id", mvt: "mvt-latn-vu", mvu: "mvu-latn-td", mvv: "mvv-latn-my", mvw: "mvw-latn-tz", mvx: "mvx-latn-id", mvy: "mvy-arab-pk", mvz: "mvz-ethi-et", "mvz-arab": "mvz-arab-et", mwa: "mwa-latn-pg", mwb: "mwb-latn-pg", mwc: "mwc-latn-pg", mwe: "mwe-latn-tz", mwf: "mwf-latn-au", mwg: "mwg-latn-pg", mwh: "mwh-latn-pg", mwi: "mwi-latn-vu", mwk: "mwk-latn-ml", mwl: "mwl-latn-pt", mwm: "mwm-latn-td", mwn: "mwn-latn-zm", mwo: "mwo-latn-vu", mwp: "mwp-latn-au", mwq: "mwq-latn-mm", mwr: "mwr-deva-in", mws: "mws-latn-ke", mwt: "mwt-mymr-mm", "mwt-thai": "mwt-thai-th", mwu: "mwu-latn-ss", mwv: "mwv-latn-id", mww: "mww-hmnp-us", mwz: "mwz-latn-cd", mxa: "mxa-latn-mx", mxb: "mxb-latn-mx", mxc: "mxc-latn-zw", mxd: "mxd-latn-id", mxe: "mxe-latn-vu", mxf: "mxf-latn-cm", mxg: "mxg-latn-ao", mxh: "mxh-latn-cd", mxi: "mxi-latn-es", mxj: "mxj-latn-in", mxk: "mxk-latn-pg", mxl: "mxl-latn-bj", mxm: "mxm-latn-zz", mxn: "mxn-latn-id", mxo: "mxo-latn-zm", mxp: "mxp-latn-mx", mxq: "mxq-latn-mx", mxr: "mxr-latn-my", mxs: "mxs-latn-mx", mxt: "mxt-latn-mx", mxu: "mxu-latn-cm", mxv: "mxv-latn-mx", mxw: "mxw-latn-pg", mxx: "mxx-latn-ci", mxy: "mxy-latn-mx", mxz: "mxz-latn-id", my: "my-mymr-mm", myb: "myb-latn-td", myc: "myc-latn-cd", mye: "mye-latn-ga", myf: "myf-latn-et", myg: "myg-latn-cm", myh: "myh-latn-us", myj: "myj-latn-ss", myk: "myk-latn-zz", myl: "myl-latn-id", mym: "mym-ethi-zz", myp: "myp-latn-br", myr: "myr-latn-pe", myu: "myu-latn-br", myv: "myv-cyrl-ru", myw: "myw-latn-zz", myx: "myx-latn-ug", myy: "myy-latn-co", myz: "myz-mand-ir", mza: "mza-latn-mx", mzd: "mzd-latn-cm", mze: "mze-latn-pg", mzh: "mzh-latn-ar", mzi: "mzi-latn-mx", mzj: "mzj-latn-lr", mzk: "mzk-latn-zz", mzl: "mzl-latn-mx", mzm: "mzm-latn-zz", mzn: "mzn-arab-ir", mzo: "mzo-latn-br", mzp: "mzp-latn-zz", mzq: "mzq-latn-id", mzr: "mzr-latn-br", mzt: "mzt-latn-my", mzu: "mzu-latn-pg", mzv: "mzv-latn-cf", mzw: "mzw-latn-zz", mzx: "mzx-latn-gy", mzz: "mzz-latn-zz", na: "na-latn-nr", naa: "naa-latn-id", nab: "nab-latn-br", nac: "nac-latn-zz", nae: "nae-latn-id", naf: "naf-latn-zz", nag: "nag-latn-in", naj: "naj-latn-gn", nak: "nak-latn-zz", nal: "nal-latn-pg", nam: "nam-latn-au", nan: "nan-hans-cn", nao: "nao-deva-np", nap: "nap-latn-it", naq: "naq-latn-na", nar: "nar-latn-ng", nas: "nas-latn-zz", nat: "nat-latn-ng", naw: "naw-latn-gh", nax: "nax-latn-pg", nay: "nay-latn-au", naz: "naz-latn-mx", nb: "nb-latn-no", nba: "nba-latn-ao", nbb: "nbb-latn-ng", nbc: "nbc-latn-in", nbd: "nbd-latn-cd", nbe: "nbe-latn-in", nbh: "nbh-latn-ng", nbi: "nbi-latn-in", nbj: "nbj-latn-au", nbk: "nbk-latn-pg", nbm: "nbm-latn-cf", nbn: "nbn-latn-id", nbo: "nbo-latn-ng", nbp: "nbp-latn-ng", nbq: "nbq-latn-id", nbr: "nbr-latn-ng", nbt: "nbt-latn-in", "nbt-deva": "nbt-deva-in", nbu: "nbu-latn-in", nbv: "nbv-latn-cm", nbw: "nbw-latn-cd", nby: "nby-latn-pg", nca: "nca-latn-zz", ncb: "ncb-latn-in", "ncb-deva": "ncb-deva-in", ncc: "ncc-latn-pg", ncd: "ncd-deva-np", nce: "nce-latn-zz", ncf: "ncf-latn-zz", ncg: "ncg-latn-ca", nch: "nch-latn-mx", nci: "nci-latn-mx", ncj: "ncj-latn-mx", nck: "nck-latn-au", ncl: "ncl-latn-mx", ncm: "ncm-latn-pg", ncn: "ncn-latn-pg", nco: "nco-latn-zz", ncq: "ncq-laoo-la", "ncq-thai": "ncq-thai-la", ncr: "ncr-latn-cm", nct: "nct-latn-in", "nct-beng": "nct-beng-in", ncu: "ncu-latn-zz", ncx: "ncx-latn-mx", ncz: "ncz-latn-us", nd: "nd-latn-zw", nda: "nda-latn-cg", ndb: "ndb-latn-cm", ndc: "ndc-latn-mz", ndd: "ndd-latn-ng", ndf: "ndf-cyrl-ru", ndg: "ndg-latn-tz", ndh: "ndh-latn-tz", ndi: "ndi-latn-ng", ndj: "ndj-latn-tz", ndk: "ndk-latn-cd", ndl: "ndl-latn-cd", ndm: "ndm-latn-td", ndn: "ndn-latn-cg", ndp: "ndp-latn-ug", ndq: "ndq-latn-ao", ndr: "ndr-latn-ng", nds: "nds-latn-de", ndt: "ndt-latn-cd", ndu: "ndu-latn-cm", ndv: "ndv-latn-sn", ndw: "ndw-latn-cd", ndx: "ndx-latn-id", ndy: "ndy-latn-cf", "ndy-td": "ndy-latn-td", ndz: "ndz-latn-ss", ne: "ne-deva-np", nea: "nea-latn-id", neb: "neb-latn-zz", nec: "nec-latn-id", ned: "ned-latn-ng", nee: "nee-latn-nc", neg: "neg-cyrl-ru", neh: "neh-tibt-bt", nei: "nei-xsux-tr", nej: "nej-latn-pg", nek: "nek-latn-nc", nem: "nem-latn-nc", nen: "nen-latn-nc", neo: "neo-latn-vn", neq: "neq-latn-mx", ner: "ner-latn-id", net: "net-latn-pg", neu: "neu-latn-001", new: "new-deva-np", nex: "nex-latn-zz", ney: "ney-latn-ci", nez: "nez-latn-us", nfa: "nfa-latn-id", nfd: "nfd-latn-ng", nfl: "nfl-latn-sb", nfr: "nfr-latn-zz", nfu: "nfu-latn-cm", ng: "ng-latn-na", nga: "nga-latn-zz", ngb: "ngb-latn-zz", ngc: "ngc-latn-cd", ngd: "ngd-latn-cf", nge: "nge-latn-cm", ngg: "ngg-latn-cf", ngh: "ngh-latn-za", ngi: "ngi-latn-ng", ngj: "ngj-latn-cm", ngk: "ngk-latn-au", ngl: "ngl-latn-mz", ngm: "ngm-latn-fm", ngn: "ngn-latn-cm", ngp: "ngp-latn-tz", ngq: "ngq-latn-tz", ngr: "ngr-latn-sb", ngs: "ngs-latn-ng", ngt: "ngt-laoo-la", ngu: "ngu-latn-mx", ngv: "ngv-latn-cm", ngw: "ngw-latn-ng", ngx: "ngx-latn-ng", ngy: "ngy-latn-cm", ngz: "ngz-latn-cg", nha: "nha-latn-au", nhb: "nhb-latn-zz", nhc: "nhc-latn-mx", nhd: "nhd-latn-py", nhe: "nhe-latn-mx", nhf: "nhf-latn-au", nhg: "nhg-latn-mx", nhi: "nhi-latn-mx", nhk: "nhk-latn-mx", nhm: "nhm-latn-mx", nhn: "nhn-latn-mx", nho: "nho-latn-pg", nhp: "nhp-latn-mx", nhq: "nhq-latn-mx", nhr: "nhr-latn-bw", nht: "nht-latn-mx", nhu: "nhu-latn-cm", nhv: "nhv-latn-mx", nhw: "nhw-latn-mx", nhx: "nhx-latn-mx", nhy: "nhy-latn-mx", nhz: "nhz-latn-mx", nia: "nia-latn-id", nib: "nib-latn-pg", nid: "nid-latn-au", nie: "nie-latn-td", nif: "nif-latn-zz", nig: "nig-latn-au", nih: "nih-latn-tz", nii: "nii-latn-zz", nij: "nij-latn-id", nil: "nil-latn-id", nim: "nim-latn-tz", nin: "nin-latn-zz", nio: "nio-cyrl-ru", niq: "niq-latn-ke", nir: "nir-latn-id", nis: "nis-latn-pg", nit: "nit-telu-in", niu: "niu-latn-nu", niv: "niv-cyrl-ru", "niv-latn": "niv-latn-ru", niw: "niw-latn-pg", nix: "nix-latn-cd", niy: "niy-latn-zz", niz: "niz-latn-zz", nja: "nja-latn-ng", njb: "njb-latn-in", njd: "njd-latn-tz", njh: "njh-latn-in", nji: "nji-latn-au", njj: "njj-latn-cm", njl: "njl-latn-ss", njm: "njm-latn-in", njn: "njn-latn-in", njo: "njo-latn-in", njr: "njr-latn-ng", njs: "njs-latn-id", njt: "njt-latn-sr", nju: "nju-latn-au", njx: "njx-latn-cg", njy: "njy-latn-cm", njz: "njz-latn-in", "njz-beng": "njz-beng-in", nka: "nka-latn-zm", nkb: "nkb-latn-in", nkc: "nkc-latn-cm", nkd: "nkd-latn-in", nke: "nke-latn-sb", nkf: "nkf-latn-in", nkg: "nkg-latn-zz", nkh: "nkh-latn-in", nki: "nki-latn-in", "nki-beng": "nki-beng-in", nkj: "nkj-latn-id", nkk: "nkk-latn-vu", nkm: "nkm-latn-pg", nkn: "nkn-latn-ao", nko: "nko-latn-zz", nkq: "nkq-latn-gh", nkr: "nkr-latn-fm", nks: "nks-latn-id", nkt: "nkt-latn-tz", nku: "nku-latn-ci", nkv: "nkv-latn-mw", nkw: "nkw-latn-cd", nkx: "nkx-latn-ng", nkz: "nkz-latn-ng", nl: "nl-latn-nl", nla: "nla-latn-cm", nlc: "nlc-latn-id", nle: "nle-latn-ke", nlg: "nlg-latn-sb", nli: "nli-arab-af", nlj: "nlj-latn-cd", nlk: "nlk-latn-id", nlm: "nlm-arab-pk", nlo: "nlo-latn-cd", nlq: "nlq-latn-mm", nlu: "nlu-latn-gh", nlv: "nlv-latn-mx", nlw: "nlw-latn-au", nlx: "nlx-deva-in", nly: "nly-latn-au", nlz: "nlz-latn-sb", nma: "nma-latn-in", nmb: "nmb-latn-vu", nmc: "nmc-latn-td", nmd: "nmd-latn-ga", nme: "nme-latn-in", nmf: "nmf-latn-in", nmg: "nmg-latn-cm", nmh: "nmh-latn-in", nmi: "nmi-latn-ng", nmj: "nmj-latn-cf", nmk: "nmk-latn-vu", nml: "nml-latn-cm", nmm: "nmm-deva-np", "nmm-tibt": "nmm-tibt-np", nmn: "nmn-latn-bw", nmo: "nmo-latn-in", "nmo-beng": "nmo-beng-in", nmp: "nmp-latn-au", nmq: "nmq-latn-zw", nmr: "nmr-latn-cm", nms: "nms-latn-vu", nmt: "nmt-latn-fm", nmu: "nmu-latn-us", nmv: "nmv-latn-au", nmw: "nmw-latn-pg", nmx: "nmx-latn-pg", nmz: "nmz-latn-zz", nn: "nn-latn-no", nna: "nna-latn-au", nnb: "nnb-latn-cd", nnc: "nnc-latn-td", nnd: "nnd-latn-vu", nne: "nne-latn-ao", nnf: "nnf-latn-zz", nng: "nng-latn-in", "nng-beng": "nng-beng-in", nnh: "nnh-latn-cm", nni: "nni-latn-id", nnj: "nnj-latn-et", nnk: "nnk-latn-zz", nnl: "nnl-latn-in", nnm: "nnm-latn-zz", nnn: "nnn-latn-td", nnp: "nnp-wcho-in", nnq: "nnq-latn-tz", nnr: "nnr-latn-au", nnt: "nnt-latn-us", nnu: "nnu-latn-gh", nnv: "nnv-latn-au", nnw: "nnw-latn-bf", nny: "nny-latn-au", nnz: "nnz-latn-cm", no: "no-latn-no", noa: "noa-latn-co", noc: "noc-latn-pg", nod: "nod-lana-th", noe: "noe-deva-in", nof: "nof-latn-pg", nog: "nog-cyrl-ru", noh: "noh-latn-pg", noi: "noi-deva-in", noj: "noj-latn-co", nok: "nok-latn-us", nom: "nom-latn-pe", non: "non-runr-se", nop: "nop-latn-zz", noq: "noq-latn-cd", nos: "nos-yiii-cn", not: "not-latn-pe", nou: "nou-latn-zz", nov: "nov-latn-001", now: "now-latn-tz", noy: "noy-latn-td", npb: "npb-tibt-bt", npg: "npg-latn-mm", nph: "nph-latn-in", npl: "npl-latn-mx", npn: "npn-latn-pg", npo: "npo-latn-in", nps: "nps-latn-id", npu: "npu-latn-in", npx: "npx-latn-sb", npy: "npy-latn-id", nqg: "nqg-latn-bj", nqk: "nqk-latn-bj", nql: "nql-latn-ao", nqm: "nqm-latn-id", nqn: "nqn-latn-pg", nqo: "nqo-nkoo-gn", nqq: "nqq-latn-mm", nqt: "nqt-latn-ng", nqy: "nqy-latn-mm", nr: "nr-latn-za", nra: "nra-latn-ga", nrb: "nrb-latn-zz", nre: "nre-latn-in", nrf: "nrf-latn-je", nrg: "nrg-latn-vu", nri: "nri-latn-in", nrk: "nrk-latn-au", nrl: "nrl-latn-au", nrm: "nrm-latn-my", nrp: "nrp-latn-it", nru: "nru-latn-cn", "nru-hans": "nru-hans-cn", "nru-hant": "nru-hant-cn", nrx: "nrx-latn-au", nrz: "nrz-latn-pg", nsa: "nsa-latn-in", nsb: "nsb-latn-za", nsc: "nsc-latn-ng", nsd: "nsd-yiii-cn", nse: "nse-latn-zm", nsf: "nsf-yiii-cn", nsg: "nsg-latn-tz", nsh: "nsh-latn-cm", nsk: "nsk-cans-ca", nsm: "nsm-latn-in", nsn: "nsn-latn-zz", nso: "nso-latn-za", nsq: "nsq-latn-us", nss: "nss-latn-zz", nst: "nst-tnsa-in", nsu: "nsu-latn-mx", nsv: "nsv-yiii-cn", nsw: "nsw-latn-vu", nsx: "nsx-latn-ao", nsy: "nsy-latn-id", nsz: "nsz-latn-us", ntd: "ntd-latn-my", nte: "nte-latn-mz", ntg: "ntg-latn-au", nti: "nti-latn-bf", ntj: "ntj-latn-au", ntk: "ntk-latn-tz", ntm: "ntm-latn-zz", nto: "nto-latn-cd", ntp: "ntp-latn-mx", ntr: "ntr-latn-zz", ntu: "ntu-latn-sb", ntx: "ntx-latn-mm", nty: "nty-yiii-vn", ntz: "ntz-arab-ir", nua: "nua-latn-nc", nuc: "nuc-latn-br", nud: "nud-latn-pg", nue: "nue-latn-cd", nuf: "nuf-latn-cn", nug: "nug-latn-au", nuh: "nuh-latn-ng", nui: "nui-latn-zz", nuj: "nuj-latn-ug", nuk: "nuk-latn-ca", num: "num-latn-to", nun: "nun-latn-mm", nuo: "nuo-latn-vn", nup: "nup-latn-zz", nuq: "nuq-latn-pg", nur: "nur-latn-pg", nus: "nus-latn-ss", nut: "nut-latn-vn", nuu: "nuu-latn-cd", nuv: "nuv-latn-zz", nuw: "nuw-latn-fm", nux: "nux-latn-zz", nuy: "nuy-latn-au", nuz: "nuz-latn-mx", nv: "nv-latn-us", nvh: "nvh-latn-vu", nvm: "nvm-latn-pg", nvo: "nvo-latn-cm", nwb: "nwb-latn-zz", nwc: "nwc-newa-np", "nwc-brah": "nwc-brah-np", "nwc-deva": "nwc-deva-np", "nwc-sidd": "nwc-sidd-np", nwe: "nwe-latn-cm", nwg: "nwg-latn-au", nwi: "nwi-latn-vu", nwm: "nwm-latn-ss", nwo: "nwo-latn-au", nwr: "nwr-latn-pg", nww: "nww-latn-tz", nwx: "nwx-deva-np", nxa: "nxa-latn-tl", nxd: "nxd-latn-cd", nxe: "nxe-latn-id", nxg: "nxg-latn-id", nxi: "nxi-latn-tz", nxl: "nxl-latn-id", nxn: "nxn-latn-au", nxo: "nxo-latn-ga", nxq: "nxq-latn-cn", nxr: "nxr-latn-zz", nxx: "nxx-latn-id", ny: "ny-latn-mw", nyb: "nyb-latn-gh", nyc: "nyc-latn-cd", nyd: "nyd-latn-ke", nye: "nye-latn-ao", nyf: "nyf-latn-ke", nyg: "nyg-latn-cd", nyh: "nyh-latn-au", nyi: "nyi-latn-sd", nyj: "nyj-latn-cd", nyk: "nyk-latn-ao", nyl: "nyl-thai-th", nym: "nym-latn-tz", nyn: "nyn-latn-ug", nyo: "nyo-latn-ug", nyp: "nyp-latn-ug", nyq: "nyq-arab-ir", nyr: "nyr-latn-mw", nys: "nys-latn-au", nyt: "nyt-latn-au", nyu: "nyu-latn-mz", nyv: "nyv-latn-au", nyx: "nyx-latn-au", nyy: "nyy-latn-tz", nza: "nza-latn-cm", nzb: "nzb-latn-ga", nzd: "nzd-latn-cd", nzi: "nzi-latn-gh", nzk: "nzk-latn-cf", nzm: "nzm-latn-in", nzu: "nzu-latn-cg", nzy: "nzy-latn-td", nzz: "nzz-latn-ml", oaa: "oaa-cyrl-ru", oac: "oac-cyrl-ru", oar: "oar-syrc-sy", oav: "oav-geor-ge", obi: "obi-latn-us", obk: "obk-latn-ph", obl: "obl-latn-cm", obm: "obm-phnx-jo", obo: "obo-latn-ph", obr: "obr-mymr-mm", obt: "obt-latn-fr", obu: "obu-latn-ng", oc: "oc-latn-fr", oca: "oca-latn-pe", oco: "oco-latn-gb", ocu: "ocu-latn-mx", oda: "oda-latn-ng", odk: "odk-arab-pk", odt: "odt-latn-nl", odu: "odu-latn-ng", ofu: "ofu-latn-ng", ogb: "ogb-latn-ng", ogc: "ogc-latn-zz", ogg: "ogg-latn-ng", ogo: "ogo-latn-ng", ogu: "ogu-latn-ng", oht: "oht-xsux-tr", oia: "oia-latn-id", oie: "oie-latn-ss", oin: "oin-latn-pg", oj: "oj-cans-ca", ojb: "ojb-latn-ca", "ojb-cans": "ojb-cans-ca", ojc: "ojc-latn-ca", ojs: "ojs-cans-ca", ojv: "ojv-latn-sb", ojw: "ojw-latn-ca", "ojw-cans": "ojw-cans-ca", oka: "oka-latn-ca", okb: "okb-latn-ng", okc: "okc-latn-cd", okd: "okd-latn-ng", oke: "oke-latn-ng", okg: "okg-latn-au", oki: "oki-latn-ke", okk: "okk-latn-pg", okm: "okm-hang-kr", oko: "oko-hani-kr", okr: "okr-latn-zz", oks: "oks-latn-ng", oku: "oku-latn-cm", okv: "okv-latn-zz", okx: "okx-latn-ng", okz: "okz-khmr-kh", ola: "ola-deva-np", "ola-tibt": "ola-tibt-cn", old: "old-latn-tz", ole: "ole-tibt-bt", olk: "olk-latn-au", olm: "olm-latn-ng", olo: "olo-latn-ru", olr: "olr-latn-vu", olt: "olt-latn-lt", olu: "olu-latn-ao", om: "om-latn-et", oma: "oma-latn-us", omb: "omb-latn-vu", omc: "omc-latn-pe", omg: "omg-latn-pe", omi: "omi-latn-cd", omk: "omk-cyrl-ru", oml: "oml-latn-cd", omo: "omo-latn-pg", omp: "omp-mtei-in", omr: "omr-modi-in", omt: "omt-latn-ke", omu: "omu-latn-pe", omw: "omw-latn-pg", ona: "ona-latn-ar", one: "one-latn-ca", ong: "ong-latn-zz", oni: "oni-latn-id", onj: "onj-latn-pg", onk: "onk-latn-pg", onn: "onn-latn-zz", ono: "ono-latn-ca", onp: "onp-latn-in", "onp-deva": "onp-deva-in", onr: "onr-latn-pg", ons: "ons-latn-zz", ont: "ont-latn-pg", onu: "onu-latn-vu", onx: "onx-latn-id", ood: "ood-latn-us", oon: "oon-deva-in", oor: "oor-latn-za", opa: "opa-latn-ng", opk: "opk-latn-id", opm: "opm-latn-zz", opo: "opo-latn-pg", opt: "opt-latn-mx", opy: "opy-latn-br", or: "or-orya-in", ora: "ora-latn-sb", orc: "orc-latn-ke", ore: "ore-latn-pe", org: "org-latn-ng", orn: "orn-latn-my", oro: "oro-latn-zz", orr: "orr-latn-ng", ors: "ors-latn-my", ort: "ort-telu-in", oru: "oru-arab-zz", orv: "orv-cyrl-ru", orw: "orw-latn-br", orx: "orx-latn-ng", orz: "orz-latn-id", os: "os-cyrl-ge", osa: "osa-osge-us", osc: "osc-ital-it", "osc-latn": "osc-latn-it", osi: "osi-java-id", oso: "oso-latn-ng", osp: "osp-latn-es", ost: "ost-latn-cm", osu: "osu-latn-pg", osx: "osx-latn-de", ota: "ota-arab-zz", otb: "otb-tibt-cn", otd: "otd-latn-id", ote: "ote-latn-mx", oti: "oti-latn-br", otk: "otk-orkh-mn", otl: "otl-latn-mx", otm: "otm-latn-mx", otn: "otn-latn-mx", otq: "otq-latn-mx", otr: "otr-latn-sd", ots: "ots-latn-mx", ott: "ott-latn-mx", otu: "otu-latn-br", otw: "otw-latn-ca", otx: "otx-latn-mx", oty: "oty-gran-in", otz: "otz-latn-mx", oub: "oub-latn-lr", oue: "oue-latn-pg", oui: "oui-ougr-143", oum: "oum-latn-pg", ovd: "ovd-latn-se", owi: "owi-latn-pg", owl: "owl-latn-gb", oyd: "oyd-latn-et", oym: "oym-latn-br", oyy: "oyy-latn-pg", ozm: "ozm-latn-zz", pa: "pa-guru-in", "pa-arab": "pa-arab-pk", "pa-pk": "pa-arab-pk", pab: "pab-latn-br", pac: "pac-latn-vn", pad: "pad-latn-br", pae: "pae-latn-cd", paf: "paf-latn-br", pag: "pag-latn-ph", pah: "pah-latn-br", pai: "pai-latn-ng", pak: "pak-latn-br", pal: "pal-phli-ir", "pal-phlp": "pal-phlp-cn", pam: "pam-latn-ph", pao: "pao-latn-us", pap: "pap-latn-cw", paq: "paq-cyrl-tj", par: "par-latn-us", pas: "pas-latn-id", pau: "pau-latn-pw", pav: "pav-latn-br", paw: "paw-latn-us", pax: "pax-latn-br", pay: "pay-latn-hn", paz: "paz-latn-br", pbb: "pbb-latn-co", pbc: "pbc-latn-gy", pbe: "pbe-latn-mx", pbf: "pbf-latn-mx", pbg: "pbg-latn-ve", pbh: "pbh-latn-ve", pbi: "pbi-latn-zz", pbl: "pbl-latn-ng", pbm: "pbm-latn-mx", pbn: "pbn-latn-ng", pbo: "pbo-latn-gw", pbp: "pbp-latn-gn", pbr: "pbr-latn-tz", pbs: "pbs-latn-mx", pbt: "pbt-arab-af", pbv: "pbv-latn-in", pby: "pby-latn-pg", pca: "pca-latn-mx", pcb: "pcb-khmr-kh", pcc: "pcc-latn-cn", "pcc-hani": "pcc-hani-cn", pcd: "pcd-latn-fr", pce: "pce-mymr-mm", "pce-thai": "pce-thai-th", pcf: "pcf-mlym-in", pcg: "pcg-mlym-in", "pcg-knda": "pcg-knda-in", "pcg-taml": "pcg-taml-in", pch: "pch-deva-in", pci: "pci-deva-in", "pci-orya": "pci-orya-in", pcj: "pcj-telu-in", pck: "pck-latn-in", pcm: "pcm-latn-ng", pcn: "pcn-latn-ng", pcp: "pcp-latn-bo", pcw: "pcw-latn-ng", pda: "pda-latn-pg", pdc: "pdc-latn-us", pdn: "pdn-latn-id", pdo: "pdo-latn-id", pdt: "pdt-latn-ca", pdu: "pdu-latn-mm", "pdu-mymr": "pdu-mymr-mm", pea: "pea-latn-id", peb: "peb-latn-us", ped: "ped-latn-zz", pee: "pee-latn-id", peg: "peg-orya-in", pei: "pei-latn-mx", pek: "pek-latn-pg", pel: "pel-latn-id", pem: "pem-latn-cd", peo: "peo-xpeo-ir", pep: "pep-latn-pg", peq: "peq-latn-us", pev: "pev-latn-ve", pex: "pex-latn-zz", pey: "pey-latn-id", pez: "pez-latn-my", pfa: "pfa-latn-fm", pfe: "pfe-latn-cm", pfl: "pfl-latn-de", pga: "pga-latn-ss", pgd: "pgd-khar-pk", pgg: "pgg-deva-in", pgi: "pgi-latn-pg", pgk: "pgk-latn-vu", pgl: "pgl-ogam-ie", pgn: "pgn-ital-it", pgs: "pgs-latn-ng", pgu: "pgu-latn-id", phd: "phd-deva-in", phg: "phg-latn-vn", phh: "phh-latn-vn", phk: "phk-mymr-in", phl: "phl-arab-zz", phm: "phm-latn-mz", phn: "phn-phnx-lb", pho: "pho-laoo-la", phr: "phr-arab-pk", pht: "pht-thai-th", phv: "phv-arab-af", phw: "phw-deva-np", pi: "pi-sinh-in", "pi-brah": "pi-brah-in", "pi-deva": "pi-deva-in", "pi-khar": "pi-khar-in", "pi-khmr": "pi-khmr-in", "pi-mymr": "pi-mymr-in", "pi-thai": "pi-thai-in", pia: "pia-latn-mx", pib: "pib-latn-pe", pic: "pic-latn-ga", pid: "pid-latn-ve", pif: "pif-latn-fm", pig: "pig-latn-pe", pih: "pih-latn-nf", pij: "pij-latn-co", pil: "pil-latn-zz", pim: "pim-latn-us", pin: "pin-latn-pg", pio: "pio-latn-co", pip: "pip-latn-zz", pir: "pir-latn-br", pis: "pis-latn-sb", pit: "pit-latn-au", piu: "piu-latn-au", piv: "piv-latn-sb", piw: "piw-latn-tz", pix: "pix-latn-pg", piy: "piy-latn-ng", piz: "piz-latn-nc", pjt: "pjt-latn-au", pka: "pka-brah-in", pkb: "pkb-latn-ke", pkg: "pkg-latn-pg", pkh: "pkh-latn-bd", "pkh-deva": "pkh-deva-bd", pkn: "pkn-latn-au", pko: "pko-latn-ke", pkp: "pkp-latn-ck", pkr: "pkr-mlym-in", pku: "pku-latn-id", pl: "pl-latn-pl", pla: "pla-latn-zz", plb: "plb-latn-vu", plc: "plc-latn-ph", pld: "pld-latn-gb", ple: "ple-latn-id", plg: "plg-latn-ar", plh: "plh-latn-id", plj: "plj-latn-ng", plk: "plk-arab-pk", pll: "pll-mymr-mm", pln: "pln-latn-co", plo: "plo-latn-mx", plr: "plr-latn-ci", pls: "pls-latn-mx", plu: "plu-latn-br", plv: "plv-latn-ph", plw: "plw-latn-ph", plz: "plz-latn-my", pma: "pma-latn-vu", pmb: "pmb-latn-cd", pmd: "pmd-latn-au", pme: "pme-latn-nc", pmf: "pmf-latn-id", pmh: "pmh-brah-in", pmi: "pmi-latn-cn", pmj: "pmj-latn-cn", pml: "pml-latn-tn", pmm: "pmm-latn-cm", pmn: "pmn-latn-cm", pmo: "pmo-latn-id", pmq: "pmq-latn-mx", pmr: "pmr-latn-pg", pms: "pms-latn-it", pmt: "pmt-latn-pf", pmw: "pmw-latn-us", pmx: "pmx-latn-in", pmy: "pmy-latn-id", pmz: "pmz-latn-mx", pna: "pna-latn-my", pnc: "pnc-latn-id", pnd: "pnd-latn-ao", pne: "pne-latn-my", png: "png-latn-zz", pnh: "pnh-latn-ck", pni: "pni-latn-id", pnj: "pnj-latn-au", pnk: "pnk-latn-bo", pnl: "pnl-latn-bf", pnm: "pnm-latn-my", pnn: "pnn-latn-zz", pno: "pno-latn-pe", pnp: "pnp-latn-id", pnq: "pnq-latn-bf", pnr: "pnr-latn-pg", pns: "pns-latn-id", pnt: "pnt-grek-gr", pnv: "pnv-latn-au", pnw: "pnw-latn-au", pny: "pny-latn-cm", pnz: "pnz-latn-cf", poc: "poc-latn-gt", poe: "poe-latn-mx", pof: "pof-latn-cd", pog: "pog-latn-br", poh: "poh-latn-gt", poi: "poi-latn-mx", pok: "pok-latn-br", pom: "pom-latn-us", pon: "pon-latn-fm", poo: "poo-latn-us", pop: "pop-latn-nc", poq: "poq-latn-mx", pos: "pos-latn-mx", pot: "pot-latn-us", pov: "pov-latn-gw", pow: "pow-latn-mx", poy: "poy-latn-tz", ppa: "ppa-deva-in", ppe: "ppe-latn-pg", ppi: "ppi-latn-mx", ppk: "ppk-latn-id", ppl: "ppl-latn-sv", ppm: "ppm-latn-id", ppn: "ppn-latn-pg", ppo: "ppo-latn-zz", ppp: "ppp-latn-cd", ppq: "ppq-latn-pg", pps: "pps-latn-mx", ppt: "ppt-latn-pg", pqa: "pqa-latn-ng", pqm: "pqm-latn-ca", pra: "pra-khar-pk", prc: "prc-arab-af", prd: "prd-arab-ir", pre: "pre-latn-st", prf: "prf-latn-ph", prg: "prg-latn-001", prh: "prh-latn-ph", pri: "pri-latn-nc", prk: "prk-latn-mm", prm: "prm-latn-pg", pro: "pro-latn-fr", prp: "prp-gujr-in", prq: "prq-latn-pe", prr: "prr-latn-br", prt: "prt-thai-th", pru: "pru-latn-id", prw: "prw-latn-pg", prx: "prx-arab-in", "prx-tibt": "prx-tibt-in", ps: "ps-arab-af", psa: "psa-latn-id", pse: "pse-latn-id", psh: "psh-arab-af", psi: "psi-arab-af", psm: "psm-latn-bo", psn: "psn-latn-id", psq: "psq-latn-pg", pss: "pss-latn-zz", pst: "pst-arab-pk", psw: "psw-latn-vu", pt: "pt-latn-br", pta: "pta-latn-py", pth: "pth-latn-br", pti: "pti-latn-au", ptn: "ptn-latn-id", pto: "pto-latn-br", ptp: "ptp-latn-zz", ptr: "ptr-latn-vu", ptt: "ptt-latn-id", ptu: "ptu-latn-id", ptv: "ptv-latn-vu", pua: "pua-latn-mx", pub: "pub-latn-in", puc: "puc-latn-id", pud: "pud-latn-id", pue: "pue-latn-ar", puf: "puf-latn-id", pug: "pug-latn-bf", pui: "pui-latn-co", puj: "puj-latn-id", pum: "pum-deva-np", puo: "puo-latn-vn", pup: "pup-latn-pg", puq: "puq-latn-pe", pur: "pur-latn-br", put: "put-latn-id", puu: "puu-latn-ga", puw: "puw-latn-fm", pux: "pux-latn-pg", puy: "puy-latn-us", pwa: "pwa-latn-zz", pwb: "pwb-latn-ng", pwg: "pwg-latn-pg", pwm: "pwm-latn-ph", pwn: "pwn-latn-tw", pwo: "pwo-mymr-mm", pwr: "pwr-deva-in", pww: "pww-thai-th", pxm: "pxm-latn-mx", pye: "pye-latn-ci", pym: "pym-latn-ng", pyn: "pyn-latn-br", pyu: "pyu-latn-tw", "pyu-hani": "pyu-hani-tw", pyx: "pyx-mymr-mm", pyy: "pyy-latn-mm", pzh: "pzh-latn-tw", pzn: "pzn-latn-mm", qu: "qu-latn-pe", qua: "qua-latn-us", qub: "qub-latn-pe", quc: "quc-latn-gt", qud: "qud-latn-ec", quf: "quf-latn-pe", qug: "qug-latn-ec", qui: "qui-latn-us", quk: "quk-latn-pe", qul: "qul-latn-bo", qum: "qum-latn-gt", qun: "qun-latn-us", qup: "qup-latn-pe", quq: "quq-latn-es", qur: "qur-latn-pe", qus: "qus-latn-ar", quv: "quv-latn-gt", quw: "quw-latn-ec", qux: "qux-latn-pe", quy: "quy-latn-pe", qva: "qva-latn-pe", qvc: "qvc-latn-pe", qve: "qve-latn-pe", qvh: "qvh-latn-pe", qvi: "qvi-latn-ec", qvj: "qvj-latn-ec", qvl: "qvl-latn-pe", qvm: "qvm-latn-pe", qvn: "qvn-latn-pe", qvo: "qvo-latn-pe", qvp: "qvp-latn-pe", qvs: "qvs-latn-pe", qvw: "qvw-latn-pe", qvz: "qvz-latn-ec", qwa: "qwa-latn-pe", qwc: "qwc-latn-pe", qwh: "qwh-latn-pe", qwm: "qwm-latn-ru", "qwm-cyrl": "qwm-cyrl-ru", "qwm-runr": "qwm-runr-ru", qws: "qws-latn-pe", qwt: "qwt-latn-us", qxa: "qxa-latn-pe", qxc: "qxc-latn-pe", qxh: "qxh-latn-pe", qxl: "qxl-latn-ec", qxn: "qxn-latn-pe", qxo: "qxo-latn-pe", qxp: "qxp-latn-pe", qxq: "qxq-arab-ir", qxr: "qxr-latn-ec", qxt: "qxt-latn-pe", qxu: "qxu-latn-pe", qxw: "qxw-latn-pe", qya: "qya-latn-001", qyp: "qyp-latn-us", raa: "raa-deva-np", rab: "rab-deva-np", rac: "rac-latn-id", rad: "rad-latn-vn", raf: "raf-deva-np", rag: "rag-latn-ke", rah: "rah-beng-in", "rah-latn": "rah-latn-in", rai: "rai-latn-zz", raj: "raj-deva-in", rak: "rak-latn-pg", ram: "ram-latn-br", ran: "ran-latn-id", rao: "rao-latn-zz", rap: "rap-latn-cl", rar: "rar-latn-ck", rav: "rav-deva-np", raw: "raw-latn-mm", rax: "rax-latn-ng", ray: "ray-latn-pf", raz: "raz-latn-id", rbb: "rbb-mymr-mm", rbk: "rbk-latn-ph", rbl: "rbl-latn-ph", rbp: "rbp-latn-au", rcf: "rcf-latn-re", rdb: "rdb-arab-ir", rea: "rea-latn-pg", reb: "reb-latn-id", ree: "ree-latn-my", reg: "reg-latn-tz", rei: "rei-orya-in", "rei-telu": "rei-telu-in", rej: "rej-latn-id", rel: "rel-latn-zz", rem: "rem-latn-pe", ren: "ren-latn-vn", res: "res-latn-zz", ret: "ret-latn-id", rey: "rey-latn-bo", rga: "rga-latn-vu", rgn: "rgn-latn-it", rgr: "rgr-latn-pe", rgs: "rgs-latn-vn", rgu: "rgu-latn-id", rhg: "rhg-rohg-mm", rhp: "rhp-latn-pg", ria: "ria-latn-in", rif: "rif-latn-ma", ril: "ril-latn-mm", rim: "rim-latn-tz", rin: "rin-latn-ng", rir: "rir-latn-id", rit: "rit-latn-au", riu: "riu-latn-id", rjg: "rjg-latn-id", rji: "rji-deva-np", rjs: "rjs-deva-np", rka: "rka-khmr-kh", rkb: "rkb-latn-br", rkh: "rkh-latn-ck", rki: "rki-mymr-mm", rkm: "rkm-latn-bf", rkt: "rkt-beng-bd", rkw: "rkw-latn-au", rm: "rm-latn-ch", rma: "rma-latn-ni", rmb: "rmb-latn-au", rmc: "rmc-latn-sk", rmd: "rmd-latn-dk", rme: "rme-latn-gb", rmf: "rmf-latn-fi", rmg: "rmg-latn-no", rmh: "rmh-latn-id", rmi: "rmi-armn-am", rmk: "rmk-latn-pg", rml: "rml-latn-pl", "rml-cyrl": "rml-cyrl-by", rmm: "rmm-latn-id", rmn: "rmn-latn-rs", "rmn-cyrl": "rmn-cyrl-bg", "rmn-grek": "rmn-grek-gr", rmo: "rmo-latn-ch", rmp: "rmp-latn-pg", rmq: "rmq-latn-es", rmt: "rmt-arab-ir", rmu: "rmu-latn-se", rmw: "rmw-latn-gb", rmx: "rmx-latn-vn", rmz: "rmz-mymr-in", rn: "rn-latn-bi", rna: "rna-latn-zz", rnd: "rnd-latn-cd", rng: "rng-latn-mz", rnl: "rnl-latn-in", rnn: "rnn-latn-id", rnr: "rnr-latn-au", rnw: "rnw-latn-tz", ro: "ro-latn-ro", rob: "rob-latn-id", roc: "roc-latn-vn", rod: "rod-latn-ng", roe: "roe-latn-pg", rof: "rof-latn-tz", rog: "rog-latn-vn", rol: "rol-latn-ph", rom: "rom-latn-ro", "rom-cyrl": "rom-cyrl-ro", roo: "roo-latn-zz", rop: "rop-latn-au", ror: "ror-latn-id", rou: "rou-latn-td", row: "row-latn-id", rpn: "rpn-latn-vu", rpt: "rpt-latn-pg", rri: "rri-latn-sb", rro: "rro-latn-zz", rrt: "rrt-latn-au", rsk: "rsk-cyrl-rs", rtc: "rtc-latn-mm", rth: "rth-latn-id", rtm: "rtm-latn-fj", rtw: "rtw-deva-in", ru: "ru-cyrl-ru", rub: "rub-latn-ug", ruc: "ruc-latn-ug", rue: "rue-cyrl-ua", ruf: "ruf-latn-tz", rug: "rug-latn-sb", rui: "rui-latn-tz", ruk: "ruk-latn-ng", ruo: "ruo-latn-hr", rup: "rup-latn-ro", "rup-grek": "rup-grek-gr", ruq: "ruq-latn-gr", rut: "rut-cyrl-ru", "rut-latn": "rut-latn-az", ruu: "ruu-latn-my", ruy: "ruy-latn-ng", ruz: "ruz-latn-ng", rw: "rw-latn-rw", rwa: "rwa-latn-pg", rwk: "rwk-latn-tz", rwl: "rwl-latn-tz", rwm: "rwm-latn-ug", rwo: "rwo-latn-zz", rwr: "rwr-deva-in", rxd: "rxd-latn-au", rxw: "rxw-latn-au", ryu: "ryu-kana-jp", sa: "sa-deva-in", saa: "saa-latn-td", sab: "sab-latn-pa", sac: "sac-latn-us", sad: "sad-latn-tz", sae: "sae-latn-br", saf: "saf-latn-gh", sah: "sah-cyrl-ru", saj: "saj-latn-id", sak: "sak-latn-ga", sam: "sam-samr-ps", "sam-hebr": "sam-hebr-ps", "sam-syrc": "sam-syrc-ps", sao: "sao-latn-id", saq: "saq-latn-ke", sar: "sar-latn-bo", sas: "sas-latn-id", sat: "sat-olck-in", sau: "sau-latn-id", sav: "sav-latn-sn", saw: "saw-latn-id", sax: "sax-latn-vu", say: "say-latn-ng", saz: "saz-saur-in", sba: "sba-latn-zz", sbb: "sbb-latn-sb", sbc: "sbc-latn-pg", sbd: "sbd-latn-bf", sbe: "sbe-latn-zz", sbg: "sbg-latn-id", sbh: "sbh-latn-pg", sbi: "sbi-latn-pg", sbj: "sbj-latn-td", sbk: "sbk-latn-tz", sbl: "sbl-latn-ph", sbm: "sbm-latn-tz", sbn: "sbn-arab-pk", sbo: "sbo-latn-my", sbp: "sbp-latn-tz", sbq: "sbq-latn-pg", sbr: "sbr-latn-id", sbs: "sbs-latn-na", sbt: "sbt-latn-id", sbu: "sbu-tibt-in", "sbu-deva": "sbu-deva-in", sbv: "sbv-latn-it", sbw: "sbw-latn-ga", sbx: "sbx-latn-id", sby: "sby-latn-zm", sbz: "sbz-latn-cf", sc: "sc-latn-it", scb: "scb-latn-vn", sce: "sce-latn-cn", "sce-arab": "sce-arab-cn", scf: "scf-latn-pa", scg: "scg-latn-id", sch: "sch-latn-in", sci: "sci-latn-lk", sck: "sck-deva-in", scl: "scl-arab-zz", scn: "scn-latn-it", sco: "sco-latn-gb", scp: "scp-deva-np", scs: "scs-latn-ca", "scs-cans": "scs-cans-ca", sct: "sct-laoo-la", scu: "scu-takr-in", scv: "scv-latn-ng", scw: "scw-latn-ng", scx: "scx-grek-it", sd: "sd-arab-pk", "sd-deva": "sd-deva-in", "sd-in": "sd-deva-in", "sd-khoj": "sd-khoj-in", "sd-sind": "sd-sind-in", sda: "sda-latn-id", sdb: "sdb-arab-iq", sdc: "sdc-latn-it", sde: "sde-latn-ng", sdf: "sdf-arab-iq", sdg: "sdg-arab-af", sdh: "sdh-arab-ir", sdj: "sdj-latn-cg", sdk: "sdk-latn-pg", sdn: "sdn-latn-it", sdo: "sdo-latn-my", sdq: "sdq-latn-id", sds: "sds-arab-tn", sdu: "sdu-latn-id", sdx: "sdx-latn-my", se: "se-latn-no", sea: "sea-latn-my", seb: "seb-latn-ci", sec: "sec-latn-ca", sed: "sed-latn-vn", see: "see-latn-us", sef: "sef-latn-ci", seg: "seg-latn-tz", seh: "seh-latn-mz", sei: "sei-latn-mx", sej: "sej-latn-pg", sek: "sek-latn-ca", "sek-cans": "sek-cans-ca", sel: "sel-cyrl-ru", sen: "sen-latn-bf", seo: "seo-latn-pg", sep: "sep-latn-bf", seq: "seq-latn-bf", ser: "ser-latn-us", ses: "ses-latn-ml", set: "set-latn-id", seu: "seu-latn-id", sev: "sev-latn-ci", sew: "sew-latn-pg", sey: "sey-latn-ec", sez: "sez-latn-mm", sfe: "sfe-latn-ph", sfm: "sfm-plrd-cn", sfw: "sfw-latn-gh", sg: "sg-latn-cf", sga: "sga-ogam-ie", sgb: "sgb-latn-ph", sgc: "sgc-latn-ke", sgd: "sgd-latn-ph", sge: "sge-latn-id", sgh: "sgh-cyrl-tj", "sgh-arab": "sgh-arab-af", "sgh-latn": "sgh-latn-tj", sgi: "sgi-latn-cm", sgj: "sgj-deva-in", sgm: "sgm-latn-ke", sgp: "sgp-latn-in", sgr: "sgr-arab-ir", sgs: "sgs-latn-lt", sgt: "sgt-tibt-bt", sgu: "sgu-latn-id", sgw: "sgw-ethi-zz", sgy: "sgy-arab-af", sgz: "sgz-latn-zz", sha: "sha-latn-ng", shb: "shb-latn-br", shc: "shc-latn-cd", shd: "shd-arab-pk", she: "she-latn-et", shg: "shg-latn-bw", shh: "shh-latn-us", shi: "shi-tfng-ma", shj: "shj-latn-sd", shk: "shk-latn-zz", shm: "shm-arab-ir", shn: "shn-mymr-mm", sho: "sho-latn-ng", shp: "shp-latn-pe", shq: "shq-latn-zm", shr: "shr-latn-cd", shs: "shs-latn-ca", sht: "sht-latn-us", shu: "shu-arab-zz", shv: "shv-arab-om", shw: "shw-latn-sd", shy: "shy-latn-dz", "shy-arab": "shy-arab-dz", "shy-tfng": "shy-tfng-dz", shz: "shz-latn-ml", si: "si-sinh-lk", sia: "sia-cyrl-ru", sib: "sib-latn-my", sid: "sid-latn-et", sie: "sie-latn-zm", sif: "sif-latn-bf", sig: "sig-latn-zz", sih: "sih-latn-nc", sii: "sii-latn-in", sij: "sij-latn-pg", sik: "sik-latn-br", sil: "sil-latn-zz", sim: "sim-latn-zz", sip: "sip-tibt-in", siq: "siq-latn-pg", sir: "sir-latn-ng", sis: "sis-latn-us", siu: "siu-latn-pg", siv: "siv-latn-pg", siw: "siw-latn-pg", six: "six-latn-pg", siy: "siy-arab-ir", siz: "siz-arab-eg", sja: "sja-latn-co", sjb: "sjb-latn-id", sjd: "sjd-cyrl-ru", sje: "sje-latn-se", sjg: "sjg-latn-td", sjl: "sjl-latn-in", sjm: "sjm-latn-ph", sjp: "sjp-deva-in", "sjp-beng": "sjp-beng-in", sjr: "sjr-latn-zz", sjt: "sjt-cyrl-ru", sju: "sju-latn-se", sjw: "sjw-latn-us", sk: "sk-latn-sk", ska: "ska-latn-us", skb: "skb-thai-th", skc: "skc-latn-zz", skd: "skd-latn-us", ske: "ske-latn-vu", skf: "skf-latn-br", skg: "skg-latn-mg", skh: "skh-latn-id", ski: "ski-latn-id", skj: "skj-deva-np", skm: "skm-latn-pg", skn: "skn-latn-ph", sko: "sko-latn-id", skp: "skp-latn-my", skq: "skq-latn-bf", skr: "skr-arab-pk", sks: "sks-latn-zz", skt: "skt-latn-cd", sku: "sku-latn-vu", skv: "skv-latn-id", skw: "skw-latn-gy", skx: "skx-latn-id", sky: "sky-latn-sb", skz: "skz-latn-id", sl: "sl-latn-si", slc: "slc-latn-co", sld: "sld-latn-zz", slg: "slg-latn-id", slh: "slh-latn-us", sli: "sli-latn-pl", slj: "slj-latn-br", sll: "sll-latn-zz", slm: "slm-latn-ph", sln: "sln-latn-us", slp: "slp-latn-id", slq: "slq-arab-ir", slr: "slr-latn-cn", slu: "slu-latn-id", slw: "slw-latn-pg", slx: "slx-latn-cd", sly: "sly-latn-id", slz: "slz-latn-id", sm: "sm-latn-ws", sma: "sma-latn-se", smb: "smb-latn-pg", smc: "smc-latn-pg", smd: "smd-latn-ao", smf: "smf-latn-pg", smg: "smg-latn-pg", smh: "smh-yiii-cn", smj: "smj-latn-se", smk: "smk-latn-ph", sml: "sml-latn-ph", smn: "smn-latn-fi", smp: "smp-samr-il", smq: "smq-latn-zz", smr: "smr-latn-id", sms: "sms-latn-fi", smt: "smt-latn-in", smu: "smu-khmr-kh", smw: "smw-latn-id", smx: "smx-latn-cd", smy: "smy-arab-ir", smz: "smz-latn-pg", sn: "sn-latn-zw", snb: "snb-latn-my", snc: "snc-latn-zz", sne: "sne-latn-my", snf: "snf-latn-sn", sng: "sng-latn-cd", "sng-brai": "sng-brai-cd", sni: "sni-latn-pe", snj: "snj-latn-cf", snk: "snk-latn-ml", snl: "snl-latn-ph", snm: "snm-latn-ug", snn: "snn-latn-co", sno: "sno-latn-us", snp: "snp-latn-zz", snq: "snq-latn-ga", snr: "snr-latn-pg", sns: "sns-latn-vu", snu: "snu-latn-id", snv: "snv-latn-my", snw: "snw-latn-gh", snx: "snx-latn-zz", sny: "sny-latn-zz", snz: "snz-latn-pg", so: "so-latn-so", soa: "soa-tavt-th", "soa-thai": "soa-thai-th", sob: "sob-latn-id", soc: "soc-latn-cd", sod: "sod-latn-cd", soe: "soe-latn-cd", sog: "sog-sogd-uz", soi: "soi-deva-np", sok: "sok-latn-zz", sol: "sol-latn-pg", soo: "soo-latn-cd", sop: "sop-latn-cd", soq: "soq-latn-zz", sor: "sor-latn-td", sos: "sos-latn-bf", sou: "sou-thai-th", sov: "sov-latn-pw", sow: "sow-latn-pg", sox: "sox-latn-cm", soy: "soy-latn-zz", soz: "soz-latn-tz", spb: "spb-latn-id", spc: "spc-latn-ve", spd: "spd-latn-zz", spe: "spe-latn-pg", spg: "spg-latn-my", spi: "spi-latn-id", spk: "spk-latn-pg", spl: "spl-latn-zz", spm: "spm-latn-pg", spn: "spn-latn-py", spo: "spo-latn-us", spp: "spp-latn-ml", spq: "spq-latn-pe", spr: "spr-latn-id", sps: "sps-latn-zz", spt: "spt-tibt-in", spv: "spv-orya-in", sq: "sq-latn-al", sqa: "sqa-latn-ng", sqh: "sqh-latn-ng", sqm: "sqm-latn-cf", sqo: "sqo-arab-ir", sqq: "sqq-laoo-la", sqt: "sqt-arab-ye", "sqt-latn": "sqt-latn-ye", squ: "squ-latn-ca", sr: "sr-cyrl-rs", "sr-me": "sr-latn-me", "sr-ro": "sr-latn-ro", "sr-ru": "sr-latn-ru", "sr-tr": "sr-latn-tr", sra: "sra-latn-pg", srb: "srb-sora-in", sre: "sre-latn-id", srf: "srf-latn-pg", srg: "srg-latn-ph", srh: "srh-arab-cn", sri: "sri-latn-co", srk: "srk-latn-my", srl: "srl-latn-id", srm: "srm-latn-sr", srn: "srn-latn-sr", sro: "sro-latn-it", srq: "srq-latn-bo", srr: "srr-latn-sn", srs: "srs-latn-ca", srt: "srt-latn-id", sru: "sru-latn-br", srv: "srv-latn-ph", srw: "srw-latn-id", srx: "srx-deva-in", sry: "sry-latn-pg", srz: "srz-arab-ir", ss: "ss-latn-za", ssb: "ssb-latn-ph", ssc: "ssc-latn-tz", ssd: "ssd-latn-zz", sse: "sse-latn-ph", "sse-arab": "sse-arab-ph", ssf: "ssf-latn-tw", ssg: "ssg-latn-zz", ssh: "ssh-arab-ae", ssj: "ssj-latn-pg", ssl: "ssl-latn-gh", ssm: "ssm-latn-my", ssn: "ssn-latn-ke", sso: "sso-latn-pg", ssq: "ssq-latn-id", sss: "sss-laoo-la", "sss-thai": "sss-thai-th", sst: "sst-latn-pg", ssu: "ssu-latn-pg", ssv: "ssv-latn-vu", ssx: "ssx-latn-pg", ssy: "ssy-latn-er", ssz: "ssz-latn-pg", st: "st-latn-za", sta: "sta-latn-zm", stb: "stb-latn-ph", ste: "ste-latn-id", stf: "stf-latn-pg", stg: "stg-latn-vn", sth: "sth-latn-ie", sti: "sti-latn-vn", "sti-kh": "sti-latn-kh", stj: "stj-latn-bf", stk: "stk-latn-zz", stl: "stl-latn-nl", stm: "stm-latn-pg", stn: "stn-latn-sb", sto: "sto-latn-ca", stp: "stp-latn-mx", stq: "stq-latn-de", str: "str-latn-ca", sts: "sts-arab-af", stt: "stt-latn-vn", stv: "stv-ethi-et", "stv-arab": "stv-arab-et", stw: "stw-latn-fm", sty: "sty-cyrl-ru", su: "su-latn-id", sua: "sua-latn-zz", sub: "sub-latn-cd", suc: "suc-latn-ph", sue: "sue-latn-zz", sug: "sug-latn-pg", sui: "sui-latn-pg", suj: "suj-latn-tz", suk: "suk-latn-tz", suo: "suo-latn-pg", suq: "suq-latn-et", "suq-ethi": "suq-ethi-et", sur: "sur-latn-zz", sus: "sus-latn-gn", sut: "sut-latn-ni", suv: "suv-latn-in", "suv-beng": "suv-beng-in", "suv-deva": "suv-deva-in", suw: "suw-latn-tz", suy: "suy-latn-br", suz: "suz-deva-np", sv: "sv-latn-se", sva: "sva-geor-ge", "sva-cyrl": "sva-cyrl-ge", "sva-latn": "sva-latn-ge", svb: "svb-latn-pg", svc: "svc-latn-vc", sve: "sve-latn-id", svm: "svm-latn-it", svs: "svs-latn-sb", sw: "sw-latn-tz", swb: "swb-arab-yt", swc: "swc-latn-cd", swf: "swf-latn-cd", swg: "swg-latn-de", swi: "swi-hani-cn", swj: "swj-latn-ga", swk: "swk-latn-mw", swm: "swm-latn-pg", swo: "swo-latn-br", swp: "swp-latn-zz", swq: "swq-latn-cm", swr: "swr-latn-id", sws: "sws-latn-id", swt: "swt-latn-id", swu: "swu-latn-id", swv: "swv-deva-in", sww: "sww-latn-vu", swx: "swx-latn-br", swy: "swy-latn-td", sxb: "sxb-latn-ke", sxe: "sxe-latn-ga", sxn: "sxn-latn-id", sxr: "sxr-latn-tw", sxs: "sxs-latn-ng", sxu: "sxu-latn-de", "sxu-runr": "sxu-runr-de", sxw: "sxw-latn-zz", sya: "sya-latn-id", syb: "syb-latn-ph", syc: "syc-syrc-tr", syi: "syi-latn-ga", syk: "syk-latn-ng", syl: "syl-beng-bd", sym: "sym-latn-bf", syn: "syn-syrc-ir", syo: "syo-latn-kh", syr: "syr-syrc-iq", sys: "sys-latn-td", syw: "syw-deva-np", syx: "syx-latn-ga", sza: "sza-latn-my", szb: "szb-latn-id", szc: "szc-latn-my", szd: "szd-latn-my", szg: "szg-latn-cd", szl: "szl-latn-pl", szn: "szn-latn-id", szp: "szp-latn-id", szv: "szv-latn-cm", szw: "szw-latn-id", szy: "szy-latn-tw", ta: "ta-taml-in", taa: "taa-latn-us", tab: "tab-cyrl-ru", tac: "tac-latn-mx", tad: "tad-latn-id", tae: "tae-latn-br", taf: "taf-latn-br", tag: "tag-latn-sd", taj: "taj-deva-np", tak: "tak-latn-ng", tal: "tal-latn-zz", tan: "tan-latn-zz", tao: "tao-latn-tw", tap: "tap-latn-cd", taq: "taq-latn-zz", tar: "tar-latn-mx", tas: "tas-latn-vn", tau: "tau-latn-us", tav: "tav-latn-co", taw: "taw-latn-pg", tax: "tax-latn-td", tay: "tay-latn-tw", "tay-hans": "tay-hans-tw", "tay-hant": "tay-hant-tw", taz: "taz-latn-sd", tba: "tba-latn-br", tbc: "tbc-latn-zz", tbd: "tbd-latn-zz", tbe: "tbe-latn-sb", tbf: "tbf-latn-zz", tbg: "tbg-latn-zz", tbh: "tbh-latn-au", tbi: "tbi-latn-sd", tbj: "tbj-latn-pg", tbk: "tbk-tagb-ph", "tbk-hano": "tbk-hano-ph", "tbk-latn": "tbk-latn-ph", tbl: "tbl-latn-ph", tbm: "tbm-latn-cd", tbn: "tbn-latn-co", tbo: "tbo-latn-zz", tbp: "tbp-latn-id", tbs: "tbs-latn-pg", tbt: "tbt-latn-cd", tbu: "tbu-latn-mx", tbv: "tbv-latn-pg", tbw: "tbw-latn-ph", tbx: "tbx-latn-pg", tby: "tby-latn-id", tbz: "tbz-latn-zz", tca: "tca-latn-br", tcb: "tcb-latn-us", tcc: "tcc-latn-tz", tcd: "tcd-latn-gh", tce: "tce-latn-ca", tcf: "tcf-latn-mx", tcg: "tcg-latn-id", tch: "tch-latn-tc", tci: "tci-latn-zz", tck: "tck-latn-ga", tcm: "tcm-latn-id", tcn: "tcn-tibt-np", tco: "tco-mymr-mm", tcp: "tcp-latn-mm", tcq: "tcq-latn-id", tcs: "tcs-latn-au", tcu: "tcu-latn-mx", tcw: "tcw-latn-mx", tcx: "tcx-taml-in", tcy: "tcy-knda-in", tcz: "tcz-latn-in", tda: "tda-tfng-ne", "tda-arab": "tda-arab-ne", "tda-latn": "tda-latn-ne", tdb: "tdb-deva-in", "tdb-beng": "tdb-beng-in", "tdb-kthi": "tdb-kthi-in", tdc: "tdc-latn-co", tdd: "tdd-tale-cn", tde: "tde-latn-ml", tdg: "tdg-deva-np", tdh: "tdh-deva-np", tdi: "tdi-latn-id", tdj: "tdj-latn-id", tdk: "tdk-latn-ng", tdl: "tdl-latn-ng", tdm: "tdm-latn-gy", tdn: "tdn-latn-id", tdo: "tdo-latn-ng", tdq: "tdq-latn-ng", tdr: "tdr-latn-vn", tds: "tds-latn-id", tdt: "tdt-latn-tl", tdu: "tdu-latn-my", tdv: "tdv-latn-ng", tdx: "tdx-latn-mg", tdy: "tdy-latn-ph", te: "te-telu-in", tea: "tea-latn-my", teb: "teb-latn-ec", tec: "tec-latn-ke", ted: "ted-latn-zz", tee: "tee-latn-mx", teg: "teg-latn-ga", teh: "teh-latn-ar", tei: "tei-latn-pg", tek: "tek-latn-cd", tem: "tem-latn-sl", ten: "ten-latn-co", teo: "teo-latn-ug", tep: "tep-latn-mx", teq: "teq-latn-sd", ter: "ter-latn-br", tes: "tes-java-id", tet: "tet-latn-tl", teu: "teu-latn-ug", tev: "tev-latn-id", tew: "tew-latn-us", tex: "tex-latn-ss", tey: "tey-latn-sd", tfi: "tfi-latn-zz", tfn: "tfn-latn-us", tfo: "tfo-latn-id", tfr: "tfr-latn-pa", tft: "tft-latn-id", tg: "tg-cyrl-tj", "tg-arab": "tg-arab-pk", "tg-pk": "tg-arab-pk", tga: "tga-latn-ke", tgb: "tgb-latn-my", tgc: "tgc-latn-zz", tgd: "tgd-latn-ng", tge: "tge-deva-np", tgf: "tgf-tibt-bt", tgh: "tgh-latn-tt", tgi: "tgi-latn-pg", tgj: "tgj-latn-in", tgn: "tgn-latn-ph", tgo: "tgo-latn-zz", tgp: "tgp-latn-vu", tgq: "tgq-latn-my", tgs: "tgs-latn-vu", tgt: "tgt-latn-ph", "tgt-hano": "tgt-hano-ph", "tgt-tagb": "tgt-tagb-ph", tgu: "tgu-latn-zz", tgv: "tgv-latn-br", tgw: "tgw-latn-ci", tgx: "tgx-latn-ca", tgy: "tgy-latn-ss", tgz: "tgz-latn-au", th: "th-thai-th", thd: "thd-latn-au", the: "the-deva-np", thf: "thf-deva-np", thh: "thh-latn-mx", thi: "thi-tale-la", thk: "thk-latn-ke", thl: "thl-deva-np", thm: "thm-thai-th", thp: "thp-latn-ca", "thp-dupl": "thp-dupl-ca", thq: "thq-deva-np", thr: "thr-deva-np", ths: "ths-deva-np", tht: "tht-latn-ca", thu: "thu-latn-ss", thv: "thv-latn-dz", "thv-arab": "thv-arab-dz", "thv-tfng": "thv-tfng-dz", thy: "thy-latn-ng", thz: "thz-latn-ne", "thz-tfng": "thz-tfng-ne", ti: "ti-ethi-et", tic: "tic-latn-sd", tif: "tif-latn-zz", tig: "tig-ethi-er", tih: "tih-latn-my", tii: "tii-latn-cd", tij: "tij-deva-np", tik: "tik-latn-zz", til: "til-latn-us", tim: "tim-latn-zz", tin: "tin-cyrl-ru", tio: "tio-latn-zz", tip: "tip-latn-id", tiq: "tiq-latn-bf", tis: "tis-latn-ph", tit: "tit-latn-co", tiu: "tiu-latn-ph", tiv: "tiv-latn-ng", tiw: "tiw-latn-au", tix: "tix-latn-us", tiy: "tiy-latn-ph", tja: "tja-latn-lr", tjg: "tjg-latn-id", tji: "tji-latn-cn", tjj: "tjj-latn-au", tjl: "tjl-mymr-mm", tjn: "tjn-latn-ci", tjo: "tjo-arab-dz", tjp: "tjp-latn-au", tjs: "tjs-latn-cn", tju: "tju-latn-au", tjw: "tjw-latn-au", tk: "tk-latn-tm", tka: "tka-latn-br", tkb: "tkb-deva-in", tkd: "tkd-latn-tl", tke: "tke-latn-mz", tkf: "tkf-latn-br", tkg: "tkg-latn-mg", tkl: "tkl-latn-tk", tkp: "tkp-latn-sb", tkq: "tkq-latn-ng", tkr: "tkr-latn-az", tks: "tks-arab-ir", tkt: "tkt-deva-np", tku: "tku-latn-mx", tkv: "tkv-latn-pg", tkw: "tkw-latn-sb", tkx: "tkx-latn-id", tkz: "tkz-latn-vn", tl: "tl-latn-ph", tla: "tla-latn-mx", tlb: "tlb-latn-id", tlc: "tlc-latn-mx", tld: "tld-latn-id", tlf: "tlf-latn-zz", tlg: "tlg-latn-id", tli: "tli-latn-us", "tli-cyrl": "tli-cyrl-us", tlj: "tlj-latn-ug", tlk: "tlk-latn-id", tll: "tll-latn-cd", tlm: "tlm-latn-vu", tln: "tln-latn-id", tlp: "tlp-latn-mx", tlq: "tlq-latn-mm", tlr: "tlr-latn-sb", tls: "tls-latn-vu", tlt: "tlt-latn-id", tlu: "tlu-latn-id", tlv: "tlv-latn-id", tlx: "tlx-latn-zz", tly: "tly-latn-az", tma: "tma-latn-td", tmb: "tmb-latn-vu", tmc: "tmc-latn-td", tmd: "tmd-latn-pg", tme: "tme-latn-br", tmf: "tmf-latn-py", tmg: "tmg-latn-id", tmh: "tmh-latn-ne", tmi: "tmi-latn-vu", tmj: "tmj-latn-id", tmk: "tmk-deva-np", tml: "tml-latn-id", tmm: "tmm-latn-vn", tmn: "tmn-latn-id", tmo: "tmo-latn-my", tmq: "tmq-latn-pg", tmr: "tmr-syrc-il", tmt: "tmt-latn-vu", tmu: "tmu-latn-id", tmv: "tmv-latn-cd", tmw: "tmw-latn-my", tmy: "tmy-latn-zz", tmz: "tmz-latn-ve", tn: "tn-latn-za", tna: "tna-latn-bo", tnb: "tnb-latn-co", tnc: "tnc-latn-co", tnd: "tnd-latn-co", tng: "tng-latn-td", tnh: "tnh-latn-zz", tni: "tni-latn-id", tnk: "tnk-latn-vu", tnl: "tnl-latn-vu", tnm: "tnm-latn-id", tnn: "tnn-latn-vu", tno: "tno-latn-bo", tnp: "tnp-latn-vu", tnq: "tnq-latn-pr", tnr: "tnr-latn-sn", tns: "tns-latn-pg", tnt: "tnt-latn-id", tnv: "tnv-cakm-bd", tnw: "tnw-latn-id", tnx: "tnx-latn-sb", tny: "tny-latn-tz", to: "to-latn-to", tob: "tob-latn-ar", toc: "toc-latn-mx", tod: "tod-latn-gn", tof: "tof-latn-zz", tog: "tog-latn-mw", toh: "toh-latn-mz", toi: "toi-latn-zm", toj: "toj-latn-mx", tok: "tok-latn-001", tol: "tol-latn-us", tom: "tom-latn-id", too: "too-latn-mx", top: "top-latn-mx", toq: "toq-latn-zz", tor: "tor-latn-cd", tos: "tos-latn-mx", tou: "tou-latn-vn", tov: "tov-arab-ir", tow: "tow-latn-us", tox: "tox-latn-pw", toy: "toy-latn-id", toz: "toz-latn-cm", tpa: "tpa-latn-pg", tpc: "tpc-latn-mx", tpe: "tpe-latn-bd", "tpe-beng": "tpe-beng-bd", tpf: "tpf-latn-id", tpg: "tpg-latn-id", tpi: "tpi-latn-pg", tpj: "tpj-latn-py", tpk: "tpk-latn-br", tpl: "tpl-latn-mx", tpm: "tpm-latn-zz", tpn: "tpn-latn-br", tpp: "tpp-latn-mx", tpr: "tpr-latn-br", tpt: "tpt-latn-mx", tpu: "tpu-khmr-kh", tpv: "tpv-latn-mp", tpx: "tpx-latn-mx", tpy: "tpy-latn-br", tpz: "tpz-latn-zz", tqb: "tqb-latn-br", tql: "tql-latn-vu", tqm: "tqm-latn-pg", tqn: "tqn-latn-us", tqo: "tqo-latn-zz", tqp: "tqp-latn-pg", tqt: "tqt-latn-mx", tqu: "tqu-latn-sb", tqw: "tqw-latn-us", tr: "tr-latn-tr", tra: "tra-arab-af", trb: "trb-latn-pg", trc: "trc-latn-mx", tre: "tre-latn-id", trf: "trf-latn-tt", trg: "trg-hebr-il", trh: "trh-latn-pg", tri: "tri-latn-sr", trj: "trj-latn-td", trl: "trl-latn-gb", trm: "trm-arab-af", trn: "trn-latn-bo", tro: "tro-latn-in", trp: "trp-latn-in", "trp-beng": "trp-beng-in", trq: "trq-latn-mx", trr: "trr-latn-pe", trs: "trs-latn-mx", trt: "trt-latn-id", tru: "tru-latn-tr", trv: "trv-latn-tw", trw: "trw-arab-pk", trx: "trx-latn-my", try: "try-latn-in", trz: "trz-latn-br", ts: "ts-latn-za", tsa: "tsa-latn-cg", tsb: "tsb-latn-et", tsc: "tsc-latn-mz", tsd: "tsd-grek-gr", tsf: "tsf-deva-np", tsg: "tsg-latn-ph", tsh: "tsh-latn-cm", tsi: "tsi-latn-ca", tsj: "tsj-tibt-bt", tsl: "tsl-latn-vn", tsp: "tsp-latn-bf", tsr: "tsr-latn-vu", tst: "tst-latn-ml", tsu: "tsu-latn-tw", tsv: "tsv-latn-ga", tsw: "tsw-latn-zz", tsx: "tsx-latn-pg", tsz: "tsz-latn-mx", tt: "tt-cyrl-ru", ttb: "ttb-latn-ng", ttc: "ttc-latn-gt", ttd: "ttd-latn-zz", tte: "tte-latn-zz", ttf: "ttf-latn-cm", tth: "tth-laoo-la", tti: "tti-latn-id", ttj: "ttj-latn-ug", ttk: "ttk-latn-co", ttl: "ttl-latn-zm", ttm: "ttm-latn-ca", ttn: "ttn-latn-id", tto: "tto-laoo-la", ttp: "ttp-latn-id", ttr: "ttr-latn-zz", tts: "tts-thai-th", ttt: "ttt-latn-az", ttu: "ttu-latn-pg", ttv: "ttv-latn-pg", ttw: "ttw-latn-my", tty: "tty-latn-id", tua: "tua-latn-pg", tub: "tub-latn-us", tuc: "tuc-latn-pg", tud: "tud-latn-br", tue: "tue-latn-co", tuf: "tuf-latn-co", tug: "tug-latn-td", tuh: "tuh-latn-zz", tui: "tui-latn-cm", tuj: "tuj-latn-id", tul: "tul-latn-zz", tum: "tum-latn-mw", tun: "tun-latn-us", tuo: "tuo-latn-br", tuq: "tuq-latn-zz", tus: "tus-latn-ca", tuu: "tuu-latn-us", tuv: "tuv-latn-ke", tux: "tux-latn-br", tuy: "tuy-latn-ke", tuz: "tuz-latn-bf", tva: "tva-latn-sb", tvd: "tvd-latn-zz", tve: "tve-latn-id", tvk: "tvk-latn-vu", tvl: "tvl-latn-tv", tvm: "tvm-latn-id", tvn: "tvn-mymr-mm", tvo: "tvo-latn-id", tvs: "tvs-latn-ke", tvt: "tvt-latn-in", tvu: "tvu-latn-zz", tvw: "tvw-latn-id", tvx: "tvx-latn-tw", twa: "twa-latn-us", twb: "twb-latn-ph", twd: "twd-latn-nl", twe: "twe-latn-id", twf: "twf-latn-us", twg: "twg-latn-id", twh: "twh-latn-zz", twl: "twl-latn-mz", twm: "twm-deva-in", twn: "twn-latn-cm", two: "two-latn-bw", twp: "twp-latn-pg", twq: "twq-latn-ne", twr: "twr-latn-mx", twt: "twt-latn-br", twu: "twu-latn-id", tww: "tww-latn-pg", twx: "twx-latn-mz", twy: "twy-latn-id", txa: "txa-latn-my", txe: "txe-latn-id", txg: "txg-tang-cn", txi: "txi-latn-br", txj: "txj-latn-ng", txm: "txm-latn-id", txn: "txn-latn-id", txo: "txo-toto-in", txq: "txq-latn-id", txs: "txs-latn-id", txt: "txt-latn-id", txu: "txu-latn-br", txx: "txx-latn-my", txy: "txy-latn-mg", ty: "ty-latn-pf", tya: "tya-latn-zz", tye: "tye-latn-ng", tyh: "tyh-latn-vn", tyi: "tyi-latn-cg", tyj: "tyj-latn-vn", tyl: "tyl-latn-vn", tyn: "tyn-latn-id", typ: "typ-latn-au", tyr: "tyr-tavt-vn", tys: "tys-latn-vn", tyt: "tyt-latn-vn", "tyt-tavt": "tyt-tavt-vn", tyu: "tyu-latn-bw", tyv: "tyv-cyrl-ru", tyx: "tyx-latn-cg", tyy: "tyy-latn-ng", tyz: "tyz-latn-vn", tzh: "tzh-latn-mx", tzj: "tzj-latn-gt", tzl: "tzl-latn-001", tzm: "tzm-latn-ma", tzn: "tzn-latn-id", tzo: "tzo-latn-mx", tzx: "tzx-latn-pg", uam: "uam-latn-br", uar: "uar-latn-pg", uba: "uba-latn-ng", ubi: "ubi-latn-td", ubl: "ubl-latn-ph", ubr: "ubr-latn-pg", ubu: "ubu-latn-zz", uda: "uda-latn-ng", ude: "ude-cyrl-ru", udg: "udg-mlym-in", udi: "udi-aghb-ru", udj: "udj-latn-id", udl: "udl-latn-cm", udm: "udm-cyrl-ru", udu: "udu-latn-sd", ues: "ues-latn-id", ufi: "ufi-latn-pg", ug: "ug-arab-cn", "ug-cyrl": "ug-cyrl-kz", "ug-kz": "ug-cyrl-kz", "ug-mn": "ug-cyrl-mn", uga: "uga-ugar-sy", ugb: "ugb-latn-au", uge: "uge-latn-sb", ugh: "ugh-cyrl-ru", ugo: "ugo-thai-th", uha: "uha-latn-ng", uhn: "uhn-latn-id", uis: "uis-latn-pg", uiv: "uiv-latn-cm", uji: "uji-latn-ng", uk: "uk-cyrl-ua", uka: "uka-latn-id", ukg: "ukg-latn-pg", ukh: "ukh-latn-cf", uki: "uki-orya-in", ukk: "ukk-latn-mm", ukp: "ukp-latn-ng", ukq: "ukq-latn-ng", uku: "uku-latn-ng", ukv: "ukv-latn-ss", ukw: "ukw-latn-ng", uky: "uky-latn-au", ula: "ula-latn-ng", ulb: "ulb-latn-ng", ulc: "ulc-cyrl-ru", ule: "ule-latn-ar", ulf: "ulf-latn-id", uli: "uli-latn-fm", ulk: "ulk-latn-au", ulm: "ulm-latn-id", uln: "uln-latn-pg", ulu: "ulu-latn-id", ulw: "ulw-latn-ni", uma: "uma-latn-us", umb: "umb-latn-ao", umd: "umd-latn-au", umg: "umg-latn-au", umi: "umi-latn-my", umm: "umm-latn-ng", umn: "umn-latn-mm", umo: "umo-latn-br", ump: "ump-latn-au", umr: "umr-latn-au", ums: "ums-latn-id", una: "una-latn-pg", und: "en-latn-us", "und-002": "en-latn-ng", "und-003": "en-latn-us", "und-005": "pt-latn-br", "und-009": "en-latn-au", "und-011": "en-latn-ng", "und-013": "es-latn-mx", "und-014": "sw-latn-tz", "und-015": "ar-arab-eg", "und-017": "sw-latn-cd", "und-018": "en-latn-za", "und-019": "en-latn-us", "und-021": "en-latn-us", "und-029": "es-latn-cu", "und-030": "zh-hans-cn", "und-034": "hi-deva-in", "und-035": "id-latn-id", "und-039": "it-latn-it", "und-053": "en-latn-au", "und-054": "en-latn-pg", "und-057": "en-latn-gu", "und-061": "sm-latn-ws", "und-142": "zh-hans-cn", "und-143": "uz-latn-uz", "und-145": "ar-arab-sa", "und-150": "ru-cyrl-ru", "und-151": "ru-cyrl-ru", "und-154": "en-latn-gb", "und-155": "de-latn-de", "und-202": "en-latn-ng", "und-419": "es-latn-419", "und-ad": "ca-latn-ad", "und-adlm": "ff-adlm-gn", "und-ae": "ar-arab-ae", "und-af": "fa-arab-af", "und-aghb": "udi-aghb-ru", "und-ahom": "aho-ahom-in", "und-al": "sq-latn-al", "und-am": "hy-armn-am", "und-ao": "pt-latn-ao", "und-aq": "und-latn-aq", "und-ar": "es-latn-ar", "und-arab": "ar-arab-eg", "und-arab-cc": "ms-arab-cc", "und-arab-cn": "ug-arab-cn", "und-arab-gb": "ur-arab-gb", "und-arab-id": "ms-arab-id", "und-arab-in": "ur-arab-in", "und-arab-kh": "cja-arab-kh", "und-arab-mm": "rhg-arab-mm", "und-arab-mn": "kk-arab-mn", "und-arab-mu": "ur-arab-mu", "und-arab-ng": "ha-arab-ng", "und-arab-pk": "ur-arab-pk", "und-arab-tg": "apd-arab-tg", "und-arab-th": "mfa-arab-th", "und-arab-tj": "fa-arab-tj", "und-arab-tr": "apc-arab-tr", "und-arab-yt": "swb-arab-yt", "und-armi": "arc-armi-ir", "und-armn": "hy-armn-am", "und-as": "sm-latn-as", "und-at": "de-latn-at", "und-avst": "ae-avst-ir", "und-aw": "nl-latn-aw", "und-ax": "sv-latn-ax", "und-az": "az-latn-az", "und-ba": "bs-latn-ba", "und-bali": "ban-bali-id", "und-bamu": "bax-bamu-cm", "und-bass": "bsq-bass-lr", "und-batk": "bbc-batk-id", "und-bd": "bn-beng-bd", "und-be": "nl-latn-be", "und-beng": "bn-beng-bd", "und-bf": "fr-latn-bf", "und-bg": "bg-cyrl-bg", "und-bh": "ar-arab-bh", "und-bhks": "sa-bhks-in", "und-bi": "rn-latn-bi", "und-bj": "fr-latn-bj", "und-bl": "fr-latn-bl", "und-bn": "ms-latn-bn", "und-bo": "es-latn-bo", "und-bopo": "zh-bopo-tw", "und-bq": "pap-latn-bq", "und-br": "pt-latn-br", "und-brah": "pka-brah-in", "und-brai": "fr-brai-fr", "und-bt": "dz-tibt-bt", "und-bugi": "bug-bugi-id", "und-buhd": "bku-buhd-ph", "und-bv": "und-latn-bv", "und-by": "be-cyrl-by", "und-cakm": "ccp-cakm-bd", "und-cans": "iu-cans-ca", "und-cari": "xcr-cari-tr", "und-cd": "sw-latn-cd", "und-cf": "fr-latn-cf", "und-cg": "fr-latn-cg", "und-ch": "de-latn-ch", "und-cham": "cjm-cham-vn", "und-cher": "chr-cher-us", "und-chrs": "xco-chrs-uz", "und-ci": "fr-latn-ci", "und-cl": "es-latn-cl", "und-cm": "fr-latn-cm", "und-cn": "zh-hans-cn", "und-co": "es-latn-co", "und-copt": "cop-copt-eg", "und-cp": "und-latn-cp", "und-cpmn": "und-cpmn-cy", "und-cpmn-cy": "und-cpmn-cy", "und-cprt": "grc-cprt-cy", "und-cr": "es-latn-cr", "und-cu": "es-latn-cu", "und-cv": "pt-latn-cv", "und-cw": "pap-latn-cw", "und-cy": "el-grek-cy", "und-cyrl": "ru-cyrl-ru", "und-cyrl-al": "mk-cyrl-al", "und-cyrl-ba": "sr-cyrl-ba", "und-cyrl-ge": "ab-cyrl-ge", "und-cyrl-gr": "mk-cyrl-gr", "und-cyrl-md": "uk-cyrl-md", "und-cyrl-ro": "bg-cyrl-ro", "und-cyrl-sk": "uk-cyrl-sk", "und-cyrl-tr": "kbd-cyrl-tr", "und-cyrl-xk": "sr-cyrl-xk", "und-cz": "cs-latn-cz", "und-de": "de-latn-de", "und-deva": "hi-deva-in", "und-deva-bt": "ne-deva-bt", "und-deva-fj": "hif-deva-fj", "und-deva-mu": "bho-deva-mu", "und-deva-pk": "btv-deva-pk", "und-diak": "dv-diak-mv", "und-dj": "aa-latn-dj", "und-dk": "da-latn-dk", "und-do": "es-latn-do", "und-dogr": "doi-dogr-in", "und-dupl": "fr-dupl-fr", "und-dz": "ar-arab-dz", "und-ea": "es-latn-ea", "und-ec": "es-latn-ec", "und-ee": "et-latn-ee", "und-eg": "ar-arab-eg", "und-egyp": "egy-egyp-eg", "und-eh": "ar-arab-eh", "und-elba": "sq-elba-al", "und-elym": "arc-elym-ir", "und-er": "ti-ethi-er", "und-es": "es-latn-es", "und-et": "am-ethi-et", "und-ethi": "am-ethi-et", "und-eu": "en-latn-ie", "und-ez": "de-latn-ez", "und-fi": "fi-latn-fi", "und-fo": "fo-latn-fo", "und-fr": "fr-latn-fr", "und-ga": "fr-latn-ga", "und-ge": "ka-geor-ge", "und-geor": "ka-geor-ge", "und-gf": "fr-latn-gf", "und-gh": "ak-latn-gh", "und-gl": "kl-latn-gl", "und-glag": "cu-glag-bg", "und-gn": "fr-latn-gn", "und-gong": "wsg-gong-in", "und-gonm": "esg-gonm-in", "und-goth": "got-goth-ua", "und-gp": "fr-latn-gp", "und-gq": "es-latn-gq", "und-gr": "el-grek-gr", "und-gran": "sa-gran-in", "und-grek": "el-grek-gr", "und-grek-tr": "bgx-grek-tr", "und-gs": "und-latn-gs", "und-gt": "es-latn-gt", "und-gujr": "gu-gujr-in", "und-guru": "pa-guru-in", "und-gw": "pt-latn-gw", "und-hanb": "zh-hanb-tw", "und-hang": "ko-hang-kr", "und-hani": "zh-hani-cn", "und-hano": "hnn-hano-ph", "und-hans": "zh-hans-cn", "und-hant": "zh-hant-tw", "und-hant-ca": "yue-hant-ca", "und-hebr": "he-hebr-il", "und-hebr-se": "yi-hebr-se", "und-hebr-ua": "yi-hebr-ua", "und-hebr-us": "yi-hebr-us", "und-hira": "ja-hira-jp", "und-hk": "zh-hant-hk", "und-hluw": "hlu-hluw-tr", "und-hm": "und-latn-hm", "und-hmng": "hnj-hmng-la", "und-hmnp": "hnj-hmnp-us", "und-hn": "es-latn-hn", "und-hr": "hr-latn-hr", "und-ht": "ht-latn-ht", "und-hu": "hu-latn-hu", "und-hung": "hu-hung-hu", "und-ic": "es-latn-ic", "und-id": "id-latn-id", "und-il": "he-hebr-il", "und-in": "hi-deva-in", "und-iq": "ar-arab-iq", "und-ir": "fa-arab-ir", "und-is": "is-latn-is", "und-it": "it-latn-it", "und-ital": "ett-ital-it", "und-jamo": "ko-jamo-kr", "und-java": "jv-java-id", "und-jo": "ar-arab-jo", "und-jp": "ja-jpan-jp", "und-jpan": "ja-jpan-jp", "und-kali": "eky-kali-mm", "und-kana": "ja-kana-jp", "und-kawi": "kaw-kawi-id", "und-ke": "sw-latn-ke", "und-kg": "ky-cyrl-kg", "und-kh": "km-khmr-kh", "und-khar": "pra-khar-pk", "und-khmr": "km-khmr-kh", "und-khoj": "sd-khoj-in", "und-kits": "zkt-kits-cn", "und-km": "ar-arab-km", "und-knda": "kn-knda-in", "und-kore": "ko-kore-kr", "und-kp": "ko-kore-kp", "und-kr": "ko-kore-kr", "und-kthi": "bho-kthi-in", "und-kw": "ar-arab-kw", "und-kz": "ru-cyrl-kz", "und-la": "lo-laoo-la", "und-lana": "nod-lana-th", "und-laoo": "lo-laoo-la", "und-laoo-au": "hnj-laoo-au", "und-laoo-cn": "hnj-laoo-cn", "und-laoo-fr": "hnj-laoo-fr", "und-laoo-gf": "hnj-laoo-gf", "und-laoo-mm": "hnj-laoo-mm", "und-laoo-sr": "hnj-laoo-sr", "und-laoo-th": "hnj-laoo-th", "und-laoo-us": "hnj-laoo-us", "und-laoo-vn": "hnj-laoo-vn", "und-latn-af": "tk-latn-af", "und-latn-am": "ku-latn-am", "und-latn-cn": "za-latn-cn", "und-latn-cy": "tr-latn-cy", "und-latn-dz": "fr-latn-dz", "und-latn-et": "en-latn-et", "und-latn-ge": "ku-latn-ge", "und-latn-ir": "tk-latn-ir", "und-latn-km": "fr-latn-km", "und-latn-ma": "fr-latn-ma", "und-latn-mk": "sq-latn-mk", "und-latn-mm": "kac-latn-mm", "und-latn-mo": "pt-latn-mo", "und-latn-mr": "fr-latn-mr", "und-latn-ru": "krl-latn-ru", "und-latn-sy": "fr-latn-sy", "und-latn-tn": "fr-latn-tn", "und-latn-tw": "trv-latn-tw", "und-latn-ua": "pl-latn-ua", "und-lb": "ar-arab-lb", "und-lepc": "lep-lepc-in", "und-li": "de-latn-li", "und-limb": "lif-limb-in", "und-lina": "lab-lina-gr", "und-linb": "grc-linb-gr", "und-lisu": "lis-lisu-cn", "und-lk": "si-sinh-lk", "und-ls": "st-latn-ls", "und-lt": "lt-latn-lt", "und-lu": "fr-latn-lu", "und-lv": "lv-latn-lv", "und-ly": "ar-arab-ly", "und-lyci": "xlc-lyci-tr", "und-lydi": "xld-lydi-tr", "und-ma": "ar-arab-ma", "und-mahj": "hi-mahj-in", "und-maka": "mak-maka-id", "und-mand": "myz-mand-ir", "und-mani": "xmn-mani-cn", "und-marc": "bo-marc-cn", "und-mc": "fr-latn-mc", "und-md": "ro-latn-md", "und-me": "sr-latn-me", "und-medf": "dmf-medf-ng", "und-mend": "men-mend-sl", "und-merc": "xmr-merc-sd", "und-mero": "xmr-mero-sd", "und-mf": "fr-latn-mf", "und-mg": "mg-latn-mg", "und-mk": "mk-cyrl-mk", "und-ml": "bm-latn-ml", "und-mlym": "ml-mlym-in", "und-mm": "my-mymr-mm", "und-mn": "mn-cyrl-mn", "und-mo": "zh-hant-mo", "und-modi": "mr-modi-in", "und-mong": "mn-mong-cn", "und-mq": "fr-latn-mq", "und-mr": "ar-arab-mr", "und-mroo": "mro-mroo-bd", "und-mt": "mt-latn-mt", "und-mtei": "mni-mtei-in", "und-mu": "mfe-latn-mu", "und-mult": "skr-mult-pk", "und-mv": "dv-thaa-mv", "und-mx": "es-latn-mx", "und-my": "ms-latn-my", "und-mymr": "my-mymr-mm", "und-mymr-in": "kht-mymr-in", "und-mymr-th": "mnw-mymr-th", "und-mz": "pt-latn-mz", "und-na": "af-latn-na", "und-nagm": "unr-nagm-in", "und-nand": "sa-nand-in", "und-narb": "xna-narb-sa", "und-nbat": "arc-nbat-jo", "und-nc": "fr-latn-nc", "und-ne": "ha-latn-ne", "und-newa": "new-newa-np", "und-ni": "es-latn-ni", "und-nkoo": "man-nkoo-gn", "und-nl": "nl-latn-nl", "und-no": "nb-latn-no", "und-np": "ne-deva-np", "und-nshu": "zhx-nshu-cn", "und-ogam": "sga-ogam-ie", "und-olck": "sat-olck-in", "und-om": "ar-arab-om", "und-orkh": "otk-orkh-mn", "und-orya": "or-orya-in", "und-osge": "osa-osge-us", "und-osma": "so-osma-so", "und-ougr": "oui-ougr-143", "und-pa": "es-latn-pa", "und-palm": "arc-palm-sy", "und-pauc": "ctd-pauc-mm", "und-pe": "es-latn-pe", "und-perm": "kv-perm-ru", "und-pf": "fr-latn-pf", "und-pg": "tpi-latn-pg", "und-ph": "fil-latn-ph", "und-phag": "lzh-phag-cn", "und-phli": "pal-phli-ir", "und-phlp": "pal-phlp-cn", "und-phnx": "phn-phnx-lb", "und-pk": "ur-arab-pk", "und-pl": "pl-latn-pl", "und-plrd": "hmd-plrd-cn", "und-pm": "fr-latn-pm", "und-pr": "es-latn-pr", "und-prti": "xpr-prti-ir", "und-ps": "ar-arab-ps", "und-pt": "pt-latn-pt", "und-pw": "pau-latn-pw", "und-py": "gn-latn-py", "und-qa": "ar-arab-qa", "und-qo": "en-latn-dg", "und-re": "fr-latn-re", "und-rjng": "rej-rjng-id", "und-ro": "ro-latn-ro", "und-rohg": "rhg-rohg-mm", "und-rs": "sr-cyrl-rs", "und-ru": "ru-cyrl-ru", "und-runr": "non-runr-se", "und-rw": "rw-latn-rw", "und-sa": "ar-arab-sa", "und-samr": "smp-samr-il", "und-sarb": "xsa-sarb-ye", "und-saur": "saz-saur-in", "und-sc": "fr-latn-sc", "und-sd": "ar-arab-sd", "und-se": "sv-latn-se", "und-sgnw": "ase-sgnw-us", "und-shaw": "en-shaw-gb", "und-shrd": "sa-shrd-in", "und-si": "sl-latn-si", "und-sidd": "sa-sidd-in", "und-sind": "sd-sind-in", "und-sinh": "si-sinh-lk", "und-sj": "nb-latn-sj", "und-sk": "sk-latn-sk", "und-sm": "it-latn-sm", "und-sn": "fr-latn-sn", "und-so": "so-latn-so", "und-sogd": "sog-sogd-uz", "und-sogo": "sog-sogo-uz", "und-sora": "srb-sora-in", "und-soyo": "cmg-soyo-mn", "und-sr": "nl-latn-sr", "und-st": "pt-latn-st", "und-sund": "su-sund-id", "und-sv": "es-latn-sv", "und-sy": "ar-arab-sy", "und-sylo": "syl-sylo-bd", "und-syrc": "syr-syrc-iq", "und-tagb": "tbw-tagb-ph", "und-takr": "doi-takr-in", "und-tale": "tdd-tale-cn", "und-talu": "khb-talu-cn", "und-taml": "ta-taml-in", "und-tang": "txg-tang-cn", "und-tavt": "blt-tavt-vn", "und-td": "fr-latn-td", "und-telu": "te-telu-in", "und-tf": "fr-latn-tf", "und-tfng": "zgh-tfng-ma", "und-tg": "fr-latn-tg", "und-tglg": "fil-tglg-ph", "und-th": "th-thai-th", "und-thaa": "dv-thaa-mv", "und-thai": "th-thai-th", "und-thai-cn": "lcp-thai-cn", "und-thai-kh": "kdt-thai-kh", "und-thai-la": "kdt-thai-la", "und-tibt": "bo-tibt-cn", "und-tirh": "mai-tirh-in", "und-tj": "tg-cyrl-tj", "und-tk": "tkl-latn-tk", "und-tl": "pt-latn-tl", "und-tm": "tk-latn-tm", "und-tn": "ar-arab-tn", "und-tnsa": "nst-tnsa-in", "und-to": "to-latn-to", "und-toto": "txo-toto-in", "und-tr": "tr-latn-tr", "und-tv": "tvl-latn-tv", "und-tw": "zh-hant-tw", "und-tz": "sw-latn-tz", "und-ua": "uk-cyrl-ua", "und-ug": "sw-latn-ug", "und-ugar": "uga-ugar-sy", "und-uy": "es-latn-uy", "und-uz": "uz-latn-uz", "und-va": "it-latn-va", "und-vaii": "vai-vaii-lr", "und-ve": "es-latn-ve", "und-vith": "sq-vith-al", "und-vn": "vi-latn-vn", "und-vu": "bi-latn-vu", "und-wara": "hoc-wara-in", "und-wcho": "nnp-wcho-in", "und-wf": "fr-latn-wf", "und-ws": "sm-latn-ws", "und-xk": "sq-latn-xk", "und-xpeo": "peo-xpeo-ir", "und-xsux": "akk-xsux-iq", "und-ye": "ar-arab-ye", "und-yezi": "ku-yezi-ge", "und-yiii": "ii-yiii-cn", "und-yt": "fr-latn-yt", "und-zanb": "cmg-zanb-mn", "und-zw": "sn-latn-zw", une: "une-latn-ng", ung: "ung-latn-au", uni: "uni-latn-pg", unk: "unk-latn-br", unm: "unm-latn-us", unn: "unn-latn-au", unr: "unr-beng-in", "unr-deva": "unr-deva-np", "unr-np": "unr-deva-np", unu: "unu-latn-pg", unx: "unx-beng-in", unz: "unz-latn-id", uok: "uok-latn-zz", uon: "uon-latn-tw", upi: "upi-latn-pg", upv: "upv-latn-vu", ur: "ur-arab-pk", ura: "ura-latn-pe", urb: "urb-latn-br", urc: "urc-latn-au", ure: "ure-latn-bo", urf: "urf-latn-au", urg: "urg-latn-pg", urh: "urh-latn-ng", uri: "uri-latn-zz", urk: "urk-thai-th", urm: "urm-latn-pg", urn: "urn-latn-id", uro: "uro-latn-pg", urp: "urp-latn-br", urr: "urr-latn-vu", urt: "urt-latn-zz", uru: "uru-latn-br", urv: "urv-latn-pg", urw: "urw-latn-zz", urx: "urx-latn-pg", ury: "ury-latn-id", urz: "urz-latn-br", usa: "usa-latn-zz", ush: "ush-arab-pk", usi: "usi-latn-bd", "usi-beng": "usi-beng-bd", usk: "usk-latn-cm", usp: "usp-latn-gt", uss: "uss-latn-ng", usu: "usu-latn-pg", uta: "uta-latn-ng", ute: "ute-latn-us", uth: "uth-latn-zz", utp: "utp-latn-sb", utr: "utr-latn-zz", utu: "utu-latn-pg", uum: "uum-grek-ge", "uum-cyrl": "uum-cyrl-ge", uur: "uur-latn-vu", uve: "uve-latn-nc", uvh: "uvh-latn-zz", uvl: "uvl-latn-zz", uwa: "uwa-latn-au", uya: "uya-latn-ng", uz: "uz-latn-uz", "uz-af": "uz-arab-af", "uz-arab": "uz-arab-af", "uz-cn": "uz-cyrl-cn", uzs: "uzs-arab-af", vaa: "vaa-taml-in", vae: "vae-latn-cf", vaf: "vaf-arab-ir", vag: "vag-latn-zz", vah: "vah-deva-in", vai: "vai-vaii-lr", vaj: "vaj-latn-na", val: "val-latn-pg", vam: "vam-latn-pg", van: "van-latn-zz", vao: "vao-latn-vu", vap: "vap-latn-in", var: "var-latn-mx", vas: "vas-deva-in", "vas-gujr": "vas-gujr-in", vau: "vau-latn-cd", vav: "vav-deva-in", "vav-gujr": "vav-gujr-in", vay: "vay-deva-np", vbb: "vbb-latn-id", vbk: "vbk-latn-ph", ve: "ve-latn-za", vec: "vec-latn-it", vem: "vem-latn-ng", veo: "veo-latn-us", vep: "vep-latn-ru", ver: "ver-latn-ng", vgr: "vgr-arab-pk", vi: "vi-latn-vn", vic: "vic-latn-sx", vid: "vid-latn-tz", vif: "vif-latn-cg", vig: "vig-latn-bf", vil: "vil-latn-ar", vin: "vin-latn-tz", vit: "vit-latn-ng", viv: "viv-latn-zz", vka: "vka-latn-au", vkj: "vkj-latn-td", vkk: "vkk-latn-id", vkl: "vkl-latn-id", vkm: "vkm-latn-br", vkn: "vkn-latn-ng", vko: "vko-latn-id", vkp: "vkp-latn-in", "vkp-deva": "vkp-deva-in", vkt: "vkt-latn-id", vku: "vku-latn-au", vkz: "vkz-latn-ng", vlp: "vlp-latn-vu", vls: "vls-latn-be", vma: "vma-latn-au", vmb: "vmb-latn-au", vmc: "vmc-latn-mx", vmd: "vmd-knda-in", vme: "vme-latn-id", vmf: "vmf-latn-de", vmg: "vmg-latn-pg", vmh: "vmh-arab-ir", vmi: "vmi-latn-au", vmj: "vmj-latn-mx", vmk: "vmk-latn-mz", vml: "vml-latn-au", vmm: "vmm-latn-mx", vmp: "vmp-latn-mx", vmq: "vmq-latn-mx", vmr: "vmr-latn-mz", vms: "vms-latn-id", vmu: "vmu-latn-au", vmw: "vmw-latn-mz", vmx: "vmx-latn-mx", vmy: "vmy-latn-mx", vmz: "vmz-latn-mx", vnk: "vnk-latn-sb", vnm: "vnm-latn-vu", vnp: "vnp-latn-vu", vo: "vo-latn-001", vor: "vor-latn-ng", vot: "vot-latn-ru", vra: "vra-latn-vu", vro: "vro-latn-ee", vrs: "vrs-latn-sb", vrt: "vrt-latn-vu", vto: "vto-latn-id", vum: "vum-latn-ga", vun: "vun-latn-tz", vut: "vut-latn-zz", vwa: "vwa-latn-cn", "vwa-mymr": "vwa-mymr-cn", wa: "wa-latn-be", waa: "waa-latn-us", wab: "wab-latn-pg", wac: "wac-latn-us", wad: "wad-latn-id", wae: "wae-latn-ch", waf: "waf-latn-br", wag: "wag-latn-pg", wah: "wah-latn-id", wai: "wai-latn-id", waj: "waj-latn-zz", wal: "wal-ethi-et", wam: "wam-latn-us", wan: "wan-latn-zz", wap: "wap-latn-gy", waq: "waq-latn-au", war: "war-latn-ph", was: "was-latn-us", wat: "wat-latn-pg", wau: "wau-latn-br", wav: "wav-latn-ng", waw: "waw-latn-br", wax: "wax-latn-pg", way: "way-latn-sr", waz: "waz-latn-pg", wba: "wba-latn-ve", wbb: "wbb-latn-id", wbe: "wbe-latn-id", wbf: "wbf-latn-bf", wbh: "wbh-latn-tz", wbi: "wbi-latn-tz", wbj: "wbj-latn-tz", wbk: "wbk-arab-af", wbl: "wbl-latn-pk", "wbl-arab": "wbl-arab-af", "wbl-cyrl": "wbl-cyrl-tj", wbm: "wbm-latn-cn", wbp: "wbp-latn-au", wbq: "wbq-telu-in", wbr: "wbr-deva-in", wbt: "wbt-latn-au", wbv: "wbv-latn-au", wbw: "wbw-latn-id", wca: "wca-latn-br", wci: "wci-latn-zz", wdd: "wdd-latn-ga", wdg: "wdg-latn-pg", wdj: "wdj-latn-au", wdk: "wdk-latn-au", wdt: "wdt-latn-ca", wdu: "wdu-latn-au", wdy: "wdy-latn-au", wec: "wec-latn-ci", wed: "wed-latn-pg", weg: "weg-latn-au", weh: "weh-latn-cm", wei: "wei-latn-pg", wem: "wem-latn-bj", weo: "weo-latn-id", wep: "wep-latn-de", wer: "wer-latn-zz", wes: "wes-latn-cm", wet: "wet-latn-id", weu: "weu-latn-mm", wew: "wew-latn-id", wfg: "wfg-latn-id", wga: "wga-latn-au", wgb: "wgb-latn-pg", wgg: "wgg-latn-au", wgi: "wgi-latn-zz", wgo: "wgo-latn-id", wgu: "wgu-latn-au", wgy: "wgy-latn-au", wha: "wha-latn-id", whg: "whg-latn-zz", whk: "whk-latn-id", whu: "whu-latn-id", wib: "wib-latn-zz", wic: "wic-latn-us", wie: "wie-latn-au", wif: "wif-latn-au", wig: "wig-latn-au", wih: "wih-latn-au", wii: "wii-latn-pg", wij: "wij-latn-au", wik: "wik-latn-au", wil: "wil-latn-au", wim: "wim-latn-au", win: "win-latn-us", wir: "wir-latn-br", wiu: "wiu-latn-zz", wiv: "wiv-latn-zz", wiy: "wiy-latn-us", wja: "wja-latn-zz", wji: "wji-latn-zz", wka: "wka-latn-tz", wkd: "wkd-latn-id", wkr: "wkr-latn-au", wkw: "wkw-latn-au", wky: "wky-latn-au", wla: "wla-latn-pg", wlg: "wlg-latn-au", wlh: "wlh-latn-tl", wli: "wli-latn-id", wlm: "wlm-latn-gb", wlo: "wlo-arab-id", wlr: "wlr-latn-vu", wls: "wls-latn-wf", wlu: "wlu-latn-au", wlv: "wlv-latn-ar", wlw: "wlw-latn-id", wlx: "wlx-latn-gh", wma: "wma-latn-ng", wmb: "wmb-latn-au", wmc: "wmc-latn-pg", wmd: "wmd-latn-br", wme: "wme-deva-np", wmh: "wmh-latn-tl", wmi: "wmi-latn-au", wmm: "wmm-latn-id", wmn: "wmn-latn-nc", wmo: "wmo-latn-zz", wms: "wms-latn-id", wmt: "wmt-latn-au", wmw: "wmw-latn-mz", "wmw-arab": "wmw-arab-mz", wmx: "wmx-latn-pg", wnb: "wnb-latn-pg", wnc: "wnc-latn-zz", wnd: "wnd-latn-au", wne: "wne-arab-pk", wng: "wng-latn-id", wni: "wni-arab-km", wnk: "wnk-latn-id", wnm: "wnm-latn-au", wnn: "wnn-latn-au", wno: "wno-latn-id", wnp: "wnp-latn-pg", wnu: "wnu-latn-zz", wnw: "wnw-latn-us", wny: "wny-latn-au", wo: "wo-latn-sn", woa: "woa-latn-au", wob: "wob-latn-zz", woc: "woc-latn-pg", wod: "wod-latn-id", woe: "woe-latn-fm", wof: "wof-latn-gm", "wof-arab": "wof-arab-gm", wog: "wog-latn-pg", woi: "woi-latn-id", wok: "wok-latn-cm", wom: "wom-latn-ng", won: "won-latn-cd", woo: "woo-latn-id", wor: "wor-latn-id", wos: "wos-latn-zz", wow: "wow-latn-id", wpc: "wpc-latn-ve", wrb: "wrb-latn-au", wrg: "wrg-latn-au", wrh: "wrh-latn-au", wri: "wri-latn-au", wrk: "wrk-latn-au", wrl: "wrl-latn-au", wrm: "wrm-latn-au", wro: "wro-latn-au", wrp: "wrp-latn-id", wrr: "wrr-latn-au", wrs: "wrs-latn-zz", wru: "wru-latn-id", wrv: "wrv-latn-pg", wrw: "wrw-latn-au", wrx: "wrx-latn-id", wrz: "wrz-latn-au", wsa: "wsa-latn-id", wsg: "wsg-gong-in", wsi: "wsi-latn-vu", wsk: "wsk-latn-zz", wsr: "wsr-latn-pg", wss: "wss-latn-gh", wsu: "wsu-latn-br", wsv: "wsv-arab-af", wtf: "wtf-latn-pg", wth: "wth-latn-au", wti: "wti-latn-et", wtk: "wtk-latn-pg", wtm: "wtm-deva-in", wtw: "wtw-latn-id", "wtw-bugi": "wtw-bugi-id", wua: "wua-latn-au", wub: "wub-latn-au", wud: "wud-latn-tg", wul: "wul-latn-id", wum: "wum-latn-ga", wun: "wun-latn-tz", wur: "wur-latn-au", wut: "wut-latn-pg", wuu: "wuu-hans-cn", wuv: "wuv-latn-zz", wux: "wux-latn-au", wuy: "wuy-latn-id", wwa: "wwa-latn-zz", wwb: "wwb-latn-au", wwo: "wwo-latn-vu", wwr: "wwr-latn-au", www: "www-latn-cm", wxw: "wxw-latn-au", wyb: "wyb-latn-au", wyi: "wyi-latn-au", wym: "wym-latn-pl", wyn: "wyn-latn-us", wyr: "wyr-latn-br", wyy: "wyy-latn-fj", xaa: "xaa-latn-es", xab: "xab-latn-ng", xai: "xai-latn-br", xaj: "xaj-latn-br", xak: "xak-latn-ve", xal: "xal-cyrl-ru", xam: "xam-latn-za", xan: "xan-ethi-et", xao: "xao-latn-vn", xar: "xar-latn-pg", xas: "xas-cyrl-ru", xat: "xat-latn-br", xau: "xau-latn-id", xav: "xav-latn-br", xaw: "xaw-latn-us", xay: "xay-latn-id", xbb: "xbb-latn-au", xbd: "xbd-latn-au", xbe: "xbe-latn-au", xbg: "xbg-latn-au", xbi: "xbi-latn-zz", xbj: "xbj-latn-au", xbm: "xbm-latn-fr", xbn: "xbn-latn-my", xbp: "xbp-latn-au", xbr: "xbr-latn-id", xbw: "xbw-latn-br", xby: "xby-latn-au", xch: "xch-latn-us", xco: "xco-chrs-uz", xcr: "xcr-cari-tr", xda: "xda-latn-au", xdk: "xdk-latn-au", xdo: "xdo-latn-ao", xdq: "xdq-cyrl-ru", xdy: "xdy-latn-id", xed: "xed-latn-cm", xeg: "xeg-latn-za", xem: "xem-latn-id", xer: "xer-latn-br", xes: "xes-latn-zz", xet: "xet-latn-br", xeu: "xeu-latn-pg", xgb: "xgb-latn-ci", xgd: "xgd-latn-au", xgg: "xgg-latn-au", xgi: "xgi-latn-au", xgm: "xgm-latn-au", xgu: "xgu-latn-au", xgw: "xgw-latn-au", xh: "xh-latn-za", xhe: "xhe-arab-pk", xhm: "xhm-khmr-kh", xhv: "xhv-latn-vn", xii: "xii-latn-za", xin: "xin-latn-gt", xir: "xir-latn-br", xis: "xis-orya-in", xiy: "xiy-latn-br", xjb: "xjb-latn-au", xjt: "xjt-latn-au", xka: "xka-arab-pk", xkb: "xkb-latn-bj", xkc: "xkc-arab-ir", xkd: "xkd-latn-id", xke: "xke-latn-id", xkg: "xkg-latn-ml", xkj: "xkj-arab-ir", xkl: "xkl-latn-id", xkn: "xkn-latn-id", xkp: "xkp-arab-ir", xkq: "xkq-latn-id", xkr: "xkr-latn-br", xks: "xks-latn-id", xkt: "xkt-latn-gh", xku: "xku-latn-cg", xkv: "xkv-latn-bw", xkw: "xkw-latn-id", xkx: "xkx-latn-pg", xky: "xky-latn-my", xkz: "xkz-latn-bt", xla: "xla-latn-zz", xlc: "xlc-lyci-tr", xld: "xld-lydi-tr", xly: "xly-elym-ir", xma: "xma-latn-so", xmb: "xmb-latn-cm", xmc: "xmc-latn-mz", xmd: "xmd-latn-cm", xmf: "xmf-geor-ge", xmg: "xmg-latn-cm", xmh: "xmh-latn-au", xmj: "xmj-latn-cm", xmm: "xmm-latn-id", xmn: "xmn-mani-cn", xmo: "xmo-latn-br", xmp: "xmp-latn-au", xmq: "xmq-latn-au", xmr: "xmr-merc-sd", xmt: "xmt-latn-id", xmu: "xmu-latn-au", xmv: "xmv-latn-mg", xmw: "xmw-latn-mg", xmx: "xmx-latn-id", xmy: "xmy-latn-au", xmz: "xmz-latn-id", xna: "xna-narb-sa", xnb: "xnb-latn-tw", xni: "xni-latn-au", xnj: "xnj-latn-tz", xnk: "xnk-latn-au", xnm: "xnm-latn-au", xnn: "xnn-latn-ph", xnq: "xnq-latn-mz", xnr: "xnr-deva-in", xnt: "xnt-latn-us", xnu: "xnu-latn-au", xny: "xny-latn-au", xnz: "xnz-latn-eg", "xnz-arab": "xnz-arab-eg", xoc: "xoc-latn-ng", xod: "xod-latn-id", xog: "xog-latn-ug", xoi: "xoi-latn-pg", xok: "xok-latn-br", xom: "xom-latn-sd", "xom-ethi": "xom-ethi-et", xon: "xon-latn-zz", xoo: "xoo-latn-br", xop: "xop-latn-pg", xor: "xor-latn-br", xow: "xow-latn-pg", xpa: "xpa-latn-au", xpb: "xpb-latn-au", xpd: "xpd-latn-au", xpf: "xpf-latn-au", xpg: "xpg-grek-tr", xph: "xph-latn-au", xpi: "xpi-ogam-gb", xpj: "xpj-latn-au", xpk: "xpk-latn-br", xpl: "xpl-latn-au", xpm: "xpm-cyrl-ru", xpn: "xpn-latn-br", xpo: "xpo-latn-mx", xpq: "xpq-latn-us", xpr: "xpr-prti-ir", xpt: "xpt-latn-au", xpv: "xpv-latn-au", xpw: "xpw-latn-au", xpx: "xpx-latn-au", xpz: "xpz-latn-au", xra: "xra-latn-br", xrb: "xrb-latn-zz", xrd: "xrd-latn-au", xre: "xre-latn-br", xrg: "xrg-latn-au", xri: "xri-latn-br", xrm: "xrm-cyrl-ru", xrn: "xrn-cyrl-ru", xrr: "xrr-latn-it", xru: "xru-latn-au", xrw: "xrw-latn-pg", xsa: "xsa-sarb-ye", xsb: "xsb-latn-ph", xse: "xse-latn-id", xsh: "xsh-latn-ng", xsi: "xsi-latn-zz", xsm: "xsm-latn-zz", xsn: "xsn-latn-ng", xsp: "xsp-latn-pg", xsq: "xsq-latn-mz", xsr: "xsr-deva-np", xss: "xss-cyrl-ru", xsu: "xsu-latn-ve", xsy: "xsy-latn-tw", xta: "xta-latn-mx", xtb: "xtb-latn-mx", xtc: "xtc-latn-sd", xtd: "xtd-latn-mx", xte: "xte-latn-id", xth: "xth-latn-au", xti: "xti-latn-mx", xtj: "xtj-latn-mx", xtl: "xtl-latn-mx", xtm: "xtm-latn-mx", xtn: "xtn-latn-mx", xtp: "xtp-latn-mx", xts: "xts-latn-mx", xtt: "xtt-latn-mx", xtu: "xtu-latn-mx", xtv: "xtv-latn-au", xtw: "xtw-latn-br", xty: "xty-latn-mx", xub: "xub-taml-in", "xub-knda": "xub-knda-in", "xub-mlym": "xub-mlym-in", xud: "xud-latn-au", xuj: "xuj-taml-in", xul: "xul-latn-au", xum: "xum-latn-it", "xum-ital": "xum-ital-it", xun: "xun-latn-au", xuo: "xuo-latn-td", xut: "xut-latn-au", xuu: "xuu-latn-na", xve: "xve-ital-it", xvi: "xvi-arab-af", xvn: "xvn-latn-es", xvo: "xvo-latn-it", xvs: "xvs-latn-it", xwa: "xwa-latn-br", xwd: "xwd-latn-au", xwe: "xwe-latn-zz", xwj: "xwj-latn-au", xwk: "xwk-latn-au", xwl: "xwl-latn-bj", xwo: "xwo-cyrl-ru", xwr: "xwr-latn-id", xwt: "xwt-latn-au", xww: "xww-latn-au", xxb: "xxb-latn-gh", xxk: "xxk-latn-id", xxm: "xxm-latn-au", xxr: "xxr-latn-br", xxt: "xxt-latn-id", xya: "xya-latn-au", xyb: "xyb-latn-au", xyj: "xyj-latn-au", xyk: "xyk-latn-au", xyl: "xyl-latn-br", xyt: "xyt-latn-au", xyy: "xyy-latn-au", xzh: "xzh-marc-cn", xzp: "xzp-latn-mx", yaa: "yaa-latn-pe", yab: "yab-latn-br", yac: "yac-latn-id", yad: "yad-latn-pe", yae: "yae-latn-ve", yaf: "yaf-latn-cd", yag: "yag-latn-cl", yai: "yai-cyrl-tj", yaj: "yaj-latn-cf", yak: "yak-latn-us", yal: "yal-latn-gn", "yal-arab": "yal-arab-gn", yam: "yam-latn-zz", yan: "yan-latn-ni", yao: "yao-latn-mz", yap: "yap-latn-fm", yaq: "yaq-latn-mx", yar: "yar-latn-ve", yas: "yas-latn-zz", yat: "yat-latn-zz", yau: "yau-latn-ve", yav: "yav-latn-cm", yaw: "yaw-latn-br", yax: "yax-latn-ao", yay: "yay-latn-zz", yaz: "yaz-latn-zz", yba: "yba-latn-zz", ybb: "ybb-latn-cm", ybe: "ybe-latn-cn", "ybe-ougr": "ybe-ougr-cn", ybh: "ybh-deva-np", ybi: "ybi-deva-np", ybj: "ybj-latn-ng", ybl: "ybl-latn-ng", ybm: "ybm-latn-pg", ybn: "ybn-latn-br", ybo: "ybo-latn-pg", ybx: "ybx-latn-pg", yby: "yby-latn-zz", ycl: "ycl-latn-cn", ycn: "ycn-latn-co", yda: "yda-latn-au", yde: "yde-latn-pg", ydg: "ydg-arab-pk", ydk: "ydk-latn-pg", yea: "yea-mlym-in", "yea-knda": "yea-knda-in", yec: "yec-latn-de", yee: "yee-latn-pg", yei: "yei-latn-cm", yej: "yej-grek-il", yel: "yel-latn-cd", yer: "yer-latn-zz", yes: "yes-latn-ng", yet: "yet-latn-id", yeu: "yeu-telu-in", yev: "yev-latn-pg", yey: "yey-latn-bw", yga: "yga-latn-au", ygi: "ygi-latn-au", ygl: "ygl-latn-pg", ygm: "ygm-latn-pg", ygp: "ygp-plrd-cn", ygr: "ygr-latn-zz", ygu: "ygu-latn-au", ygw: "ygw-latn-zz", yhd: "yhd-hebr-il", yi: "yi-hebr-001", yia: "yia-latn-au", yig: "yig-yiii-cn", yih: "yih-hebr-de", yii: "yii-latn-au", yij: "yij-latn-au", yil: "yil-latn-au", yim: "yim-latn-in", yir: "yir-latn-id", yis: "yis-latn-pg", yiv: "yiv-yiii-cn", yka: "yka-latn-ph", "yka-arab": "yka-arab-ph", ykg: "ykg-cyrl-ru", yki: "yki-latn-id", ykk: "ykk-latn-pg", ykm: "ykm-latn-pg", yko: "yko-latn-zz", ykr: "ykr-latn-pg", yky: "yky-latn-cf", yla: "yla-latn-pg", ylb: "ylb-latn-pg", yle: "yle-latn-zz", ylg: "ylg-latn-zz", yli: "yli-latn-id", yll: "yll-latn-zz", ylr: "ylr-latn-au", ylu: "ylu-latn-pg", yly: "yly-latn-nc", ymb: "ymb-latn-pg", yme: "yme-latn-pe", ymg: "ymg-latn-cd", ymk: "ymk-latn-mz", "ymk-arab": "ymk-arab-mz", yml: "yml-latn-zz", ymm: "ymm-latn-so", ymn: "ymn-latn-id", ymo: "ymo-latn-pg", ymp: "ymp-latn-pg", yna: "yna-plrd-cn", ynd: "ynd-latn-au", yng: "yng-latn-cd", ynk: "ynk-cyrl-ru", ynl: "ynl-latn-pg", ynq: "ynq-latn-ng", yns: "yns-latn-cd", ynu: "ynu-latn-co", yo: "yo-latn-ng", yob: "yob-latn-pg", yog: "yog-latn-ph", yoi: "yoi-jpan-jp", yok: "yok-latn-us", yol: "yol-latn-gb", yom: "yom-latn-cd", yon: "yon-latn-zz", yot: "yot-latn-ng", yoy: "yoy-thai-th", yra: "yra-latn-pg", yrb: "yrb-latn-zz", yre: "yre-latn-zz", yrk: "yrk-cyrl-ru", yrl: "yrl-latn-br", yrm: "yrm-latn-au", yro: "yro-latn-br", yrs: "yrs-latn-id", yrw: "yrw-latn-pg", yry: "yry-latn-au", ysd: "ysd-yiii-cn", ysn: "ysn-yiii-cn", ysp: "ysp-yiii-cn", ysr: "ysr-cyrl-ru", yss: "yss-latn-zz", ysy: "ysy-plrd-cn", ytw: "ytw-latn-pg", yty: "yty-latn-au", yua: "yua-latn-mx", yub: "yub-latn-au", yuc: "yuc-latn-us", yud: "yud-hebr-il", yue: "yue-hant-hk", "yue-cn": "yue-hans-cn", "yue-hans": "yue-hans-cn", yuf: "yuf-latn-us", yug: "yug-cyrl-ru", yui: "yui-latn-co", yuj: "yuj-latn-zz", yul: "yul-latn-cf", yum: "yum-latn-us", yun: "yun-latn-ng", yup: "yup-latn-co", yuq: "yuq-latn-bo", yur: "yur-latn-us", yut: "yut-latn-zz", yuw: "yuw-latn-zz", yux: "yux-cyrl-ru", yuz: "yuz-latn-bo", yva: "yva-latn-id", yvt: "yvt-latn-ve", ywa: "ywa-latn-pg", ywg: "ywg-latn-au", ywn: "ywn-latn-br", ywq: "ywq-plrd-cn", "ywq-yiii": "ywq-yiii-cn", ywr: "ywr-latn-au", ywu: "ywu-plrd-cn", "ywu-yiii": "ywu-yiii-cn", yww: "yww-latn-au", yxa: "yxa-latn-au", yxg: "yxg-latn-au", yxl: "yxl-latn-au", yxm: "yxm-latn-au", yxu: "yxu-latn-au", yxy: "yxy-latn-au", yyr: "yyr-latn-au", yyu: "yyu-latn-pg", za: "za-latn-cn", zaa: "zaa-latn-mx", zab: "zab-latn-mx", zac: "zac-latn-mx", zad: "zad-latn-mx", zae: "zae-latn-mx", zaf: "zaf-latn-mx", zag: "zag-latn-sd", zah: "zah-latn-ng", zaj: "zaj-latn-tz", zak: "zak-latn-tz", zam: "zam-latn-mx", zao: "zao-latn-mx", zap: "zap-latn-mx", zaq: "zaq-latn-mx", zar: "zar-latn-mx", zas: "zas-latn-mx", zat: "zat-latn-mx", zau: "zau-tibt-in", "zau-arab": "zau-arab-in", zav: "zav-latn-mx", zaw: "zaw-latn-mx", zax: "zax-latn-mx", zay: "zay-latn-et", "zay-ethi": "zay-ethi-et", zaz: "zaz-latn-ng", zba: "zba-arab-001", zbc: "zbc-latn-my", zbe: "zbe-latn-my", zbt: "zbt-latn-id", zbu: "zbu-latn-ng", zbw: "zbw-latn-my", zca: "zca-latn-mx", zch: "zch-hani-cn", zdj: "zdj-arab-km", zea: "zea-latn-nl", zeg: "zeg-latn-pg", zeh: "zeh-hani-cn", zen: "zen-tfng-mr", "zen-arab": "zen-arab-mr", zga: "zga-latn-tz", zgb: "zgb-hani-cn", zgh: "zgh-tfng-ma", zgm: "zgm-hani-cn", zgn: "zgn-hani-cn", zgr: "zgr-latn-pg", zh: "zh-hans-cn", "zh-au": "zh-hant-au", "zh-bn": "zh-hant-bn", "zh-bopo": "zh-bopo-tw", "zh-gb": "zh-hant-gb", "zh-gf": "zh-hant-gf", "zh-hanb": "zh-hanb-tw", "zh-hant": "zh-hant-tw", "zh-hk": "zh-hant-hk", "zh-id": "zh-hant-id", "zh-mo": "zh-hant-mo", "zh-pa": "zh-hant-pa", "zh-pf": "zh-hant-pf", "zh-ph": "zh-hant-ph", "zh-sr": "zh-hant-sr", "zh-th": "zh-hant-th", "zh-tw": "zh-hant-tw", "zh-us": "zh-hant-us", "zh-vn": "zh-hant-vn", zhd: "zhd-hani-cn", "zhd-latn": "zhd-latn-vn", zhi: "zhi-latn-ng", zhn: "zhn-latn-cn", "zhn-hani": "zhn-hani-cn", zhw: "zhw-latn-cm", zhx: "zhx-nshu-cn", zia: "zia-latn-zz", zik: "zik-latn-pg", zil: "zil-latn-gn", zim: "zim-latn-td", zin: "zin-latn-tz", ziw: "ziw-latn-tz", ziz: "ziz-latn-ng", zka: "zka-latn-id", zkb: "zkb-cyrl-ru", zkd: "zkd-latn-mm", zko: "zko-cyrl-ru", zkp: "zkp-latn-br", zkt: "zkt-kits-cn", zku: "zku-latn-au", zkz: "zkz-cyrl-ru", zla: "zla-latn-cd", zlj: "zlj-hani-cn", "zlj-latn": "zlj-latn-cn", zlm: "zlm-latn-tg", zln: "zln-hani-cn", zlq: "zlq-hani-cn", zma: "zma-latn-au", zmb: "zmb-latn-cd", zmc: "zmc-latn-au", zmd: "zmd-latn-au", zme: "zme-latn-au", zmf: "zmf-latn-cd", zmg: "zmg-latn-au", zmh: "zmh-latn-pg", zmi: "zmi-latn-my", zmj: "zmj-latn-au", zmk: "zmk-latn-au", zml: "zml-latn-au", zmm: "zmm-latn-au", zmn: "zmn-latn-ga", zmo: "zmo-latn-sd", zmp: "zmp-latn-cd", zmq: "zmq-latn-cd", zmr: "zmr-latn-au", zms: "zms-latn-cd", zmt: "zmt-latn-au", zmu: "zmu-latn-au", zmv: "zmv-latn-au", zmw: "zmw-latn-cd", zmx: "zmx-latn-cg", zmy: "zmy-latn-au", zmz: "zmz-latn-cd", zna: "zna-latn-td", zne: "zne-latn-zz", zng: "zng-latn-vn", znk: "znk-latn-au", zns: "zns-latn-ng", zoc: "zoc-latn-mx", zoh: "zoh-latn-mx", zom: "zom-latn-in", zoo: "zoo-latn-mx", zoq: "zoq-latn-mx", zor: "zor-latn-mx", zos: "zos-latn-mx", zpa: "zpa-latn-mx", zpb: "zpb-latn-mx", zpc: "zpc-latn-mx", zpd: "zpd-latn-mx", zpe: "zpe-latn-mx", zpf: "zpf-latn-mx", zpg: "zpg-latn-mx", zph: "zph-latn-mx", zpi: "zpi-latn-mx", zpj: "zpj-latn-mx", zpk: "zpk-latn-mx", zpl: "zpl-latn-mx", zpm: "zpm-latn-mx", zpn: "zpn-latn-mx", zpo: "zpo-latn-mx", zpp: "zpp-latn-mx", zpq: "zpq-latn-mx", zpr: "zpr-latn-mx", zps: "zps-latn-mx", zpt: "zpt-latn-mx", zpu: "zpu-latn-mx", zpv: "zpv-latn-mx", zpw: "zpw-latn-mx", zpx: "zpx-latn-mx", zpy: "zpy-latn-mx", zpz: "zpz-latn-mx", zqe: "zqe-hani-cn", "zqe-latn": "zqe-latn-cn", zrn: "zrn-latn-td", zro: "zro-latn-ec", zrp: "zrp-hebr-fr", zrs: "zrs-latn-id", zsa: "zsa-latn-pg", zsr: "zsr-latn-mx", zsu: "zsu-latn-pg", zte: "zte-latn-mx", ztg: "ztg-latn-mx", ztl: "ztl-latn-mx", ztm: "ztm-latn-mx", ztn: "ztn-latn-mx", ztp: "ztp-latn-mx", ztq: "ztq-latn-mx", zts: "zts-latn-mx", ztt: "ztt-latn-mx", ztu: "ztu-latn-mx", ztx: "ztx-latn-mx", zty: "zty-latn-mx", zu: "zu-latn-za", zua: "zua-latn-ng", zuh: "zuh-latn-pg", zum: "zum-arab-om", zun: "zun-latn-us", zuy: "zuy-latn-cm", zyg: "zyg-hani-cn", zyj: "zyj-latn-cn", "zyj-hani": "zyj-hani-cn", zyn: "zyn-hani-cn", zyp: "zyp-latn-mm", zza: "zza-latn-tr", zzj: "zzj-hani-cn" }, Ho = {}.hasOwnProperty;
        function qo(y) {
          const { language: f, script: E, region: v } = y;
          let M;
          var x, z;
          return E && v && (M = Bo[ds({ language: f, script: E, region: v })]) ? (y.script = void 0, y.region = void 0) : E && (M = Bo[ds({ language: f, script: E })]) ? y.script = void 0 : v && (M = Bo[ds({ language: f, region: v })]) ? y.region = void 0 : f && (M = Bo[f]), M && (y.language = void 0, x = y, z = Ga(M), x.language || (x.language = z.language), x.script || (x.script = z.script), x.region || (x.region = z.region), z.variants && x.variants.push(...z.variants)), ds(y);
        }
        function Go(y, f) {
          const E = {}, v = Ga(String(y || "").toLowerCase(), E), M = ds(v);
          if (!M) return M;
          let x = -1;
          for (; ++x < Kl.length; ) {
            let z = Kl[x].from;
            z.slice(0, 4) === "und-" && v.language && (z = v.language + z.slice(3)), Wl(M, z).length > 0 && Cm(v, z, Kl[x].to);
          }
          for (x = -1; ++x < lo.length; ) bd(v, lo[x].from.field, lo[x].from.value) && Ed(v, lo[x].to.field, lo[x].to.value);
          if (function(z) {
            qo(z);
            const { language: O, script: k, region: H } = z;
            if (!O) return z;
            const B = ds({ language: O, script: k, region: H });
            B === qo(Ga(O)) ? (z.script = void 0, z.region = void 0) : H && B === qo(Ga(O + "-" + H)) ? z.script = void 0 : k && B === qo(Ga(O + "-" + k)) && (z.region = void 0);
          }(v), v.variants.sort(), v.extensions.sort(Nm), E.warning) {
            let z;
            for (z in $l) if (Ho.call($l, z)) {
              const O = $l[z], k = v[z];
              if (k && Ho.call(O, k)) {
                const H = O[k];
                E.warning("Deprecated " + z + " `" + k + "`, expected one of `" + H.join("`, `") + "`", -1, 7);
              }
            }
          }
          return v.script && (v.script = v.script.charAt(0).toUpperCase() + v.script.slice(1)), v.region && (v.region = v.region.toUpperCase()), ds(v);
        }
        function Cm(y, f, E) {
          const v = Ga(f), M = Ga(E), x = [], z = v.language;
          let O;
          for (O in v) if (Ho.call(v, O)) {
            const k = v[O];
            k && bd(y, O, k) && x.push(O);
          }
          for (O in M) if (Ho.call(M, O)) {
            const k = M[O];
            z && k && (x.includes(O) || !y[O]) && Ed(y, O, O === "language" && k === "und" ? z : k);
          }
        }
        function bd(y, f, E) {
          let v, M = !1;
          if (E) {
            const x = y[f];
            if (v = x, Array.isArray(x)) {
              v = [];
              let z = -1;
              for (; ++z < x.length; ) {
                const O = x[z];
                E.includes(O) ? M = !0 : v.push(O);
              }
            } else x === E && (v = null, M = !0);
            y[f] = v;
          }
          return M;
        }
        function Ed(y, f, E) {
          const v = y[f];
          if (Array.isArray(v)) {
            const M = Array.isArray(E) ? E : [E];
            let x = -1;
            for (; ++x < M.length; ) {
              const z = M[x];
              v.includes(z) || v.push(z);
            }
          } else y[f] = E;
        }
        function Nm(y, f) {
          return y.singleton > f.singleton ? 1 : y.singleton < f.singleton ? -1 : 0;
        }
        function Xl() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k, H, B, D, N;
          function Y(V) {
            if (!(V && V.currentRepresentation && V.currentRepresentation.mediaInfo && V.currentRepresentation.mediaInfo.type)) return;
            const mt = V.currentRepresentation.mediaInfo.type;
            k[mt] = V.currentRepresentation;
          }
          function J(V, mt) {
            return V && M[mt] && M[mt][V] ? M[mt][V].list : [];
          }
          function it(V, mt) {
            return V && M[mt] && M[mt][V] ? M[mt][V].current : null;
          }
          function lt(V) {
            let mt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!V || !V.streamInfo) return;
            const Mt = V.type, Lt = V.streamInfo.id, Bt = it(Mt, Lt);
            if (M[Lt] && M[Lt][Mt] && (M[Lt][Mt].current = V, M[Lt][Mt].current && (Mt !== q.A.TEXT && !ht(V, Bt) || Mt === q.A.TEXT && V.isFragmented) && f.trigger(et.A.CURRENT_TRACK_CHANGED, { oldMediaInfo: Bt, newMediaInfo: V, switchMode: x.get().streaming.trackSwitchMode[Mt], options: mt }, { streamId: Lt }), !mt.hasOwnProperty("noSettingsSave") || !mt.noSettingsSave)) {
              let Qt = function(Zt) {
                const fe = { lang: Zt.lang, viewpoint: Zt.viewpoint, roles: Zt.roles, accessibility: Zt.accessibility, audioChannelConfiguration: Zt.audioChannelConfiguration, codec: Zt.codec };
                return fe.lang || fe.viewpoint || fe.role && fe.role.length > 0 || fe.accessibility && fe.accessibility.length > 0 || fe.audioChannelConfiguration && fe.audioChannelConfiguration.length > 0 ? fe : null;
              }(V);
              if (!Qt || !M[Lt][Mt].storeLastSettings) return;
              Qt.roles && (Qt.role = Qt.roles[0], delete Qt.roles), Qt.accessibility && (Qt.accessibility = Qt.accessibility[0]), Qt.audioChannelConfiguration && (Qt.audioChannelConfiguration = Qt.audioChannelConfiguration[0]), O[Mt] = Qt, N.setSavedMediaSettings(Mt, Qt);
            }
          }
          function at(V, mt) {
            V && mt && (z[V] = mt);
          }
          function st(V) {
            return V ? z[V] : null;
          }
          function ht(V, mt) {
            if (!V && !mt) return !0;
            if (!V || !mt) return !1;
            const Mt = V.id === mt.id, Lt = JSON.stringify(V.viewpoint) === JSON.stringify(mt.viewpoint), Bt = V.lang === mt.lang, Qt = V.codec === mt.codec, Zt = JSON.stringify(V.roles) === JSON.stringify(mt.roles), fe = JSON.stringify(V.accessibility) === JSON.stringify(mt.accessibility), Ue = JSON.stringify(V.audioChannelConfiguration) === JSON.stringify(mt.audioChannelConfiguration);
            return Mt && Qt && Lt && Bt && Zt && fe && Ue;
          }
          function At() {
            M = {}, O = {}, k = {}, z = { audio: null, video: null, text: null, mesh: null }, f.off(St.A.REPRESENTATION_SWITCH, Y, E);
          }
          function Z(V, mt, Mt) {
            let Lt = [];
            return V.forEach(function(Bt) {
              mt(Mt, Bt) && Lt.push(Bt);
            }), Lt.length !== 0 ? Lt : (v.info("Filter-Function (" + mt.name + ") resulted in no tracks; setting ignored"), V);
          }
          function F(V, mt) {
            try {
              return !V.lang || V.lang instanceof RegExp ? mt.lang.match(V.lang) : mt.lang !== "" && Wl(mt.lang, Go(V.lang)).length > 0;
            } catch {
              return !1;
            }
          }
          function G(V, mt) {
            return V.index === void 0 || V.index === null || mt.index === V.index;
          }
          function K(V, mt) {
            return V.id === void 0 || V.id === null || mt.id === V.id;
          }
          function ft(V, mt) {
            return !V.viewpoint || !!mt.viewpoint.filter(function(Mt) {
              return ct(Mt, V.viewpoint);
            })[0];
          }
          function bt(V, mt) {
            let Mt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            return !V.role || !!mt.roles.filter(function(Lt) {
              return ct(Lt, V.role);
            })[0] || mt.type === q.A.AUDIO && Mt;
          }
          function _t(V, mt) {
            let Mt;
            return Mt = V.accessibility ? !!mt.accessibility.filter(function(Lt) {
              return ct(Lt, V.accessibility);
            })[0] : !mt.accessibility.length, Mt;
          }
          function vt(V, mt) {
            return !V.audioChannelConfiguration || !!mt.audioChannelConfiguration.filter(function(Mt) {
              return ct(Mt, V.audioChannelConfiguration);
            })[0];
          }
          function Pt(V, mt) {
            return !V.codec || V.codec === mt.codec;
          }
          function Ot(V) {
            let mt = 0, Mt = [];
            return V.forEach((Lt) => {
              isNaN(Lt.selectionPriority) || (Lt.selectionPriority > mt ? (mt = Lt.selectionPriority, Mt = [Lt]) : Lt.selectionPriority === mt && Mt.push(Lt));
            }), Mt;
          }
          function W(V) {
            let mt, Mt = 0, Lt = [];
            return V.forEach(function(Bt) {
              mt = Math.max.apply(Math, Bt.bitrateList.map(function(Qt) {
                return Qt.bandwidth;
              })), mt > Mt ? (Mt = mt, Lt = [Bt]) : mt === Mt && Lt.push(Bt);
            }), Lt;
          }
          function tt(V) {
            let mt, Mt = 1 / 0, Lt = [];
            return V.forEach(function(Bt) {
              mt = Bt.bitrateList.reduce(function(Zt, fe) {
                const Ue = Math.max(1, fe.width * fe.height);
                return Zt + fe.bandwidth / Ue;
              }, 0) / Bt.bitrateList.length, mt < Mt ? (Mt = mt, Lt = [Bt]) : mt === Mt && Lt.push(Bt);
            }), Lt;
          }
          function Tt(V) {
            let mt, Mt = 0, Lt = [];
            return V.forEach(function(Bt) {
              mt = Bt.representationCount, mt > Mt ? (Mt = mt, Lt = [Bt]) : mt === Mt && Lt.push(Bt);
            }), Lt;
          }
          function yt(V, mt) {
            if (V === q.A.TEXT) return function(Bt) {
              if (!Bt || Bt.length === 0) return null;
              const Qt = Bt.filter((Zt) => !(Zt && Zt.roles && Zt.roles.length > 0) || Zt.roles.every((fe) => fe.schemeIdUri !== q.A.DASH_ROLE_SCHEME_ID || fe.value !== I.A.FORCED_SUBTITLE));
              return Qt.length > 0 ? Qt[0] : Bt[0];
            }(mt);
            let Mt;
            const Lt = H.getCustomInitialTrackSelectionFunction();
            if (Mt = function(Bt) {
              try {
                let Qt;
                return Qt = function(Zt) {
                  try {
                    const fe = Zt.filter((Ue) => {
                      const Ye = Ue.type;
                      return Ue.bitrateList.some((on) => {
                        const cn = B.getAbrBitrateParameter("maxBitrate", Ye), Nn = B.getAbrBitrateParameter("minBitrate", Ye);
                        return !(cn > -1 && on.bandwidth > 1e3 * cn || Nn > -1 && on.bandwidth < 1e3 * Nn);
                      });
                    });
                    return fe.length > 0 ? fe : Zt;
                  } catch (fe) {
                    return v.error(fe), Zt;
                  }
                }(Bt), Qt = function(Zt) {
                  try {
                    if (!x.get().streaming.abr.limitBitrateByPortal) return Zt;
                    const { elementWidth: fe } = D.getVideoElementSize(), Ue = Zt.filter((Ye) => Ye.type !== q.A.VIDEO || Ye.bitrateList.some((on) => on.width <= fe));
                    return Ue.length > 0 ? Ue : Zt;
                  } catch (fe) {
                    return v.error(fe), Zt;
                  }
                }(Qt), Qt;
              } catch (Qt) {
                return v.error(Qt), Bt;
              }
            }(mt), Lt && typeof Lt == "function") Mt = Lt(Mt);
            else if (k[V]) Mt = function(Bt, Qt) {
              if (!Bt || Bt.length === 0 || !Qt || !k[Qt]) return Bt;
              const Zt = k[Qt].bandwidth;
              if (!Zt || isNaN(Zt)) return Bt;
              let fe = { min: NaN, track: null };
              return Bt.forEach((Ue) => {
                Ue.bitrateList.forEach((Ye) => {
                  const on = Math.abs(Ye.bandwidth - Zt);
                  (isNaN(fe.min) || on < fe.min) && (fe.min = on, fe.track = Ue);
                });
              }), fe.track ? [fe.track] : Bt;
            }(Mt, V);
            else {
              let Bt = x.get().streaming.selectionModeForInitialTrack;
              switch (Bt) {
                case q.A.TRACK_SELECTION_MODE_HIGHEST_SELECTION_PRIORITY:
                  Mt = function(Qt) {
                    let Zt = Ot(Qt);
                    return Zt.length > 1 && (Zt = tt(Zt)), Zt.length > 1 && (Zt = W(Zt)), Zt.length > 1 && (Zt = Tt(Zt)), Zt;
                  }(Mt);
                  break;
                case q.A.TRACK_SELECTION_MODE_HIGHEST_BITRATE:
                  Mt = function(Qt) {
                    let Zt = W(Qt);
                    return Zt.length > 1 && (Zt = Tt(Zt)), Zt;
                  }(Mt);
                  break;
                case q.A.TRACK_SELECTION_MODE_FIRST_TRACK:
                  Mt = nt(Mt);
                  break;
                case q.A.TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY:
                  Mt = function(Qt) {
                    let Zt = tt(Qt);
                    return Zt.length > 1 && (Zt = W(Zt)), Zt;
                  }(Mt);
                  break;
                case q.A.TRACK_SELECTION_MODE_WIDEST_RANGE:
                  Mt = function(Qt) {
                    let Zt = Tt(Qt);
                    return Zt.length > 1 && (Zt = W(Qt)), Zt;
                  }(Mt);
                  break;
                default:
                  v.warn(`Track selection mode ${Bt} is not supported. Falling back to TRACK_SELECTION_MODE_FIRST_TRACK`), Mt = nt(Mt);
              }
            }
            return Mt.length > 0 ? Mt[0] : mt[0];
          }
          function nt(V) {
            return V[0];
          }
          function ct(V, mt) {
            return !(!V || !mt) && JSON.stringify({ schemeIdUri: V.schemeIdUri, value: V.value }) === JSON.stringify({ schemeIdUri: mt.schemeIdUri, value: mt.value });
          }
          return E = { addTrack: function(V) {
            if (!V) return;
            const mt = V.type;
            if ((Mt = mt) !== q.A.MESH && Mt !== q.A.AUDIO && Mt !== q.A.VIDEO && Mt !== q.A.TEXT && Mt !== q.A.IMAGE) return;
            var Mt;
            let Lt = V.streamInfo.id;
            M[Lt] || (M[Lt] = function() {
              const Qt = x.get().streaming.saveLastMediaSettingsForCurrentStreamingSession;
              return { mesh: { list: [], storeLastSettings: !0, current: null }, audio: { list: [], storeLastSettings: Qt, current: null }, video: { list: [], storeLastSettings: Qt, current: null }, text: { list: [], storeLastSettings: Qt, current: null }, image: { list: [], storeLastSettings: Qt, current: null } };
            }());
            const Bt = M[Lt][mt].list;
            for (let Qt = 0, Zt = Bt.length; Qt < Zt; ++Qt) if (ht(Bt[Qt], V)) return;
            Bt.push(V);
          }, areTracksEqual: ht, clearDataForStream: function(V) {
            M[V] && delete M[V];
          }, getCurrentTrackFor: it, getInitialSettings: st, getTracksFor: J, getTracksWithHighestSelectionPriority: Ot, getTracksWithHighestBitrate: W, getTracksWithHighestEfficiency: tt, getTracksWithWidestRange: Tt, initialize: function() {
            f.on(St.A.REPRESENTATION_SWITCH, Y, E);
          }, isCurrentTrack: function(V) {
            if (!V) return !1;
            const mt = V.type, Mt = V.streamInfo.id;
            return M[Mt] && M[Mt][mt] && ht(M[Mt][mt].current, V);
          }, matchSettings: function(V, mt) {
            let Mt = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            try {
              let Lt = !1;
              if (V.lang) {
                if (V.lang instanceof RegExp) Lt = mt.lang.match(V.lang);
                else if (mt.lang !== "") {
                  const Ye = Go(V.lang);
                  Ye && (Lt = Wl(mt.lang, Ye).length > 0);
                }
              } else Lt = !0;
              const Bt = V.index === void 0 || V.index === null || mt.index === V.index, Qt = !V.viewpoint || !!mt.viewpoint.filter(function(Ye) {
                return ct(Ye, V.viewpoint);
              })[0], Zt = !V.role || !!mt.roles.filter(function(Ye) {
                return ct(Ye, V.role);
              })[0];
              let fe = !V.accessibility || !!mt.accessibility.filter(function(Ye) {
                return ct(Ye, V.accessibility);
              })[0], Ue = !V.audioChannelConfiguration || !!mt.audioChannelConfiguration.filter(function(Ye) {
                return ct(Ye, V.audioChannelConfiguration);
              })[0];
              return Lt && Bt && Qt && (Zt || mt.type === q.A.AUDIO && Mt) && fe && Ue;
            } catch {
              return !1;
            }
          }, matchSettingsAccessibility: _t, matchSettingsAudioChannelConfig: vt, matchSettingsIndex: G, matchSettingsLang: F, matchSettingsRole: bt, matchSettingsViewPoint: ft, reset: At, saveTextSettingsDisabled: function() {
            N.setSavedMediaSettings(q.A.TEXT, null);
          }, selectInitialTrack: yt, setConfig: function(V) {
            V && (V.domStorage && (N = V.domStorage), V.settings && (x = V.settings), V.customParametersModel && (H = V.customParametersModel), V.mediaPlayerModel && (B = V.mediaPlayerModel), V.videoModel && (D = V.videoModel));
          }, setInitialMediaSettingsForType: function(V, mt) {
            let Mt = O[V] || st(V);
            const Lt = J(V, mt.id);
            let Bt = [];
            Mt && Object.keys(Mt).length !== 0 || (Mt = N.getSavedMediaSettings(V), Mt && delete Mt.codec, at(V, Mt)), Lt && Lt.length !== 0 && (Mt && (Bt = Array.from(Lt), v.info("Filtering " + Bt.length + " " + V + " tracks based on settings"), Bt = Z(Bt, K, Mt), Bt = Z(Bt, F, Mt), Bt = Z(Bt, G, Mt), Bt = Z(Bt, ft, Mt), V === q.A.AUDIO && O[V] || (Bt = Z(Bt, bt, Mt)), Bt = Z(Bt, _t, Mt), Bt = Z(Bt, vt, Mt), Bt = Z(Bt, Pt, Mt), v.info("Filtering " + V + " tracks ended, found " + Bt.length + " matching track(s).")), Bt.length === 0 ? lt(yt(V, Lt)) : Bt.length > 1 ? lt(yt(V, Bt)) : lt(Bt[0]));
          }, setInitialSettings: at, setTrack: lt }, v = (0, ae.A)(y).getInstance().getLogger(E), At(), E;
        }
        Xl.__dashjs_factory_name = "MediaController";
        const vd = Dt.A.getSingletonFactory(Xl);
        Dt.A.updateSingletonFactory(Xl.__dashjs_factory_name, vd);
        var Pm = vd;
        const Vo = NaN;
        class Td {
          constructor(f, E) {
            this.data = { baseUrls: f || null, selectedIdx: E || Vo }, this.children = [];
          }
        }
        function wd() {
          let y, f, E, v;
          const M = this.context, x = (0, di.A)(M).getInstance();
          function z(B, D, N) {
            const Y = O(N);
            B[D] ? x.areEqual(Y, B[D].data.baseUrls) || (B[D].data.baseUrls = Y, B[D].data.selectedIdx = Vo) : B[D] = new Td(Y);
          }
          function O(B) {
            let D = E.getBaseURLsFromElement(B);
            const N = v.getSynthesizedBaseUrlElements(D);
            return N && N.length > 0 && (D = D.concat(N)), D;
          }
          function k(B, D) {
            const N = D || f;
            B(N.data), N.children && N.children.forEach((Y) => k(B, Y));
          }
          function H() {
            f = new Td();
          }
          return y = { reset: H, update: function(B) {
            (function(D) {
              (function() {
                if (!E || !E.hasOwnProperty("getBaseURLsFromElement") || !E.hasOwnProperty("getRepresentationSortFunction")) throw new Error("setConfig function has to be called previously");
              })();
              const N = O(D);
              x.areEqual(N, f.data.baseUrls) || (f.data.baseUrls = N, f.data.selectedIdx = Vo), D && D.Period && D.Period.forEach((Y, J) => {
                z(f.children, J, Y), Y.AdaptationSet && Y.AdaptationSet.forEach((it, lt) => {
                  z(f.children[J].children, lt, it), it.Representation && it.Representation.sort(E.getRepresentationSortFunction()).forEach((at, st) => {
                    z(f.children[J].children[lt].children, st, at);
                  });
                });
              });
            })(B);
          }, getForPath: function(B) {
            let D = f;
            const N = [D.data];
            return B && B.forEach((Y) => {
              D = D.children[Y], D && N.push(D.data);
            }), N.filter((Y) => Y.baseUrls.length);
          }, invalidateSelectedIndexes: function(B) {
            k((D) => {
              isNaN(D.selectedIdx) || B === D.baseUrls[D.selectedIdx].serviceLocation && (D.selectedIdx = Vo);
            });
          }, setConfig: function(B) {
            B.adapter && (E = B.adapter), B.contentSteeringController && (v = B.contentSteeringController);
          }, getBaseUrls: function(B) {
            return O(B);
          } }, H(), y;
        }
        wd.__dashjs_factory_name = "BaseURLTreeModel";
        var zm = Dt.A.getClassFactory(wd);
        function Ad(y) {
          let f;
          const E = (y = y || {}).blacklistController;
          return f = { select: function(v) {
            return v && function(M) {
              let x, z, O = 0, k = [], H = 0;
              if (z = M.sort(function(B, D) {
                let N = B.dvbPriority - D.dvbPriority;
                return isNaN(N) ? 0 : N;
              }).filter(function(B, D, N) {
                return !D || N[0].dvbPriority && B.dvbPriority && N[0].dvbPriority === B.dvbPriority;
              }), z.length) return z.length > 1 && (z.forEach((B) => {
                O += B.dvbWeight, k.push(O);
              }), x = Math.floor(Math.random() * (O - 1)), k.every((B, D) => (H = D, !(x < B)))), z[H];
            }(function(M) {
              let x = [];
              return M.filter(function(z) {
                return !E.contains(z.serviceLocation) || (z.dvbPriority && x.push(z.dvbPriority), !1);
              }).filter(function(z) {
                return !x.length || !z.dvbPriority || x.indexOf(z.dvbPriority) === -1;
              });
            }(v));
          } }, f;
        }
        Ad.__dashjs_factory_name = "DVBSelector";
        var Om = Dt.A.getClassFactory(Ad);
        function Sd(y) {
          let f;
          const E = (y = y || {}).blacklistController;
          return f = { select: function(v) {
            let M, x = 0;
            return v && v.some((z, O) => (x = O, !E.contains(z.serviceLocation))) && (M = v[x]), M;
          } }, f;
        }
        Sd.__dashjs_factory_name = "BasicSelector";
        var Ym = Dt.A.getClassFactory(Sd);
        function Md() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x = [];
          function z() {
            let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], H = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], B = 0, D = NaN;
            for (; B < k.length; ) {
              const N = k[B], Y = H.findIndex((J) => J.serviceLocation && J.serviceLocation === N);
              if (Y !== -1 && !M.contains(H[Y].serviceLocation)) {
                D = Y;
                break;
              }
              B += 1;
            }
            return D;
          }
          function O(k) {
            const H = v.getCurrentSteeringResponseData();
            if (!H) return;
            const B = k.entry, D = setTimeout(() => {
              M.remove(B), x.splice(x.indexOf(D, 1));
            }, 1e3 * H.ttl);
            x.push(D);
          }
          return E = { selectBaseUrlIndex: function(k) {
            let H = NaN;
            if (isNaN(k.selectedIdx)) {
              const D = v.getSteeringDataFromManifest();
              D && D.defaultServiceLocationArray.length > 0 && (H = z(D.defaultServiceLocationArray, k.baseUrls));
            }
            const B = v.getCurrentSteeringResponseData();
            return k.baseUrls && k.baseUrls.length && B && B.pathwayPriority && B.pathwayPriority.length && (H = z(B.pathwayPriority, k.baseUrls)), H;
          }, setConfig: function(k) {
            k.blacklistController && (M = k.blacklistController), k.contentSteeringController && (v = k.contentSteeringController), f.on(k.addBlacklistEventName, O, E);
          }, reset: function() {
            x.forEach((k) => clearTimeout(k)), x = [];
          } }, v = Ut(y).getInstance(), E;
        }
        Md.__dashjs_factory_name = "ContentSteeringSelector";
        var Fm = Dt.A.getClassFactory(Md);
        function kd() {
          const y = this.context, f = (0, It.A)(y).getInstance(), E = (0, Q.A)(y).getInstance();
          let v, M, x, z, O, k;
          function H() {
            O.reset(), M.reset();
          }
          return v = { chooseSelector: function(B) {
            (0, pe.sq)(B, "boolean"), k = B ? z : x;
          }, select: function(B) {
            if (!B) return;
            if (E.get().streaming.applyContentSteering) {
              const N = O.selectBaseUrlIndex(B);
              isNaN(N) || N === -1 || (B.selectedIdx = N);
            }
            if (!isNaN(B.selectedIdx)) return B.baseUrls[B.selectedIdx];
            let D = k.select(B.baseUrls);
            return D ? (B.selectedIdx = B.baseUrls.indexOf(D), D) : (f.trigger(et.A.URL_RESOLUTION_FAILED, { error: new Yt.A(X.URL_RESOLUTION_FAILED_GENERIC_ERROR_CODE, X.URL_RESOLUTION_FAILED_GENERIC_ERROR_MESSAGE) }), void (k === x && H()));
          }, reset: H, setConfig: function(B) {
            B.selector && (k = B.selector), B.contentSteeringSelector && (O = B.contentSteeringSelector);
          } }, M = fa(y).create({ updateEventName: et.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, addBlacklistEventName: et.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD }), x = Ym(y).create({ blacklistController: M }), z = Om(y).create({ blacklistController: M }), O = Fm(y).create(), O.setConfig({ blacklistController: M, addBlacklistEventName: et.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_ADD }), k = x, v;
        }
        kd.__dashjs_factory_name = "BaseURLSelector";
        var Um = Dt.A.getClassFactory(kd);
        function xd() {
          let y, f;
          const E = this.context, v = (0, It.A)(E).getInstance(), M = Se(E).getInstance();
          let x, z, O;
          function k(B) {
            x.update(B), z.chooseSelector(f.getIsDVB(B)), v.trigger(St.A.BASE_URLS_UPDATED, { baseUrls: H(B) });
          }
          function H(B) {
            return x.getBaseUrls(B);
          }
          return y = { reset: function() {
            x.reset(), z.reset();
          }, initialize: function(B) {
            x.setConfig({ adapter: f, contentSteeringController: O }), k(B);
          }, resolve: function(B) {
            const D = x.getForPath(B).reduce((N, Y) => {
              const J = z.select(Y);
              return J ? (M.isRelative(J.url) ? N.url = M.resolve(J.url, N.url) : (N.url = J.url, N.serviceLocation = J.serviceLocation), N.availabilityTimeOffset = Yi(J.availabilityTimeOffset), N.availabilityTimeComplete = J.availabilityTimeComplete, N.queryParams = J.queryParams, N) : new qr();
            }, new qr());
            if (!M.isRelative(D.url)) return D;
          }, setConfig: function(B) {
            B.baseURLTreeModel && (x = B.baseURLTreeModel), B.baseURLSelector && (z = B.baseURLSelector), B.adapter && (f = B.adapter), B.contentSteeringController && (O = B.contentSteeringController);
          }, getBaseUrls: H, update: k }, x = zm(E).create(), z = Um(E).create(), v.on(et.A.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, function(B) {
            x.invalidateSelectedIndexes(B.entry);
          }, y), y;
        }
        xd.__dashjs_factory_name = "BaseURLController";
        var jm = Dt.A.getClassFactory(xd), Ld = class extends ze {
          constructor(y, f) {
            super(), this.url = y || null, this.type = f || null, this.mediaType = q.A.STREAM, this.responseType = "";
          }
        };
        function Dd(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance();
          let v, M = Ha(f).create({ errHandler: y.errHandler, dashMetrics: y.dashMetrics, mediaPlayerModel: y.mediaPlayerModel, errors: X });
          return v = { load: function(x, z, O) {
            const k = function(H, B) {
              z.resolved = !0, z.resolvedContent = H || null, E.trigger(et.A.XLINK_ELEMENT_LOADED, { element: z, resolveObject: O, error: H || B ? null : new Yt.A(X.XLINK_LOADER_LOADING_FAILURE_ERROR_CODE, X.XLINK_LOADER_LOADING_FAILURE_ERROR_MESSAGE + x) });
            };
            if (x === "urn:mpeg:dash:resolve-to-zero:2013") k(null, !0);
            else {
              const H = new Ld(x, Ct.G.XLINK_EXPANSION_TYPE);
              M.load({ request: H, success: function(B) {
                k(B);
              }, error: function() {
                k(null);
              } });
            }
          }, reset: function() {
            M && (M.abort(), M = null);
          } }, v;
        }
        Dd.__dashjs_factory_name = "XlinkLoader";
        var Bm = Dt.A.getClassFactory(Dd);
        const Ms = "onLoad";
        function Id(y) {
          y = y || {};
          let f = this.context, E = (0, It.A)(f).getInstance();
          const v = Se(f).getInstance();
          let M, x, z, O;
          function k(Y, J, it) {
            let lt, at, st = {};
            st.elements = Y, st.type = J, st.resolveType = it, st.elements.length === 0 && B(st);
            for (let ht = 0; ht < st.elements.length; ht++) lt = st.elements[ht], at = v.isHTTPURL(lt.url) ? lt.url : lt.originalContent.BaseURL + lt.url, O.load(at, lt, st);
          }
          function H(Y) {
            let J, it, lt = "";
            if (J = Y.element, it = Y.resolveObject, J.resolvedContent) {
              let at = 0;
              J.resolvedContent.indexOf("<?xml") === 0 && (at = J.resolvedContent.indexOf("?>") + 2), lt = J.resolvedContent.substr(0, at) + "<response>" + J.resolvedContent.substr(at) + "</response>", J.resolvedContent = x.parseXml(lt).response;
            }
            (function(at) {
              let st, ht;
              for (st = 0; st < at.elements.length; st++) if (ht = at.elements[st], ht.resolved === !1) return !1;
              return !0;
            })(it) && B(it);
          }
          function B(Y) {
            let J, it, lt = [];
            if (function(at) {
              let st, ht, At, Z, F, G, K = [];
              for (Z = at.elements.length - 1; Z >= 0; Z--) {
                if (st = at.elements[Z], ht = st.type, st.resolvedContent) {
                  if (st.resolvedContent) for (F = 0; F < st.resolvedContent[ht].length; F++) At = st.resolvedContent[ht][F], K.push(At);
                } else delete st.originalContent["xlink:actuate"], delete st.originalContent["xlink:href"], K.push(st.originalContent);
                for (st.parentElement[ht].splice(st.index, 1), G = 0; G < K.length; G++) st.parentElement[ht].splice(st.index + G, 0, K[G]);
                K = [];
              }
              at.elements.length > 0 && x.getIron().run(z);
            }(Y), Y.resolveType === "onActuate" && E.trigger(et.A.XLINK_READY, { manifest: z }), Y.resolveType === Ms) switch (Y.type) {
              case I.A.PERIOD:
                for (J = 0; J < z[I.A.PERIOD].length; J++) it = z[I.A.PERIOD][J], it.hasOwnProperty(I.A.ADAPTATION_SET) && (lt = lt.concat(D(it[I.A.ADAPTATION_SET], it, I.A.ADAPTATION_SET, Ms))), it.hasOwnProperty(I.A.EVENT_STREAM) && (lt = lt.concat(D(it[I.A.EVENT_STREAM], it, I.A.EVENT_STREAM, Ms)));
                k(lt, I.A.ADAPTATION_SET, Ms);
                break;
              case I.A.ADAPTATION_SET:
                E.trigger(et.A.XLINK_READY, { manifest: z });
            }
          }
          function D(Y, J, it, lt) {
            let at, st, ht, At = [];
            for (st = Y.length - 1; st >= 0; st--) at = Y[st], at.hasOwnProperty("xlink:href") && at["xlink:href"] === "urn:mpeg:dash:resolve-to-zero:2013" && Y.splice(st, 1);
            for (st = 0; st < Y.length; st++) at = Y[st], at.hasOwnProperty("xlink:href") && at.hasOwnProperty("xlink:actuate") && at["xlink:actuate"] === lt && (ht = N(at["xlink:href"], J, it, st, lt, at), At.push(ht));
            return At;
          }
          function N(Y, J, it, lt, at, st) {
            return { url: Y, parentElement: J, type: it, index: lt, resolveType: at, originalContent: st, resolvedContent: null, resolved: !1 };
          }
          return M = { resolveManifestOnLoad: function(Y) {
            let J;
            z = Y, z.Period ? (J = D(z.Period, z, I.A.PERIOD, Ms), k(J, I.A.PERIOD, Ms)) : E.trigger(et.A.XLINK_READY, { manifest: z });
          }, setParser: function(Y) {
            Y && (x = Y);
          }, reset: function() {
            E.off(et.A.XLINK_ELEMENT_LOADED, H, M), O && (O.reset(), O = null);
          } }, E.on(et.A.XLINK_ELEMENT_LOADED, H, M), O = Bm(f).create({ errHandler: y.errHandler, dashMetrics: y.dashMetrics, mediaPlayerModel: y.mediaPlayerModel, settings: y.settings }), M;
        }
        Id.__dashjs_factory_name = "XlinkController";
        var Hm = Dt.A.getClassFactory(Id);
        function Rd(y) {
          function f(M, x) {
            for (let z in M) x.hasOwnProperty(z) || (x[z] = M[z]);
          }
          function E(M, x, z) {
            for (let O = 0, k = M.length; O < k; ++O) {
              const H = M[O];
              if (x[H.name]) if (z[H.name]) {
                if (H.merge) {
                  const B = x[H.name], D = z[H.name];
                  typeof B == "object" && typeof D == "object" ? f(B, D) : z[H.name] = B + D;
                }
              } else z[H.name] = x[H.name];
            }
          }
          function v(M, x) {
            for (let z = 0, O = M.children.length; z < O; ++z) {
              const k = M.children[z], H = x[k.name];
              if (H) for (let B = 0, D = H.length; B < D; ++B) {
                const N = H[B];
                E(M.properties, x, N), v(k, N);
              }
            }
          }
          return { run: function(M) {
            if (M === null || typeof M != "object") return M;
            if (M.Period && "period" in y) {
              const x = y.period, z = M.Period;
              for (let O = 0, k = z.length; O < k; ++O) {
                const H = z[O];
                if (v(x, H), "adaptationset" in y) {
                  const B = H.AdaptationSet;
                  if (B) {
                    const D = y.adaptationset;
                    for (let N = 0, Y = B.length; N < Y; ++N) v(D, B[N]);
                  }
                }
              }
            }
            return M;
          } };
        }
        Rd.__dashjs_factory_name = "ObjectIron";
        var qm = Dt.A.getClassFactory(Rd), Wo = class {
          constructor(y, f) {
            this._test = y, this._converter = f;
          }
          get test() {
            return this._test;
          }
          get converter() {
            return this._converter;
          }
        };
        const Cd = /^([-])?P(([\d.]*)Y)?(([\d.]*)M)?(([\d.]*)D)?T?(([\d.]*)H)?(([\d.]*)M)?(([\d.]*)S)?/;
        var Gm = class extends Wo {
          constructor() {
            super((y, f, E) => {
              const v = [I.A.MIN_BUFFER_TIME, I.A.MEDIA_PRESENTATION_DURATION, I.A.MINIMUM_UPDATE_PERIOD, I.A.TIMESHIFT_BUFFER_DEPTH, I.A.MAX_SEGMENT_DURATION, I.A.MAX_SUBSEGMENT_DURATION, I.A.SUGGESTED_PRESENTATION_DELAY, I.A.START, q.A.START_TIME, I.A.DURATION], M = v.length;
              for (let x = 0; x < M; x++) if (f === v[x]) return Cd.test(E);
              return !1;
            }, (y) => {
              const f = Cd.exec(y);
              let E = 31536e3 * parseFloat(f[3] || 0) + 2592e3 * parseFloat(f[5] || 0) + 86400 * parseFloat(f[7] || 0) + 3600 * parseFloat(f[9] || 0) + 60 * parseFloat(f[11] || 0) + parseFloat(f[13] || 0);
              return f[1] !== void 0 && (E = -E), E;
            });
          }
        };
        const Nd = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\.[0-9]*)?)?(?:([+-])([0-9]{2})(?::?)([0-9]{2}))?/;
        var Vm = class extends Wo {
          constructor() {
            super((y, f, E) => Nd.test(E), (y) => {
              const f = Nd.exec(y);
              let E;
              if (E = Date.UTC(parseInt(f[1], 10), parseInt(f[2], 10) - 1, parseInt(f[3], 10), parseInt(f[4], 10), parseInt(f[5], 10), f[6] && parseInt(f[6], 10) || 0, f[7] && 1e3 * parseFloat(f[7]) || 0), f[9] && f[10]) {
                const v = 60 * parseInt(f[9], 10) + parseInt(f[10], 10);
                E += (f[8] === "+" ? -1 : 1) * v * 60 * 1e3;
              }
              return new Date(E);
            });
          }
        };
        const Wm = /^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/, Km = [I.A.ID];
        var $m = class extends Wo {
          constructor() {
            super((y, f, E) => Wm.test(E) && Km.indexOf(f) === -1, (y) => parseFloat(y));
          }
        }, Xm = class extends Wo {
          constructor() {
            super((y, f) => {
              const E = { [I.A.ADAPTATION_SET]: [I.A.LANG], [I.A.REPRESENTATION]: [I.A.LANG], [I.A.CONTENT_COMPONENT]: [I.A.LANG], [I.A.LABEL]: [I.A.LANG], [I.A.GROUP_LABEL]: [I.A.LANG] };
              if (E.hasOwnProperty(y)) {
                let v = E[y];
                return v !== void 0 && v.indexOf(f) >= 0;
              }
              return !1;
            }, (y) => Go(y) || String(y));
          }
        }, Qm = class {
          constructor(y) {
            var f;
            this._name = y, this._merge = (f = y) && f.length && f.charAt(0) === f.charAt(0).toUpperCase();
          }
          get name() {
            return this._name;
          }
          get merge() {
            return this._merge;
          }
        }, ks = class {
          constructor(y, f, E) {
            this._name = y || "", this._properties = [], this._children = E || [], Array.isArray(f) && f.forEach((v) => {
              this._properties.push(new Qm(v));
            });
          }
          get name() {
            return this._name;
          }
          get children() {
            return this._children;
          }
          get properties() {
            return this._properties;
          }
        }, Jm = class extends ks {
          constructor() {
            const y = [I.A.PROFILES, I.A.WIDTH, I.A.HEIGHT, I.A.SAR, I.A.FRAMERATE, I.A.AUDIO_SAMPLING_RATE, I.A.MIME_TYPE, I.A.SEGMENT_PROFILES, I.A.CODECS, I.A.MAXIMUM_SAP_PERIOD, I.A.START_WITH_SAP, I.A.MAX_PLAYOUT_RATE, I.A.CODING_DEPENDENCY, I.A.SCAN_TYPE, I.A.FRAME_PACKING, I.A.AUDIO_CHANNEL_CONFIGURATION, I.A.CONTENT_PROTECTION, I.A.INBAND_EVENT_STREAM];
            super(I.A.ADAPTATION_SET, y, [new ks(I.A.REPRESENTATION, y, [new ks(I.A.SUB_REPRESENTATION, y)])]);
          }
        }, Zm = class extends ks {
          constructor() {
            const y = [I.A.SEGMENT_BASE, I.A.SEGMENT_TEMPLATE, I.A.SEGMENT_LIST];
            super(I.A.PERIOD, y, [new ks(I.A.ADAPTATION_SET, y, [new ks(I.A.REPRESENTATION, y)])]);
          }
        };
        const Pd = { "&amp;": "&", "&gt;": ">", "&lt;": "<", "&quot;": '"', "&apos;": "'" };
        function zd(y, f) {
          const E = f.split(/(&[#a-zA-Z0-9]+;)/);
          if (E.length <= 1) return f;
          for (let v = 1; v < E.length; v += 2) {
            const M = E[v];
            if (M.charAt(1) === "#") {
              let x;
              x = M.charAt(2) === "x" ? parseInt(M.substring(3, M.length - 1), 16) : parseInt(M.substring(2, M.length - 1), 10), !isNaN(x) && x >= 0 && x <= 1114111 && (E[v] = String.fromCodePoint(x));
            } else y.hasOwnProperty(M) && (E[v] = y[M]);
          }
          return E.join("");
        }
        function tp(y, f) {
          var E = (f = f || {}).pos || 0, v = !!f.keepComments, M = !!f.keepWhitespace, x = f.attrMatchers || [], z = f.nodesAsArray || [], O = "<", k = 60, H = ">", B = 62, D = 45, N = 47, Y = 33, J = 39, it = 34, lt = 91, at = 93;
          function st(bt, _t) {
            for (var vt = []; y[E]; ) if (y.charCodeAt(E) == k) {
              if (y.charCodeAt(E + 1) === N) {
                var Pt = E + 2;
                if (E = y.indexOf(H, E), y.substring(Pt, E).indexOf(bt) == -1) {
                  var Ot = y.substring(0, E).split(`
`);
                  throw new Error(`Unexpected close tag
Line: ` + (Ot.length - 1) + `
Column: ` + (Ot[Ot.length - 1].length + 1) + `
Char: ` + y[E]);
                }
                return E + 1 && (E += 1), vt;
              }
              if (y.charCodeAt(E + 1) === Y) {
                if (y.charCodeAt(E + 2) == D) {
                  const ct = E;
                  for (; E !== -1 && (y.charCodeAt(E) !== B || y.charCodeAt(E - 1) != D || y.charCodeAt(E - 2) != D || E == -1); ) E = y.indexOf(H, E + 1);
                  E === -1 && (E = y.length), v && vt.push(y.substring(ct, E + 1));
                } else {
                  if (y.charCodeAt(E + 2) === lt && y.charCodeAt(E + 8) === lt && y.substr(E + 3, 5).toLowerCase() === "cdata") {
                    var W = y.indexOf("]]>", E);
                    W == -1 ? (vt.push(y.substr(E + 9)), E = y.length) : (vt.push(y.substring(E + 9, W)), E = W + 3);
                    continue;
                  }
                  {
                    const ct = E + 1;
                    E += 2;
                    for (var tt = !1; (y.charCodeAt(E) !== B || tt === !0) && y[E]; ) y.charCodeAt(E) === lt ? tt = !0 : tt === !0 && y.charCodeAt(E) === at && (tt = !1), E++;
                    vt.push(y.substring(ct, E));
                  }
                }
                E++;
                continue;
              }
              var Tt = G();
              if (vt.push(Tt), Tt.tagName[0] === "?" && (vt.push(...Tt.children), Tt.children = []), _t) {
                let ct = Tt.tagName;
                z.indexOf(ct) !== -1 ? (_t[ct] || (_t[ct] = []), _t[ct].push(Tt)) : _t[ct] = Tt;
              }
            } else {
              var yt = (nt = void 0, nt = E, (E = y.indexOf(O, E) - 1) == -2 && (E = y.length), zd(Pd, y.slice(nt, E + 1)));
              M || (yt = yt.trim()), _t ? _t.__text = yt : vt.push(yt), E++;
            }
            var nt;
            return vt;
          }
          function ht(bt, _t, vt) {
            if (bt === "S") return parseInt(vt);
            let Pt = zd(Pd, vt);
            return x.forEach((Ot) => {
              Ot.test(bt, _t, vt) && (Pt = Ot.converter(vt));
            }), Pt;
          }
          var At = `\r
	>/= `;
          function Z() {
            for (var bt = E; At.indexOf(y[E]) === -1 && y[E]; ) E++;
            return y.slice(bt, E);
          }
          var F = f.noChildNodes || ["img", "br", "input", "meta", "link", "hr"];
          function G() {
            E++;
            const bt = Z();
            let _t = [], vt = { tagName: bt }, Pt = vt.tagName.indexOf(":");
            for (Pt !== -1 && (vt.__prefix = vt.tagName.substr(0, Pt), vt.tagName = vt.tagName.substr(Pt + 1)); y.charCodeAt(E) !== B && y[E]; ) {
              var Ot = y.charCodeAt(E);
              if (Ot > 64 && Ot < 91 || Ot > 96 && Ot < 123) {
                for (var W = Z(), tt = y.charCodeAt(E); tt && tt !== J && tt !== it && !(tt > 64 && tt < 91 || tt > 96 && tt < 123) && tt !== B; ) E++, tt = y.charCodeAt(E);
                if (tt === J || tt === it) {
                  var Tt = (yt = void 0, nt = void 0, yt = y[E], nt = E + 1, E = y.indexOf(yt, nt), y.slice(nt, E));
                  if (E === -1) return vt;
                } else Tt = null, E--;
                Tt = ht(vt.tagName, W, Tt), vt[W] = Tt;
              }
              E++;
            }
            var yt, nt;
            if (y.charCodeAt(E - 1) !== N) if (bt == "script") {
              var ct = E + 1;
              E = y.indexOf("<\/script>", E), _t = [y.slice(ct, E)], E += 9;
            } else bt == "style" ? (ct = E + 1, E = y.indexOf("</style>", E), _t = [y.slice(ct, E)], E += 8) : F.indexOf(bt) === -1 ? (E++, _t = st(bt, vt)) : E++;
            else E++;
            return vt.__children = _t, vt;
          }
          var K, ft = null;
          if (f.attrValue !== void 0) for (f.attrName = f.attrName || "id", ft = []; K = new RegExp("\\s" + f.attrName + `\\s*=['"]` + f.attrValue + `['"]`).exec(y), (E = K ? K.index : -1) !== -1; ) (E = y.lastIndexOf("<", E)) !== -1 && ft.push(G()), y = y.substr(E), E = 0;
          else ft = f.parseNode ? G() : st("");
          return f.filter && (ft = Yd(ft, f.filter)), f.simplify ? Od(Array.isArray(ft) ? ft : [ft]) : (f.setPos && (ft.pos = E), ft);
        }
        function Od(y) {
          var f = {};
          if (!y.length) return "";
          if (y.length === 1 && typeof y[0] == "string") return y[0];
          for (var E in y.forEach(function(v) {
            if (typeof v == "object") {
              f[v.tagName] || (f[v.tagName] = []);
              var M = Od(v.children);
              f[v.tagName].push(M), Object.keys(v.attributes).length && typeof M != "string" && (M._attributes = v.attributes);
            }
          }), f) f[E].length == 1 && (f[E] = f[E][0]);
          return f;
        }
        function Yd(y, f) {
          let E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, v = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
          var M = [];
          return y.forEach(function(x, z) {
            if (typeof x == "object" && f(x, z, E, v) && M.push(x), x.children) {
              var O = Yd(x.children, f, E + 1, (v ? v + "." : "") + z + "." + x.tagName);
              M = M.concat(O);
            }
          }), M;
        }
        const ep = [I.A.PERIOD, I.A.BASE_URL, I.A.ADAPTATION_SET, I.A.REPRESENTATION, I.A.CONTENT_PROTECTION, I.A.ROLE, I.A.ACCESSIBILITY, I.A.AUDIO_CHANNEL_CONFIGURATION, I.A.CONTENT_COMPONENT, I.A.ESSENTIAL_PROPERTY, I.A.LABEL, I.A.S, I.A.SEGMENT_URL, I.A.EVENT, I.A.EVENT_STREAM, I.A.LOCATION, I.A.SERVICE_DESCRIPTION, I.A.SUPPLEMENTAL_PROPERTY, I.A.METRICS, I.A.REPORTING, I.A.PATCH_LOCATION, I.A.REPLACE, I.A.ADD, I.A.REMOVE, I.A.UTC_TIMING, I.A.INBAND_EVENT_STREAM, I.A.PRODUCER_REFERENCE_TIME, I.A.CONTENT_STEERING];
        function Fd(y) {
          y = y || {};
          const f = this.context, E = y.debug;
          let v, M, x, z;
          function O(k) {
            try {
              let H = tp(k, { parseNode: !0, attrMatchers: x, nodesAsArray: ep }), B = {};
              if (H.tagName.toLowerCase().indexOf("xml") !== -1) for (let D in H) {
                if (Array.isArray(H[D])) {
                  B[D] = H[D][0];
                  break;
                }
                if (typeof H[D] == "object") {
                  B[D] = H[D];
                  break;
                }
              }
              else B[H.tagName] = H, delete H.tagName;
              return B;
            } catch {
              return null;
            }
          }
          return v = { getIron: function() {
            return z;
          }, parseXml: O, parse: function(k) {
            let H;
            const B = window.performance.now();
            if (H = O(k), !H) throw new Error("failed to parse the manifest");
            H.Patch ? (H = H.Patch, H.add && H.add.forEach((N) => z.run(N)), H.replace && H.replace.forEach((N) => z.run(N))) : (H = H.MPD, z.run(H));
            const D = window.performance.now();
            return M.info("Parsing complete: " + (D - B).toPrecision(3) + "ms"), H.protocol = "DASH", H;
          } }, M = E.getLogger(v), x = [new Gm(), new Vm(), new $m(), new Xm()], z = qm(f).create({ adaptationset: new Jm(), period: new Zm() }), v;
        }
        Fd.__dashjs_factory_name = "DashParser";
        var np = Dt.A.getClassFactory(Fd);
        function Ud(y) {
          y = y || {};
          const f = this.context, E = y.debug, v = y.settings, M = (0, It.A)(f).getInstance(), x = Se(f).getInstance();
          let z, O, k, H, B, D = y.mssHandler, N = y.errHandler;
          function Y(J) {
            M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: J.manifest });
          }
          return z = { load: function(J) {
            let it = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, lt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            const at = /* @__PURE__ */ new Date(), st = new Ld(J, Ct.G.MPD_TYPE);
            it && (st.serviceLocation = it), lt && (st.queryParams = lt), st.startDate || (st.startDate = at), M.trigger(et.A.MANIFEST_LOADING_STARTED, { request: st }), k.load({ request: st, success: function(ht, At, Z) {
              if (!H) return;
              let F, G, K;
              if (Z && Z !== J ? (G = x.parseBaseUrl(Z), F = Z) : (x.isRelative(J) && (J = x.resolve(J, window.location.href)), G = x.parseBaseUrl(J)), At != "No Content") if (B === null && (B = function(ft) {
                let bt = null;
                return ft.indexOf("SmoothStreamingMedia") > -1 ? (D && (bt = D.createMssParser(), D.createMssFragmentProcessor(), D.registerEvents()), bt) : ft.indexOf("MPD") > -1 || ft.indexOf("Patch") > -1 ? np(f).create({ debug: E }) : bt;
              }(ht)), B !== null) {
                H.setParser(B);
                try {
                  K = B.parse(ht);
                } catch {
                  return void M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Yt.A(X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${J}`) });
                }
                if (K) {
                  if (K.url = F || J, K.originalUrl || (K.originalUrl = K.url), v && v.get().streaming.enableManifestDurationMismatchFix && K.mediaPresentationDuration && K.Period.length > 1) {
                    const ft = K.Period.reduce((bt, _t) => bt + _t.duration, 0);
                    !isNaN(ft) && K.mediaPresentationDuration > ft && (O.warn("Media presentation duration greater than duration of all periods. Setting duration to total period duration"), K.mediaPresentationDuration = ft);
                  }
                  K.baseUri = G, K.loadedTime = /* @__PURE__ */ new Date(), H.resolveManifestOnLoad(K), M.trigger(et.A.ORIGINAL_MANIFEST_LOADED, { originalManifest: ht });
                } else M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Yt.A(X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${J}`) });
              } else M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Yt.A(X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_CODE, X.MANIFEST_LOADER_PARSING_FAILURE_ERROR_MESSAGE + `${J}`) });
              else M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: null });
            }, error: function(ht, At, Z) {
              M.trigger(et.A.INTERNAL_MANIFEST_LOADED, { manifest: null, error: new Yt.A(X.MANIFEST_LOADER_LOADING_FAILURE_ERROR_CODE, X.MANIFEST_LOADER_LOADING_FAILURE_ERROR_MESSAGE + `${J}, ${Z}`) });
            } });
          }, reset: function() {
            M.off(et.A.XLINK_READY, Y, z), D && D.reset(), H && (H.reset(), H = null), k && (k.abort(), k = null);
          } }, O = E.getLogger(z), M.on(et.A.XLINK_READY, Y, z), k = Ha(f).create({ errHandler: y.errHandler, dashMetrics: y.dashMetrics, mediaPlayerModel: y.mediaPlayerModel, urlUtils: x, constants: q.A, dashConstants: I.A, errors: X, requestTimeout: y.settings.get().streaming.manifestRequestTimeout }), H = Hm(f).create({ errHandler: N, dashMetrics: y.dashMetrics, mediaPlayerModel: y.mediaPlayerModel, settings: y.settings }), B = null, z;
        }
        Ud.__dashjs_factory_name = "ManifestLoader";
        var ip = Dt.A.getClassFactory(Ud);
        function jd() {
          let y;
          const f = this.context, E = (0, It.A)(f).getInstance();
          return y = { error: function(v) {
            E.trigger(et.A.ERROR, { error: v });
          } }, y;
        }
        jd.__dashjs_factory_name = "ErrorHandler";
        var rp = Dt.A.getSingletonFactory(jd), Bd = b(559);
        function Hd() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M, x, z, O, k;
          function H(Y, J, it) {
            const lt = D(Y, J, it);
            return M.isCodecSupportedBasedOnTestedConfigurations(lt, Y);
          }
          function B(Y, J, it, lt, at) {
            const st = D(Y, J, it), ht = JSON.stringify(st);
            lt.has(ht) || (lt.add(ht), at.push(st));
          }
          function D(Y, J, it) {
            let lt = null;
            switch (Y) {
              case q.A.VIDEO:
                lt = function(at, st) {
                  let ht = { codec: st, width: at.width || null, height: at.height || null, framerate: at.frameRate || null, bitrate: at.bandwidth || null, isSupported: !0 };
                  x.get().streaming.capabilities.filterVideoColorimetryEssentialProperties && Object.assign(ht, function(F) {
                    let G = { colorGamut: null, transferFunction: null, isSupported: !0 };
                    for (const K of F.EssentialProperty || []) K.schemeIdUri === q.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["1", "5", "6", "7"].includes(K.value.toString()) ? G.colorGamut = q.A.MEDIA_CAPABILITIES_API.COLORGAMUT.SRGB : K.schemeIdUri === q.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["11", "12"].includes(K.value.toString()) ? G.colorGamut = q.A.MEDIA_CAPABILITIES_API.COLORGAMUT.P3 : K.schemeIdUri === q.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["9"].includes(K.value.toString()) ? G.colorGamut = q.A.MEDIA_CAPABILITIES_API.COLORGAMUT.REC2020 : K.schemeIdUri === q.A.COLOUR_PRIMARIES_SCHEME_ID_URI && ["2"].includes(K.value.toString()) ? G.colorGamut = null : K.schemeIdUri === q.A.COLOUR_PRIMARIES_SCHEME_ID_URI && (G.isSupported = !1), K.schemeIdUri === q.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["1", "6", "13", "14", "15"].includes(K.value.toString()) ? G.transferFunction = q.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.SRGB : K.schemeIdUri === q.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["16"].includes(K.value.toString()) ? G.transferFunction = q.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.PQ : K.schemeIdUri === q.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["18"].includes(K.value.toString()) ? G.transferFunction = q.A.MEDIA_CAPABILITIES_API.TRANSFERFUNCTION.HLG : K.schemeIdUri === q.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && ["2"].includes(K.value.toString()) ? G.transferFunction = null : K.schemeIdUri === q.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI && (G.isSupported = !1);
                    return G;
                  }(at));
                  let At = ht.isSupported;
                  x.get().streaming.capabilities.filterHDRMetadataFormatEssentialProperties && Object.assign(ht, function(F) {
                    let G = { isSupported: !0, hdrMetadataType: null };
                    for (const K of F.EssentialProperty || []) K.schemeIdUri === q.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && K.value === q.A.HDR_METADATA_FORMAT_VALUES.ST2094_10 ? G.hdrMetadataType = q.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SMPTE_ST_2094_10 : K.schemeIdUri === q.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && K.value === q.A.HDR_METADATA_FORMAT_VALUES.SL_HDR2 ? G.hdrMetadataType = q.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SLHDR2 : K.schemeIdUri === q.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && K.value === q.A.HDR_METADATA_FORMAT_VALUES.ST2094_40 ? G.hdrMetadataType = q.A.MEDIA_CAPABILITIES_API.HDR_METADATATYPE.SMPTE_ST_2094_40 : K.schemeIdUri === q.A.HDR_METADATA_FORMAT_SCHEME_ID_URI && (G.isSupported = !1);
                    return G;
                  }(at));
                  let Z = ht.isSupported;
                  return At && Z || (ht.isSupported = !1), ht;
                }(J, it);
                break;
              case q.A.AUDIO:
                lt = function(at, st) {
                  const ht = at.audioSamplingRate || null;
                  return { codec: st, bitrate: at.bandwidth || null, samplerate: ht, isSupported: !0 };
                }(J, it);
                break;
              default:
                return lt;
            }
            return function(at, st) {
              return at && at[I.A.CONTENT_PROTECTION] && at[I.A.CONTENT_PROTECTION].length > 0 && (st.keySystemsMetadata = O.getSupportedKeySystemMetadataFromContentProtection(at[I.A.CONTENT_PROTECTION])), st;
            }(J, lt);
          }
          function N(Y) {
            if (!Y || Y.length === 0) return !0;
            let J = 0;
            for (; J < Y.length; ) {
              if (!M.supportsEssentialProperty(Y[J])) return k.debug("[Stream] EssentialProperty not supported: " + Y[J].schemeIdUri), !1;
              J += 1;
            }
            return !0;
          }
          return E = { setConfig: function(Y) {
            Y && (Y.adapter && (v = Y.adapter), Y.capabilities && (M = Y.capabilities), Y.settings && (x = Y.settings), Y.protectionController && (O = Y.protectionController), Y.customParametersModel && (z = Y.customParametersModel));
          }, filterUnsupportedFeatures: function(Y) {
            return new Promise((J) => {
              const it = [q.A.VIDEO, q.A.AUDIO], lt = [];
              it.forEach((at) => {
                (function(ht, At) {
                  if (!ht || !ht.Period || ht.Period.length === 0) return [];
                  const Z = /* @__PURE__ */ new Set(), F = [];
                  return ht.Period.forEach((G) => {
                    G.AdaptationSet.forEach((K) => {
                      v.getIsTypeOf(K, At) && K.Representation.forEach((ft, bt) => {
                        const _t = v.getCodec(K, bt, !1);
                        B(At, ft, _t, Z, F);
                        const vt = v.getSupplementalCodecs(ft);
                        vt.length > 0 && B(At, ft, vt[0], Z, F);
                      });
                    });
                  }), F;
                })(Y, at).forEach((ht) => {
                  lt.push(M.runCodecSupportCheck(ht, at));
                });
              }), Promise.allSettled(lt).then(() => (it.forEach((at) => {
                (function(st, ht) {
                  ht && ht.Period && ht.Period.length !== 0 && ht.Period.forEach((At) => {
                    (function(Z, F) {
                      Z && Z.AdaptationSet && Z.AdaptationSet.length !== 0 && (Z.AdaptationSet = Z.AdaptationSet.filter((G) => {
                        v.getIsTypeOf(G, F) && function(ft, bt) {
                          ft.Representation && ft.Representation.length !== 0 && (ft.Representation = ft.Representation.filter((_t, vt) => {
                            const Pt = v.getCodec(ft, vt, !1), Ot = H(bt, _t, Pt);
                            let W = function(tt, Tt) {
                              let yt = !1;
                              const nt = v.getSupplementalCodecs(tt);
                              return nt.length > 0 && (nt.length > 1 && k.warn("[CapabilitiesFilter] Multiple supplemental codecs not supported; using the first in list"), yt = H(Tt, tt, nt[0])), yt;
                            }(_t, bt);
                            return W && (k.debug(`[CapabilitiesFilter] Codec supported. Upgrading codecs string of Representation with ID ${_t.id}`), _t.codecs = _t[I.A.SUPPLEMENTAL_CODECS]), Ot || W || k.warn(`[CapabilitiesFilter] Codec ${Pt} not supported. Removing Representation with ID ${_t.id}`), Ot || W;
                          }));
                        }(G, F);
                        const K = G.Representation && G.Representation.length > 0;
                        return K || (f.trigger(et.A.ADAPTATION_SET_REMOVED_NO_CAPABILITIES, { adaptationSet: G }), k.warn(`[CapabilitiesFilter] AdaptationSet with ID ${G.id ? G.id : "undefined"} and codec ${G.codecs ? G.codecs : "undefined"} has been removed because of no supported Representation`)), K;
                      }));
                    })(At, st);
                  });
                })(at, Y);
              }), x.get().streaming.capabilities.filterUnsupportedEssentialProperties && function(at) {
                at && at.Period && at.Period.length !== 0 && at.Period.forEach((st) => {
                  st.AdaptationSet = st.AdaptationSet.filter((ht) => !ht.Representation || ht.Representation.length === 0 || !!N(v.getEssentialPropertiesForAdaptationSet(ht)) && (ht.Representation = ht.Representation.filter((At) => N(v.getEssentialPropertiesForRepresentation(At))), ht.Representation && ht.Representation.length > 0));
                });
              }(Y), function(at) {
                if (!at || !at.Period || at.Period.length === 0) return Promise.resolve();
                const st = [];
                return at.Period.forEach((ht) => {
                  st.push(function(At) {
                    return new Promise((Z) => {
                      if (!At || !At.AdaptationSet || At.AdaptationSet.length === 0) return void Z();
                      const F = [];
                      At.AdaptationSet.forEach((G) => {
                        F.push(function(K) {
                          return new Promise((ft) => {
                            if (!K.Representation || K.Representation.length === 0) return void ft();
                            const bt = [];
                            K.Representation.forEach((_t) => {
                              bt.push(function(vt) {
                                const Pt = [], Ot = z.getCustomCapabilitiesFilters();
                                return Ot && Ot.length !== 0 ? Ot.forEach((W) => {
                                  Pt.push(new Promise((tt) => tt(W(vt))));
                                }) : Pt.push(Promise.resolve(!0)), Promise.all(Pt);
                              }(_t));
                            }), Promise.all(bt).then((_t) => {
                              K.Representation = K.Representation.filter((vt, Pt) => {
                                let Ot = _t[Pt].every((W) => W);
                                return Ot || k.debug("[Stream] Representation " + vt.id + " has been removed because of unsupported CustomFilter"), Ot;
                              }), ft();
                            }).catch((_t) => {
                              k.warn("[Stream] at least one promise rejected in CustomFilter with error: ", _t), ft();
                            });
                          });
                        }(G));
                      }), Promise.all(F).then(() => {
                        At.AdaptationSet = At.AdaptationSet.filter((G) => G.Representation && G.Representation.length > 0), Z();
                      }).catch(() => {
                        Z();
                      });
                    });
                  }(ht));
                }), Promise.all(st);
              }(Y))).then(() => {
                J();
              }).catch((at) => {
                k.error(at), J();
              });
            });
          } }, k = (0, ae.A)(y).getInstance().getLogger(E), E;
        }
        Hd.__dashjs_factory_name = "CapabilitiesFilter";
        var ap = Dt.A.getSingletonFactory(Hd), sp = class {
          constructor() {
            this.t = null, this.xywh = null, this.track = null, this.id = null, this.s = null, this.r = null;
          }
        };
        function qd() {
          let y, f;
          return y = { initialize: function(E) {
            if (f = new sp(), !E) return null;
            const v = E.indexOf("#");
            if (v !== -1) {
              const M = E.substr(v + 1).split("&");
              for (let x = 0, z = M.length; x < z; ++x) {
                const O = M[x], k = O.indexOf("=");
                if (k !== -1) {
                  const H = O.substring(0, k);
                  f.hasOwnProperty(H) && (f[H] = O.substr(k + 1));
                }
              }
            }
          }, getURIFragmentData: function() {
            return f;
          } }, y;
        }
        qd.__dashjs_factory_name = "URIFragmentModel";
        var op = Dt.A.getSingletonFactory(qd);
        function Gd() {
          let y, f, E = this.context, v = (0, It.A)(E).getInstance();
          return y = { getValue: function() {
            return f;
          }, setValue: function(M) {
            f = M, M && v.trigger(et.A.MANIFEST_LOADED, { data: M });
          } }, y;
        }
        Gd.__dashjs_factory_name = "ManifestModel";
        var lp = Dt.A.getSingletonFactory(Gd);
        function Vd() {
          let y, f, E, v;
          const M = this.context, x = (0, Q.A)(M).getInstance();
          function z(D, N) {
            return isNaN(D) ? 0 : D > 0 ? (N && f.warn("Supplied minimum playback rate is a positive value when it should be negative or 0. The supplied rate will not be applied and set to 0: 100% playback speed."), 0) : D < -0.5 ? (N && f.warn("Supplied minimum playback rate is out of range and will be limited to -0.5: -50% playback speed."), -0.5) : D;
          }
          function O(D, N) {
            return isNaN(D) ? 0 : D < 0 ? (N && f.warn("Supplied maximum playback rate is a negative value when it should be negative or 0. The supplied rate will not be applied and set to 0: 100% playback speed."), 0) : D > 1 ? (N && f.warn("Supplied maximum playback rate is out of range and will be limited to 1: 200% playback speed."), 1) : D;
          }
          function k() {
            const D = H(), N = E.getLiveDelay();
            return !isNaN(N) && N > 0 ? Math.min(D, N) : D;
          }
          function H() {
            return x.get().streaming.buffer.bufferTimeDefault > 0 ? x.get().streaming.buffer.bufferTimeDefault : B() ? 20 : 12;
          }
          function B() {
            return x.get().streaming.buffer.fastSwitchEnabled !== null ? x.get().streaming.buffer.fastSwitchEnabled : !E.getLowLatencyModeEnabled();
          }
          return y = { getCatchupMaxDrift: function() {
            if (!isNaN(x.get().streaming.liveCatchup.maxDrift) && x.get().streaming.liveCatchup.maxDrift >= 0) return x.get().streaming.liveCatchup.maxDrift;
            const D = v.getServiceDescriptionSettings();
            return D && D.liveCatchup && !isNaN(D.liveCatchup.maxDrift) && D.liveCatchup.maxDrift >= 0 ? D.liveCatchup.maxDrift : 12;
          }, getCatchupModeEnabled: function() {
            return x.get().streaming.liveCatchup.enabled !== null ? x.get().streaming.liveCatchup.enabled : E.getInitialCatchupModeActivated();
          }, getBufferTimeDefault: k, getBufferTimeDefaultUnadjusted: H, getFastSwitchEnabled: B, getInitialBufferLevel: function() {
            const D = x.get().streaming.buffer.initialBufferLevel;
            return isNaN(D) || D < 0 ? 0 : Math.min(k(), D);
          }, getRetryAttemptsForType: function(D) {
            const N = isNaN(x.get().streaming.retryAttempts.lowLatencyMultiplyFactor) ? 5 : x.get().streaming.retryAttempts.lowLatencyMultiplyFactor;
            return E.getLowLatencyModeEnabled() ? x.get().streaming.retryAttempts[D] * N : x.get().streaming.retryAttempts[D];
          }, getRetryIntervalsForType: function(D) {
            const N = isNaN(x.get().streaming.retryIntervals.lowLatencyReductionFactor) ? 10 : x.get().streaming.retryIntervals.lowLatencyReductionFactor;
            return E.getLowLatencyModeEnabled() ? x.get().streaming.retryIntervals[D] / N : x.get().streaming.retryIntervals[D];
          }, getCatchupPlaybackRates: function(D) {
            const N = x.get().streaming.liveCatchup.playbackRate;
            if (!isNaN(N.min) || !isNaN(N.max)) return { min: z(N.min, D), max: O(N.max, D) };
            const Y = v.getServiceDescriptionSettings();
            if (Y && Y.liveCatchup && (!isNaN(Y.liveCatchup.playbackRate.min) || !isNaN(Y.liveCatchup.playbackRate.max))) {
              const J = Y.liveCatchup.playbackRate;
              return { min: z(J.min, D), max: O(J.max, D) };
            }
            return { min: -0.5, max: 0.5 };
          }, getAbrBitrateParameter: function(D, N) {
            try {
              const Y = x.get().streaming.abr[D][N];
              if (!isNaN(Y) && Y !== -1) return Y;
              const J = v.getServiceDescriptionSettings();
              return J && J[D] && !isNaN(J[D][N]) ? J[D][N] : -1;
            } catch {
              return -1;
            }
          }, setConfig: function(D) {
            D.playbackController && (E = D.playbackController), D.serviceDescriptionController && (v = D.serviceDescriptionController);
          }, reset: function() {
          } }, f = (0, ae.A)(M).getInstance().getLogger(y), y;
        }
        Vd.__dashjs_factory_name = "MediaPlayerModel";
        var up = Dt.A.getSingletonFactory(Vd);
        const uo = { DEFAULT: 0.5, STRONG: 1, WEAK: 0 };
        function Ql(y, f, E, v) {
          let M, x, z, O, k;
          return x = y === void 0 ? null : y, z = function(H) {
            let B = uo.DEFAULT;
            return H !== uo.DEFAULT && H !== uo.STRONG && H !== uo.WEAK || (B = H), B;
          }(E), O = f === void 0 ? null : f, k = v === void 0 ? null : v, M = { representation: x, reason: O, rule: k, priority: z }, M;
        }
        Ql.__dashjs_factory_name = "SwitchRequest";
        const Ko = Dt.A.getClassFactory(Ql);
        Ko.NO_CHANGE = null, Ko.PRIORITY = uo, Dt.A.updateClassFactory(Ql.__dashjs_factory_name, Ko);
        var bi = Ko;
        function Wd(y) {
          y = y || {};
          const f = this.context, E = y.dashMetrics;
          let v, M;
          return v = { getSwitchRequest: function(x) {
            try {
              const z = bi(f).create();
              z.rule = this.getClassName();
              const O = x.getMediaInfo(), k = x.getMediaType(), H = E.getCurrentBufferState(k), B = x.getScheduleController(), D = x.getAbrController(), N = x.getStreamInfo(), Y = N ? N.id : null, J = N && N.manifestInfo ? N.manifestInfo.isDynamic : null, it = x.getThroughputController(), lt = it.getSafeAverageThroughput(k), at = it.getAverageLatency(k);
              return isNaN(lt) || !H || D.getAbandonmentStateFor(Y, k) === pt.ALLOW_LOAD && (H.state === pt.BUFFER_LOADED || J) && (z.representation = D.getOptimalRepresentationForBitrate(O, lt, !0), z.reason = { throughput: lt, latency: at, message: `[ThroughputRule]: Switching to Representation with bitrate ${z.representation ? z.representation.bitrateInKbit : "n/a"} kbit/s. Throughput: ${lt}` }, B.setTimeToLoadDelay(0)), z;
            } catch (z) {
              return M.error(z), bi(f).create();
            }
          }, reset: function() {
          } }, M = (0, ae.A)(f).getInstance().getLogger(v), v;
        }
        Wd.__dashjs_factory_name = "ThroughputRule";
        var Kd = Dt.A.getClassFactory(Wd);
        function $d(y) {
          y = y || {};
          const f = this.context, E = (0, It.A)(f).getInstance(), v = y.dashMetrics, M = (0, Q.A)(f).getInstance();
          let x, z, O;
          function k() {
            const D = M.get().streaming.abr.rules.insufficientBufferRule.parameters.segmentIgnoreCount;
            O = {}, O[q.A.VIDEO] = { ignoreCount: D }, O[q.A.AUDIO] = { ignoreCount: D }, O[q.A.MESH] = { ignoreCount: D };
          }
          function H() {
            k();
          }
          function B(D) {
            isNaN(D.startTime) || D.mediaType !== q.A.AUDIO && D.mediaType !== q.A.VIDEO && D.mediaType !== q.A.MESH || O[D.mediaType].ignoreCount > 0 && O[D.mediaType].ignoreCount--;
          }
          return x = { getSwitchRequest: function(D) {
            const N = bi(f).create();
            if (N.rule = this.getClassName(), !D || !D.hasOwnProperty("getMediaType")) return N;
            const Y = D.getMediaType(), J = v.getCurrentBufferState(Y), it = D.getRepresentation().fragmentDuration;
            if (!function(st, ht, At) {
              return !st.getLowLatencyModeEnabled() && O[ht].ignoreCount <= 0 && At;
            }(D.getScheduleController().getPlaybackController(), Y, it)) return N;
            const lt = D.getMediaInfo(), at = D.getAbrController();
            if (J && J.state === pt.BUFFER_EMPTY) z.debug("[" + Y + "] Switch to index 0; buffer is empty."), N.representation = at.getOptimalRepresentationForBitrate(lt, 0, !0), N.reason = { message: "[InsufficientBufferRule]: Switching to lowest Representation because buffer is empty" };
            else {
              const st = D.getThroughputController(), ht = v.getCurrentBufferLevel(Y), At = st.getAverageThroughput(Y, null, NaN) * M.get().streaming.abr.rules.insufficientBufferRule.parameters.throughputSafetyFactor * ht / it;
              if (isNaN(At) || At <= 0) return N;
              N.representation = at.getOptimalRepresentationForBitrate(lt, At, !0), N.reason = { message: "[InsufficientBufferRule]: Limiting maximum bitrate to avoid a buffer underrun.", bitrate: At };
            }
            return N;
          }, reset: function() {
            k(), E.off(St.A.PLAYBACK_SEEKING, H, x), E.off(et.A.BYTES_APPENDED_END_FRAGMENT, B, x);
          } }, z = (0, ae.A)(f).getInstance().getLogger(x), k(), E.on(St.A.PLAYBACK_SEEKING, H, x), E.on(et.A.BYTES_APPENDED_END_FRAGMENT, B, x), x;
        }
        $d.__dashjs_factory_name = "InsufficientBufferRule";
        var dp = Dt.A.getClassFactory($d);
        function Xd(y) {
          const f = (y = y || {}).mediaPlayerModel, E = y.dashMetrics, v = this.context, M = (0, Q.A)(v).getInstance();
          let x, z, O;
          function k() {
            O = {};
          }
          return x = { shouldAbandon: function(H) {
            const B = bi(v).create();
            B.rule = this.getClassName();
            try {
              if (!H) return B;
              const D = H.getCurrentRequest();
              if (!isNaN(D.index)) {
                if (D.firstByteDate === null || O.hasOwnProperty(D.index)) return B;
                const N = f.getBufferTimeDefault(), Y = H.getMediaType();
                if (E.getCurrentBufferLevel(Y) > N) return B;
                const J = Date.now() - D.firstByteDate.getTime();
                if (D.traces.length >= M.get().streaming.abr.rules.abandonRequestsRule.parameters.minThroughputSamplesThreshold && J > M.get().streaming.abr.rules.abandonRequestsRule.parameters.minSegmentDownloadTimeThresholdInMs && D.bytesLoaded < D.bytesTotal) return function(it, lt, at) {
                  const st = it.getMediaInfo(), ht = it.getMediaType(), At = lt.traces.reduce((bt, _t) => bt + _t.b[0], 0) - lt.traces[0].b[0], Z = Math.max(lt.traces.reduce((bt, _t) => bt + _t.d, 0) - lt.traces[0].d, 1), F = Math.round(8 * At / Z), G = Number(8 * lt.bytesTotal / F / 1e3).toFixed(2), K = it.getRepresentation(), ft = it.getAbrController();
                  if (G < lt.duration * M.get().streaming.abr.rules.abandonRequestsRule.parameters.abandonDurationMultiplier || ft.isPlayingAtLowestQuality(K)) return at;
                  if (!O.hasOwnProperty(lt.index)) {
                    const bt = it.getAbrController(), _t = lt.bytesTotal - lt.bytesLoaded, vt = bt.getOptimalRepresentationForBitrate(st, F, !0), Pt = lt.representation;
                    _t > lt.bytesTotal * vt.bitrateInKbit / Pt.bitrateInKbit && (at.representation = vt, at.reason = { throughputInKbit: F, message: `[AbandonRequestRule][${ht} is asking to abandon and switch to quality to ${vt.absoluteIndex}. The measured bandwidth was ${F} kbit/s` }, O[lt.index] = !0);
                  }
                  return at;
                }(H, D, B);
              }
              return B;
            } catch (D) {
              return z.error(D), B;
            }
          }, reset: k }, z = (0, ae.A)(v).getInstance().getLogger(x), k(), x;
        }
        Xd.__dashjs_factory_name = "AbandonRequestsRule";
        var cp = Dt.A.getClassFactory(Xd);
        function Qd() {
          const y = this.context, f = (0, Q.A)(y).getInstance();
          let E;
          return E = { getSwitchRequest: function(v) {
            const M = bi(y).create();
            if (M.rule = this.getClassName(), !v || !v.hasOwnProperty("getDroppedFramesHistory")) return M;
            const x = v.getDroppedFramesHistory();
            if (!x) return M;
            const z = v.getStreamInfo().id, O = v.getMediaInfo(), k = v.getAbrController(), H = x.getFrameHistory(z);
            if (!H || Object.keys(H).length === 0) return M;
            let B = 0, D = 0;
            const N = k.getPossibleVoRepresentationsFilteredBySettings(O, !0);
            let Y = null;
            for (let J = 1; J < N.length; J++) {
              const it = N[J];
              if (it && H[it.id] && (B = H[it.id].droppedVideoFrames, D = H[it.id].totalVideoFrames, D > f.get().streaming.abr.rules.droppedFramesRule.parameters.minimumSampleSize && B / D > f.get().streaming.abr.rules.droppedFramesRule.parameters.droppedFramesPercentageThreshold)) {
                Y = N[J - 1];
                break;
              }
            }
            return Y && (M.representation = Y, M.reason = { droppedFrames: B, message: `[DroppedFramesRule]: Switching to index ${Y.absoluteIndex}. Dropped Frames: ${B}, Total Frames: ${D}` }), M;
          } }, E;
        }
        Qd.__dashjs_factory_name = "DroppedFramesRule";
        var hp = Dt.A.getClassFactory(Qd);
        function Jd() {
          const y = this.context, f = (0, Q.A)(y).getInstance();
          let E;
          return E = { getSwitchRequest: function(v) {
            const M = bi(y).create();
            if (M.rule = this.getClassName(), !v) return M;
            const x = v.getStreamInfo().id, z = v.getMediaType(), O = v ? v.getSwitchRequestHistory() : null, k = O ? O.getSwitchRequests(x, z) : {}, H = v.getAbrController(), B = v.getMediaInfo(), D = H.getPossibleVoRepresentationsFilteredBySettings(B, !0);
            let N = 0, Y = 0;
            for (let J = 0; J < D.length; J++) {
              const it = D[J];
              if (it && k[it.id] && (N += k[it.id].drops, Y += k[it.id].noDrops, N + Y >= f.get().streaming.abr.rules.switchHistoryRule.parameters.sampleSize && N / Y > f.get().streaming.abr.rules.switchHistoryRule.parameters.switchPercentageThreshold)) {
                M.representation = J > 0 && k[it.id].drops > 0 ? D[J - 1] : it, M.reason = { drops: N, noDrops: Y, message: `[SwitchHistoryRule]: Switch to index: ${M.representation.absoluteIndex} samples: ${N + Y} drops:  ${N}` };
                break;
              }
            }
            return M;
          } }, E;
        }
        Jd.__dashjs_factory_name = "SwitchHistoryRule";
        var fp = Dt.A.getClassFactory(Jd);
        const Va = "BOLA_STATE_ONE_BITRATE", $o = "BOLA_STATE_STARTUP", Jl = "BOLA_STATE_STEADY", xs = 10;
        function Zd(y) {
          y = y || {};
          const f = this.context, E = y.dashMetrics, v = y.mediaPlayerModel, M = (0, It.A)(f).getInstance(), x = fc(f).getInstance();
          let z, O, k;
          function H(G) {
            const K = G.mediaType, ft = G.streamId, bt = K === q.A.AUDIO ? [q.A.AUDIO] : k[ft];
            for (const _t in bt) k[ft] && k[ft].hasOwnProperty(_t) && k[ft][_t].state === Jl && (k[ft][_t].placeholderBuffer = 0);
          }
          function B(G) {
            const K = G.streamId;
            for (const ft in k[K]) if (k[K].hasOwnProperty(ft)) {
              const bt = k[K][ft];
              bt.state !== Va && (bt.state = $o, D(bt));
            }
          }
          function D(G) {
            G.placeholderBuffer = 0, G.mostAdvancedSegmentStart = NaN, G.lastSegmentWasReplacement = !1, G.lastSegmentStart = NaN, G.lastSegmentDurationS = NaN, G.lastSegmentRequestTimeMs = NaN, G.lastSegmentFinishTimeMs = NaN;
          }
          function N(G) {
            try {
              if (G && G.metric === pt.HTTP_REQUEST && G.value && G.value.type === Ct.G.MEDIA_SEGMENT_TYPE && G.value.trace && G.value.trace.length) {
                const K = k[G.value._streamId] && k[G.value._streamId][G.mediaType] ? k[G.value._streamId][G.mediaType] : null;
                K && K.state !== Va && (K.lastSegmentRequestTimeMs = G.value.trequest.getTime(), K.lastSegmentFinishTimeMs = G.value._tfinish.getTime(), Y(K, G.mediaType));
              }
            } catch (K) {
              O.error(K);
            }
          }
          function Y(G, K) {
            if (!isNaN(G.lastSegmentStart) && !isNaN(G.lastSegmentRequestTimeMs) && !isNaN(G.placeholderBuffer)) {
              if (G.placeholderBuffer *= 0.99, !isNaN(G.lastSegmentFinishTimeMs)) {
                const ft = E.getCurrentBufferLevel(K) + 1e-3 * (G.lastSegmentFinishTimeMs - G.lastSegmentRequestTimeMs), bt = at(G, G.currentRepresentation), _t = Math.max(0, bt - ft);
                G.placeholderBuffer = Math.min(_t, G.placeholderBuffer);
              }
              G.lastSegmentWasReplacement && !isNaN(G.lastSegmentDurationS) && (G.placeholderBuffer += G.lastSegmentDurationS), G.lastSegmentStart = NaN, G.lastSegmentRequestTimeMs = NaN;
            }
          }
          function J(G) {
            if (G && k[G.streamId] && k[G.streamId][G.mediaType]) {
              const K = k[G.streamId][G.mediaType];
              K && K.state !== Va && (K.currentRepresentation = G.newRepresentation);
            }
          }
          function it(G, K, ft) {
            const bt = ft.reduce((Pt, Ot, W) => Ot > ft[Pt] ? W : Pt, 0);
            if (bt === 0) return null;
            const _t = Math.max(G, xs + 2 * K.length), vt = (ft[bt] - 1) / (_t / xs - 1);
            return { gp: vt, Vp: xs / vt };
          }
          function lt(G, K) {
            const ft = v.getBufferTimeDefault();
            if (G.bufferTimeDefault !== ft) {
              const bt = it(ft, G.representations, G.utilities);
              if (bt.Vp !== G.Vp || bt.gp !== G.gp) {
                const _t = E.getCurrentBufferLevel(K);
                let vt = _t + G.placeholderBuffer;
                vt -= xs, vt *= bt.Vp / G.Vp, vt += xs, G.bufferTimeDefault = ft, G.Vp = bt.Vp, G.gp = bt.gp, G.placeholderBuffer = Math.max(0, vt - _t);
              }
            }
          }
          function at(G, K) {
            return G.Vp * (G.utilities[K.absoluteIndex] + G.gp);
          }
          function st(G) {
            if (G && G.chunk && G.chunk.representation.mediaInfo && k[G.streamId]) {
              const K = k[G.streamId][G.chunk.representation.mediaInfo.type];
              if (K && K.state !== Va) {
                const ft = G.chunk.start;
                isNaN(K.mostAdvancedSegmentStart) || ft > K.mostAdvancedSegmentStart ? (K.mostAdvancedSegmentStart = ft, K.lastSegmentWasReplacement = !1) : K.lastSegmentWasReplacement = !0, K.lastSegmentStart = ft, K.lastSegmentDurationS = G.chunk.duration, K.currentRepresentation = G.chunk.representation, Y(K, G.chunk.representation.mediaInfo.type);
              }
            }
          }
          function ht() {
            F();
          }
          function At(G, K) {
            const ft = K.absoluteIndex, bt = K.bandwidth, _t = G.utilities[ft];
            let vt = 0;
            for (let Pt = ft - 1; Pt >= 0; --Pt) if (G.utilities[Pt] < G.utilities[ft]) {
              const Ot = G.representations[Pt].bandwidth, W = G.utilities[Pt], tt = G.Vp * (G.gp + (bt * W - Ot * _t) / (bt - Ot));
              vt = Math.max(vt, tt);
            }
            return vt;
          }
          function Z(G) {
            if (G && k[G.streamId]) {
              const K = k[G.streamId][G.mediaType];
              if (K && K.state !== Va) {
                const ft = E.getCurrentBufferLevel(G.mediaType);
                let bt;
                bt = K.currentRepresentation.absoluteIndex > 0 ? At(K, K.currentRepresentation) : xs;
                const _t = Math.max(0, bt - ft);
                K.placeholderBuffer = Math.min(K.placeholderBuffer, _t);
              }
            }
          }
          function F() {
            k = {};
          }
          return z = { getSwitchRequest: function(G) {
            try {
              const K = bi(f).create();
              G.getScheduleController().setTimeToLoadDelay(0), K.rule = this.getClassName(), K.reason = K.reason || {};
              const ft = function(bt) {
                const _t = bt.getMediaType(), vt = bt.getStreamInfo().id;
                k[vt] || (k = {}, k[vt] = {});
                let Pt = k[vt][_t];
                return Pt ? Pt.state !== Va && lt(Pt, _t) : (Pt = function(Ot) {
                  const W = {}, tt = Ot.getMediaInfo(), Tt = x.getPossibleVoRepresentationsFilteredBySettings(tt, !0);
                  let yt = Tt.map((V) => V.bandwidth).map((V) => Math.log(V));
                  yt = yt.map((V) => V - yt[0] + 1);
                  const nt = v.getBufferTimeDefault(), ct = it(nt, Tt, yt);
                  return ct ? (W.state = $o, W.representations = Tt, W.utilities = yt, W.bufferTimeDefault = nt, W.Vp = ct.Vp, W.gp = ct.gp, W.currentRepresentation = null, D(W)) : W.state = Va, W;
                }(bt), k[vt][_t] = Pt), Pt;
              }(G);
              switch (K.reason.state = ft.state, ft.state) {
                case Va:
                  break;
                case $o:
                  (function(bt, _t, vt) {
                    const Pt = _t.getMediaType(), Ot = _t.getThroughputController().getSafeAverageThroughput(Pt);
                    if (isNaN(Ot)) return;
                    const W = _t.getMediaInfo(), tt = x.getOptimalRepresentationForBitrate(W, Ot, !0), Tt = E.getCurrentBufferLevel(Pt);
                    bt.representation = tt, bt.reason.throughput = Ot, vt.placeholderBuffer = Math.max(0, At(vt, tt) - Tt), vt.currentRepresentation = tt, !isNaN(vt.lastSegmentDurationS) && Tt >= vt.lastSegmentDurationS && (vt.state = Jl);
                  })(K, G, ft);
                  break;
                case Jl:
                  (function(bt, _t, vt) {
                    const Pt = _t.getMediaType(), Ot = _t.getThroughputController(), W = _t.getMediaInfo(), tt = Ot.getSafeAverageThroughput(Pt), Tt = _t.getScheduleController();
                    (function(mt, Mt) {
                      const Lt = Date.now();
                      if (isNaN(mt.lastSegmentFinishTimeMs)) {
                        if (!isNaN(mt.lastCallTimeMs)) {
                          const Bt = 1e-3 * (Lt - mt.lastCallTimeMs);
                          mt.placeholderBuffer += Math.max(0, Bt);
                        }
                      } else {
                        const Bt = 1e-3 * (Lt - mt.lastSegmentFinishTimeMs);
                        mt.placeholderBuffer += Math.max(0, Bt);
                      }
                      mt.lastCallTimeMs = Lt, mt.lastSegmentStart = NaN, mt.lastSegmentRequestTimeMs = NaN, mt.lastSegmentFinishTimeMs = NaN, lt(mt, Mt);
                    })(vt, Pt);
                    const yt = E.getCurrentBufferLevel(Pt);
                    let nt = function(mt, Mt) {
                      const Lt = mt.representations.length;
                      let Bt = NaN, Qt = NaN;
                      for (let Zt = 0; Zt < Lt; ++Zt) {
                        let fe = (mt.Vp * (mt.utilities[Zt] - 1 + mt.gp) - Mt) / mt.representations[Zt].bandwidth;
                        (isNaN(Qt) || fe >= Qt) && (Qt = fe, Bt = Zt);
                      }
                      return mt.representations[Bt];
                    }(vt, yt + vt.placeholderBuffer);
                    const ct = x.getOptimalRepresentationForBitrate(W, tt, !0);
                    nt.absoluteIndex > vt.currentRepresentation.absoluteIndex && nt.absoluteIndex > ct.absoluteIndex && (nt = ct.absoluteIndex > vt.currentRepresentation.absoluteIndex ? ct : vt.currentRepresentation);
                    let V = Math.max(0, yt + vt.placeholderBuffer - at(vt, nt));
                    V <= vt.placeholderBuffer ? (vt.placeholderBuffer -= V, V = 0) : (V -= vt.placeholderBuffer, vt.placeholderBuffer = 0, x.isPlayingAtTopQuality(nt) ? V = 0 : Tt.setTimeToLoadDelay(1e3 * V)), bt.representation = nt, bt.reason.throughput = tt, bt.reason.bufferLevel = yt, bt.reason.placeholderBuffer = vt.placeholderBuffer, bt.reason.delay = V, vt.currentRepresentation = nt;
                  })(K, G, ft);
                  break;
                default:
                  (function(bt, _t, vt) {
                    O.debug("BOLA ABR rule invoked in bad state.");
                    const Pt = _t.getMediaInfo(), Ot = _t.getMediaType(), W = _t.getThroughputController().getSafeAverageThroughput(Ot);
                    bt.representation = x.getOptimalRepresentationForBitrate(Pt, W, !0), bt.reason.state = vt.state, bt.reason.throughput = W, vt.state = $o, D(vt);
                  })(K, G, ft);
              }
              return K;
            } catch (K) {
              return O.error(K), bi(f).create();
            }
          }, handleNewMediaInfo: function(G) {
            G && G.streamInfo && G.type && k[G.streamInfo.id] && k[G.streamInfo.id][G.type] && delete k[G.streamInfo.id][G.type];
          }, reset: function() {
            F(), M.off(St.A.BUFFER_EMPTY, H, z), M.off(St.A.PLAYBACK_SEEKING, B, z), M.off(St.A.METRIC_ADDED, N, z), M.off(St.A.QUALITY_CHANGE_REQUESTED, J, z), M.off(St.A.FRAGMENT_LOADING_ABANDONED, Z, z), M.off(et.A.MEDIA_FRAGMENT_LOADED, st, z), M.off(et.A.SETTING_UPDATED_MAX_BITRATE, ht, z), M.off(et.A.SETTING_UPDATED_MIN_BITRATE, ht, z);
          } }, O = (0, ae.A)(f).getInstance().getLogger(z), F(), M.on(St.A.BUFFER_EMPTY, H, z), M.on(St.A.PLAYBACK_SEEKING, B, z), M.on(St.A.METRIC_ADDED, N, z), M.on(St.A.QUALITY_CHANGE_REQUESTED, J, z), M.on(St.A.FRAGMENT_LOADING_ABANDONED, Z, z), M.on(et.A.MEDIA_FRAGMENT_LOADED, st, z), M.on(et.A.SETTING_UPDATED_MAX_BITRATE, ht, z), M.on(et.A.SETTING_UPDATED_MIN_BITRATE, ht, z), z;
        }
        Zd.__dashjs_factory_name = "BolaRule";
        var tc = Dt.A.getClassFactory(Zd);
        const Xo = "L2A_STATE_ONE_BITRATE", Qo = "L2A_STATE_STARTUP", ec = "L2A_STATE_STEADY", Jo = Math.pow(4, 0.99);
        function nc(y) {
          y = y || {};
          const f = this.context, E = y.dashMetrics, v = (0, It.A)(f).getInstance();
          let M, x, z, O;
          function k(it) {
            it.placeholderBuffer = 0, it.mostAdvancedSegmentStart = NaN, it.lastSegmentWasReplacement = !1, it.lastSegmentStart = NaN, it.lastSegmentDurationS = NaN, it.lastSegmentRequestTimeMs = NaN, it.lastSegmentFinishTimeMs = NaN, it.lastSegmentUrl = "";
          }
          function H() {
            for (const it in x) if (x.hasOwnProperty(it)) {
              const lt = x[it];
              lt.state !== Xo && (lt.state = Qo, k(lt));
            }
          }
          function B(it) {
            if (it && it.chunk && it.chunk.representation && it.chunk.representation.mediaInfo) {
              const lt = x[it.chunk.representation.mediaInfo.type], at = z[it.chunk.representation.mediaInfo.type];
              if (lt && lt.state !== Xo) {
                const st = it.chunk.start;
                isNaN(lt.mostAdvancedSegmentStart) || st > lt.mostAdvancedSegmentStart ? (lt.mostAdvancedSegmentStart = st, lt.lastSegmentWasReplacement = !1) : lt.lastSegmentWasReplacement = !0, lt.lastSegmentStart = st, lt.lastSegmentDurationS = it.chunk.duration, lt.currentRepresentation = it.chunk.representation, N(lt, at);
              }
            }
          }
          function D(it) {
            if (it && it.metric === pt.HTTP_REQUEST && it.value && it.value.type === Ct.G.MEDIA_SEGMENT_TYPE && it.value.trace && it.value.trace.length) {
              const lt = x[it.mediaType], at = z[it.mediaType];
              lt && lt.state !== Xo && (lt.lastSegmentRequestTimeMs = it.value.trequest.getTime(), lt.lastSegmentFinishTimeMs = it.value._tfinish.getTime(), N(lt, at));
            }
          }
          function N(it, lt) {
            isNaN(it.lastSegmentStart) || isNaN(it.lastSegmentRequestTimeMs) || (lt.segment_request_start_s = 1e-3 * it.lastSegmentRequestTimeMs, lt.segment_download_finish_s = 1e-3 * it.lastSegmentFinishTimeMs, it.lastSegmentStart = NaN, it.lastSegmentRequestTimeMs = NaN);
          }
          function Y(it, lt) {
            if (it.length !== lt.length) return -1;
            let at = 0;
            for (let st = 0; st < it.length; st++) at += it[st] * lt[st];
            return at;
          }
          function J() {
            x = {}, z = {};
          }
          return M = { getSwitchRequest: function(it) {
            try {
              const lt = bi(f).create();
              lt.rule = this.getClassName();
              const at = it.getMediaType(), st = it.getScheduleController();
              if (lt.reason = lt.reason || {}, at === q.A.AUDIO) return lt;
              st.setTimeToLoadDelay(0);
              const ht = function(At) {
                const Z = At.getMediaType();
                let F = x[Z];
                return F || (F = function(G) {
                  const K = {}, ft = G.getMediaInfo();
                  return K.state = Qo, K.currentRepresentation = null, function(bt) {
                    bt && bt.type && (z[bt.type] = {}, z[bt.type].w = [], z[bt.type].prev_w = [], z[bt.type].Q = 0, z[bt.type].segment_request_start_s = 0, z[bt.type].segment_download_finish_s = 0, z[bt.type].B_target = 1.5);
                  }(ft), k(K), K;
                }(At), x[Z] = F), F;
              }(it);
              if (!z[at]) return lt;
              switch (lt.reason.state = ht.state, ht.state) {
                case Xo:
                  break;
                case Qo:
                  (function(At, Z, F) {
                    const G = At.getMediaInfo(), K = At.getMediaType(), ft = At.getThroughputController().getSafeAverageThroughput(K);
                    if (isNaN(ft)) return Z;
                    const bt = At.getAbrController(), _t = bt.getOptimalRepresentationForBitrate(G, ft, !0), vt = E.getCurrentBufferLevel(K, !0), Pt = z[K], Ot = bt.getPossibleVoRepresentationsFilteredBySettings(G, !0);
                    if (Z.representation = _t, Z.reason.throughput = ft, F.currentRepresentation = _t, !isNaN(F.lastSegmentDurationS) && vt >= Pt.B_target) {
                      F.state = ec, Pt.Q = Jo;
                      for (let W = 0; W < Ot.length; ++W) Ot[W].id === F.currentRepresentation.id ? Pt.prev_w[W] = 1 : Pt.prev_w[W] = 0;
                    }
                  })(it, lt, ht);
                  break;
                case ec:
                  (function(At, Z, F) {
                    let G = [];
                    const K = At.getThroughputController(), ft = At.getMediaType();
                    let bt = K.getAverageThroughput(ft, q.A.THROUGHPUT_CALCULATION_MODES.ARITHMETIC_MEAN, 1), _t = E.getCurrentHttpRequest(ft), vt = null;
                    const Pt = z[ft];
                    if (bt < 1 && (bt = 1), _t.url === F.lastSegmentUrl || _t.type === Ct.G.INIT_SEGMENT_TYPE) vt = F.currentRepresentation;
                    else {
                      let Ot = F.lastSegmentDurationS, W = 1;
                      const tt = At.getAbrController(), Tt = At.getMediaInfo(), yt = tt.getPossibleVoRepresentationsFilteredBySettings(Tt, !0);
                      let nt = At.getVideoModel().getPlaybackRate();
                      const ct = Math.max(Math.pow(4, 1), Jo * Math.sqrt(4));
                      for (let Lt = 0; Lt < yt.length; ++Lt) {
                        const Bt = yt[Lt];
                        nt * Bt.bitrateInKbit > bt && (W = -1), Pt.w[Lt] = Pt.prev_w[Lt] + W * (Ot / (2 * ct)) * ((Pt.Q + Jo) * (nt * Bt.bitrateInKbit / bt));
                      }
                      Pt.w = function(Lt) {
                        const Bt = Lt.length;
                        let Qt = !1, Zt = [];
                        for (let cn = 0; cn < Bt; ++cn) Zt[cn] = Lt[cn];
                        let fe = Lt.sort(function(cn, Nn) {
                          return Nn - cn;
                        }), Ue = 0, Ye = 0, on = [];
                        for (let cn = 0; cn < Bt - 1; ++cn) if (Ue += fe[cn], Ye = (Ue - 1) / (cn + 1), Ye >= fe[cn + 1]) {
                          Qt = !0;
                          break;
                        }
                        Qt || (Ye = (Ue + fe[Bt - 1] - 1) / Bt);
                        for (let cn = 0; cn < Bt; ++cn) on[cn] = Math.max(Zt[cn] - Ye, 0);
                        return on;
                      }(Pt.w);
                      for (let Lt = 0; Lt < yt.length; ++Lt) G[Lt] = Pt.w[Lt] - Pt.prev_w[Lt], Pt.prev_w[Lt] = Pt.w[Lt];
                      const V = yt.map((Lt) => Lt.bandwidth);
                      Pt.Q = Math.max(0, Pt.Q - Ot + Ot * nt * ((Y(V, Pt.prev_w) + Y(V, G)) / bt));
                      let mt = [];
                      for (let Lt = 0; Lt < V.length; ++Lt) mt[Lt] = Math.abs(V[Lt] - Y(Pt.w, V));
                      const Mt = mt.indexOf(Math.min(...mt));
                      vt = tt.getRepresentationByAbsoluteIndex(Mt, Tt, !0), vt.absoluteIndex > F.currentRepresentation.absoluteIndex && V[F.currentRepresentation.absoluteIndex + 1] <= bt && (vt = tt.getRepresentationByAbsoluteIndex(F.currentRepresentation.absoluteIndex + 1, Tt, !0)), vt.bitrateInKbit >= bt && (Pt.Q = 2 * Math.max(Jo, Pt.Q)), F.lastSegmentUrl = _t.url;
                    }
                    Z.representation = vt, F.currentRepresentation = Z.representation;
                  })(it, lt, ht);
                  break;
                default:
                  (function(At, Z, F) {
                    const G = At.getAbrController(), K = At.getMediaInfo(), ft = At.getMediaType(), bt = At.getThroughputController().getSafeAverageThroughput(ft);
                    Z.representation = G.getOptimalRepresentationForBitrate(K, bt, !0), Z.reason.throughput = bt, F.state = Qo, k(F);
                  })(it, lt, ht);
              }
              return lt;
            } catch (lt) {
              return O.error(lt), bi(f).create();
            }
          }, reset: function() {
            J(), v.off(et.A.PLAYBACK_SEEKING, H, M), v.off(et.A.MEDIA_FRAGMENT_LOADED, B, M), v.off(et.A.METRIC_ADDED, D, M);
          } }, O = (0, ae.A)(f).getInstance().getLogger(M), J(), v.on(et.A.PLAYBACK_SEEKING, H, M), v.on(et.A.MEDIA_FRAGMENT_LOADED, B, M), v.on(et.A.METRIC_ADDED, D, M), M;
        }
        nc.__dashjs_factory_name = "L2ARule";
        var mp = Dt.A.getClassFactory(nc);
        function ic() {
          const y = this.context;
          let f, E, v, M, x, z, O, k, H;
          function B() {
            v = null, M = 1, x = 100, z = 0, O = null, k = null, H = "dynamic_weight_selection";
          }
          function D() {
            let lt = 0;
            if (v) for (let at = 0; at < v.length; at++) {
              let st = v[at];
              st.state.throughput > lt && (lt = st.state.throughput);
            }
            return lt;
          }
          function N(lt, at, st) {
            let ht = lt.map((At, Z) => st[Z] * Math.pow(At - at[Z], 2)).reduce((At, Z) => At + Z);
            return (ht < 0 ? -1 : 1) * Math.sqrt(Math.abs(ht));
          }
          function Y(lt, at) {
            return N([lt.state.throughput, lt.state.latency, lt.state.rebuffer, lt.state.switch], [at.state.throughput, at.state.latency, at.state.rebuffer, at.state.switch], [1, 1, 1, 1]);
          }
          function J(lt, at) {
            for (let st = 0; st < v.length; st++) {
              let ht = v[st], At = 0.1;
              const Z = Y(ht, lt);
              it(ht, at, Math.exp(-1 * Math.pow(Z, 2) / (2 * Math.pow(At, 2))));
            }
          }
          function it(lt, at, st) {
            let ht = lt.state, At = [0.01, 0.01, 0.01, 0.01];
            ht.throughput = ht.throughput + (at[0] - ht.throughput) * At[0] * st, ht.latency = ht.latency + (at[1] - ht.latency) * At[1] * st, ht.rebuffer = ht.rebuffer + (at[2] - ht.rebuffer) * At[2] * st, ht.switch = ht.switch + (at[3] - ht.switch) * At[3] * st;
          }
          return f = { getNextQuality: function(lt, at, st, ht, At, Z, F, G) {
            let K = ht, ft = st;
            (function(yt, nt) {
              if (!v) {
                v = [];
                const ct = nt.getPossibleVoRepresentationsFilteredBySettings(yt, !0), V = ct.map((mt) => mt.bandwidth);
                z = Math.min(...V), M = function(mt) {
                  const Mt = mt.map((Lt) => Math.pow(Lt, 2)).reduce((Lt, Bt) => Lt + Bt);
                  return Math.sqrt(Mt);
                }(V), ct.forEach((mt) => {
                  let Mt = { representation: mt, state: { throughput: mt.bandwidth / M, latency: 0, rebuffer: 0, switch: 0 } };
                  v.push(Mt);
                }), k = function(mt) {
                  let Mt = [], Lt = function(Ue) {
                    let Ye = [];
                    for (let on = 0; on < Ue; on++) {
                      let cn = [Math.random() * D(), Math.random(), Math.random(), Math.random()];
                      Ye.push(cn);
                    }
                    return Ye;
                  }(Math.pow(mt.length, 2));
                  Mt.push(Lt[0]);
                  let Bt = [1, 1, 1, 1];
                  for (let Ue = 1; Ue < mt.length; Ue++) {
                    let Ye = null, on = null;
                    for (let cn = 0; cn < Lt.length; cn++) {
                      let Nn = Lt[cn], Qe = null;
                      for (let hn = 0; hn < Mt.length; hn++) {
                        let Sn = N(Nn, Mt[hn], Bt);
                        (Qe === null || Sn < Qe) && (Qe = Sn);
                      }
                      (on === null || Qe > on) && (Ye = Nn, on = Qe);
                    }
                    Mt.push(Ye);
                  }
                  let Qt = null, Zt = null;
                  for (let Ue = 0; Ue < Mt.length; Ue++) {
                    let Ye = 0;
                    for (let on = 0; on < Mt.length; on++) Ue !== on && (Ye += N(Mt[Ue], Mt[on], Bt));
                    (Qt === null || Ye > Qt) && (Qt = Ye, Zt = Ue);
                  }
                  let fe = [];
                  for (fe.push(Mt[Zt]), Mt.splice(Zt, 1); Mt.length > 0; ) {
                    let Ue = null, Ye = null;
                    for (let on = 0; on < Mt.length; on++) {
                      let cn = N(fe[0], Mt[on], Bt);
                      (Ue === null || cn < Ue) && (Ue = cn, Ye = on);
                    }
                    fe.push(Mt[Ye]), Mt.splice(Ye, 1);
                  }
                  return fe;
                }(v);
              }
            })(at, lt);
            let bt = st / M;
            bt > 1 && (bt = D()), ht /= x;
            let _t = v.find((yt) => yt.representation.id === F.id), vt = _t.representation.bandwidth * G.getSegmentDuration() / ft, Pt = Math.max(0, vt - At);
            if (At - vt < G.getMinBuffer()) return E.debug(`Buffer is low for bitrate= ${_t.representation.bandwidth} downloadTime=${vt} currentBuffer=${At} rebuffer=${Pt}`), function(yt, nt) {
              let ct = 0, V = yt;
              if (v) for (let mt = 0; mt < v.length; mt++) {
                let Mt = v[mt];
                Mt.representation.bandwidth < yt.representation.bandwidth && Mt.representation.bandwidth > ct && nt > Mt.representation.bandwidth && (ct = Mt.representation.bandwidth, V = Mt);
              }
              return V;
            }(_t, ft).representation;
            switch (H) {
              case "manual_weight_selection":
                O = [0.4, 0.4, 0.4, 0.4];
                break;
              case "random_weight_selection":
                O = function(yt) {
                  let nt = [], ct = Math.sqrt(2 / yt);
                  for (let V = 0; V < 4; V++) nt.push(Math.random() * ct);
                  return O = nt, O;
                }(v.length);
                break;
              default:
                (function(yt, nt, ct, V, mt, Mt) {
                  O || (O = k[k.length - 1]);
                  let Lt = yt.findWeightVector(v, nt, ct, V, mt, Mt);
                  Lt !== null && Lt !== -1 && (O = Lt);
                })(G, K, At, Pt, ft, Z);
            }
            let Ot = null, W = null, tt = null;
            for (let yt = 0; yt < v.length; yt++) {
              let nt = v[yt], ct = nt.state, V = [ct.throughput, ct.latency, ct.rebuffer, ct.switch], mt = O.slice(), Mt = G.getNextBufferWithBitrate(nt.representation.bandwidth, At, ft), Lt = Mt < G.getMinBuffer();
              Lt && E.debug(`Buffer is low for bitrate=${nt.representation.bandwidth} downloadTime=${vt} currentBuffer=${At} nextBuffer=${Mt}`), (nt.representation.bandwidth > st - 1e4 || Lt) && nt.representation.bandwidth !== z && (mt[0] = 100);
              let Bt = N(V, [bt, 0, 0, 0], mt);
              (Ot === null || Bt < Ot) && (Ot = Bt, W = nt.representation, tt = nt);
            }
            let Tt = Math.abs(_t.representation.bandwidth - tt.representation.bandwidth) / M;
            return J(_t, [bt, ht, Pt, Tt]), J(tt, [bt, 0, 0, Tt]), W;
          }, reset: function() {
            B();
          } }, E = (0, ae.A)(y).getInstance().getLogger(f), B(), f;
        }
        ic.__dashjs_factory_name = "LearningAbrController";
        var pp = Dt.A.getClassFactory(ic), gp = class {
          constructor() {
            this.type = null, this.lastBitrate = null, this.weights = {}, this.weights.bitrateReward = null, this.weights.bitrateSwitchPenalty = null, this.weights.rebufferPenalty = null, this.weights.latencyPenalty = null, this.weights.playbackSpeedPenalty = null, this.bitrateWSum = 0, this.bitrateSwitchWSum = 0, this.rebufferWSum = 0, this.latencyWSum = 0, this.playbackSpeedWSum = 0, this.totalQoe = 0;
          }
        };
        function rc() {
          let y, f, E, v, M;
          function x() {
            f = null, E = null, v = null, M = null;
          }
          function z(k, H, B, D) {
            let N = new gp();
            return N.type = k, N.weights.bitrateReward = H || 1, N.weights.bitrateSwitchPenalty = 1, N.weights.rebufferPenalty = B || 1e3, N.weights.latencyPenalty = [], N.weights.latencyPenalty.push({ threshold: 1.1, penalty: 0.05 * D }), N.weights.latencyPenalty.push({ threshold: 1e8, penalty: 0.1 * B }), N.weights.playbackSpeedPenalty = D || 200, N;
          }
          function O(k, H, B, D, N) {
            N.bitrateWSum += N.weights.bitrateReward * k, N.lastBitrate && (N.bitrateSwitchWSum += N.weights.bitrateSwitchPenalty * Math.abs(k - N.lastBitrate)), N.lastBitrate = k, N.rebufferWSum += N.weights.rebufferPenalty * H;
            for (let Y = 0; Y < N.weights.latencyPenalty.length; Y++) {
              let J = N.weights.latencyPenalty[Y];
              if (B <= J.threshold) {
                N.latencyWSum += J.penalty * B;
                break;
              }
            }
            N.playbackSpeedWSum += N.weights.playbackSpeedPenalty * Math.abs(1 - D), N.totalQoe = N.bitrateWSum - N.bitrateSwitchWSum - N.rebufferWSum - N.latencyWSum - N.playbackSpeedWSum;
          }
          return y = { setupPerSegmentQoe: function(k, H, B) {
            f = z("segment", k, H, B), E = k, v = H, M = B;
          }, logSegmentMetrics: function(k, H, B, D) {
            f && O(k, H, B, D, f);
          }, getPerSegmentQoe: function() {
            return f;
          }, calculateSingleUseQoe: function(k, H, B, D) {
            let N = null;
            return E && v && M && (N = z("segment", E, v, M)), N ? (O(k, H, B, D, N), N.totalQoe) : 0;
          }, reset: function() {
            x();
          } }, x(), y;
        }
        rc.__dashjs_factory_name = "LoLpQoeEvaluator";
        var _p = Dt.A.getClassFactory(rc);
        function ac(y) {
          let f, E, v, M, x = y.targetLatency, z = y.bufferMin, O = y.segmentDuration, k = y.qoeEvaluator;
          function H() {
            return O;
          }
          function B(D, N) {
            const Y = H();
            let J;
            return J = N > Y ? D - Y : D + Y - N, J;
          }
          return f = { getMinBuffer: function() {
            return z;
          }, getSegmentDuration: H, getNextBufferWithBitrate: function(D, N, Y) {
            return B(N, D * O / Y);
          }, getNextBuffer: B, findWeightVector: function(D, N, Y, J, it, lt) {
            let at = null, st = null, ht = null, At = Math.abs(N - M);
            return D.forEach((Z) => {
              v.forEach((F) => {
                F[0];
                let G, K = F[1], ft = F[2], bt = (F[3], Z.representation.bandwidth * O / it), _t = B(Y, bt);
                G = ft === 0 ? 10 : 1 / ft;
                let vt = G * Math.max(1e-5, bt - _t);
                G = K === 0 ? 10 : 1 / K;
                let Pt = G * Z.state.latency, Ot = k.calculateSingleUseQoe(Z.representation.bandwidth, vt, Pt, lt);
                (at === null || Ot > at) && function(W, tt, Tt) {
                  return !(W > x + Tt) && tt >= z;
                }(N, _t, At) && (at = Ot, st = F, ht = Z.representation.bandwidth);
              });
            }), st === null && ht === null && (st = -1), M = N, st;
          } }, E = [0.2, 0.4, 0.6, 0.8, 1], v = function(D) {
            let N = D.map(function(J) {
              return [J];
            }), Y = function(J, it, lt) {
              if (lt === it) return J;
              let at = J.length;
              for (let st = 0; st < at; st++) {
                let ht = J.shift();
                for (let At = 0; At < D.length; At++) J.push(ht.concat(D[At]));
              }
              return Y(J, it, lt + 1);
            };
            return Y(N, 4, 1);
          }(E), M = 0, f;
        }
        ac.__dashjs_factory_name = "LoLpWeightSelector";
        var yp = Dt.A.getClassFactory(ac);
        function sc(y) {
          let f, E, v, M, x = (y = y || {}).dashMetrics, z = this.context;
          return E = { getSwitchRequest: function(O) {
            try {
              let k = bi(z).create();
              k.rule = this.getClassName();
              let H = O.getMediaInfo().type, B = O.getAbrController();
              const D = O.getStreamInfo();
              let N = O.getRepresentation();
              const Y = O.getMediaInfo(), J = x.getCurrentBufferState(H), it = O.getScheduleController(), lt = x.getCurrentBufferLevel(H, !0), at = it.getPlaybackController();
              let st = at.getCurrentLiveLatency();
              if (H === q.A.AUDIO) return k;
              st || (st = 0);
              const ht = at.getPlaybackRate(), At = O.getThroughputController().getSafeAverageThroughput(H);
              if (f.debug(`Throughput ${Math.round(At)} kbps`), isNaN(At) || !J || B.getAbandonmentStateFor(D.id, H) === pt.ABANDON_LOAD) return k;
              let Z = B.getPossibleVoRepresentationsFilteredBySettings(Y, !0).map((Ot) => Ot.bandwidth), F = O.getRepresentation().fragmentDuration, G = Math.min(...Z) / 1e3, K = Math.max(...Z) / 1e3, ft = N.bandwidth / 1e3, bt = x.getCurrentHttpRequest(H, !0), _t = (bt.tresponse.getTime() - bt.trequest.getTime()) / 1e3, vt = _t > F ? _t - F : 0;
              M.setupPerSegmentQoe(F, K, G), M.logSegmentMetrics(ft, vt, st, ht);
              let Pt = yp(z).create({ targetLatency: 1.5, bufferMin: 0.3, segmentDuration: F, qoeEvaluator: M });
              return k.representation = v.getNextQuality(B, Y, 1e3 * At, st, lt, ht, N, Pt), k.reason = { throughput: At, latency: st }, k.priority = bi.PRIORITY.STRONG, it.setTimeToLoadDelay(0), k;
            } catch (k) {
              throw k;
            }
          }, reset: function() {
            v.reset(), M.reset();
          } }, f = (0, ae.A)(z).getInstance().getLogger(E), v = pp(z).create(), M = _p(z).create(), E;
        }
        sc.__dashjs_factory_name = "LoLPRule";
        var bp = Dt.A.getClassFactory(sc);
        function Zl(y) {
          y = y || {};
          const f = this.context, E = y.mediaPlayerModel, v = y.customParametersModel, M = y.dashMetrics, x = y.settings, z = (0, It.A)(f).getInstance();
          let O, k, H, B;
          function D() {
            Object.values(q.A.QUALITY_SWITCH_RULES).forEach((at) => {
              k = N(at, k);
            });
            let lt = Object.values(q.A.ABANDON_FRAGMENT_RULES);
            lt.forEach((at) => {
              H = N(at, H);
            }), v.getAbrCustomRules().forEach(function(at) {
              at.type === q.A.RULES_TYPES.QUALITY_SWITCH_RULES && k.push(at.rule(f).create()), at.type === q.A.RULES_TYPES.ABANDON_FRAGMENT_RULES && lt.push(at.rule(f).create());
            }), k.length === 0 && (k.push(tc(f).create({ dashMetrics: M, mediaPlayerModel: E, settings: x })), k.push(Kd(f).create({ dashMetrics: M })));
          }
          function N(lt, at) {
            const st = lt.charAt(0).toLowerCase() + lt.slice(1);
            return x.get().streaming.abr.rules[st].active && !function(ht, At) {
              return ht.filter((Z) => Z.getClassName() === At).length > 0;
            }(at, lt) ? (at.push(function(ht) {
              switch (ht) {
                case q.A.QUALITY_SWITCH_RULES.BOLA_RULE:
                  return tc(f).create({ dashMetrics: M, mediaPlayerModel: E, settings: x });
                case q.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE:
                  return Kd(f).create({ dashMetrics: M });
                case q.A.QUALITY_SWITCH_RULES.INSUFFICIENT_BUFFER_RULE:
                  return dp(f).create({ dashMetrics: M, settings: x });
                case q.A.QUALITY_SWITCH_RULES.SWITCH_HISTORY_RULE:
                  return fp(f).create();
                case q.A.QUALITY_SWITCH_RULES.DROPPED_FRAMES_RULE:
                  return hp(f).create();
                case q.A.QUALITY_SWITCH_RULES.LEARN_TO_ADAPT_RULE:
                  return mp(f).create({ dashMetrics: M, settings: x });
                case q.A.QUALITY_SWITCH_RULES.LOL_PLUS_RULE:
                  return bp(f).create({ dashMetrics: M });
                case q.A.ABANDON_FRAGMENT_RULES.ABANDON_REQUEST_RULE:
                  return cp(f).create({ dashMetrics: M, mediaPlayerModel: E, settings: x });
              }
            }(lt)), at) : x.get().streaming.abr.rules[st].active ? at : function(ht, At) {
              return ht.filter((Z) => Z.getClassName() !== At);
            }(at, lt);
          }
          function Y(lt) {
            return lt.filter((at) => at.representation !== bi.NO_CHANGE);
          }
          function J(lt) {
            const at = {};
            let st, ht, At, Z = null;
            if (lt.length !== 0) {
              for (at[bi.PRIORITY.STRONG] = null, at[bi.PRIORITY.WEAK] = null, at[bi.PRIORITY.DEFAULT] = null, st = 0, ht = lt.length; st < ht; st += 1) At = lt[st], At.representation !== bi.NO_CHANGE && (at[At.priority] === null || at[At.priority].representation !== bi.NO_CHANGE && At.representation.bitrateInKbit < at[At.priority].representation.bitrateInKbit) && (at[At.priority] = At);
              return at[bi.PRIORITY.WEAK] && at[bi.PRIORITY.WEAK].representation !== bi.NO_CHANGE && (Z = at[bi.PRIORITY.WEAK]), at[bi.PRIORITY.DEFAULT] && at[bi.PRIORITY.DEFAULT].representation !== bi.NO_CHANGE && (Z = at[bi.PRIORITY.DEFAULT]), at[bi.PRIORITY.STRONG] && at[bi.PRIORITY.STRONG].representation !== bi.NO_CHANGE && (Z = at[bi.PRIORITY.STRONG]), Z;
            }
          }
          function it() {
            D();
          }
          return O = { clearDataForStream: function(lt) {
            [k, H].forEach((at) => {
              at && at.length && at.forEach((st) => st.clearDataForStream && typeof st.clearDataForStream == "function" && st.clearDataForStream(lt));
            });
          }, getAbandonFragmentRules: function() {
            return H;
          }, getBestPossibleSwitchRequest: function(lt) {
            return lt && J(Y(k.filter((at) => {
              const st = at.getClassName();
              if (st !== q.A.QUALITY_SWITCH_RULES.BOLA_RULE && st !== q.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE) return !0;
              const ht = lt.getMediaType();
              return B[ht] && st === q.A.QUALITY_SWITCH_RULES.BOLA_RULE || !B[ht] && st === q.A.QUALITY_SWITCH_RULES.THROUGHPUT_RULE;
            }).map((at) => at.getSwitchRequest(lt)))) || bi(f).create();
          }, getBolaState: function(lt) {
            return B[lt];
          }, getMinSwitchRequest: J, getQualitySwitchRules: function() {
            return k;
          }, handleNewMediaInfo: function(lt) {
            k.forEach((at) => at.handleNewMediaInfo && at.handleNewMediaInfo(lt)), H.forEach((at) => at.handleNewMediaInfo && at.handleNewMediaInfo(lt));
          }, initialize: function() {
            k = [], H = [], B = {}, D(), z.on(et.A.SETTING_UPDATED_ABR_ACTIVE_RULES, it, O);
          }, reset: function() {
            [k, H].forEach((lt) => {
              lt && lt.length && lt.forEach((at) => at.reset && at.reset());
            }), k = [], H = [], B = {}, z.off(et.A.SETTING_UPDATED_ABR_ACTIVE_RULES, it, O);
          }, setBolaState: function(lt, at) {
            B[lt] = at;
          }, shouldAbandonFragment: function(lt) {
            if (!lt) return bi(f).create();
            const at = J(Y(H.map((st) => st.shouldAbandon(lt))));
            return at && (at.reason.forceAbandon = !0), at || bi(f).create();
          } }, O;
        }
        Zl.__dashjs_factory_name = "ABRRulesCollection";
        const oc = Dt.A.getClassFactory(Zl);
        Dt.A.updateSingletonFactory(Zl.__dashjs_factory_name, oc);
        var Ep = oc;
        function lc(y) {
          let f;
          const E = (y = y || {}).abrController, v = y.throughputController, M = y.switchRequestHistory, x = y.droppedFramesHistory, z = y.currentRequest, O = y.streamProcessor ? y.streamProcessor.getScheduleController() : null, k = y.streamProcessor ? y.streamProcessor.getRepresentation() : null, H = y.videoModel ? y.videoModel : null;
          function B() {
            return k ? k.mediaInfo : null;
          }
          return f = { getAbrController: function() {
            return E;
          }, getCurrentRequest: function() {
            return z;
          }, getDroppedFramesHistory: function() {
            return x;
          }, getMediaInfo: B, getMediaType: function() {
            const D = B();
            return D ? D.type : null;
          }, getRepresentation: function() {
            return k;
          }, getScheduleController: function() {
            return O;
          }, getStreamInfo: function() {
            const D = B();
            return D ? D.streamInfo : null;
          }, getSwitchRequestHistory: function() {
            return M;
          }, getThroughputController: function() {
            return v;
          }, getVideoModel: function() {
            return H;
          } }, f;
        }
        lc.__dashjs_factory_name = "RulesContext";
        var uc = Dt.A.getClassFactory(lc);
        function dc() {
          let y = {}, f = {};
          const E = this.context, v = (0, Q.A)(E).getInstance();
          return { clearForStream: function(M) {
            delete y[M], delete f[M];
          }, getSwitchRequests: function(M, x) {
            return M != null && x != null && y[M] && y[M][x] ? y[M][x] : {};
          }, push: function(M) {
            const x = M.currentRepresentation, z = M.newRepresentation;
            if (x.mediaInfo.streamInfo.id !== z.mediaInfo.streamInfo.id || z.mediaInfo.id !== x.mediaInfo.id) return;
            const O = x.mediaInfo.streamInfo.id;
            y[O] || function(it) {
              y[it] = {}, f[it] = {};
            }(O);
            const k = x.mediaInfo.type;
            y[O][k] || function(it, lt) {
              y[it][lt] = {}, f[it][lt] = [];
            }(O, k);
            const H = M.currentRepresentation.id;
            y[O][k][H] || function(it, lt, at) {
              y[it][lt][at] = { noDrops: 0, drops: 0, dropSize: 0 };
            }(O, k, H);
            let B = M.newRepresentation.absoluteIndex - M.currentRepresentation.absoluteIndex, D = B < 0 ? 1 : 0, N = D ? -B : 0, Y = D ? 0 : 1;
            y[O][k][M.currentRepresentation.id].drops += D, y[O][k][M.currentRepresentation.id].dropSize += N, y[O][k][M.currentRepresentation.id].noDrops += Y, f[O][k].push({ id: M.currentRepresentation.id, noDrop: Y, drop: D, dropSize: N });
            const J = function(it, lt) {
              return f[it][lt].length > v.get().streaming.abr.rules.switchHistoryRule.parameters.sampleSize ? f[it][lt].shift() : null;
            }(O, k);
            J && function(it, lt, at) {
              y[it][lt][at.id].drops -= at.drop, y[it][lt][at.id].dropSize -= at.dropSize, y[it][lt][at.id].noDrops -= at.noDrop;
            }(O, k, J);
          }, reset: function() {
            y = {}, f = {};
          } };
        }
        dc.__dashjs_factory_name = "SwitchRequestHistory";
        var vp = Dt.A.getClassFactory(dc);
        function cc() {
          let y = {}, f = {}, E = {};
          return { clearForStream: function(v) {
            delete y[v], delete f[v], delete E[v];
          }, getFrameHistory: function(v) {
            return y[v];
          }, push: function(v, M, x) {
            if (!M) return;
            y[v] || function(D) {
              y[D] = [], f[D] = 0, E[D] = 0;
            }(v);
            let z = x && x.droppedVideoFrames ? x.droppedVideoFrames : 0, O = x && x.totalVideoFrames ? x.totalVideoFrames : 0, k = z - f[v];
            f[v] = z;
            let H = O - E[v];
            E[v] = O;
            const B = y[v];
            B[M] ? (B[M].droppedVideoFrames += k, B[M].totalVideoFrames += H) : B[M] = { droppedVideoFrames: k, totalVideoFrames: H };
          }, reset: function() {
            y = {}, f = {}, E = {};
          } };
        }
        cc.__dashjs_factory_name = "DroppedFramesHistory";
        var Tp = Dt.A.getClassFactory(cc);
        function tu() {
          const y = this.context, f = (0, ae.A)(y).getInstance(), E = (0, It.A)(y).getInstance();
          let v, M, x, z, O, k, H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F;
          function G() {
            H = {}, k = {}, ht && ht.reset(), st && st.reset(), at = void 0, ht = void 0, st = void 0, clearTimeout(B), B = null;
          }
          function K(tt) {
            let Tt = ft(tt, !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]);
            return Tt = function(yt) {
              try {
                return function(nt) {
                  try {
                    if (!F.get().streaming.cmsd.enabled || !F.get().streaming.cmsd.abr.applyMb) return nt;
                    const ct = nt.filter((V) => {
                      const mt = V.mediaInfo.type;
                      let Mt = it.getMaxBitrate(mt);
                      if (mt !== q.A.VIDEO || Mt < 0) return !0;
                      const Lt = V.mediaInfo.streamInfo.id;
                      return Mt -= k[Lt][q.A.AUDIO].getRepresentation().bitrateInKbit || 0, V.bitrateInKbit <= Mt;
                    });
                    return ct.length > 0 ? ct : nt;
                  } catch (ct) {
                    return M.error(ct), nt;
                  }
                }(yt = function(nt) {
                  try {
                    if (!F.get().streaming.abr.limitBitrateByPortal) return nt;
                    const { elementWidth: ct } = N.getVideoElementSize(), V = nt.filter((mt) => mt.mediaInfo.type !== q.A.VIDEO || mt.width <= ct);
                    return V.length > 0 ? V : nt;
                  } catch (ct) {
                    return M.error(ct), nt;
                  }
                }(yt = function(nt) {
                  try {
                    const ct = nt.filter((V) => {
                      const mt = V.mediaInfo.type, Mt = V.bitrateInKbit, Lt = Y.getAbrBitrateParameter("maxBitrate", mt), Bt = Y.getAbrBitrateParameter("minBitrate", mt);
                      return !(Lt > -1 && Mt > Lt || Bt > -1 && Mt < Bt);
                    });
                    return ct.length > 0 ? ct : nt;
                  } catch (ct) {
                    return M.error(ct), nt;
                  }
                }(yt)));
              } catch (nt) {
                return M.error(nt), yt;
              }
            }(Tt), Tt;
          }
          function ft(tt, Tt) {
            let yt = [];
            return tt && (function(ct) {
              try {
                const V = [];
                if (ct && V.push(ct), !F.get().streaming.abr.enableSupplementalPropertyAdaptationSetSwitching || !ct.adaptationSetSwitchingCompatibleIds || ct.adaptationSetSwitchingCompatibleIds.length === 0) return V;
                const mt = k[ct.streamInfo.id][ct.type].getAllMediaInfos().filter((Mt) => ct.adaptationSetSwitchingCompatibleIds.includes(Mt.id));
                return V.concat(mt);
              } catch {
                return [ct];
              }
            }(tt).forEach((ct) => {
              let V = D.getVoRepresentations(ct);
              V && V.length > 0 && (yt = yt.concat(V));
            }), yt = function(ct) {
              return ct = function(V) {
                let mt = null;
                return V.filter((Mt) => (mt || (mt = Mt.mediaInfo), !isNaN(Mt.qualityRanking) && D.areMediaInfosEqual(mt, Mt.mediaInfo))).length === V.length;
              }(ct) ? function(V) {
                return V.sort((mt, Mt) => Mt.qualityRanking - mt.qualityRanking), V;
              }(ct) : function(V) {
                return V.sort((mt, Mt) => D.areMediaInfosEqual(mt.mediaInfo, Mt.mediaInfo) ? isNaN(mt.pixelsPerSecond) || isNaN(Mt.pixelsPerSecond) || mt.pixelsPerSecond === Mt.pixelsPerSecond ? mt.bandwidth - Mt.bandwidth : mt.pixelsPerSecond - Mt.pixelsPerSecond : isNaN(mt.pixelsPerSecond) || isNaN(Mt.pixelsPerSecond) || mt.pixelsPerSecond === Mt.pixelsPerSecond ? isNaN(mt.bitsPerPixel) || isNaN(Mt.bitsPerPixel) ? mt.bandwidth - Mt.bandwidth : Mt.bitsPerPixel - mt.bitsPerPixel : mt.pixelsPerSecond - Mt.pixelsPerSecond), V;
              }(ct);
            }(yt), yt.forEach((ct, V) => {
              ct.absoluteIndex = V;
            }), yt = yt.filter((ct) => {
              const V = !!Tt || D.areMediaInfosEqual(ct.mediaInfo, tt), mt = !ct || !ct.mediaInfo || O.areKeyIdsUsable(ct.mediaInfo);
              return V && mt;
            })), yt;
          }
          function bt(tt) {
            const Tt = tt.request.mediaType, yt = tt.streamId;
            if (!(Tt && yt && k[yt] && F.get().streaming.abr.autoSwitchBitrate[Tt])) return;
            const nt = k[yt][Tt];
            if (!nt) return;
            const ct = uc(y).create({ abrController: v, streamProcessor: nt, currentRequest: tt.request, throughputController: At, adapter: D, videoModel: N }), V = x.shouldAbandonFragment(ct);
            V && V.representation !== bi.NO_CHANGE && function(mt, Mt, Lt, Bt, Qt) {
              if (Bt.getFragmentModel().getRequests({ state: wn.FRAGMENT_MODEL_LOADING, index: mt.request.index })[0]) {
                const Zt = function(fe, Ue) {
                  return H[fe] && H[fe][Ue] ? H[fe][Ue] : null;
                }(Mt, Lt);
                Zt && (Zt.state = pt.ABANDON_LOAD), st.reset(), Pt(Lt, z.getActiveStreamInfo(), Qt.representation, Qt.reason), clearTimeout(B), B = setTimeout(() => {
                  Zt && (H[Mt][Lt].state = pt.ALLOW_LOAD), B = null;
                }, F.get().streaming.abandonLoadTimeout);
              }
            }(tt, yt, Tt, nt, V);
          }
          function _t(tt) {
            tt.mediaType === q.A.VIDEO && (at !== void 0 && ht.push(tt.streamId, at, N.getPlaybackQuality()), at = tt.newRepresentation.id);
          }
          function vt(tt) {
            !W() || tt.metric !== pt.BUFFER_LEVEL || tt.mediaType !== q.A.AUDIO && tt.mediaType !== q.A.VIDEO && tt.mediaType !== q.A.MESH || function(Tt, yt) {
              try {
                const nt = Y.getBufferTimeDefault(), ct = nt, V = 0.5 * nt, mt = x.getBolaState(Tt), Mt = yt >= (mt ? V : ct);
                x.setBolaState(Tt, Mt), Mt !== mt && (Mt ? M.info("[" + Tt + "] switching from throughput to buffer occupancy ABR rule (buffer: " + yt.toFixed(3) + ").") : M.info("[" + Tt + "] switching from buffer occupancy to throughput ABR rule (buffer: " + yt.toFixed(3) + ")."));
              } catch (nt) {
                M.error(nt);
              }
            }(tt.mediaType, 1e-3 * tt.value.level);
          }
          function Pt(tt, Tt, yt) {
            let nt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            if (!(Tt && Tt.id && tt && k && k[Tt.id] && k[Tt.id][tt] && yt)) return;
            const ct = k[Tt.id][tt].getRepresentation();
            ct && yt.id === ct.id || Ot(ct, yt, nt);
          }
          function Ot(tt, Tt, yt) {
            const nt = Tt.mediaInfo.streamInfo.id, ct = Tt.mediaInfo.type;
            if (ct && k[nt] && k[nt][ct]) {
              const V = k[nt][ct].getStreamInfo(), mt = Z.getCurrentBufferLevel(ct), Mt = tt !== null && !D.areMediaInfosEqual(tt.mediaInfo, Tt.mediaInfo), Lt = tt ? tt.bitrateInKbit : 0;
              M.info(`[AbrController]: Switching quality in period ${nt} for media type ${ct}. Switch from bitrate ${Lt} to bitrate ${Tt.bitrateInKbit}. Current buffer level: ${mt}. Reason:` + (yt ? JSON.stringify(yt) : "/")), E.trigger(et.A.QUALITY_CHANGE_REQUESTED, { oldRepresentation: tt, newRepresentation: Tt, reason: yt, streamInfo: V, mediaType: ct, isAdaptationSetSwitch: Mt }, { streamId: V.id, mediaType: ct });
              const Bt = At.getAverageThroughput(ct);
              isNaN(Bt) || lt.setSavedBitrateSettings(ct, Bt);
            }
          }
          function W() {
            return F.get().streaming.abr.rules.bolaRule.active && F.get().streaming.abr.rules.throughputRule.active;
          }
          return v = { checkPlaybackQuality: function(tt, Tt) {
            try {
              if (!(tt && k && k[Tt] && k[Tt][tt])) return !1;
              if (ht) {
                const Mt = N.getPlaybackQuality();
                Mt && ht.push(Tt, at, Mt);
              }
              if (!F.get().streaming.abr.autoSwitchBitrate[tt]) return !1;
              const yt = k[Tt][tt], nt = yt.getRepresentation(), ct = uc(y).create({ abrController: v, throughputController: At, switchRequestHistory: st, droppedFramesHistory: ht, streamProcessor: yt, adapter: D, videoModel: N }), V = x.getBestPossibleSwitchRequest(ct);
              if (!V || !V.representation) return !1;
              let mt = V.representation;
              return st.push({ currentRepresentation: nt, newRepresentation: mt }), mt.id !== nt.id && (H[Tt][tt].state === pt.ALLOW_LOAD || mt.absoluteIndex < nt.absoluteIndex) && (Ot(nt, mt, V.reason), !0);
            } catch (yt) {
              return M.error(yt), !1;
            }
          }, clearDataForStream: function(tt) {
            ht && ht.clearForStream(tt), k[tt] && delete k[tt], st && st.clearForStream(tt), H[tt] && delete H[tt], x.clearDataForStream(tt);
          }, getAbandonmentStateFor: function(tt, Tt) {
            return H[tt] && H[tt][Tt] ? H[tt][Tt].state : null;
          }, getInitialBitrateFor: function(tt) {
            if (tt === q.A.TEXT) return NaN;
            let Tt = Y.getAbrBitrateParameter("initialBitrate", tt);
            if (Tt > 0) return Tt;
            let yt = NaN;
            if (lt && lt.hasOwnProperty("getSavedBitrateSettings") && (yt = lt.getSavedBitrateSettings(tt)), !isNaN(yt)) return yt;
            const nt = At.getAverageThroughput(tt);
            return !isNaN(nt) && nt > 0 ? nt : tt === q.A.VIDEO ? 1e3 : 100;
          }, getOptimalRepresentationForBitrate: function(tt, Tt) {
            const yt = K(tt, !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2]);
            if (!yt || yt.length === 0) return null;
            const nt = yt.reduce((V, mt) => V.bandwidth < mt.bandwidth ? V : mt);
            if (Tt <= 0) return nt;
            const ct = yt.filter((V) => V.bitrateInKbit <= Tt);
            return ct && ct.length !== 0 ? ct.reduce((V, mt) => mt.absoluteIndex > V.absoluteIndex ? mt : V) : nt;
          }, getPossibleVoRepresentations: function(tt) {
            return ft(tt, !(arguments.length > 1 && arguments[1] !== void 0) || arguments[1]);
          }, getPossibleVoRepresentationsFilteredBySettings: K, getRepresentationByAbsoluteIndex: function(tt, Tt) {
            let yt = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
            return isNaN(tt) || tt < 0 ? null : K(Tt, yt).find((nt) => nt.absoluteIndex === tt);
          }, handleNewMediaInfo: function(tt) {
            x.handleNewMediaInfo(tt);
          }, initialize: function() {
            ht = Tp(y).create(), st = vp(y).create(), x = Ep(y).create({ dashMetrics: Z, customParametersModel: J, mediaPlayerModel: Y, settings: F }), x.initialize(), E.on(St.A.QUALITY_CHANGE_RENDERED, _t, v), E.on(St.A.METRIC_ADDED, vt, v), E.on(et.A.LOADING_PROGRESS, bt, v);
          }, isPlayingAtLowestQuality: function(tt) {
            return K(tt.mediaInfo, !0)[0].id === tt.id;
          }, isPlayingAtTopQuality: function(tt) {
            if (!tt) return !0;
            const Tt = K(tt.mediaInfo, !0);
            return Tt[Tt.length - 1].id === tt.id;
          }, registerStreamType: function(tt, Tt) {
            const yt = Tt.getStreamInfo().id;
            k[yt] || (k[yt] = {}), k[yt][tt] = Tt, H[yt] || (H[yt] = {}), H[yt][tt] = {}, H[yt][tt].state = pt.ALLOW_LOAD, x.getBolaState(tt) === void 0 && x.setBolaState(tt, F.get().streaming.abr.rules.bolaRule.active && !W());
          }, reset: function() {
            G(), E.off(St.A.QUALITY_CHANGE_RENDERED, _t, v), E.off(St.A.METRIC_ADDED, vt, v), E.off(et.A.LOADING_PROGRESS, bt, v), x && x.reset();
          }, setConfig: function(tt) {
            tt && (tt.streamController && (z = tt.streamController), tt.throughputController && (At = tt.throughputController), tt.domStorage && (lt = tt.domStorage), tt.mediaPlayerModel && (Y = tt.mediaPlayerModel), tt.customParametersModel && (J = tt.customParametersModel), tt.cmsdModel && (it = tt.cmsdModel), tt.dashMetrics && (Z = tt.dashMetrics), tt.adapter && (D = tt.adapter), tt.videoModel && (N = tt.videoModel), tt.settings && (F = tt.settings), tt.capabilities && (O = tt.capabilities));
          }, setPlaybackQuality: Pt, setWindowResizeEventCalled: function(tt) {
          }, unRegisterStreamType: function(tt, Tt) {
            try {
              k[tt] && k[tt][Tt] && delete k[tt][Tt], H[tt] && H[tt][Tt] && delete H[tt][Tt];
            } catch {
            }
          } }, M = f.getLogger(v), G(), v;
        }
        tu.__dashjs_factory_name = "AbrController";
        const hc = Dt.A.getSingletonFactory(tu);
        Dt.A.updateSingletonFactory(tu.__dashjs_factory_name, hc);
        var fc = hc;
        const wp = /* @__PURE__ */ new Map([[q.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, "loadedmetadata"], [q.A.VIDEO_ELEMENT_READY_STATES.HAVE_CURRENT_DATA, "loadeddata"], [q.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, "canplay"], [q.A.VIDEO_ELEMENT_READY_STATES.HAVE_ENOUGH_DATA, "canplaythrough"]]);
        function mc() {
          let y, f, E, v, M, x, z, O, k, H, B;
          const D = this.context, N = (0, It.A)(D).getInstance(), Y = [];
          function J(bt) {
            v && (arguments.length > 1 && arguments[1] !== void 0 && arguments[1] ? v.playbackRate = bt : ft(q.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, () => {
              v.playbackRate = bt;
            }));
          }
          function it() {
            return Y.length > 0;
          }
          function lt(bt) {
            let _t = Y.indexOf(bt);
            if (bt !== null && (_t !== -1 && Y.splice(_t, 1), E.get().streaming.buffer.syntheticStallEvents.enabled && v && !it())) {
              const vt = () => {
                if (J(H || 1, E.get().streaming.buffer.syntheticStallEvents.ignoreReadyState), !v.paused) {
                  const Pt = document.createEvent("Event");
                  Pt.initEvent("playing", !0, !1), v.dispatchEvent(Pt);
                }
              };
              E.get().streaming.buffer.syntheticStallEvents.ignoreReadyState ? vt() : (z && z.func && z.event && ht(z.event, z.func), z = ft(q.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA, vt));
            }
          }
          function at() {
            if (v && it() && v.playbackRate === 0) {
              const bt = document.createEvent("Event");
              bt.initEvent("waiting", !0, !1), v.dispatchEvent(bt);
            }
          }
          function st(bt, _t) {
            v && v.addEventListener(bt, _t);
          }
          function ht(bt, _t) {
            v && v.removeEventListener(bt, _t);
          }
          function At() {
            return v ? v.readyState : NaN;
          }
          function Z() {
            return v ? v.buffered : null;
          }
          function F() {
            return v ? v.clientWidth : NaN;
          }
          function G() {
            return v ? v.clientHeight : NaN;
          }
          function K(bt, _t, vt, Pt, Ot) {
            if (v) {
              for (let W = 0; W < v.textTracks.length; W++) if (v.textTracks[W].kind === bt && (!_t || v.textTracks[W].label == _t) && v.textTracks[W].language === vt && v.textTracks[W].isTTML === Pt && v.textTracks[W].isEmbedded === Ot) return v.textTracks[W];
            }
            return null;
          }
          function ft(bt, _t) {
            return bt === q.A.VIDEO_ELEMENT_READY_STATES.HAVE_NOTHING || At() >= bt ? (_t(), null) : function(vt, Pt) {
              const Ot = () => {
                ht(vt, Ot), Pt(vt);
              };
              return st(vt, Ot), { func: Ot, event: vt };
            }(wp.get(bt), _t);
          }
          return y = { addEventListener: st, addTextTrack: function(bt, _t, vt, Pt, Ot) {
            if (!v) return null;
            let W = K(bt, _t, vt, Pt, Ot);
            return W || (W = v.addTextTrack(bt, _t, vt), W.isEmbedded = Ot, W.isTTML = Pt), W;
          }, appendChild: function(bt) {
            v && (v.appendChild(bt), bt.isTTML !== void 0 && (v.textTracks[v.textTracks.length - 1].isTTML = bt.isTTML, v.textTracks[v.textTracks.length - 1].isEmbedded = bt.isEmbedded));
          }, getBufferRange: Z, getClientHeight: G, getClientWidth: F, getElement: function() {
            return v;
          }, getEnded: function() {
            return v ? v.ended : null;
          }, getPlaybackQuality: function() {
            if (!v) return null;
            let bt = "webkitDroppedFrameCount" in v && "webkitDecodedFrameCount" in v, _t = null;
            return "getVideoPlaybackQuality" in v ? _t = v.getVideoPlaybackQuality() : bt && (_t = { droppedVideoFrames: v.webkitDroppedFrameCount, totalVideoFrames: v.webkitDroppedFrameCount + v.webkitDecodedFrameCount, creationTime: /* @__PURE__ */ new Date() }), _t;
          }, getPlaybackRate: function() {
            return v ? v.playbackRate : null;
          }, getPlayedRanges: function() {
            return v ? v.played : null;
          }, getReadyState: At, getSource: function() {
            return v ? v.src : null;
          }, getTTMLRenderingDiv: function() {
            return O;
          }, getTextTrack: K, getTextTracks: function() {
            return v ? v.textTracks : [];
          }, getTime: function() {
            return v ? isNaN(M) ? v.currentTime : M : null;
          }, getVideoElementSize: function() {
            const bt = E.get().streaming.abr.usePixelRatioInLimitBitrateByPortal && window.hasOwnProperty("devicePixelRatio") ? window.devicePixelRatio : 1;
            return { elementWidth: F() * bt, elementHeight: G() * bt };
          }, getVideoHeight: function() {
            return v ? v.videoHeight : NaN;
          }, getVideoRelativeOffsetLeft: function() {
            if (v) {
              const bt = v.parentNode.host || v.parentNode;
              return bt ? v.getBoundingClientRect().left - bt.getBoundingClientRect().left : NaN;
            }
            return NaN;
          }, getVideoRelativeOffsetTop: function() {
            if (v) {
              const bt = v.parentNode.host || v.parentNode;
              return bt ? v.getBoundingClientRect().top - bt.getBoundingClientRect().top : NaN;
            }
            return NaN;
          }, getVideoWidth: function() {
            return v ? v.videoWidth : NaN;
          }, getVttRenderingDiv: function() {
            return k;
          }, initialize: function() {
            N.on(et.A.PLAYBACK_PLAYING, at, this);
          }, isPaused: function() {
            return v ? v.paused : null;
          }, isSeeking: function() {
            return v ? v.seeking || !isNaN(M) : null;
          }, isStalled: it, pause: function() {
            v && (v.pause(), v.autoplay = !1);
          }, play: function() {
            if (v) {
              v.autoplay = !0;
              const bt = v.play();
              bt && bt.catch && typeof Promise < "u" && bt.catch((_t) => {
                _t.name === "NotAllowedError" && N.trigger(et.A.PLAYBACK_NOT_ALLOWED), f.warn(`Caught pending play exception - continuing (${_t})`);
              });
            }
          }, removeChild: function(bt) {
            v && v.removeChild(bt);
          }, removeEventListener: ht, reset: function() {
            clearTimeout(B), N.off(et.A.PLAYBACK_PLAYING, at, this), Y.length = 0;
          }, setConfig: function(bt) {
            bt && bt.settings && (E = bt.settings);
          }, setCurrentTime: function(bt, _t) {
            v && (x && x.func && x.event && ht(x.event, x.func), M = bt, x = ft(q.A.VIDEO_ELEMENT_READY_STATES.HAVE_METADATA, () => {
              if (v) if (v.currentTime !== M) try {
                M = _t ? function(vt) {
                  const Pt = Z();
                  let Ot = vt, W = 9999999999;
                  if (Pt) for (let tt = 0; tt < Pt.length; tt++) {
                    const Tt = Pt.start(tt), yt = Pt.end(tt), nt = Math.abs(Tt - vt), ct = Math.abs(yt - vt);
                    if (vt >= Tt && vt <= yt) return vt;
                    nt < W && (W = nt, Ot = Tt), ct < W && (W = ct, Ot = yt);
                  }
                  return Ot;
                }(M) : M, isNaN(M) || (v.currentTime = M), M = NaN;
              } catch (vt) {
                v.readyState === 0 && vt.code === vt.INVALID_STATE_ERR && (B = setTimeout(function() {
                  v.currentTime = M, M = NaN;
                }, 400));
              }
              else M = NaN;
            }));
          }, setDisableRemotePlayback: function(bt) {
            v && (v.disableRemotePlayback = bt);
          }, setElement: function(bt) {
            if (!(bt == null || bt && /^(VIDEO|AUDIO)$/i.test(bt.nodeName))) throw "element is not video or audio DOM type!";
            v = bt, v && (v.preload = "auto");
          }, setPlaybackRate: J, setSource: function(bt) {
            v && (bt ? v.src = bt : (v.removeAttribute("src"), v.load()));
          }, setStallState: function(bt, _t) {
            (function(vt, Pt) {
              Pt ? function(Ot) {
                if (Ot !== null && v && !v.seeking && Y.indexOf(Ot) === -1 && (Y.push(Ot), E.get().streaming.buffer.syntheticStallEvents.enabled && v && Y.length === 1 && (E.get().streaming.buffer.syntheticStallEvents.ignoreReadyState || At() >= q.A.VIDEO_ELEMENT_READY_STATES.HAVE_FUTURE_DATA))) {
                  H = v.playbackRate, J(0, !0);
                  const W = document.createEvent("Event");
                  W.initEvent("waiting", !0, !1), v.dispatchEvent(W);
                }
              }(vt) : lt(vt);
            })(bt, _t);
          }, setTTMLRenderingDiv: function(bt) {
            O = bt, O.style.position = "absolute", O.style.display = "flex", O.style.overflow = "hidden", O.style.pointerEvents = "none", O.style.top = 0, O.style.left = 0;
          }, setVttRenderingDiv: function(bt) {
            k = bt;
          }, waitForReadyState: ft }, f = (0, ae.A)(D).getInstance().getLogger(y), E = (0, Q.A)(D).getInstance(), M = NaN, y;
        }
        mc.__dashjs_factory_name = "VideoModel";
        var Ap = Dt.A.getSingletonFactory(mc);
        const Sp = [{ oldKey: "dashjs_vbitrate", newKey: "dashjs_video_bitrate" }, { oldKey: "dashjs_abitrate", newKey: "dashjs_audio_bitrate" }, { oldKey: "dashjs_vsettings", newKey: "dashjs_video_settings" }, { oldKey: "dashjs_asettings", newKey: "dashjs_audio_settings" }], pc = "dashjs_?_bitrate", gc = "dashjs_?_settings", Ls = "localStorage", _c = "lastBitrate", yc = "lastMediaSettings";
        function bc(y) {
          y = y || {};
          const f = this.context, E = y.settings;
          let v, M, x;
          function z(B) {
            if (x !== void 0) return x;
            let D;
            x = !1;
            try {
              typeof window < "u" && (D = window[B]);
            } catch (N) {
              return M.warn("DOMStorage access denied: " + N.message), x;
            }
            if (!D || B !== Ls) return x;
            try {
              D.setItem("1", "1"), D.removeItem("1"), x = !0;
            } catch (N) {
              M.warn("DOMStorage is supported, but cannot be used: " + N.message);
            }
            return x;
          }
          function O() {
            return Math.round((/* @__PURE__ */ new Date()).getTime() / 6e5) * 6e5;
          }
          function k(B, D) {
            return z(B) && E.get().streaming[D + "CachingInfo"].enabled;
          }
          function H() {
            if (!E) throw new Error(q.A.MISSING_CONFIG_ERROR);
          }
          return v = { getSavedBitrateSettings: function(B) {
            if (H(), !E.get().streaming.lastBitrateCachingInfo.enabled) return NaN;
            let D = NaN;
            if (k(Ls, _c)) {
              const N = pc.replace(/\?/, B);
              try {
                const Y = JSON.parse(localStorage.getItem(N)) || {}, J = (/* @__PURE__ */ new Date()).getTime() - parseInt(Y.timestamp, 10) >= E.get().streaming.lastBitrateCachingInfo.ttl || !1, it = parseFloat(Y.bitrate);
                isNaN(it) || J ? J && localStorage.removeItem(N) : (D = it, M.debug("Last saved bitrate for " + B + " was " + it));
              } catch {
                return null;
              }
            }
            return D;
          }, setSavedBitrateSettings: function(B, D) {
            if (k(Ls, _c) && D) {
              const N = pc.replace(/\?/, B);
              try {
                localStorage.setItem(N, JSON.stringify({ bitrate: D.toFixed(3), timestamp: O() }));
              } catch (Y) {
                M.error(Y.message);
              }
            }
          }, getSavedMediaSettings: function(B) {
            if (H(), !E.get().streaming.lastMediaSettingsCachingInfo.enabled) return null;
            let D = null;
            if (k(Ls, yc)) {
              const N = gc.replace(/\?/, B);
              try {
                const Y = JSON.parse(localStorage.getItem(N)) || {}, J = (/* @__PURE__ */ new Date()).getTime() - parseInt(Y.timestamp, 10) >= E.get().streaming.lastMediaSettingsCachingInfo.ttl || !1;
                D = Y.settings, J && (localStorage.removeItem(N), D = null);
              } catch {
                return null;
              }
            }
            return D;
          }, setSavedMediaSettings: function(B, D) {
            if (k(Ls, yc)) {
              const N = gc.replace(/\?/, B);
              try {
                localStorage.setItem(N, JSON.stringify({ settings: D, timestamp: O() }));
              } catch (Y) {
                M.error(Y.message);
              }
            }
          } }, M = (0, ae.A)(f).getInstance().getLogger(v), z(Ls) && Sp.forEach((B) => {
            const D = localStorage.getItem(B.oldKey);
            if (D) {
              localStorage.removeItem(B.oldKey);
              try {
                localStorage.setItem(B.newKey, D);
              } catch (N) {
                M.error(N.message);
              }
            }
          }), v;
        }
        bc.__dashjs_factory_name = "DOMStorage";
        var Mp = Dt.A.getSingletonFactory(bc), kp = b(8986);
        function Ec() {
          const y = this.context;
          let f, E, v, M, x, z, O, k, H, B, D, N;
          function Y(at, st, ht, At) {
            let Z = null;
            const F = at ? N.resolve(at.path) : null, G = At || { init: !0, url: F ? F.url : void 0, range: { start: 0, end: 1500 }, searching: !1, bytesLoaded: 0, bytesToLoad: 1500, mediaType: st, representation: at };
            E.debug("Start searching for initialization.");
            const K = lt(G);
            O.load({ request: K, success: function(ft) {
              if (G.bytesLoaded = G.range.end, Z = M.findInitRange(ft), !Z) return G.range.end = G.bytesLoaded + G.bytesToLoad, Y(at, st, ht, G);
              at.range = Z, ht(at);
            }, error: function() {
              ht(at);
            } }), E.debug("Perform init search: " + G.url);
          }
          function J(at, st, ht, At, Z, F) {
            if (ht && (ht.start === void 0 || ht.end === void 0)) {
              const Pt = ht ? ht.toString().split("-") : null;
              ht = Pt ? { start: parseFloat(Pt[0]), end: parseFloat(Pt[1]) } : null;
            }
            Z = Z || it;
            let G = null, K = null;
            const ft = !!ht, bt = at ? N.resolve(at.path) : null, _t = { init: !1, url: bt ? bt.url : void 0, range: ft ? ht : { start: 0, end: 1500 }, searching: !ft, bytesLoaded: F ? F.bytesLoaded : 0, bytesToLoad: 1500, mediaType: st, representation: at }, vt = lt(_t);
            O.load({ request: vt, success: function(Pt) {
              const Ot = _t.bytesToLoad, W = Pt.byteLength;
              if (_t.bytesLoaded = _t.range.end - _t.range.start, G = M.parse(Pt), K = G.getBox("sidx"), K && K.isComplete) {
                const tt = K.references;
                let Tt, yt;
                if (tt != null && tt.length > 0 && (Tt = tt[0].reference_type === 1), Tt) {
                  let nt, ct, V, mt, Mt;
                  E.debug("Initiate multiple SIDX load."), _t.range.end = _t.range.start + K.size;
                  let Lt = [], Bt = 0, Qt = (K.offset || _t.range.start) + K.size;
                  const Zt = function(fe) {
                    fe ? (Lt = Lt.concat(fe), Bt++, Bt >= ct && (Lt.sort(function(Ue, Ye) {
                      return Ue.startTime - Ye.startTime < 0 ? -1 : 0;
                    }), Z(Lt, at, At))) : Z(null, at, At);
                  };
                  for (nt = 0, ct = tt.length; nt < ct; nt++) V = Qt, mt = Qt + tt[nt].referenced_size - 1, Qt += tt[nt].referenced_size, Mt = { start: V, end: mt }, J(at, st, Mt, At, Zt, _t);
                } else E.debug("Parsing segments from SIDX. representation " + st + " - id: " + at.id + " for range : " + _t.range.start + " - " + _t.range.end), yt = function(nt, ct) {
                  const V = nt.references, mt = V.length, Mt = nt.timescale;
                  let Lt = nt.earliest_presentation_time, Bt = ct.range.start + nt.offset + nt.first_offset + nt.size;
                  const Qt = [];
                  let Zt, fe, Ue, Ye;
                  for (let on = 0; on < mt; on++) Ue = V[on].subsegment_duration, Ye = V[on].referenced_size, Zt = new ke(), Zt.duration = Ue, Zt.startTime = Lt, Zt.timescale = Mt, fe = Bt + Ye - 1, Zt.mediaRange = Bt + "-" + fe, Qt.push(Zt), Lt += Ue, Bt += Ye;
                  return Qt;
                }(K, _t), Z(yt, at, At);
              } else {
                if (K) _t.range.start = K.offset || _t.range.start, _t.range.end = _t.range.start + (K.size || Ot);
                else {
                  if (W < _t.bytesLoaded) return void Z(null, at, At);
                  {
                    const tt = G.getLastBox();
                    tt && tt.size ? (_t.range.start = tt.offset + tt.size, _t.range.end = _t.range.start + Ot) : _t.range.end += Ot;
                  }
                }
                J(at, st, _t.range, At, null, _t);
              }
            }, error: function() {
              Z(null, at, At);
            } }), E.debug(`Perform SIDX load for type ${st} : ${_t.url} with range ${_t.range.start} - ${_t.range.end}`);
          }
          function it(at, st, ht) {
            ht({ segments: at, representation: st, error: at ? void 0 : new Yt.A(k.SEGMENT_BASE_LOADER_ERROR_CODE, k.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
          }
          function lt(at) {
            if (!at.url) return;
            const st = new ze();
            return st.setInfo(at), st;
          }
          return f = { setConfig: function(at) {
            at.baseURLController && (N = at.baseURLController), at.dashMetrics && (x = at.dashMetrics), at.mediaPlayerModel && (z = at.mediaPlayerModel), at.errHandler && (v = at.errHandler), at.boxParser && (M = at.boxParser), at.debug && (E = at.debug.getLogger(f)), at.errors && (k = at.errors), at.urlUtils && (D = at.urlUtils), at.constants && (H = at.constants), at.dashConstants && (B = at.dashConstants);
          }, initialize: function() {
            O = Ha(y).create({ errHandler: v, dashMetrics: x, mediaPlayerModel: z, boxParser: M, errors: k, urlUtils: D, constants: H, dashConstants: B });
          }, loadInitialization: function(at, st) {
            return new Promise((ht) => {
              Y(at, st, ht);
            });
          }, loadSegments: function(at, st, ht) {
            return new Promise((At) => {
              J(at, st, ht, At);
            });
          }, reset: function() {
            O && (O.abort(), O = null);
          } }, f;
        }
        Ec.__dashjs_factory_name = "SegmentBaseLoader";
        var xp = Dt.A.getSingletonFactory(Ec);
        function vc(y) {
          let f;
          y = y || {};
          let E = new DataView(y.data), v = 0;
          function M(z, O) {
            let k, H, B = !0, D = 0;
            if (O === void 0 && (O = !1), z.tag > 16777215 ? (E.getUint32(v) !== z.tag && (B = !1), D = 4) : z.tag > 65535 ? (k = E.getUint16(v), H = E.getUint8(v + 2), 256 * k + H !== z.tag && (B = !1), D = 3) : z.tag > 255 ? (E.getUint16(v) !== z.tag && (B = !1), D = 2) : (E.getUint8(v) !== z.tag && (B = !1), D = 1), !B && z.required && !O) throw new Error("required tag not found");
            return B && (v += D), B;
          }
          function x(z) {
            let O = 1, k = 128, H = -1, B = 0, D = E.getUint8(v), N = 0;
            for (N = 0; N < 8; N += 1) {
              if ((D & k) === k) {
                B = z === void 0 ? D & ~k : D, H = N;
                break;
              }
              k >>= 1;
            }
            for (N = 0; N < H; N += 1, O += 1) B = B << 8 | 255 & E.getUint8(v + O);
            return v += O, B;
          }
          return f = { getPos: function() {
            return v;
          }, setPos: function(z) {
            v = z;
          }, consumeTag: M, consumeTagAndSize: function(z, O) {
            let k = M(z, O);
            return k && x(), k;
          }, parseTag: function(z) {
            let O;
            return M(z), O = x(), f[z.parse](O);
          }, skipOverElement: function(z, O) {
            let k, H = M(z, O);
            return H && (k = x(), v += k), H;
          }, getMatroskaCodedNum: x, getMatroskaFloat: function(z) {
            let O;
            switch (z) {
              case 4:
                O = E.getFloat32(v), v += 4;
                break;
              case 8:
                O = E.getFloat64(v), v += 8;
            }
            return O;
          }, getMatroskaUint: function(z) {
            if (z > 4) return function(k) {
              const H = Math.floor(Number.MAX_SAFE_INTEGER / 256);
              let B = 0;
              for (let D = 0; D < k; D += 1) {
                if (B > H) throw new Error("Value exceeds safe integer limit");
                B *= 256;
                const N = E.getUint8(v + D);
                if (B > Number.MAX_SAFE_INTEGER - N) throw new Error("Value exceeds safe integer limit");
                B += N;
              }
              return v += k, B;
            }(z);
            let O = 0;
            for (let k = 0; k < z; k += 1) O <<= 8, O |= 255 & E.getUint8(v + k);
            return v += z, O >>> 0;
          }, moreData: function() {
            return v < E.byteLength;
          } }, f;
        }
        vc.__dashjs_factory_name = "EBMLParser";
        var Tc = Dt.A.getClassFactory(vc);
        function wc() {
          const y = this.context;
          let f, E, v, M, x, z, O, k, H;
          function B(D) {
            const N = new ze();
            return N.setInfo(D), N;
          }
          return f = { setConfig: function(D) {
            if (!(D.baseURLController && D.dashMetrics && D.mediaPlayerModel && D.errHandler)) throw new Error(q.A.MISSING_CONFIG_ERROR);
            H = D.baseURLController, x = D.dashMetrics, z = D.mediaPlayerModel, M = D.errHandler, k = D.errors, E = D.debug.getLogger(f);
          }, initialize: function() {
            O = Ha(y).create({ errHandler: M, dashMetrics: x, mediaPlayerModel: z, errors: k });
          }, loadInitialization: function(D, N) {
            return new Promise((Y) => {
              let J = null, it = D ? H.resolve(D.path) : null, lt = D ? D.range.split("-") : null, at = { range: { start: lt ? parseFloat(lt[0]) : null, end: lt ? parseFloat(lt[1]) : null }, request: J, url: it ? it.url : void 0, init: !0, mediaType: N };
              E.info("Start loading initialization."), J = B(at), O.load({ request: J, success: function() {
                Y(D);
              }, error: function() {
                Y(D);
              } }), E.debug("Perform init load: " + at.url);
            });
          }, loadSegments: function(D, N, Y) {
            return new Promise((J) => {
              let it = null, lt = D ? H.resolve(D.path) : null, at = lt ? lt.url : void 0;
              it = B({ bytesLoaded: 0, bytesToLoad: 8192, range: { start: 0, end: 8192 }, request: it, url: at, init: !1, mediaType: N, representation: D }), E.debug("Parsing ebml header"), O.load({ request: it, success: function(st) {
                (function(ht, At, Z, F) {
                  if (!ht || ht.byteLength === 0) return void F(null);
                  let G, K, ft, bt, _t = Tc(y).create({ data: ht }), vt = Z ? Z.split("-") : null, Pt = null, Ot = { url: At, range: { start: vt ? parseFloat(vt[0]) : null, end: vt ? parseFloat(vt[1]) : null }, request: Pt };
                  for (E.debug("Parse EBML header: " + Ot.url), _t.skipOverElement(v.EBML), _t.consumeTag(v.Segment), ft = _t.getMatroskaCodedNum(), ft += _t.getPos(), bt = _t.getPos(); _t.moreData() && !_t.consumeTagAndSize(v.Segment.Info, !0); ) if (!(_t.skipOverElement(v.Segment.SeekHead, !0) || _t.skipOverElement(v.Segment.Tracks, !0) || _t.skipOverElement(v.Segment.Cues, !0) || _t.skipOverElement(v.Void, !0))) throw new Error("no valid top level element found");
                  for (; G === void 0; ) {
                    let W = _t.getMatroskaCodedNum(!0), tt = _t.getMatroskaCodedNum();
                    W === v.Segment.Info.Duration.tag ? G = _t[v.Segment.Info.Duration.parse](tt) : _t.setPos(_t.getPos() + tt);
                  }
                  Pt = B(Ot), O.load({ request: Pt, success: function(W) {
                    K = function(tt, Tt, yt, nt) {
                      let ct, V, mt, Mt, Lt, Bt, Qt, Zt;
                      for (V = function(fe) {
                        let Ue, Ye, on = [], cn = Tc(y).create({ data: fe });
                        for (cn.consumeTagAndSize(v.Segment.Cues); cn.moreData() && cn.consumeTagAndSize(v.Segment.Cues.CuePoint, !0); ) {
                          for (Ue = {}, Ue.CueTime = cn.parseTag(v.Segment.Cues.CuePoint.CueTime), Ue.CueTracks = []; cn.moreData() && cn.consumeTag(v.Segment.Cues.CuePoint.CueTrackPositions, !0); ) {
                            const Nn = cn.getMatroskaCodedNum(), Qe = cn.getPos();
                            if (Ye = {}, Ye.Track = cn.parseTag(v.Segment.Cues.CuePoint.CueTrackPositions.CueTrack), Ye.Track === 0) throw new Error("Cue track cannot be 0");
                            Ye.ClusterPosition = cn.parseTag(v.Segment.Cues.CuePoint.CueTrackPositions.CueClusterPosition), Ue.CueTracks.push(Ye), cn.setPos(Qe + Nn);
                          }
                          if (Ue.CueTracks.length === 0) throw new Error("Mandatory cuetrack not found");
                          on.push(Ue);
                        }
                        if (on.length === 0) throw new Error("mandatory cuepoint not found");
                        return on;
                      }(tt), mt = [], Lt = 0, Bt = V.length; Lt < Bt; Lt += 1) Mt = new ke(), ct = 0, ct = Lt < V.length - 1 ? V[Lt + 1].CueTime - V[Lt].CueTime : nt - V[Lt].CueTime, Mt.duration = ct, Mt.startTime = V[Lt].CueTime, Mt.timescale = 1e3, Qt = V[Lt].CueTracks[0].ClusterPosition + Tt, Zt = Lt < V.length - 1 ? V[Lt + 1].CueTracks[0].ClusterPosition + Tt - 1 : yt - 1, Mt.mediaRange = Qt + "-" + Zt, mt.push(Mt);
                      return E.debug("Parsed cues: " + mt.length + " cues."), mt;
                    }(W, bt, ft, G), F(K);
                  }, error: function() {
                    E.error("Download Error: Cues " + Ot.url), F(null);
                  } }), E.debug("Perform cues load: " + Ot.url + " bytes=" + Ot.range.start + "-" + Ot.range.end);
                })(st, at, Y, function(ht) {
                  J({ segments: ht, representation: D, error: ht ? void 0 : new Yt.A(k.SEGMENT_BASE_LOADER_ERROR_CODE, k.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
                });
              }, error: function() {
                J({ representation: D, error: new Yt.A(k.SEGMENT_BASE_LOADER_ERROR_CODE, k.SEGMENT_BASE_LOADER_ERROR_MESSAGE) });
              } });
            });
          }, reset: function() {
            O && (O.abort(), O = null);
          } }, v = { EBML: { tag: 440786851, required: !0 }, Segment: { tag: 408125543, required: !0, SeekHead: { tag: 290298740, required: !0 }, Info: { tag: 357149030, required: !0, TimecodeScale: { tag: 2807729, required: !0, parse: "getMatroskaUint" }, Duration: { tag: 17545, required: !0, parse: "getMatroskaFloat" } }, Tracks: { tag: 374648427, required: !0 }, Cues: { tag: 475249515, required: !0, CuePoint: { tag: 187, required: !0, CueTime: { tag: 179, required: !0, parse: "getMatroskaUint" }, CueTrackPositions: { tag: 183, required: !0, CueTrack: { tag: 247, required: !0, parse: "getMatroskaUint" }, CueClusterPosition: { tag: 241, required: !0, parse: "getMatroskaUint" } } } } }, Void: { tag: 236, required: !0 } }, f;
        }
        wc.__dashjs_factory_name = "WebmSegmentBaseLoader";
        var Lp = Dt.A.getSingletonFactory(wc);
        function Ac(y) {
          y = y || {};
          const f = this.context, E = y.eventBus, v = y.events, M = y.dashMetrics, x = y.mediaPlayerModel, z = y.errHandler, O = y.baseURLController, k = y.debug, H = y.boxParser, B = y.errors;
          let D, N, Y;
          function J(it) {
            return (it ? it.split("/")[1] : "").toLowerCase() === "webm";
          }
          return D = { initialize: function() {
            N.initialize(), Y.initialize();
          }, getSegmentBaseInitSegment: function(it) {
            return J(it.representation.mimeType) ? Y.loadInitialization(it.representation, it.mediaType) : N.loadInitialization(it.representation, it.mediaType);
          }, getSegmentList: function(it) {
            return J(it.mimeType) ? Y.loadSegments(it.representation, it.mediaType, it.representation ? it.representation.indexRange : null) : N.loadSegments(it.representation, it.mediaType, it.representation ? it.representation.indexRange : null);
          }, reset: function() {
            N.reset(), Y.reset();
          } }, N = xp(f).getInstance(), Y = Lp(f).getInstance(), N.setConfig({ baseURLController: O, dashMetrics: M, mediaPlayerModel: x, errHandler: z, eventBus: E, events: v, errors: B, debug: k, boxParser: H }), Y.setConfig({ baseURLController: O, dashMetrics: M, mediaPlayerModel: x, errHandler: z, eventBus: E, events: v, errors: B, debug: k }), D;
        }
        Ac.__dashjs_factory_name = "SegmentBaseController";
        var Dp = Dt.A.getSingletonFactory(Ac), eu = class {
          constructor() {
            this.accessibility = null, this.adaptationSetSwitchingCompatibleIds = [], this.audioChannelConfiguration = null, this.bitrateList = null, this.codec = null, this.contentProtection = null, this.essentialProperties = [], this.id = null, this.index = null, this.isEmbedded = null, this.isFragmented = null, this.isText = !1, this.labels = null, this.lang = null, this.mimeType = null, this.normalizedKeyIds = /* @__PURE__ */ new Set(), this.representationCount = 0, this.roles = null, this.segmentAlignment = !1, this.selectionPriority = 1, this.streamInfo = null, this.subSegmentAlignment = !1, this.supplementalProperties = [], this.type = null, this.viewpoint = null;
          }
        }, Sc = class {
          constructor() {
            this.id = null, this.index = null, this.start = NaN, this.duration = NaN, this.manifestInfo = null, this.isLast = !0, this.isEncrypted = !1;
          }
        }, Ip = class {
          constructor() {
            this.dvrWindowSize = NaN, this.loadedTime = null, this.availableFrom = null, this.minBufferTime = NaN, this.duration = NaN, this.isDynamic = !1, this.maxFragmentDuration = null, this.serviceDescriptions = [], this.protocol = null;
          }
        }, Rp = class {
          constructor(y) {
            this.valid = y[0] == "/", this.path = y.split("/").filter((f) => f.length !== 0).map((f) => {
              let E = { name: f }, v = f.indexOf("[");
              if (v != -1) {
                E.name = f.substring(0, v);
                let M = f.substring(v + 1, f.length - 1);
                this.valid = this.valid && M.indexOf("[") == -1;
                let x = M.indexOf("=");
                x != -1 ? (E.attribute = { name: M.substring(1, x), value: M.substring(x + 1) }, ["'", '"'].indexOf(E.attribute.value[0]) != -1 && (E.attribute.value = E.attribute.value.substring(1, E.attribute.value.length - 1))) : E.position = parseInt(M, 10) - 1;
              }
              return E;
            });
          }
          isValid() {
            return this.valid;
          }
          findsElement() {
            return !this.findsAttribute();
          }
          findsAttribute() {
            return this.path[this.path.length - 1].name.startsWith("@");
          }
          findsTextReplace() {
            return this.path[this.path.length - 1].name === "text()";
          }
          getMpdTarget(y, f) {
            let E = null, v = y, M = 1, x = "MPD";
            for (; M < this.path.length && v !== null; ) {
              E = v;
              let z = this.path[M];
              if (x = z.name, M !== this.path.length - 1 || !x.startsWith("@") && x !== "text()") {
                let O = E[x] || [];
                if (O.length === 0 && E[x] && O.push(E[x]), z.position) v = O[z.position] || null;
                else if (z.attribute) {
                  let k = z.attribute;
                  v = O.filter((H) => H[k.name] == k.value)[0] || null;
                } else v = Array.isArray(O) ? O[0] : O;
              }
              M++;
            }
            return v === null ? null : x.startsWith("@") ? { name: x.substring(1), leaf: v, target: v } : x === "text()" ? { name: "__text", leaf: v, target: v } : { name: x, leaf: v, target: f ? E : v };
          }
        }, Cp = class {
          constructor(y, f, E) {
            this.action = y, this.xpath = f, this.value = E, this.position = null;
          }
          getMpdTarget(y) {
            let f = this.action === "remove" || this.action === "replace" || this.position === "before" || this.position === "after";
            return this.xpath.getMpdTarget(y, f);
          }
        };
        function Mc() {
          let y, f;
          const E = this.context;
          return y = { getIsPatch: function(v) {
            return v && v.hasOwnProperty(I.A.ORIGINAL_MPD_ID) || !1;
          }, getMpdId: function(v) {
            return v && v[I.A.ORIGINAL_MPD_ID] || null;
          }, getOriginalPublishTime: function(v) {
            return v && v.hasOwnProperty(I.A.ORIGINAL_PUBLISH_TIME) ? new Date(v[I.A.ORIGINAL_PUBLISH_TIME]) : null;
          }, getPatchOperations: function(v) {
            return v ? (v.__children || []).map((M) => {
              const x = M.tagName;
              if (x !== "add" && x !== "remove" && x !== "replace") return f.warn(`Ignoring node of invalid action: ${x}`), null;
              let z = M.sel;
              if (x === "add" && M.type) {
                if (!M.type.startsWith("@")) return f.warn(`Ignoring add action for prefixed namespace declaration: ${M.type}=${M.__text}`), null;
                z = `${z}/${M.type}`;
              }
              let O = new Rp(z);
              if (!O.isValid()) return f.warn(`Ignoring action with invalid selector: ${x} - ${z}`), null;
              let k = null;
              O.findsAttribute() || O.findsTextReplace() ? k = M.__text || "" : x !== "remove" && (k = M.__children.reduce((B, D) => {
                let N = D.tagName;
                return N !== "#text" && (B[N] = B[N] || [], B[N].push(D)), B;
              }, {}));
              let H = new Cp(x, O, k);
              return x === "add" && (H.position = M.pos), H;
            }).filter((M) => !!M) : [];
          }, getPublishTime: function(v) {
            return v && v.hasOwnProperty(I.A.PUBLISH_TIME) ? new Date(v[I.A.PUBLISH_TIME]) : null;
          } }, f = (0, ae.A)(E).getInstance().getLogger(y), y;
        }
        Mc.__dashjs_factory_name = "PatchManifestModel";
        var Np = Dt.A.getSingletonFactory(Mc);
        function pa(y) {
          let f = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
          if (typeof TextDecoder < "u") {
            const k = new TextDecoder("utf-8").decode(y);
            if (f) {
              const H = k.indexOf("\0");
              return H !== -1 ? k.substring(0, H) : k;
            }
            return k.replace(/\0/g, "");
          }
          const E = y.length;
          let v, M, x, z = "", O = 0;
          for (; O < E; ) {
            if (v = y[O++], v === 0 && f) return z;
            if (v !== 0 && v !== 3) switch (v >> 4) {
              case 0:
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
                z += String.fromCharCode(v);
                break;
              case 12:
              case 13:
                M = y[O++], z += String.fromCharCode((31 & v) << 6 | 63 & M);
                break;
              case 14:
                M = y[O++], x = y[O++], z += String.fromCharCode((15 & v) << 12 | (63 & M) << 6 | 63 & x);
            }
          }
          return z;
        }
        function nu(y) {
          return function(f, E, v, M) {
            const x = (z = f) instanceof ArrayBuffer ? z : z.buffer;
            var z;
            let O = 1;
            "BYTES_PER_ELEMENT" in M && (O = M.BYTES_PER_ELEMENT);
            const k = (N = f) && N.buffer instanceof ArrayBuffer && N.byteLength !== void 0 && N.byteOffset !== void 0 ? f.byteOffset : 0, H = (k + f.byteLength) / O, B = (k + E) / O, D = Math.floor(Math.max(0, Math.min(B, H)));
            var N;
            return new M(x, D, Math.floor(Math.min(D + Math.max(v, 0), H)) - D);
          }(y, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, Uint8Array);
        }
        function Pp(y) {
          return y.type === "PRIV" ? function(f) {
            if (f.size < 2) return;
            const E = pa(f.data, !0), v = new Uint8Array(f.data.subarray(E.length + 1));
            return { key: f.type, info: E, data: v.buffer };
          }(y) : y.type[0] === "W" ? function(f) {
            if (f.type === "WXXX") {
              if (f.size < 2) return;
              let v = 1;
              const M = pa(f.data.subarray(v), !0);
              v += M.length + 1;
              const x = pa(f.data.subarray(v));
              return { key: f.type, info: M, data: x };
            }
            const E = pa(f.data);
            return { key: f.type, info: "", data: E };
          }(y) : y.type === "APIC" ? function(f) {
            const E = { key: f.type, description: "", data: "", mimeType: null, pictureType: null };
            if (f.size < 2) return;
            if (f.data[0] !== 3) return void console.log("Ignore frame with unrecognized character encoding");
            const v = f.data.subarray(1).indexOf(0);
            if (v === -1) return;
            const M = pa(nu(f.data, 1, v)), x = f.data[2 + v], z = f.data.subarray(3 + v).indexOf(0);
            if (z === -1) return;
            const O = pa(nu(f.data, 3 + v, z));
            let k;
            return k = M === "-->" ? pa(nu(f.data, 4 + v + z)) : (H = f.data.subarray(4 + v + z)) instanceof ArrayBuffer ? H : H.byteOffset == 0 && H.byteLength == H.buffer.byteLength ? H.buffer : new Uint8Array(H).buffer, E.mimeType = M, E.pictureType = x, E.description = O, E.data = k, E;
            var H;
          }(y) : function(f) {
            if (f.size < 2) return;
            if (f.type === "TXXX") {
              let v = 1;
              const M = pa(f.data.subarray(v), !0);
              v += M.length + 1;
              const x = pa(f.data.subarray(v));
              return { key: f.type, info: M, data: x };
            }
            const E = pa(f.data.subarray(1));
            return { key: f.type, info: "", data: E };
          }(y);
        }
        function kc(y, f) {
          let E = 0;
          return E = (127 & y[f]) << 21, E |= (127 & y[f + 1]) << 14, E |= (127 & y[f + 2]) << 7, E |= 127 & y[f + 3], E;
        }
        function zp(y) {
          const f = String.fromCharCode(y[0], y[1], y[2], y[3]), E = kc(y, 4);
          return { type: f, size: E, data: y.subarray(10, 10 + E) };
        }
        function Op(y, f) {
          return f + 10 <= y.length && y[f] === 51 && y[f + 1] === 68 && y[f + 2] === 73 && y[f + 3] < 255 && y[f + 4] < 255 && y[f + 6] < 128 && y[f + 7] < 128 && y[f + 8] < 128 && y[f + 9] < 128;
        }
        function Yp(y, f) {
          return f + 10 <= y.length && y[f] === 73 && y[f + 1] === 68 && y[f + 2] === 51 && y[f + 3] < 255 && y[f + 4] < 255 && y[f + 6] < 128 && y[f + 7] < 128 && y[f + 8] < 128 && y[f + 9] < 128;
        }
        function xc() {
          let y, f, E, v, M, x;
          const z = this.context;
          function O(Z, F) {
            const G = F ? F.index : 0, K = f.getAdaptationsForType(v[G].mpd.manifest, G, Z);
            if (!K || K.length === 0) return null;
            if (K.length > 1 && F) {
              for (let bt = 0, _t = K.length; bt < _t; bt++) if (ft = K[bt], f.getRolesForAdaptation(ft).filter(function(vt) {
                return vt.value === I.A.MAIN;
              })[0]) return K[bt];
            }
            var ft;
            return K[0];
          }
          function k(Z, F, G, K, ft, bt) {
            let _t, vt, Pt, Ot, W, tt, Tt = [];
            if (!K || K.length === 0) return [];
            const yt = f.getAdaptationsForPeriod(F);
            for (Ot = 0, tt = K.length; Ot < tt; Ot++) if (_t = K[Ot], Pt = f.getIndexForAdaptation(_t, Z, G.index), vt = it(yt[Pt]), bt) {
              let nt = vt.accessibility.length;
              for (W = 0; W < nt; W++) {
                if (!vt) continue;
                let ct = vt.accessibility[W];
                if (ct.schemeIdUri === M.ACCESSIBILITY_CEA608_SCHEME) if (ct.value && ct.value !== "") {
                  let V = ct.value.split(";");
                  if (V[0].substring(0, 2) === "CC") for (W = 0; W < V.length; W++) vt || (vt = it.call(this, yt[Pt])), lt(vt, V[W].substring(0, 3), V[W].substring(4)), Tt.push(vt), vt = null;
                  else for (W = 0; W < V.length; W++) vt || (vt = it.call(this, yt[Pt])), lt(vt, "CC" + (W + 1), V[W]), Tt.push(vt), vt = null;
                } else lt(vt, M.CC1, "eng"), Tt.push(vt), vt = null;
              }
            } else ft === M.IMAGE ? (vt.type = M.IMAGE, Tt.push(vt), vt = null) : vt && Tt.push(vt);
            return Tt;
          }
          function H(Z) {
            const F = B(Z);
            return f.getRegularPeriods(F);
          }
          function B(Z) {
            const F = N(Z);
            return f.getMpd(F);
          }
          function D() {
            v = [];
          }
          function N(Z) {
            return Z || (v.length > 0 ? v[0].mpd.manifest : null);
          }
          function Y(Z) {
            try {
              const F = J(Z.streamInfo, v), G = f.getAdaptationsForPeriod(F);
              return Z && Z.streamInfo && Z.streamInfo.id !== void 0 && G ? G[Z.index] : null;
            } catch {
              return null;
            }
          }
          function J(Z, F) {
            const G = F.length;
            for (let K = 0; K < G; K++) {
              let ft = F[K];
              if (Z && Z.id === ft.id) return ft;
            }
            return null;
          }
          function it(Z) {
            if (!Z) return null;
            let F = new eu();
            const G = Z.period.mpd.manifest.Period[Z.period.index].AdaptationSet[Z.index];
            return F.id = Z.id, F.index = Z.index, F.type = Z.type, F.streamInfo = at(Z.period), F.representationCount = f.getRepresentationCount(G), F.labels = f.getLabelsForAdaptation(G), F.lang = f.getLanguageForAdaptation(G), F.segmentAlignment = f.getSegmentAlignment(G), F.subSegmentAlignment = f.getSubSegmentAlignment(G), F.viewpoint = f.getViewpointForAdaptation(G), F.accessibility = f.getAccessibilityForAdaptation(G), F.accessibility.filter(function(K) {
              if (K.schemeIdUri && K.schemeIdUri.search("cea-608") >= 0 && x !== void 0) return !0;
            })[0] && (F.embeddedCaptions = !0), F.audioChannelConfiguration = f.getAudioChannelConfigurationForAdaptation(G), F.audioChannelConfiguration.length === 0 && G.Representation && G.Representation.length > 0 && (F.audioChannelConfiguration = f.getAudioChannelConfigurationForRepresentation(G.Representation[0])), F.roles = f.getRolesForAdaptation(G), F.codec = f.getCodec(G), F.mimeType = f.getMimeType(G), F.contentProtection = f.getContentProtectionByAdaptation(G), F.bitrateList = f.getBitrateListForAdaptation(G), F.selectionPriority = f.getSelectionPriority(G), F.contentProtection && F.contentProtection.length > 0 && (F.contentProtection = function(K, ft) {
              if (!K || !K.length || !ft) return K;
              const bt = f.getContentProtectionByManifest(ft);
              if (!bt || !bt.length) return K;
              const _t = bt.reduce((vt, Pt) => (Pt.refId && vt.set(Pt.refId, Pt), vt), /* @__PURE__ */ new Map());
              return K.map((vt) => {
                if (vt.ref) {
                  const Pt = _t.get(vt.ref);
                  Pt && vt.mergeAttributesFromReference(Pt);
                }
                return vt;
              });
            }(F.contentProtection, Z.period.mpd.manifest), F.contentProtection = function(K) {
              const ft = K.map((bt) => bt.cencDefaultKid).filter((bt) => bt !== null);
              if (ft.length) {
                const bt = ft[0];
                K.forEach((_t) => {
                  _t.keyId = bt;
                });
              }
              return K;
            }(F.contentProtection), F.normalizedKeyIds = function(K) {
              const ft = /* @__PURE__ */ new Set();
              return K.forEach((bt) => {
                bt.cencDefaultKid && typeof bt.cencDefaultKid == "string" && ft.add(bt.cencDefaultKid.replace(/-/g, "").toLowerCase());
              }), ft;
            }(F.contentProtection)), F.isText = f.getIsText(G), F.essentialProperties = f.getCombinedEssentialPropertiesForAdaptationSet(G), F.supplementalProperties = f.getCombinedSupplementalPropertiesForAdaptationSet(G), F.isFragmented = f.getIsFragmented(G), F.isEmbedded = !1, F.adaptationSetSwitchingCompatibleIds = function(K) {
              if (!K || !K.supplementalProperties) return [];
              let ft = [];
              const bt = K.supplementalProperties.filter((_t) => _t.schemeIdUri === I.A.ADAPTATION_SET_SWITCHING_SCHEME_ID_URI);
              return bt && bt.length > 0 && (ft = bt[0].value.toString().split(",").map((_t) => _t)), ft;
            }(F), F;
          }
          function lt(Z, F, G) {
            Z.id = F, Z.index = 100 + parseInt(F.substring(2, 3)), Z.type = M.TEXT, Z.codec = "cea-608-in-SEI", Z.isEmbedded = !0, Z.isFragmented = !1, Z.lang = Go(G), Z.roles = [{ schemeIdUri: "urn:mpeg:dash:role:2011", value: "caption" }];
          }
          function at(Z) {
            let F = new Sc();
            return F.id = Z.id, F.index = Z.index, F.start = Z.start, F.duration = Z.duration, F.manifestInfo = function(G) {
              let K = new Ip();
              return K.dvrWindowSize = G.timeShiftBufferDepth, K.loadedTime = G.manifest.loadedTime, K.availableFrom = G.availabilityStartTime, K.minBufferTime = G.manifest.minBufferTime, K.maxFragmentDuration = G.maxSegmentDuration, K.duration = f.getDuration(G.manifest), K.isDynamic = f.getIsDynamic(G.manifest), K.serviceDescriptions = f.getServiceDescriptions(G.manifest), K.protocol = G.manifest.protocol, K;
            }(Z.mpd), F.isLast = Z.mpd.manifest.Period.length === 1 || Math.abs(F.start + F.duration - F.manifestInfo.duration) < 1, F.isEncrypted = Z.isEncrypted, F;
          }
          function st() {
            if (!M) throw new Error("setConfig function has to be called previously");
          }
          function ht(Z) {
            return v.length > 0 ? v[0].mpd.manifest.Period[Z] : null;
          }
          function At(Z, F, G) {
            let K, ft, bt, _t, vt, Pt;
            if (Z) {
              for (ft = Z.AdaptationSet, vt = 0; vt < ft.length; vt += 1) for (K = ft[vt], _t = K.Representation, Pt = 0; Pt < _t.length; Pt += 1) if (bt = _t[Pt], F === bt.id) return G ? Pt : bt;
            }
            return null;
          }
          return y = { applyPatchToManifest: function(Z, F) {
            E.getPatchOperations(F).forEach((G) => {
              let K = G.getMpdTarget(Z);
              if (K === null) return;
              let { name: ft, target: bt, leaf: _t } = K;
              if (G.xpath.findsAttribute() || ft === "__text") {
                switch (G.action) {
                  case "add":
                  case "replace":
                    bt[ft] = G.value;
                    break;
                  case "remove":
                    delete bt[ft];
                }
                return;
              }
              let vt = (bt[ft] || []).indexOf(_t), Pt = G.position === "prepend" || G.position === "before";
              if (G.action === "remove" || G.action === "replace") if (Array.isArray(bt[ft])) {
                if (vt != -1) {
                  let Ot = bt[ft];
                  Ot.splice(vt, 1), Ot.length > 0 ? bt[ft] = Ot : delete bt[ft];
                }
              } else delete bt[ft];
              G.action !== "add" && G.action !== "replace" || Object.keys(G.value).forEach((Ot) => {
                let W = G.value[Ot], tt = bt[Ot] || [];
                if (tt.length === 0 && bt[Ot] && tt.push(bt[Ot]), tt.length === 0) tt = W;
                else {
                  let Tt = tt.length;
                  Tt = Ot == ft && vt != -1 ? vt + (Pt ? 0 : 1) + (G.action === "replace" ? -1 : 0) : Pt ? 0 : tt.length, tt.splice.apply(tt, [Tt, 0].concat(W));
                }
                bt[Ot] = tt;
              });
            });
          }, areMediaInfosEqual: function(Z, F) {
            if (!Z || !F) return !1;
            const G = Z.id === F.id, K = Z.codec === F.codec, ft = JSON.stringify(Z.viewpoint) === JSON.stringify(F.viewpoint), bt = Z.lang === F.lang, _t = JSON.stringify(Z.roles) === JSON.stringify(F.roles), vt = JSON.stringify(Z.accessibility) === JSON.stringify(F.accessibility), Pt = JSON.stringify(Z.audioChannelConfiguration) === JSON.stringify(F.audioChannelConfiguration);
            return G && K && ft && bt && _t && vt && Pt;
          }, getAllMediaInfoForType: function(Z, F, G) {
            let K = v, ft = G, bt = [];
            if (ft) st(), K = H(ft);
            else {
              if (!(v.length > 0)) return bt;
              ft = v[0].mpd.manifest;
            }
            const _t = J(Z, K);
            let vt = f.getAdaptationsForType(ft, Z ? Z.index : null, F);
            return bt = k(ft, _t, Z, vt, F), F === M.TEXT && (vt = f.getAdaptationsForType(ft, Z ? Z.index : null, M.VIDEO), bt = bt.concat(k(ft, _t, Z, vt, F, !0))), bt;
          }, getAvailabilityStartTime: function(Z) {
            const F = B(Z);
            return f.getAvailabilityStartTime(F);
          }, getBandwidthForRepresentation: function(Z, F) {
            let G;
            return G = At(ht(F), Z), G ? G.bandwidth : null;
          }, getBaseURLsFromElement: function(Z) {
            return f.getBaseURLsFromElement(Z);
          }, getCodec: function(Z, F, G) {
            return f.getCodec(Z, F, G);
          }, getContentSteering: function(Z) {
            return f.getContentSteering(Z);
          }, getDuration: function(Z) {
            const F = N(Z);
            return f.getDuration(F);
          }, getEssentialPropertiesForAdaptationSet: function(Z) {
            try {
              return f.getEssentialPropertiesForRepresentation(Z);
            } catch {
              return [];
            }
          }, getEssentialPropertiesForRepresentation: function(Z) {
            try {
              return f.getEssentialPropertiesForRepresentation(Z);
            } catch {
              return [];
            }
          }, getEvent: function(Z, F, G, K) {
            try {
              if (!Z || !F || isNaN(G) || !K) return null;
              const ft = Z.scheme_id_uri, bt = Z.value;
              if (!F[ft + "/" + bt]) return null;
              const _t = new Xe(), vt = Z.timescale || 1, Pt = K.adaptation.period.start, Ot = F[ft + "/" + bt], W = isNaN(K.presentationTimeOffset) ? isNaN(Ot.presentationTimeOffset) ? 0 : Ot.presentationTimeOffset : K.presentationTimeOffset;
              let tt, Tt = Z.presentation_time_delta / vt;
              tt = Z.version === 0 ? Pt + G - W + Tt : Pt - W + Tt;
              const yt = Z.event_duration / vt, nt = Z.id, ct = Z.message_data;
              return _t.eventStream = Ot, _t.eventStream.value = bt, _t.eventStream.timescale = vt, _t.duration = yt, _t.id = nt, _t.calculatedPresentationTime = tt, _t.messageData = ct, _t.presentationTimeDelta = Tt, _t.parsedMessageData = ft === q.A.ID3_SCHEME_ID_URI ? function(V) {
                let mt = 0;
                const Mt = [];
                for (; Yp(V, mt); ) {
                  const Lt = kc(V, mt + 6);
                  V[mt + 5] >> 6 & 1 && (mt += 10), mt += 10;
                  const Bt = mt + Lt;
                  for (; mt + 10 < Bt; ) {
                    const Qt = zp(V.subarray(mt)), Zt = Pp(Qt);
                    Zt && Mt.push(Zt), mt += Qt.size + 10;
                  }
                  Op(V, mt) && (mt += 10);
                }
                return Mt;
              }(ct) : null, _t;
            } catch {
              return null;
            }
          }, getEventsFor: function(Z, F, G) {
            let K = [];
            if (v.length > 0) {
              const ft = v[0].mpd.manifest;
              if (Z instanceof Sc) {
                const bt = J(Z, v);
                K = f.getEventsForPeriod(bt);
              } else if (Z instanceof eu) {
                const bt = J(G, v);
                K = f.getEventStreamForAdaptationSet(ft, Y(Z), bt);
              } else if (Z instanceof Qn) {
                const bt = J(G, v);
                K = f.getEventStreamForRepresentation(ft, F, bt);
              }
            }
            return K;
          }, getIndexForRepresentation: function(Z, F) {
            return function(G, K) {
              const ft = At(G, K, !0);
              return ft !== null ? ft : -1;
            }(ht(F), Z);
          }, getIsDVB: function(Z) {
            return f.hasProfile(Z, "urn:dvb:dash:profile:dvb-dash:2014");
          }, getIsDynamic: function(Z) {
            const F = N(Z);
            return f.getIsDynamic(F);
          }, getIsPatch: function(Z) {
            return E.getIsPatch(Z);
          }, getIsTextTrack: function(Z) {
            return f.getIsText(Z);
          }, getIsTypeOf: function(Z, F) {
            return f.getIsTypeOf(Z, F);
          }, getLocation: function(Z) {
            return f.getLocation(Z);
          }, getMainAdaptationForType: O, getManifestUpdatePeriod: function(Z) {
            let F = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            return f.getManifestUpdatePeriod(Z, F);
          }, getMediaInfoForType: function(Z, F) {
            if (v.length === 0 || !Z) return null;
            let G = J(Z, v);
            if (!G) return null;
            const K = f.getAdaptationsForPeriod(G);
            let ft = O(F, Z);
            return ft ? it(K[f.getIndexForAdaptation(ft, v[0].mpd.manifest, Z.index)]) : null;
          }, getMpd: B, getPatchLocation: function(Z) {
            const F = f.getPatchLocation(Z), G = f.getPublishTime(Z);
            return F && F.length !== 0 && G ? F.filter((K) => isNaN(K.ttl) || G.getTime() + K.ttl > (/* @__PURE__ */ new Date()).getTime()) : [];
          }, getPeriodById: function(Z) {
            if (!Z || v.length === 0) return null;
            const F = v.filter((G) => G.id === Z);
            return F && F.length > 0 ? F[0] : null;
          }, getProducerReferenceTimes: function(Z, F) {
            let G, K;
            const ft = J(Z, v);
            return G = F ? F.id : null, v.length > 0 && ft && (K = G ? f.getAdaptationForId(G, v[0].mpd.manifest, ft.index) : f.getAdaptationForIndex(F ? F.index : null, v[0].mpd.manifest, ft.index)), K ? f.getProducerReferenceTimesForAdaptation(K) : [];
          }, getPublishTime: function(Z) {
            return f.getPublishTime(Z);
          }, getRealAdaptation: function(Z, F) {
            let G, K;
            const ft = J(Z, v);
            return G = F ? F.id : null, v.length > 0 && ft && (K = G ? f.getAdaptationForId(G, v[0].mpd.manifest, ft.index) : f.getAdaptationForIndex(F ? F.index : null, v[0].mpd.manifest, ft.index)), K;
          }, getRealPeriodByIndex: function(Z) {
            return f.getRealPeriodForIndex(Z, v[0].mpd.manifest);
          }, getRegularPeriods: H, getRepresentationSortFunction: function() {
            return f.getRepresentationSortFunction();
          }, getStreamsInfo: function(Z, F) {
            const G = [];
            let K = v;
            if (Z && (st(), K = H(Z)), K.length > 0) {
              (!F || F > K.length) && (F = K.length);
              for (let ft = 0; ft < F; ft++) G.push(at(K[ft]));
            }
            return G;
          }, getSuggestedPresentationDelay: function() {
            const Z = v.length > 0 ? v[0].mpd : null;
            return f.getSuggestedPresentationDelay(Z);
          }, getSupplementalCodecs: function(Z) {
            const F = Z[I.A.SUPPLEMENTAL_CODECS];
            return F ? F.split(" ").map((G) => Z.mimeType + ';codecs="' + G + '"') : [];
          }, getUTCTimingSources: function() {
            const Z = N();
            return f.getUTCTimingSources(Z);
          }, getVoRepresentations: function(Z) {
            let F;
            const G = Y(Z);
            return F = f.getRepresentationsForAdaptation(G, Z), F;
          }, isPatchValid: function(Z, F) {
            let G = f.getId(Z), K = E.getMpdId(F), ft = f.getPublishTime(Z), bt = E.getPublishTime(F), _t = E.getOriginalPublishTime(F);
            return !!(G && K && G == K && ft && _t && ft.getTime() == _t.getTime() && bt && ft.getTime() < bt.getTime());
          }, reset: D, setConfig: function(Z) {
            Z && (Z.constants && (M = Z.constants), Z.cea608parser && (x = Z.cea608parser), Z.errHandler && f.setConfig({ errHandler: Z.errHandler }), Z.BASE64 && f.setConfig({ BASE64: Z.BASE64 }));
          }, updatePeriods: function(Z) {
            if (!Z) return null;
            st(), v = H(Z);
          } }, f = Zi(z).getInstance(), E = Np(z).getInstance(), D(), y;
        }
        xc.__dashjs_factory_name = "DashAdapter";
        var Fp = Dt.A.getSingletonFactory(xc);
        class Up {
          static round10(f, E) {
            return function(v, M, x) {
              return x === void 0 || +x == 0 ? Math[v](M) : (x = +x, (M = +M) === null || isNaN(M) || typeof x != "number" || x % 1 != 0 ? NaN : (M = M.toString().split("e"), +((M = (M = Math[v](+(M[0] + "e" + (M[1] ? +M[1] - x : -x)))).toString().split("e"))[0] + "e" + (M[1] ? +M[1] + x : x))));
            }("round", f, E);
          }
        }
        var jp = class {
          constructor() {
            this.TcpList = [], this.HttpList = [], this.RepSwitchList = [], this.BufferLevel = [], this.BufferState = [], this.PlayList = [], this.DroppedFrames = [], this.SchedulingInfo = [], this.DVRInfo = [], this.ManifestUpdate = [], this.RequestsQueue = null, this.DVBErrors = [];
          }
        }, Bp = class {
          constructor() {
            this.t = null, this.mt = null, this.to = null, this.lto = null;
          }
        }, Hp = class {
          constructor() {
            this.t = null, this.level = null;
          }
        }, qp = class {
          constructor() {
            this.target = null, this.state = pt.BUFFER_EMPTY;
          }
        }, Gp = class {
          constructor() {
            this.time = null, this.range = null, this.manifestInfo = null;
          }
        }, Vp = class {
          constructor() {
            this.time = null, this.droppedFrames = null;
          }
        };
        class Wp {
          constructor() {
            this.mediaType = null, this.type = null, this.requestTime = null, this.fetchTime = null, this.availabilityStartTime = null, this.presentationStartTime = 0, this.clientTimeOffset = 0, this.currentTime = null, this.buffered = null, this.latency = 0, this.streamInfo = [], this.representationInfo = [];
          }
        }
        class Kp {
          constructor() {
            this.id = null, this.index = null, this.start = null, this.duration = null;
          }
        }
        class $p {
          constructor() {
            this.id = null, this.index = null, this.mediaType = null, this.presentationTimeOffset = null, this.startNumber = null;
          }
        }
        var Xp = class {
          constructor() {
            this.mediaType = null, this.t = null, this.type = null, this.startTime = null, this.availabilityStartTime = null, this.duration = null, this.bandwidth = null, this.range = null, this.state = null;
          }
        }, Qp = class {
          constructor() {
            this.loadingRequests = [], this.executedRequests = [];
          }
        };
        function Lc(y) {
          const f = (y = y || {}).settings;
          let E, v, M = this.context, x = (0, It.A)(M).getInstance();
          function z() {
            x.trigger(et.A.METRICS_CHANGED);
          }
          function O(Y) {
            x.trigger(et.A.METRIC_CHANGED, { mediaType: Y }), z();
          }
          function k(Y, J, it) {
            x.trigger(et.A.METRIC_UPDATED, { mediaType: Y, metric: J, value: it }), O(Y);
          }
          function H(Y, J, it) {
            x.trigger(et.A.METRIC_ADDED, { mediaType: Y, metric: J, value: it }), O(Y);
          }
          function B(Y, J) {
            let it = null;
            return Y && (v.hasOwnProperty(Y) ? it = v[Y] : J || (it = new jp(), v[Y] = it)), it;
          }
          function D(Y, J, it) {
            let lt = B(Y);
            lt !== null && (lt[J].push(it), lt[J].length > f.get().streaming.metrics.maxListDepth && lt[J].shift());
          }
          function N(Y, J, it) {
            D(Y, J, it), H(Y, J, it);
          }
          return E = { addBufferLevel: function(Y, J, it) {
            let lt = new Hp();
            lt.t = J, lt.level = it, N(Y, pt.BUFFER_LEVEL, lt);
          }, addBufferState: function(Y, J, it) {
            let lt = new qp();
            lt.target = it, lt.state = J, N(Y, pt.BUFFER_STATE, lt);
          }, addDVBErrors: function(Y) {
            N(q.A.STREAM, pt.DVB_ERRORS, Y);
          }, addDVRInfo: function(Y, J, it, lt) {
            let at = new Gp();
            at.time = J, at.range = lt, at.manifestInfo = it, N(Y, pt.DVR_INFO, at);
          }, addDroppedFrames: function(Y, J) {
            let it = new Vp(), lt = B(Y).DroppedFrames;
            J && (it.time = J.creationTime, it.droppedFrames = J.droppedVideoFrames, lt.length > 0 && lt[lt.length - 1] == it || N(Y, pt.DROPPED_FRAMES, it));
          }, addHttpRequest: function Y(J, it, lt, at) {
            let st = new Ct.G();
            it.url && it.url !== J.url && (Y({ mediaType: J.mediaType, type: J.type, url: J.url, quality: J.quality, serviceLocation: null, range: J.range, startDate: J.startDate, firstByteDate: null, endDate: null, duration: J.duration, fileLoaderType: J.fileLoaderType, resourceTimingValues: J.resourceTimingValues }, { url: null, status: null, headers: null }, null, at), st.actualurl = it.url), st.tcpid = null, st.type = J.type, st.url = J.url, st.range = J.range || null, st.trequest = J.startDate, st.tresponse = J.firstByteDate, st.responsecode = it.status, st.cmsd = at, st._tfinish = J.endDate, st._stream = J.mediaType, st._mediaduration = J.duration, st._quality = J.quality, st._responseHeaders = "";
            for (const ht in it.headers) st._responseHeaders += ht + ": " + it.headers[ht] + `\r
`;
            st._serviceLocation = J.serviceLocation || null, st._fileLoaderType = J.fileLoaderType, st._resourceTimingValues = J.resourceTimingValues, st._streamId = J && J.representation && J.representation.mediaInfo && J.representation.mediaInfo.streamInfo ? J.representation.mediaInfo.streamInfo.id : null, lt ? lt.forEach((ht) => {
              (function(At, Z, F, G) {
                let K = new Ct.N();
                K.s = Z, K.d = F, K.b = G, At.trace.push(K), At.interval || (At.interval = 0), At.interval += F;
              })(st, ht.s, ht.d, ht.b, ht.t);
            }) : (delete st.interval, delete st.trace), N(J.mediaType, pt.HTTP_REQUEST, st);
          }, addManifestUpdate: function(Y, J, it, lt) {
            let at = new Wp();
            at.mediaType = Y, at.type = J, at.requestTime = it, at.fetchTime = lt, D(q.A.STREAM, pt.MANIFEST_UPDATE, at), H(Y, pt.MANIFEST_UPDATE, at);
          }, addManifestUpdateRepresentationInfo: function(Y, J, it) {
            if (Y && Y.representationInfo) {
              const lt = new $p();
              lt.id = J ? J.id : null, lt.index = J ? J.index : null, lt.mediaType = it, lt.startNumber = J ? J.startNumber : null, lt.presentationTimeOffset = J ? J.presentationTimeOffset : null, Y.representationInfo.push(lt), k(Y.mediaType, pt.MANIFEST_UPDATE_TRACK_INFO, Y);
            }
          }, addManifestUpdateStreamInfo: function(Y, J, it, lt, at) {
            if (Y) {
              let st = new Kp();
              st.id = J, st.index = it, st.start = lt, st.duration = at, Y.streamInfo.push(st), k(Y.mediaType, pt.MANIFEST_UPDATE_STREAM_INFO, Y);
            }
          }, addPlayList: function(Y) {
            Y.trace && Array.isArray(Y.trace) ? Y.trace.forEach((J) => {
              J.hasOwnProperty("subreplevel") && !J.subreplevel && delete J.subreplevel;
            }) : delete Y.trace, N(q.A.STREAM, pt.PLAY_LIST, Y);
          }, addRepresentationSwitch: function(Y, J, it, lt, at) {
            let st = new Bp();
            st.t = J, st.mt = it, st.to = lt, at ? st.lto = at : delete st.lto, N(Y, pt.TRACK_SWITCH, st);
          }, addRequestsQueue: function(Y, J, it) {
            let lt = new Qp();
            lt.loadingRequests = J, lt.executedRequests = it, B(Y).RequestsQueue = lt, H(Y, pt.REQUESTS_QUEUE, lt);
          }, addSchedulingInfo: function(Y, J, it, lt, at, st, ht, At, Z) {
            let F = new Xp();
            F.mediaType = Y, F.t = J, F.type = it, F.startTime = lt, F.availabilityStartTime = at, F.duration = st, F.bandwidth = ht, F.range = At, F.state = Z, N(Y, pt.SCHEDULING_INFO, F);
          }, clearAllCurrentMetrics: function() {
            v = {}, z();
          }, clearCurrentMetricsForType: function(Y) {
            delete v[Y], O(Y);
          }, getMetricsFor: B, updateManifestUpdateInfo: function(Y, J) {
            if (Y) {
              for (let it in J) Y[it] = J[it];
              k(Y.mediaType, pt.MANIFEST_UPDATE, Y);
            }
          } }, v = {}, E;
        }
        Lc.__dashjs_factory_name = "MetricsModel";
        var Jp = Dt.A.getSingletonFactory(Lc);
        function Dc(y) {
          y = y || {};
          const f = this.context;
          let E, v, M, x, z = y.metricsModel;
          function O(B) {
            const D = z.getMetricsFor(B, !0);
            if (!D) return null;
            const N = D.HttpList;
            let Y, J = null;
            if (!N || N.length <= 0) return null;
            for (Y = N.length - 1; Y >= 0; ) {
              if (N[Y].responsecode) {
                J = N[Y];
                break;
              }
              Y--;
            }
            return J;
          }
          function k(B) {
            const D = z.getMetricsFor(B, !0);
            return D && D.HttpList ? D.HttpList : [];
          }
          function H(B, D) {
            if (!B) return null;
            const N = B[D];
            return N && N.length !== 0 ? N[N.length - 1] : null;
          }
          return E = { getCurrentRepresentationSwitch: function(B) {
            return H(z.getMetricsFor(B, !0), pt.TRACK_SWITCH);
          }, getCurrentBufferState: function(B) {
            return H(z.getMetricsFor(B, !0), pt.BUFFER_STATE);
          }, getCurrentBufferLevel: function(B) {
            const D = H(z.getMetricsFor(B, !0), pt.BUFFER_LEVEL);
            return D ? Up.round10(D.level / 1e3, -3) : 0;
          }, getCurrentHttpRequest: O, getHttpRequests: k, getCurrentDroppedFrames: function() {
            return H(z.getMetricsFor(q.A.VIDEO, !0), pt.DROPPED_FRAMES);
          }, getCurrentSchedulingInfo: function(B) {
            return H(z.getMetricsFor(B, !0), pt.SCHEDULING_INFO);
          }, getCurrentDVRInfo: function(B) {
            return H(B ? z.getMetricsFor(B, !0) : z.getMetricsFor(q.A.VIDEO, !0) || z.getMetricsFor(q.A.AUDIO, !0) || z.getMetricsFor(q.A.MESH, !0), pt.DVR_INFO);
          }, getCurrentManifestUpdate: function() {
            return H(z.getMetricsFor(q.A.STREAM), pt.MANIFEST_UPDATE);
          }, getLatestFragmentRequestHeaderValueByID: function(B, D) {
            if (!D) return null;
            let N = {}, Y = O(B);
            Y && (N = ai.A.parseHttpHeaders(Y._responseHeaders));
            const J = N[D.toLowerCase()];
            return J === void 0 ? null : J;
          }, getLatestMPDRequestHeaderValueByID: function(B) {
            if (!B) return null;
            let D, N, Y, J = {};
            for (D = k(q.A.STREAM), Y = D.length - 1; Y >= 0; Y--) if (N = D[Y], N.type === Ct.G.MPD_TYPE) {
              J = ai.A.parseHttpHeaders(N._responseHeaders);
              break;
            }
            const it = J[B.toLowerCase()];
            return it === void 0 ? null : it;
          }, addRepresentationSwitch: function(B, D, N, Y, J) {
            z.addRepresentationSwitch(B, D, N, Y, J);
          }, addDVRInfo: function(B, D, N, Y) {
            z.addDVRInfo(B, D, N, Y);
          }, updateManifestUpdateInfo: function(B) {
            const D = this.getCurrentManifestUpdate();
            z.updateManifestUpdateInfo(D, B);
          }, addManifestUpdateStreamInfo: function(B) {
            if (B) {
              const D = this.getCurrentManifestUpdate();
              z.addManifestUpdateStreamInfo(D, B.id, B.index, B.start, B.duration);
            }
          }, addManifestUpdateRepresentationInfo: function(B, D) {
            if (B) {
              const N = this.getCurrentManifestUpdate();
              z.addManifestUpdateRepresentationInfo(N, B, D);
            }
          }, addManifestUpdate: function(B) {
            z.addManifestUpdate(q.A.STREAM, B.type, B.startDate, B.endDate);
          }, addHttpRequest: function(B, D, N, Y, J, it) {
            const lt = { status: N, headers: Y, url: D };
            z.addHttpRequest(B, lt, J, it);
          }, addSchedulingInfo: function(B, D) {
            z.addSchedulingInfo(B.mediaType, /* @__PURE__ */ new Date(), B.type, B.startTime, B.availabilityStartTime, B.duration, B.bandwidth, B.range, D);
          }, addRequestsQueue: function(B, D, N) {
            z.addRequestsQueue(B, D, N);
          }, addBufferLevel: function(B, D, N) {
            z.addBufferLevel(B, D, N);
          }, addBufferState: function(B, D, N) {
            z.addBufferState(B, D, N);
          }, addDroppedFrames: function(B) {
            z.addDroppedFrames(q.A.VIDEO, B);
          }, addPlayList: function() {
            x && (z.addPlayList(x), x = null);
          }, addDVBErrors: function(B) {
            z.addDVBErrors(B);
          }, createPlaylistMetrics: function(B, D) {
            x = new $e(), x.start = /* @__PURE__ */ new Date(), x.mstart = B, x.starttype = D;
          }, createPlaylistTraceMetrics: function(B, D, N) {
            v === !0 && (v = !1, M = new kn(), M.representationid = B, M.start = /* @__PURE__ */ new Date(), M.mstart = D, M.playbackspeed = N !== null ? N.toString() : null);
          }, updatePlayListTraceMetrics: function(B) {
            if (M) for (let D in M) M[D] = B[D];
          }, pushPlayListTraceMetrics: function(B, D) {
            if (v === !1 && x && M && M.start) {
              const N = M.start;
              M.duration = B.getTime() - N.getTime(), M.stopreason = D, x.trace.push(M), v = !0;
            }
          }, clearAllCurrentMetrics: function() {
            z.clearAllCurrentMetrics();
          } }, z = z || Jp(f).getInstance({ settings: y.settings }), v = !0, M = null, x = null, E;
        }
        Dc.__dashjs_factory_name = "DashMetrics";
        var Zp = Dt.A.getSingletonFactory(Dc);
        function Ic() {
          const y = this.context, f = (0, It.A)(y).getInstance(), E = (0, Q.A)(y).getInstance();
          let v, M, x, z;
          function O(at) {
            z = at;
          }
          function k(at, st, ht, At) {
            let Z, F = st.adaptation.period.mpd;
            const G = F.availabilityStartTime;
            if (At) Z = ht && F.timeShiftBufferDepth !== Number.POSITIVE_INFINITY ? new Date(G.getTime() + 1e3 * (at + F.timeShiftBufferDepth)) : F.availabilityEndTime;
            else if (ht) {
              let K = Yi(st.availabilityTimeOffset);
              Z = new Date(G.getTime() + 1e3 * (at - K));
            } else Z = G;
            return Z;
          }
          function H(at, st) {
            return (at.getTime() - st.mpd.availabilityStartTime.getTime() + 1e3 * z) / 1e3;
          }
          function B(at, st) {
            return at + (st.adaptation.period.start - st.presentationTimeOffset);
          }
          function D(at) {
            const st = { start: NaN, end: NaN }, ht = at[0].getAdapter().getRegularPeriods()[0], At = H(/* @__PURE__ */ new Date(), ht);
            if (!at || at.length === 0) return { range: st, now: At };
            at.forEach((F) => {
              let G = F.getCurrentRepresentationForType(q.A.VIDEO);
              if (G || (G = F.getCurrentRepresentationForType(q.A.AUDIO)), !G) {
                const ft = F.getAdapter(), bt = ft.getMediaInfoForType(F.getStreamInfo(), q.A.VIDEO) || ft.getMediaInfoForType(F.getStreamInfo(), q.A.AUDIO) || ft.getMediaInfoForType(F.getStreamInfo(), q.A.MESH);
                G = ft.getVoRepresentations(bt)[0];
              }
              let K = { start: NaN, end: NaN };
              if (G) if (G.segmentInfoType === I.A.SEGMENT_TIMELINE) K = function(ft) {
                const bt = ft.adaptation.period.mpd.manifest.Period[ft.adaptation.period.index].AdaptationSet[ft.adaptation.index], _t = M.getRepresentationFor(ft.index, bt), vt = _t.SegmentTemplate || _t.SegmentList, Pt = vt.SegmentTimeline, Ot = vt.timescale, W = Pt.S, tt = { start: 0, end: 0 }, Tt = W[0].t, yt = !isNaN(Tt), nt = yt ? Tt : 0;
                let ct, V, mt, Mt, Lt = 0;
                for (yt && (tt.start = B(nt / Ot, ft)), mt = 0, Mt = W.length; mt < Mt; mt++) ct = W[mt], V = 0, ct.hasOwnProperty("r") && (V = ct.r), Lt += ct.d * (1 + V);
                return tt.end = B((nt + Lt) / Ot, ft), tt;
              }(G);
              else {
                const ft = G.adaptation.period;
                K.start = ft.start, K.end = Math.max(At, ft.start + ft.duration);
              }
              !isNaN(K.start) && (isNaN(st.start) || st.start > K.start) && (st.start = K.start), !isNaN(K.end) && (isNaN(st.end) || st.end < K.end) && (st.end = K.end);
            }), st.end = Math.min(At, st.end);
            const Z = Y(at, st.end, !0);
            return st.end = isNaN(Z) ? st.end : Z, st.start = ht && ht.mpd && ht.mpd.timeShiftBufferDepth && !isNaN(ht.mpd.timeShiftBufferDepth) && !isNaN(st.end) ? Math.max(st.end - ht.mpd.timeShiftBufferDepth, st.start) : st.start, st.start = Y(at, st.start), { range: st, now: At };
          }
          function N(at, st) {
            x = at - st.end;
          }
          function Y(at, st) {
            let ht = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            try {
              let At = 0, Z = !1, F = NaN;
              for (; !Z && At < at.length; ) {
                const G = at[At].getStreamInfo();
                G.start <= st && (!isFinite(G.duration) || G.start + G.duration >= st) ? (F = st, Z = !0) : !ht && G.start > st && (isNaN(F) || G.start < F) ? F = G.start : ht && G.start + G.duration < st && (isNaN(F) || G.start + G.duration > F) && (F = G.start + G.duration), At += 1;
              }
              return F;
            } catch {
              return st;
            }
          }
          function J(at) {
            at.offset === void 0 || isNaN(at.offset) || O(at.offset / 1e3);
          }
          function it() {
            z = 0, x = 0;
          }
          function lt() {
            f.off(et.A.UPDATE_TIME_SYNC_OFFSET, J, this), it();
          }
          return v = { initialize: function() {
            it(), f.on(et.A.UPDATE_TIME_SYNC_OFFSET, J, this);
          }, getClientTimeOffset: function() {
            return z;
          }, setClientTimeOffset: O, getClientReferenceTime: function() {
            return Date.now() - 1e3 * x + 1e3 * z;
          }, calcAvailabilityStartTimeFromPresentationTime: function(at, st, ht) {
            return k(at, st, ht);
          }, calcAvailabilityEndTimeFromPresentationTime: function(at, st, ht) {
            return k(at, st, ht, !0);
          }, calcPresentationTimeFromWallTime: H, calcPresentationTimeFromMediaTime: B, calcPeriodRelativeTimeFromMpdRelativeTime: function(at, st) {
            return st - at.adaptation.period.start;
          }, calcMediaTimeFromPresentationTime: function(at, st) {
            return at - st.adaptation.period.start + st.presentationTimeOffset;
          }, calcWallTimeForSegment: function(at, st) {
            let ht, At, Z;
            return st && (ht = at.representation.adaptation.period.mpd.suggestedPresentationDelay, At = at.presentationStartTime + ht, Z = new Date(at.availabilityStartTime.getTime() + 1e3 * At)), Z;
          }, calcTimeShiftBufferWindow: function(at, st) {
            if (!st) return function(ht) {
              const At = { start: NaN, end: NaN };
              let Z = 0, F = NaN;
              return ht.forEach((G) => {
                const K = G.getStreamInfo();
                Z += K.duration, (isNaN(F) || K.start < F) && (F = K.start);
              }), At.start = F, At.end = F + Z, At;
            }(at);
            if (E.get().streaming.timeShiftBuffer.calcFromSegmentTimeline) {
              const ht = D(at);
              return N(ht.now, ht.range), ht.range;
            }
            return function(ht) {
              const At = { start: NaN, end: NaN };
              if (!ht || ht.length === 0) return At;
              const Z = ht[0].getAdapter().getRegularPeriods()[0], F = H(/* @__PURE__ */ new Date(), Z), G = Z.mpd.timeShiftBufferDepth, K = isNaN(G) ? 0 : F - G;
              if (At.start = Y(ht, K), At.end = !isNaN(At.start) && F < At.start ? F : Y(ht, F, !0), !isNaN(G) && At.end < F - G && (At.end = NaN), E.get().streaming.timeShiftBuffer.fallbackToSegmentTimeline) {
                const ft = D(ht);
                if (ft.range.end < At.start) return f.trigger(St.A.CONFORMANCE_VIOLATION, { level: pr.LEVELS.WARNING, event: pr.EVENTS.INVALID_DVR_WINDOW }), N(ft.now, ft.range), ft.range;
              }
              return At;
            }(at);
          }, reset: lt }, M = Zi(y).getInstance(), lt(), v;
        }
        Ic.__dashjs_factory_name = "TimelineConverter";
        var $r, iu, co, Zo, ru, tg = Dt.A.getSingletonFactory(Ic), eg = function(y) {
          for (var f = [], E = 0; E < y.length; ++E) {
            var v = y.charCodeAt(E);
            v < 128 ? f.push(v) : v < 2048 ? (f.push(192 | v >> 6), f.push(128 | 63 & v)) : v < 65536 ? (f.push(224 | v >> 12), f.push(128 | 63 & v >> 6), f.push(128 | 63 & v)) : (f.push(240 | v >> 18), f.push(128 | 63 & v >> 12), f.push(128 | 63 & v >> 6), f.push(128 | 63 & v));
          }
          return f;
        }, ng = function(y) {
          for (var f = [], E = 0; E < y.length; ) {
            var v = y[E++];
            v < 128 || (v < 224 ? (v = (31 & v) << 6, v |= 63 & y[E++]) : v < 240 ? (v = (15 & v) << 12, v |= (63 & y[E++]) << 6, v |= 63 & y[E++]) : (v = (7 & v) << 18, v |= (63 & y[E++]) << 12, v |= (63 & y[E++]) << 6, v |= 63 & y[E++])), f.push(String.fromCharCode(v));
          }
          return f.join("");
        }, ga = {};
        $r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", iu = function(y) {
          for (var f = 0, E = [], v = 0 | y.length / 3; 0 < v--; ) {
            var M = (y[f] << 16) + (y[f + 1] << 8) + y[f + 2];
            f += 3, E.push($r.charAt(63 & M >> 18)), E.push($r.charAt(63 & M >> 12)), E.push($r.charAt(63 & M >> 6)), E.push($r.charAt(63 & M));
          }
          return y.length - f == 2 ? (M = (y[f] << 16) + (y[f + 1] << 8), E.push($r.charAt(63 & M >> 18)), E.push($r.charAt(63 & M >> 12)), E.push($r.charAt(63 & M >> 6)), E.push("=")) : y.length - f == 1 && (M = y[f] << 16, E.push($r.charAt(63 & M >> 18)), E.push($r.charAt(63 & M >> 12)), E.push("==")), E.join("");
        }, co = function() {
          for (var y = [], f = 0; f < 64; ++f) y[$r.charCodeAt(f)] = f;
          return y[61] = 0, y;
        }(), Zo = function(y) {
          for (var f = 0, E = [], v = 0 | y.length / 4; 0 < v--; ) {
            var M = (co[y.charCodeAt(f)] << 18) + (co[y.charCodeAt(f + 1)] << 12) + (co[y.charCodeAt(f + 2)] << 6) + co[y.charCodeAt(f + 3)];
            E.push(255 & M >> 16), E.push(255 & M >> 8), E.push(255 & M), f += 4;
          }
          return E && (y.charAt(f - 2) == "=" ? (E.pop(), E.pop()) : y.charAt(f - 1) == "=" && E.pop()), E;
        }, ru = { encode: function(y) {
          for (var f = [], E = 0; E < y.length; ++E) f.push(y.charCodeAt(E));
          return f;
        }, decode: function(y) {
          for (var f = 0; f < s.length; ++f) a[f] = String.fromCharCode(a[f]);
          return a.join("");
        } }, ga.decodeArray = function(y) {
          var f = Zo(y);
          return new Uint8Array(f);
        }, ga.encodeASCII = function(y) {
          var f = ru.encode(y);
          return iu(f);
        }, ga.decodeASCII = function(y) {
          var f = Zo(y);
          return ru.decode(f);
        }, ga.encode = function(y) {
          var f = eg(y);
          return iu(f);
        }, ga.decode = function(y) {
          var f = Zo(y);
          return ng(f);
        }, t.decode = ga.decode, t.decodeArray = ga.decodeArray, t.encode = ga.encode, t.encodeASCII = ga.encodeASCII;
        var au = ga, ig = class extends eu {
          constructor() {
            super(), this.captionData = null, this.label = null, this.defaultTrack = !1, this.kind = null, this.isFragmented = !1, this.isEmbedded = !1, this.isTTML = null;
          }
        }, rg = b(7377);
        function Rc() {
          let y, f = 0;
          function E(k) {
            let H = "";
            for (let B = 0; B < k.length; ++B) H += k[B].uchar;
            return H.length - H.replace(/^\s+/, "").length;
          }
          function v(k) {
            return "left: " + 3.125 * k.x + "%; top: " + 6.66 * k.y1 + "%; width: " + (100 - 3.125 * k.x) + "%; height: " + 6.66 * Math.max(k.y2 - 1 - k.y1, 1) + "%; align-items: flex-start; overflow: visible; -webkit-writing-mode: horizontal-tb;";
          }
          function M(k) {
            return k === "red" ? "rgb(255, 0, 0)" : k === "green" ? "rgb(0, 255, 0)" : k === "blue" ? "rgb(0, 0, 255)" : k === "cyan" ? "rgb(0, 255, 255)" : k === "magenta" ? "rgb(255, 0, 255)" : k === "yellow" ? "rgb(255, 255, 0)" : k === "white" ? "rgb(255, 255, 255)" : k === "black" ? "rgb(0, 0, 0)" : k;
          }
          function x(k, H) {
            const B = k.videoHeight / 15;
            return H ? "font-size: " + B + "px; font-family: Menlo, Consolas, 'Cutive Mono', monospace; color: " + (H.foreground ? M(H.foreground) : "rgb(255, 255, 255)") + "; font-style: " + (H.italics ? "italic" : "normal") + "; text-decoration: " + (H.underline ? "underline" : "none") + "; white-space: pre; background-color: " + (H.background ? M(H.background) : "transparent") + ";" : "font-size: " + B + "px; font-family: Menlo, Consolas, 'Cutive Mono', monospace; justify-content: flex-start; text-align: left; color: rgb(255, 255, 255); font-style: normal; white-space: pre; line-height: normal; font-weight: normal; text-decoration: none; width: 100%; display: flex;";
          }
          function z(k) {
            return k.replace(/^\s+/g, "");
          }
          function O(k) {
            return k.replace(/\s+$/g, "");
          }
          return y = { createHTMLCaptionsFromScreen: function(k, H, B, D) {
            let N = null, Y = null, J = !1, it = -1, lt = { start: H, end: B, spans: [] }, at = "style_cea608_white_black";
            const st = {}, ht = {}, At = [];
            let Z, F;
            for (Z = 0; Z < 15; ++Z) {
              const K = D.rows[Z];
              let ft = "", bt = null;
              if (K.isEmpty() === !1) {
                const _t = E(K.chars);
                N === null && (N = { x: _t, y1: Z, y2: Z + 1, p: [] }), _t !== it && J && (N.p.push(lt), lt = { start: H, end: B, spans: [] }, N.y2 = Z, N.name = "region_" + N.x + "_" + N.y1 + "_" + N.y2, st.hasOwnProperty(N.name) === !1 ? (At.push(N), st[N.name] = N) : (Y = st[N.name], Y.p.contat(N.p)), N = { x: _t, y1: Z, y2: Z + 1, p: [] });
                for (let vt = 0; vt < K.chars.length; ++vt) {
                  const Pt = K.chars[vt], Ot = Pt.penState;
                  if (bt === null || !Ot.equals(bt)) {
                    ft.trim().length > 0 && (lt.spans.push({ name: at, line: ft, row: Z }), ft = "");
                    let W = "style_cea608_" + Ot.foreground + "_" + Ot.background;
                    Ot.underline && (W += "_underline"), Ot.italics && (W += "_italics"), ht.hasOwnProperty(W) || (ht[W] = JSON.parse(JSON.stringify(Ot))), bt = Ot, at = W;
                  }
                  ft += Pt.uchar;
                }
                ft.trim().length > 0 && lt.spans.push({ name: at, line: ft, row: Z }), J = !0, it = _t;
              } else J = !1, it = -1, N && (N.p.push(lt), lt = { start: H, end: B, spans: [] }, N.y2 = Z, N.name = "region_" + N.x + "_" + N.y1 + "_" + N.y2, st.hasOwnProperty(N.name) === !1 ? (At.push(N), st[N.name] = N) : (Y = st[N.name], Y.p.contat(N.p)), N = null);
            }
            N && (N.p.push(lt), N.y2 = Z + 1, N.name = "region_" + N.x + "_" + N.y1 + "_" + N.y2, st.hasOwnProperty(N.name) === !1 ? (At.push(N), st[N.name] = N) : (Y = st[N.name], Y.p.contat(N.p)), N = null);
            const G = [];
            for (Z = 0; Z < At.length; ++Z) {
              const K = At[Z], ft = "sub_cea608_" + f++, bt = document.createElement("div");
              bt.id = ft;
              const _t = v(K);
              bt.style.cssText = "position: absolute; margin: 0; display: flex; box-sizing: border-box; pointer-events: none;" + _t;
              const vt = document.createElement("div");
              vt.className = "paragraph bodyStyle", vt.style.cssText = x(k);
              const Pt = document.createElement("div");
              Pt.className = "cueUniWrapper", Pt.style.cssText = "unicode-bidi: normal; direction: ltr;";
              for (let W = 0; W < K.p.length; ++W) {
                const tt = K.p[W];
                let Tt = 0;
                for (F = 0; F < tt.spans.length; ++F) {
                  let yt = tt.spans[F];
                  if (yt.line.length > 0) {
                    if (F !== 0 && Tt != yt.row) {
                      const mt = document.createElement("br");
                      mt.className = "lineBreak", Pt.appendChild(mt);
                    }
                    let nt = !1;
                    Tt === yt.row && (nt = !0), Tt = yt.row;
                    const ct = ht[yt.name], V = document.createElement("span");
                    V.className = "spanPadding " + yt.name + " customSpanColor", V.style.cssText = x(k, ct), F !== 0 && nt ? F === tt.spans.length - 1 ? V.textContent = O(yt.line) : V.textContent = yt.line : tt.spans.length > 1 && F < tt.spans.length - 1 && yt.row === tt.spans[F + 1].row ? V.textContent = z(yt.line) : V.textContent = yt.line.trim(), Pt.appendChild(V);
                  }
                }
              }
              vt.appendChild(Pt), bt.appendChild(vt);
              const Ot = { bodyStyle: ["%", 90] };
              for (const W in ht) ht.hasOwnProperty(W) && (Ot[W] = ["%", 90]);
              G.push({ type: "html", start: H, end: B, cueHTMLElement: bt, cueID: ft, cellResolution: [32, 15], isFromCEA608: !0, fontSize: Ot, lineHeight: {}, linePadding: {} });
            }
            return G;
          } }, y;
        }
        Rc.__dashjs_factory_name = "EmbeddedTextHtmlRender";
        var ag = Dt.A.getSingletonFactory(Rc);
        function sg(y, f, E) {
          const v = [];
          for (let M = f; M < E; M++) M + 2 < E && y.getUint8(M) === 0 && y.getUint8(M + 1) === 0 && y.getUint8(M + 2) === 3 ? (v.push(0), v.push(0), M += 2) : v.push(y.getUint8(M));
          return new DataView(new Uint8Array(v).buffer);
        }
        function og(y, f, E, v) {
          return !(y !== 4 || f < 8) && E.getUint8(v) === 181 && E.getUint16(v + 1) === 49 && E.getUint32(v + 3) === 1195456820 && E.getUint8(v + 7) === 3;
        }
        function lg(y, f) {
          return (127 & y) > 0 || (127 & f) > 0;
        }
        function ug(y, f) {
          let E = 0;
          for (; E < y.byteLength; ) {
            let M, x = 0, z = 0;
            do
              x += M = y.getUint8(E++);
            while (M === 255);
            do
              z += M = y.getUint8(E++);
            while (M === 255);
            if (og(x, z, y, E)) {
              const O = E + 10, k = O + 3 * (31 & y.getUint8(O - 2));
              for (let H = O; H < k; H += 3) {
                const B = y.getUint8(H);
                if (4 & B) {
                  const D = 3 & B;
                  if ((v = D) === 0 || v === 1) {
                    const N = y.getUint8(H + 1), Y = y.getUint8(H + 2);
                    lg(N, Y) && f[D].push(N, Y);
                  }
                }
              }
            }
            E += z;
          }
          var v;
        }
        function dg(y, f, E) {
          let v = 0, M = 0;
          const x = [[], []];
          for (let z = f; z < f + E - 5 && (v = y.getUint32(z), M = 31 & y.getUint8(z + 4), !(z + 5 + v > f + E)); z++) M === 6 && z + 5 + v <= y.byteLength && ug(sg(y, z + 5, z + 5 + v), x), z += v + 3;
          return x;
        }
        function Cc(y) {
          const f = y.errHandler, E = y.manifestModel, v = y.mediaController, M = y.videoModel, x = y.textTracks, z = y.vttParser, O = y.vttCustomRenderingParser, k = y.ttmlParser, H = y.streamInfo, B = y.settings, D = this.context, N = (0, It.A)(D).getInstance();
          let Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft, bt, _t, vt, Pt, Ot = !1;
          function W() {
            st = null, At = NaN, Z = [], F = null, ht = !1, at = [], lt = null;
          }
          function tt(Lt) {
            const Bt = {};
            Bt[I.A.SUBTITLE] = "subtitles", Bt[I.A.CAPTION] = "captions", Bt[I.A.FORCED_SUBTITLE] = "subtitles";
            const Qt = new ig();
            for (let Zt in Lt) Qt[Zt] = Lt[Zt];
            Qt.defaultTrack = function(Zt) {
              let fe = !1;
              return K.length > 1 && Zt.isEmbedded ? fe = Zt.id && Zt.id === q.A.CC1 : K.length === 1 ? Zt.id && typeof Zt.id == "string" && Zt.id.substring(0, 2) === "CC" && (fe = !0) : K.length === 0 && (fe = Zt.index === at[0].index), fe;
            }(Lt), Qt.isTTML = function(Zt) {
              return Zt.codec && Zt.codec.search(q.A.STPP) >= 0 || Zt.mimeType && Zt.mimeType.search(q.A.TTML) >= 0;
            }(Lt), Qt.kind = function(Zt, fe) {
              let Ue = Zt.roles && Zt.roles.length > 0 ? fe[Zt.roles[0].value] : fe.caption;
              return Ue = Object.values(fe).includes(Ue) ? Ue : fe.caption, Ue;
            }(Lt, Bt), x.addTextTrackInfo(Qt);
          }
          function Tt(Lt) {
            const Bt = Lt.chunk;
            Bt.representation.mediaInfo.embeddedCaptions && nt(Bt.bytes, Bt);
          }
          function yt(Lt) {
            G = Lt;
          }
          function nt(Lt, Bt) {
            const Qt = Bt.representation.mediaInfo, Zt = Qt.type, fe = Qt.mimeType, Ue = Qt.codec || fe;
            Ue ? Qt.codec.indexOf("application/mp4") !== -1 ? function(Ye, on, cn) {
              let Nn, Qe;
              if (on.segmentType === "InitializationSegment") ht = !0, At = it.getMediaTimescaleFromMoov(Ye);
              else {
                if (!ht) return;
                Qe = it.getSamplesInfo(Ye), Nn = Qe.sampleList, Nn.length > 0 && (F = Nn[0].cts - on.start * At), cn.search(q.A.STPP) >= 0 ? function(hn, Sn, jn) {
                  let Ln, Rn;
                  for (lt = lt !== null ? lt : mt(jn), Ln = 0; Ln < Sn.length; Ln++) {
                    const $t = Sn[Ln], be = $t.cts, ge = V(), Te = ge + be / At, ee = Te + $t.duration / At;
                    Y.buffered.add(Te, ee);
                    const De = new DataView(hn, $t.offset, $t.subSizes[0]);
                    let Pe = us.Utils.dataViewToString(De, q.A.UTF8);
                    const nn = [];
                    let sn = $t.offset + $t.subSizes[0];
                    for (Rn = 1; Rn < $t.subSizes.length; Rn++) {
                      const gn = new Uint8Array(hn, sn, $t.subSizes[Rn]), ie = String.fromCharCode.apply(null, gn);
                      nn.push(ie), sn += $t.subSizes[Rn];
                    }
                    try {
                      const gn = E.getValue().ttmlTimeIsRelative ? be / At : 0, ie = lt.parse(Pe, gn, be / At, (be + $t.duration) / At, nn);
                      x.addCaptions(G, ge, ie);
                    } catch (gn) {
                      st.removeExecutedRequestsBeforeTime(), this.remove(), J.error("TTML parser error: " + gn.message);
                    }
                  }
                }(Ye, Nn, cn) : function(hn, Sn) {
                  let jn, Ln, Rn;
                  const $t = [];
                  for (jn = 0; jn < Sn.length; jn++) {
                    const be = Sn[jn];
                    be.cts -= F;
                    const ge = V() + be.cts / At, Te = ge + be.duration / At;
                    Y.buffered.add(ge, Te);
                    const ee = hn.slice(be.offset, be.offset + be.size), De = us.parseBuffer(ee);
                    for (Ln = 0; Ln < De.boxes.length; Ln++) {
                      const Pe = De.boxes[Ln];
                      if (J.debug("VTT box1: " + Pe.type), Pe.type !== "vtte" && Pe.type === "vttc") {
                        J.debug("VTT vttc boxes.length = " + Pe.boxes.length);
                        let nn = { styles: {} };
                        for (Rn = 0; Rn < Pe.boxes.length; Rn++) {
                          const sn = Pe.boxes[Rn];
                          if (J.debug("VTT box2: " + sn.type), sn.type === "payl") nn.start = be.cts / At, nn.end = (be.cts + be.duration) / At, nn.data = sn.cue_text;
                          else if (sn.type === "sttg" && sn.settings && sn.settings !== "") try {
                            const gn = sn.settings.split(" ");
                            nn.styles = z.getCaptionStyles(gn);
                          } catch {
                          }
                        }
                        nn && nn.data && ($t.push(nn), J.debug(`VTT  ${nn.start} - ${nn.end} :  ${nn.data}`));
                      }
                    }
                  }
                  $t.length > 0 && x.addCaptions(G, 0, $t);
                }(Ye, Nn);
              }
            }(Lt, Bt, Ue) : Zt === q.A.VIDEO ? function(Ye, on) {
              let cn, Nn;
              if (on.segmentType === Ct.G.INIT_SEGMENT_TYPE) ft === 0 && (ft = it.getMediaTimescaleFromMoov(Ye));
              else if (on.segmentType === Ct.G.MEDIA_SEGMENT_TYPE) {
                if (ft === 0) return void J.warn("CEA-608: No timescale for embeddedTextTrack yet");
                Nn = it.getSamplesInfo(Ye);
                const Qe = Nn.lastSequenceNumber, hn = Math.trunc(on.start), Sn = Math.trunc(on.end);
                if (vt[0] || vt[1] || function() {
                  let jn;
                  for (let Ln = 0; Ln < K.length; Ln++) {
                    if (jn = x.getTrackIdxForId(K[Ln].id), jn === -1) return void J.warn("CEA-608: data before track is ready.");
                    const Rn = ct(jn);
                    vt[Ln] = new jt(Ln + 1, { newCue: Rn }, null);
                  }
                }(), ft) {
                  if (function(Ln, Rn, $t, be, ge) {
                    return Ln !== null && Rn !== null && be !== null && ge !== null && (Rn === Ln ? be !== ge : Rn !== Ln + $t);
                  }(bt, Qe, Nn.numSequences, _t, hn)) for (cn = 0; cn < vt.length; cn++) vt[cn] && vt[cn].reset();
                  const jn = function(Ln, Rn) {
                    if (Rn.length === 0) return null;
                    const $t = { splits: [], fields: [[], []] }, be = new DataView(Ln);
                    for (let ge = 0; ge < Rn.length; ge++) {
                      const Te = Rn[ge], ee = dg(be, Te.offset, Te.size);
                      let De = null, Pe = 0;
                      for (let nn = 0; nn < 2; nn++) if (ee[nn].length > 0) {
                        Te.cts !== De ? Pe = 0 : Pe += 1;
                        const sn = V();
                        $t.fields[nn].push([Te.cts + sn * ft, ee[nn], Pe]), De = Te.cts;
                      }
                    }
                    return $t.fields.forEach(function(ge) {
                      ge.sort(function(Te, ee) {
                        return Te[0] === ee[0] ? Te[2] - ee[2] : Te[0] - ee[0];
                      });
                    }), $t;
                  }(Ye, Nn.sampleList);
                  for (let Ln = 0; Ln < vt.length; Ln++) {
                    const Rn = jn.fields[Ln], $t = vt[Ln];
                    if ($t) for (cn = 0; cn < Rn.length; cn++) $t.addData(Rn[cn][0] / ft, Rn[cn][1]);
                  }
                  bt = Qe, _t = Sn;
                }
              }
            }(Lt, Bt) : function(Ye, on, cn) {
              let Nn, Qe;
              const hn = new DataView(Ye, 0, Ye.byteLength);
              Qe = us.Utils.dataViewToString(hn, q.A.UTF8);
              try {
                Nn = mt(cn).parse(Qe, 0), x.addCaptions(x.getCurrentTrackIdx(), 0, Nn), Y.buffered && Y.buffered.add(on.start, on.end);
              } catch (Sn) {
                f.error(new Yt.A(X.TIMED_TEXT_ERROR_ID_PARSE_CODE, X.TIMED_TEXT_ERROR_MESSAGE_PARSE + Sn.message, Qe));
              }
            }(Lt, Bt, Ue) : J.error("No text type defined");
          }
          function ct(Lt) {
            return function(Bt, Qt, Zt) {
              let fe;
              fe = M.getTTMLRenderingDiv() ? Pt.createHTMLCaptionsFromScreen(M.getElement(), Bt, Qt, Zt) : [{ start: Bt, end: Qt, data: Zt.getDisplayText(), styles: {} }], fe && x.addCaptions(Lt, 0, fe);
            };
          }
          function V() {
            return isNaN(Y.timestampOffset) ? 0 : Y.timestampOffset;
          }
          function mt(Lt) {
            let Bt;
            return Lt.search(q.A.VTT) >= 0 ? Bt = B.get().streaming.text.webvtt.customRenderingEnabled && O ? O : z : (Lt.search(q.A.TTML) >= 0 || Lt.search(q.A.STPP) >= 0) && (Bt = k), Bt;
          }
          function Mt(Lt) {
            K.forEach(function(Bt) {
              const Qt = x.getTrackIdxForId(Bt.id);
              Qt >= 0 && x.deleteCuesFromTrackIdx(Qt, Lt.from, Lt.to);
            });
          }
          return Y = { initialize: function() {
            Ot || (K = [], G = null, ft = 0, vt = [], bt = null, _t = null, Ot = !0, Pt = ag(D).getInstance(), N.on(et.A.VIDEO_CHUNK_RECEIVED, Tt, Y), N.on(et.A.BUFFER_CLEARED, Mt, Y));
          }, addMediaInfos: function(Lt, Bt, Qt) {
            if (at = at.concat(Bt), Lt === q.A.TEXT && Bt[0].isFragmented && !Bt[0].isEmbedded) {
              st = Qt, Y.buffered = (0, rg.A)(D).create(), Z = v.getTracksFor(q.A.TEXT, H.id).filter((fe) => fe.isFragmented);
              const Zt = v.getCurrentTrackFor(q.A.TEXT, H.id);
              for (let fe = 0; fe < Z.length; fe++) if (Z[fe] === Zt) {
                yt(fe);
                break;
              }
            }
            for (let Zt = 0; Zt < Bt.length; Zt++) tt(Bt[Zt]);
          }, resetMediaInfos: function() {
            at = [];
          }, getStreamId: function() {
            return H.id;
          }, append: nt, abort: function() {
          }, addEmbeddedTrack: function(Lt) {
            if (Ot && Lt) if (Lt.id === q.A.CC1 || Lt.id === q.A.CC3) {
              for (let Bt = 0; Bt < K.length; Bt++) if (K[Bt].id === Lt.id) return;
              K.push(Lt);
            } else J.warn("Embedded track " + Lt.id + " not supported!");
          }, resetEmbedded: function() {
            N.off(et.A.VIDEO_CHUNK_RECEIVED, Tt, Y), N.off(et.A.BUFFER_CLEARED, Mt, Y), x && x.deleteAllTextTracks(), Ot = !1, K = [], vt = [null, null], bt = null, _t = null;
          }, getConfig: function() {
            return { fragmentModel: st, fragmentedTracks: Z, videoModel: M };
          }, setCurrentFragmentedTrackIdx: yt, remove: function(Lt, Bt) {
            Lt === void 0 && Lt === Bt && (Lt = Y.buffered.start(0), Bt = Y.buffered.end(Y.buffered.length - 1)), Y.buffered.remove(Lt, Bt), x.deleteCuesFromTrackIdx(G, Lt, Bt);
          }, reset: function() {
            W(), at = [], it = null;
          } }, J = (0, ae.A)(D).getInstance().getLogger(Y), it = Ts(D).getInstance(), W(), Y;
        }
        Cc.__dashjs_factory_name = "TextSourceBuffer";
        var cg = Dt.A.getClassFactory(Cc), su = b(7640);
        const hg = ["text", "align", "fontSize", "id", "isd", "line", "lineAlign", "lineHeight", "linePadding", "position", "positionAlign", "region", "size", "snapToLines", "vertical"];
        function Nc(y) {
          const f = this.context, E = (0, It.A)(f).getInstance(), v = y.videoModel, M = y.streamInfo, x = y.settings;
          let z, O, k, H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft;
          function bt($t) {
            const be = $t.kind, ge = $t.id !== void 0 ? $t.id : $t.lang, Te = $t.lang, ee = $t.isTTML, De = $t.isEmbedded;
            return v.addTextTrack(be, ge, Te, ee, De);
          }
          function _t($t, be, ge, Te, ee, De) {
            let Pe = 0, nn = 0;
            $t / be > ge / Te ? (nn = be, Pe = nn / Te * ge) : (Pe = $t, nn = Pe / ge * Te);
            let sn = 0, gn = 0, ie = 0, Le = 0;
            return Pe / nn > ee ? (Le = nn, ie = nn * ee) : (ie = Pe, Le = Pe / ee), sn = ($t - ie) / 2, gn = (be - Le) / 2, De ? { x: sn + 0.1 * ie, y: gn + 0.1 * Le, w: 0.8 * ie, h: 0.8 * Le } : { x: sn, y: gn, w: ie, h: Le };
          }
          function vt($t, be) {
            const ge = v.getClientWidth(), Te = v.getClientHeight(), ee = v.getVideoWidth(), De = v.getVideoHeight(), Pe = v.getVideoRelativeOffsetTop(), nn = v.getVideoRelativeOffsetLeft();
            if (ee !== 0 && De !== 0) {
              let sn = ee / De, gn = !1;
              $t.isFromCEA608 && (sn = 1.1666666666666667, gn = !0);
              const ie = _t.call(this, ge, Te, ee, De, sn, gn), Le = ie.w, We = ie.h, ln = ie.x, ye = ie.y;
              if (Le != J || We != it || ln != N || ye != Y || be) {
                if (N = ln + nn, Y = ye + Pe, J = Le, it = We, lt) {
                  const Wt = lt.style;
                  Wt && (Wt.left = N + "px", Wt.top = Y + "px", Wt.width = J + "px", Wt.height = it + "px", Wt.zIndex = ht && document[ht] || At ? F : null, E.trigger(St.A.CAPTION_CONTAINER_RESIZE));
                }
                const Rt = $t.activeCues;
                if (Rt) {
                  const Wt = Rt.length;
                  for (let Ee = 0; Ee < Wt; ++Ee) {
                    const te = Rt[Ee];
                    te.scaleCue(te);
                  }
                }
              }
            }
          }
          function Pt($t) {
            const be = J, ge = it;
            let Te, ee, De, Pe, nn;
            if ($t.cellResolution) {
              const sn = [be / $t.cellResolution[0], ge / $t.cellResolution[1]];
              if ($t.linePadding) {
                for (Te in $t.linePadding) if ($t.linePadding.hasOwnProperty(Te)) {
                  ee = ($t.linePadding[Te] * sn[0]).toString();
                  const gn = document.getElementsByClassName("spanPadding");
                  for (let ie = 0; ie < gn.length; ie++) gn[ie].style.cssText = gn[ie].style.cssText.replace(/(padding-left\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + ee), gn[ie].style.cssText = gn[ie].style.cssText.replace(/(padding-right\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + ee);
                }
              }
              if ($t.fontSize) {
                for (Te in $t.fontSize) if ($t.fontSize.hasOwnProperty(Te)) {
                  $t.fontSize[Te][0] === "%" ? De = $t.fontSize[Te][1] / 100 : $t.fontSize[Te][0] === "c" && (De = $t.fontSize[Te][1]), ee = (De * sn[1]).toString(), nn = Te !== "defaultFontSize" ? document.getElementsByClassName(Te) : document.getElementsByClassName("paragraph");
                  for (let gn = 0; gn < nn.length; gn++) nn[gn].style.cssText = nn[gn].style.cssText.replace(/(font-size\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + ee);
                }
                if ($t.lineHeight) {
                  for (Te in $t.lineHeight) if ($t.lineHeight.hasOwnProperty(Te)) {
                    $t.lineHeight[Te][0] === "%" ? Pe = $t.lineHeight[Te][1] / 100 : $t.fontSize[Te][0] === "c" && (Pe = $t.lineHeight[Te][1]), ee = (Pe * sn[1]).toString(), nn = document.getElementsByClassName(Te);
                    for (let gn = 0; gn < nn.length; gn++) nn[gn].style.cssText = nn[gn].style.cssText.replace(/(line-height\s*:\s*)[\d.,]+(?=\s*px)/gi, "$1" + ee);
                  }
                }
              }
            }
            if ($t.isd) {
              let sn = document.getElementById($t.cueID);
              sn && lt.removeChild(sn), W($t);
            }
          }
          function Ot($t, be) {
            const ge = /^(urn:)(mpeg:[a-z0-9][a-z0-9-]{0,31}:)(subs:)([0-9]+)$/, Te = /^#(.*)$/;
            if (ge.test(be)) {
              const ee = ge.exec(be), De = parseInt(ee[4], 10) - 1;
              return "data:image/png;base64," + btoa($t.images[De]);
            }
            if (Te.test(be)) {
              const ee = Te.exec(be)[1];
              return "data:image/png;base64," + $t.embeddedImages[ee];
            }
            return be;
          }
          function W($t) {
            if (lt) {
              Rn.call(this);
              const be = document.createElement("div");
              lt.appendChild(be), Z = (0, su.renderHTML)($t.isd, be, function(ge) {
                return Ot($t, ge);
              }, lt.clientHeight, lt.clientWidth, x.get().streaming.text.imsc.displayForcedOnlyMode, function(ge) {
                O.info("renderCaption :", ge);
              }, Z, x.get().streaming.text.imsc.enableRollUp), be.id = $t.cueID, E.trigger(St.A.CAPTION_RENDERED, { captionDiv: be, currentTrackIdx: D });
            }
          }
          function tt($t, be) {
            return !!be && be.endTime >= $t.startTime;
          }
          function Tt($t, be) {
            return !!x.get().streaming.text.extendSegmentedCues && !!function(ge, Te, ee) {
              for (let De = 0; De < ee.length; De++) {
                const Pe = ee[De];
                if (JSON.stringify(ge[Pe]) !== JSON.stringify(Te[Pe])) return !1;
              }
              return !0;
            }(be, $t, hg) && (be.endTime = Math.max(be.endTime, $t.endTime), !0);
          }
          function yt($t, be) {
            be && be.forEach((ge) => {
              ge.kind && ge.kind === "image" && (ge.src = Ot($t, ge.src)), yt($t, ge.contents);
            });
          }
          function nt($t, be, ge) {
            const Te = Ue($t), ee = x.get().streaming.text.dispatchForManualRendering;
            if (Te && Array.isArray(ge) && ge.length !== 0) for (let De = 0; De < ge.length; De++) {
              let Pe = null;
              const nn = ge[De];
              Te.cellResolution = nn.cellResolution, Te.isFromCEA608 = nn.isFromCEA608, isNaN(nn.start) || isNaN(nn.end) || (ee ? Pe = ct(nn, be) : Bt(nn) && lt ? Pe = Mt(nn, be, Te) : nn.data && (Pe = Lt(nn, be, Te)));
              try {
                if (Pe) {
                  if (!cn(Te, Pe)) if (x.get().streaming.text.webvtt.customRenderingEnabled) Te.manualCueList || (Te.manualCueList = []), Te.manualCueList.push(Pe);
                  else {
                    let gn;
                    Te.cues && Te.cues.length !== 0 && (gn = Te.cues[Te.cues.length - 1]), tt(Pe, gn) ? Tt(Pe, gn) || (gn.isd && (gn.onexit = function() {
                    }), Te.mode !== q.A.TEXT_DISABLED && Te.addCue(Pe)) : Te.mode !== q.A.TEXT_DISABLED && Te.addCue(Pe);
                  }
                  const sn = x.get().streaming.buffer.bufferToKeep;
                  Qe(Te, 0, v.getTime() - sn);
                } else O.error("Impossible to display subtitles. You might have missed setting a TTML rendering div via player.attachTTMLRenderingDiv(TTMLRenderingDiv)");
              } catch (sn) {
                throw hn(Te), Te.addCue(Pe), sn;
              }
            }
          }
          function ct($t, be) {
            let ge = Qt($t, be);
            return ge.onenter = function() {
              Bt($t) && ft && ft.cueID !== ge.cueID && mt(ft), delete ge.type, ft = ge, V(ge);
            }, ge.onexit = function() {
              mt(ge), ft = null;
            }, ge;
          }
          function V($t) {
            E.trigger(St.A.CUE_ENTER, $t);
          }
          function mt($t) {
            E.trigger(St.A.CUE_EXIT, { cueID: $t.cueID });
          }
          function Mt($t, be, ge) {
            const Te = this;
            let ee = Qt($t, be);
            return lt.style.left = N + "px", lt.style.top = Y + "px", lt.style.width = J + "px", lt.style.height = it + "px", ee.onenter = function() {
              ge.mode === q.A.TEXT_SHOWING && (this.isd ? (K ? requestAnimationFrame(() => W(this)) : W(this), O.debug("Cue enter id:" + this.cueID)) : (lt.appendChild(this.cueHTMLElement), Pt.call(Te, this), E.trigger(St.A.CAPTION_RENDERED, { captionDiv: this.cueHTMLElement, currentTrackIdx: D })));
            }, ee.onexit = function() {
              if (lt) {
                const De = lt.childNodes;
                for (let Pe = 0; Pe < De.length; ++Pe) De[Pe].id === this.cueID && (O.debug("Cue exit id:" + De[Pe].id), lt.removeChild(De[Pe]), --Pe);
              }
            }, ee;
          }
          function Lt($t, be, ge) {
            let Te = Qt($t, be);
            if (Te.isActive = !1, $t.styles) try {
              $t.styles.align !== void 0 && "align" in Te && (Te.align = $t.styles.align), $t.styles.line !== void 0 && "line" in Te && (Te.line = $t.styles.line), $t.styles.snapToLines !== void 0 && "snapToLines" in Te && (Te.snapToLines = $t.styles.snapToLines), $t.styles.position !== void 0 && "position" in Te && (Te.position = $t.styles.position), $t.styles.size !== void 0 && "size" in Te && (Te.size = $t.styles.size);
            } catch (ee) {
              O.error(ee);
            }
            return Te.onenter = function() {
              ge.mode === q.A.TEXT_SHOWING && E.trigger(St.A.CAPTION_RENDERED, { currentTrackIdx: D });
            }, Te;
          }
          function Bt($t) {
            return $t.type === "html";
          }
          function Qt($t, be) {
            return Bt($t) ? function(ge, Te) {
              let ee = new k(ge.start + Te, ge.end + Te, "");
              return ee.cueHTMLElement = ge.cueHTMLElement, ee.isd = ge.isd, ee.images = ge.images, ee.embeddedImages = ge.embeddedImages, ee.cueID = ge.cueID, ee.scaleCue = Pt.bind(self), ee.cellResolution = ge.cellResolution, ee.lineHeight = ge.lineHeight, ee.linePadding = ge.linePadding, ee.fontSize = ge.fontSize, ee.isd && yt(ee, ee.isd.contents), ee;
            }($t, be) : function(ge, Te) {
              let ee = new k(ge.start - Te, ge.end - Te, ge.data);
              return ee.cueID = `${ee.startTime}_${ee.endTime}`, ee;
            }($t, be);
          }
          function Zt($t) {
            if (at) {
              const be = at.childNodes;
              for (let ge = 0; ge < be.length; ++ge) be[ge].id === $t.cueID && (at.removeChild(be[ge]), --ge);
            }
          }
          function fe() {
            const $t = v.getTextTracks(), be = [];
            for (const ge of $t) ge.manualMode === q.A.TEXT_SHOWING && be.push(ge);
            return be;
          }
          function Ue($t) {
            return $t >= 0 && H[$t] ? v.getTextTrack(H[$t].kind, H[$t].id, H[$t].lang, H[$t].isTTML, H[$t].isEmbedded) : null;
          }
          function Ye($t) {
            if ($t === D) return;
            D = $t;
            const be = Ue(D);
            on.call(this, be), st && (clearInterval(st), st = null), be && be.renderingType === "html" && (vt.call(this, be, !0), window.ResizeObserver ? (G = new window.ResizeObserver(() => {
              vt.call(this, be, !0);
            }), G.observe(v.getElement())) : st = setInterval(vt.bind(this, be), 500));
          }
          function on($t) {
            Rn.call(this), $t && $t.renderingType === "html" ? jn.call(this) : Ln.call(this);
          }
          function cn($t, be) {
            if (!$t.cues) return !1;
            for (let ge = 0; ge < $t.cues.length; ge++) if ($t.cues[ge].startTime === be.startTime && $t.cues[ge].endTime === be.endTime) return !0;
            return !1;
          }
          function Nn($t, be, ge) {
            let Te = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            return !!$t && (isNaN(be) || (Te ? $t.startTime : $t.endTime) >= be) && (isNaN(ge) || (Te ? $t.endTime : $t.startTime) <= ge);
          }
          function Qe($t, be, ge) {
            if (!(ge < be) && $t && ($t.cues || $t.manualCueList)) {
              const Te = $t.cues && $t.cues.length > 0 ? "native" : "custom", ee = Te === "native" ? $t.cues : $t.manualCueList;
              if (!ee || ee.length === 0) return;
              for (let De = ee.length - 1; De >= 0; De--) Nn(ee[De], be, ge, !0) && !Sn(ee[De]) && (Te === "native" ? $t.removeCue(ee[De]) : (Zt(ee[De]), delete $t.manualCueList[De]));
            }
          }
          function hn($t, be, ge) {
            let Te = !(arguments.length > 3 && arguments[3] !== void 0) || arguments[3];
            if ($t && ($t.cues || $t.manualCueList)) {
              const ee = $t.cues && $t.cues.length > 0 ? "native" : "custom", De = ee === "native" ? $t.cues : $t.manualCueList;
              if (!De || De.length === 0) return;
              for (let Pe = De.length - 1; Pe >= 0; Pe--) Nn(De[Pe], be, ge, Te) && (ee === "native" ? (De[Pe].onexit && De[Pe].onexit(), $t.removeCue(De[Pe])) : (Zt(De[Pe]), delete $t.manualCueList[Pe]));
            }
          }
          function Sn($t) {
            const be = v.getTime();
            return be >= $t.startTime && be <= $t.endTime;
          }
          function jn() {
            let $t = document.getElementById("native-cue-style");
            if ($t) return;
            $t = document.createElement("style"), $t.id = "native-cue-style", document.head.appendChild($t);
            const be = $t.sheet, ge = v.getElement();
            try {
              ge && (ge.id ? be.insertRule("#" + ge.id + "::cue {background: transparent}", 0) : ge.classList.length !== 0 ? be.insertRule("." + ge.className + "::cue {background: transparent}", 0) : be.insertRule("video::cue {background: transparent}", 0));
            } catch (Te) {
              O.info("" + Te.message);
            }
          }
          function Ln() {
            const $t = document.getElementById("native-cue-style");
            $t && document.head.removeChild($t);
          }
          function Rn() {
            if (lt) for (; lt.firstChild; ) lt.removeChild(lt.firstChild);
          }
          return z = { addCaptions: nt, addTextTrackInfo: function($t) {
            H.push($t);
          }, createTracks: function() {
            H.sort(function(be, ge) {
              return be.index - ge.index;
            }), lt = v.getTTMLRenderingDiv(), at = v.getVttRenderingDiv();
            let $t = -1;
            for (let be = 0; be < H.length; be++) {
              const ge = bt(H[be]);
              B.push(ge), H[be].defaultTrack && (ge.default = !0, $t = be);
              const Te = Ue(be);
              Te && (Te.mode = q.A.TEXT_SHOWING, lt && (H[be].isTTML || H[be].isEmbedded) ? Te.renderingType = "html" : Te.renderingType = "default"), nt(be, 0, H[be].captionData), E.trigger(St.A.TEXT_TRACK_ADDED);
            }
            if (Ye.call(this, $t), $t >= 0) {
              let be = function() {
                const ge = Ue($t);
                ge && ge.renderingType === "html" && vt.call(this, ge, !0), E.off(St.A.PLAYBACK_METADATA_LOADED, be, this);
              };
              E.on(St.A.PLAYBACK_METADATA_LOADED, be, this);
              for (let ge = 0; ge < H.length; ge++) {
                const Te = Ue(ge);
                if (Te) {
                  const ee = x.get().streaming.text.dispatchForManualRendering;
                  Te.mode = ge !== $t || ee ? q.A.TEXT_HIDDEN : q.A.TEXT_SHOWING, Te.manualMode = ge === $t ? q.A.TEXT_SHOWING : q.A.TEXT_HIDDEN;
                }
              }
            }
            E.trigger(et.A.TEXT_TRACKS_QUEUE_INITIALIZED, { index: D, tracks: H, streamId: M.id });
          }, deleteAllTextTracks: function() {
            const $t = B ? B.length : 0;
            for (let be = 0; be < $t; be++) {
              const ge = Ue(be);
              ge && hn.call(this, ge, M.start, M.start + M.duration, !1);
            }
            B = [], H = [], st && (clearInterval(st), st = null), G && v && (G.unobserve(v.getElement()), G = null), D = -1, Rn.call(this);
          }, deleteCuesFromTrackIdx: function($t, be, ge) {
            const Te = Ue($t);
            Te && hn(Te, be, ge);
          }, disableManualTracks: function() {
            const $t = fe();
            if ($t && $t.length > 0) {
              const be = $t[0].manualCueList;
              be && be.length > 0 && be.forEach((ge) => {
                if (ge.isActive) {
                  if (ge.isActive = !1, x.get().streaming.text.dispatchForManualRendering) mt(ge);
                  else if (at) {
                    const Te = at.childNodes;
                    for (let ee = 0; ee < Te.length; ++ee) Te[ee].id === ge.cueID && (at.removeChild(Te[ee]), --ee);
                  }
                }
              });
            }
          }, getCurrentTrackIdx: function() {
            return D;
          }, getCurrentTextTrackInfo: function() {
            return H[D];
          }, getStreamId: function() {
            return M.id;
          }, getTextTrackInfos: function() {
            return H;
          }, getTrackIdxForId: function($t) {
            let be = -1;
            for (let ge = 0; ge < H.length; ge++) if (H[ge].id === $t) {
              be = ge;
              break;
            }
            return be;
          }, initialize: function() {
            typeof window < "u" && typeof navigator < "u" && (k = window.VTTCue || window.TextTrackCue, H = [], B = [], D = -1, N = 0, Y = 0, J = 0, it = 0, lt = null, at = null, st = null, At = !1, F = 2147483647, Z = null, K = "requestAnimationFrame" in window, document.fullscreenElement !== void 0 ? ht = "fullscreenElement" : document.webkitIsFullScreen !== void 0 ? ht = "webkitIsFullScreen" : document.msFullscreenElement ? ht = "msFullscreenElement" : document.mozFullScreen && (ht = "mozFullScreen"));
          }, manualCueProcessing: function($t) {
            const be = fe();
            if (be && be.length > 0) {
              const ge = be[0].manualCueList;
              ge && ge.length > 0 && ge.forEach((Te) => {
                Te.startTime <= $t && Te.endTime >= $t && !Te.isActive ? (Te.isActive = !0, x.get().streaming.text.dispatchForManualRendering ? V(Te) : WebVTT.processCues(window, [Te], at, Te.cueID)) : Te.isActive && (Te.startTime > $t || Te.endTime < $t) && (Te.isActive = !1, x.get().streaming.text.dispatchForManualRendering ? mt(Te) : Zt(Te));
              });
            }
          }, setCurrentTrackIdx: Ye, setModeForTrackIdx: function($t, be) {
            const ge = Ue($t);
            ge && ge.mode !== be && (ge.mode = be), ge && ge.manualMode !== be && (ge.manualMode = be);
          } }, O = (0, ae.A)(f).getInstance().getLogger(z), z;
        }
        Nc.__dashjs_factory_name = "TextTracks";
        var fg = Dt.A.getClassFactory(Nc);
        function Pc() {
          const y = this.context;
          let f, E, v, M, x, z;
          function O(D) {
            const N = D.split(":"), Y = N.length - 1;
            return D = 60 * parseInt(N[Y - 1], 10) + parseFloat(N[Y]), Y === 2 && (D += 3600 * parseInt(N[0], 10)), D;
          }
          function k(D) {
            const N = D.split(M), Y = N[1].split(z);
            return Y.shift(), N[1] = Y[0], Y.shift(), { cuePoints: N, styles: H(Y) };
          }
          function H(D) {
            const N = {};
            return D.forEach(function(Y) {
              if (Y.split(/:/).length > 1) {
                let J = Y.split(/:/)[1], it = !1;
                J && J.search(/%/) != -1 && (it = !0, J = parseInt(J.replace(/%/, ""), 10)), (Y.match(/align/) || Y.match(/A/)) && (N.align = J), (Y.match(/line/) || Y.match(/L/)) && (N.line = J === "auto" ? J : parseInt(J, 10), it && (N.snapToLines = !1)), (Y.match(/position/) || Y.match(/P/)) && (N.position = J), (Y.match(/size/) || Y.match(/S/)) && (N.size = J);
              }
            }), N;
          }
          function B(D, N) {
            let Y, J = N, it = "", lt = "";
            for (; D[J] !== "" && J < D.length; ) J++;
            if (Y = J - N, Y > 1) for (let at = 0; at < Y; at++) {
              if (lt = D[N + at], lt.match(M)) {
                it = "";
                break;
              }
              it += lt, at !== Y - 1 && (it += `
`);
            }
            else lt = D[N], lt.match(M) || (it = lt);
            return it;
          }
          return f = { parse: function(D) {
            const N = [];
            let Y, J;
            if (!D) return N;
            Y = (D = D.split(v)).length, J = -1;
            for (let it = 0; it < Y; it++) {
              let lt = D[it];
              if (lt.length > 0 && lt !== "WEBVTT" && lt.match(M)) {
                const at = k(lt), st = at.cuePoints, ht = at.styles, At = B(D, it + 1), Z = O(st[0].replace(x, "")), F = O(st[1].replace(x, ""));
                !isNaN(Z) && !isNaN(F) && Z >= J && F > Z ? At !== "" ? (J = Z, N.push({ start: Z, end: F, data: At, styles: ht })) : E.error("Skipping cue due to empty/malformed cue text") : E.error("Skipping cue due to incorrect cue timing");
              }
            }
            return N;
          }, getCaptionStyles: H }, E = (0, ae.A)(y).getInstance().getLogger(f), v = /(?:\r\n|\r|\n)/gm, M = /-->/, x = /(^[\s]+|[\s]+$)/g, z = /\s\b/g, f;
        }
        Pc.__dashjs_factory_name = "VTTParser";
        var mg = Dt.A.getSingletonFactory(Pc);
        function zc() {
          let y, f;
          return y = { parse: function(E) {
            let v = [];
            return f.oncue = function(M) {
              M.start = M.startTime, M.end = M.endTime, M.data = M.text, M.styles = { align: M.align, line: M.line, position: M.position, size: M.size }, v.push(M);
            }, f.parse(E), v;
          } }, function() {
            try {
              window && window.WebVTT && window.WebVTT.Parser && (f = new window.WebVTT.Parser(window, window.vttjs, window.WebVTT.StringDecoder()));
            } catch {
            }
          }(), y;
        }
        zc.__dashjs_factory_name = "VttCustomRenderingParser";
        var pg = Dt.A.getSingletonFactory(zc);
        function Oc() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M = 0;
          function x() {
            const z = "cue_TTML_" + M;
            return M++, z;
          }
          return E = { parse: function(z, O, k, H, B) {
            let D = "";
            const N = [];
            let Y, J, it;
            const lt = {}, at = {};
            let st = "", ht = "", At = { onOpenTag: function(G, K, ft) {
              if (ft[" imagetype"] && !ft[" imageType"] && (f.trigger(St.A.CONFORMANCE_VIOLATION, { level: pr.LEVELS.ERROR, event: pr.EVENTS.NON_COMPLIANT_SMPTE_IMAGE_ATTRIBUTE }), ft[" imageType"] = ft[" imagetype"]), K === "image" && (G === "http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt" || G === "http://www.smpte-ra.org/schemas/2052-1/2013/smpte-tt")) {
                if (!ft[" imageType"] || ft[" imageType"].value !== "PNG") return void v.warn("smpte-tt imageType != PNG. Discarded");
                st = ft["http://www.w3.org/XML/1998/namespace id"].value;
              }
            }, onCloseTag: function() {
              st && (at[st] = ht.trim()), ht = "", st = "";
            }, onText: function(G) {
              st && (ht += G);
            } };
            if (!z) throw D = "no ttml data to parse", new Error(D);
            lt.data = z, f.trigger(et.A.TTML_TO_PARSE, lt);
            let Z = (0, su.fromXML)(lt.data, function(G) {
              D = G;
            }, At);
            f.trigger(et.A.TTML_PARSED, { ttmlString: lt.data, ttmlDoc: Z });
            const F = Z.getMediaTimeEvents();
            for (it = 0; it < F.length; it++) {
              let G = (0, su.generateISD)(Z, F[it], function(K) {
                D = K;
              });
              G.contents.some((K) => K.contents.length) && (Y = F[it] + O, J = F[it + 1] + O, Y < J && N.push({ start: Y, end: J, type: "html", cueID: x(), isd: G, images: B, embeddedImages: at }));
            }
            if (D !== "") throw v.error(D), new Error(D);
            return N;
          } }, v = (0, ae.A)(y).getInstance().getLogger(E), E;
        }
        Oc.__dashjs_factory_name = "TTMLParser";
        var gg = Dt.A.getSingletonFactory(Oc);
        function Yc(y) {
          let f = this.context;
          const E = (0, It.A)(f).getInstance(), v = Se(f).getInstance(), M = y.adapter, x = y.baseURLController, z = "error", O = "loaded", k = "unloaded";
          let H, B, D;
          function N(it, lt) {
            let at, st, ht = !1;
            if (x.resolve()) {
              const F = M.getVoRepresentations(it);
              F && F.length > 0 && (at = x.resolve(F[0].path).url);
            }
            const At = it.essentialProperties.filter((F) => F.schemeIdUri && F.schemeIdUri === q.A.FONT_DOWNLOAD_DVB_SCHEME), Z = it.supplementalProperties.filter((F) => F.schemeIdUri && F.schemeIdUri === q.A.FONT_DOWNLOAD_DVB_SCHEME);
            At.length > 0 ? (ht = !0, st = At) : st = Z, st.forEach((F) => {
              if (function(ft) {
                return !(!(ft.value && parseInt(ft.value) === 1 && ft.dvbUrl && ft.dvbUrl.length > 0 && ft.dvbFontFamily && ft.dvbFontFamily.length > 0 && ft.dvbMimeType) || ft.dvbMimeType !== q.A.OFF_MIMETYPE && ft.dvbMimeType !== q.A.WOFF_MIMETYPE);
              }(F)) {
                let ft = (G = F.dvbUrl, K = at, v.isPathAbsolute(G) ? G : v.isRelative(G) ? K ? v.resolve(G, K) : v.resolve(G) : G);
                D.push({ fontFamily: F.dvbFontFamily, url: ft, mimeType: F.dvbMimeType, trackId: it.id, streamId: lt, isEssential: ht, status: k, fontFace: new FontFace(F.dvbFontFamily, `url(${ft})`, { display: "swap" }) });
              }
              var G, K;
            });
          }
          function Y(it, lt) {
            const at = D[it];
            D[it] = { ...at, status: lt };
          }
          function J() {
            D = [];
          }
          return H = { addFontsFromTracks: function(it, lt) {
            if (it && Array.isArray(it) && lt) for (let at = 0; at < it.length; at++) N(it[at], lt);
          }, downloadFonts: function() {
            for (let it = 0; it < D.length; it++) {
              let lt = D[it];
              document.fonts.add(lt.fontFace), E.trigger(St.A.DVB_FONT_DOWNLOAD_ADDED, lt), lt.fontFace.load().then(() => {
                Y(it, O), E.trigger(St.A.DVB_FONT_DOWNLOAD_COMPLETE, lt);
              }, (at) => {
                Y(it, z), B.debug("Font download error: ", at), E.trigger(St.A.DVB_FONT_DOWNLOAD_FAILED, lt);
              });
            }
          }, getFonts: function() {
            return D;
          }, getFontsForTrackId: function(it) {
            return D.filter((lt) => lt.trackId && lt.trackId === it);
          }, reset: function() {
            (function() {
              for (const it of D) {
                let lt = document.fonts.delete(it.fontFace);
                B.debug(`Removal of fontFamily: ${it.fontFamily} was ${lt ? "successful" : "unsuccessful"}`);
              }
            })(), J();
          } }, B = (0, ae.A)(f).getInstance().getLogger(H), J(), H;
        }
        Yc.__dashjs_factory_name = "DVBFonts";
        var _g = Dt.A.getClassFactory(Yc);
        function Fc(y) {
          let f = this.context;
          const E = y.adapter, v = y.errHandler, M = y.manifestModel, x = y.mediaController, z = y.baseURLController, O = y.videoModel, k = y.settings;
          let H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F;
          function G(nt) {
            if (F.error(`Could not download ${nt.isEssential ? "an essential" : "a"} font - fontFamily: ${nt.fontFamily}, url: ${nt.url}`), nt.isEssential) {
              let ct = N[nt.streamId].getTrackIdxForId(nt.trackId);
              N[nt.streamId].setModeForTrackIdx(ct, q.A.TEXT_DISABLED);
            }
          }
          function K(nt) {
            if (F.debug(`Successfully downloaded ${nt.isEssential ? "an essential" : "a"} font - fontFamily: ${nt.fontFamily}, url: ${nt.url}`), nt.isEssential) {
              let ct = N[nt.streamId].getTrackIdxForId(nt.trackId);
              ct === N[nt.streamId].getCurrentTrackIdx() ? N[nt.streamId].setModeForTrackIdx(ct, q.A.TEXT_SHOWING) : N[nt.streamId].setModeForTrackIdx(ct, q.A.TEXT_HIDDEN);
            }
          }
          function ft(nt) {
            let ct = nt.tracks, V = nt.index;
            const mt = nt.streamId;
            if (k.get().streaming.text.defaultEnabled === !1 && !Pt() || At) Ot(mt, -1);
            else {
              const Mt = x.getCurrentTrackFor(q.A.TEXT, mt);
              if (Mt) {
                const Lt = { lang: Mt.lang, role: Mt.roles[0], index: Mt.index, codec: Mt.codec, accessibility: Mt.accessibility[0] };
                ct.some((Bt, Qt) => {
                  if (x.matchSettings(Lt, Bt)) return Ot(mt, Qt), V = Qt, !0;
                });
              }
              at = !1;
            }
            B[mt].lastEnabledIndex = V, lt.trigger(St.A.TEXT_TRACKS_ADDED, { enabled: Pt(), index: V, tracks: ct, streamId: mt }), ht = !0, Z.addFontsFromTracks(ct, mt), Z.getFonts().forEach((Mt) => {
              if (Mt.isEssential) {
                let Lt = N[Mt.streamId].getTrackIdxForId(Mt.trackId);
                N[Mt.streamId].setModeForTrackIdx(Lt, q.A.TEXT_DISABLED);
              }
            }), Z.downloadFonts();
          }
          function bt(nt) {
            try {
              const ct = nt.streamId;
              if (!N[ct] || isNaN(nt.time)) return;
              N[ct].manualCueProcessing(nt.time);
            } catch {
            }
          }
          function _t(nt) {
            try {
              const ct = nt.streamId;
              if (!N[ct]) return;
              N[ct].disableManualTracks();
            } catch {
            }
          }
          function vt(nt) {
            try {
              if (!nt || !nt.mediaType || nt.mediaType !== q.A.AUDIO || !nt.currentMediaInfo) return;
              const ct = N[nt.streamId].getCurrentTextTrackInfo();
              let V = NaN;
              at ? V = W(nt.streamId) : tt(ct) && nt.currentMediaInfo.lang && nt.currentMediaInfo.lang !== ct.lang && (V = W(nt.streamId), isNaN(V) && (V = -1)), isNaN(V) || Ot(nt.streamId, V);
            } catch (ct) {
              F.error(ct);
            }
          }
          function Pt() {
            let nt = !0;
            return at && !st && (nt = !1), nt;
          }
          function Ot(nt, ct) {
            at = ct === -1, at && x && x.saveTextSettingsDisabled();
            let V = Tt(nt);
            if (V === ct || !N[nt]) return;
            N[nt].disableManualTracks();
            let mt = N[nt].getCurrentTextTrackInfo(), Mt = mt ? O.getTextTrack(mt.kind, mt.id, mt.lang, mt.isTTML, mt.isEmbedded) : null;
            Mt && Mt.mode !== q.A.TEXT_DISABLED && N[nt].setModeForTrackIdx(V, q.A.TEXT_HIDDEN), N[nt].setCurrentTrackIdx(ct), mt = N[nt].getCurrentTextTrackInfo();
            const Lt = k.get().streaming.text.dispatchForManualRendering;
            if (mt && !Lt && mt.mode !== q.A.TEXT_DISABLED && N[nt].setModeForTrackIdx(ct, q.A.TEXT_SHOWING), mt && mt.isFragmented && !mt.isEmbedded) (function(Bt, Qt, Zt) {
              if (!D[Bt]) return;
              let fe = D[Bt].getConfig().fragmentedTracks;
              for (let Ue = 0; Ue < fe.length; Ue++) {
                let Ye = fe[Ue];
                if (Qt.lang === Ye.lang && (Ye.id ? Qt.id === Ye.id : Qt.index === Ye.index)) {
                  let on = x.getCurrentTrackFor(q.A.TEXT, Bt);
                  (Ye.id ? on.id !== Ye.id : on.index !== Ye.index) ? (N[Bt].deleteCuesFromTrackIdx(Zt), D[Bt].setCurrentFragmentedTrackIdx(Ue)) : Zt === -1 && lt.trigger(et.A.SET_FRAGMENTED_TEXT_AFTER_DISABLED, {}, { streamId: Bt, mediaType: q.A.TEXT });
                }
              }
            })(nt, mt, V);
            else if (mt && !mt.isFragmented) (function(Bt, Qt) {
              lt.trigger(et.A.SET_NON_FRAGMENTED_TEXT, { currentTrackInfo: Qt }, { streamId: Bt, mediaType: q.A.TEXT });
            })(nt, mt);
            else if (!mt && at) {
              const Bt = W(nt);
              return void (isNaN(Bt) || Ot(nt, Bt));
            }
            x.setTrack(mt);
          }
          function W(nt) {
            const ct = function(Mt) {
              return N[Mt].getTextTrackInfos().filter((Lt, Bt) => (Lt._indexToSelect = Bt, !!(Lt && Lt.roles && Lt.roles.length > 0) && tt(Lt)));
            }(nt);
            if (!ct || ct.length <= 0) return NaN;
            const V = x.getCurrentTrackFor(q.A.AUDIO, nt);
            if (!V) return NaN;
            const mt = ct.find((Mt) => V.lang === Mt.lang);
            return mt ? mt._indexToSelect : NaN;
          }
          function tt(nt) {
            return !(!nt || !nt.roles || nt.roles.length === 0) && nt.roles.some((ct) => ct.schemeIdUri === q.A.DASH_ROLE_SCHEME_ID && ct.value === I.A.FORCED_SUBTITLE);
          }
          function Tt(nt) {
            return N[nt].getCurrentTrackIdx();
          }
          function yt() {
            D = {}, N = {}, B = {}, at = !0, ht = !1, At = !1;
          }
          return H = { addEmbeddedTrack: function(nt, ct) {
            const V = nt.id;
            D[V] && D[V].addEmbeddedTrack(ct);
          }, addMediaInfosToBuffer: function(nt, ct, V) {
            let mt = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            const Mt = nt.id;
            D[Mt] && D[Mt].addMediaInfos(ct, V, mt);
          }, createTracks: function(nt) {
            const ct = nt.id;
            N[ct] && N[ct].createTracks();
          }, deactivateStream: function(nt) {
            if (!nt) return;
            const ct = nt.id;
            D[ct] && D[ct].resetMediaInfos(), N[ct] && N[ct].deleteAllTextTracks();
          }, enableForcedTextStreaming: function(nt) {
            return (0, pe.sq)(nt, "boolean"), st = nt, !0;
          }, enableText: function(nt, ct) {
            return (0, pe.sq)(ct, "boolean"), Pt() !== ct && (ct && Ot(nt, B[nt].lastEnabledIndex), ct || (B[nt].lastEnabledIndex = Tt(nt), ht ? Ot(nt, -1) : At = !0)), !0;
          }, getAllTracksAreDisabled: function() {
            return at;
          }, getCurrentTrackIdx: Tt, getTextSourceBuffer: function(nt) {
            const ct = nt.id;
            if (D && D[ct]) return D[ct];
          }, initialize: function() {
            Z = _g(f).create({ adapter: E, baseURLController: z }), lt.on(et.A.TEXT_TRACKS_QUEUE_INITIALIZED, ft, H), lt.on(et.A.DVB_FONT_DOWNLOAD_FAILED, G, H), lt.on(et.A.DVB_FONT_DOWNLOAD_COMPLETE, K, H), lt.on(et.A.MEDIAINFO_UPDATED, vt, H), k.get().streaming.text.webvtt.customRenderingEnabled && (lt.on(et.A.PLAYBACK_TIME_UPDATED, bt, H), lt.on(et.A.PLAYBACK_SEEKING, _t, H));
          }, initializeForStream: function(nt) {
            const ct = nt.id, V = fg(f).create({ videoModel: O, settings: k, streamInfo: nt });
            V.initialize(), N[ct] = V;
            const mt = cg(f).create({ errHandler: v, adapter: E, dvbFonts: Z, manifestModel: M, mediaController: x, videoModel: O, textTracks: V, vttParser: Y, vttCustomRenderingParser: J, ttmlParser: it, streamInfo: nt, settings: k });
            mt.initialize(), D[ct] = mt, B[ct] = {}, B[ct].lastEnabledIndex = -1;
          }, isTextEnabled: Pt, reset: function() {
            Object.keys(D).forEach((nt) => {
              D[nt].resetEmbedded(), D[nt].reset();
            }), Z.reset(), yt(), lt.off(et.A.TEXT_TRACKS_QUEUE_INITIALIZED, ft, H), lt.off(et.A.DVB_FONT_DOWNLOAD_FAILED, G, H), lt.off(et.A.DVB_FONT_DOWNLOAD_COMPLETE, K, H), lt.off(et.A.MEDIAINFO_UPDATED, vt, H), k.get().streaming.text.webvtt.customRenderingEnabled && (lt.off(et.A.PLAYBACK_TIME_UPDATED, bt, H), lt.off(et.A.PLAYBACK_SEEKING, _t, H));
          }, setTextTrack: Ot, clearDataForStream: function(nt) {
            D[nt] && (D[nt].resetEmbedded(), D[nt].reset(), delete D[nt]), N[nt] && (N[nt].deleteAllTextTracks(), delete N[nt]), B[nt] && delete B[nt];
          } }, st = !1, ht = !1, At = !1, Y = mg(f).getInstance(), J = pg(f).getInstance(), it = gg(f).getInstance(), lt = (0, It.A)(f).getInstance(), F = (0, ae.A)(f).getInstance().getLogger(H), yt(), H;
        }
        Fc.__dashjs_factory_name = "TextController";
        var yg = Dt.A.getClassFactory(Fc);
        function Uc(y) {
          y = y || {};
          const f = this.context, E = (0, ae.A)(f).getInstance(), v = y.settings, M = (0, It.A)(f).getInstance();
          let x, z, O, k, H, B;
          function D() {
            return navigator && navigator.connection && !isNaN(navigator.connection.downlink) && navigator.connection.downlink > 0 ? 1e3 * navigator.connection.downlink : NaN;
          }
          function N(it, lt, at, st) {
            const ht = Math.pow(0.5, at / st.fast);
            it.fastEstimate = (1 - ht) * lt + ht * it.fastEstimate;
            const At = Math.pow(0.5, at / st.slow);
            it.slowEstimate = (1 - At) * lt + At * it.slowEstimate, it.totalWeight += at;
          }
          function Y() {
            x = {}, z = {}, O = {}, k = {};
          }
          const J = { addEntry: function(it, lt) {
            try {
              if (!(it && lt && lt.trace && lt.trace.length)) return;
              (function(ht) {
                x[ht] = x[ht] || [], z[ht] = z[ht] || [], O[ht] = O[ht] || { fastEstimate: 0, slowEstimate: 0, totalWeight: 0 }, k[ht] = k[ht] || { fastEstimate: 0, slowEstimate: 0, totalWeight: 0 };
              })(it);
              const at = lt.tresponse.getTime() - lt.trequest.getTime() || 1;
              let st = function(ht, At) {
                return ht._fileLoaderType && ht._fileLoaderType === q.A.FILE_LOADER_TYPES.FETCH ? function(Z) {
                  const F = Z.trace.reduce((ft, bt) => ft + bt.b[0], 0), G = Z.trace.reduce((ft, bt) => ft + bt.d, 0);
                  let K = NaN;
                  return v.get().streaming.abr.throughput.useNetworkInformationApi.fetch && (K = D()), isNaN(K) && (K = Math.round(8 * F / G)), { downloadedBytes: F, value: K, downloadTimeInMs: G };
                }(ht) : function(Z, F) {
                  let G = NaN, K = NaN, ft = !1;
                  if (v.get().streaming.abr.throughput.useResourceTimingApi && Z._resourceTimingValues) G = Z._resourceTimingValues.transferSize, K = Z._resourceTimingValues.responseEnd - Z._resourceTimingValues.responseStart, ft = !0;
                  else {
                    if (Z.trace.length <= 1) return { throughput: NaN, downloadTimeInMs: NaN };
                    G = Z.trace.reduce((_t, vt) => _t + vt.b[0], 0) - Z.trace[0].b[0], K = Math.max(Z.trace.reduce((_t, vt) => _t + vt.d, 0) - Z.trace[0].d, 1);
                  }
                  let bt = NaN;
                  if (!ft && v.get().streaming.abr.throughput.useNetworkInformationApi.xhr && (bt = D()), isNaN(bt)) {
                    const _t = v.get().streaming.abr.throughput.useDeadTimeLatency ? K : K + F;
                    bt = Math.round(8 * G / _t);
                  }
                  return { downloadedBytes: G, value: bt, downloadTimeInMs: K };
                }(ht, At);
              }(lt, at);
              if (st.latencyInMs = at, isNaN(st.value) || !isFinite(st.value)) return;
              if (lt.cmsd) {
                const ht = lt.cmsd.dynamic && lt.cmsd.dynamic.etp ? lt.cmsd.dynamic.etp : null;
                if (ht) {
                  const At = v.get().streaming.cmsd.abr.etpWeightRatio;
                  At > 0 && At <= 1 && (st.value = st.value * (1 - At) + ht * At);
                }
              }
              if (function(ht, At, Z) {
                return v.get().streaming.abr.throughput.useResourceTimingApi && Z._resourceTimingValues ? Z._resourceTimingValues.transferSize === 0 && Z._resourceTimingValues.decodedBodySize > 0 : !isNaN(At) && (ht === q.A.VIDEO ? At < v.get().streaming.cacheLoadThresholds[q.A.VIDEO] : ht === q.A.AUDIO ? At < v.get().streaming.cacheLoadThresholds[q.A.AUDIO] : ht === q.A.MESH ? At < v.get().streaming.cacheLoadThresholds[q.A.MESH] : void 0);
              }(it, lt._tfinish.getTime() - lt.trequest.getTime(), lt)) return void B.debug(`${it} Assuming segment ${lt.url} came from cache, ignoring it for throughput calculation`);
              B.debug(`Added throughput entry for ${it}: ${st.value} kbit/s`), st.serviceLocation = lt._serviceLocation, x[it].push(st), z[it].push({ value: at }), function(ht) {
                x[ht].length > v.get().streaming.abr.throughput.sampleSettings.maxMeasurementsToKeep && x[ht].shift(), z[ht].length > v.get().streaming.abr.throughput.sampleSettings.maxMeasurementsToKeep && z[ht].shift();
              }(it), M.trigger(St.A.THROUGHPUT_MEASUREMENT_STORED, { throughputValues: st }), lt.type !== Ct.G.MPD_TYPE && (N(O[it], st.value, v.get().streaming.abr.throughput.ewma.weightDownloadTimeMultiplicationFactor * st.downloadTimeInMs, H.bandwidthHalfLife), N(k[it], at, 1, H.latencyHalfLife));
            } catch (at) {
              B.error(at);
            }
          }, getThroughputDict: function(it) {
            return it ? x[it] : x;
          }, getEwmaThroughputDict: function(it) {
            return it ? O[it] : O;
          }, getEwmaLatencyDict: function(it) {
            return it ? k[it] : k;
          }, getEwmaHalfLife: function() {
            return H;
          }, getLatencyDict: function(it) {
            return it ? z[it] : z;
          }, reset: Y };
          return B = E.getLogger(J), H = { bandwidthHalfLife: { fast: v.get().streaming.abr.throughput.ewma.throughputFastHalfLifeSeconds, slow: v.get().streaming.abr.throughput.ewma.throughputSlowHalfLifeSeconds }, latencyHalfLife: { fast: v.get().streaming.abr.throughput.ewma.latencyFastHalfLifeCount, slow: v.get().streaming.abr.throughput.ewma.latencySlowHalfLifeCount } }, Y(), J;
        }
        Uc.__dashjs_factory_name = "ThroughputModel";
        var bg = Dt.A.getClassFactory(Uc);
        function jc() {
          const y = this.context, f = (0, It.A)(y).getInstance();
          let E, v, M;
          function x() {
            performance.clearResourceTimings();
          }
          function z(ht) {
            ht.metric !== pt.HTTP_REQUEST || !ht.value || ht.value.type !== Ct.G.MPD_TYPE && (ht.value.type !== Ct.G.MEDIA_SEGMENT_TYPE || ht.mediaType !== q.A.AUDIO && ht.mediaType !== q.A.VIDEO && ht.mediaType !== q.A.MESH) || E.addEntry(ht.mediaType, ht.value);
          }
          function O(ht, At) {
            let Z, F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, G = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : NaN, K = null, ft = E.getEwmaHalfLife(), bt = null, _t = !0;
            switch (F || (F = M.get().streaming.abr.throughput.averageCalculationMode), ht) {
              case q.A.THROUGHPUT_TYPES.BANDWIDTH:
                K = F === q.A.THROUGHPUT_CALCULATION_MODES.EWMA ? E.getEwmaThroughputDict(At) : E.getThroughputDict(At), bt = ft.bandwidthHalfLife, _t = !0, G = isNaN(G) ? v.getIsDynamic() ? M.get().streaming.abr.throughput.sampleSettings.live : M.get().streaming.abr.throughput.sampleSettings.vod : G;
                break;
              case q.A.THROUGHPUT_TYPES.LATENCY:
                K = F === q.A.THROUGHPUT_CALCULATION_MODES.EWMA ? E.getEwmaLatencyDict(At) : E.getLatencyDict(At), bt = ft.latencyHalfLife, _t = !1, G = isNaN(G) ? M.get().streaming.abr.throughput.sampleSettings.averageLatencySampleAmount : G;
            }
            if (!K || K.length === 0) return NaN;
            switch (F) {
              case q.A.THROUGHPUT_CALCULATION_MODES.ARITHMETIC_MEAN:
                return Z = k(K, G, ht), H(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.BYTE_SIZE_WEIGHTED_ARITHMETIC_MEAN:
                return Z = k(K, G, ht), B(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.DATE_WEIGHTED_ARITHMETIC_MEAN:
                return Z = k(K, G, ht), D(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.HARMONIC_MEAN:
                return Z = k(K, G, ht), N(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.BYTE_SIZE_WEIGHTED_HARMONIC_MEAN:
                return Z = k(K, G, ht), Y(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.DATE_WEIGHTED_HARMONIC_MEAN:
                return Z = k(K, G, ht), J(K, Z);
              case q.A.THROUGHPUT_CALCULATION_MODES.EWMA:
                return it(K, bt, _t);
              case q.A.THROUGHPUT_CALCULATION_MODES.ZLEMA:
                return Z = k(K, G, ht), lt(K, Z);
            }
          }
          function k(ht, At, Z) {
            if (ht) {
              if (At >= ht.length) At = ht.length;
              else if (Z === q.A.THROUGHPUT_TYPES.BANDWIDTH && M.get().streaming.abr.throughput.sampleSettings.enableSampleSizeAdjustment) for (let F = 1; F < At; ++F) {
                const G = ht[ht.length - F].value / ht[ht.length - F - 1].value;
                if ((G >= M.get().streaming.abr.throughput.sampleSettings.increaseScale || G <= M.get().streaming.abr.throughput.sampleSettings.decreaseScale) && (At += 1) === ht.length) break;
              }
            } else At = 0;
            return At;
          }
          function H(ht, At) {
            let Z = ht;
            return At !== 0 && Z && Z.length !== 0 ? (Z = Z.slice(-At), Z.reduce((F, G) => F + G.value, 0) / Z.length) : NaN;
          }
          function B(ht, At) {
            let Z = ht;
            if (At === 0 || !Z || Z.length === 0) return NaN;
            Z = Z.slice(-At);
            let F = 0;
            return Z.reduce((G, K) => {
              let ft = Math.sqrt(K.downloadedBytes);
              return F += ft, G + K.value * ft;
            }, 0) / F;
          }
          function D(ht, At) {
            let Z = ht;
            if (At === 0 || !Z || Z.length === 0) return NaN;
            Z = Z.slice(-At);
            let F = 0;
            return Z.reduce((G, K, ft) => {
              let bt = ft + 1;
              return F += bt, G + K.value * bt;
            }, 0) / F;
          }
          function N(ht, At) {
            let Z = ht;
            if (At === 0 || !Z || Z.length === 0) return NaN;
            Z = Z.slice(-At);
            const F = Z.reduce((G, K) => G + 1 / K.value, 0);
            return Z.length / F;
          }
          function Y(ht, At) {
            let Z = ht;
            if (At === 0 || !Z || Z.length === 0) return NaN;
            Z = Z.slice(-At);
            let F = 0;
            const G = Z.reduce((K, ft) => {
              let bt = Math.sqrt(ft.downloadedBytes);
              return F += bt, K + 1 / ft.value * bt;
            }, 0);
            return F / G;
          }
          function J(ht, At) {
            let Z = ht;
            if (At === 0 || !Z || Z.length === 0) return NaN;
            Z = Z.slice(-At);
            let F = 0;
            const G = Z.reduce((K, ft, bt) => {
              let _t = bt + 1;
              return F += _t, K + 1 / ft.value * _t;
            }, 0);
            return F / G;
          }
          function it(ht, At) {
            let Z = !(arguments.length > 2 && arguments[2] !== void 0) || arguments[2];
            if (!ht || ht.totalWeight <= 0) return NaN;
            const F = ht.fastEstimate / (1 - Math.pow(0.5, ht.totalWeight / At.fast)), G = ht.slowEstimate / (1 - Math.pow(0.5, ht.totalWeight / At.slow));
            return Z ? Math.min(F, G) : Math.max(F, G);
          }
          function lt(ht, At) {
            if (At === 0 || !ht || ht.length === 0) return NaN;
            let Z = ht.slice(-At).map((ft) => ft.value), F = 2 / (Z.length + 1), G = Z[Z.length - 1], K = Z[Z.length - 1];
            for (let ft = 0; ft < Z.length; ft++) G = F * Z[ft] + (1 - F) * G, K = F * G + (1 - F) * K;
            return K;
          }
          function at(ht) {
            let At = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            const F = O(q.A.THROUGHPUT_TYPES.BANDWIDTH, ht, At, Z);
            return Math.round(F);
          }
          const st = { getArithmeticMean: H, getAverageLatency: function(ht) {
            let At = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            const F = O(q.A.THROUGHPUT_TYPES.LATENCY, ht, At, Z);
            return Math.round(F);
          }, getAverageThroughput: at, getByteSizeWeightedArithmeticMean: B, getByteSizeWeightedHarmonicMean: Y, getDateWeightedArithmeticMean: D, getDateWeightedHarmonicMean: J, getEwma: it, getHarmonicMean: N, getRawThroughputData: function(ht) {
            return ht ? E.getThroughputDict(ht) : [];
          }, getSafeAverageThroughput: function(ht) {
            let At = at(ht, arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN);
            return isNaN(At) || (At *= M.get().streaming.abr.throughput.bandwidthSafetyFactor), At;
          }, getZlema: lt, initialize: function() {
            E = bg(y).create({ settings: M }), f.on(St.A.METRIC_ADDED, z, st), performance && performance.addEventListener("resourcetimingbufferfull", x);
          }, reset: function() {
            E.reset(), f.off(St.A.METRIC_ADDED, z, st), performance && performance.removeEventListener("resourcetimingbufferfull", x);
          }, setConfig: function(ht) {
            ht.settings && (M = ht.settings), ht.playbackController && (v = ht.playbackController);
          } };
          return st;
        }
        jc.__dashjs_factory_name = "ThroughputController";
        var Eg = Dt.A.getSingletonFactory(jc);
        function ou() {
          const y = "You must first call initialize() and set a source before calling this method", f = "You must first call initialize() and set a valid source and view before calling this method", E = "You must first call attachView() to set the video element before calling this method", v = "You must first call attachSource() with a valid source before calling this method", M = "MediaPlayer not initialized!", x = this.context, z = (0, It.A)(x).getInstance();
          let O = (0, Q.A)(x).getInstance();
          const k = (0, ae.A)(x).getInstance({ settings: O });
          let H, B, D, N, Y, J, it, lt, at, st, ht, At, Z, F, G, K, ft, bt, _t, vt, Pt, Ot, W, tt, Tt, yt, nt, ct, V, mt, Mt, Lt, Bt, Qt, Zt, fe, Ue, Ye, on, cn, Nn;
          function Qe() {
            sn(null), Pe(null), N = null, G && (G.reset(), G = null), K && (K.reset(), K = null), Pt && Pt.reset(), O.reset(), bt && (bt.reset(), bt = null);
          }
          function hn() {
            return !!D && !!Ue.getElement();
          }
          function Sn() {
            return (0, kp.i)();
          }
          function jn() {
            if (!it) throw f;
            return V.isPaused();
          }
          function Ln() {
            if (!it) throw f;
            return V.getIsDynamic();
          }
          function Rn(Rt) {
            const Wt = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
            let Ee = Bt.getCurrentDVRInfo(Wt);
            return Ee ? $t(Ee.range.start + Rt, Ee) : 0;
          }
          function $t(Rt, Wt) {
            let Ee = V.getOriginalLiveDelay();
            return Rt > Wt.range.end - Ee && (Rt = Wt.range.end - Ee), Rt;
          }
          function be() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
            if (!it) throw f;
            let Wt = De().currentTime;
            return Rt !== "" && (Wt = yt.getTimeRelativeToStreamId(Wt, Rt)), Wt;
          }
          function ge(Rt) {
            (0, pe.sq)(Rt, "boolean"), lt = Rt;
          }
          function Te() {
            Pt.restoreDefaultUTCTimingSources();
          }
          function ee() {
            return Bt;
          }
          function De() {
            if (!Ue.getElement()) throw E;
            return Ue.getElement();
          }
          function Pe(Rt) {
            if (!Y) throw M;
            Ue.setElement(Rt), Rt && (We(), function() {
              if (K || typeof dashjs > "u") return;
              let Wt = dashjs.MetricsReporting;
              typeof Wt == "function" && (K = Wt(x).create().createMetricsReporting({ debug: k, eventBus: z, mediaElement: De(), adapter: _t, dashMetrics: Bt, mediaPlayerModel: vt, events: et.A, constants: q.A, metricsConstants: pt }));
            }(), function() {
              if (ft || typeof dashjs > "u") return;
              let Wt = dashjs.MssHandler;
              typeof Wt == "function" && (X.extend(Wt.errors), ft = Wt(x).create({ eventBus: z, mediaPlayerModel: vt, dashMetrics: Bt, manifestModel: Qt, playbackController: V, streamController: yt, protectionController: G, baseURLController: W, errHandler: Ot, events: et.A, constants: q.A, debug: k, initSegmentType: Ct.G.INIT_SEGMENT_TYPE, BASE64: au, ISOBoxer: us, settings: O }));
            }(), yt && yt.switchToVideoElement(at)), it && ie(), ye(at);
          }
          function nn(Rt) {
            if (!J) throw y;
            let Wt = yt.getActiveStreamInfo();
            return Wt ? F.getTracksFor(Rt, Wt.id).filter((Ee) => !G || G.areKeyIdsUsable(Ee.normalizedKeyIds)) : [];
          }
          function sn(Rt) {
            let Wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NaN;
            if (!Y) throw M;
            typeof Rt == "string" && Ye.initialize(Rt), Wt == null && (Wt = NaN), isNaN(Wt) || (Wt = Math.max(0, Wt)), at = Wt, D = Rt, (J || it) && ie(), hn() && ye(at);
          }
          function gn() {
            if (!J) throw y;
            let Rt = yt.getActiveStreamInfo();
            return Rt ? yt.getStreamById(Rt.id) : null;
          }
          function ie() {
            it = !1, J = !1, _t.reset(), yt.reset(), ct.reset(), Lt.reset(), V.reset(), mt.reset(), Mt.reset(), st.reset(), ht.reset(), F.reset(), cn.reset(), G && (O.get().streaming.protection.keepProtectionMediaKeys ? G.stop() : (G.reset(), G = null, We())), nt.reset(), Zt.reset(), fe.reset();
          }
          function Le() {
            return ip(x).create({ debug: k, errHandler: Ot, dashMetrics: Bt, mediaPlayerModel: vt, mssHandler: ft, settings: O });
          }
          function We() {
            if (G) return G;
            if (typeof dashjs > "u") return null;
            let Rt = dashjs.Protection;
            if (typeof Rt == "function") {
              let Wt = Rt(x).create();
              return et.A.extend(Rt.events), St.A.extend(Rt.events, { publicOnly: !0 }), X.extend(Rt.errors), G = Wt.createProtectionSystem({ debug: k, errHandler: Ot, videoModel: Ue, customParametersModel: Pt, capabilities: tt, eventBus: z, events: et.A, BASE64: au, constants: q.A, cmcdModel: Zt, settings: O }), tt || (tt = (0, Bd.A)(x).getInstance()), tt.setProtectionController(G), G;
            }
            return null;
          }
          function ln() {
            if (!Y) throw M;
            if (bt) return bt;
            if (typeof dashjs > "u") return null;
            let Rt = dashjs.OfflineController;
            if (typeof Rt == "function") {
              et.A.extend(Rt.events), St.A.extend(Rt.events, { publicOnly: !0 }), X.extend(Rt.errors);
              const Wt = Le(), Ee = Ne(x).create();
              return Ee.setConfig({ manifestModel: Qt, adapter: _t, manifestLoader: Wt, errHandler: Ot, contentSteeringController: Mt }), bt = Rt(x).create({ debug: k, manifestUpdater: Ee, baseURLController: W, manifestLoader: Wt, manifestModel: Qt, mediaPlayerModel: vt, abrController: st, playbackController: V, adapter: _t, errHandler: Ot, dashMetrics: Bt, timelineConverter: Z, segmentBaseController: cn, schemeLoaderFactory: At, eventBus: z, events: et.A, errors: X, constants: q.A, settings: O, dashConstants: I.A, urlUtils: Se(x).getInstance() }), bt;
            }
            return null;
          }
          function ye() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NaN;
            bt && bt.resetRecords(), !J && D && (J = !0, B.info("Streaming Initialized"), function() {
              const Wt = Le();
              yt || (yt = cd(x).getInstance()), nt || (nt = yg(x).create({ errHandler: Ot, manifestModel: Qt, adapter: _t, mediaController: F, baseURLController: W, videoModel: Ue, settings: O })), Tt.setConfig({ capabilities: tt, customParametersModel: Pt, adapter: _t, settings: O, protectionController: G, manifestModel: Qt, errHandler: Ot }), yt.setConfig({ capabilities: tt, capabilitiesFilter: Tt, manifestLoader: Wt, manifestModel: Qt, mediaPlayerModel: vt, customParametersModel: Pt, protectionController: G, textController: nt, adapter: _t, dashMetrics: Bt, errHandler: Ot, timelineConverter: Z, videoModel: Ue, playbackController: V, serviceDescriptionController: mt, contentSteeringController: Mt, abrController: st, throughputController: ht, mediaController: F, settings: O, baseURLController: W, uriFragmentModel: Ye, segmentBaseController: cn }), ct.setConfig({ settings: O, playbackController: V, streamController: yt, videoModel: Ue, timelineConverter: Z, adapter: _t }), V.setConfig({ streamController: yt, serviceDescriptionController: mt, dashMetrics: Bt, adapter: _t, videoModel: Ue, timelineConverter: Z, settings: O }), Lt.setConfig({ streamController: yt, playbackController: V, mediaPlayerModel: vt, videoModel: Ue, settings: O }), ht.setConfig({ settings: O, playbackController: V }), st.setConfig({ streamController: yt, capabilities: tt, domStorage: on, mediaPlayerModel: vt, customParametersModel: Pt, throughputController: ht, cmsdModel: fe, dashMetrics: Bt, adapter: _t, videoModel: Ue, settings: O }), Zt.setConfig({ abrController: st, dashMetrics: Bt, playbackController: V, serviceDescriptionController: mt, throughputController: ht }), Nn.setConfig({ serviceDescriptionController: mt }), fe.setConfig({}), F.initialize(), ht.initialize(), st.initialize(), yt.initialize(lt, N), nt.initialize(), ct.initialize(), Lt.initialize(), Zt.initialize(lt), fe.initialize(), Mt.initialize(), cn.initialize();
            }(), typeof D == "string" ? yt.load(D, Rt) : yt.loadWithManifest(D, Rt)), !it && hn() && (it = !0, z.trigger(St.A.PLAYBACK_INITIALIZED), B.info("Playback Initialized"));
          }
          return H = { addABRCustomRule: function(Rt, Wt, Ee) {
            Pt.addAbrCustomRule(Rt, Wt, Ee);
          }, addRequestInterceptor: function(Rt) {
            Pt.addRequestInterceptor(Rt);
          }, addResponseInterceptor: function(Rt) {
            Pt.addResponseInterceptor(Rt);
          }, addUTCTimingSource: function(Rt, Wt) {
            Pt.addUTCTimingSource(Rt, Wt);
          }, attachProtectionController: function(Rt) {
            G = Rt;
          }, attachSource: sn, attachTTMLRenderingDiv: function(Rt) {
            if (!Ue.getElement()) throw E;
            Ue.setTTMLRenderingDiv(Rt);
          }, attachView: Pe, attachVttRenderingDiv: function(Rt) {
            if (!Ue.getElement()) throw E;
            Ue.setVttRenderingDiv(Rt);
          }, clearDefaultUTCTimingSources: function() {
            Pt.clearDefaultUTCTimingSources();
          }, convertToTimeCode: function(Rt) {
            Rt = Math.max(Rt, 0);
            let Wt = Math.floor(Rt / 3600), Ee = Math.floor(Rt % 3600 / 60), te = Math.floor(Rt % 3600 % 60);
            return (Wt === 0 ? "" : Wt < 10 ? "0" + Wt.toString() + ":" : Wt.toString() + ":") + (Ee < 10 ? "0" + Ee.toString() : Ee.toString()) + ":" + (te < 10 ? "0" + te.toString() : te.toString());
          }, destroy: function() {
            Qe(), Dt.A.deleteSingletonInstances(x);
          }, duration: function() {
            if (!it) throw f;
            let Rt = De().duration;
            if (V.getIsDynamic()) {
              const Wt = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
              let Ee = Bt.getCurrentDVRInfo(Wt);
              Rt = Ee ? Ee.range.end - Ee.range.start : 0;
            }
            return Rt;
          }, enableForcedTextStreaming: function(Rt) {
            return !(!yt.getActiveStreamInfo() || !nt) && nt.enableForcedTextStreaming(Rt);
          }, enableText: function(Rt) {
            const Wt = yt.getActiveStreamInfo();
            return !(!Wt || !nt) && nt.enableText(Wt.id, Rt);
          }, extend: function(Rt, Wt, Ee) {
            Dt.A.extend(Rt, Wt, Ee, x);
          }, formatUTC: function(Rt, Wt, Ee) {
            let te = arguments.length > 3 && arguments[3] !== void 0 && arguments[3];
            const Ie = new Date(1e3 * Rt), rn = Ie.toLocaleDateString(Wt), Tn = Ie.toLocaleTimeString(Wt, { hour12: Ee });
            return te ? Tn + " " + rn : Tn;
          }, getABRCustomRules: function() {
            return Pt.getAbrCustomRules();
          }, getActiveStream: gn, getAutoPlay: function() {
            return lt;
          }, getAvailableBaseUrls: function() {
            const Rt = Qt.getValue();
            return Rt ? W.getBaseUrls(Rt) : [];
          }, getAvailableLocations: function() {
            const Rt = Qt.getValue();
            if (!Rt) return [];
            const Wt = _t.getLocation(Rt), Ee = Mt.getSynthesizedLocationElements(Wt);
            return Wt.concat(Ee);
          }, getAverageLatency: function() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q.A.VIDEO, Wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return ht ? ht.getAverageLatency(Rt, Wt, Ee) : 0;
          }, getAverageThroughput: function() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q.A.VIDEO, Wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return ht ? ht.getAverageThroughput(Rt, Wt, Ee) : 0;
          }, getBufferLength: function(Rt) {
            const Wt = [q.A.VIDEO, q.A.AUDIO, q.A.TEXT, q.A.MESH];
            if (Rt)
              return Wt.indexOf(Rt) !== -1 ? ee().getCurrentBufferLevel(Rt) || NaN : (B.warn("getBufferLength requested for invalid type"), NaN);
            {
              const Ee = Wt.map((te) => nn(te).length > 0 ? ee().getCurrentBufferLevel(te) : Number.MAX_VALUE).reduce((te, Ie) => Math.min(te, Ie));
              return Ee === Number.MAX_VALUE ? NaN : Ee;
            }
          }, getCurrentLiveLatency: function() {
            if (!Y) throw M;
            return it ? V.getCurrentLiveLatency() : NaN;
          }, getCurrentRepresentationForType: function(Rt) {
            if (!J) throw y;
            if (Rt !== q.A.IMAGE && Rt !== q.A.VIDEO && Rt !== q.A.AUDIO && Rt !== q.A.MESH) return null;
            const Wt = gn();
            if (!Wt) return null;
            if (Rt === q.A.IMAGE) {
              const Ee = Wt.getThumbnailController();
              return Ee ? Ee.getCurrentTrack() : -1;
            }
            return Wt.getCurrentRepresentationForType(Rt);
          }, getCurrentSteeringResponseData: function() {
            if (Mt) return Mt.getCurrentSteeringResponseData();
          }, getCurrentTextTrackIndex: function() {
            let Rt = NaN;
            const Wt = yt.getActiveStreamInfo();
            if (Wt && nt) return Rt = nt.getCurrentTrackIdx(Wt.id), Rt;
          }, getCurrentTrackFor: function(Rt) {
            if (!J) throw y;
            let Wt = yt.getActiveStreamInfo();
            return Wt ? F.getCurrentTrackFor(Rt, Wt.id) : null;
          }, getDashAdapter: function() {
            return _t;
          }, getDashMetrics: ee, getDebug: function() {
            return k;
          }, getDvrSeekOffset: Rn, getDvrWindow: function() {
            if (!it) throw f;
            const Rt = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
            let Wt = Bt.getCurrentDVRInfo(Rt);
            if (!Wt) return {};
            let Ee = 0;
            const te = V.getIsDynamic();
            return te && (Ee = Wt.manifestInfo.availableFrom.getTime() / 1e3), { start: Wt.range.start, end: Wt.range.end, startAsUtc: te ? Ee + Wt.range.start : NaN, endAsUtc: te ? Ee + Wt.range.end : NaN, size: Wt.range.end - Wt.range.start };
          }, getInitialMediaSettingsFor: function(Rt) {
            if (!Y) throw M;
            return F.getInitialSettings(Rt);
          }, getLowLatencyModeEnabled: function() {
            if (!it) throw f;
            return V.getLowLatencyModeEnabled();
          }, getManifest: function() {
            return Qt.getValue();
          }, getOfflineController: function() {
            return ln();
          }, getPlaybackRate: function() {
            return De().playbackRate;
          }, getProtectionController: function() {
            return We();
          }, getRawThroughputData: function() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q.A.VIDEO;
            return ht ? ht.getRawThroughputData(Rt) : [];
          }, getRepresentationsByType: function(Rt) {
            let Wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            if (!J) throw y;
            let Ee = Wt ? yt.getStreamById(Wt) : gn();
            return Ee ? Ee.getRepresentationsByType(Rt) : [];
          }, getSafeAverageThroughput: function() {
            let Rt = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : q.A.VIDEO, Wt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, Ee = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : NaN;
            return ht ? ht.getSafeAverageThroughput(Rt, Wt, Ee) : 0;
          }, getSettings: function() {
            return O.get();
          }, getSource: function() {
            if (!D) throw v;
            return D;
          }, getStreamsFromManifest: function(Rt) {
            if (!J) throw y;
            return _t.getStreamsInfo(Rt);
          }, getTTMLRenderingDiv: function() {
            return Ue ? Ue.getTTMLRenderingDiv() : null;
          }, getTargetLiveDelay: function() {
            if (!it) throw f;
            return V.getOriginalLiveDelay();
          }, getTracksFor: nn, getTracksForTypeFromManifest: function(Rt, Wt, Ee) {
            if (!J) throw y;
            return (Ee = Ee || _t.getStreamsInfo(Wt, 1)[0]) ? _t.getAllMediaInfoForType(Ee, Rt, Wt) : [];
          }, getVersion: Sn, getVideoElement: De, getVolume: function() {
            return De().volume;
          }, getXHRWithCredentialsForType: function(Rt) {
            return Pt.getXHRWithCredentialsForType(Rt);
          }, initialize: function(Rt, Wt, Ee) {
            let te = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : NaN;
            tt || (tt = (0, Bd.A)(x).getInstance(), tt.setConfig({ settings: O, protectionController: G })), Ot || (Ot = rp(x).getInstance()), tt.supportsMediaSource() ? (Y || (Y = !0, Z = tg(x).getInstance(), ht || (ht = Eg(x).getInstance()), st || (st = fc(x).getInstance()), At || (At = Nr(x).getInstance()), V || (V = zt(x).getInstance()), F || (F = Pm(x).getInstance()), yt || (yt = cd(x).getInstance()), ct || (ct = Mm(x).getInstance()), Lt || (Lt = km(x).getInstance()), mt || (mt = Lm(x).getInstance()), Mt || (Mt = Ut(x).getInstance()), Tt || (Tt = ap(x).getInstance()), _t = Fp(x).getInstance(), Qt = lp(x).getInstance(), Zt = Pn(x).getInstance(), fe = Ro(x).getInstance(), Nn = ls(x).getInstance(), Bt = Zp(x).getInstance({ settings: O }), on = Mp(x).getInstance({ settings: O }), _t.setConfig({ constants: q.A, cea608parser: new jt(), errHandler: Ot, BASE64: au }), W || (W = jm(x).create()), W.setConfig({ adapter: _t, contentSteeringController: Mt }), mt.setConfig({ adapter: _t }), cn || (cn = Dp(x).getInstance({ dashMetrics: Bt, mediaPlayerModel: vt, errHandler: Ot, baseURLController: W, events: et.A, eventBus: z, debug: k, boxParser: Ts(x).getInstance(), errors: X })), F.setConfig({ domStorage: on, settings: O, mediaPlayerModel: vt, customParametersModel: Pt, videoModel: Ue }), vt.setConfig({ playbackController: V, serviceDescriptionController: mt }), Mt.setConfig({ adapter: _t, errHandler: Ot, dashMetrics: Bt, mediaPlayerModel: vt, manifestModel: Qt, serviceDescriptionController: mt, throughputController: ht, eventBus: z }), Te(), ge(Ee === void 0 || Ee), ln()), Rt && Pe(Rt), Wt && sn(Wt, te), B.info("[dash.js " + Sn() + "] MediaPlayer has been initialized")) : Ot.error(new Yt.A(X.CAPABILITY_MEDIASOURCE_ERROR_CODE, X.CAPABILITY_MEDIASOURCE_ERROR_MESSAGE));
          }, isDynamic: Ln, isMuted: function() {
            return De().muted;
          }, isPaused: jn, isReady: hn, isSeeking: function() {
            if (!it) throw f;
            return V.isSeeking();
          }, isTextEnabled: function() {
            const Rt = yt.getActiveStreamInfo();
            return !(!Rt || !nt) && nt.isTextEnabled(Rt);
          }, off: function(Rt, Wt, Ee) {
            z.off(Rt, Wt, Ee);
          }, on: function(Rt, Wt, Ee, te) {
            z.on(Rt, Wt, Ee, te);
          }, pause: function() {
            if (!it) throw f;
            V.pause();
          }, play: function() {
            if (!it) throw f;
            (!lt || jn() && it) && V.play(!0);
          }, preload: function() {
            if (!Ue.getElement() && !J) {
              if (!D) throw v;
              ye(at);
            }
          }, provideThumbnail: function(Rt, Wt) {
            if (typeof Wt != "function") return;
            if (Rt < 0) return void Wt(null);
            const Ee = V.getIsDynamic() ? Rn(Rt) : Rt, te = yt.getStreamForTime(Ee);
            if (te === null) return void Wt(null);
            const Ie = te.getThumbnailController();
            if (Ie) return Ie.provide(Ee, Wt);
            Wt(null);
          }, refreshManifest: function(Rt) {
            if (!Y) throw M;
            if (!hn()) return Rt(null, v);
            let Wt = this;
            if (typeof Rt == "function") {
              const Ee = function(te) {
                z.off(et.A.INTERNAL_MANIFEST_LOADED, Ee, Wt), te.error ? Rt(null, te.error) : Rt(te.manifest);
              };
              z.on(et.A.INTERNAL_MANIFEST_LOADED, Ee, Wt);
            }
            yt.refreshManifest();
          }, registerCustomCapabilitiesFilter: function(Rt) {
            Pt.registerCustomCapabilitiesFilter(Rt);
          }, registerLicenseRequestFilter: function(Rt) {
            Pt.registerLicenseRequestFilter(Rt);
          }, registerLicenseResponseFilter: function(Rt) {
            Pt.registerLicenseResponseFilter(Rt);
          }, removeABRCustomRule: function(Rt) {
            Pt.removeAbrCustomRule(Rt);
          }, removeAllABRCustomRule: function() {
            Pt.removeAllAbrCustomRule();
          }, removeRequestInterceptor: function(Rt) {
            Pt.removeRequestInterceptor(Rt);
          }, removeResponseInterceptor: function(Rt) {
            Pt.removeResponseInterceptor(Rt);
          }, removeUTCTimingSource: function(Rt, Wt) {
            Pt.removeUTCTimingSource(Rt, Wt);
          }, reset: Qe, resetCustomInitialTrackSelectionFunction: function() {
            Pt.resetCustomInitialTrackSelectionFunction(null);
          }, resetSettings: function() {
            O.reset();
          }, restoreDefaultUTCTimingSources: Te, retrieveManifest: function(Rt, Wt) {
            let Ee = Le(), te = this;
            const Ie = function(rn) {
              rn.error ? Wt(null, rn.error) : Wt(rn.manifest), z.off(et.A.INTERNAL_MANIFEST_LOADED, Ie, te), Ee.reset();
            };
            z.on(et.A.INTERNAL_MANIFEST_LOADED, Ie, te), Ye.initialize(Rt), Ee.load(Rt);
          }, seek: function(Rt) {
            if (!it) throw f;
            if ((0, pe.sq)(Rt, "number"), isNaN(Rt)) throw q.A.BAD_ARGUMENT_ERROR;
            Rt < 0 && (Rt = 0);
            let Wt = V.getIsDynamic() ? Rn(Rt) : Rt;
            const Ee = De();
            !V.getIsDynamic() && Ee.duration && (Wt = Math.min(Ee.duration, Wt)), V.seek(Wt, !1, !1, !0);
          }, seekToOriginalLive: function() {
            it && Ln() && V.seekToOriginalLive();
          }, seekToPresentationTime: function(Rt) {
            if (!it) throw f;
            if ((0, pe.sq)(Rt, "number"), isNaN(Rt)) throw q.A.BAD_ARGUMENT_ERROR;
            Rt < 0 && (Rt = 0);
            const Wt = De();
            if (!V.getIsDynamic() && Wt.duration && (Rt = Math.min(Wt.duration, Rt)), V.getIsDynamic()) {
              const Ee = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
              let te = Bt.getCurrentDVRInfo(Ee);
              if (!te) return;
              (Rt = $t(Rt, te)) < te.range.start && (Rt = te.range.start);
            }
            V.seek(Rt, !1, !1, !0);
          }, setAutoPlay: ge, setConfig: function(Rt) {
            Rt && (Rt.capabilities && (tt = Rt.capabilities), Rt.capabilitiesFilter && (Tt = Rt.capabilitiesFilter), Rt.streamController && (yt = Rt.streamController), Rt.textController && (nt = Rt.textController), Rt.gapController && (ct = Rt.gapController), Rt.throughputController && (ht = Rt.throughputController), Rt.playbackController && (V = Rt.playbackController), Rt.serviceDescriptionController && (mt = Rt.serviceDescriptionController), Rt.contentSteeringController && (Mt = Rt.contentSteeringController), Rt.clientDataReportingController && (Nn = Rt.clientDataReportingController), Rt.catchupController && (Lt = Rt.catchupController), Rt.mediaPlayerModel && (vt = Rt.mediaPlayerModel), Rt.customParametersModel && (Pt = Rt.customParametersModel), Rt.abrController && (st = Rt.abrController), Rt.schemeLoaderFactory && (At = Rt.schemeLoaderFactory), Rt.mediaController && (F = Rt.mediaController), Rt.settings && (O = Rt.settings), Rt.dashMetrics && (Bt = Rt.dashMetrics));
          }, setCurrentTrack: function(Rt) {
            let Wt = arguments.length > 1 && arguments[1] !== void 0 && arguments[1];
            if (!J) throw y;
            !G || G.areKeyIdsUsable(Rt.normalizedKeyIds) ? F.setTrack(Rt, { noSettingsSave: Wt }) : B.error(`Can not switch to track with index ${Rt.index} because key is not usable`);
          }, setCustomInitialTrackSelectionFunction: function(Rt) {
            Pt.setCustomInitialTrackSelectionFunction(Rt);
          }, setInitialMediaSettingsFor: function(Rt, Wt) {
            if (!Y) throw M;
            let Ee = function(te) {
              const Ie = O.get().streaming.defaultSchemeIdUri;
              let rn = {};
              function Tn(Un, Cn, wi) {
                let Ui = {};
                if (Cn) {
                  if (Cn instanceof Array) throw "Array type not supported for settings!";
                  return Cn instanceof Object ? (Ui.schemeIdUri = Cn.schemeIdUri ? Cn.schemeIdUri : "", Ui.value = Cn.value ? Cn.value : "") : (Ui.schemeIdUri = wi, Ui.value = Cn, B.warn("No schemeIdUri provided for " + Un + ', using default "' + wi + '"')), Ui;
                }
                return null;
              }
              return te.lang && (rn.lang = te.lang), isNaN(te.index) || (rn.index = te.index), te.viewpoint && (rn.viewpoint = Tn("viewpoint", te.viewpoint, Ie.viewpoint)), te.audioChannelConfiguration && (rn.audioChannelConfiguration = Tn("audioChannelConfiguration", te.audioChannelConfiguration, Ie.audioChannelConfiguration)), te.role && (rn.role = Tn("role", te.role, Ie.role)), te.accessibility && (rn.accessibility = Tn("accessibility", te.accessibility, Ie.accessibility)), rn;
            }(Wt);
            F.setInitialSettings(Rt, Ee);
          }, setMute: function(Rt) {
            (0, pe.sq)(Rt, "boolean"), De().muted = Rt;
          }, setPlaybackRate: function(Rt) {
            De().playbackRate = Rt;
          }, setProtectionData: function(Rt) {
            N = Rt, yt && yt.setProtectionData(N);
          }, setRepresentationForTypeById: function(Rt, Wt) {
            let Ee = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            if (Rt !== q.A.IMAGE && Rt !== q.A.VIDEO && Rt !== q.A.AUDIO && Rt !== q.A.MESH) return;
            if (!J) throw y;
            const te = gn();
            if (te) if (Rt === q.A.IMAGE) {
              const Ie = te.getThumbnailController();
              Ie && Ie.setTrackById(Wt);
            } else {
              const Ie = te.getRepresentationForTypeById(Rt, Wt);
              Ie && st.setPlaybackQuality(Rt, yt.getActiveStreamInfo(), Ie, { forceReplace: Ee });
            }
          }, setRepresentationForTypeByIndex: function(Rt, Wt) {
            let Ee = arguments.length > 2 && arguments[2] !== void 0 && arguments[2];
            if (Rt !== q.A.IMAGE && Rt !== q.A.VIDEO && Rt !== q.A.AUDIO && Rt !== q.A.MESH) return;
            if (!J) throw y;
            const te = gn();
            if (te) if (Rt === q.A.IMAGE) {
              const Ie = te.getThumbnailController();
              Ie && Ie.setTrackByIndex(Wt);
            } else {
              const Ie = te.getRepresentationForTypeByIndex(Rt, Wt);
              Ie && st.setPlaybackQuality(Rt, yt.getActiveStreamInfo(), Ie, { forceReplace: Ee });
            }
          }, setTextTrack: function(Rt) {
            if (!it) throw f;
            const Wt = yt.getActiveStreamInfo();
            Wt && nt && nt.setTextTrack(Wt.id, Rt);
          }, setVolume: function(Rt) {
            if (typeof Rt != "number" || isNaN(Rt) || Rt < 0 || Rt > 1) throw q.A.BAD_ARGUMENT_ERROR;
            De().volume = Rt;
          }, setXHRWithCredentialsForType: function(Rt, Wt) {
            Pt.setXHRWithCredentialsForType(Rt, Wt);
          }, time: be, timeAsUTC: function() {
            if (!it) throw f;
            if (!V.getIsDynamic() || be() < 0) return NaN;
            const Rt = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
            let Wt, Ee, te = Bt.getCurrentDVRInfo(Rt);
            return te ? (Wt = te.manifestInfo.availableFrom.getTime() / 1e3, Ee = Wt + be(), Ee) : 0;
          }, timeInDvrWindow: function() {
            if (!it) throw f;
            if (!V.getIsDynamic()) return be();
            let Rt = De().currentTime;
            const Wt = yt && yt.hasVideoTrack() ? q.A.VIDEO : q.A.AUDIO;
            let Ee = Bt.getCurrentDVRInfo(Wt);
            return Rt = Ee === null || Rt === 0 ? 0 : Math.max(0, Rt - Ee.range.start), Rt;
          }, trigger: function(Rt, Wt, Ee) {
            z.trigger(Rt, Wt, Ee);
          }, triggerSteeringRequest: function() {
            if (Mt) return Mt.loadSteeringData();
          }, unregisterCustomCapabilitiesFilter: function(Rt) {
            Pt.unregisterCustomCapabilitiesFilter(Rt);
          }, unregisterLicenseRequestFilter: function(Rt) {
            Pt.unregisterLicenseRequestFilter(Rt);
          }, unregisterLicenseResponseFilter: function(Rt) {
            Pt.unregisterLicenseResponseFilter(Rt);
          }, updateSettings: function(Rt) {
            O.update(Rt);
          }, updateSource: function(Rt) {
            D = Rt, yt.load(D);
          } }, B = k.getLogger(H), Y = !1, it = !1, J = !1, lt = !0, at = NaN, G = null, bt = null, N = null, _t = null, cn = null, et.A.extend(St.A), vt = up(x).getInstance(), Pt = (0, Co.A)(x).getInstance(), Ue = Ap(x).getInstance(), Ye = op(x).getInstance(), H;
        }
        ou.__dashjs_factory_name = "MediaPlayer";
        const tl = Dt.A.getClassFactory(ou);
        tl.events = St.A, tl.errors = X, Dt.A.updateClassFactory(ou.__dashjs_factory_name, tl);
        var vg = tl;
      }, 1191: function(L, h, b) {
        var A = b(7252);
        class l extends A.A {
          constructor() {
            super(), this.AST_IN_FUTURE = "astInFuture", this.BASE_URLS_UPDATED = "baseUrlsUpdated", this.BUFFER_EMPTY = "bufferStalled", this.BUFFER_LOADED = "bufferLoaded", this.BUFFER_LEVEL_STATE_CHANGED = "bufferStateChanged", this.BUFFER_LEVEL_UPDATED = "bufferLevelUpdated", this.DVB_FONT_DOWNLOAD_ADDED = "dvbFontDownloadAdded", this.DVB_FONT_DOWNLOAD_COMPLETE = "dvbFontDownloadComplete", this.DVB_FONT_DOWNLOAD_FAILED = "dvbFontDownloadFailed", this.DYNAMIC_TO_STATIC = "dynamicToStatic", this.ERROR = "error", this.FRAGMENT_LOADING_COMPLETED = "fragmentLoadingCompleted", this.FRAGMENT_LOADING_PROGRESS = "fragmentLoadingProgress", this.FRAGMENT_LOADING_STARTED = "fragmentLoadingStarted", this.FRAGMENT_LOADING_ABANDONED = "fragmentLoadingAbandoned", this.LOG = "log", this.MANIFEST_LOADING_STARTED = "manifestLoadingStarted", this.MANIFEST_LOADING_FINISHED = "manifestLoadingFinished", this.MANIFEST_LOADED = "manifestLoaded", this.METRICS_CHANGED = "metricsChanged", this.METRIC_CHANGED = "metricChanged", this.METRIC_ADDED = "metricAdded", this.METRIC_UPDATED = "metricUpdated", this.PERIOD_SWITCH_STARTED = "periodSwitchStarted", this.PERIOD_SWITCH_COMPLETED = "periodSwitchCompleted", this.QUALITY_CHANGE_REQUESTED = "qualityChangeRequested", this.QUALITY_CHANGE_RENDERED = "qualityChangeRendered", this.NEW_TRACK_SELECTED = "newTrackSelected", this.TRACK_CHANGE_RENDERED = "trackChangeRendered", this.STREAM_INITIALIZING = "streamInitializing", this.STREAM_UPDATED = "streamUpdated", this.STREAM_ACTIVATED = "streamActivated", this.STREAM_DEACTIVATED = "streamDeactivated", this.STREAM_INITIALIZED = "streamInitialized", this.STREAM_TEARDOWN_COMPLETE = "streamTeardownComplete", this.TEXT_TRACKS_ADDED = "allTextTracksAdded", this.TEXT_TRACK_ADDED = "textTrackAdded", this.CUE_ENTER = "cueEnter", this.CUE_EXIT = "cueExit", this.THROUGHPUT_MEASUREMENT_STORED = "throughputMeasurementStored", this.TTML_PARSED = "ttmlParsed", this.TTML_TO_PARSE = "ttmlToParse", this.CAPTION_RENDERED = "captionRendered", this.CAPTION_CONTAINER_RESIZE = "captionContainerResize", this.CAN_PLAY = "canPlay", this.CAN_PLAY_THROUGH = "canPlayThrough", this.PLAYBACK_ENDED = "playbackEnded", this.PLAYBACK_ERROR = "playbackError", this.PLAYBACK_INITIALIZED = "playbackInitialized", this.PLAYBACK_NOT_ALLOWED = "playbackNotAllowed", this.PLAYBACK_METADATA_LOADED = "playbackMetaDataLoaded", this.PLAYBACK_LOADED_DATA = "playbackLoadedData", this.PLAYBACK_PAUSED = "playbackPaused", this.PLAYBACK_PLAYING = "playbackPlaying", this.PLAYBACK_PROGRESS = "playbackProgress", this.PLAYBACK_RATE_CHANGED = "playbackRateChanged", this.PLAYBACK_SEEKED = "playbackSeeked", this.PLAYBACK_SEEKING = "playbackSeeking", this.PLAYBACK_STALLED = "playbackStalled", this.PLAYBACK_STARTED = "playbackStarted", this.PLAYBACK_TIME_UPDATED = "playbackTimeUpdated", this.PLAYBACK_VOLUME_CHANGED = "playbackVolumeChanged", this.PLAYBACK_WAITING = "playbackWaiting", this.MANIFEST_VALIDITY_CHANGED = "manifestValidityChanged", this.EVENT_MODE_ON_START = "eventModeOnStart", this.EVENT_MODE_ON_RECEIVE = "eventModeOnReceive", this.CONFORMANCE_VIOLATION = "conformanceViolation", this.REPRESENTATION_SWITCH = "representationSwitch", this.ADAPTATION_SET_REMOVED_NO_CAPABILITIES = "adaptationSetRemovedNoCapabilities", this.CONTENT_STEERING_REQUEST_COMPLETED = "contentSteeringRequestCompleted", this.INBAND_PRFT = "inbandPrft", this.MANAGED_MEDIA_SOURCE_START_STREAMING = "managedMediaSourceStartStreaming", this.MANAGED_MEDIA_SOURCE_END_STREAMING = "managedMediaSourceEndStreaming";
          }
        }
        let o = new l();
        h.A = o;
      }, 5212: function(L, h) {
        h.A = { MESH: "mesh", STREAM: "stream", VIDEO: "video", AUDIO: "audio", TEXT: "text", MUXED: "muxed", IMAGE: "image", STPP: "stpp", TTML: "ttml", VTT: "vtt", WVTT: "wvtt", CONTENT_STEERING: "contentSteering", LIVE_CATCHUP_MODE_DEFAULT: "liveCatchupModeDefault", LIVE_CATCHUP_MODE_LOLP: "liveCatchupModeLoLP", MOVING_AVERAGE_SLIDING_WINDOW: "slidingWindow", MOVING_AVERAGE_EWMA: "ewma", BAD_ARGUMENT_ERROR: "Invalid Arguments", MISSING_CONFIG_ERROR: "Missing config parameter(s)", TRACK_SWITCH_MODE_ALWAYS_REPLACE: "alwaysReplace", TRACK_SWITCH_MODE_NEVER_REPLACE: "neverReplace", TRACK_SELECTION_MODE_FIRST_TRACK: "firstTrack", TRACK_SELECTION_MODE_HIGHEST_BITRATE: "highestBitrate", TRACK_SELECTION_MODE_HIGHEST_EFFICIENCY: "highestEfficiency", TRACK_SELECTION_MODE_WIDEST_RANGE: "widestRange", TRACK_SELECTION_MODE_HIGHEST_SELECTION_PRIORITY: "highestSelectionPriority", CMCD_QUERY_KEY: "CMCD", CMCD_MODE_QUERY: "query", CMCD_MODE_HEADER: "header", CMCD_AVAILABLE_KEYS: ["br", "d", "ot", "tb", "bl", "dl", "mtp", "nor", "nrr", "su", "bs", "rtp", "cid", "pr", "sf", "sid", "st", "v"], CMCD_V2_AVAILABLE_KEYS: ["msd", "ltc"], CMCD_AVAILABLE_REQUESTS: ["segment", "mpd", "xlink", "steering", "other"], INITIALIZE: "initialize", TEXT_SHOWING: "showing", TEXT_HIDDEN: "hidden", TEXT_DISABLED: "disabled", ACCESSIBILITY_CEA608_SCHEME: "urn:scte:dash:cc:cea-608:2015", CC1: "CC1", CC3: "CC3", UTF8: "utf-8", SCHEME_ID_URI: "schemeIdUri", START_TIME: "starttime", SERVICE_DESCRIPTION_DVB_LL_SCHEME: "urn:dvb:dash:lowlatency:scope:2019", SUPPLEMENTAL_PROPERTY_DVB_LL_SCHEME: "urn:dvb:dash:lowlatency:critical:2019", CTA_5004_2023_SCHEME: "urn:mpeg:dash:cta-5004:2023", THUMBNAILS_SCHEME_ID_URIS: ["http://dashif.org/thumbnail_tile", "http://dashif.org/guidelines/thumbnail_tile"], FONT_DOWNLOAD_DVB_SCHEME: "urn:dvb:dash:fontdownload:2014", COLOUR_PRIMARIES_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:ColourPrimaries", URL_QUERY_INFO_SCHEME: "urn:mpeg:dash:urlparam:2014", EXT_URL_QUERY_INFO_SCHEME: "urn:mpeg:dash:urlparam:2016", MATRIX_COEFFICIENTS_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:MatrixCoefficients", TRANSFER_CHARACTERISTICS_SCHEME_ID_URI: "urn:mpeg:mpegB:cicp:TransferCharacteristics", HDR_METADATA_FORMAT_SCHEME_ID_URI: "urn:dvb:dash:hdr-dmi", HDR_METADATA_FORMAT_VALUES: { ST2094_10: "ST2094-10", SL_HDR2: "SL-HDR2", ST2094_40: "ST2094-40" }, MEDIA_CAPABILITIES_API: { COLORGAMUT: { SRGB: "srgb", P3: "p3", REC2020: "rec2020" }, TRANSFERFUNCTION: { SRGB: "srgb", PQ: "pq", HLG: "hlg" }, HDR_METADATATYPE: { SMPTE_ST_2094_10: "smpteSt2094-10", SLHDR2: "slhdr2", SMPTE_ST_2094_40: "smpteSt2094-40" } }, XML: "XML", ARRAY_BUFFER: "ArrayBuffer", DVB_REPORTING_URL: "dvb:reportingUrl", DVB_PROBABILITY: "dvb:probability", OFF_MIMETYPE: "application/font-sfnt", WOFF_MIMETYPE: "application/font-woff", VIDEO_ELEMENT_READY_STATES: { HAVE_NOTHING: 0, HAVE_METADATA: 1, HAVE_CURRENT_DATA: 2, HAVE_FUTURE_DATA: 3, HAVE_ENOUGH_DATA: 4 }, FILE_LOADER_TYPES: { FETCH: "fetch_loader", XHR: "xhr_loader" }, THROUGHPUT_TYPES: { LATENCY: "throughput_type_latency", BANDWIDTH: "throughput_type_bandwidth" }, THROUGHPUT_CALCULATION_MODES: { EWMA: "throughputCalculationModeEwma", ZLEMA: "throughputCalculationModeZlema", ARITHMETIC_MEAN: "throughputCalculationModeArithmeticMean", BYTE_SIZE_WEIGHTED_ARITHMETIC_MEAN: "throughputCalculationModeByteSizeWeightedArithmeticMean", DATE_WEIGHTED_ARITHMETIC_MEAN: "throughputCalculationModeDateWeightedArithmeticMean", HARMONIC_MEAN: "throughputCalculationModeHarmonicMean", BYTE_SIZE_WEIGHTED_HARMONIC_MEAN: "throughputCalculationModeByteSizeWeightedHarmonicMean", DATE_WEIGHTED_HARMONIC_MEAN: "throughputCalculationModeDateWeightedHarmonicMean" }, LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE: { MOOF_PARSING: "lowLatencyDownloadTimeCalculationModeMoofParsing", DOWNLOADED_DATA: "lowLatencyDownloadTimeCalculationModeDownloadedData", AAST: "lowLatencyDownloadTimeCalculationModeAast" }, RULES_TYPES: { QUALITY_SWITCH_RULES: "qualitySwitchRules", ABANDON_FRAGMENT_RULES: "abandonFragmentRules" }, QUALITY_SWITCH_RULES: { BOLA_RULE: "BolaRule", THROUGHPUT_RULE: "ThroughputRule", INSUFFICIENT_BUFFER_RULE: "InsufficientBufferRule", SWITCH_HISTORY_RULE: "SwitchHistoryRule", DROPPED_FRAMES_RULE: "DroppedFramesRule", LEARN_TO_ADAPT_RULE: "L2ARule", LOL_PLUS_RULE: "LoLPRule" }, ABANDON_FRAGMENT_RULES: { ABANDON_REQUEST_RULE: "AbandonRequestsRule" }, ID3_SCHEME_ID_URI: "https://aomedia.org/emsg/ID3", COMMON_ACCESS_TOKEN_HEADER: "common-access-token", DASH_ROLE_SCHEME_ID: "urn:mpeg:dash:role:2011", CODEC_FAMILIES: { MP3: "mp3", AAC: "aac", AC3: "ac3", EC3: "ec3", DTSX: "dtsx", DTSC: "dtsc", AVC: "avc", HEVC: "hevc" } };
      }, 2861: function(L, h) {
        h.A = { CLEARKEY_KEYSTEM_STRING: "org.w3.clearkey", WIDEVINE_KEYSTEM_STRING: "com.widevine.alpha", PLAYREADY_KEYSTEM_STRING: "com.microsoft.playready", PLAYREADY_RECOMMENDATION_KEYSTEM_STRING: "com.microsoft.playready.recommendation", WIDEVINE_UUID: "edef8ba9-79d6-4ace-a3c8-27dcd51d21ed", PLAYREADY_UUID: "9a04f079-9840-4286-ab92-e65be0885f95", CLEARKEY_UUID: "e2719d58-a985-b3c9-781a-b030af78d30e", W3C_CLEARKEY_UUID: "1077efec-c0b2-4d02-ace3-3c1e52e2fb4b", INITIALIZATION_DATA_TYPE_CENC: "cenc", INITIALIZATION_DATA_TYPE_KEYIDS: "keyids", INITIALIZATION_DATA_TYPE_WEBM: "webm", ENCRYPTION_SCHEME_CENC: "cenc", ENCRYPTION_SCHEME_CBCS: "cbcs", MEDIA_KEY_MESSAGE_TYPES: { LICENSE_REQUEST: "license-request", LICENSE_RENEWAL: "license-renewal", LICENSE_RELEASE: "license-release", INDIVIDUALIZATION_REQUEST: "individualization-request" }, ROBUSTNESS_STRINGS: { WIDEVINE: { SW_SECURE_CRYPTO: "SW_SECURE_CRYPTO", SW_SECURE_DECODE: "SW_SECURE_DECODE", HW_SECURE_CRYPTO: "HW_SECURE_CRYPTO", HW_SECURE_DECODE: "HW_SECURE_DECODE", HW_SECURE_ALL: "HW_SECURE_ALL" } }, MEDIA_KEY_STATUSES: { USABLE: "usable", EXPIRED: "expired", RELEASED: "released", OUTPUT_RESTRICTED: "output-restricted", OUTPUT_DOWNSCALED: "output-downscaled", STATUS_PENDING: "status-pending", INTERNAL_ERROR: "internal-error" } };
      }, 4469: function(L, h, b) {
        b.d(h, { default: function() {
          return U;
        } });
        class A {
          constructor() {
            this.mpdurl = null, this.errorcode = null, this.terror = null, this.url = null, this.ipaddress = null, this.servicelocation = null;
          }
        }
        A.SSL_CONNECTION_FAILED_PREFIX = "SSL", A.DNS_RESOLUTION_FAILED = "C00", A.HOST_UNREACHABLE = "C01", A.CONNECTION_REFUSED = "C02", A.CONNECTION_ERROR = "C03", A.CORRUPT_MEDIA_ISOBMFF = "M00", A.CORRUPT_MEDIA_OTHER = "M01", A.BASE_URL_CHANGED = "F00", A.BECAME_REPORTER = "S00";
        var l = A, o = b(913), u = b(138);
        function g(gt) {
          let rt, Ft;
          const ne = (gt = gt || {}).eventBus, Vt = gt.dashMetrics, Xt = gt.metricsConstants, qt = gt.events;
          function Gt(ke) {
            let ce = new l();
            if (Ft) {
              for (const je in ke) ke.hasOwnProperty(je) && (ce[je] = ke[je]);
              ce.mpdurl || (ce.mpdurl = Ft.originalUrl || Ft.url), ce.terror || (ce.terror = /* @__PURE__ */ new Date()), Vt.addDVBErrors(ce);
            }
          }
          function se(ke) {
            ke.error || (Ft = ke.manifest);
          }
          function Jt(ke) {
            Gt({ errorcode: l.BASE_URL_CHANGED, servicelocation: ke.entry });
          }
          function he() {
            Gt({ errorcode: l.BECAME_REPORTER });
          }
          function an(ke) {
            var ce;
            ke.metric === Xt.HTTP_REQUEST && ((ce = ke.value).responsecode === 0 || ce.responsecode == null || ce.responsecode >= 400 || ce.responsecode < 100 || ce.responsecode >= 600) && Gt({ errorcode: ce.responsecode || l.CONNECTION_ERROR, url: ce.url, terror: ce.tresponse, servicelocation: ce._serviceLocation });
          }
          function Fe(ke) {
            let ce;
            switch (ke.error ? ke.error.code : 0) {
              case MediaError.MEDIA_ERR_NETWORK:
                ce = l.CONNECTION_ERROR;
                break;
              case MediaError.MEDIA_ERR_DECODE:
                ce = l.CORRUPT_MEDIA_OTHER;
                break;
              default:
                return;
            }
            Gt({ errorcode: ce });
          }
          return rt = { initialize: function() {
            ne.on(qt.MANIFEST_UPDATED, se, rt), ne.on(qt.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, Jt, rt), ne.on(qt.METRIC_ADDED, an, rt), ne.on(qt.METRIC_UPDATED, an, rt), ne.on(qt.PLAYBACK_ERROR, Fe, rt), ne.on(o.A.BECAME_REPORTING_PLAYER, he, rt);
          }, reset: function() {
            ne.off(qt.MANIFEST_UPDATED, se, rt), ne.off(qt.SERVICE_LOCATION_BASE_URL_BLACKLIST_CHANGED, Jt, rt), ne.off(qt.METRIC_ADDED, an, rt), ne.off(qt.METRIC_UPDATED, an, rt), ne.off(qt.PLAYBACK_ERROR, Fe, rt), ne.off(o.A.BECAME_REPORTING_PLAYER, he, rt);
          } }, rt;
        }
        g.__dashjs_factory_name = "DVBErrorsTranslator";
        var m = u.A.getSingletonFactory(g), S = b(7377);
        function e(gt) {
          gt = gt || {};
          let rt, Ft, ne = !1, Vt = this.context, Xt = gt.mediaElement;
          return rt = { initialize: function(qt) {
            qt && qt.length && (qt.forEach((Gt) => {
              let se = Gt.starttime, Jt = se + Gt.duration;
              Ft.add(se, Jt);
            }), ne = !!qt[0]._useWallClockTime);
          }, reset: function() {
            Ft.clear();
          }, isEnabled: function() {
            let qt, Gt = Ft.length;
            if (!Gt) return !0;
            qt = ne ? (/* @__PURE__ */ new Date()).getTime() / 1e3 : Xt.currentTime;
            for (let se = 0; se < Gt; se += 1) {
              let Jt = Ft.start(se), he = Ft.end(se);
              if (Jt <= qt && qt < he) return !0;
            }
            return !1;
          } }, Ft = (0, S.A)(Vt).create(), rt;
        }
        e.__dashjs_factory_name = "RangeController";
        var n = u.A.getClassFactory(e);
        function d() {
          return { serialise: function gt(rt) {
            let Ft, ne, Vt = [], Xt = [];
            for (Ft in rt) if (rt.hasOwnProperty(Ft) && Ft.indexOf("_") !== 0) {
              if (ne = rt[Ft], ne == null && (ne = ""), Array.isArray(ne)) {
                if (!ne.length) continue;
                Xt = [], ne.forEach(function(qt) {
                  let Gt = Object.prototype.toString.call(qt).slice(8, -1) !== "Object";
                  Xt.push(Gt ? qt : gt(qt));
                }), ne = Xt.map(encodeURIComponent).join(",");
              } else typeof ne == "string" ? ne = encodeURIComponent(ne) : ne instanceof Date ? ne = ne.toISOString() : typeof ne == "number" && (ne = Math.round(ne));
              Vt.push(Ft + "=" + ne);
            }
            return Vt.join("&");
          } };
        }
        d.__dashjs_factory_name = "MetricSerialiser";
        var _ = u.A.getSingletonFactory(d);
        function p() {
          let gt, rt, Ft, ne = window.crypto || window.msCrypto, Vt = Uint32Array, Xt = Math.pow(2, 8 * Vt.BYTES_PER_ELEMENT) - 1;
          function qt() {
            ne && (gt || (gt = new Vt(10)), ne.getRandomValues(gt), rt = 0);
          }
          return Ft = { random: function(Gt, se) {
            let Jt;
            return Gt || (Gt = 0), se || (se = 1), ne ? (rt === gt.length && qt(), Jt = gt[rt] / Xt, rt += 1) : Jt = Math.random(), Jt * (se - Gt) + Gt;
          } }, qt(), Ft;
        }
        p.__dashjs_factory_name = "RNG";
        var P = u.A.getSingletonFactory(p), $ = b(1926);
        function ot(gt) {
          let rt;
          gt = gt || {};
          let Ft, ne, Vt, Xt, qt, Gt, se, Jt = this.context, he = [];
          const an = gt.metricsConstants;
          function Fe() {
            Xt = !1, qt = !1, Gt = null, se = null;
          }
          return rt = { report: function(ke, ce) {
            Array.isArray(ce) || (ce = [ce]), qt && se.isEnabled() && ce.forEach(function(je) {
              let ii = Ft.serialise(je);
              ke !== an.DVB_ERRORS && (ii = `metricname=${ke}&${ii}`), ii = `${Gt}?${ii}`, function(Wn, Ai, Gn) {
                let Di = new XMLHttpRequest();
                Di.withCredentials = ne.getXHRWithCredentialsForType(an.HTTP_REQUEST_DVB_REPORTING_TYPE);
                const Ae = function() {
                  let Ke = he.indexOf(Di);
                  Ke !== -1 && (he.splice(Ke, 1), !(Di.status >= 200 && Di.status < 300) && Gn && Gn());
                };
                he.push(Di);
                try {
                  Di.open("GET", Wn), Di.onloadend = Ae, Di.onerror = Ae, Di.send();
                } catch {
                  Di.onerror();
                }
              }(ii, 0, function() {
                qt = !1;
              });
            });
          }, initialize: function(ke, ce) {
            let je;
            if (se = ce, Gt = ke.dvbReportingUrl, !Gt) throw new Error("required parameter missing (dvb:reportingUrl)");
            Xt || (je = ke.dvbProbability, je && (je === 1e3 || je / 1e3 >= Vt.random()) && (qt = !0), Xt = !0);
          }, reset: function() {
            Fe();
          } }, Ft = _(Jt).getInstance(), Vt = P(Jt).getInstance(), ne = (0, $.A)(Jt).getInstance(), Fe(), rt;
        }
        ot.__dashjs_factory_name = "DVBReporting";
        var dt = u.A.getClassFactory(ot);
        function xt(gt) {
          gt = gt || {};
          const rt = { "urn:dvb:dash:reporting:2014": dt }, Ft = this.context;
          let ne;
          const Vt = gt.debug ? gt.debug.getLogger(ne) : {}, Xt = gt.metricsConstants, qt = gt.mediaPlayerModel || {};
          return ne = { create: function(Gt, se) {
            let Jt;
            try {
              Jt = rt[Gt.schemeIdUri](Ft).create({ metricsConstants: Xt, mediaPlayerModel: qt }), Jt.initialize(Gt, se);
            } catch (he) {
              Jt = null, Vt.error(`ReportingFactory: could not create Reporting with schemeIdUri ${Gt.schemeIdUri} (${he.message})`);
            }
            return Jt;
          }, register: function(Gt, se) {
            rt[Gt] = se;
          }, unregister: function(Gt) {
            delete rt[Gt];
          } }, ne;
        }
        xt.__dashjs_factory_name = "ReportingFactory";
        var Nt = u.A.getSingletonFactory(xt);
        function jt(gt) {
          let rt, Ft = [];
          const ne = Nt(this.context).getInstance(gt);
          return rt = { initialize: function(Vt, Xt) {
            Vt.some((qt) => {
              let Gt = ne.create(qt, Xt);
              if (Gt) return Ft.push(Gt), !0;
            });
          }, reset: function() {
            Ft.forEach((Vt) => Vt.reset()), Ft = [];
          }, report: function(Vt, Xt) {
            Ft.forEach((qt) => qt.report(Vt, Xt));
          } }, rt;
        }
        jt.__dashjs_factory_name = "ReportingController";
        var q = u.A.getClassFactory(jt);
        function I() {
          return { reconstructFullMetricName: function(gt, rt, Ft) {
            let ne = gt;
            return rt && (ne += "(" + rt, Ft && Ft.length && (ne += "," + Ft), ne += ")"), ne;
          }, validateN: function(gt) {
            if (!gt) throw new Error("missing n");
            if (isNaN(gt)) throw new Error("n is NaN");
            if (gt < 0) throw new Error("n must be positive");
            return gt;
          } };
        }
        I.__dashjs_factory_name = "HandlerHelpers";
        var pt = u.A.getSingletonFactory(I);
        function It(gt) {
          let rt, Ft, ne, Vt, Xt, qt;
          gt = gt || {};
          let Gt = this.context, se = pt(Gt).getInstance(), Jt = [];
          const he = gt.metricsConstants;
          function an() {
            let Fe = function() {
              try {
                return Object.keys(Jt).map((ke) => Jt[ke]).reduce((ke, ce) => ke.level < ce.level ? ke : ce);
              } catch {
                return;
              }
            }();
            Fe && qt !== Fe.t && (qt = Fe.t, Ft.report(Vt, Fe));
          }
          return rt = { initialize: function(Fe, ke, ce) {
            ke && (ne = se.validateN(ce), Ft = ke, Vt = se.reconstructFullMetricName(Fe, ce), Xt = setInterval(an, ne));
          }, reset: function() {
            clearInterval(Xt), Xt = null, ne = 0, Ft = null, qt = null;
          }, handleNewMetric: function(Fe, ke, ce) {
            Fe === he.BUFFER_LEVEL && (Jt[ce] = ke);
          } }, rt;
        }
        It.__dashjs_factory_name = "BufferLevelHandler";
        var et = u.A.getClassFactory(It), Dt = u.A.getClassFactory(function(gt) {
          let rt, Ft, ne = (gt = gt || {}).eventBus;
          const Vt = gt.metricsConstants;
          function Xt() {
            ne.off(o.A.METRICS_INITIALISATION_COMPLETE, Xt, this), ne.trigger(o.A.BECAME_REPORTING_PLAYER);
          }
          return rt = { initialize: function(qt, Gt) {
            Gt && (Ft = Gt, ne.on(o.A.METRICS_INITIALISATION_COMPLETE, Xt, this));
          }, reset: function() {
            Ft = null;
          }, handleNewMetric: function(qt, Gt) {
            qt === Vt.DVB_ERRORS && Ft && Ft.report(qt, Gt);
          } }, rt;
        });
        function ae(gt) {
          let rt, Ft, ne, Vt, Xt, qt;
          gt = gt || {};
          let Gt = [], se = pt(this.context).getInstance();
          const Jt = gt.metricsConstants;
          function he() {
            var an = Gt;
            an.length && Ft && Ft.report(Xt, an), Gt = [];
          }
          return rt = { initialize: function(an, Fe, ke, ce) {
            Fe && (ne = se.validateN(ke), Ft = Fe, ce && ce.length && (Vt = ce), Xt = se.reconstructFullMetricName(an, ke, ce), qt = setInterval(he, ne));
          }, reset: function() {
            clearInterval(qt), qt = null, ne = null, Vt = null, Gt = [], Ft = null;
          }, handleNewMetric: function(an, Fe) {
            an === Jt.HTTP_REQUEST && (Vt && Vt !== Fe.type || Gt.push(Fe));
          } }, rt;
        }
        ae.__dashjs_factory_name = "HttpListHandler";
        var St = u.A.getClassFactory(ae);
        function qe() {
          let gt, rt, Ft;
          return gt = { initialize: function(ne, Vt) {
            rt = ne, Ft = Vt;
          }, reset: function() {
            Ft = null, rt = void 0;
          }, handleNewMetric: function(ne, Vt) {
            ne === rt && Ft && Ft.report(rt, Vt);
          } }, gt;
        }
        qe.__dashjs_factory_name = "GenericMetricHandler";
        var zt = u.A.getClassFactory(qe);
        function Ct(gt) {
          let rt;
          const Ft = (gt = gt || {}).debug ? gt.debug.getLogger(rt) : {};
          let ne = /([a-zA-Z]*)(\(([0-9]*)(\,\s*([a-zA-Z]*))?\))?/;
          const Vt = this.context;
          let Xt = { BufferLevel: et, DVBErrors: Dt, HttpList: St, PlayList: zt, RepSwitchList: zt, TcpList: zt };
          return rt = { create: function(qt, Gt) {
            var se, Jt = qt.match(ne);
            if (Jt) {
              try {
                (se = Xt[Jt[1]](Vt).create({ eventBus: gt.eventBus, metricsConstants: gt.metricsConstants })).initialize(Jt[1], Gt, Jt[3], Jt[5]);
              } catch (he) {
                se = null, Ft.error(`MetricsHandlerFactory: Could not create handler for type ${Jt[1]} with args ${Jt[3]}, ${Jt[5]} (${he.message})`);
              }
              return se;
            }
          }, register: function(qt, Gt) {
            Xt[qt] = Gt;
          }, unregister: function(qt) {
            delete Xt[qt];
          } }, rt;
        }
        Ct.__dashjs_factory_name = "MetricsHandlerFactory";
        var de = u.A.getSingletonFactory(Ct);
        function ze(gt) {
          gt = gt || {};
          let rt, Ft = [];
          const ne = this.context, Vt = gt.eventBus, Xt = gt.events;
          let qt = de(ne).getInstance({ debug: gt.debug, eventBus: gt.eventBus, metricsConstants: gt.metricsConstants });
          function Gt(se) {
            Ft.forEach((Jt) => {
              Jt.handleNewMetric(se.metric, se.value, se.mediaType);
            });
          }
          return rt = { initialize: function(se, Jt) {
            se.split(",").forEach((he, an, Fe) => {
              let ke;
              if (he.indexOf("(") !== -1 && he.indexOf(")") === -1) {
                let ce = Fe[an + 1];
                ce && ce.indexOf("(") === -1 && ce.indexOf(")") !== -1 && (he += "," + ce, delete Fe[an + 1]);
              }
              ke = qt.create(he, Jt), ke && Ft.push(ke);
            }), Vt.on(Xt.METRIC_ADDED, Gt, rt), Vt.on(Xt.METRIC_UPDATED, Gt, rt);
          }, reset: function() {
            Vt.off(Xt.METRIC_ADDED, Gt, rt), Vt.off(Xt.METRIC_UPDATED, Gt, rt), Ft.forEach((se) => se.reset()), Ft = [];
          } }, rt;
        }
        ze.__dashjs_factory_name = "MetricsHandlersController";
        var le = u.A.getClassFactory(ze);
        function Ze(gt) {
          let rt, Ft, ne, Vt;
          gt = gt || {};
          let Xt = this.context;
          function qt() {
            rt && rt.reset(), Ft && Ft.reset(), ne && ne.reset();
          }
          return Vt = { initialize: function(Gt) {
            try {
              ne = n(Xt).create({ mediaElement: gt.mediaElement }), ne.initialize(Gt.Range), Ft = q(Xt).create({ debug: gt.debug, metricsConstants: gt.metricsConstants, mediaPlayerModel: gt.mediaPlayerModel }), Ft.initialize(Gt.Reporting, ne), rt = le(Xt).create({ debug: gt.debug, eventBus: gt.eventBus, metricsConstants: gt.metricsConstants, events: gt.events }), rt.initialize(Gt.metrics, Ft);
            } catch (se) {
              throw qt(), se;
            }
          }, reset: qt }, Vt;
        }
        Ze.__dashjs_factory_name = "MetricsController";
        var me = u.A.getClassFactory(Ze), bn = class {
          constructor() {
            this.metrics = "", this.Range = [], this.Reporting = [];
          }
        }, pn = class {
          constructor() {
            this.starttime = 0, this.duration = 1 / 0, this._useWallClockTime = !1;
          }
        }, wn = class {
          constructor() {
            this.schemeIdUri = "", this.value = "", this.dvbReportingUrl = "", this.dvbProbability = 1e3;
          }
        };
        function Yt(gt) {
          let rt, Ft = (gt = gt || {}).adapter;
          const ne = gt.constants;
          return rt = { getMetrics: function(Vt) {
            let Xt = [];
            return Vt && Vt.Metrics && Vt.Metrics.forEach((qt) => {
              var Gt = new bn(), se = Ft.getIsDynamic(Vt);
              qt.hasOwnProperty("metrics") && (Gt.metrics = qt.metrics, qt.Range && qt.Range.forEach((Jt) => {
                var he = new pn();
                he.starttime = function(an, Fe, ke) {
                  let ce, je, ii = 0;
                  return Fe ? ii = Ft.getAvailabilityStartTime(an) / 1e3 : (ce = Ft.getRegularPeriods(an), ce.length && (ii = ce[0].start)), je = ii, ke && ke.hasOwnProperty(ne.START_TIME) && (je += ke.starttime), je;
                }(Vt, se, Jt), Jt.hasOwnProperty("duration") ? he.duration = Jt.duration : he.duration = Ft.getDuration(Vt), he._useWallClockTime = se, Gt.Range.push(he);
              }), qt.Reporting && (qt.Reporting.forEach((Jt) => {
                var he = new wn();
                Jt.hasOwnProperty(ne.SCHEME_ID_URI) && (he.schemeIdUri = Jt.schemeIdUri, Jt.hasOwnProperty("value") && (he.value = Jt.value), Jt.hasOwnProperty(ne.DVB_REPORTING_URL) && (he.dvbReportingUrl = Jt[ne.DVB_REPORTING_URL]), Jt.hasOwnProperty(ne.DVB_PROBABILITY) && (he.dvbProbability = Jt[ne.DVB_PROBABILITY]), Gt.Reporting.push(he));
              }), Xt.push(Gt)));
            }), Xt;
          } }, rt;
        }
        Yt.__dashjs_factory_name = "ManifestParsing";
        var Ht = u.A.getSingletonFactory(Yt);
        function Me(gt) {
          let rt;
          gt = gt || {};
          let Ft = {}, ne = this.context, Vt = gt.eventBus;
          const Xt = gt.events;
          function qt(se) {
            if (se.error) return;
            let Jt = Object.keys(Ft);
            Ht(ne).getInstance({ adapter: gt.adapter, constants: gt.constants }).getMetrics(se.manifest).forEach((he) => {
              const an = JSON.stringify(he);
              if (Ft.hasOwnProperty(an)) Jt.splice(an, 1);
              else try {
                let Fe = me(ne).create(gt);
                Fe.initialize(he), Ft[an] = Fe;
              } catch {
              }
            }), Jt.forEach((he) => {
              Ft[he].reset(), delete Ft[he];
            }), Vt.trigger(o.A.METRICS_INITIALISATION_COMPLETE);
          }
          function Gt() {
            Object.keys(Ft).forEach((se) => {
              Ft[se].reset();
            }), Ft = {};
          }
          return rt = { reset: function() {
            Vt.off(Xt.MANIFEST_UPDATED, qt, rt), Vt.off(Xt.STREAM_TEARDOWN_COMPLETE, Gt, rt);
          } }, Vt.on(Xt.MANIFEST_UPDATED, qt, rt), Vt.on(Xt.STREAM_TEARDOWN_COMPLETE, Gt, rt), rt;
        }
        Me.__dashjs_factory_name = "MetricsCollectionController";
        var X = u.A.getClassFactory(Me);
        function Q() {
          let gt, rt, Ft = this.context;
          return gt = { createMetricsReporting: function(ne) {
            return rt = m(Ft).getInstance({ eventBus: ne.eventBus, dashMetrics: ne.dashMetrics, metricsConstants: ne.metricsConstants, events: ne.events }), rt.initialize(), X(Ft).create(ne);
          }, getReportingFactory: function() {
            return Nt(Ft).getInstance();
          }, getMetricsHandlerFactory: function() {
            return de(Ft).getInstance();
          } }, gt;
        }
        Q.__dashjs_factory_name = "MetricsReporting";
        const C = dashjs.FactoryMaker.getClassFactory(Q);
        C.events = o.A, dashjs.FactoryMaker.updateClassFactory(Q.__dashjs_factory_name, C);
        var U = C;
      }, 913: function(L, h, b) {
        var A = b(7252);
        class l extends A.A {
          constructor() {
            super(), this.METRICS_INITIALISATION_COMPLETE = "internal_metricsReportingInitialized", this.BECAME_REPORTING_PLAYER = "internal_becameReportingPlayer", this.CMCD_DATA_GENERATED = "cmcdDataGenerated";
          }
        }
        let o = new l();
        h.A = o;
      }, 1926: function(L, h, b) {
        var A = b(5717), l = b(138), o = b(8261), u = b(656), g = b(5212);
        function m() {
          let S, e, n, d, _, p, P, $, ot, dt;
          const xt = this.context, Nt = (0, o.A)(xt).getInstance();
          function jt() {
            d = [], _ = [], p = [], P = [], $ = [], dt = [], ot = null, e = [];
          }
          function q(et, Dt) {
            let ae = -1;
            et.some((St, qe) => {
              if (St === Dt) return ae = qe, !0;
            }), ae < 0 || et.splice(ae, 1);
          }
          function I(et) {
            let Dt;
            for (Dt = 0; Dt < dt.length; Dt++) if (dt[Dt].rulename === et) return Dt;
            return -1;
          }
          function pt(et, Dt) {
            It(et, Dt);
            let ae = new A.A();
            ae.schemeIdUri = et, ae.value = Dt, e.push(ae);
          }
          function It(et, Dt) {
            (0, u.sq)(et, "string"), (0, u.sq)(Dt, "string"), e.forEach(function(ae, St) {
              ae.schemeIdUri === et && ae.value === Dt && e.splice(St, 1);
            });
          }
          return S = { addAbrCustomRule: function(et, Dt, ae) {
            if (typeof et != "string" || et !== g.A.RULES_TYPES.ABANDON_FRAGMENT_RULES && et !== g.A.RULES_TYPES.QUALITY_SWITCH_RULES || typeof Dt != "string") throw g.A.BAD_ARGUMENT_ERROR;
            let St = I(Dt);
            St === -1 ? dt.push({ type: et, rulename: Dt, rule: ae }) : (dt[St].type = et, dt[St].rule = ae);
          }, addRequestInterceptor: function(et) {
            d.push(et);
          }, addResponseInterceptor: function(et) {
            _.push(et);
          }, addUTCTimingSource: pt, clearDefaultUTCTimingSources: function() {
            e = [];
          }, getAbrCustomRules: function() {
            return dt;
          }, getCustomCapabilitiesFilters: function() {
            return $;
          }, getCustomInitialTrackSelectionFunction: function() {
            return ot;
          }, getLicenseRequestFilters: function() {
            return p;
          }, getLicenseResponseFilters: function() {
            return P;
          }, getRequestInterceptors: function() {
            return d;
          }, getResponseInterceptors: function() {
            return _;
          }, getUTCTimingSources: function() {
            return e;
          }, getXHRWithCredentialsForType: function(et) {
            const Dt = n[et];
            return Dt === void 0 ? n.default : Dt;
          }, registerCustomCapabilitiesFilter: function(et) {
            $.push(et);
          }, registerLicenseRequestFilter: function(et) {
            p.push(et);
          }, registerLicenseResponseFilter: function(et) {
            P.push(et);
          }, removeAbrCustomRule: function(et) {
            if (et) {
              let Dt = I(et);
              Dt !== -1 && dt.splice(Dt, 1);
            } else dt = [];
          }, removeAllAbrCustomRule: function() {
            dt = [];
          }, removeRequestInterceptor: function(et) {
            q(d, et);
          }, removeResponseInterceptor: function(et) {
            q(_, et);
          }, removeUTCTimingSource: It, reset: function() {
            jt();
          }, resetCustomInitialTrackSelectionFunction: function() {
            ot = null;
          }, restoreDefaultUTCTimingSources: function() {
            let et = Nt.get().streaming.utcSynchronization.defaultTimingSource;
            pt(et.scheme, et.value);
          }, setConfig: function() {
          }, setCustomInitialTrackSelectionFunction: function(et) {
            ot = et;
          }, setXHRWithCredentialsForType: function et(Dt, ae) {
            Dt ? n[Dt] = !!ae : Object.keys(n).forEach((St) => {
              et(St, ae);
            });
          }, unregisterCustomCapabilitiesFilter: function(et) {
            q($, et);
          }, unregisterLicenseRequestFilter: function(et) {
            q(p, et);
          }, unregisterLicenseResponseFilter: function(et) {
            q(P, et);
          } }, n = { default: !1 }, jt(), S;
        }
        m.__dashjs_factory_name = "CustomParametersModel", h.A = l.A.getSingletonFactory(m);
      }, 3888: function(L, h, b) {
        b.d(h, { default: function() {
          return Di;
        } });
        var A = b(8854), l = b(2861);
        const o = { prefixes: ["clearkey", "dashif", "ck"] };
        class u {
          static findMp4ProtectionElement(Ke) {
            let Re = null;
            for (let pe = 0; pe < Ke.length; ++pe) {
              let Ce = Ke[pe];
              Ce.schemeIdUri && Ce.schemeIdUri.toLowerCase() === A.A.MP4_PROTECTION_SCHEME && Ce.value && (Ce.value.toLowerCase() === l.A.ENCRYPTION_SCHEME_CENC || Ce.value.toLowerCase() === l.A.ENCRYPTION_SCHEME_CBCS) && (Re = Ce);
            }
            return Re;
          }
          static getPSSHData(Ke) {
            let Re = 8, pe = new DataView(Ke), Ce = pe.getUint8(Re);
            return Re += 20, Ce > 0 && (Re += 4 + 16 * pe.getUint32(Re)), Re += 4, Ke.slice(Re);
          }
          static getPSSHForKeySystem(Ke, Re) {
            let pe = u.parsePSSHList(Re);
            return Ke && pe.hasOwnProperty(Ke.uuid.toLowerCase()) ? pe[Ke.uuid.toLowerCase()] : null;
          }
          static parseInitDataFromContentProtection(Ke, Re) {
            return "pssh" in Ke && Ke.pssh ? (Ke.pssh.__text = Ke.pssh.__text.replace(/\r?\n|\r/g, "").replace(/\s+/g, ""), Re.decodeArray(Ke.pssh.__text).buffer) : null;
          }
          static parsePSSHList(Ke) {
            if (Ke == null) return [];
            let Re = new DataView(Ke.buffer || Ke), pe = {}, Ce = 0;
            for (; ; ) {
              let He, Je, tn, xe, Se, $e, kn = Ce;
              if (Ce >= Re.buffer.byteLength) break;
              if (He = Re.getUint32(Ce), Je = Ce + He, Ce += 4, Re.getUint32(Ce) === 1886614376) if (Ce += 4, tn = Re.getUint8(Ce), tn === 0 || tn === 1) {
                for (Ce++, Ce += 3, xe = "", Se = 0; Se < 4; Se++) $e = Re.getUint8(Ce + Se).toString(16), xe += $e.length === 1 ? "0" + $e : $e;
                for (Ce += 4, xe += "-", Se = 0; Se < 2; Se++) $e = Re.getUint8(Ce + Se).toString(16), xe += $e.length === 1 ? "0" + $e : $e;
                for (Ce += 2, xe += "-", Se = 0; Se < 2; Se++) $e = Re.getUint8(Ce + Se).toString(16), xe += $e.length === 1 ? "0" + $e : $e;
                for (Ce += 2, xe += "-", Se = 0; Se < 2; Se++) $e = Re.getUint8(Ce + Se).toString(16), xe += $e.length === 1 ? "0" + $e : $e;
                for (Ce += 2, xe += "-", Se = 0; Se < 6; Se++) $e = Re.getUint8(Ce + Se).toString(16), xe += $e.length === 1 ? "0" + $e : $e;
                Ce += 6, xe = xe.toLowerCase(), Ce += 4, pe[xe] = Re.buffer.slice(kn, Je), Ce = Je;
              } else Ce = Je;
              else Ce = Je;
            }
            return pe;
          }
          static getLicenseServerUrlFromMediaInfo(Ke, Re) {
            try {
              if (!Ke || Ke.length === 0) return null;
              let pe = 0, Ce = null;
              for (; pe < Ke.length && !Ce; ) {
                const He = Ke[pe];
                if (He && He.contentProtection && He.contentProtection.length > 0) {
                  const Je = He.contentProtection.filter((tn) => tn.schemeIdUri && tn.schemeIdUri === Re);
                  if (Je && Je.length > 0) {
                    let tn = 0;
                    for (; tn < Je.length && !Ce; ) {
                      const xe = Je[tn];
                      xe.laUrl && xe.laUrl.__prefix && o.prefixes.includes(xe.laUrl.__prefix) && xe.laUrl.__text && (Ce = xe.laUrl.__text), tn += 1;
                    }
                  }
                }
                pe += 1;
              }
              return Ce;
            } catch {
              return null;
            }
          }
          static hexKidToBufferSource(Ke) {
            const Re = Ke.replace(/-/g, "");
            return new Uint8Array(Re.match(/[\da-f]{2}/gi).map(function(pe) {
              return parseInt(pe, 16);
            })).buffer;
          }
        }
        var g = u, m = class {
          constructor(Ae, Ke) {
            this.contentType = Ae, this.robustness = Ke;
          }
        }, S = class {
          constructor(Ae, Ke, Re, pe, Ce, He) {
            this.initDataTypes = He && He.length > 0 ? He : [l.A.INITIALIZATION_DATA_TYPE_CENC], Ae && Ae.length && (this.audioCapabilities = Ae), Ke && Ke.length && (this.videoCapabilities = Ke), this.distinctiveIdentifier = Re, this.persistentState = pe, this.sessionTypes = Ce;
          }
        }, e = b(1923), n = b(1944), d = class {
          constructor(Ae, Ke, Re, pe, Ce, He, Je, tn) {
            this.url = Ae, this.method = Ke, this.responseType = Re, this.headers = pe, this.withCredentials = Ce, this.messageType = He, this.sessionId = Je, this.data = tn;
          }
        }, _ = class {
          constructor(Ae, Ke, Re) {
            this.url = Ae, this.headers = Ke, this.data = Re;
          }
        }, p = b(7568), P = b(7263), $ = b(5212), ot = b(138);
        function dt(Ae) {
          const Ke = (Ae = Ae || {}).BASE64, Re = Ae.cmcdModel, pe = Ae.constants, Ce = Ae.customParametersModel, He = Ae.debug, Je = Ae.eventBus, tn = Ae.events, xe = Ae.protectionKeyController, Se = Ae.settings;
          let $e, kn, Ge, En, An, Dn, In, Kn, vn, ve, ue, Be, dn = Ae.protectionModel, Yn = [];
          function $n() {
            if (!(Je && Je.hasOwnProperty("on") && xe && xe.hasOwnProperty("getSupportedKeySystemMetadataFromContentProtection"))) throw new Error("Missing config parameter(s)");
          }
          function ui(Xe, fn) {
            ue || En ? ue && Ii() : function(Fn, Xn) {
              if (En) return;
              var di;
              En = !0;
              const xi = function(Zn) {
                const zn = [];
                for (let Qn = 0; Qn < Zn.length; Qn++) {
                  const mi = Ei(Zn[Qn]);
                  zn.push({ ks: Zn[Qn].ks, configs: [mi], protData: Zn[Qn].protData });
                }
                return zn;
              }(Fn = (di = Fn).sort((Zn, zn) => ($e && $e[Zn.ks.systemString] && $e[Zn.ks.systemString].priority >= 0 ? $e[Zn.ks.systemString].priority : di.length) - ($e && $e[zn.ks.systemString] && $e[zn.ks.systemString].priority >= 0 ? $e[zn.ks.systemString].priority : di.length)));
              let oi;
              dn.requestKeySystemAccess(xi).then((Zn) => (oi = Zn.data, function(zn) {
                let Qn = zn && zn.selectedSystemString ? zn.selectedSystemString : zn.keySystem.systemString;
                return In.info("DRM: KeySystem Access Granted for system string (" + Qn + ")!  Selecting key system..."), dn.selectKeySystem(zn);
              }(oi))).then((Zn) => {
                (function(zn, Qn) {
                  ue = zn, En = !1, Je.trigger(tn.KEY_SYSTEM_SELECTED, { data: Qn });
                  const mi = Oi(ue);
                  mi && mi.serverCertificate && mi.serverCertificate.length > 0 && dn.setServerCertificate(Ke.decodeArray(mi.serverCertificate).buffer), Ii();
                })(Zn, oi);
              }).catch((Zn) => {
                (function(zn, Qn) {
                  ue = null, En = !1, Qn || Je.trigger(tn.KEY_SYSTEM_SELECTED, { data: null, error: new n.A(e.A.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE, e.A.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE + "Error selecting key system! -- " + zn.error) });
                })(Zn, Xn);
              });
            }(Xe, fn);
          }
          function Ii() {
            let Xe;
            for (let Fn = 0; Fn < vn.length; Fn++) for (Xe = 0; Xe < vn[Fn].length; Xe++) if (ue === vn[Fn][Xe].ks) {
              fn = vn[Fn][Xe], xe.isClearKey(ue) && function(Xn) {
                if (Xn.protData && Xn.protData.hasOwnProperty("clearkeys") && Object.keys(Xn.protData.clearkeys).length !== 0) {
                  const di = { kids: Object.keys(Xn.protData.clearkeys) };
                  Xn.initData = new TextEncoder().encode(JSON.stringify(di));
                }
              }(fn), fn.sessionId ? ai(fn) : fn.initData !== null && Mi(fn);
              break;
            }
            var fn;
            vn = [];
          }
          function Ei(Xe) {
            const fn = Xe.protData, Fn = [], Xn = [], di = fn && fn.initDataTypes && fn.initDataTypes.length > 0 ? fn.initDataTypes : [l.A.INITIALIZATION_DATA_TYPE_CENC], xi = fn && fn.audioRobustness && fn.audioRobustness.length > 0 ? fn.audioRobustness : ve, oi = fn && fn.videoRobustness && fn.videoRobustness.length > 0 ? fn.videoRobustness : ve, Zn = Xe.sessionType, zn = fn && fn.distinctiveIdentifier ? fn.distinctiveIdentifier : "optional", Qn = fn && fn.persistentState ? fn.persistentState : Zn === "temporary" ? "optional" : "required";
            return Kn.forEach((mi) => {
              mi.type === pe.AUDIO ? Fn.push(new m(mi.codec, xi)) : mi.type === pe.VIDEO && Xn.push(new m(mi.codec, oi));
            }), new S(Fn, Xn, zn, Qn, [Zn], di);
          }
          function ai(Xe) {
            $n(), dn.loadKeySession(Xe);
          }
          function Mi(Xe) {
            if (Xe && function(Fn) {
              if (!Fn) return !1;
              try {
                const Xn = dn.getSessionTokens();
                for (let di = 0; di < Xn.length; di++) if (Xn[di].getKeyId() === Fn) return !0;
                return !1;
              } catch {
                return !1;
              }
            }(Xe.keyId)) return;
            const fn = g.getPSSHForKeySystem(ue, Xe ? Xe.initData : null);
            if (fn) {
              if (Bi(fn)) return;
              try {
                Xe.initData = fn, dn.createKeySession(Xe);
              } catch (Fn) {
                Je.trigger(tn.KEY_SESSION_CREATED, { data: null, error: new n.A(e.A.KEY_SESSION_CREATED_ERROR_CODE, e.A.KEY_SESSION_CREATED_ERROR_MESSAGE + Fn.message) });
              }
            } else Xe && Xe.initData ? dn.createKeySession(Xe) : Je.trigger(tn.KEY_SESSION_CREATED, { data: null, error: new n.A(e.A.KEY_SESSION_CREATED_ERROR_CODE, e.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Selected key system is " + (ue ? ue.systemString : null) + ".  needkey/encrypted event contains no initData corresponding to that key system!") });
          }
          function Oi(Xe) {
            if (Xe) {
              const fn = Xe.systemString;
              if ($e) return fn in $e ? $e[fn] : null;
            }
            return null;
          }
          function Bi(Xe) {
            if (!Xe) return !1;
            try {
              const fn = dn.getAllInitData();
              for (let Fn = 0; Fn < fn.length; Fn++) if (xe.initDataEquals(Xe, fn[Fn])) return In.debug("DRM: Ignoring initData because we have already seen it!"), !0;
              return !1;
            } catch {
              return !1;
            }
          }
          function dr(Xe) {
            $n(), Xe ? (dn.setMediaElement(Xe), Je.on(tn.NEED_KEY, ia, kn)) : Xe === null && (dn.setMediaElement(Xe), Je.off(tn.NEED_KEY, ia, kn));
          }
          function Ri(Xe) {
            In.debug("DRM: onKeyMessage");
            const fn = Xe.data;
            Je.trigger(tn.KEY_MESSAGE, { data: fn });
            const Fn = fn.messageType ? fn.messageType : l.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST, Xn = fn.message, di = fn.sessionToken, xi = Oi(ue), oi = xe.getLicenseServerModelInstance(ue, xi, Fn), Zn = { sessionToken: di, messageType: Fn };
            if (Xn && Xn.byteLength !== 0) {
              if (!oi) return In.debug("DRM: License server request not required for this message (type = " + Xe.data.messageType + ").  Session ID = " + di.getSessionId()), void Ci(Zn);
              if (xe.isClearKey(ue)) {
                const zn = xe.processClearKeyLicenseRequest(ue, xi, Xn);
                if (zn && zn.keyPairs && zn.keyPairs.length > 0) return In.debug("DRM: ClearKey license request handled by application!"), Ci(Zn), void dn.updateKeySession(di, zn);
              }
              (function(zn, Qn, mi) {
                const cr = zn.sessionToken, Yi = zn.messageType ? zn.messageType : l.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST, Hi = { sessionToken: cr, messageType: Yi }, Zi = ue ? ue.systemString : null;
                let qi = function(hi, hr, vr, fr, vi) {
                  let Xi = null;
                  const Rr = fr.message;
                  if (hi && hi.serverURL) {
                    const Qi = hi.serverURL;
                    typeof Qi == "string" && Qi !== "" ? Xi = Qi : typeof Qi == "object" && Qi.hasOwnProperty(hr) && (Xi = Qi[hr]);
                  } else if (hi && hi.laURL && hi.laURL !== "") Xi = hi.laURL;
                  else if (Xi = g.getLicenseServerUrlFromMediaInfo(Kn, ue.schemeIdURI), !Xi && !xe.isClearKey(ue)) {
                    const Qi = g.getPSSHData(vr.initData);
                    Xi = ue.getLicenseServerURLFromInitData(Qi), Xi || (Xi = fr.laURL);
                  }
                  return Xi = vi.getServerURLFromMessage(Xi, Rr, hr), Xi;
                }(mi, Yi, cr, zn, Qn);
                if (!qi) return void Ci(Hi, new n.A(e.A.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE));
                const Fi = {};
                let ra = !1;
                mi && ji(Fi, mi.httpRequestHeaders);
                const Gr = zn.message;
                ji(Fi, ue.getRequestHeadersFromMessage(Gr)), Object.keys(Fi).forEach((hi) => {
                  hi.toLowerCase() === "authorization" && (ra = !0);
                }), mi && typeof mi.withCredentials == "boolean" && (ra = mi.withCredentials);
                const ss = function(hi) {
                  if (dn) if (hi.status >= 200 && hi.status <= 299) {
                    const hr = P.A.parseHttpHeaders(hi.getAllResponseHeaders ? hi.getAllResponseHeaders() : null);
                    let vr = new _(hi.responseURL, hr, hi.response);
                    Ta(Ce.getLicenseResponseFilters(), vr).then(() => {
                      const fr = Qn.getLicenseMessage(vr.data, Zi, Yi);
                      fr !== null ? (Ci(Hi), dn.updateKeySession(cr, fr)) : va(hi, Hi, Zi, Yi, Qn);
                    });
                  } else va(hi, Hi, Zi, Yi, Qn);
                }, sr = function(hi) {
                  Ci(Hi, new n.A(e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + Zi + ' update, XHR aborted. status is "' + hi.statusText + '" (' + hi.status + "), readyState is " + hi.readyState));
                }, Vi = function(hi) {
                  Ci(Hi, new n.A(e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + Zi + ' update, XHR error. status is "' + hi.statusText + '" (' + hi.status + "), readyState is " + hi.readyState));
                }, Dr = ue.getLicenseRequestFromMessage(Gr), Fa = Qn.getHTTPMethod(Yi), tr = Qn.getResponseType(Zi, Yi), aa = mi && !isNaN(mi.httpTimeout) ? mi.httpTimeout : 8e3, Aa = cr.getSessionId() || null;
                let Ir = new d(qi, Fa, tr, Fi, ra, Yi, Aa, Dr);
                const or = isNaN(Se.get().streaming.retryAttempts[p.G.LICENSE]) ? 3 : Se.get().streaming.retryAttempts[p.G.LICENSE];
                Ta(Ce.getLicenseRequestFilters(), Ir).then(() => {
                  $i(Ir, or, aa, ss, sr, Vi);
                });
              })(fn, oi, xi);
            } else Ci(Zn, new n.A(e.A.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE));
          }
          function Ci(Xe) {
            let fn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
            Je.trigger(tn.LICENSE_REQUEST_COMPLETE, { data: Xe, error: fn });
          }
          function $i(Xe, fn, Fn, Xn, di, xi) {
            const oi = new XMLHttpRequest(), Zn = Re.getCmcdParametersFromManifest();
            if (Re.isCmcdEnabled() && (Zn.mode ? Zn.mode : Se.get().streaming.cmcd.mode) === $.A.CMCD_MODE_QUERY) {
              const Qn = Re.getQueryParameter({ url: Xe.url, type: p.G.LICENSE });
              Qn && (Xe.url = P.A.addAdditionalQueryParameterToUrl(Xe.url, [Qn]));
            }
            oi.open(Xe.method, Xe.url, !0), oi.responseType = Xe.responseType, oi.withCredentials = Xe.withCredentials, Fn > 0 && (oi.timeout = Fn);
            for (const Qn in Xe.headers) oi.setRequestHeader(Qn, Xe.headers[Qn]);
            if (Re.isCmcdEnabled() && (Zn.mode ? Zn.mode : Se.get().streaming.cmcd.mode) === $.A.CMCD_MODE_HEADER) {
              const Qn = Re.getHeaderParameters({ url: Xe.url, type: p.G.LICENSE });
              if (Qn) for (const mi in Qn) {
                let cr = Qn[mi];
                cr && oi.setRequestHeader(mi, cr);
              }
            }
            const zn = function() {
              fn--;
              const Qn = isNaN(Se.get().streaming.retryIntervals[p.G.LICENSE]) ? 1e3 : Se.get().streaming.retryIntervals[p.G.LICENSE];
              An = setTimeout(function() {
                $i(Xe, fn, Fn, Xn, di, xi);
              }, Qn);
            };
            oi.onload = function() {
              Dn = null, this.status >= 200 && this.status <= 299 || fn <= 0 ? Xn(this) : (In.warn("License request failed (" + this.status + "). Retrying it... Pending retries: " + fn), zn());
            }, oi.ontimeout = oi.onerror = function() {
              Dn = null, fn <= 0 ? xi(this) : (In.warn("License request network request failed . Retrying it... Pending retries: " + fn), zn());
            }, oi.onabort = function() {
              di(this);
            }, Je.trigger(tn.LICENSE_REQUEST_SENDING, { url: Xe.url, headers: Xe.headers, payload: Xe.data, sessionId: Xe.sessionId }), Dn = oi, oi.send(Xe.data);
          }
          function qr() {
            Dn && (Dn.onloadend = Dn.onerror = Dn.onprogress = void 0, Dn.abort(), Dn = null), An && (clearTimeout(An), An = null);
          }
          function ji(Xe, fn) {
            if (fn) for (const Fn in fn) Xe[Fn] = fn[Fn];
          }
          function va(Xe, fn, Fn, Xn, di) {
            let xi = "NONE", oi = null;
            Xe.response && (xi = di.getErrorResponse(Xe.response, Fn, Xn), oi = { serverResponse: Xe.response || null, responseCode: Xe.status || null, responseText: Xe.statusText || null }), Ci(fn, new n.A(e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE + Fn + ' update, XHR complete. status is "' + Xe.statusText + '" (' + Xe.status + "), readyState is " + Xe.readyState + ".  Response is " + xi, oi));
          }
          function Ta(Xe, fn) {
            return Xe ? Xe.reduce((Fn, Xn) => Fn.then(() => Xn(fn)), Promise.resolve()) : Promise.resolve();
          }
          function ia(Xe, fn) {
            if (!Se.get().streaming.protection.ignoreEmeEncryptedEvent) {
              if (In.debug("DRM: onNeedKey"), Xe.key.initDataType !== l.A.INITIALIZATION_DATA_TYPE_CENC) return void In.warn("DRM:  Only 'cenc' initData is supported!  Ignoring initData of type: " + Xe.key.initDataType);
              if (Kn.length === 0 && (In.warn("DRM: onNeedKey called before initializeForMedia, wait until initialized"), (fn = fn === void 0 ? 1 : fn + 1) < 5)) return void Yn.push(setTimeout(() => {
                ia(Xe, fn);
              }, 500));
              let Xn = Xe.key.initData;
              if (ArrayBuffer.isView(Xn) && (Xn = Xn.buffer), ue) {
                const xi = g.getPSSHForKeySystem(ue, Xn);
                if (xi && Bi(xi)) return;
              }
              In.debug("DRM: initData:", String.fromCharCode.apply(null, new Uint8Array(Xn)));
              const di = xe.getSupportedKeySystemsFromSegmentPssh(Xn, $e, Be);
              if (di.length === 0) return void In.debug("DRM: Received needkey event with initData, but we don't support any of the key systems!");
              Fn = di, vn.push(Fn), ui(Fn, !1);
            }
            var Fn;
          }
          function wa(Xe) {
            const fn = dn.getSessionTokens();
            if (fn && fn.length > 0) {
              const Fn = fn.filter((Xn) => [...Xe].includes(Xn.normalizedKeyId));
              if (Fn.some((Xn) => !Xn.hasTriggeredKeyStatusMapUpdate) || Fn.length === 0) return !1;
            }
            return !Se.get().streaming.protection.ignoreKeyStatuses && Xe && Xe.size > 0 && Ge && Ge.size > 0;
          }
          return kn = { areKeyIdsExpired: function(Xe) {
            try {
              return !!wa(Xe) && [...Xe].every((fn) => Ge.get(fn) === l.A.MEDIA_KEY_STATUSES.EXPIRED);
            } catch (fn) {
              return In.error(fn), !1;
            }
          }, areKeyIdsUsable: function(Xe) {
            try {
              return !wa(Xe) || [...Xe].some((fn) => {
                const Fn = Ge.get(fn);
                return Fn && Fn !== l.A.MEDIA_KEY_STATUSES.INTERNAL_ERROR && Fn !== l.A.MEDIA_KEY_STATUSES.OUTPUT_RESTRICTED;
              });
            } catch (fn) {
              return In.error(fn), !0;
            }
          }, clearMediaInfoArray: function() {
            Kn = [];
          }, closeKeySession: function(Xe) {
            $n(), dn.closeKeySession(Xe);
          }, createKeySession: Mi, getKeySystems: function() {
            return xe ? xe.getKeySystems() : [];
          }, getSupportedKeySystemMetadataFromContentProtection: function(Xe) {
            return $n(), xe.getSupportedKeySystemMetadataFromContentProtection(Xe, $e, Be);
          }, handleKeySystemFromManifest: function() {
            if (!Kn || Kn.length === 0) return;
            let Xe = [];
            Kn.forEach((fn) => {
              const Fn = xe.getSupportedKeySystemMetadataFromContentProtection(fn.contentProtection, $e, Be);
              Fn.length > 0 && (Xe.length === 0 && (Xe = Fn), vn.push(Fn));
            }), Xe && Xe.length > 0 && ui(Xe, !0);
          }, initializeForMedia: function(Xe) {
            if (!Xe) throw new Error("mediaInfo can not be null or undefined");
            $n(), Kn.push(Xe);
          }, loadKeySession: ai, removeKeySession: function(Xe) {
            $n(), dn.removeKeySession(Xe);
          }, reset: function() {
            Je.off(tn.INTERNAL_KEY_MESSAGE, Ri, kn), $n(), qr(), dr(null), ue = null, En = !1, Ge = /* @__PURE__ */ new Map(), dn && (dn.reset(), dn = null), Yn.forEach((Xe) => clearTimeout(Xe)), Yn = [], Kn = [], vn = [];
          }, setKeySystems: function(Xe) {
            xe && xe.setKeySystems(Xe);
          }, setMediaElement: dr, setProtectionData: function(Xe) {
            $e = Xe, xe.setProtectionData(Xe);
          }, setRobustnessLevel: function(Xe) {
            ve = Xe;
          }, setServerCertificate: function(Xe) {
            $n(), dn.setServerCertificate(Xe);
          }, setSessionType: function(Xe) {
            Be = Xe;
          }, stop: function() {
            qr(), dn && dn.stop();
          }, updateKeyStatusesMap: function(Xe) {
            try {
              if (!Xe || !Xe.sessionToken || !Xe.parsedKeyStatuses) return;
              Xe.sessionToken.hasTriggeredKeyStatusMapUpdate = !0;
              const fn = Xe.parsedKeyStatuses, Fn = P.A.parseUserAgent(), Xn = Fn && Fn.browser && Fn.browser.name && Fn.browser.name.toLowerCase() === "edge";
              fn.forEach((di) => {
                Xn && ue.uuid === l.A.PLAYREADY_UUID && di.keyId && di.keyId.byteLength === 16 && function(oi) {
                  const Zn = P.A.bufferSourceToDataView(oi), zn = Zn.getUint32(0, !0), Qn = Zn.getUint16(4, !0), mi = Zn.getUint16(6, !0);
                  Zn.setUint32(0, zn, !1), Zn.setUint16(4, Qn, !1), Zn.setUint16(6, mi, !1);
                }(di.keyId);
                const xi = P.A.bufferSourceToHex(di.keyId).slice(0, 32);
                xi && xi !== "" && Ge.set(xi, di.status);
              }), Je.trigger(tn.KEY_STATUSES_MAP_UPDATED, { keyStatusMap: Ge });
            } catch (fn) {
              In.error(fn);
            }
          } }, In = He.getLogger(kn), vn = [], Kn = [], Be = "temporary", ve = "", Dn = null, An = null, Ge = /* @__PURE__ */ new Map(), Je.on(tn.INTERNAL_KEY_MESSAGE, Ri, kn), kn;
        }
        dt.__dashjs_factory_name = "ProtectionController";
        var xt = ot.A.getClassFactory(dt), Nt = class {
          constructor(Ae, Ke) {
            this.keyID = Ae, this.key = Ke;
          }
        }, jt = class {
          constructor(Ae, Ke) {
            if (Ke && Ke !== "persistent" && Ke !== "temporary") throw new Error("Invalid ClearKey key set type!  Must be one of 'persistent' or 'temporary'");
            this.keyPairs = Ae, this.type = Ke;
          }
          toJWK() {
            let Ae, Ke = this.keyPairs.length, Re = { keys: [] };
            for (Ae = 0; Ae < Ke; Ae++) {
              let tn = { kty: "oct", alg: "A128KW", kid: this.keyPairs[Ae].keyID, k: this.keyPairs[Ae].key };
              Re.keys.push(tn);
            }
            this.type && (Re.type = this.type);
            let pe = JSON.stringify(Re);
            const Ce = pe.length;
            let He = new ArrayBuffer(Ce), Je = new Uint8Array(He);
            for (Ae = 0; Ae < Ce; Ae++) Je[Ae] = pe.charCodeAt(Ae);
            return He;
          }
        };
        const q = l.A.CLEARKEY_UUID, I = l.A.CLEARKEY_KEYSTEM_STRING, pt = "urn:uuid:" + q;
        function It(Ae) {
          let Ke;
          const Re = (Ae = Ae || {}).BASE64;
          return Ke = { uuid: q, schemeIdURI: pt, systemString: I, getInitData: function(pe, Ce) {
            try {
              let He = g.parseInitDataFromContentProtection(pe, Re);
              if (!He && Ce) {
                const Je = { kids: [function(tn) {
                  try {
                    let xe = tn.replace(/-/g, "");
                    return xe = btoa(xe.match(/\w{2}/g).map((Se) => String.fromCharCode(parseInt(Se, 16))).join("")), xe.replace(/=/g, "").replace(/\//g, "_").replace(/\+/g, "-");
                  } catch {
                    return null;
                  }
                }(Ce.cencDefaultKid)] };
                He = new TextEncoder().encode(JSON.stringify(Je));
              }
              return He;
            } catch {
              return null;
            }
          }, getRequestHeadersFromMessage: function() {
            return { "Content-Type": "application/json" };
          }, getLicenseRequestFromMessage: function(pe) {
            return JSON.stringify(JSON.parse(String.fromCharCode.apply(null, new Uint8Array(pe))));
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          }, getClearKeysFromProtectionData: function(pe, Ce) {
            let He = null;
            if (pe) {
              const Je = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(Ce))), tn = [];
              for (let xe = 0; xe < Je.kids.length; xe++) {
                const Se = Je.kids[xe], $e = pe.clearkeys && pe.clearkeys.hasOwnProperty(Se) ? pe.clearkeys[Se] : null;
                if (!$e) throw new Error("DRM: ClearKey keyID (" + Se + ") is not known!");
                tn.push(new Nt(Se, $e));
              }
              He = new jt(tn);
            }
            return He;
          } }, Ke;
        }
        It.__dashjs_factory_name = "KeySystemClearKey";
        var et = ot.A.getSingletonFactory(It);
        const Dt = l.A.W3C_CLEARKEY_UUID, ae = l.A.CLEARKEY_KEYSTEM_STRING, St = "urn:uuid:" + Dt;
        function qe(Ae) {
          let Ke;
          const Re = Ae.BASE64, pe = Ae.debug.getLogger(Ke);
          return Ke = { uuid: Dt, schemeIdURI: St, systemString: ae, getInitData: function(Ce) {
            return g.parseInitDataFromContentProtection(Ce, Re);
          }, getRequestHeadersFromMessage: function() {
            return null;
          }, getLicenseRequestFromMessage: function(Ce) {
            return new Uint8Array(Ce);
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          }, getClearKeysFromProtectionData: function(Ce, He) {
            let Je = null;
            if (Ce) {
              const tn = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(He))), xe = [];
              for (let Se = 0; Se < tn.kids.length; Se++) {
                const $e = tn.kids[Se], kn = Ce.clearkeys && Ce.clearkeys.hasOwnProperty($e) ? Ce.clearkeys[$e] : null;
                if (!kn) throw new Error("DRM: ClearKey keyID (" + $e + ") is not known!");
                xe.push(new Nt($e, kn));
              }
              Je = new jt(xe), pe.warn("ClearKey schemeIdURI is using W3C Common PSSH systemID (1077efec-c0b2-4d02-ace3-3c1e52e2fb4b) in Content Protection. See DASH-IF IOP v4.1 section 7.6.2.4");
            }
            return Je;
          } }, Ke;
        }
        qe.__dashjs_factory_name = "KeySystemW3CClearKey";
        var zt = ot.A.getSingletonFactory(qe);
        const Ct = l.A.WIDEVINE_UUID, de = l.A.WIDEVINE_KEYSTEM_STRING, ze = "urn:uuid:" + Ct;
        function le(Ae) {
          let Ke;
          const Re = (Ae = Ae || {}).BASE64;
          return Ke = { uuid: Ct, schemeIdURI: ze, systemString: de, getInitData: function(pe) {
            return g.parseInitDataFromContentProtection(pe, Re);
          }, getRequestHeadersFromMessage: function() {
            return null;
          }, getLicenseRequestFromMessage: function(pe) {
            return new Uint8Array(pe);
          }, getLicenseServerURLFromInitData: function() {
            return null;
          }, getCDMData: function() {
            return null;
          } }, Ke;
        }
        le.__dashjs_factory_name = "KeySystemWidevine";
        var Ze = ot.A.getSingletonFactory(le);
        const me = l.A.PLAYREADY_UUID, bn = l.A.PLAYREADY_KEYSTEM_STRING, pn = "urn:uuid:" + me;
        function wn(Ae) {
          let Ke, Re = "utf-16";
          const pe = (Ae = Ae || {}).BASE64, Ce = Ae.settings;
          function He() {
            if (!pe || !pe.hasOwnProperty("decodeArray") || !pe.hasOwnProperty("decodeArray")) throw new Error("Missing config parameter(s)");
          }
          return Ke = { uuid: me, schemeIdURI: pn, systemString: bn, getInitData: function(Je) {
            const tn = new Uint8Array([112, 115, 115, 104, 0, 0, 0, 0]), xe = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);
            let Se, $e, kn, Ge, En, An = 0, Dn = null;
            if (He(), !Je) return null;
            if ("pssh" in Je && Je.pssh) return g.parseInitDataFromContentProtection(Je, pe);
            if ("pro" in Je && Je.pro) Dn = pe.decodeArray(Je.pro.__text);
            else {
              if (!("prheader" in Je) || !Je.prheader) return null;
              Dn = pe.decodeArray(Je.prheader.__text);
            }
            return Se = Dn.length, $e = 4 + tn.length + xe.length + 4 + Se, kn = new ArrayBuffer($e), Ge = new Uint8Array(kn), En = new DataView(kn), En.setUint32(An, $e), An += 4, Ge.set(tn, An), An += tn.length, Ge.set(xe, An), An += xe.length, En.setUint32(An, Se), An += 4, Ge.set(Dn, An), An += Se, Ge.buffer;
          }, getRequestHeadersFromMessage: function(Je) {
            let tn, xe;
            const Se = {}, $e = new DOMParser();
            if (Ce && Ce.get().streaming.protection.detectPlayreadyMessageFormat && Re === "utf-16" && Je && Je.byteLength % 2 == 1) return Se["Content-Type"] = "text/xml; charset=utf-8", Se;
            const kn = Re === "utf-16" ? new Uint16Array(Je) : new Uint8Array(Je);
            tn = String.fromCharCode.apply(null, kn), xe = $e.parseFromString(tn, "application/xml");
            const Ge = xe.getElementsByTagName("name"), En = xe.getElementsByTagName("value");
            for (let An = 0; An < Ge.length; An++) Se[Ge[An].childNodes[0].nodeValue] = En[An].childNodes[0].nodeValue;
            return Se.hasOwnProperty("Content") && (Se["Content-Type"] = Se.Content, delete Se.Content), Se.hasOwnProperty("Content-Type") || (Se["Content-Type"] = "text/xml; charset=utf-8"), Se;
          }, getLicenseRequestFromMessage: function(Je) {
            let tn = null;
            const xe = new DOMParser();
            if (Ce && Ce.get().streaming.protection.detectPlayreadyMessageFormat && Re === "utf-16" && Je && Je.byteLength % 2 == 1) return Je;
            const Se = Re === "utf-16" ? new Uint16Array(Je) : new Uint8Array(Je);
            He();
            const $e = String.fromCharCode.apply(null, Se), kn = xe.parseFromString($e, "application/xml");
            if (!kn.getElementsByTagName("PlayReadyKeyMessage")[0]) return Je;
            {
              const Ge = kn.getElementsByTagName("Challenge")[0].childNodes[0].nodeValue;
              Ge && (tn = pe.decode(Ge));
            }
            return tn;
          }, getLicenseServerURLFromInitData: function(Je) {
            if (Je) {
              const tn = new DataView(Je), xe = tn.getUint16(4, !0);
              let Se = 6;
              const $e = new DOMParser();
              for (let kn = 0; kn < xe; kn++) {
                const Ge = tn.getUint16(Se, !0);
                Se += 2;
                const En = tn.getUint16(Se, !0);
                if (Se += 2, Ge !== 1) {
                  Se += En;
                  continue;
                }
                const An = Je.slice(Se, Se + En), Dn = String.fromCharCode.apply(null, new Uint16Array(An)), In = $e.parseFromString(Dn, "application/xml");
                if (In.getElementsByTagName("LA_URL")[0]) {
                  const Kn = In.getElementsByTagName("LA_URL")[0].childNodes[0].nodeValue;
                  if (Kn) return Kn;
                }
                if (In.getElementsByTagName("LUI_URL")[0]) {
                  const Kn = In.getElementsByTagName("LUI_URL")[0].childNodes[0].nodeValue;
                  if (Kn) return Kn;
                }
              }
            }
            return null;
          }, getCDMData: function(Je) {
            let tn, xe, Se, $e;
            if (He(), !Je) return null;
            for (tn = [], $e = 0; $e < Je.length; ++$e) tn.push(Je.charCodeAt($e)), tn.push(0);
            for (tn = String.fromCharCode.apply(null, tn), tn = pe.encode(tn), xe = '<PlayReadyCDMData type="LicenseAcquisition"><LicenseAcquisition version="1.0" Proactive="false"><CustomData encoding="base64encoded">%CUSTOMDATA%</CustomData></LicenseAcquisition></PlayReadyCDMData>'.replace("%CUSTOMDATA%", tn), Se = [], $e = 0; $e < xe.length; ++$e) Se.push(xe.charCodeAt($e)), Se.push(0);
            return new Uint8Array(Se).buffer;
          }, setPlayReadyMessageFormat: function(Je) {
            if (Je !== "utf-8" && Je !== "utf-16") throw new Error('Specified message format is not one of "utf-8" or "utf-16"');
            Re = Je;
          } }, Ke;
        }
        wn.__dashjs_factory_name = "KeySystemPlayReady";
        var Yt = ot.A.getSingletonFactory(wn);
        function Ht(Ae) {
          const Ke = (Ae = Ae || {}).BASE64, Re = {};
          let pe;
          return Re[l.A.WIDEVINE_KEYSTEM_STRING] = { responseType: "json", getLicenseMessage: function(Ce) {
            return Ke.decodeArray(Ce.license);
          }, getErrorResponse: function(Ce) {
            return Ce;
          } }, Re[l.A.PLAYREADY_KEYSTEM_STRING] = { responseType: "arraybuffer", getLicenseMessage: function(Ce) {
            return Ce;
          }, getErrorResponse: function(Ce) {
            return String.fromCharCode.apply(null, new Uint8Array(Ce));
          } }, pe = { getServerURLFromMessage: function(Ce) {
            return Ce;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function(Ce) {
            return Re[Ce].responseType;
          }, getLicenseMessage: function(Ce, He) {
            return function() {
              if (!Ke || !Ke.hasOwnProperty("decodeArray")) throw new Error("Missing config parameter(s)");
            }(), Re[He].getLicenseMessage(Ce);
          }, getErrorResponse: function(Ce, He) {
            return Re[He].getErrorResponse(Ce);
          } }, pe;
        }
        Ht.__dashjs_factory_name = "DRMToday";
        var Me = ot.A.getSingletonFactory(Ht);
        function X() {
          let Ae;
          const Ke = "http://schemas.xmlsoap.org/soap/envelope/";
          function Re(He) {
            const Je = String.fromCharCode.apply(null, new Uint8Array(He));
            return decodeURIComponent(escape(Je));
          }
          function pe(He) {
            if (window.DOMParser) {
              const Je = Re(He), tn = new window.DOMParser().parseFromString(Je, "text/xml"), xe = tn ? tn.getElementsByTagNameNS(Ke, "Envelope")[0] : null, Se = xe ? xe.getElementsByTagNameNS(Ke, "Body")[0] : null;
              if (Se && Se.getElementsByTagNameNS(Ke, "Fault")[0]) return null;
            }
            return He;
          }
          function Ce(He) {
            let Je = "", tn = "", xe = "", Se = -1, $e = -1;
            if (window.DOMParser) {
              const Ge = Re(He), En = new window.DOMParser().parseFromString(Ge, "text/xml"), An = En ? En.getElementsByTagNameNS(Ke, "Envelope")[0] : null, Dn = An ? An.getElementsByTagNameNS(Ke, "Body")[0] : null, In = Dn ? Dn.getElementsByTagNameNS(Ke, "Fault")[0] : null, Kn = In ? In.getElementsByTagName("detail")[0] : null, vn = Kn ? Kn.getElementsByTagName("Exception")[0] : null;
              let ve = null;
              if (In === null) return Ge;
              ve = In.getElementsByTagName("faultstring")[0].firstChild, Je = ve ? ve.nodeValue : null, vn !== null && (ve = vn.getElementsByTagName("StatusCode")[0], tn = ve ? ve.firstChild.nodeValue : null, ve = vn.getElementsByTagName("Message")[0], xe = ve ? ve.firstChild.nodeValue : null, Se = xe ? xe.lastIndexOf("[") + 1 : -1, $e = xe ? xe.indexOf("]") : -1, xe = xe ? xe.substring(Se, $e) : "");
            }
            let kn = `code: ${tn}, name: ${Je}`;
            return xe && (kn += `, message: ${xe}`), kn;
          }
          return Ae = { getServerURLFromMessage: function(He) {
            return He;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "arraybuffer";
          }, getLicenseMessage: function(He) {
            return pe.call(this, He);
          }, getErrorResponse: function(He) {
            return Ce.call(this, He);
          } }, Ae;
        }
        X.__dashjs_factory_name = "PlayReady";
        var Q = ot.A.getSingletonFactory(X);
        function C() {
          let Ae;
          return Ae = { getServerURLFromMessage: function(Ke) {
            return Ke;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "arraybuffer";
          }, getLicenseMessage: function(Ke) {
            return Ke;
          }, getErrorResponse: function(Ke) {
            return String.fromCharCode.apply(null, new Uint8Array(Ke));
          } }, Ae;
        }
        C.__dashjs_factory_name = "Widevine";
        var U = ot.A.getSingletonFactory(C);
        function gt() {
          let Ae;
          return Ae = { getServerURLFromMessage: function(Ke) {
            return Ke;
          }, getHTTPMethod: function() {
            return "POST";
          }, getResponseType: function() {
            return "json";
          }, getLicenseMessage: function(Ke) {
            if (!Ke.hasOwnProperty("keys")) return null;
            let Re = [];
            for (let pe = 0; pe < Ke.keys.length; pe++) {
              let Ce = Ke.keys[pe], He = Ce.kid.replace(/=/g, ""), Je = Ce.k.replace(/=/g, "");
              Re.push(new Nt(He, Je));
            }
            return new jt(Re);
          }, getErrorResponse: function(Ke) {
            return String.fromCharCode.apply(null, new Uint8Array(Ke));
          } }, Ae;
        }
        gt.__dashjs_factory_name = "ClearKey";
        var rt = ot.A.getSingletonFactory(gt), Ft = class {
          constructor(Ae) {
            this.ks = Ae.ks, this.keyId = Ae.keyId, this.initData = Ae.initData, this.protData = Ae.protData, this.cdmData = Ae.cdmData, this.sessionId = Ae.sessionId, this.sessionType = Ae.sessionType;
          }
        };
        function ne() {
          let Ae, Ke, Re, pe, Ce, He, Je, tn, xe = this.context;
          function Se(Ge, En) {
            return En && Ge in En ? En[Ge] : null;
          }
          function $e(Ge, En) {
            return Ge && Ge.sessionId ? Ge.sessionId : En && En.sessionId ? En.sessionId : null;
          }
          function kn(Ge, En) {
            return Ge && Ge.sessionType ? Ge.sessionType : En;
          }
          return Ae = { getKeySystemBySystemString: function(Ge) {
            for (let En = 0; En < pe.length; En++) if (pe[En].systemString === Ge) return pe[En];
            return null;
          }, getKeySystems: function() {
            return pe;
          }, getLicenseServerModelInstance: function(Ge, En, An) {
            if (An === l.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_RELEASE || An === l.A.MEDIA_KEY_MESSAGE_TYPES.INDIVIDUALIZATION_REQUEST) return null;
            let Dn = null;
            return En && En.hasOwnProperty("drmtoday") ? Dn = Me(xe).getInstance({ BASE64: Ce }) : Ge.systemString === l.A.WIDEVINE_KEYSTEM_STRING ? Dn = U(xe).getInstance() : Ge.systemString === l.A.PLAYREADY_KEYSTEM_STRING ? Dn = Q(xe).getInstance() : Ge.systemString === l.A.CLEARKEY_KEYSTEM_STRING && (Dn = rt(xe).getInstance()), Dn;
          }, getSupportedKeySystemMetadataFromContentProtection: function(Ge, En, An) {
            let Dn, In, Kn, vn, ve = [];
            if (!Ge || !Ge.length) return ve;
            const ue = g.findMp4ProtectionElement(Ge);
            for (Kn = 0; Kn < pe.length; Kn++) {
              In = pe[Kn];
              const Be = Se(In.systemString, En);
              for (vn = 0; vn < Ge.length; vn++) if (Dn = Ge[vn], Dn.schemeIdUri.toLowerCase() === In.schemeIdURI) {
                let dn = In.getInitData(Dn, ue);
                const Yn = new Ft({ ks: pe[Kn], keyId: Dn.keyId, initData: dn, protData: Be, cdmData: In.getCDMData(Be ? Be.cdmData : null), sessionId: $e(Be, Dn), sessionType: kn(Be, An) });
                Be ? ve.unshift(Yn) : ve.push(Yn);
              }
            }
            return ve;
          }, getSupportedKeySystemsFromSegmentPssh: function(Ge, En, An) {
            let Dn, In, Kn = [], vn = g.parsePSSHList(Ge);
            for (let ve = 0; ve < pe.length; ++ve) {
              Dn = pe[ve], In = Dn.systemString;
              const ue = Se(In, En);
              Dn.uuid in vn && Kn.push({ ks: Dn, initData: vn[Dn.uuid], protData: ue, cdmData: Dn.getCDMData(ue ? ue.cdmData : null), sessionId: $e(ue), sessionType: kn(ue, An) });
            }
            return Kn;
          }, initDataEquals: function(Ge, En) {
            if (Ge.byteLength === En.byteLength) {
              let An = new Uint8Array(Ge), Dn = new Uint8Array(En);
              for (let In = 0; In < An.length; In++) if (An[In] !== Dn[In]) return !1;
              return !0;
            }
            return !1;
          }, initialize: function() {
            let Ge;
            pe = [], Ge = Yt(xe).getInstance({ BASE64: Ce, settings: He }), pe.push(Ge), Ge = Ze(xe).getInstance({ BASE64: Ce }), pe.push(Ge), Ge = et(xe).getInstance({ BASE64: Ce }), pe.push(Ge), Je = Ge, Ge = zt(xe).getInstance({ BASE64: Ce, debug: Ke }), pe.push(Ge), tn = Ge;
          }, isClearKey: function(Ge) {
            return Ge === Je || Ge === tn;
          }, processClearKeyLicenseRequest: function(Ge, En, An) {
            try {
              return Ge.getClearKeysFromProtectionData(En, An);
            } catch {
              return Re.error("Failed to retrieve clearkeys from ProtectionData"), null;
            }
          }, setConfig: function(Ge) {
            Ge && (Ge.debug && (Ke = Ge.debug, Re = Ke.getLogger(Ae)), Ge.BASE64 && (Ce = Ge.BASE64), Ge.settings && (He = Ge.settings));
          }, setKeySystems: function(Ge) {
            pe = Ge;
          }, setProtectionData: function(Ge) {
            for (var En, An, Dn = 0; Dn < pe.length; Dn++) {
              var In = pe[Dn];
              In.hasOwnProperty("init") && In.init((En = In.systemString, An = void 0, An = null, Ge && (An = En in Ge ? Ge[En] : null), An));
            }
          } }, Ae;
        }
        ne.__dashjs_factory_name = "ProtectionKeyController";
        var Vt = ot.A.getSingletonFactory(ne), Xt = b(445), qt = class {
          constructor(Ae, Ke) {
            this.initData = Ae, this.initDataType = Ke;
          }
        }, Gt = class {
          constructor(Ae, Ke, Re, pe) {
            this.sessionToken = Ae, this.message = Ke, this.defaultURL = Re, this.messageType = pe || l.A.MEDIA_KEY_MESSAGE_TYPES.LICENSE_REQUEST;
          }
        }, se = class {
          constructor(Ae, Ke) {
            this.keySystem = Ae, this.ksConfiguration = Ke, this.nativeMediaKeySystemAccessObject = null, this.selectedSystemString = null;
          }
        };
        const Jt = {};
        function he(Ae) {
          Ae = Ae || {};
          const Ke = this.context, Re = Ae.eventBus, pe = Ae.events, Ce = Ae.debug;
          let He, Je, tn, xe, Se, $e, kn, Ge;
          function En(ve, ue, Be, dn) {
            if (navigator.requestMediaKeySystemAccess === void 0 || typeof navigator.requestMediaKeySystemAccess != "function") {
              const Ei = "Insecure origins are not allowed";
              return Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { error: Ei }), void dn({ error: Ei });
            }
            const Yn = ve[ue].protData && ve[ue].protData.systemStringPriority ? ve[ue].protData.systemStringPriority : null, $n = ve[ue].configs, ui = ve[ue].ks;
            let Ii = ui.systemString;
            (function(Ei, ai) {
              return new Promise((Mi, Oi) => {
                An(Ei, ai, 0, Mi, Oi);
              });
            })(Yn || (Jt[Ii] ? Jt[Ii] : [Ii]), $n).then((Ei) => {
              const ai = Ei && Ei.nativeMediaKeySystemAccessObject && typeof Ei.nativeMediaKeySystemAccessObject.getConfiguration == "function" ? Ei.nativeMediaKeySystemAccessObject.getConfiguration() : null, Mi = new se(ui, ai);
              Mi.selectedSystemString = Ei.selectedSystemString, Mi.nativeMediaKeySystemAccessObject = Ei.nativeMediaKeySystemAccessObject, Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { data: Mi }), Be({ data: Mi });
            }).catch((Ei) => {
              if (ue + 1 < ve.length) En(ve, ue + 1, Be, dn);
              else {
                const ai = "Key system access denied! ";
                Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { error: ai + Ei.message }), dn({ error: ai + Ei.message });
              }
            });
          }
          function An(ve, ue, Be, dn, Yn) {
            const $n = ve[Be];
            Je.debug(`Requesting key system access for system string ${$n}`), navigator.requestMediaKeySystemAccess($n, ue).then((ui) => {
              dn({ nativeMediaKeySystemAccessObject: ui, selectedSystemString: $n });
            }).catch((ui) => {
              Be + 1 < ve.length ? An(ve, ue, Be + 1, dn, Yn) : Yn(ui);
            });
          }
          function Dn(ve) {
            if (!ve || !ve.session) return Promise.resolve;
            const ue = ve.session;
            return ue.removeEventListener("keystatuseschange", ve), ue.removeEventListener("message", ve), ue.close();
          }
          function In(ve) {
            for (let ue = 0; ue < $e.length; ue++) if ($e[ue] === ve) {
              $e.splice(ue, 1);
              break;
            }
          }
          function Kn(ve, ue) {
            const Be = { session: ve, keyId: ue.keyId, normalizedKeyId: ue && ue.keyId && typeof ue.keyId == "string" ? ue.keyId.replace(/-/g, "").toLowerCase() : "", initData: ue.initData, sessionId: ue.sessionId, sessionType: ue.sessionType, hasTriggeredKeyStatusMapUpdate: !1, handleEvent: function(dn) {
              switch (dn.type) {
                case "keystatuseschange":
                  this._onKeyStatusesChange(dn);
                  break;
                case "message":
                  this._onKeyMessage(dn);
              }
            }, _onKeyStatusesChange: function(dn) {
              Re.trigger(pe.KEY_STATUSES_CHANGED, { data: this });
              const Yn = [];
              dn.target.keyStatuses.forEach(function() {
                Yn.push(vn(arguments));
              }), Re.trigger(pe.INTERNAL_KEY_STATUSES_CHANGED, { parsedKeyStatuses: Yn, sessionToken: Be });
            }, _onKeyMessage: function(dn) {
              let Yn = ArrayBuffer.isView(dn.message) ? dn.message.buffer : dn.message;
              Re.trigger(pe.INTERNAL_KEY_MESSAGE, { data: new Gt(this, Yn, void 0, dn.messageType) });
            }, getKeyId: function() {
              return this.keyId;
            }, getSessionId: function() {
              return ve.sessionId;
            }, getSessionType: function() {
              return this.sessionType;
            }, getExpirationTime: function() {
              return ve.expiration;
            }, getKeyStatuses: function() {
              return ve.keyStatuses;
            }, getUsable: function() {
              let dn = !1;
              return ve.keyStatuses.forEach(function() {
                vn(arguments).status === l.A.MEDIA_KEY_STATUSES.USABLE && (dn = !0);
              }), dn;
            } };
            return ve.addEventListener("keystatuseschange", Be), ve.addEventListener("message", Be), ve.closed.then(() => {
              In(Be), Je.debug("DRM: Session closed.  SessionID = " + Be.getSessionId()), Re.trigger(pe.KEY_SESSION_CLOSED, { data: Be.getSessionId() });
            }), $e.push(Be), Be;
          }
          function vn(ve) {
            let ue, Be;
            return ve && ve.length > 0 && (ve[0] && (typeof ve[0] == "string" ? ue = ve[0] : Be = ve[0]), ve[1] && (typeof ve[1] == "string" ? ue = ve[1] : Be = ve[1])), { status: ue, keyId: Be };
          }
          return He = { closeKeySession: function(ve) {
            Dn(ve).catch(function(ue) {
              In(ve), Re.trigger(pe.KEY_SESSION_CLOSED, { data: null, error: "Error closing session (" + ve.getSessionId() + ") " + ue.name });
            });
          }, createKeySession: function(ve) {
            if (!tn || !Se) throw new Error("Can not create sessions until you have selected a key system");
            const ue = Se.createSession(ve.sessionType), Be = Kn(ue, ve), dn = tn.systemString === l.A.CLEARKEY_KEYSTEM_STRING && (ve.initData || ve.protData && ve.protData.clearkeys) ? l.A.INITIALIZATION_DATA_TYPE_KEYIDS : l.A.INITIALIZATION_DATA_TYPE_CENC;
            ue.generateRequest(dn, ve.initData).then(function() {
              Je.debug("DRM: Session created.  SessionID = " + Be.getSessionId()), Re.trigger(pe.KEY_SESSION_CREATED, { data: Be });
            }).catch(function(Yn) {
              In(Be), Re.trigger(pe.KEY_SESSION_CREATED, { data: null, error: new n.A(e.A.KEY_SESSION_CREATED_ERROR_CODE, e.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Error generating key request -- " + Yn.name) });
            });
          }, getAllInitData: function() {
            const ve = [];
            for (let ue = 0; ue < $e.length; ue++) $e[ue].initData && ve.push($e[ue].initData);
            return ve;
          }, getSessionTokens: function() {
            return $e;
          }, loadKeySession: function(ve) {
            if (!tn || !Se) throw new Error("Can not load sessions until you have selected a key system");
            const ue = ve.sessionId;
            for (let Yn = 0; Yn < $e.length; Yn++) if (ue === $e[Yn].sessionId) return void Je.warn("DRM: Ignoring session ID because we have already seen it!");
            const Be = Se.createSession(ve.sessionType), dn = Kn(Be, ve);
            dn.hasTriggeredKeyStatusMapUpdate = !0, Be.load(ue).then(function(Yn) {
              Yn ? (Je.debug("DRM: Session loaded.  SessionID = " + dn.getSessionId()), Re.trigger(pe.KEY_SESSION_CREATED, { data: dn })) : (In(dn), Re.trigger(pe.KEY_SESSION_CREATED, { data: null, error: new n.A(e.A.KEY_SESSION_CREATED_ERROR_CODE, e.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Could not load session! Invalid Session ID (" + ue + ")") }));
            }).catch(function(Yn) {
              In(dn), Re.trigger(pe.KEY_SESSION_CREATED, { data: null, error: new n.A(e.A.KEY_SESSION_CREATED_ERROR_CODE, e.A.KEY_SESSION_CREATED_ERROR_MESSAGE + "Could not load session (" + ue + ")! " + Yn.name) });
            });
          }, removeKeySession: function(ve) {
            ve.session.remove().then(function() {
              Je.debug("DRM: Session removed.  SessionID = " + ve.getSessionId()), Re.trigger(pe.KEY_SESSION_REMOVED, { data: ve.getSessionId() });
            }, function(ue) {
              Re.trigger(pe.KEY_SESSION_REMOVED, { data: null, error: "Error removing session (" + ve.getSessionId() + "). " + ue.name });
            });
          }, requestKeySystemAccess: function(ve) {
            return new Promise((ue, Be) => {
              En(ve, 0, ue, Be);
            });
          }, reset: function() {
            const ve = $e.length;
            let ue;
            if (ve !== 0) {
              const Be = function(dn) {
                In(dn), $e.length === 0 && (xe ? (xe.removeEventListener("encrypted", kn), xe.setMediaKeys(null).then(function() {
                  Re.trigger(pe.TEARDOWN_COMPLETE);
                })) : Re.trigger(pe.TEARDOWN_COMPLETE));
              };
              for (let dn = 0; dn < ve; dn++) ue = $e[dn], function(Yn) {
                Dn(ue), Be(Yn);
              }(ue);
            } else Re.trigger(pe.TEARDOWN_COMPLETE);
          }, selectKeySystem: function(ve) {
            return new Promise((ue, Be) => {
              ve.nativeMediaKeySystemAccessObject.createMediaKeys().then((dn) => (tn = ve.keySystem, Se = dn, xe ? xe.setMediaKeys(Se) : Promise.resolve())).then(() => {
                ue(tn);
              }).catch(function() {
                Be({ error: "Error selecting keys system (" + ve.keySystem.systemString + ")! Could not create MediaKeys -- TODO" });
              });
            });
          }, setMediaElement: function(ve) {
            xe !== ve && (xe && (xe.removeEventListener("encrypted", kn), xe.setMediaKeys && xe.setMediaKeys(null)), xe = ve, xe && (xe.addEventListener("encrypted", kn), xe.setMediaKeys && Se && xe.setMediaKeys(Se)));
          }, setServerCertificate: function(ve) {
            return new Promise((ue, Be) => {
              Se.setServerCertificate(ve).then(function() {
                Je.info("DRM: License server certificate successfully updated."), Re.trigger(pe.SERVER_CERTIFICATE_UPDATED), ue();
              }).catch((dn) => {
                Be(dn), Re.trigger(pe.SERVER_CERTIFICATE_UPDATED, { error: new n.A(e.A.SERVER_CERTIFICATE_UPDATED_ERROR_CODE, e.A.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE + dn.name) });
              });
            });
          }, stop: function() {
            let ve;
            for (let ue = 0; ue < $e.length; ue++) ve = $e[ue], ve.getUsable() || (Dn(ve), In(ve));
          }, updateKeySession: function(ve, ue) {
            const Be = ve.session;
            Ge.isClearKey(tn) && (ue = ue.toJWK()), Be.update(ue).then(() => {
              Re.trigger(pe.KEY_SESSION_UPDATED);
            }).catch(function(dn) {
              Re.trigger(pe.KEY_ERROR, { error: new n.A(e.A.MEDIA_KEYERR_CODE, "Error sending update() message! " + dn.name, ve) });
            });
          } }, Je = Ce.getLogger(He), tn = null, xe = null, Se = null, $e = [], Ge = Vt(Ke).getInstance(), kn = { handleEvent: function(ve) {
            if (ve.type === "encrypted" && ve.initData) {
              let ue = ArrayBuffer.isView(ve.initData) ? ve.initData.buffer : ve.initData;
              Re.trigger(pe.NEED_KEY, { key: new qt(ue, ve.initDataType) });
            }
          } }, He;
        }
        Jt[l.A.PLAYREADY_KEYSTEM_STRING] = [l.A.PLAYREADY_KEYSTEM_STRING, l.A.PLAYREADY_RECOMMENDATION_KEYSTEM_STRING], Jt[l.A.WIDEVINE_KEYSTEM_STRING] = [l.A.WIDEVINE_KEYSTEM_STRING], Jt[l.A.CLEARKEY_KEYSTEM_STRING] = [l.A.CLEARKEY_KEYSTEM_STRING], he.__dashjs_factory_name = "DefaultProtectionModel";
        var an = ot.A.getClassFactory(he);
        function Fe(Ae) {
          Ae = Ae || {};
          const Ke = this.context, Re = Ae.eventBus, pe = Ae.events, Ce = Ae.debug, He = Ae.api;
          let Je, tn, xe, Se, $e, kn, Ge, En, An;
          function Dn() {
            try {
              for (let vn = 0; vn < Ge.length; vn++) In(Ge[vn]);
              xe && xe.removeEventListener(He.needkey, En), Re.trigger(pe.TEARDOWN_COMPLETE);
            } catch (vn) {
              Re.trigger(pe.TEARDOWN_COMPLETE, { error: "Error tearing down key sessions and MediaKeys! -- " + vn.message });
            }
          }
          function In(vn) {
            const ve = vn.session;
            ve.removeEventListener(He.error, vn), ve.removeEventListener(He.message, vn), ve.removeEventListener(He.ready, vn), ve.removeEventListener(He.close, vn);
            for (let ue = 0; ue < Ge.length; ue++) if (Ge[ue] === vn) {
              Ge.splice(ue, 1);
              break;
            }
            ve[He.release]();
          }
          function Kn() {
            let vn = null;
            const ve = function() {
              xe.removeEventListener("loadedmetadata", vn), xe[He.setMediaKeys]($e), Re.trigger(pe.VIDEO_ELEMENT_SELECTED);
            };
            xe.readyState >= 1 ? ve() : (vn = ve.bind(this), xe.addEventListener("loadedmetadata", vn));
          }
          return Je = { getAllInitData: function() {
            const vn = [];
            for (let ve = 0; ve < Ge.length; ve++) vn.push(Ge[ve].initData);
            return vn;
          }, getSessionTokens: function() {
            return Ge;
          }, requestKeySystemAccess: function(vn) {
            return new Promise((ve, ue) => {
              let Be = !1;
              for (let dn = 0; dn < vn.length; dn++) {
                const Yn = vn[dn].ks.systemString, $n = vn[dn].configs;
                let ui = null, Ii = null;
                for (let Ei = 0; Ei < $n.length; Ei++) {
                  const ai = $n[Ei].audioCapabilities, Mi = $n[Ei].videoCapabilities;
                  if (ai && ai.length !== 0) {
                    ui = [];
                    for (let Ri = 0; Ri < ai.length; Ri++) window[He.MediaKeys].isTypeSupported(Yn, ai[Ri].contentType) && ui.push(ai[Ri]);
                  }
                  if (Mi && Mi.length !== 0) {
                    Ii = [];
                    for (let Ri = 0; Ri < Mi.length; Ri++) window[He.MediaKeys].isTypeSupported(Yn, Mi[Ri].contentType) && Ii.push(Mi[Ri]);
                  }
                  if (!ui && !Ii || ui && ui.length === 0 || Ii && Ii.length === 0) continue;
                  Be = !0;
                  const Oi = new S(ui, Ii), Bi = An.getKeySystemBySystemString(Yn), dr = new se(Bi, Oi);
                  Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { data: dr }), ve({ data: dr });
                  break;
                }
              }
              if (!Be) {
                const dn = "Key system access denied! -- No valid audio/video content configurations detected!";
                Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { error: dn }), ue({ error: dn });
              }
            });
          }, selectKeySystem: function(vn) {
            return new Promise((ve, ue) => {
              try {
                $e = vn.mediaKeys = new window[He.MediaKeys](vn.keySystem.systemString), Se = vn.keySystem, kn = vn, xe && Kn(), ve(Se);
              } catch {
                ue({ error: "Error selecting keys system (" + Se.systemString + ")! Could not create MediaKeys -- TODO" });
              }
            });
          }, setMediaElement: function(vn) {
            xe !== vn && (xe && xe.removeEventListener(He.needkey, En), xe = vn, xe && (xe.addEventListener(He.needkey, En), $e && Kn()));
          }, createKeySession: function(vn) {
            if (!Se || !$e || !kn) throw new Error("Can not create sessions until you have selected a key system");
            let ve = null;
            if (kn.ksConfiguration.videoCapabilities && kn.ksConfiguration.videoCapabilities.length > 0 && (ve = kn.ksConfiguration.videoCapabilities[0]), ve === null && kn.ksConfiguration.audioCapabilities && kn.ksConfiguration.audioCapabilities.length > 0 && (ve = kn.ksConfiguration.audioCapabilities[0]), ve === null) throw new Error("Can not create sessions for unknown content types.");
            const ue = ve.contentType, Be = $e.createSession(ue, new Uint8Array(vn.initData), vn.cdmData ? new Uint8Array(vn.cdmData) : null), dn = function(Yn, $n) {
              return { session: Yn, keyId: $n.keyId, normalizedKeyId: $n && $n.keyId && typeof $n.keyId == "string" ? $n.keyId.replace(/-/g, "").toLowerCase() : "", initData: $n.initData, hasTriggeredKeyStatusMapUpdate: !1, getKeyId: function() {
                return this.keyId;
              }, getSessionId: function() {
                return this.session.sessionId;
              }, getExpirationTime: function() {
                return NaN;
              }, getSessionType: function() {
                return "temporary";
              }, getKeyStatuses: function() {
                return { size: 0, has: () => !1, get: () => {
                } };
              }, handleEvent: function(ui) {
                switch (ui.type) {
                  case He.error:
                    let Ii = "KeyError";
                    Re.trigger(pe.KEY_ERROR, { error: new n.A(e.A.MEDIA_KEYERR_CODE, Ii, this) });
                    break;
                  case He.message:
                    let Ei = ArrayBuffer.isView(ui.message) ? ui.message.buffer : ui.message;
                    Re.trigger(pe.INTERNAL_KEY_MESSAGE, { data: new Gt(this, Ei, ui.destinationURL) });
                    break;
                  case He.ready:
                    tn.debug("DRM: Key added."), Re.trigger(pe.KEY_ADDED);
                    break;
                  case He.close:
                    tn.debug("DRM: Session closed.  SessionID = " + this.getSessionId()), Re.trigger(pe.KEY_SESSION_CLOSED, { data: this.getSessionId() });
                }
              } };
            }(Be, vn);
            Be.addEventListener(He.error, dn), Be.addEventListener(He.message, dn), Be.addEventListener(He.ready, dn), Be.addEventListener(He.close, dn), Ge.push(dn), tn.debug("DRM: Session created.  SessionID = " + dn.getSessionId()), Re.trigger(pe.KEY_SESSION_CREATED, { data: dn });
          }, updateKeySession: function(vn, ve) {
            const ue = vn.session;
            An.isClearKey(Se) ? ue.update(new Uint8Array(ve.toJWK())) : ue.update(new Uint8Array(ve)), Re.trigger(pe.KEY_SESSION_UPDATED);
          }, closeKeySession: In, setServerCertificate: function() {
          }, loadKeySession: function() {
          }, removeKeySession: function() {
          }, stop: Dn, reset: Dn }, tn = Ce.getLogger(Je), xe = null, Se = null, $e = null, kn = null, Ge = [], An = Vt(Ke).getInstance(), En = { handleEvent: function(vn) {
            if (vn.type === He.needkey && vn.initData) {
              const ve = ArrayBuffer.isView(vn.initData) ? vn.initData.buffer : vn.initData;
              Re.trigger(pe.NEED_KEY, { key: new qt(ve, l.A.INITIALIZATION_DATA_TYPE_CENC) });
            }
          } }, Je;
        }
        Fe.__dashjs_factory_name = "ProtectionModel_3Feb2014";
        var ke = ot.A.getClassFactory(Fe);
        function ce(Ae) {
          Ae = Ae || {};
          const Ke = this.context, Re = Ae.eventBus, pe = Ae.events, Ce = Ae.debug, He = Ae.api, Je = Ae.errHandler;
          let tn, xe, Se, $e, kn, Ge, En, An, Dn;
          function In() {
            Se && ve();
            for (let ue = 0; ue < En.length; ue++) Kn(En[ue]);
            Re.trigger(pe.TEARDOWN_COMPLETE);
          }
          function Kn(ue) {
            try {
              Se[He.cancelKeyRequest]($e.systemString, ue.sessionId);
            } catch (Be) {
              Re.trigger(pe.KEY_SESSION_CLOSED, { data: null, error: "Error closing session (" + ue.sessionId + ") " + Be.message });
            }
          }
          function vn(ue, Be) {
            if (Be && ue) {
              const dn = ue.length;
              for (let Yn = 0; Yn < dn; Yn++) if (ue[Yn].sessionId == Be) return ue[Yn];
              return null;
            }
            return null;
          }
          function ve() {
            Se.removeEventListener(He.keyerror, Dn), Se.removeEventListener(He.needkey, Dn), Se.removeEventListener(He.keymessage, Dn), Se.removeEventListener(He.keyadded, Dn);
          }
          return tn = { getAllInitData: function() {
            const ue = [];
            for (let Be = 0; Be < Ge.length; Be++) ue.push(Ge[Be].initData);
            for (let Be = 0; Be < En.length; Be++) ue.push(En[Be].initData);
            return ue;
          }, getSessionTokens: function() {
            return En.concat(Ge);
          }, requestKeySystemAccess: function(ue) {
            return new Promise((Be, dn) => {
              let Yn = Se;
              Yn || (Yn = document.createElement("video"));
              let $n = !1;
              for (let ui = 0; ui < ue.length; ui++) {
                const Ii = ue[ui].ks.systemString, Ei = ue[ui].configs;
                let ai = null, Mi = null;
                for (let Oi = 0; Oi < Ei.length; Oi++) {
                  const Bi = Ei[Oi].videoCapabilities;
                  if (Bi && Bi.length !== 0) {
                    Mi = [];
                    for (let $i = 0; $i < Bi.length; $i++) Yn.canPlayType(Bi[$i].contentType, Ii) !== "" && Mi.push(Bi[$i]);
                  }
                  if (!Mi || ai || Mi && Mi.length === 0) continue;
                  $n = !0;
                  const dr = new S(ai, Mi), Ri = kn.getKeySystemBySystemString(Ii), Ci = new se(Ri, dr);
                  Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { data: Ci }), Be({ data: Ci });
                  break;
                }
              }
              if (!$n) {
                const ui = "Key system access denied! -- No valid audio/video content configurations detected!";
                Re.trigger(pe.KEY_SYSTEM_ACCESS_COMPLETE, { error: ui }), dn({ error: ui });
              }
            });
          }, selectKeySystem: function(ue) {
            return $e = ue.keySystem, Promise.resolve($e);
          }, setMediaElement: function(ue) {
            if (Se !== ue) {
              if (Se) {
                ve();
                for (var Be = 0; Be < En.length; Be++) Kn(En[Be]);
                En = [];
              }
              Se = ue, Se && (Se.addEventListener(He.keyerror, Dn), Se.addEventListener(He.needkey, Dn), Se.addEventListener(He.keymessage, Dn), Se.addEventListener(He.keyadded, Dn), Re.trigger(pe.VIDEO_ELEMENT_SELECTED));
            }
          }, createKeySession: function(ue) {
            if (!$e) throw new Error("Can not create sessions until you have selected a key system");
            if (An || En.length === 0) {
              const Be = { sessionId: null, keyId: ue.keyId, normalizedKeyId: ue && ue.keyId && typeof ue.keyId == "string" ? ue.keyId.replace(/-/g, "").toLowerCase() : "", initData: ue.initData, hasTriggeredKeyStatusMapUpdate: !1, getKeyId: function() {
                return this.keyId;
              }, getSessionId: function() {
                return this.sessionId;
              }, getExpirationTime: function() {
                return NaN;
              }, getSessionType: function() {
                return "temporary";
              }, getKeyStatuses: function() {
                return { size: 0, has: () => !1, get: () => {
                } };
              } };
              return Ge.push(Be), Se[He.generateKeyRequest]($e.systemString, new Uint8Array(ue.initData)), Be;
            }
            throw new Error("Multiple sessions not allowed!");
          }, updateKeySession: function(ue, Be) {
            const dn = ue.sessionId;
            if (kn.isClearKey($e)) for (let Yn = 0; Yn < Be.keyPairs.length; Yn++) Se[He.addKey]($e.systemString, Be.keyPairs[Yn].key, Be.keyPairs[Yn].keyID, dn);
            else Se[He.addKey]($e.systemString, new Uint8Array(Be), new Uint8Array(ue.initData), dn);
            Re.trigger(pe.KEY_SESSION_UPDATED);
          }, closeKeySession: Kn, setServerCertificate: function() {
          }, loadKeySession: function() {
          }, removeKeySession: function() {
          }, stop: In, reset: In }, xe = Ce.getLogger(tn), Se = null, $e = null, Ge = [], En = [], kn = Vt(Ke).getInstance(), Dn = { handleEvent: function(ue) {
            let Be = null;
            switch (ue.type) {
              case He.needkey:
                let dn = ArrayBuffer.isView(ue.initData) ? ue.initData.buffer : ue.initData;
                Re.trigger(pe.NEED_KEY, { key: new qt(dn, l.A.INITIALIZATION_DATA_TYPE_CENC) });
                break;
              case He.keyerror:
                if (Be = vn(En, ue.sessionId), Be || (Be = vn(Ge, ue.sessionId)), Be) {
                  let Yn = e.A.MEDIA_KEYERR_CODE, $n = "";
                  switch (ue.errorCode.code) {
                    case 1:
                      Yn = e.A.MEDIA_KEYERR_UNKNOWN_CODE, $n += "MEDIA_KEYERR_UNKNOWN - " + e.A.MEDIA_KEYERR_UNKNOWN_MESSAGE;
                      break;
                    case 2:
                      Yn = e.A.MEDIA_KEYERR_CLIENT_CODE, $n += "MEDIA_KEYERR_CLIENT - " + e.A.MEDIA_KEYERR_CLIENT_MESSAGE;
                      break;
                    case 3:
                      Yn = e.A.MEDIA_KEYERR_SERVICE_CODE, $n += "MEDIA_KEYERR_SERVICE - " + e.A.MEDIA_KEYERR_SERVICE_MESSAGE;
                      break;
                    case 4:
                      Yn = e.A.MEDIA_KEYERR_OUTPUT_CODE, $n += "MEDIA_KEYERR_OUTPUT - " + e.A.MEDIA_KEYERR_OUTPUT_MESSAGE;
                      break;
                    case 5:
                      Yn = e.A.MEDIA_KEYERR_HARDWARECHANGE_CODE, $n += "MEDIA_KEYERR_HARDWARECHANGE - " + e.A.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;
                      break;
                    case 6:
                      Yn = e.A.MEDIA_KEYERR_DOMAIN_CODE, $n += "MEDIA_KEYERR_DOMAIN - " + e.A.MEDIA_KEYERR_DOMAIN_MESSAGE;
                  }
                  $n += "  System Code = " + ue.systemCode, Re.trigger(pe.KEY_ERROR, { error: new n.A(Yn, $n, Be) });
                } else xe.error("No session token found for key error");
                break;
              case He.keyadded:
                Be = vn(En, ue.sessionId), Be || (Be = vn(Ge, ue.sessionId)), Be ? (xe.debug("DRM: Key added."), Re.trigger(pe.KEY_ADDED, { data: Be })) : xe.debug("No session token found for key added");
                break;
              case He.keymessage:
                if (An = ue.sessionId !== null && ue.sessionId !== void 0, An ? (Be = vn(En, ue.sessionId), !Be && Ge.length > 0 && (Be = Ge.shift(), En.push(Be), Be.sessionId = ue.sessionId, Re.trigger(pe.KEY_SESSION_CREATED, { data: Be }))) : Ge.length > 0 && (Be = Ge.shift(), En.push(Be), Ge.length !== 0 && Je.error(new n.A(e.A.MEDIA_KEY_MESSAGE_ERROR_CODE, e.A.MEDIA_KEY_MESSAGE_ERROR_MESSAGE))), Be) {
                  let Yn = ArrayBuffer.isView(ue.message) ? ue.message.buffer : ue.message;
                  Be.keyMessage = Yn, Re.trigger(pe.INTERNAL_KEY_MESSAGE, { data: new Gt(Be, Yn, ue.defaultURL) });
                } else xe.warn("No session token found for key message");
            }
          } }, tn;
        }
        ce.__dashjs_factory_name = "ProtectionModel_01b";
        var je = ot.A.getClassFactory(ce);
        const ii = [{ generateKeyRequest: "generateKeyRequest", addKey: "addKey", cancelKeyRequest: "cancelKeyRequest", needkey: "needkey", keyerror: "keyerror", keyadded: "keyadded", keymessage: "keymessage" }, { generateKeyRequest: "webkitGenerateKeyRequest", addKey: "webkitAddKey", cancelKeyRequest: "webkitCancelKeyRequest", needkey: "webkitneedkey", keyerror: "webkitkeyerror", keyadded: "webkitkeyadded", keymessage: "webkitkeymessage" }], Wn = [{ setMediaKeys: "setMediaKeys", MediaKeys: "MediaKeys", release: "close", needkey: "needkey", error: "keyerror", message: "keymessage", ready: "keyadded", close: "keyclose" }, { setMediaKeys: "msSetMediaKeys", MediaKeys: "MSMediaKeys", release: "close", needkey: "msneedkey", error: "mskeyerror", message: "mskeymessage", ready: "mskeyadded", close: "mskeyclose" }];
        function Ai() {
          let Ae;
          const Ke = this.context;
          function Re(pe, Ce) {
            for (let He = 0; He < Ce.length; He++) {
              const Je = Ce[He];
              if (typeof pe[Je[Object.keys(Je)[0]]] == "function") return Je;
            }
            return null;
          }
          return Ae = { createProtectionSystem: function(pe) {
            let Ce = null;
            const He = Vt(Ke).getInstance();
            He.setConfig({ debug: pe.debug, BASE64: pe.BASE64, settings: pe.settings }), He.initialize();
            let Je = function(tn) {
              const xe = tn.debug, Se = xe.getLogger(Ae), $e = tn.eventBus, kn = tn.errHandler, Ge = tn.videoModel ? tn.videoModel.getElement() : null;
              return Ge && Ge.onencrypted === void 0 || Ge && Ge.mediaKeys === void 0 ? Re(Ge, Wn) ? (Se.info("EME detected on this user agent! (ProtectionModel_3Feb2014)"), ke(Ke).create({ debug: xe, eventBus: $e, events: tn.events, api: Re(Ge, Wn) })) : Re(Ge, ii) ? (Se.info("EME detected on this user agent! (ProtectionModel_01b)"), je(Ke).create({ debug: xe, eventBus: $e, errHandler: kn, events: tn.events, api: Re(Ge, ii) })) : (Se.warn("No supported version of EME detected on this user agent! - Attempts to play encrypted content will fail!"), null) : (Se.info("EME detected on this user agent! (DefaultProtectionModel"), an(Ke).create({ debug: xe, eventBus: $e, events: tn.events }));
            }(pe);
            return Je && (Ce = xt(Ke).create({ BASE64: pe.BASE64, cmcdModel: pe.cmcdModel, constants: pe.constants, customParametersModel: pe.customParametersModel, debug: pe.debug, eventBus: pe.eventBus, events: pe.events, protectionKeyController: He, protectionModel: Je, settings: pe.settings }), pe.capabilities.setEncryptedMediaSupported(!0)), Ce;
          } }, Ae;
        }
        Ai.__dashjs_factory_name = "Protection";
        const Gn = dashjs.FactoryMaker.getClassFactory(Ai);
        Gn.events = Xt.A, Gn.errors = e.A, dashjs.FactoryMaker.updateClassFactory(Ai.__dashjs_factory_name, Gn);
        var Di = Gn;
      }, 445: function(L, h, b) {
        var A = b(7252);
        class l extends A.A {
          constructor() {
            super(), this.INTERNAL_KEY_MESSAGE = "internalKeyMessage", this.INTERNAL_KEY_STATUSES_CHANGED = "internalkeyStatusesChanged", this.KEY_ADDED = "public_keyAdded", this.KEY_ERROR = "public_keyError", this.KEY_MESSAGE = "public_keyMessage", this.KEY_SESSION_CLOSED = "public_keySessionClosed", this.KEY_SESSION_CREATED = "public_keySessionCreated", this.KEY_SESSION_REMOVED = "public_keySessionRemoved", this.KEY_STATUSES_CHANGED = "public_keyStatusesChanged", this.KEY_STATUSES_MAP_UPDATED = "keyStatusesMapUpdated", this.KEY_SYSTEM_ACCESS_COMPLETE = "public_keySystemAccessComplete", this.KEY_SYSTEM_SELECTED = "public_keySystemSelected", this.LICENSE_REQUEST_COMPLETE = "public_licenseRequestComplete", this.LICENSE_REQUEST_SENDING = "public_licenseRequestSending", this.NEED_KEY = "needkey", this.PROTECTION_CREATED = "public_protectioncreated", this.PROTECTION_DESTROYED = "public_protectiondestroyed", this.SERVER_CERTIFICATE_UPDATED = "serverCertificateUpdated", this.TEARDOWN_COMPLETE = "protectionTeardownComplete", this.VIDEO_ELEMENT_SELECTED = "videoElementSelected", this.KEY_SESSION_UPDATED = "public_keySessionUpdated";
          }
        }
        let o = new l();
        h.A = o;
      }, 1923: function(L, h, b) {
        var A = b(8748);
        class l extends A.A {
          constructor() {
            super(), this.MEDIA_KEYERR_CODE = 100, this.MEDIA_KEYERR_UNKNOWN_CODE = 101, this.MEDIA_KEYERR_CLIENT_CODE = 102, this.MEDIA_KEYERR_SERVICE_CODE = 103, this.MEDIA_KEYERR_OUTPUT_CODE = 104, this.MEDIA_KEYERR_HARDWARECHANGE_CODE = 105, this.MEDIA_KEYERR_DOMAIN_CODE = 106, this.MEDIA_KEY_MESSAGE_ERROR_CODE = 107, this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_CODE = 108, this.SERVER_CERTIFICATE_UPDATED_ERROR_CODE = 109, this.KEY_STATUS_CHANGED_EXPIRED_ERROR_CODE = 110, this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE = 111, this.KEY_SYSTEM_ACCESS_DENIED_ERROR_CODE = 112, this.KEY_SESSION_CREATED_ERROR_CODE = 113, this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_CODE = 114, this.MEDIA_KEYERR_UNKNOWN_MESSAGE = "An unspecified error occurred. This value is used for errors that don't match any of the other codes.", this.MEDIA_KEYERR_CLIENT_MESSAGE = "The Key System could not be installed or updated.", this.MEDIA_KEYERR_SERVICE_MESSAGE = "The message passed into update indicated an error from the license service.", this.MEDIA_KEYERR_OUTPUT_MESSAGE = "There is no available output device with the required characteristics for the content protection system.", this.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE = "A hardware configuration change caused a content protection error.", this.MEDIA_KEYERR_DOMAIN_MESSAGE = "An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.", this.MEDIA_KEY_MESSAGE_ERROR_MESSAGE = "Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!", this.MEDIA_KEY_MESSAGE_NO_CHALLENGE_ERROR_MESSAGE = "DRM: Empty key message from CDM", this.SERVER_CERTIFICATE_UPDATED_ERROR_MESSAGE = "Error updating server certificate -- ", this.KEY_STATUS_CHANGED_EXPIRED_ERROR_MESSAGE = "DRM: KeyStatusChange error! -- License has expired", this.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_MESSAGE = "DRM: No license server URL specified!", this.KEY_SYSTEM_ACCESS_DENIED_ERROR_MESSAGE = "DRM: KeySystem Access Denied! -- ", this.KEY_SESSION_CREATED_ERROR_MESSAGE = "DRM: unable to create session! --", this.MEDIA_KEY_MESSAGE_LICENSER_ERROR_MESSAGE = "DRM: licenser error! --";
          }
        }
        let o = new l();
        h.A = o;
      }, 559: function(L, h, b) {
        b.d(h, { a: function() {
          return m;
        } });
        var A = b(138), l = b(5212), o = b(2861), u = b(7393), g = b(649);
        function m() {
          let e = "ManagedMediaSource" in window, n = "WebKitMediaSource" in window, d = "MediaSource" in window;
          return e || n || d;
        }
        function S() {
          let e, n, d, _, p, P;
          const $ = this.context, ot = (0, u.A)($).getInstance();
          function dt(q, I) {
            let pt;
            I === l.A.VIDEO ? pt = function(et) {
              const Dt = { video: {} };
              return et && (et.width && (Dt.video.width = et.width), et.height && (Dt.video.height = et.height), et.framerate && (Dt.video.framerate = parseFloat(et.framerate)), et.hdrMetadataType && (Dt.video.hdrMetadataType = et.hdrMetadataType), et.colorGamut && (Dt.video.colorGamut = et.colorGamut), et.transferFunction && (Dt.video.transferFunction = et.transferFunction)), Dt;
            }(q) : I === l.A.AUDIO && (pt = function(et) {
              const Dt = { audio: {} };
              return et.samplerate && (Dt.audio.samplerate = et.samplerate), Dt;
            }(q)), pt[I].contentType = q.codec, pt[I].bitrate = parseInt(q.bitrate), pt.type = "media-source";
            let It = q.codec;
            return q.width && q.height && (It += ';width="' + q.width + '";height="' + q.height + '"'), pt.mediaSourceCodecString = It, function(et, Dt, ae) {
              return Dt && Dt.keySystemsMetadata && Dt.keySystemsMetadata.length !== 0 ? Dt.keySystemsMetadata.map((St) => {
                const qe = { ...et };
                if (St.ks) {
                  qe.keySystemConfiguration = {}, St.ks.systemString && (qe.keySystemConfiguration.keySystem = St.ks.systemString);
                  let zt = "";
                  St.ks.systemString === o.A.WIDEVINE_KEYSTEM_STRING && (zt = o.A.ROBUSTNESS_STRINGS.WIDEVINE.SW_SECURE_CRYPTO);
                  const Ct = St.protData, de = Ct && Ct.audioRobustness && Ct.audioRobustness.length > 0 ? Ct.audioRobustness : zt, ze = Ct && Ct.videoRobustness && Ct.videoRobustness.length > 0 ? Ct.videoRobustness : zt;
                  ae === l.A.AUDIO ? qe.keySystemConfiguration[ae] = { robustness: de } : ae === l.A.VIDEO && (qe.keySystemConfiguration[ae] = { robustness: ze });
                }
                return qe;
              }) : [et];
            }(pt, q, I);
          }
          function xt(q) {
            if (_ && _.length !== 0 && q) return _.find((I) => {
              const pt = Nt(q, I, l.A.AUDIO), It = Nt(q, I, l.A.VIDEO), et = Nt(q, I, "keySystemConfiguration");
              return pt && It && et;
            });
          }
          function Nt(q, I, pt) {
            return !q[pt] && !I[pt] || !(!q[pt] || !I[pt]) && ot.areEqual(q[pt], I[pt]);
          }
          function jt(q, I) {
            return (q = q.filter((pt) => !(pt.schemeIdUri && I.some((It) => It.schemeIdUri === pt.schemeIdUri)))).push(...I), q;
          }
          return e = { areKeyIdsExpired: function(q) {
            return !!(d && q && q.normalizedKeyIds && q.normalizedKeyIds.size !== 0) && d.areKeyIdsExpired(q.normalizedKeyIds);
          }, areKeyIdsUsable: function(q) {
            return !(d && q && q.normalizedKeyIds && q.normalizedKeyIds.size !== 0) || d.areKeyIdsUsable(q.normalizedKeyIds);
          }, isCodecSupportedBasedOnTestedConfigurations: function(q, I) {
            if (!q || !q.codec || q.isSupported === !1) return !1;
            const pt = dt(q, I).map((It) => xt(It)).filter((It) => It != null);
            return !(pt && pt.length > 0) || function(It) {
              return It.some((et) => et && et.decodingInfo && et.decodingInfo.supported);
            }(pt);
          }, isProtectionCompatible: function(q, I) {
            return !I || !(!q.isEncrypted && I.isEncrypted);
          }, runCodecSupportCheck: function(q, I) {
            if (I !== l.A.AUDIO && I !== l.A.VIDEO && I !== l.A.MESH) return Promise.resolve();
            const pt = dt(q, I);
            return function(It, et) {
              return n.get().streaming.capabilities.useMediaCapabilitiesApi && navigator.mediaCapabilities && navigator.mediaCapabilities.decodingInfo && (It.codec && et === l.A.AUDIO || et === l.A.VIDEO && It.codec && It.width && It.height && It.bitrate && It.framerate);
            }(q, I) ? function(It) {
              return new Promise((et) => {
                if (!It || It.length === 0) return void et();
                const Dt = It.map((ae) => function(St) {
                  return new Promise((qe) => {
                    xt(St) ? qe() : navigator.mediaCapabilities.decodingInfo(St).then((zt) => {
                      St.decodingInfo = zt, _.push(St), qe();
                    }).catch((zt) => {
                      St.decodingInfo = { supported: !1 }, _.push(St), P.error(zt), qe();
                    });
                  });
                }(ae));
                Promise.allSettled(Dt).then(() => {
                  et();
                }).catch((ae) => {
                  P.error(ae), et();
                });
              });
            }(pt) : (function(It) {
              if (!It || !It.length) return;
              const et = It[0];
              if (xt(et)) return;
              let Dt = { supported: !1 };
              ("ManagedMediaSource" in window && ManagedMediaSource.isTypeSupported(et.mediaSourceCodecString) || "MediaSource" in window && MediaSource.isTypeSupported(et.mediaSourceCodecString) || "WebKitMediaSource" in window && WebKitMediaSource.isTypeSupported(et.mediaSourceCodecString)) && (Dt.supported = !0), et.decodingInfo = Dt, _.push(et);
            }(pt), Promise.resolve());
          }, setConfig: function(q) {
            q && (q.settings && (n = q.settings), q.protectionController && (d = q.protectionController));
          }, setEncryptedMediaSupported: function(q) {
            p = q;
          }, setProtectionController: function(q) {
            d = q;
          }, supportsChangeType: function() {
            return !!window.SourceBuffer && !!SourceBuffer.prototype && !!SourceBuffer.prototype.changeType;
          }, supportsEncryptedMedia: function() {
            return p;
          }, supportsEssentialProperty: function(q) {
            let I = n.get().streaming.capabilities.supportedEssentialProperties;
            n.get().streaming.capabilities.useMediaCapabilitiesApi && n.get().streaming.capabilities.filterVideoColorimetryEssentialProperties && (I = jt(I, [{ schemeIdUri: l.A.COLOUR_PRIMARIES_SCHEME_ID_URI }, { schemeIdUri: l.A.MATRIX_COEFFICIENTS_SCHEME_ID_URI }, { schemeIdUri: l.A.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI }])), n.get().streaming.capabilities.useMediaCapabilitiesApi && n.get().streaming.capabilities.filterHDRMetadataFormatEssentialProperties && (I = jt(I, [{ schemeIdUri: l.A.HDR_METADATA_FORMAT_SCHEME_ID_URI }]));
            try {
              return q.inArray(I);
            } catch {
              return !0;
            }
          }, supportsMediaSource: m }, p = !1, _ = [], P = (0, g.A)($).getInstance().getLogger(e), e;
        }
        S.__dashjs_factory_name = "Capabilities", h.A = A.A.getSingletonFactory(S);
      }, 7377: function(L, h, b) {
        var A = b(138), l = b(656);
        function o() {
          return { customTimeRangeArray: [], length: 0, add: function(u, g) {
            let m;
            for (m = 0; m < this.customTimeRangeArray.length && u > this.customTimeRangeArray[m].start; m++) ;
            for (this.customTimeRangeArray.splice(m, 0, { start: u, end: g }), m = 0; m < this.customTimeRangeArray.length - 1; m++) this.mergeRanges(m, m + 1) && m--;
            this.length = this.customTimeRangeArray.length;
          }, clear: function() {
            this.customTimeRangeArray = [], this.length = 0;
          }, remove: function(u, g) {
            for (let m = 0; m < this.customTimeRangeArray.length; m++) if (u <= this.customTimeRangeArray[m].start && g >= this.customTimeRangeArray[m].end) this.customTimeRangeArray.splice(m, 1), m--;
            else {
              if (u > this.customTimeRangeArray[m].start && g < this.customTimeRangeArray[m].end) {
                this.customTimeRangeArray.splice(m + 1, 0, { start: g, end: this.customTimeRangeArray[m].end }), this.customTimeRangeArray[m].end = u;
                break;
              }
              u > this.customTimeRangeArray[m].start && u < this.customTimeRangeArray[m].end ? this.customTimeRangeArray[m].end = u : g > this.customTimeRangeArray[m].start && g < this.customTimeRangeArray[m].end && (this.customTimeRangeArray[m].start = g);
            }
            this.length = this.customTimeRangeArray.length;
          }, mergeRanges: function(u, g) {
            let m = this.customTimeRangeArray[u], S = this.customTimeRangeArray[g];
            return m.start <= S.start && S.start <= m.end && m.end <= S.end ? (m.end = S.end, this.customTimeRangeArray.splice(g, 1), !0) : S.start <= m.start && m.start <= S.end && S.end <= m.end ? (m.start = S.start, this.customTimeRangeArray.splice(g, 1), !0) : S.start <= m.start && m.start <= S.end && m.end <= S.end ? (this.customTimeRangeArray.splice(u, 1), !0) : m.start <= S.start && S.start <= m.end && S.end <= m.end && (this.customTimeRangeArray.splice(g, 1), !0);
          }, start: function(u) {
            return (0, l.zQ)(u), u >= this.customTimeRangeArray.length || u < 0 ? NaN : this.customTimeRangeArray[u].start;
          }, end: function(u) {
            return (0, l.zQ)(u), u >= this.customTimeRangeArray.length || u < 0 ? NaN : this.customTimeRangeArray[u].end;
          } };
        }
        o.__dashjs_factory_name = "CustomTimeRanges", h.A = A.A.getClassFactory(o);
      }, 7393: function(L, h, b) {
        var A = b(138), l = b(7316);
        function o() {
          let u;
          return u = { areEqual: function(g, m) {
            return l(g, m);
          } }, u;
        }
        o.__dashjs_factory_name = "ObjectUtils", h.A = A.A.getSingletonFactory(o);
      }, 656: function(L, h, b) {
        b.d(h, { sq: function() {
          return l;
        }, zQ: function() {
          return o;
        } });
        var A = b(5212);
        function l(u, g) {
          if (typeof u !== g) throw A.A.BAD_ARGUMENT_ERROR;
        }
        function o(u) {
          if (u === null || isNaN(u) || u % 1 != 0) throw A.A.BAD_ARGUMENT_ERROR + " : argument is not an integer";
        }
      }, 1944: function(L, h) {
        h.A = class {
          constructor(b, A, l) {
            this.code = b || null, this.message = A || null, this.data = l || null;
          }
        };
      }, 7568: function(L, h, b) {
        b.d(h, { G: function() {
          return A;
        }, N: function() {
          return l;
        } });
        class A {
          constructor() {
            this.tcpid = null, this.type = null, this.url = null, this.actualurl = null, this.range = null, this.trequest = null, this.tresponse = null, this.responsecode = null, this.interval = null, this.trace = [], this.cmsd = null, this._stream = null, this._tfinish = null, this._mediaduration = null, this._quality = null, this._responseHeaders = null, this._serviceLocation = null, this._fileLoaderType = null, this._resourceTimingValues = null;
          }
        }
        class l {
          constructor() {
            this.s = null, this.d = null, this.b = [];
          }
        }
        A.GET = "GET", A.HEAD = "HEAD", A.MPD_TYPE = "MPD", A.XLINK_EXPANSION_TYPE = "XLinkExpansion", A.INIT_SEGMENT_TYPE = "InitializationSegment", A.INDEX_SEGMENT_TYPE = "IndexSegment", A.MEDIA_SEGMENT_TYPE = "MediaSegment", A.BITSTREAM_SWITCHING_SEGMENT_TYPE = "BitstreamSwitchingSegment", A.MSS_FRAGMENT_INFO_SEGMENT_TYPE = "FragmentInfoSegment", A.DVB_REPORTING_TYPE = "DVBReporting", A.LICENSE = "license", A.CONTENT_STEERING_TYPE = "ContentSteering", A.OTHER_TYPE = "other";
      } }, c = {};
      function w(L) {
        var h = c[L];
        if (h !== void 0) return h.exports;
        var b = c[L] = { id: L, loaded: !1, exports: {} };
        return r[L].call(b.exports, b, b.exports, w), b.loaded = !0, b.exports;
      }
      w.amdO = {}, w.d = function(L, h) {
        for (var b in h) w.o(h, b) && !w.o(L, b) && Object.defineProperty(L, b, { enumerable: !0, get: h[b] });
      }, w.g = function() {
        if (typeof globalThis == "object") return globalThis;
        try {
          return this || new Function("return this")();
        } catch {
          if (typeof window == "object") return window;
        }
      }(), w.o = function(L, h) {
        return Object.prototype.hasOwnProperty.call(L, h);
      }, w.nmd = function(L) {
        return L.paths = [], L.children || (L.children = []), L;
      };
      var R = {};
      return function() {
        w.d(R, { default: function() {
          return S;
        } }), w(5393);
        var L = w(4469), h = w(3888), b = w(6161);
        let A, l = /* @__PURE__ */ function() {
          const e = "application/dash+xml";
          let n;
          function d(p, P, $) {
            if (!p || !/^VIDEO$/i.test(p.nodeName)) return null;
            if (p._dashjs_player) return p._dashjs_player;
            let ot, dt = p.id || p.name || "video element";
            if (!(P = P || [].slice.call(p.querySelectorAll("source")).filter(function(xt) {
              return xt.type == e;
            })[0]) && p.src) (P = document.createElement("source")).src = p.src;
            else if (!P && !p.src) return null;
            return $ = $ || {}, ot = (0, b.A)($).create(), ot.initialize(p, P.src, p.autoplay), n || (n = ot.getDebug().getLogger()), n.debug("Converted " + dt + " to dash.js player and added content: " + P.src), p._dashjs_player = ot, ot;
          }
          function _(p) {
            return /^VIDEO$/i.test(p.nodeName) ? p : _(p.parentNode);
          }
          return { create: d, createAll: function(p, P) {
            let $ = [];
            p = p || "[data-dashjs-player]";
            let ot = (P = P || document).querySelectorAll(p);
            for (let xt = 0; xt < ot.length; xt++) {
              let Nt = d(ot[xt], null);
              $.push(Nt);
            }
            let dt = P.querySelectorAll('source[type="' + e + '"]');
            for (let xt = 0; xt < dt.length; xt++) {
              let Nt = d(_(dt[xt]), null);
              $.push(Nt);
            }
            return $;
          } };
        }();
        !(typeof window < "u" && window && window.dashjs && window.dashjs.skipAutoCreate) && typeof window < "u" && window && window.addEventListener && (window.document.readyState === "complete" ? window.dashjs ? l.createAll() : A = window.setInterval(function() {
          window.dashjs && (window.clearInterval(A), l.createAll());
        }, 500) : window.addEventListener("load", function e() {
          window.removeEventListener("load", e), l.createAll();
        }));
        var o = l, u = w(649), g = w(5212), m = w(559);
        dashjs.Protection = h.default, dashjs.MetricsReporting = L.default, dashjs.MediaPlayerFactory = o, dashjs.Debug = u.A, dashjs.supportsMediaSource = m.a, dashjs.Constants = g.A;
        var S = dashjs;
      }(), R.default;
    }();
  });
})(Uu, Uu.exports);
var _i = Uu.exports, On = {}, ju = { exports: {} }, li = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qc;
function wg() {
  if (qc) return li;
  qc = 1;
  var Et = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), w = Symbol.for("react.profiler"), R = Symbol.for("react.provider"), L = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), b = Symbol.for("react.suspense"), A = Symbol.for("react.memo"), l = Symbol.for("react.lazy"), o = Symbol.iterator;
  function u(zt) {
    return zt === null || typeof zt != "object" ? null : (zt = o && zt[o] || zt["@@iterator"], typeof zt == "function" ? zt : null);
  }
  var g = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, m = Object.assign, S = {};
  function e(zt, Ct, de) {
    this.props = zt, this.context = Ct, this.refs = S, this.updater = de || g;
  }
  e.prototype.isReactComponent = {}, e.prototype.setState = function(zt, Ct) {
    if (typeof zt != "object" && typeof zt != "function" && zt != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, zt, Ct, "setState");
  }, e.prototype.forceUpdate = function(zt) {
    this.updater.enqueueForceUpdate(this, zt, "forceUpdate");
  };
  function n() {
  }
  n.prototype = e.prototype;
  function d(zt, Ct, de) {
    this.props = zt, this.context = Ct, this.refs = S, this.updater = de || g;
  }
  var _ = d.prototype = new n();
  _.constructor = d, m(_, e.prototype), _.isPureReactComponent = !0;
  var p = Array.isArray, P = Object.prototype.hasOwnProperty, $ = { current: null }, ot = { key: !0, ref: !0, __self: !0, __source: !0 };
  function dt(zt, Ct, de) {
    var ze, le = {}, Ze = null, me = null;
    if (Ct != null) for (ze in Ct.ref !== void 0 && (me = Ct.ref), Ct.key !== void 0 && (Ze = "" + Ct.key), Ct) P.call(Ct, ze) && !ot.hasOwnProperty(ze) && (le[ze] = Ct[ze]);
    var bn = arguments.length - 2;
    if (bn === 1) le.children = de;
    else if (1 < bn) {
      for (var pn = Array(bn), wn = 0; wn < bn; wn++) pn[wn] = arguments[wn + 2];
      le.children = pn;
    }
    if (zt && zt.defaultProps) for (ze in bn = zt.defaultProps, bn) le[ze] === void 0 && (le[ze] = bn[ze]);
    return { $$typeof: Et, type: zt, key: Ze, ref: me, props: le, _owner: $.current };
  }
  function xt(zt, Ct) {
    return { $$typeof: Et, type: zt.type, key: Ct, ref: zt.ref, props: zt.props, _owner: zt._owner };
  }
  function Nt(zt) {
    return typeof zt == "object" && zt !== null && zt.$$typeof === Et;
  }
  function jt(zt) {
    var Ct = { "=": "=0", ":": "=2" };
    return "$" + zt.replace(/[=:]/g, function(de) {
      return Ct[de];
    });
  }
  var q = /\/+/g;
  function I(zt, Ct) {
    return typeof zt == "object" && zt !== null && zt.key != null ? jt("" + zt.key) : Ct.toString(36);
  }
  function pt(zt, Ct, de, ze, le) {
    var Ze = typeof zt;
    (Ze === "undefined" || Ze === "boolean") && (zt = null);
    var me = !1;
    if (zt === null) me = !0;
    else switch (Ze) {
      case "string":
      case "number":
        me = !0;
        break;
      case "object":
        switch (zt.$$typeof) {
          case Et:
          case t:
            me = !0;
        }
    }
    if (me) return me = zt, le = le(me), zt = ze === "" ? "." + I(me, 0) : ze, p(le) ? (de = "", zt != null && (de = zt.replace(q, "$&/") + "/"), pt(le, Ct, de, "", function(wn) {
      return wn;
    })) : le != null && (Nt(le) && (le = xt(le, de + (!le.key || me && me.key === le.key ? "" : ("" + le.key).replace(q, "$&/") + "/") + zt)), Ct.push(le)), 1;
    if (me = 0, ze = ze === "" ? "." : ze + ":", p(zt)) for (var bn = 0; bn < zt.length; bn++) {
      Ze = zt[bn];
      var pn = ze + I(Ze, bn);
      me += pt(Ze, Ct, de, pn, le);
    }
    else if (pn = u(zt), typeof pn == "function") for (zt = pn.call(zt), bn = 0; !(Ze = zt.next()).done; ) Ze = Ze.value, pn = ze + I(Ze, bn++), me += pt(Ze, Ct, de, pn, le);
    else if (Ze === "object") throw Ct = String(zt), Error("Objects are not valid as a React child (found: " + (Ct === "[object Object]" ? "object with keys {" + Object.keys(zt).join(", ") + "}" : Ct) + "). If you meant to render a collection of children, use an array instead.");
    return me;
  }
  function It(zt, Ct, de) {
    if (zt == null) return zt;
    var ze = [], le = 0;
    return pt(zt, ze, "", "", function(Ze) {
      return Ct.call(de, Ze, le++);
    }), ze;
  }
  function et(zt) {
    if (zt._status === -1) {
      var Ct = zt._result;
      Ct = Ct(), Ct.then(function(de) {
        (zt._status === 0 || zt._status === -1) && (zt._status = 1, zt._result = de);
      }, function(de) {
        (zt._status === 0 || zt._status === -1) && (zt._status = 2, zt._result = de);
      }), zt._status === -1 && (zt._status = 0, zt._result = Ct);
    }
    if (zt._status === 1) return zt._result.default;
    throw zt._result;
  }
  var Dt = { current: null }, ae = { transition: null }, St = { ReactCurrentDispatcher: Dt, ReactCurrentBatchConfig: ae, ReactCurrentOwner: $ };
  function qe() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return li.Children = { map: It, forEach: function(zt, Ct, de) {
    It(zt, function() {
      Ct.apply(this, arguments);
    }, de);
  }, count: function(zt) {
    var Ct = 0;
    return It(zt, function() {
      Ct++;
    }), Ct;
  }, toArray: function(zt) {
    return It(zt, function(Ct) {
      return Ct;
    }) || [];
  }, only: function(zt) {
    if (!Nt(zt)) throw Error("React.Children.only expected to receive a single React element child.");
    return zt;
  } }, li.Component = e, li.Fragment = r, li.Profiler = w, li.PureComponent = d, li.StrictMode = c, li.Suspense = b, li.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = St, li.act = qe, li.cloneElement = function(zt, Ct, de) {
    if (zt == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + zt + ".");
    var ze = m({}, zt.props), le = zt.key, Ze = zt.ref, me = zt._owner;
    if (Ct != null) {
      if (Ct.ref !== void 0 && (Ze = Ct.ref, me = $.current), Ct.key !== void 0 && (le = "" + Ct.key), zt.type && zt.type.defaultProps) var bn = zt.type.defaultProps;
      for (pn in Ct) P.call(Ct, pn) && !ot.hasOwnProperty(pn) && (ze[pn] = Ct[pn] === void 0 && bn !== void 0 ? bn[pn] : Ct[pn]);
    }
    var pn = arguments.length - 2;
    if (pn === 1) ze.children = de;
    else if (1 < pn) {
      bn = Array(pn);
      for (var wn = 0; wn < pn; wn++) bn[wn] = arguments[wn + 2];
      ze.children = bn;
    }
    return { $$typeof: Et, type: zt.type, key: le, ref: Ze, props: ze, _owner: me };
  }, li.createContext = function(zt) {
    return zt = { $$typeof: L, _currentValue: zt, _currentValue2: zt, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, zt.Provider = { $$typeof: R, _context: zt }, zt.Consumer = zt;
  }, li.createElement = dt, li.createFactory = function(zt) {
    var Ct = dt.bind(null, zt);
    return Ct.type = zt, Ct;
  }, li.createRef = function() {
    return { current: null };
  }, li.forwardRef = function(zt) {
    return { $$typeof: h, render: zt };
  }, li.isValidElement = Nt, li.lazy = function(zt) {
    return { $$typeof: l, _payload: { _status: -1, _result: zt }, _init: et };
  }, li.memo = function(zt, Ct) {
    return { $$typeof: A, type: zt, compare: Ct === void 0 ? null : Ct };
  }, li.startTransition = function(zt) {
    var Ct = ae.transition;
    ae.transition = {};
    try {
      zt();
    } finally {
      ae.transition = Ct;
    }
  }, li.unstable_act = qe, li.useCallback = function(zt, Ct) {
    return Dt.current.useCallback(zt, Ct);
  }, li.useContext = function(zt) {
    return Dt.current.useContext(zt);
  }, li.useDebugValue = function() {
  }, li.useDeferredValue = function(zt) {
    return Dt.current.useDeferredValue(zt);
  }, li.useEffect = function(zt, Ct) {
    return Dt.current.useEffect(zt, Ct);
  }, li.useId = function() {
    return Dt.current.useId();
  }, li.useImperativeHandle = function(zt, Ct, de) {
    return Dt.current.useImperativeHandle(zt, Ct, de);
  }, li.useInsertionEffect = function(zt, Ct) {
    return Dt.current.useInsertionEffect(zt, Ct);
  }, li.useLayoutEffect = function(zt, Ct) {
    return Dt.current.useLayoutEffect(zt, Ct);
  }, li.useMemo = function(zt, Ct) {
    return Dt.current.useMemo(zt, Ct);
  }, li.useReducer = function(zt, Ct, de) {
    return Dt.current.useReducer(zt, Ct, de);
  }, li.useRef = function(zt) {
    return Dt.current.useRef(zt);
  }, li.useState = function(zt) {
    return Dt.current.useState(zt);
  }, li.useSyncExternalStore = function(zt, Ct, de) {
    return Dt.current.useSyncExternalStore(zt, Ct, de);
  }, li.useTransition = function() {
    return Dt.current.useTransition();
  }, li.version = "18.3.1", li;
}
var Eo = { exports: {} };
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Eo.exports;
var Gc;
function Ag() {
  return Gc || (Gc = 1, function(Et, t) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var r = "18.3.1", c = Symbol.for("react.element"), w = Symbol.for("react.portal"), R = Symbol.for("react.fragment"), L = Symbol.for("react.strict_mode"), h = Symbol.for("react.profiler"), b = Symbol.for("react.provider"), A = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), o = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), g = Symbol.for("react.memo"), m = Symbol.for("react.lazy"), S = Symbol.for("react.offscreen"), e = Symbol.iterator, n = "@@iterator";
      function d(kt) {
        if (kt === null || typeof kt != "object")
          return null;
        var Kt = e && kt[e] || kt[n];
        return typeof Kt == "function" ? Kt : null;
      }
      var _ = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, p = {
        transition: null
      }, P = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, $ = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, ot = {}, dt = null;
      function xt(kt) {
        dt = kt;
      }
      ot.setExtraStackFrame = function(kt) {
        dt = kt;
      }, ot.getCurrentStack = null, ot.getStackAddendum = function() {
        var kt = "";
        dt && (kt += dt);
        var Kt = ot.getCurrentStack;
        return Kt && (kt += Kt() || ""), kt;
      };
      var Nt = !1, jt = !1, q = !1, I = !1, pt = !1, It = {
        ReactCurrentDispatcher: _,
        ReactCurrentBatchConfig: p,
        ReactCurrentOwner: $
      };
      It.ReactDebugCurrentFrame = ot, It.ReactCurrentActQueue = P;
      function et(kt) {
        {
          for (var Kt = arguments.length, we = new Array(Kt > 1 ? Kt - 1 : 0), Oe = 1; Oe < Kt; Oe++)
            we[Oe - 1] = arguments[Oe];
          ae("warn", kt, we);
        }
      }
      function Dt(kt) {
        {
          for (var Kt = arguments.length, we = new Array(Kt > 1 ? Kt - 1 : 0), Oe = 1; Oe < Kt; Oe++)
            we[Oe - 1] = arguments[Oe];
          ae("error", kt, we);
        }
      }
      function ae(kt, Kt, we) {
        {
          var Oe = It.ReactDebugCurrentFrame, yn = Oe.getStackAddendum();
          yn !== "" && (Kt += "%s", we = we.concat([yn]));
          var Hn = we.map(function(Pn) {
            return String(Pn);
          });
          Hn.unshift("Warning: " + Kt), Function.prototype.apply.call(console[kt], console, Hn);
        }
      }
      var St = {};
      function qe(kt, Kt) {
        {
          var we = kt.constructor, Oe = we && (we.displayName || we.name) || "ReactClass", yn = Oe + "." + Kt;
          if (St[yn])
            return;
          Dt("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", Kt, Oe), St[yn] = !0;
        }
      }
      var zt = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(kt) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(kt, Kt, we) {
          qe(kt, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(kt, Kt, we, Oe) {
          qe(kt, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(kt, Kt, we, Oe) {
          qe(kt, "setState");
        }
      }, Ct = Object.assign, de = {};
      Object.freeze(de);
      function ze(kt, Kt, we) {
        this.props = kt, this.context = Kt, this.refs = de, this.updater = we || zt;
      }
      ze.prototype.isReactComponent = {}, ze.prototype.setState = function(kt, Kt) {
        if (typeof kt != "object" && typeof kt != "function" && kt != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, kt, Kt, "setState");
      }, ze.prototype.forceUpdate = function(kt) {
        this.updater.enqueueForceUpdate(this, kt, "forceUpdate");
      };
      {
        var le = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, Ze = function(kt, Kt) {
          Object.defineProperty(ze.prototype, kt, {
            get: function() {
              et("%s(...) is deprecated in plain JavaScript React classes. %s", Kt[0], Kt[1]);
            }
          });
        };
        for (var me in le)
          le.hasOwnProperty(me) && Ze(me, le[me]);
      }
      function bn() {
      }
      bn.prototype = ze.prototype;
      function pn(kt, Kt, we) {
        this.props = kt, this.context = Kt, this.refs = de, this.updater = we || zt;
      }
      var wn = pn.prototype = new bn();
      wn.constructor = pn, Ct(wn, ze.prototype), wn.isPureReactComponent = !0;
      function Yt() {
        var kt = {
          current: null
        };
        return Object.seal(kt), kt;
      }
      var Ht = Array.isArray;
      function Me(kt) {
        return Ht(kt);
      }
      function X(kt) {
        {
          var Kt = typeof Symbol == "function" && Symbol.toStringTag, we = Kt && kt[Symbol.toStringTag] || kt.constructor.name || "Object";
          return we;
        }
      }
      function Q(kt) {
        try {
          return C(kt), !1;
        } catch {
          return !0;
        }
      }
      function C(kt) {
        return "" + kt;
      }
      function U(kt) {
        if (Q(kt))
          return Dt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", X(kt)), C(kt);
      }
      function gt(kt, Kt, we) {
        var Oe = kt.displayName;
        if (Oe)
          return Oe;
        var yn = Kt.displayName || Kt.name || "";
        return yn !== "" ? we + "(" + yn + ")" : we;
      }
      function rt(kt) {
        return kt.displayName || "Context";
      }
      function Ft(kt) {
        if (kt == null)
          return null;
        if (typeof kt.tag == "number" && Dt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof kt == "function")
          return kt.displayName || kt.name || null;
        if (typeof kt == "string")
          return kt;
        switch (kt) {
          case R:
            return "Fragment";
          case w:
            return "Portal";
          case h:
            return "Profiler";
          case L:
            return "StrictMode";
          case o:
            return "Suspense";
          case u:
            return "SuspenseList";
        }
        if (typeof kt == "object")
          switch (kt.$$typeof) {
            case A:
              var Kt = kt;
              return rt(Kt) + ".Consumer";
            case b:
              var we = kt;
              return rt(we._context) + ".Provider";
            case l:
              return gt(kt, kt.render, "ForwardRef");
            case g:
              var Oe = kt.displayName || null;
              return Oe !== null ? Oe : Ft(kt.type) || "Memo";
            case m: {
              var yn = kt, Hn = yn._payload, Pn = yn._init;
              try {
                return Ft(Pn(Hn));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var ne = Object.prototype.hasOwnProperty, Vt = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, Xt, qt, Gt;
      Gt = {};
      function se(kt) {
        if (ne.call(kt, "ref")) {
          var Kt = Object.getOwnPropertyDescriptor(kt, "ref").get;
          if (Kt && Kt.isReactWarning)
            return !1;
        }
        return kt.ref !== void 0;
      }
      function Jt(kt) {
        if (ne.call(kt, "key")) {
          var Kt = Object.getOwnPropertyDescriptor(kt, "key").get;
          if (Kt && Kt.isReactWarning)
            return !1;
        }
        return kt.key !== void 0;
      }
      function he(kt, Kt) {
        var we = function() {
          Xt || (Xt = !0, Dt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Kt));
        };
        we.isReactWarning = !0, Object.defineProperty(kt, "key", {
          get: we,
          configurable: !0
        });
      }
      function an(kt, Kt) {
        var we = function() {
          qt || (qt = !0, Dt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Kt));
        };
        we.isReactWarning = !0, Object.defineProperty(kt, "ref", {
          get: we,
          configurable: !0
        });
      }
      function Fe(kt) {
        if (typeof kt.ref == "string" && $.current && kt.__self && $.current.stateNode !== kt.__self) {
          var Kt = Ft($.current.type);
          Gt[Kt] || (Dt('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', Kt, kt.ref), Gt[Kt] = !0);
        }
      }
      var ke = function(kt, Kt, we, Oe, yn, Hn, Pn) {
        var Vn = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: c,
          // Built-in properties that belong on the element
          type: kt,
          key: Kt,
          ref: we,
          props: Pn,
          // Record the component responsible for creating this element.
          _owner: Hn
        };
        return Vn._store = {}, Object.defineProperty(Vn._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(Vn, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Oe
        }), Object.defineProperty(Vn, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: yn
        }), Object.freeze && (Object.freeze(Vn.props), Object.freeze(Vn)), Vn;
      };
      function ce(kt, Kt, we) {
        var Oe, yn = {}, Hn = null, Pn = null, Vn = null, ri = null;
        if (Kt != null) {
          se(Kt) && (Pn = Kt.ref, Fe(Kt)), Jt(Kt) && (U(Kt.key), Hn = "" + Kt.key), Vn = Kt.__self === void 0 ? null : Kt.__self, ri = Kt.__source === void 0 ? null : Kt.__source;
          for (Oe in Kt)
            ne.call(Kt, Oe) && !Vt.hasOwnProperty(Oe) && (yn[Oe] = Kt[Oe]);
        }
        var pi = arguments.length - 2;
        if (pi === 1)
          yn.children = we;
        else if (pi > 1) {
          for (var Bn = Array(pi), Ti = 0; Ti < pi; Ti++)
            Bn[Ti] = arguments[Ti + 2];
          Object.freeze && Object.freeze(Bn), yn.children = Bn;
        }
        if (kt && kt.defaultProps) {
          var ei = kt.defaultProps;
          for (Oe in ei)
            yn[Oe] === void 0 && (yn[Oe] = ei[Oe]);
        }
        if (Hn || Pn) {
          var Si = typeof kt == "function" ? kt.displayName || kt.name || "Unknown" : kt;
          Hn && he(yn, Si), Pn && an(yn, Si);
        }
        return ke(kt, Hn, Pn, Vn, ri, $.current, yn);
      }
      function je(kt, Kt) {
        var we = ke(kt.type, Kt, kt.ref, kt._self, kt._source, kt._owner, kt.props);
        return we;
      }
      function ii(kt, Kt, we) {
        if (kt == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + kt + ".");
        var Oe, yn = Ct({}, kt.props), Hn = kt.key, Pn = kt.ref, Vn = kt._self, ri = kt._source, pi = kt._owner;
        if (Kt != null) {
          se(Kt) && (Pn = Kt.ref, pi = $.current), Jt(Kt) && (U(Kt.key), Hn = "" + Kt.key);
          var Bn;
          kt.type && kt.type.defaultProps && (Bn = kt.type.defaultProps);
          for (Oe in Kt)
            ne.call(Kt, Oe) && !Vt.hasOwnProperty(Oe) && (Kt[Oe] === void 0 && Bn !== void 0 ? yn[Oe] = Bn[Oe] : yn[Oe] = Kt[Oe]);
        }
        var Ti = arguments.length - 2;
        if (Ti === 1)
          yn.children = we;
        else if (Ti > 1) {
          for (var ei = Array(Ti), Si = 0; Si < Ti; Si++)
            ei[Si] = arguments[Si + 2];
          yn.children = ei;
        }
        return ke(kt.type, Hn, Pn, Vn, ri, pi, yn);
      }
      function Wn(kt) {
        return typeof kt == "object" && kt !== null && kt.$$typeof === c;
      }
      var Ai = ".", Gn = ":";
      function Di(kt) {
        var Kt = /[=:]/g, we = {
          "=": "=0",
          ":": "=2"
        }, Oe = kt.replace(Kt, function(yn) {
          return we[yn];
        });
        return "$" + Oe;
      }
      var Ae = !1, Ke = /\/+/g;
      function Re(kt) {
        return kt.replace(Ke, "$&/");
      }
      function pe(kt, Kt) {
        return typeof kt == "object" && kt !== null && kt.key != null ? (U(kt.key), Di("" + kt.key)) : Kt.toString(36);
      }
      function Ce(kt, Kt, we, Oe, yn) {
        var Hn = typeof kt;
        (Hn === "undefined" || Hn === "boolean") && (kt = null);
        var Pn = !1;
        if (kt === null)
          Pn = !0;
        else
          switch (Hn) {
            case "string":
            case "number":
              Pn = !0;
              break;
            case "object":
              switch (kt.$$typeof) {
                case c:
                case w:
                  Pn = !0;
              }
          }
        if (Pn) {
          var Vn = kt, ri = yn(Vn), pi = Oe === "" ? Ai + pe(Vn, 0) : Oe;
          if (Me(ri)) {
            var Bn = "";
            pi != null && (Bn = Re(pi) + "/"), Ce(ri, Kt, Bn, "", function(bs) {
              return bs;
            });
          } else ri != null && (Wn(ri) && (ri.key && (!Vn || Vn.key !== ri.key) && U(ri.key), ri = je(
            ri,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            we + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (ri.key && (!Vn || Vn.key !== ri.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Re("" + ri.key) + "/"
            ) : "") + pi
          )), Kt.push(ri));
          return 1;
        }
        var Ti, ei, Si = 0, Pi = Oe === "" ? Ai : Oe + Gn;
        if (Me(kt))
          for (var ua = 0; ua < kt.length; ua++)
            Ti = kt[ua], ei = Pi + pe(Ti, ua), Si += Ce(Ti, Kt, we, ei, yn);
        else {
          var wr = d(kt);
          if (typeof wr == "function") {
            var ja = kt;
            wr === ja.entries && (Ae || et("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), Ae = !0);
            for (var os = wr.call(ja), da, Ba = 0; !(da = os.next()).done; )
              Ti = da.value, ei = Pi + pe(Ti, Ba++), Si += Ce(Ti, Kt, we, ei, yn);
          } else if (Hn === "object") {
            var ca = String(kt);
            throw new Error("Objects are not valid as a React child (found: " + (ca === "[object Object]" ? "object with keys {" + Object.keys(kt).join(", ") + "}" : ca) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return Si;
      }
      function He(kt, Kt, we) {
        if (kt == null)
          return kt;
        var Oe = [], yn = 0;
        return Ce(kt, Oe, "", "", function(Hn) {
          return Kt.call(we, Hn, yn++);
        }), Oe;
      }
      function Je(kt) {
        var Kt = 0;
        return He(kt, function() {
          Kt++;
        }), Kt;
      }
      function tn(kt, Kt, we) {
        He(kt, function() {
          Kt.apply(this, arguments);
        }, we);
      }
      function xe(kt) {
        return He(kt, function(Kt) {
          return Kt;
        }) || [];
      }
      function Se(kt) {
        if (!Wn(kt))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return kt;
      }
      function $e(kt) {
        var Kt = {
          $$typeof: A,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: kt,
          _currentValue2: kt,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        Kt.Provider = {
          $$typeof: b,
          _context: Kt
        };
        var we = !1, Oe = !1, yn = !1;
        {
          var Hn = {
            $$typeof: A,
            _context: Kt
          };
          Object.defineProperties(Hn, {
            Provider: {
              get: function() {
                return Oe || (Oe = !0, Dt("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), Kt.Provider;
              },
              set: function(Pn) {
                Kt.Provider = Pn;
              }
            },
            _currentValue: {
              get: function() {
                return Kt._currentValue;
              },
              set: function(Pn) {
                Kt._currentValue = Pn;
              }
            },
            _currentValue2: {
              get: function() {
                return Kt._currentValue2;
              },
              set: function(Pn) {
                Kt._currentValue2 = Pn;
              }
            },
            _threadCount: {
              get: function() {
                return Kt._threadCount;
              },
              set: function(Pn) {
                Kt._threadCount = Pn;
              }
            },
            Consumer: {
              get: function() {
                return we || (we = !0, Dt("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), Kt.Consumer;
              }
            },
            displayName: {
              get: function() {
                return Kt.displayName;
              },
              set: function(Pn) {
                yn || (et("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Pn), yn = !0);
              }
            }
          }), Kt.Consumer = Hn;
        }
        return Kt._currentRenderer = null, Kt._currentRenderer2 = null, Kt;
      }
      var kn = -1, Ge = 0, En = 1, An = 2;
      function Dn(kt) {
        if (kt._status === kn) {
          var Kt = kt._result, we = Kt();
          if (we.then(function(Hn) {
            if (kt._status === Ge || kt._status === kn) {
              var Pn = kt;
              Pn._status = En, Pn._result = Hn;
            }
          }, function(Hn) {
            if (kt._status === Ge || kt._status === kn) {
              var Pn = kt;
              Pn._status = An, Pn._result = Hn;
            }
          }), kt._status === kn) {
            var Oe = kt;
            Oe._status = Ge, Oe._result = we;
          }
        }
        if (kt._status === En) {
          var yn = kt._result;
          return yn === void 0 && Dt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, yn), "default" in yn || Dt(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, yn), yn.default;
        } else
          throw kt._result;
      }
      function In(kt) {
        var Kt = {
          // We use these fields to store the result.
          _status: kn,
          _result: kt
        }, we = {
          $$typeof: m,
          _payload: Kt,
          _init: Dn
        };
        {
          var Oe, yn;
          Object.defineProperties(we, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Oe;
              },
              set: function(Hn) {
                Dt("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Oe = Hn, Object.defineProperty(we, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return yn;
              },
              set: function(Hn) {
                Dt("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), yn = Hn, Object.defineProperty(we, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return we;
      }
      function Kn(kt) {
        kt != null && kt.$$typeof === g ? Dt("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof kt != "function" ? Dt("forwardRef requires a render function but was given %s.", kt === null ? "null" : typeof kt) : kt.length !== 0 && kt.length !== 2 && Dt("forwardRef render functions accept exactly two parameters: props and ref. %s", kt.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), kt != null && (kt.defaultProps != null || kt.propTypes != null) && Dt("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var Kt = {
          $$typeof: l,
          render: kt
        };
        {
          var we;
          Object.defineProperty(Kt, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return we;
            },
            set: function(Oe) {
              we = Oe, !kt.name && !kt.displayName && (kt.displayName = Oe);
            }
          });
        }
        return Kt;
      }
      var vn;
      vn = Symbol.for("react.module.reference");
      function ve(kt) {
        return !!(typeof kt == "string" || typeof kt == "function" || kt === R || kt === h || pt || kt === L || kt === o || kt === u || I || kt === S || Nt || jt || q || typeof kt == "object" && kt !== null && (kt.$$typeof === m || kt.$$typeof === g || kt.$$typeof === b || kt.$$typeof === A || kt.$$typeof === l || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        kt.$$typeof === vn || kt.getModuleId !== void 0));
      }
      function ue(kt, Kt) {
        ve(kt) || Dt("memo: The first argument must be a component. Instead received: %s", kt === null ? "null" : typeof kt);
        var we = {
          $$typeof: g,
          type: kt,
          compare: Kt === void 0 ? null : Kt
        };
        {
          var Oe;
          Object.defineProperty(we, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Oe;
            },
            set: function(yn) {
              Oe = yn, !kt.name && !kt.displayName && (kt.displayName = yn);
            }
          });
        }
        return we;
      }
      function Be() {
        var kt = _.current;
        return kt === null && Dt(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), kt;
      }
      function dn(kt) {
        var Kt = Be();
        if (kt._context !== void 0) {
          var we = kt._context;
          we.Consumer === kt ? Dt("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : we.Provider === kt && Dt("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return Kt.useContext(kt);
      }
      function Yn(kt) {
        var Kt = Be();
        return Kt.useState(kt);
      }
      function $n(kt, Kt, we) {
        var Oe = Be();
        return Oe.useReducer(kt, Kt, we);
      }
      function ui(kt) {
        var Kt = Be();
        return Kt.useRef(kt);
      }
      function Ii(kt, Kt) {
        var we = Be();
        return we.useEffect(kt, Kt);
      }
      function Ei(kt, Kt) {
        var we = Be();
        return we.useInsertionEffect(kt, Kt);
      }
      function ai(kt, Kt) {
        var we = Be();
        return we.useLayoutEffect(kt, Kt);
      }
      function Mi(kt, Kt) {
        var we = Be();
        return we.useCallback(kt, Kt);
      }
      function Oi(kt, Kt) {
        var we = Be();
        return we.useMemo(kt, Kt);
      }
      function Bi(kt, Kt, we) {
        var Oe = Be();
        return Oe.useImperativeHandle(kt, Kt, we);
      }
      function dr(kt, Kt) {
        {
          var we = Be();
          return we.useDebugValue(kt, Kt);
        }
      }
      function Ri() {
        var kt = Be();
        return kt.useTransition();
      }
      function Ci(kt) {
        var Kt = Be();
        return Kt.useDeferredValue(kt);
      }
      function $i() {
        var kt = Be();
        return kt.useId();
      }
      function qr(kt, Kt, we) {
        var Oe = Be();
        return Oe.useSyncExternalStore(kt, Kt, we);
      }
      var ji = 0, va, Ta, ia, wa, Xe, fn, Fn;
      function Xn() {
      }
      Xn.__reactDisabledLog = !0;
      function di() {
        {
          if (ji === 0) {
            va = console.log, Ta = console.info, ia = console.warn, wa = console.error, Xe = console.group, fn = console.groupCollapsed, Fn = console.groupEnd;
            var kt = {
              configurable: !0,
              enumerable: !0,
              value: Xn,
              writable: !0
            };
            Object.defineProperties(console, {
              info: kt,
              log: kt,
              warn: kt,
              error: kt,
              group: kt,
              groupCollapsed: kt,
              groupEnd: kt
            });
          }
          ji++;
        }
      }
      function xi() {
        {
          if (ji--, ji === 0) {
            var kt = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: Ct({}, kt, {
                value: va
              }),
              info: Ct({}, kt, {
                value: Ta
              }),
              warn: Ct({}, kt, {
                value: ia
              }),
              error: Ct({}, kt, {
                value: wa
              }),
              group: Ct({}, kt, {
                value: Xe
              }),
              groupCollapsed: Ct({}, kt, {
                value: fn
              }),
              groupEnd: Ct({}, kt, {
                value: Fn
              })
            });
          }
          ji < 0 && Dt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var oi = It.ReactCurrentDispatcher, Zn;
      function zn(kt, Kt, we) {
        {
          if (Zn === void 0)
            try {
              throw Error();
            } catch (yn) {
              var Oe = yn.stack.trim().match(/\n( *(at )?)/);
              Zn = Oe && Oe[1] || "";
            }
          return `
` + Zn + kt;
        }
      }
      var Qn = !1, mi;
      {
        var cr = typeof WeakMap == "function" ? WeakMap : Map;
        mi = new cr();
      }
      function Yi(kt, Kt) {
        if (!kt || Qn)
          return "";
        {
          var we = mi.get(kt);
          if (we !== void 0)
            return we;
        }
        var Oe;
        Qn = !0;
        var yn = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var Hn;
        Hn = oi.current, oi.current = null, di();
        try {
          if (Kt) {
            var Pn = function() {
              throw Error();
            };
            if (Object.defineProperty(Pn.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Pn, []);
              } catch (Pi) {
                Oe = Pi;
              }
              Reflect.construct(kt, [], Pn);
            } else {
              try {
                Pn.call();
              } catch (Pi) {
                Oe = Pi;
              }
              kt.call(Pn.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Pi) {
              Oe = Pi;
            }
            kt();
          }
        } catch (Pi) {
          if (Pi && Oe && typeof Pi.stack == "string") {
            for (var Vn = Pi.stack.split(`
`), ri = Oe.stack.split(`
`), pi = Vn.length - 1, Bn = ri.length - 1; pi >= 1 && Bn >= 0 && Vn[pi] !== ri[Bn]; )
              Bn--;
            for (; pi >= 1 && Bn >= 0; pi--, Bn--)
              if (Vn[pi] !== ri[Bn]) {
                if (pi !== 1 || Bn !== 1)
                  do
                    if (pi--, Bn--, Bn < 0 || Vn[pi] !== ri[Bn]) {
                      var Ti = `
` + Vn[pi].replace(" at new ", " at ");
                      return kt.displayName && Ti.includes("<anonymous>") && (Ti = Ti.replace("<anonymous>", kt.displayName)), typeof kt == "function" && mi.set(kt, Ti), Ti;
                    }
                  while (pi >= 1 && Bn >= 0);
                break;
              }
          }
        } finally {
          Qn = !1, oi.current = Hn, xi(), Error.prepareStackTrace = yn;
        }
        var ei = kt ? kt.displayName || kt.name : "", Si = ei ? zn(ei) : "";
        return typeof kt == "function" && mi.set(kt, Si), Si;
      }
      function Hi(kt, Kt, we) {
        return Yi(kt, !1);
      }
      function Zi(kt) {
        var Kt = kt.prototype;
        return !!(Kt && Kt.isReactComponent);
      }
      function qi(kt, Kt, we) {
        if (kt == null)
          return "";
        if (typeof kt == "function")
          return Yi(kt, Zi(kt));
        if (typeof kt == "string")
          return zn(kt);
        switch (kt) {
          case o:
            return zn("Suspense");
          case u:
            return zn("SuspenseList");
        }
        if (typeof kt == "object")
          switch (kt.$$typeof) {
            case l:
              return Hi(kt.render);
            case g:
              return qi(kt.type, Kt, we);
            case m: {
              var Oe = kt, yn = Oe._payload, Hn = Oe._init;
              try {
                return qi(Hn(yn), Kt, we);
              } catch {
              }
            }
          }
        return "";
      }
      var Fi = {}, ra = It.ReactDebugCurrentFrame;
      function Gr(kt) {
        if (kt) {
          var Kt = kt._owner, we = qi(kt.type, kt._source, Kt ? Kt.type : null);
          ra.setExtraStackFrame(we);
        } else
          ra.setExtraStackFrame(null);
      }
      function ss(kt, Kt, we, Oe, yn) {
        {
          var Hn = Function.call.bind(ne);
          for (var Pn in kt)
            if (Hn(kt, Pn)) {
              var Vn = void 0;
              try {
                if (typeof kt[Pn] != "function") {
                  var ri = Error((Oe || "React class") + ": " + we + " type `" + Pn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof kt[Pn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw ri.name = "Invariant Violation", ri;
                }
                Vn = kt[Pn](Kt, Pn, Oe, we, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (pi) {
                Vn = pi;
              }
              Vn && !(Vn instanceof Error) && (Gr(yn), Dt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Oe || "React class", we, Pn, typeof Vn), Gr(null)), Vn instanceof Error && !(Vn.message in Fi) && (Fi[Vn.message] = !0, Gr(yn), Dt("Failed %s type: %s", we, Vn.message), Gr(null));
            }
        }
      }
      function sr(kt) {
        if (kt) {
          var Kt = kt._owner, we = qi(kt.type, kt._source, Kt ? Kt.type : null);
          xt(we);
        } else
          xt(null);
      }
      var Vi;
      Vi = !1;
      function Dr() {
        if ($.current) {
          var kt = Ft($.current.type);
          if (kt)
            return `

Check the render method of \`` + kt + "`.";
        }
        return "";
      }
      function Fa(kt) {
        if (kt !== void 0) {
          var Kt = kt.fileName.replace(/^.*[\\\/]/, ""), we = kt.lineNumber;
          return `

Check your code at ` + Kt + ":" + we + ".";
        }
        return "";
      }
      function tr(kt) {
        return kt != null ? Fa(kt.__source) : "";
      }
      var aa = {};
      function Aa(kt) {
        var Kt = Dr();
        if (!Kt) {
          var we = typeof kt == "string" ? kt : kt.displayName || kt.name;
          we && (Kt = `

Check the top-level render call using <` + we + ">.");
        }
        return Kt;
      }
      function Ir(kt, Kt) {
        if (!(!kt._store || kt._store.validated || kt.key != null)) {
          kt._store.validated = !0;
          var we = Aa(Kt);
          if (!aa[we]) {
            aa[we] = !0;
            var Oe = "";
            kt && kt._owner && kt._owner !== $.current && (Oe = " It was passed a child from " + Ft(kt._owner.type) + "."), sr(kt), Dt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', we, Oe), sr(null);
          }
        }
      }
      function or(kt, Kt) {
        if (typeof kt == "object") {
          if (Me(kt))
            for (var we = 0; we < kt.length; we++) {
              var Oe = kt[we];
              Wn(Oe) && Ir(Oe, Kt);
            }
          else if (Wn(kt))
            kt._store && (kt._store.validated = !0);
          else if (kt) {
            var yn = d(kt);
            if (typeof yn == "function" && yn !== kt.entries)
              for (var Hn = yn.call(kt), Pn; !(Pn = Hn.next()).done; )
                Wn(Pn.value) && Ir(Pn.value, Kt);
          }
        }
      }
      function hi(kt) {
        {
          var Kt = kt.type;
          if (Kt == null || typeof Kt == "string")
            return;
          var we;
          if (typeof Kt == "function")
            we = Kt.propTypes;
          else if (typeof Kt == "object" && (Kt.$$typeof === l || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          Kt.$$typeof === g))
            we = Kt.propTypes;
          else
            return;
          if (we) {
            var Oe = Ft(Kt);
            ss(we, kt.props, "prop", Oe, kt);
          } else if (Kt.PropTypes !== void 0 && !Vi) {
            Vi = !0;
            var yn = Ft(Kt);
            Dt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", yn || "Unknown");
          }
          typeof Kt.getDefaultProps == "function" && !Kt.getDefaultProps.isReactClassApproved && Dt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function hr(kt) {
        {
          for (var Kt = Object.keys(kt.props), we = 0; we < Kt.length; we++) {
            var Oe = Kt[we];
            if (Oe !== "children" && Oe !== "key") {
              sr(kt), Dt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Oe), sr(null);
              break;
            }
          }
          kt.ref !== null && (sr(kt), Dt("Invalid attribute `ref` supplied to `React.Fragment`."), sr(null));
        }
      }
      function vr(kt, Kt, we) {
        var Oe = ve(kt);
        if (!Oe) {
          var yn = "";
          (kt === void 0 || typeof kt == "object" && kt !== null && Object.keys(kt).length === 0) && (yn += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Hn = tr(Kt);
          Hn ? yn += Hn : yn += Dr();
          var Pn;
          kt === null ? Pn = "null" : Me(kt) ? Pn = "array" : kt !== void 0 && kt.$$typeof === c ? (Pn = "<" + (Ft(kt.type) || "Unknown") + " />", yn = " Did you accidentally export a JSX literal instead of a component?") : Pn = typeof kt, Dt("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Pn, yn);
        }
        var Vn = ce.apply(this, arguments);
        if (Vn == null)
          return Vn;
        if (Oe)
          for (var ri = 2; ri < arguments.length; ri++)
            or(arguments[ri], kt);
        return kt === R ? hr(Vn) : hi(Vn), Vn;
      }
      var fr = !1;
      function vi(kt) {
        var Kt = vr.bind(null, kt);
        return Kt.type = kt, fr || (fr = !0, et("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(Kt, "type", {
          enumerable: !1,
          get: function() {
            return et("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: kt
            }), kt;
          }
        }), Kt;
      }
      function Xi(kt, Kt, we) {
        for (var Oe = ii.apply(this, arguments), yn = 2; yn < arguments.length; yn++)
          or(arguments[yn], Oe.type);
        return hi(Oe), Oe;
      }
      function Rr(kt, Kt) {
        var we = p.transition;
        p.transition = {};
        var Oe = p.transition;
        p.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          kt();
        } finally {
          if (p.transition = we, we === null && Oe._updatedFibers) {
            var yn = Oe._updatedFibers.size;
            yn > 10 && et("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Oe._updatedFibers.clear();
          }
        }
      }
      var Qi = !1, Tr = null;
      function Sa(kt) {
        if (Tr === null)
          try {
            var Kt = ("require" + Math.random()).slice(0, 7), we = Et && Et[Kt];
            Tr = we.call(Et, "timers").setImmediate;
          } catch {
            Tr = function(yn) {
              Qi === !1 && (Qi = !0, typeof MessageChannel > "u" && Dt("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var Hn = new MessageChannel();
              Hn.port1.onmessage = yn, Hn.port2.postMessage(void 0);
            };
          }
        return Tr(kt);
      }
      var mr = 0, sa = !1;
      function Ua(kt) {
        {
          var Kt = mr;
          mr++, P.current === null && (P.current = []);
          var we = P.isBatchingLegacy, Oe;
          try {
            if (P.isBatchingLegacy = !0, Oe = kt(), !we && P.didScheduleLegacyUpdate) {
              var yn = P.current;
              yn !== null && (P.didScheduleLegacyUpdate = !1, Cr(yn));
            }
          } catch (ei) {
            throw oa(Kt), ei;
          } finally {
            P.isBatchingLegacy = we;
          }
          if (Oe !== null && typeof Oe == "object" && typeof Oe.then == "function") {
            var Hn = Oe, Pn = !1, Vn = {
              then: function(ei, Si) {
                Pn = !0, Hn.then(function(Pi) {
                  oa(Kt), mr === 0 ? Vr(Pi, ei, Si) : ei(Pi);
                }, function(Pi) {
                  oa(Kt), Si(Pi);
                });
              }
            };
            return !sa && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Pn || (sa = !0, Dt("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), Vn;
          } else {
            var ri = Oe;
            if (oa(Kt), mr === 0) {
              var pi = P.current;
              pi !== null && (Cr(pi), P.current = null);
              var Bn = {
                then: function(ei, Si) {
                  P.current === null ? (P.current = [], Vr(ri, ei, Si)) : ei(ri);
                }
              };
              return Bn;
            } else {
              var Ti = {
                then: function(ei, Si) {
                  ei(ri);
                }
              };
              return Ti;
            }
          }
        }
      }
      function oa(kt) {
        kt !== mr - 1 && Dt("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), mr = kt;
      }
      function Vr(kt, Kt, we) {
        {
          var Oe = P.current;
          if (Oe !== null)
            try {
              Cr(Oe), Sa(function() {
                Oe.length === 0 ? (P.current = null, Kt(kt)) : Vr(kt, Kt, we);
              });
            } catch (yn) {
              we(yn);
            }
          else
            Kt(kt);
        }
      }
      var la = !1;
      function Cr(kt) {
        if (!la) {
          la = !0;
          var Kt = 0;
          try {
            for (; Kt < kt.length; Kt++) {
              var we = kt[Kt];
              do
                we = we(!0);
              while (we !== null);
            }
            kt.length = 0;
          } catch (Oe) {
            throw kt = kt.slice(Kt + 1), Oe;
          } finally {
            la = !1;
          }
        }
      }
      var Ma = vr, Zs = Xi, ys = vi, lr = {
        map: He,
        forEach: tn,
        count: Je,
        toArray: xe,
        only: Se
      };
      t.Children = lr, t.Component = ze, t.Fragment = R, t.Profiler = h, t.PureComponent = pn, t.StrictMode = L, t.Suspense = o, t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = It, t.act = Ua, t.cloneElement = Zs, t.createContext = $e, t.createElement = Ma, t.createFactory = ys, t.createRef = Yt, t.forwardRef = Kn, t.isValidElement = Wn, t.lazy = In, t.memo = ue, t.startTransition = Rr, t.unstable_act = Ua, t.useCallback = Mi, t.useContext = dn, t.useDebugValue = dr, t.useDeferredValue = Ci, t.useEffect = Ii, t.useId = $i, t.useImperativeHandle = Bi, t.useInsertionEffect = Ei, t.useLayoutEffect = ai, t.useMemo = Oi, t.useReducer = $n, t.useRef = ui, t.useState = Yn, t.useSyncExternalStore = qr, t.useTransition = Ri, t.version = r, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Eo, Eo.exports)), Eo.exports;
}
process.env.NODE_ENV === "production" ? ju.exports = wg() : ju.exports = Ag();
var Sg = ju.exports, Bu = { exports: {} };
(function(Et, t) {
  (function(r, c) {
    var w = "1.0.38", R = "", L = "?", h = "function", b = "undefined", A = "object", l = "string", o = "major", u = "model", g = "name", m = "type", S = "vendor", e = "version", n = "architecture", d = "console", _ = "mobile", p = "tablet", P = "smarttv", $ = "wearable", ot = "embedded", dt = 500, xt = "Amazon", Nt = "Apple", jt = "ASUS", q = "BlackBerry", I = "Browser", pt = "Chrome", It = "Edge", et = "Firefox", Dt = "Google", ae = "Huawei", St = "LG", qe = "Microsoft", zt = "Motorola", Ct = "Opera", de = "Samsung", ze = "Sharp", le = "Sony", Ze = "Xiaomi", me = "Zebra", bn = "Facebook", pn = "Chromium OS", wn = "Mac OS", Yt = function(Gt, se) {
      var Jt = {};
      for (var he in Gt)
        se[he] && se[he].length % 2 === 0 ? Jt[he] = se[he].concat(Gt[he]) : Jt[he] = Gt[he];
      return Jt;
    }, Ht = function(Gt) {
      for (var se = {}, Jt = 0; Jt < Gt.length; Jt++)
        se[Gt[Jt].toUpperCase()] = Gt[Jt];
      return se;
    }, Me = function(Gt, se) {
      return typeof Gt === l ? X(se).indexOf(X(Gt)) !== -1 : !1;
    }, X = function(Gt) {
      return Gt.toLowerCase();
    }, Q = function(Gt) {
      return typeof Gt === l ? Gt.replace(/[^\d\.]/g, R).split(".")[0] : c;
    }, C = function(Gt, se) {
      if (typeof Gt === l)
        return Gt = Gt.replace(/^\s\s*/, R), typeof se === b ? Gt : Gt.substring(0, dt);
    }, U = function(Gt, se) {
      for (var Jt = 0, he, an, Fe, ke, ce, je; Jt < se.length && !ce; ) {
        var ii = se[Jt], Wn = se[Jt + 1];
        for (he = an = 0; he < ii.length && !ce && ii[he]; )
          if (ce = ii[he++].exec(Gt), ce)
            for (Fe = 0; Fe < Wn.length; Fe++)
              je = ce[++an], ke = Wn[Fe], typeof ke === A && ke.length > 0 ? ke.length === 2 ? typeof ke[1] == h ? this[ke[0]] = ke[1].call(this, je) : this[ke[0]] = ke[1] : ke.length === 3 ? typeof ke[1] === h && !(ke[1].exec && ke[1].test) ? this[ke[0]] = je ? ke[1].call(this, je, ke[2]) : c : this[ke[0]] = je ? je.replace(ke[1], ke[2]) : c : ke.length === 4 && (this[ke[0]] = je ? ke[3].call(this, je.replace(ke[1], ke[2])) : c) : this[ke] = je || c;
        Jt += 2;
      }
    }, gt = function(Gt, se) {
      for (var Jt in se)
        if (typeof se[Jt] === A && se[Jt].length > 0) {
          for (var he = 0; he < se[Jt].length; he++)
            if (Me(se[Jt][he], Gt))
              return Jt === L ? c : Jt;
        } else if (Me(se[Jt], Gt))
          return Jt === L ? c : Jt;
      return Gt;
    }, rt = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, Ft = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, ne = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [e, [g, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [e, [g, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [g, e], [/opios[\/ ]+([\w\.]+)/i], [e, [g, Ct + " Mini"]], [/\bop(?:rg)?x\/([\w\.]+)/i], [e, [g, Ct + " GX"]], [/\bopr\/([\w\.]+)/i], [e, [g, Ct]], [/\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i], [e, [g, "Baidu"]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [g, e], [/\bddg\/([\w\.]+)/i], [e, [g, "DuckDuckGo"]], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [e, [g, "UC" + I]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i, /micromessenger\/([\w\.]+)/i], [e, [g, "WeChat"]], [/konqueror\/([\w\.]+)/i], [e, [g, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [e, [g, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [e, [g, "Yandex"]], [/slbrowser\/([\w\.]+)/i], [e, [g, "Smart Lenovo " + I]], [/(avast|avg)\/([\w\.]+)/i], [[g, /(.+)/, "$1 Secure " + I], e], [/\bfocus\/([\w\.]+)/i], [e, [g, et + " Focus"]], [/\bopt\/([\w\.]+)/i], [e, [g, Ct + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [e, [g, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [e, [g, "Dolphin"]], [/coast\/([\w\.]+)/i], [e, [g, Ct + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [e, [g, "MIUI " + I]], [/fxios\/([-\w\.]+)/i], [e, [g, et]], [/\bqihu|(qi?ho?o?|360)browser/i], [[g, "360 " + I]], [/(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i], [[g, /(.+)/, "$1 " + I], e], [/samsungbrowser\/([\w\.]+)/i], [e, [g, de + " Internet"]], [/(comodo_dragon)\/([\w\.]+)/i], [[g, /_/g, " "], e], [/metasr[\/ ]?([\d\.]+)/i], [e, [g, "Sogou Explorer"]], [/(sogou)mo\w+\/([\d\.]+)/i], [[g, "Sogou Mobile"], e], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i], [g, e], [/(lbbrowser)/i, /\[(linkedin)app\]/i], [g], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[g, bn], e], [/(Klarna)\/([\w\.]+)/i, /(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(alipay)client\/([\w\.]+)/i, /(twitter)(?:and| f.+e\/([\w\.]+))/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [g, e], [/\bgsa\/([\w\.]+) .*safari\//i], [e, [g, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [e, [g, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [e, [g, pt + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[g, pt + " WebView"], e], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [e, [g, "Android " + I]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [g, e], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [e, [g, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [e, g], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [g, [e, gt, rt]], [/(webkit|khtml)\/([\w\.]+)/i], [g, e], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[g, "Netscape"], e], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [e, [g, et + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [g, e], [/(cobalt)\/([\w\.]+)/i], [g, [e, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[n, "amd64"]], [/(ia32(?=;))/i], [[n, X]], [/((?:i[346]|x)86)[;\)]/i], [[n, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[n, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[n, "armhf"]], [/windows (ce|mobile); ppc;/i], [[n, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[n, /ower/, R, X]], [/(sun4\w)[;\)]/i], [[n, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[n, X]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [u, [S, de], [m, p]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [u, [S, de], [m, _]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [u, [S, Nt], [m, _]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [u, [S, Nt], [m, p]], [/(macintosh);/i], [u, [S, Nt]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [u, [S, ze], [m, _]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [u, [S, ae], [m, p]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [u, [S, ae], [m, _]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[u, /_/g, " "], [S, Ze], [m, _]], [/oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i, /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[u, /_/g, " "], [S, Ze], [m, p]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [u, [S, "OPPO"], [m, _]], [/\b(opd2\d{3}a?) bui/i], [u, [S, "OPPO"], [m, p]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [u, [S, "Vivo"], [m, _]], [/\b(rmx[1-3]\d{3})(?: bui|;|\))/i], [u, [S, "Realme"], [m, _]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [u, [S, zt], [m, _]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [u, [S, zt], [m, p]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [u, [S, St], [m, p]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [u, [S, St], [m, _]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [u, [S, "Lenovo"], [m, p]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[u, /_/g, " "], [S, "Nokia"], [m, _]], [/(pixel c)\b/i], [u, [S, Dt], [m, p]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [u, [S, Dt], [m, _]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [u, [S, le], [m, _]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[u, "Xperia Tablet"], [S, le], [m, p]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [u, [S, "OnePlus"], [m, _]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [u, [S, xt], [m, p]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[u, /(.+)/g, "Fire Phone $1"], [S, xt], [m, _]], [/(playbook);[-\w\),; ]+(rim)/i], [u, S, [m, p]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [u, [S, q], [m, _]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [u, [S, jt], [m, p]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [u, [S, jt], [m, _]], [/(nexus 9)/i], [u, [S, "HTC"], [m, p]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [S, [u, /_/g, " "], [m, _]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [u, [S, "Acer"], [m, p]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [u, [S, "Meizu"], [m, _]], [/; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i], [u, [S, "Ulefone"], [m, _]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [S, u, [m, _]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [S, u, [m, p]], [/(surface duo)/i], [u, [S, qe], [m, p]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [u, [S, "Fairphone"], [m, _]], [/(u304aa)/i], [u, [S, "AT&T"], [m, _]], [/\bsie-(\w*)/i], [u, [S, "Siemens"], [m, _]], [/\b(rct\w+) b/i], [u, [S, "RCA"], [m, p]], [/\b(venue[\d ]{2,7}) b/i], [u, [S, "Dell"], [m, p]], [/\b(q(?:mv|ta)\w+) b/i], [u, [S, "Verizon"], [m, p]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [u, [S, "Barnes & Noble"], [m, p]], [/\b(tm\d{3}\w+) b/i], [u, [S, "NuVision"], [m, p]], [/\b(k88) b/i], [u, [S, "ZTE"], [m, p]], [/\b(nx\d{3}j) b/i], [u, [S, "ZTE"], [m, _]], [/\b(gen\d{3}) b.+49h/i], [u, [S, "Swiss"], [m, _]], [/\b(zur\d{3}) b/i], [u, [S, "Swiss"], [m, p]], [/\b((zeki)?tb.*\b) b/i], [u, [S, "Zeki"], [m, p]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[S, "Dragon Touch"], u, [m, p]], [/\b(ns-?\w{0,9}) b/i], [u, [S, "Insignia"], [m, p]], [/\b((nxa|next)-?\w{0,9}) b/i], [u, [S, "NextBook"], [m, p]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[S, "Voice"], u, [m, _]], [/\b(lvtel\-)?(v1[12]) b/i], [[S, "LvTel"], u, [m, _]], [/\b(ph-1) /i], [u, [S, "Essential"], [m, _]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [u, [S, "Envizen"], [m, p]], [/\b(trio[-\w\. ]+) b/i], [u, [S, "MachSpeed"], [m, p]], [/\btu_(1491) b/i], [u, [S, "Rotor"], [m, p]], [/(shield[\w ]+) b/i], [u, [S, "Nvidia"], [m, p]], [/(sprint) (\w+)/i], [S, u, [m, _]], [/(kin\.[onetw]{3})/i], [[u, /\./g, " "], [S, qe], [m, _]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [u, [S, me], [m, p]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [u, [S, me], [m, _]], [/smart-tv.+(samsung)/i], [S, [m, P]], [/hbbtv.+maple;(\d+)/i], [[u, /^/, "SmartTV"], [S, de], [m, P]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[S, St], [m, P]], [/(apple) ?tv/i], [S, [u, Nt + " TV"], [m, P]], [/crkey/i], [[u, pt + "cast"], [S, Dt], [m, P]], [/droid.+aft(\w+)( bui|\))/i], [u, [S, xt], [m, P]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [u, [S, ze], [m, P]], [/(bravia[\w ]+)( bui|\))/i], [u, [S, le], [m, P]], [/(mitv-\w{5}) bui/i], [u, [S, Ze], [m, P]], [/Hbbtv.*(technisat) (.*);/i], [S, u, [m, P]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[S, C], [u, C], [m, P]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[m, P]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [S, u, [m, d]], [/droid.+; (shield) bui/i], [u, [S, "Nvidia"], [m, d]], [/(playstation [345portablevi]+)/i], [u, [S, le], [m, d]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [u, [S, qe], [m, d]], [/((pebble))app/i], [S, u, [m, $]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [u, [S, Nt], [m, $]], [/droid.+; (glass) \d/i], [u, [S, Dt], [m, $]], [/droid.+; (wt63?0{2,3})\)/i], [u, [S, me], [m, $]], [/(quest( \d| pro)?)/i], [u, [S, bn], [m, $]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [S, [m, ot]], [/(aeobc)\b/i], [u, [S, xt], [m, ot]], [/droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i], [u, [m, _]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [u, [m, p]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[m, p]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[m, _]], [/(android[-\w\. ]{0,9});.+buil/i], [u, [S, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [e, [g, It + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [e, [g, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [g, e], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [e, g]], os: [[/microsoft (windows) (vista|xp)/i], [g, e], [/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i], [g, [e, gt, Ft]], [/windows nt 6\.2; (arm)/i, /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i, /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[e, gt, Ft], [g, "Windows"]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[e, /_/g, "."], [g, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[g, wn], [e, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [e, g], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [g, e], [/\(bb(10);/i], [e, [g, q]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [e, [g, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [e, [g, et + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [e, [g, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [e, [g, "watchOS"]], [/crkey\/([\d\.]+)/i], [e, [g, pt + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[g, pn], e], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [g, e], [/(sunos) ?([\w\.\d]*)/i], [[g, "Solaris"], e], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [g, e]] }, Vt = function(Gt, se) {
      if (typeof Gt === A && (se = Gt, Gt = c), !(this instanceof Vt))
        return new Vt(Gt, se).getResult();
      var Jt = typeof r !== b && r.navigator ? r.navigator : c, he = Gt || (Jt && Jt.userAgent ? Jt.userAgent : R), an = Jt && Jt.userAgentData ? Jt.userAgentData : c, Fe = se ? Yt(ne, se) : ne, ke = Jt && Jt.userAgent == he;
      return this.getBrowser = function() {
        var ce = {};
        return ce[g] = c, ce[e] = c, U.call(ce, he, Fe.browser), ce[o] = Q(ce[e]), ke && Jt && Jt.brave && typeof Jt.brave.isBrave == h && (ce[g] = "Brave"), ce;
      }, this.getCPU = function() {
        var ce = {};
        return ce[n] = c, U.call(ce, he, Fe.cpu), ce;
      }, this.getDevice = function() {
        var ce = {};
        return ce[S] = c, ce[u] = c, ce[m] = c, U.call(ce, he, Fe.device), ke && !ce[m] && an && an.mobile && (ce[m] = _), ke && ce[u] == "Macintosh" && Jt && typeof Jt.standalone !== b && Jt.maxTouchPoints && Jt.maxTouchPoints > 2 && (ce[u] = "iPad", ce[m] = p), ce;
      }, this.getEngine = function() {
        var ce = {};
        return ce[g] = c, ce[e] = c, U.call(ce, he, Fe.engine), ce;
      }, this.getOS = function() {
        var ce = {};
        return ce[g] = c, ce[e] = c, U.call(ce, he, Fe.os), ke && !ce[g] && an && an.platform && an.platform != "Unknown" && (ce[g] = an.platform.replace(/chrome os/i, pn).replace(/macos/i, wn)), ce;
      }, this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      }, this.getUA = function() {
        return he;
      }, this.setUA = function(ce) {
        return he = typeof ce === l && ce.length > dt ? C(ce, dt) : ce, this;
      }, this.setUA(he), this;
    };
    Vt.VERSION = w, Vt.BROWSER = Ht([g, e, o]), Vt.CPU = Ht([n]), Vt.DEVICE = Ht([u, S, m, d, _, P, p, $, ot]), Vt.ENGINE = Vt.OS = Ht([g, e]), Et.exports && (t = Et.exports = Vt), t.UAParser = Vt;
    var Xt = typeof r !== b && (r.jQuery || r.Zepto);
    if (Xt && !Xt.ua) {
      var qt = new Vt();
      Xt.ua = qt.getResult(), Xt.ua.get = function() {
        return qt.getUA();
      }, Xt.ua.set = function(Gt) {
        qt.setUA(Gt);
        var se = qt.getResult();
        for (var Jt in se)
          Xt.ua[Jt] = se[Jt];
      };
    }
  })(typeof window == "object" ? window : Zh);
})(Bu, Bu.exports);
var Mg = Bu.exports;
Object.defineProperty(On, "__esModule", { value: !0 });
function kg(Et) {
  return Et && typeof Et == "object" && "default" in Et ? Et.default : Et;
}
var rr = Sg, Li = kg(rr), tf = Mg, is = new tf(), ar = is.getBrowser(), xg = is.getCPU(), Lr = is.getDevice(), td = is.getEngine(), rs = is.getOS(), So = is.getUA(), ef = function(t) {
  return is.setUA(t);
}, Mo = function(t) {
  if (!t) {
    console.error("No userAgent string was provided");
    return;
  }
  var r = new tf(t);
  return {
    UA: r,
    browser: r.getBrowser(),
    cpu: r.getCPU(),
    device: r.getDevice(),
    engine: r.getEngine(),
    os: r.getOS(),
    ua: r.getUA(),
    setUserAgent: function(w) {
      return r.setUA(w);
    }
  };
}, nf = /* @__PURE__ */ Object.freeze({
  ClientUAInstance: is,
  browser: ar,
  cpu: xg,
  device: Lr,
  engine: td,
  os: rs,
  ua: So,
  setUa: ef,
  parseUserAgent: Mo
});
function Vc(Et, t) {
  var r = Object.keys(Et);
  if (Object.getOwnPropertySymbols) {
    var c = Object.getOwnPropertySymbols(Et);
    t && (c = c.filter(function(w) {
      return Object.getOwnPropertyDescriptor(Et, w).enumerable;
    })), r.push.apply(r, c);
  }
  return r;
}
function Lg(Et) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vc(Object(r), !0).forEach(function(c) {
      Cg(Et, c, r[c]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Et, Object.getOwnPropertyDescriptors(r)) : Vc(Object(r)).forEach(function(c) {
      Object.defineProperty(Et, c, Object.getOwnPropertyDescriptor(r, c));
    });
  }
  return Et;
}
function To(Et) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? To = function(t) {
    return typeof t;
  } : To = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, To(Et);
}
function Dg(Et, t) {
  if (!(Et instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ig(Et, t) {
  for (var r = 0; r < t.length; r++) {
    var c = t[r];
    c.enumerable = c.enumerable || !1, c.configurable = !0, "value" in c && (c.writable = !0), Object.defineProperty(Et, c.key, c);
  }
}
function Rg(Et, t, r) {
  return t && Ig(Et.prototype, t), Et;
}
function Cg(Et, t, r) {
  return t in Et ? Object.defineProperty(Et, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : Et[t] = r, Et;
}
function Hu() {
  return Hu = Object.assign || function(Et) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var c in r)
        Object.prototype.hasOwnProperty.call(r, c) && (Et[c] = r[c]);
    }
    return Et;
  }, Hu.apply(this, arguments);
}
function Ng(Et, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  Et.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: Et,
      writable: !0,
      configurable: !0
    }
  }), t && Gu(Et, t);
}
function qu(Et) {
  return qu = Object.setPrototypeOf ? Object.getPrototypeOf : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, qu(Et);
}
function Gu(Et, t) {
  return Gu = Object.setPrototypeOf || function(c, w) {
    return c.__proto__ = w, c;
  }, Gu(Et, t);
}
function Pg(Et, t) {
  if (Et == null) return {};
  var r = {}, c = Object.keys(Et), w, R;
  for (R = 0; R < c.length; R++)
    w = c[R], !(t.indexOf(w) >= 0) && (r[w] = Et[w]);
  return r;
}
function Hr(Et, t) {
  if (Et == null) return {};
  var r = Pg(Et, t), c, w;
  if (Object.getOwnPropertySymbols) {
    var R = Object.getOwnPropertySymbols(Et);
    for (w = 0; w < R.length; w++)
      c = R[w], !(t.indexOf(c) >= 0) && Object.prototype.propertyIsEnumerable.call(Et, c) && (r[c] = Et[c]);
  }
  return r;
}
function wl(Et) {
  if (Et === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return Et;
}
function zg(Et, t) {
  if (t && (typeof t == "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return wl(Et);
}
function Og(Et, t) {
  return Yg(Et) || Fg(Et, t) || Ug(Et, t) || jg();
}
function Yg(Et) {
  if (Array.isArray(Et)) return Et;
}
function Fg(Et, t) {
  var r = Et == null ? null : typeof Symbol < "u" && Et[Symbol.iterator] || Et["@@iterator"];
  if (r != null) {
    var c = [], w = !0, R = !1, L, h;
    try {
      for (r = r.call(Et); !(w = (L = r.next()).done) && (c.push(L.value), !(t && c.length === t)); w = !0)
        ;
    } catch (b) {
      R = !0, h = b;
    } finally {
      try {
        !w && r.return != null && r.return();
      } finally {
        if (R) throw h;
      }
    }
    return c;
  }
}
function Ug(Et, t) {
  if (Et) {
    if (typeof Et == "string") return Wc(Et, t);
    var r = Object.prototype.toString.call(Et).slice(8, -1);
    if (r === "Object" && Et.constructor && (r = Et.constructor.name), r === "Map" || r === "Set") return Array.from(Et);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return Wc(Et, t);
  }
}
function Wc(Et, t) {
  (t == null || t > Et.length) && (t = Et.length);
  for (var r = 0, c = new Array(t); r < t; r++) c[r] = Et[r];
  return c;
}
function jg() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var ir = {
  Mobile: "mobile",
  Tablet: "tablet",
  SmartTv: "smarttv",
  Console: "console",
  Wearable: "wearable",
  Embedded: "embedded",
  Browser: void 0
}, br = {
  Chrome: "Chrome",
  Firefox: "Firefox",
  Opera: "Opera",
  Yandex: "Yandex",
  Safari: "Safari",
  InternetExplorer: "Internet Explorer",
  Edge: "Edge",
  Chromium: "Chromium",
  Ie: "IE",
  MobileSafari: "Mobile Safari",
  EdgeChromium: "Edge Chromium",
  MIUI: "MIUI Browser",
  SamsungBrowser: "Samsung Browser"
}, Qs = {
  IOS: "iOS",
  Android: "Android",
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MAC_OS: "Mac OS"
}, Bg = {
  isMobile: !1,
  isTablet: !1,
  isBrowser: !1,
  isSmartTV: !1,
  isConsole: !1,
  isWearable: !1
}, Hg = function(t) {
  switch (t) {
    case ir.Mobile:
      return {
        isMobile: !0
      };
    case ir.Tablet:
      return {
        isTablet: !0
      };
    case ir.SmartTv:
      return {
        isSmartTV: !0
      };
    case ir.Console:
      return {
        isConsole: !0
      };
    case ir.Wearable:
      return {
        isWearable: !0
      };
    case ir.Browser:
      return {
        isBrowser: !0
      };
    case ir.Embedded:
      return {
        isEmbedded: !0
      };
    default:
      return Bg;
  }
}, qg = function(t) {
  return ef(t);
}, Jn = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  return t || r;
}, ed = function() {
  return typeof window < "u" && (window.navigator || navigator) ? window.navigator || navigator : !1;
}, nd = function(t) {
  var r = ed();
  return r && r.platform && (r.platform.indexOf(t) !== -1 || r.platform === "MacIntel" && r.maxTouchPoints > 1 && !window.MSStream);
}, Gg = function(t, r, c, w, R) {
  return {
    isBrowser: t,
    browserMajorVersion: Jn(r.major),
    browserFullVersion: Jn(r.version),
    browserName: Jn(r.name),
    engineName: Jn(c.name),
    engineVersion: Jn(c.version),
    osName: Jn(w.name),
    osVersion: Jn(w.version),
    userAgent: Jn(R)
  };
}, Kc = function(t, r, c, w) {
  return Lg({}, t, {
    vendor: Jn(r.vendor),
    model: Jn(r.model),
    os: Jn(c.name),
    osVersion: Jn(c.version),
    ua: Jn(w)
  });
}, Vg = function(t, r, c, w) {
  return {
    isSmartTV: t,
    engineName: Jn(r.name),
    engineVersion: Jn(r.version),
    osName: Jn(c.name),
    osVersion: Jn(c.version),
    userAgent: Jn(w)
  };
}, Wg = function(t, r, c, w) {
  return {
    isConsole: t,
    engineName: Jn(r.name),
    engineVersion: Jn(r.version),
    osName: Jn(c.name),
    osVersion: Jn(c.version),
    userAgent: Jn(w)
  };
}, Kg = function(t, r, c, w) {
  return {
    isWearable: t,
    engineName: Jn(r.name),
    engineVersion: Jn(r.version),
    osName: Jn(c.name),
    osVersion: Jn(c.version),
    userAgent: Jn(w)
  };
}, $g = function(t, r, c, w, R) {
  return {
    isEmbedded: t,
    vendor: Jn(r.vendor),
    model: Jn(r.model),
    engineName: Jn(c.name),
    engineVersion: Jn(c.version),
    osName: Jn(w.name),
    osVersion: Jn(w.version),
    userAgent: Jn(R)
  };
};
function Xg(Et) {
  var t = Et ? Mo(Et) : nf, r = t.device, c = t.browser, w = t.engine, R = t.os, L = t.ua, h = Hg(r.type), b = h.isBrowser, A = h.isMobile, l = h.isTablet, o = h.isSmartTV, u = h.isConsole, g = h.isWearable, m = h.isEmbedded;
  if (b)
    return Gg(b, c, w, R, L);
  if (o)
    return Vg(o, w, R, L);
  if (u)
    return Wg(u, w, R, L);
  if (A || l)
    return Kc(h, r, R, L);
  if (g)
    return Kg(g, w, R, L);
  if (m)
    return $g(m, r, w, R, L);
}
var rf = function(t) {
  var r = t.type;
  return r === ir.Mobile;
}, af = function(t) {
  var r = t.type;
  return r === ir.Tablet;
}, sf = function(t) {
  var r = t.type;
  return r === ir.Mobile || r === ir.Tablet;
}, of = function(t) {
  var r = t.type;
  return r === ir.SmartTv;
}, xl = function(t) {
  var r = t.type;
  return r === ir.Browser;
}, lf = function(t) {
  var r = t.type;
  return r === ir.Wearable;
}, uf = function(t) {
  var r = t.type;
  return r === ir.Console;
}, df = function(t) {
  var r = t.type;
  return r === ir.Embedded;
}, cf = function(t) {
  var r = t.vendor;
  return Jn(r);
}, hf = function(t) {
  var r = t.model;
  return Jn(r);
}, ff = function(t) {
  var r = t.type;
  return Jn(r, "browser");
}, mf = function(t) {
  var r = t.name;
  return r === Qs.Android;
}, pf = function(t) {
  var r = t.name;
  return r === Qs.Windows;
}, gf = function(t) {
  var r = t.name;
  return r === Qs.MAC_OS;
}, _f = function(t) {
  var r = t.name;
  return r === Qs.WindowsPhone;
}, yf = function(t) {
  var r = t.name;
  return r === Qs.IOS;
}, bf = function(t) {
  var r = t.version;
  return Jn(r);
}, Ef = function(t) {
  var r = t.name;
  return Jn(r);
}, vf = function(t) {
  var r = t.name;
  return r === br.Chrome;
}, Tf = function(t) {
  var r = t.name;
  return r === br.Firefox;
}, wf = function(t) {
  var r = t.name;
  return r === br.Chromium;
}, Ll = function(t) {
  var r = t.name;
  return r === br.Edge;
}, Af = function(t) {
  var r = t.name;
  return r === br.Yandex;
}, Sf = function(t) {
  var r = t.name;
  return r === br.Safari || r === br.MobileSafari;
}, Mf = function(t) {
  var r = t.name;
  return r === br.MobileSafari;
}, kf = function(t) {
  var r = t.name;
  return r === br.Opera;
}, xf = function(t) {
  var r = t.name;
  return r === br.InternetExplorer || r === br.Ie;
}, Lf = function(t) {
  var r = t.name;
  return r === br.MIUI;
}, Df = function(t) {
  var r = t.name;
  return r === br.SamsungBrowser;
}, If = function(t) {
  var r = t.version;
  return Jn(r);
}, Rf = function(t) {
  var r = t.major;
  return Jn(r);
}, Cf = function(t) {
  var r = t.name;
  return Jn(r);
}, Nf = function(t) {
  var r = t.name;
  return Jn(r);
}, Pf = function(t) {
  var r = t.version;
  return Jn(r);
}, zf = function() {
  var t = ed(), r = t && t.userAgent && t.userAgent.toLowerCase();
  return typeof r == "string" ? /electron/.test(r) : !1;
}, Ks = function(t) {
  return typeof t == "string" && t.indexOf("Edg/") !== -1;
}, Of = function() {
  var t = ed();
  return t && (/iPad|iPhone|iPod/.test(t.platform) || t.platform === "MacIntel" && t.maxTouchPoints > 1) && !window.MSStream;
}, ya = function() {
  return nd("iPad");
}, Yf = function() {
  return nd("iPhone");
}, Ff = function() {
  return nd("iPod");
}, Uf = function(t) {
  return Jn(t);
};
function jf(Et) {
  var t = Et || nf, r = t.device, c = t.browser, w = t.os, R = t.engine, L = t.ua;
  return {
    isSmartTV: of(r),
    isConsole: uf(r),
    isWearable: lf(r),
    isEmbedded: df(r),
    isMobileSafari: Mf(c) || ya(),
    isChromium: wf(c),
    isMobile: sf(r) || ya(),
    isMobileOnly: rf(r),
    isTablet: af(r) || ya(),
    isBrowser: xl(r),
    isDesktop: xl(r),
    isAndroid: mf(w),
    isWinPhone: _f(w),
    isIOS: yf(w) || ya(),
    isChrome: vf(c),
    isFirefox: Tf(c),
    isSafari: Sf(c),
    isOpera: kf(c),
    isIE: xf(c),
    osVersion: bf(w),
    osName: Ef(w),
    fullBrowserVersion: If(c),
    browserVersion: Rf(c),
    browserName: Cf(c),
    mobileVendor: cf(r),
    mobileModel: hf(r),
    engineName: Nf(R),
    engineVersion: Pf(R),
    getUA: Uf(L),
    isEdge: Ll(c) || Ks(L),
    isYandex: Af(c),
    deviceType: ff(r),
    isIOS13: Of(),
    isIPad13: ya(),
    isIPhone13: Yf(),
    isIPod13: Ff(),
    isElectron: zf(),
    isEdgeChromium: Ks(L),
    isLegacyEdge: Ll(c) && !Ks(L),
    isWindows: pf(w),
    isMacOs: gf(w),
    isMIUI: Lf(c),
    isSamsungBrowser: Df(c)
  };
}
var Bf = of(Lr), Hf = uf(Lr), qf = lf(Lr), Qg = df(Lr), Jg = Mf(ar) || ya(), Zg = wf(ar), zl = sf(Lr) || ya(), Gf = rf(Lr), Vf = af(Lr) || ya(), Wf = xl(Lr), t_ = xl(Lr), Kf = mf(rs), $f = _f(rs), Xf = yf(rs) || ya(), e_ = vf(ar), n_ = Tf(ar), i_ = Sf(ar), r_ = kf(ar), Qf = xf(ar), a_ = bf(rs), s_ = Ef(rs), o_ = If(ar), l_ = Rf(ar), u_ = Cf(ar), d_ = cf(Lr), c_ = hf(Lr), h_ = Nf(td), f_ = Pf(td), m_ = Uf(So), p_ = Ll(ar) || Ks(So), g_ = Af(ar), __ = ff(Lr), y_ = Of(), b_ = ya(), E_ = Yf(), v_ = Ff(), T_ = zf(), w_ = Ks(So), A_ = Ll(ar) && !Ks(So), S_ = pf(rs), M_ = gf(rs), k_ = Lf(ar), x_ = Df(ar), L_ = function(t) {
  if (!t || typeof t != "string") {
    console.error("No valid user agent string was provided");
    return;
  }
  var r = Mo(t), c = r.device, w = r.browser, R = r.os, L = r.engine, h = r.ua;
  return jf({
    device: c,
    browser: w,
    os: R,
    engine: L,
    ua: h
  });
}, D_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Kf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, I_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Wf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, R_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Qf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, C_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Xf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, N_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return zl ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, P_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Vf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, z_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return $f ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, O_ = function(t) {
  var r = t.renderWithFragment, c = t.children;
  t.viewClassName, t.style;
  var w = Hr(t, ["renderWithFragment", "children", "viewClassName", "style"]);
  return Gf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, Y_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Bf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, F_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return Hf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, U_ = function(t) {
  var r = t.renderWithFragment, c = t.children, w = Hr(t, ["renderWithFragment", "children"]);
  return qf ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", w, c) : null;
}, j_ = function(t) {
  var r = t.renderWithFragment, c = t.children;
  t.viewClassName, t.style;
  var w = t.condition, R = Hr(t, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
  return w ? r ? Li.createElement(rr.Fragment, null, c) : Li.createElement("div", R, c) : null;
};
function B_(Et) {
  return /* @__PURE__ */ function(t) {
    Ng(r, t);
    function r(c) {
      var w;
      return Dg(this, r), w = zg(this, qu(r).call(this, c)), w.isEventListenerAdded = !1, w.handleOrientationChange = w.handleOrientationChange.bind(wl(w)), w.onOrientationChange = w.onOrientationChange.bind(wl(w)), w.onPageLoad = w.onPageLoad.bind(wl(w)), w.state = {
        isLandscape: !1,
        isPortrait: !1
      }, w;
    }
    return Rg(r, [{
      key: "handleOrientationChange",
      value: function() {
        this.isEventListenerAdded || (this.isEventListenerAdded = !0);
        var w = window.innerWidth > window.innerHeight ? 90 : 0;
        this.setState({
          isPortrait: w === 0,
          isLandscape: w === 90
        });
      }
    }, {
      key: "onOrientationChange",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "onPageLoad",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "componentDidMount",
      value: function() {
        (typeof window > "u" ? "undefined" : To(window)) !== void 0 && zl && (this.isEventListenerAdded ? window.removeEventListener("load", this.onPageLoad, !1) : (this.handleOrientationChange(), window.addEventListener("load", this.onPageLoad, !1)), window.addEventListener("resize", this.onOrientationChange, !1));
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        window.removeEventListener("resize", this.onOrientationChange, !1);
      }
    }, {
      key: "render",
      value: function() {
        return Li.createElement(Et, Hu({}, this.props, {
          isLandscape: this.state.isLandscape,
          isPortrait: this.state.isPortrait
        }));
      }
    }]), r;
  }(Li.Component);
}
function H_() {
  var Et = rr.useState(function() {
    var R = window.innerWidth > window.innerHeight ? 90 : 0;
    return {
      isPortrait: R === 0,
      isLandscape: R === 90,
      orientation: R === 0 ? "portrait" : "landscape"
    };
  }), t = Og(Et, 2), r = t[0], c = t[1], w = rr.useCallback(function() {
    var R = window.innerWidth > window.innerHeight ? 90 : 0, L = {
      isPortrait: R === 0,
      isLandscape: R === 90,
      orientation: R === 0 ? "portrait" : "landscape"
    };
    r.orientation !== L.orientation && c(L);
  }, [r.orientation]);
  return rr.useEffect(function() {
    return (typeof window > "u" ? "undefined" : To(window)) !== void 0 && zl && (w(), window.addEventListener("load", w, !1), window.addEventListener("resize", w, !1)), function() {
      window.removeEventListener("resize", w, !1), window.removeEventListener("load", w, !1);
    };
  }, [w]), r;
}
function Jf(Et) {
  var t = Et || window.navigator.userAgent;
  return Mo(t);
}
function q_(Et) {
  var t = Et || window.navigator.userAgent, r = Jf(t), c = jf(r);
  return [c, r];
}
On.AndroidView = D_;
On.BrowserTypes = br;
On.BrowserView = I_;
On.ConsoleView = F_;
On.CustomView = j_;
On.IEView = R_;
On.IOSView = C_;
On.MobileOnlyView = O_;
On.MobileView = N_;
On.OsTypes = Qs;
On.SmartTVView = Y_;
On.TabletView = P_;
On.WearableView = U_;
On.WinPhoneView = z_;
On.browserName = u_;
On.browserVersion = l_;
On.deviceDetect = Xg;
On.deviceType = __;
On.engineName = h_;
On.engineVersion = f_;
On.fullBrowserVersion = o_;
On.getSelectorsByUserAgent = L_;
On.getUA = m_;
On.isAndroid = Kf;
On.isBrowser = Wf;
On.isChrome = e_;
On.isChromium = Zg;
On.isConsole = Hf;
var G_ = On.isDesktop = t_;
On.isEdge = p_;
On.isEdgeChromium = w_;
On.isElectron = T_;
On.isEmbedded = Qg;
On.isFirefox = n_;
On.isIE = Qf;
var uu = On.isIOS = Xf;
On.isIOS13 = y_;
On.isIPad13 = b_;
On.isIPhone13 = E_;
On.isIPod13 = v_;
On.isLegacyEdge = A_;
On.isMIUI = k_;
On.isMacOs = M_;
var Dl = On.isMobile = zl;
On.isMobileOnly = Gf;
On.isMobileSafari = Jg;
On.isOpera = r_;
var Zf = On.isSafari = i_;
On.isSamsungBrowser = x_;
On.isSmartTV = Bf;
var V_ = On.isTablet = Vf;
On.isWearable = qf;
On.isWinPhone = $f;
On.isWindows = S_;
On.isYandex = g_;
On.mobileModel = c_;
On.mobileVendor = d_;
On.osName = s_;
On.osVersion = a_;
On.parseUserAgent = Mo;
On.setUserAgent = qg;
On.useDeviceData = Jf;
On.useDeviceSelectors = q_;
On.useMobileOrientation = H_;
On.withOrientationChange = B_;
const Yr = "Not implemented", Vu = 0, Wu = 1, Al = 2, Ku = 3, $u = 4, Sl = 5, Xu = 6, Il = "initialized", W_ = "error", K_ = "updatestart", $c = "update", Xc = "updateend", $_ = "abort", id = 2048, X_ = 2048, Q_ = 2080, J_ = 25, Z_ = 740, ty = 0.85, ey = 1, Qc = 'mesh/fb;codecs="draco.514"', Jc = 'mesh/mp4;codecs="draco.514"', ny = "image/jpeg", tm = "audio", Fr = "video", Xa = "mesh", Zc = 4, Ao = 16, yr = 16, $s = 4, ba = 10, iy = "https://player4-dev.8i.com/draco/", em = 1, ry = 4, Ml = "full", ho = "delta", th = "interpolated", ay = "StringEntry", fo = "IntEntryArray", eh = "IntEntry", sy = "manifestloading", oy = "manifestloaded", rd = "qualitychange", nm = "frameratechange", ly = "destroy", uy = "keyreceived", dy = "immersive-vr", cy = "immersive-ar", hy = "A128CTR", fy = "decrypt", my = "jwk", im = "AES-CTR", vo = 1 << ba, nh = vo >> 1, ih = 6e4, py = /^(rtmp|https?:\/\/|mailto:|data:|tel:)/, gy = /^(-)?\d+$/, _y = (Et) => typeof Et < "u", Rl = (Et) => typeof Et == "number" && !isNaN(Et), yy = (Et) => Rl(Et) ? gy.test(Et.toString()) : !1, rm = (Et) => typeof Et == "string", by = (Et) => rm(Et) && Et.trim().length > 0, Ey = (Et) => rm(Et) ? py.test(Et) : !1, vy = /* @__PURE__ */ new Map([
  [Vu, "SILLY"],
  [Wu, "TRACE"],
  [Al, "DEBUG"],
  [Ku, "INFO "],
  [$u, "WARN "],
  [Sl, "ERROR"],
  [Xu, "FATAL"]
]);
class Ol {
  constructor(t = "Triangular", r = {}) {
    this.prettyLogTemplate = [], this.name = t;
    const { prettyLogTemplate: c } = this;
    let w = r == null ? void 0 : r.logLevel;
    yy(w) || (w = Sl), this.logLevel = w, c.push("{{logLevelName}}", "{{nameWithDelimiterSuffix}}"), w > Al && c.unshift("{{dateIsoStr}}");
  }
  formatLog(t, ...r) {
    const { prettyLogTemplate: c, name: w } = this, R = (/* @__PURE__ */ new Date()).toISOString(), L = w ? `${w}:` : "", h = vy.get(t);
    let b = c.join(" ");
    return b = b.replace("{{logLevelName}}", h).replace("{{dateIsoStr}}", R).replace("{{nameWithDelimiterSuffix}}", L), [b, ...r];
  }
  setLogLevel(t) {
    this.logLevel = t;
  }
  silly(...t) {
    const { logLevel: r } = this;
    r > Vu || console.debug(...this.formatLog(Vu, ...t));
  }
  trace(...t) {
    const { logLevel: r } = this;
    r > Wu || console.trace(...this.formatLog(Wu, ...t));
  }
  debug(...t) {
    const { logLevel: r } = this;
    r > Al || console.debug(...this.formatLog(Al, ...t));
  }
  info(...t) {
    const { logLevel: r } = this;
    r > Ku || console.info(...this.formatLog(Ku, ...t));
  }
  warn(...t) {
    const { logLevel: r } = this;
    r > $u || console.warn(...this.formatLog($u, ...t));
  }
  error(...t) {
    const { logLevel: r } = this;
    r > Sl || console.error(...this.formatLog(Sl, ...t));
  }
  fatal(...t) {
    const { logLevel: r } = this;
    r > Xu || console.error(...this.formatLog(Xu, "FATAL:", ...t));
  }
}
var am = {};
(function(Et) {
  var t = /* @__PURE__ */ function() {
    var e = /* @__PURE__ */ new Date(), n = 4, d = 3, _ = 2, p = 1, P = n, $ = {
      setLogLevel: function(ot) {
        ot == this.debug ? P = p : ot == this.info ? P = _ : ot == this.warn ? P = d : (ot == this.error, P = n);
      },
      debug: function(ot, dt) {
        console.debug === void 0 && (console.debug = console.log), p >= P && console.debug("[" + t.getDurationString(/* @__PURE__ */ new Date() - e, 1e3) + "]", "[" + ot + "]", dt);
      },
      log: function(ot, dt) {
        this.debug(ot.msg);
      },
      info: function(ot, dt) {
        _ >= P && console.info("[" + t.getDurationString(/* @__PURE__ */ new Date() - e, 1e3) + "]", "[" + ot + "]", dt);
      },
      warn: function(ot, dt) {
        d >= P && console.warn("[" + t.getDurationString(/* @__PURE__ */ new Date() - e, 1e3) + "]", "[" + ot + "]", dt);
      },
      error: function(ot, dt) {
        n >= P && console.error("[" + t.getDurationString(/* @__PURE__ */ new Date() - e, 1e3) + "]", "[" + ot + "]", dt);
      }
    };
    return $;
  }();
  t.getDurationString = function(e, n) {
    var d;
    function _(xt, Nt) {
      for (var jt = "" + xt, q = jt.split("."); q[0].length < Nt; )
        q[0] = "0" + q[0];
      return q.join(".");
    }
    e < 0 ? (d = !0, e = -e) : d = !1;
    var p = n || 1, P = e / p, $ = Math.floor(P / 3600);
    P -= $ * 3600;
    var ot = Math.floor(P / 60);
    P -= ot * 60;
    var dt = P * 1e3;
    return P = Math.floor(P), dt -= P * 1e3, dt = Math.floor(dt), (d ? "-" : "") + $ + ":" + _(ot, 2) + ":" + _(P, 2) + "." + _(dt, 3);
  }, t.printRanges = function(e) {
    var n = e.length;
    if (n > 0) {
      for (var d = "", _ = 0; _ < n; _++)
        _ > 0 && (d += ","), d += "[" + t.getDurationString(e.start(_)) + "," + t.getDurationString(e.end(_)) + "]";
      return d;
    } else
      return "(empty)";
  }, Et.Log = t;
  var r = function(e) {
    if (e instanceof ArrayBuffer)
      this.buffer = e, this.dataview = new DataView(e);
    else
      throw "Needs an array buffer";
    this.position = 0;
  };
  r.prototype.getPosition = function() {
    return this.position;
  }, r.prototype.getEndPosition = function() {
    return this.buffer.byteLength;
  }, r.prototype.getLength = function() {
    return this.buffer.byteLength;
  }, r.prototype.seek = function(e) {
    var n = Math.max(0, Math.min(this.buffer.byteLength, e));
    return this.position = isNaN(n) || !isFinite(n) ? 0 : n, !0;
  }, r.prototype.isEos = function() {
    return this.getPosition() >= this.getEndPosition();
  }, r.prototype.readAnyInt = function(e, n) {
    var d = 0;
    if (this.position + e <= this.buffer.byteLength) {
      switch (e) {
        case 1:
          n ? d = this.dataview.getInt8(this.position) : d = this.dataview.getUint8(this.position);
          break;
        case 2:
          n ? d = this.dataview.getInt16(this.position) : d = this.dataview.getUint16(this.position);
          break;
        case 3:
          if (n)
            throw "No method for reading signed 24 bits values";
          d = this.dataview.getUint8(this.position) << 16, d |= this.dataview.getUint8(this.position + 1) << 8, d |= this.dataview.getUint8(this.position + 2);
          break;
        case 4:
          n ? d = this.dataview.getInt32(this.position) : d = this.dataview.getUint32(this.position);
          break;
        case 8:
          if (n)
            throw "No method for reading signed 64 bits values";
          d = this.dataview.getUint32(this.position) << 32, d |= this.dataview.getUint32(this.position + 4);
          break;
        default:
          throw "readInt method not implemented for size: " + e;
      }
      return this.position += e, d;
    } else
      throw "Not enough bytes in buffer";
  }, r.prototype.readUint8 = function() {
    return this.readAnyInt(1, !1);
  }, r.prototype.readUint16 = function() {
    return this.readAnyInt(2, !1);
  }, r.prototype.readUint24 = function() {
    return this.readAnyInt(3, !1);
  }, r.prototype.readUint32 = function() {
    return this.readAnyInt(4, !1);
  }, r.prototype.readUint64 = function() {
    return this.readAnyInt(8, !1);
  }, r.prototype.readString = function(e) {
    if (this.position + e <= this.buffer.byteLength) {
      for (var n = "", d = 0; d < e; d++)
        n += String.fromCharCode(this.readUint8());
      return n;
    } else
      throw "Not enough bytes in buffer";
  }, r.prototype.readCString = function() {
    for (var e = []; ; ) {
      var n = this.readUint8();
      if (n !== 0)
        e.push(n);
      else
        break;
    }
    return String.fromCharCode.apply(null, e);
  }, r.prototype.readInt8 = function() {
    return this.readAnyInt(1, !0);
  }, r.prototype.readInt16 = function() {
    return this.readAnyInt(2, !0);
  }, r.prototype.readInt32 = function() {
    return this.readAnyInt(4, !0);
  }, r.prototype.readInt64 = function() {
    return this.readAnyInt(8, !1);
  }, r.prototype.readUint8Array = function(e) {
    for (var n = new Uint8Array(e), d = 0; d < e; d++)
      n[d] = this.readUint8();
    return n;
  }, r.prototype.readInt16Array = function(e) {
    for (var n = new Int16Array(e), d = 0; d < e; d++)
      n[d] = this.readInt16();
    return n;
  }, r.prototype.readUint16Array = function(e) {
    for (var n = new Int16Array(e), d = 0; d < e; d++)
      n[d] = this.readUint16();
    return n;
  }, r.prototype.readUint32Array = function(e) {
    for (var n = new Uint32Array(e), d = 0; d < e; d++)
      n[d] = this.readUint32();
    return n;
  }, r.prototype.readInt32Array = function(e) {
    for (var n = new Int32Array(e), d = 0; d < e; d++)
      n[d] = this.readInt32();
    return n;
  }, Et.MP4BoxStream = r;
  var c = function(e, n, d) {
    this._byteOffset = n || 0, e instanceof ArrayBuffer ? this.buffer = e : typeof e == "object" ? (this.dataView = e, n && (this._byteOffset += n)) : this.buffer = new ArrayBuffer(e || 0), this.position = 0, this.endianness = d ?? c.LITTLE_ENDIAN;
  };
  c.prototype = {}, c.prototype.getPosition = function() {
    return this.position;
  }, c.prototype._realloc = function(e) {
    if (this._dynamicSize) {
      var n = this._byteOffset + this.position + e, d = this._buffer.byteLength;
      if (n <= d) {
        n > this._byteLength && (this._byteLength = n);
        return;
      }
      for (d < 1 && (d = 1); n > d; )
        d *= 2;
      var _ = new ArrayBuffer(d), p = new Uint8Array(this._buffer), P = new Uint8Array(_, 0, p.length);
      P.set(p), this.buffer = _, this._byteLength = n;
    }
  }, c.prototype._trimAlloc = function() {
    if (this._byteLength != this._buffer.byteLength) {
      var e = new ArrayBuffer(this._byteLength), n = new Uint8Array(e), d = new Uint8Array(this._buffer, 0, n.length);
      n.set(d), this.buffer = e;
    }
  }, c.BIG_ENDIAN = !1, c.LITTLE_ENDIAN = !0, c.prototype._byteLength = 0, Object.defineProperty(
    c.prototype,
    "byteLength",
    { get: function() {
      return this._byteLength - this._byteOffset;
    } }
  ), Object.defineProperty(
    c.prototype,
    "buffer",
    {
      get: function() {
        return this._trimAlloc(), this._buffer;
      },
      set: function(e) {
        this._buffer = e, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;
      }
    }
  ), Object.defineProperty(
    c.prototype,
    "byteOffset",
    {
      get: function() {
        return this._byteOffset;
      },
      set: function(e) {
        this._byteOffset = e, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._buffer.byteLength;
      }
    }
  ), Object.defineProperty(
    c.prototype,
    "dataView",
    {
      get: function() {
        return this._dataView;
      },
      set: function(e) {
        this._byteOffset = e.byteOffset, this._buffer = e.buffer, this._dataView = new DataView(this._buffer, this._byteOffset), this._byteLength = this._byteOffset + e.byteLength;
      }
    }
  ), c.prototype.seek = function(e) {
    var n = Math.max(0, Math.min(this.byteLength, e));
    this.position = isNaN(n) || !isFinite(n) ? 0 : n;
  }, c.prototype.isEof = function() {
    return this.position >= this._byteLength;
  }, c.prototype.mapUint8Array = function(e) {
    this._realloc(e * 1);
    var n = new Uint8Array(this._buffer, this.byteOffset + this.position, e);
    return this.position += e * 1, n;
  }, c.prototype.readInt32Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 4;
    var d = new Int32Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readInt16Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 2;
    var d = new Int16Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readInt8Array = function(e) {
    e = e ?? this.byteLength - this.position;
    var n = new Int8Array(e);
    return c.memcpy(
      n.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * n.BYTES_PER_ELEMENT
    ), this.position += n.byteLength, n;
  }, c.prototype.readUint32Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 4;
    var d = new Uint32Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readUint16Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 2;
    var d = new Uint16Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readUint8Array = function(e) {
    e = e ?? this.byteLength - this.position;
    var n = new Uint8Array(e);
    return c.memcpy(
      n.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * n.BYTES_PER_ELEMENT
    ), this.position += n.byteLength, n;
  }, c.prototype.readFloat64Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 8;
    var d = new Float64Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readFloat32Array = function(e, n) {
    e = e ?? this.byteLength - this.position / 4;
    var d = new Float32Array(e);
    return c.memcpy(
      d.buffer,
      0,
      this.buffer,
      this.byteOffset + this.position,
      e * d.BYTES_PER_ELEMENT
    ), c.arrayToNative(d, n ?? this.endianness), this.position += d.byteLength, d;
  }, c.prototype.readInt32 = function(e) {
    var n = this._dataView.getInt32(this.position, e ?? this.endianness);
    return this.position += 4, n;
  }, c.prototype.readInt16 = function(e) {
    var n = this._dataView.getInt16(this.position, e ?? this.endianness);
    return this.position += 2, n;
  }, c.prototype.readInt8 = function() {
    var e = this._dataView.getInt8(this.position);
    return this.position += 1, e;
  }, c.prototype.readUint32 = function(e) {
    var n = this._dataView.getUint32(this.position, e ?? this.endianness);
    return this.position += 4, n;
  }, c.prototype.readUint16 = function(e) {
    var n = this._dataView.getUint16(this.position, e ?? this.endianness);
    return this.position += 2, n;
  }, c.prototype.readUint8 = function() {
    var e = this._dataView.getUint8(this.position);
    return this.position += 1, e;
  }, c.prototype.readFloat32 = function(e) {
    var n = this._dataView.getFloat32(this.position, e ?? this.endianness);
    return this.position += 4, n;
  }, c.prototype.readFloat64 = function(e) {
    var n = this._dataView.getFloat64(this.position, e ?? this.endianness);
    return this.position += 8, n;
  }, c.endianness = new Int8Array(new Int16Array([1]).buffer)[0] > 0, c.memcpy = function(e, n, d, _, p) {
    var P = new Uint8Array(e, n, p), $ = new Uint8Array(d, _, p);
    P.set($);
  }, c.arrayToNative = function(e, n) {
    return n == this.endianness ? e : this.flipArrayEndianness(e);
  }, c.nativeToEndian = function(e, n) {
    return this.endianness == n ? e : this.flipArrayEndianness(e);
  }, c.flipArrayEndianness = function(e) {
    for (var n = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), d = 0; d < e.byteLength; d += e.BYTES_PER_ELEMENT)
      for (var _ = d + e.BYTES_PER_ELEMENT - 1, p = d; _ > p; _--, p++) {
        var P = n[p];
        n[p] = n[_], n[_] = P;
      }
    return e;
  }, c.prototype.failurePosition = 0, String.fromCharCodeUint8 = function(e) {
    for (var n = [], d = 0; d < e.length; d++)
      n[d] = e[d];
    return String.fromCharCode.apply(null, n);
  }, c.prototype.readString = function(e, n) {
    return n == null || n == "ASCII" ? String.fromCharCodeUint8.apply(null, [this.mapUint8Array(e ?? this.byteLength - this.position)]) : new TextDecoder(n).decode(this.mapUint8Array(e));
  }, c.prototype.readCString = function(e) {
    var n = this.byteLength - this.position, d = new Uint8Array(this._buffer, this._byteOffset + this.position), _ = n;
    e != null && (_ = Math.min(e, n));
    for (var p = 0; p < _ && d[p] !== 0; p++) ;
    var P = String.fromCharCodeUint8.apply(null, [this.mapUint8Array(p)]);
    return e != null ? this.position += _ - p : p != n && (this.position += 1), P;
  };
  var w = Math.pow(2, 32);
  c.prototype.readInt64 = function() {
    return this.readInt32() * w + this.readUint32();
  }, c.prototype.readUint64 = function() {
    return this.readUint32() * w + this.readUint32();
  }, c.prototype.readInt64 = function() {
    return this.readUint32() * w + this.readUint32();
  }, c.prototype.readUint24 = function() {
    return (this.readUint8() << 16) + (this.readUint8() << 8) + this.readUint8();
  }, Et.DataStream = c, c.prototype.save = function(e) {
    var n = new Blob([this.buffer]);
    if (window.URL && URL.createObjectURL) {
      var d = window.URL.createObjectURL(n), _ = document.createElement("a");
      document.body.appendChild(_), _.setAttribute("href", d), _.setAttribute("download", e), _.setAttribute("target", "_self"), _.click(), window.URL.revokeObjectURL(d);
    } else
      throw "DataStream.save: Can't create object URL.";
  }, c.prototype._dynamicSize = !0, Object.defineProperty(
    c.prototype,
    "dynamicSize",
    {
      get: function() {
        return this._dynamicSize;
      },
      set: function(e) {
        e || this._trimAlloc(), this._dynamicSize = e;
      }
    }
  ), c.prototype.shift = function(e) {
    var n = new ArrayBuffer(this._byteLength - e), d = new Uint8Array(n), _ = new Uint8Array(this._buffer, e, d.length);
    d.set(_), this.buffer = n, this.position -= e;
  }, c.prototype.writeInt32Array = function(e, n) {
    if (this._realloc(e.length * 4), e instanceof Int32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapInt32Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeInt32(e[d], n);
  }, c.prototype.writeInt16Array = function(e, n) {
    if (this._realloc(e.length * 2), e instanceof Int16Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapInt16Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeInt16(e[d], n);
  }, c.prototype.writeInt8Array = function(e) {
    if (this._realloc(e.length * 1), e instanceof Int8Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapInt8Array(e.length);
    else
      for (var n = 0; n < e.length; n++)
        this.writeInt8(e[n]);
  }, c.prototype.writeUint32Array = function(e, n) {
    if (this._realloc(e.length * 4), e instanceof Uint32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapUint32Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeUint32(e[d], n);
  }, c.prototype.writeUint16Array = function(e, n) {
    if (this._realloc(e.length * 2), e instanceof Uint16Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapUint16Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeUint16(e[d], n);
  }, c.prototype.writeUint8Array = function(e) {
    if (this._realloc(e.length * 1), e instanceof Uint8Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapUint8Array(e.length);
    else
      for (var n = 0; n < e.length; n++)
        this.writeUint8(e[n]);
  }, c.prototype.writeFloat64Array = function(e, n) {
    if (this._realloc(e.length * 8), e instanceof Float64Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapFloat64Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeFloat64(e[d], n);
  }, c.prototype.writeFloat32Array = function(e, n) {
    if (this._realloc(e.length * 4), e instanceof Float32Array && this.byteOffset + this.position % e.BYTES_PER_ELEMENT === 0)
      c.memcpy(
        this._buffer,
        this.byteOffset + this.position,
        e.buffer,
        0,
        e.byteLength
      ), this.mapFloat32Array(e.length, n);
    else
      for (var d = 0; d < e.length; d++)
        this.writeFloat32(e[d], n);
  }, c.prototype.writeInt32 = function(e, n) {
    this._realloc(4), this._dataView.setInt32(this.position, e, n ?? this.endianness), this.position += 4;
  }, c.prototype.writeInt16 = function(e, n) {
    this._realloc(2), this._dataView.setInt16(this.position, e, n ?? this.endianness), this.position += 2;
  }, c.prototype.writeInt8 = function(e) {
    this._realloc(1), this._dataView.setInt8(this.position, e), this.position += 1;
  }, c.prototype.writeUint32 = function(e, n) {
    this._realloc(4), this._dataView.setUint32(this.position, e, n ?? this.endianness), this.position += 4;
  }, c.prototype.writeUint16 = function(e, n) {
    this._realloc(2), this._dataView.setUint16(this.position, e, n ?? this.endianness), this.position += 2;
  }, c.prototype.writeUint8 = function(e) {
    this._realloc(1), this._dataView.setUint8(this.position, e), this.position += 1;
  }, c.prototype.writeFloat32 = function(e, n) {
    this._realloc(4), this._dataView.setFloat32(this.position, e, n ?? this.endianness), this.position += 4;
  }, c.prototype.writeFloat64 = function(e, n) {
    this._realloc(8), this._dataView.setFloat64(this.position, e, n ?? this.endianness), this.position += 8;
  }, c.prototype.writeUCS2String = function(e, n, d) {
    d == null && (d = e.length);
    for (var _ = 0; _ < e.length && _ < d; _++)
      this.writeUint16(e.charCodeAt(_), n);
    for (; _ < d; _++)
      this.writeUint16(0);
  }, c.prototype.writeString = function(e, n, d) {
    var _ = 0;
    if (n == null || n == "ASCII")
      if (d != null) {
        var p = Math.min(e.length, d);
        for (_ = 0; _ < p; _++)
          this.writeUint8(e.charCodeAt(_));
        for (; _ < d; _++)
          this.writeUint8(0);
      } else
        for (_ = 0; _ < e.length; _++)
          this.writeUint8(e.charCodeAt(_));
    else
      this.writeUint8Array(new TextEncoder(n).encode(e.substring(0, d)));
  }, c.prototype.writeCString = function(e, n) {
    var d = 0;
    if (n != null) {
      var _ = Math.min(e.length, n);
      for (d = 0; d < _; d++)
        this.writeUint8(e.charCodeAt(d));
      for (; d < n; d++)
        this.writeUint8(0);
    } else {
      for (d = 0; d < e.length; d++)
        this.writeUint8(e.charCodeAt(d));
      this.writeUint8(0);
    }
  }, c.prototype.writeStruct = function(e, n) {
    for (var d = 0; d < e.length; d += 2) {
      var _ = e[d + 1];
      this.writeType(_, n[e[d]], n);
    }
  }, c.prototype.writeType = function(e, n, d) {
    var _;
    if (typeof e == "function")
      return e(this, n);
    if (typeof e == "object" && !(e instanceof Array))
      return e.set(this, n, d);
    var p = null, P = "ASCII", $ = this.position;
    switch (typeof e == "string" && /:/.test(e) && (_ = e.split(":"), e = _[0], p = parseInt(_[1])), typeof e == "string" && /,/.test(e) && (_ = e.split(","), e = _[0], P = parseInt(_[1])), e) {
      case "uint8":
        this.writeUint8(n);
        break;
      case "int8":
        this.writeInt8(n);
        break;
      case "uint16":
        this.writeUint16(n, this.endianness);
        break;
      case "int16":
        this.writeInt16(n, this.endianness);
        break;
      case "uint32":
        this.writeUint32(n, this.endianness);
        break;
      case "int32":
        this.writeInt32(n, this.endianness);
        break;
      case "float32":
        this.writeFloat32(n, this.endianness);
        break;
      case "float64":
        this.writeFloat64(n, this.endianness);
        break;
      case "uint16be":
        this.writeUint16(n, c.BIG_ENDIAN);
        break;
      case "int16be":
        this.writeInt16(n, c.BIG_ENDIAN);
        break;
      case "uint32be":
        this.writeUint32(n, c.BIG_ENDIAN);
        break;
      case "int32be":
        this.writeInt32(n, c.BIG_ENDIAN);
        break;
      case "float32be":
        this.writeFloat32(n, c.BIG_ENDIAN);
        break;
      case "float64be":
        this.writeFloat64(n, c.BIG_ENDIAN);
        break;
      case "uint16le":
        this.writeUint16(n, c.LITTLE_ENDIAN);
        break;
      case "int16le":
        this.writeInt16(n, c.LITTLE_ENDIAN);
        break;
      case "uint32le":
        this.writeUint32(n, c.LITTLE_ENDIAN);
        break;
      case "int32le":
        this.writeInt32(n, c.LITTLE_ENDIAN);
        break;
      case "float32le":
        this.writeFloat32(n, c.LITTLE_ENDIAN);
        break;
      case "float64le":
        this.writeFloat64(n, c.LITTLE_ENDIAN);
        break;
      case "cstring":
        this.writeCString(n, p);
        break;
      case "string":
        this.writeString(n, P, p);
        break;
      case "u16string":
        this.writeUCS2String(n, this.endianness, p);
        break;
      case "u16stringle":
        this.writeUCS2String(n, c.LITTLE_ENDIAN, p);
        break;
      case "u16stringbe":
        this.writeUCS2String(n, c.BIG_ENDIAN, p);
        break;
      default:
        if (e.length == 3) {
          for (var ot = e[1], dt = 0; dt < n.length; dt++)
            this.writeType(ot, n[dt]);
          break;
        } else {
          this.writeStruct(e, n);
          break;
        }
    }
    p != null && (this.position = $, this._realloc(p), this.position = $ + p);
  }, c.prototype.writeUint64 = function(e) {
    var n = Math.floor(e / w);
    this.writeUint32(n), this.writeUint32(e & 4294967295);
  }, c.prototype.writeUint24 = function(e) {
    this.writeUint8((e & 16711680) >> 16), this.writeUint8((e & 65280) >> 8), this.writeUint8(e & 255);
  }, c.prototype.adjustUint32 = function(e, n) {
    var d = this.position;
    this.seek(e), this.writeUint32(n), this.seek(d);
  }, c.prototype.mapInt32Array = function(e, n) {
    this._realloc(e * 4);
    var d = new Int32Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 4, d;
  }, c.prototype.mapInt16Array = function(e, n) {
    this._realloc(e * 2);
    var d = new Int16Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 2, d;
  }, c.prototype.mapInt8Array = function(e) {
    this._realloc(e * 1);
    var n = new Int8Array(this._buffer, this.byteOffset + this.position, e);
    return this.position += e * 1, n;
  }, c.prototype.mapUint32Array = function(e, n) {
    this._realloc(e * 4);
    var d = new Uint32Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 4, d;
  }, c.prototype.mapUint16Array = function(e, n) {
    this._realloc(e * 2);
    var d = new Uint16Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 2, d;
  }, c.prototype.mapFloat64Array = function(e, n) {
    this._realloc(e * 8);
    var d = new Float64Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 8, d;
  }, c.prototype.mapFloat32Array = function(e, n) {
    this._realloc(e * 4);
    var d = new Float32Array(this._buffer, this.byteOffset + this.position, e);
    return c.arrayToNative(d, n ?? this.endianness), this.position += e * 4, d;
  };
  var R = function(e) {
    this.buffers = [], this.bufferIndex = -1, e && (this.insertBuffer(e), this.bufferIndex = 0);
  };
  R.prototype = new c(new ArrayBuffer(), 0, c.BIG_ENDIAN), R.prototype.initialized = function() {
    var e;
    return this.bufferIndex > -1 ? !0 : this.buffers.length > 0 ? (e = this.buffers[0], e.fileStart === 0 ? (this.buffer = e, this.bufferIndex = 0, t.debug("MultiBufferStream", "Stream ready for parsing"), !0) : (t.warn("MultiBufferStream", "The first buffer should have a fileStart of 0"), this.logBufferLevel(), !1)) : (t.warn("MultiBufferStream", "No buffer to start parsing from"), this.logBufferLevel(), !1);
  }, ArrayBuffer.concat = function(e, n) {
    t.debug("ArrayBuffer", "Trying to create a new buffer of size: " + (e.byteLength + n.byteLength));
    var d = new Uint8Array(e.byteLength + n.byteLength);
    return d.set(new Uint8Array(e), 0), d.set(new Uint8Array(n), e.byteLength), d.buffer;
  }, R.prototype.reduceBuffer = function(e, n, d) {
    var _;
    return _ = new Uint8Array(d), _.set(new Uint8Array(e, n, d)), _.buffer.fileStart = e.fileStart + n, _.buffer.usedBytes = 0, _.buffer;
  }, R.prototype.insertBuffer = function(e) {
    for (var n = !0, d = 0; d < this.buffers.length; d++) {
      var _ = this.buffers[d];
      if (e.fileStart <= _.fileStart) {
        if (e.fileStart === _.fileStart)
          if (e.byteLength > _.byteLength) {
            this.buffers.splice(d, 1), d--;
            continue;
          } else
            t.warn("MultiBufferStream", "Buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ") already appended, ignoring");
        else
          e.fileStart + e.byteLength <= _.fileStart || (e = this.reduceBuffer(e, 0, _.fileStart - e.fileStart)), t.debug("MultiBufferStream", "Appending new buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ")"), this.buffers.splice(d, 0, e), d === 0 && (this.buffer = e);
        n = !1;
        break;
      } else if (e.fileStart < _.fileStart + _.byteLength) {
        var p = _.fileStart + _.byteLength - e.fileStart, P = e.byteLength - p;
        if (P > 0)
          e = this.reduceBuffer(e, p, P);
        else {
          n = !1;
          break;
        }
      }
    }
    n && (t.debug("MultiBufferStream", "Appending new buffer (fileStart: " + e.fileStart + " - Length: " + e.byteLength + ")"), this.buffers.push(e), d === 0 && (this.buffer = e));
  }, R.prototype.logBufferLevel = function(e) {
    var n, d, _, p, P = [], $, ot = "";
    for (_ = 0, p = 0, n = 0; n < this.buffers.length; n++)
      d = this.buffers[n], n === 0 ? ($ = {}, P.push($), $.start = d.fileStart, $.end = d.fileStart + d.byteLength, ot += "[" + $.start + "-") : $.end === d.fileStart ? $.end = d.fileStart + d.byteLength : ($ = {}, $.start = d.fileStart, ot += P[P.length - 1].end - 1 + "], [" + $.start + "-", $.end = d.fileStart + d.byteLength, P.push($)), _ += d.usedBytes, p += d.byteLength;
    P.length > 0 && (ot += $.end - 1 + "]");
    var dt = e ? t.info : t.debug;
    this.buffers.length === 0 ? dt("MultiBufferStream", "No more buffer in memory") : dt("MultiBufferStream", "" + this.buffers.length + " stored buffer(s) (" + _ + "/" + p + " bytes), continuous ranges: " + ot);
  }, R.prototype.cleanBuffers = function() {
    var e, n;
    for (e = 0; e < this.buffers.length; e++)
      n = this.buffers[e], n.usedBytes === n.byteLength && (t.debug("MultiBufferStream", "Removing buffer #" + e), this.buffers.splice(e, 1), e--);
  }, R.prototype.mergeNextBuffer = function() {
    var e;
    if (this.bufferIndex + 1 < this.buffers.length)
      if (e = this.buffers[this.bufferIndex + 1], e.fileStart === this.buffer.fileStart + this.buffer.byteLength) {
        var n = this.buffer.byteLength, d = this.buffer.usedBytes, _ = this.buffer.fileStart;
        return this.buffers[this.bufferIndex] = ArrayBuffer.concat(this.buffer, e), this.buffer = this.buffers[this.bufferIndex], this.buffers.splice(this.bufferIndex + 1, 1), this.buffer.usedBytes = d, this.buffer.fileStart = _, t.debug("ISOFile", "Concatenating buffer for box parsing (length: " + n + "->" + this.buffer.byteLength + ")"), !0;
      } else
        return !1;
    else
      return !1;
  }, R.prototype.findPosition = function(e, n, d) {
    var _, p = null, P = -1;
    for (e === !0 ? _ = 0 : _ = this.bufferIndex; _ < this.buffers.length && (p = this.buffers[_], p.fileStart <= n); ) {
      P = _, d && (p.fileStart + p.byteLength <= n ? p.usedBytes = p.byteLength : p.usedBytes = n - p.fileStart, this.logBufferLevel());
      _++;
    }
    return P !== -1 ? (p = this.buffers[P], p.fileStart + p.byteLength >= n ? (t.debug("MultiBufferStream", "Found position in existing buffer #" + P), P) : -1) : -1;
  }, R.prototype.findEndContiguousBuf = function(e) {
    var n, d, _, p = e !== void 0 ? e : this.bufferIndex;
    if (d = this.buffers[p], this.buffers.length > p + 1)
      for (n = p + 1; n < this.buffers.length && (_ = this.buffers[n], _.fileStart === d.fileStart + d.byteLength); n++)
        d = _;
    return d.fileStart + d.byteLength;
  }, R.prototype.getEndFilePositionAfter = function(e) {
    var n = this.findPosition(!0, e, !1);
    return n !== -1 ? this.findEndContiguousBuf(n) : e;
  }, R.prototype.addUsedBytes = function(e) {
    this.buffer.usedBytes += e, this.logBufferLevel();
  }, R.prototype.setAllUsedBytes = function() {
    this.buffer.usedBytes = this.buffer.byteLength, this.logBufferLevel();
  }, R.prototype.seek = function(e, n, d) {
    var _;
    return _ = this.findPosition(n, e, d), _ !== -1 ? (this.buffer = this.buffers[_], this.bufferIndex = _, this.position = e - this.buffer.fileStart, t.debug("MultiBufferStream", "Repositioning parser at buffer position: " + this.position), !0) : (t.debug("MultiBufferStream", "Position " + e + " not found in buffered data"), !1);
  }, R.prototype.getPosition = function() {
    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)
      throw "Error accessing position in the MultiBufferStream";
    return this.buffers[this.bufferIndex].fileStart + this.position;
  }, R.prototype.getLength = function() {
    return this.byteLength;
  }, R.prototype.getEndPosition = function() {
    if (this.bufferIndex === -1 || this.buffers[this.bufferIndex] === null)
      throw "Error accessing position in the MultiBufferStream";
    return this.buffers[this.bufferIndex].fileStart + this.byteLength;
  }, Et.MultiBufferStream = R;
  var L = function() {
    var e = 3, n = 4, d = 5, _ = 6, p = [];
    p[e] = "ES_Descriptor", p[n] = "DecoderConfigDescriptor", p[d] = "DecoderSpecificInfo", p[_] = "SLConfigDescriptor", this.getDescriptorName = function(ot) {
      return p[ot];
    };
    var P = this, $ = {};
    return this.parseOneDescriptor = function(ot) {
      var dt = 0, xt, Nt, jt;
      for (xt = ot.readUint8(), jt = ot.readUint8(); jt & 128; )
        dt = (dt << 7) + (jt & 127), jt = ot.readUint8();
      return dt = (dt << 7) + (jt & 127), t.debug("MPEG4DescriptorParser", "Found " + (p[xt] || "Descriptor " + xt) + ", size " + dt + " at position " + ot.getPosition()), p[xt] ? Nt = new $[p[xt]](dt) : Nt = new $.Descriptor(dt), Nt.parse(ot), Nt;
    }, $.Descriptor = function(ot, dt) {
      this.tag = ot, this.size = dt, this.descs = [];
    }, $.Descriptor.prototype.parse = function(ot) {
      this.data = ot.readUint8Array(this.size);
    }, $.Descriptor.prototype.findDescriptor = function(ot) {
      for (var dt = 0; dt < this.descs.length; dt++)
        if (this.descs[dt].tag == ot)
          return this.descs[dt];
      return null;
    }, $.Descriptor.prototype.parseRemainingDescriptors = function(ot) {
      for (var dt = ot.position; ot.position < dt + this.size; ) {
        var xt = P.parseOneDescriptor(ot);
        this.descs.push(xt);
      }
    }, $.ES_Descriptor = function(ot) {
      $.Descriptor.call(this, e, ot);
    }, $.ES_Descriptor.prototype = new $.Descriptor(), $.ES_Descriptor.prototype.parse = function(ot) {
      if (this.ES_ID = ot.readUint16(), this.flags = ot.readUint8(), this.size -= 3, this.flags & 128 ? (this.dependsOn_ES_ID = ot.readUint16(), this.size -= 2) : this.dependsOn_ES_ID = 0, this.flags & 64) {
        var dt = ot.readUint8();
        this.URL = ot.readString(dt), this.size -= dt + 1;
      } else
        this.URL = "";
      this.flags & 32 ? (this.OCR_ES_ID = ot.readUint16(), this.size -= 2) : this.OCR_ES_ID = 0, this.parseRemainingDescriptors(ot);
    }, $.ES_Descriptor.prototype.getOTI = function(ot) {
      var dt = this.findDescriptor(n);
      return dt ? dt.oti : 0;
    }, $.ES_Descriptor.prototype.getAudioConfig = function(ot) {
      var dt = this.findDescriptor(n);
      if (!dt) return null;
      var xt = dt.findDescriptor(d);
      if (xt && xt.data) {
        var Nt = (xt.data[0] & 248) >> 3;
        return Nt === 31 && xt.data.length >= 2 && (Nt = 32 + ((xt.data[0] & 7) << 3) + ((xt.data[1] & 224) >> 5)), Nt;
      } else
        return null;
    }, $.DecoderConfigDescriptor = function(ot) {
      $.Descriptor.call(this, n, ot);
    }, $.DecoderConfigDescriptor.prototype = new $.Descriptor(), $.DecoderConfigDescriptor.prototype.parse = function(ot) {
      this.oti = ot.readUint8(), this.streamType = ot.readUint8(), this.upStream = (this.streamType >> 1 & 1) !== 0, this.streamType = this.streamType >>> 2, this.bufferSize = ot.readUint24(), this.maxBitrate = ot.readUint32(), this.avgBitrate = ot.readUint32(), this.size -= 13, this.parseRemainingDescriptors(ot);
    }, $.DecoderSpecificInfo = function(ot) {
      $.Descriptor.call(this, d, ot);
    }, $.DecoderSpecificInfo.prototype = new $.Descriptor(), $.SLConfigDescriptor = function(ot) {
      $.Descriptor.call(this, _, ot);
    }, $.SLConfigDescriptor.prototype = new $.Descriptor(), this;
  };
  Et.MPEG4DescriptorParser = L;
  var h = {
    ERR_INVALID_DATA: -1,
    ERR_NOT_ENOUGH_DATA: 0,
    OK: 1,
    // Boxes to be created with default parsing
    BASIC_BOXES: ["mdat", "idat", "free", "skip", "meco", "strk"],
    FULL_BOXES: ["hmhd", "nmhd", "iods", "xml ", "bxml", "ipro", "mere"],
    CONTAINER_BOXES: [
      ["moov", ["trak", "pssh"]],
      ["trak"],
      ["edts"],
      ["mdia"],
      ["minf"],
      ["dinf"],
      ["stbl", ["sgpd", "sbgp"]],
      ["mvex", ["trex"]],
      ["moof", ["traf"]],
      ["traf", ["trun", "sgpd", "sbgp"]],
      ["vttc"],
      ["tref"],
      ["iref"],
      ["mfra", ["tfra"]],
      ["meco"],
      ["hnti"],
      ["hinf"],
      ["strk"],
      ["strd"],
      ["sinf"],
      ["rinf"],
      ["schi"],
      ["trgr"],
      ["udta", ["kind"]],
      ["iprp", ["ipma"]],
      ["ipco"],
      ["grpl"],
      ["j2kH"],
      ["etyp", ["tyco"]]
    ],
    // Boxes effectively created
    boxCodes: [],
    fullBoxCodes: [],
    containerBoxCodes: [],
    sampleEntryCodes: {},
    sampleGroupEntryCodes: [],
    trackGroupTypes: [],
    UUIDBoxes: {},
    UUIDs: [],
    initialize: function() {
      h.FullBox.prototype = new h.Box(), h.ContainerBox.prototype = new h.Box(), h.SampleEntry.prototype = new h.Box(), h.TrackGroupTypeBox.prototype = new h.FullBox(), h.BASIC_BOXES.forEach(function(e) {
        h.createBoxCtor(e);
      }), h.FULL_BOXES.forEach(function(e) {
        h.createFullBoxCtor(e);
      }), h.CONTAINER_BOXES.forEach(function(e) {
        h.createContainerBoxCtor(e[0], null, e[1]);
      });
    },
    Box: function(e, n, d) {
      this.type = e, this.size = n, this.uuid = d;
    },
    FullBox: function(e, n, d) {
      h.Box.call(this, e, n, d), this.flags = 0, this.version = 0;
    },
    ContainerBox: function(e, n, d) {
      h.Box.call(this, e, n, d), this.boxes = [];
    },
    SampleEntry: function(e, n, d, _) {
      h.ContainerBox.call(this, e, n), this.hdr_size = d, this.start = _;
    },
    SampleGroupEntry: function(e) {
      this.grouping_type = e;
    },
    TrackGroupTypeBox: function(e, n) {
      h.FullBox.call(this, e, n);
    },
    createBoxCtor: function(e, n) {
      h.boxCodes.push(e), h[e + "Box"] = function(d) {
        h.Box.call(this, e, d);
      }, h[e + "Box"].prototype = new h.Box(), n && (h[e + "Box"].prototype.parse = n);
    },
    createFullBoxCtor: function(e, n) {
      h[e + "Box"] = function(d) {
        h.FullBox.call(this, e, d);
      }, h[e + "Box"].prototype = new h.FullBox(), h[e + "Box"].prototype.parse = function(d) {
        this.parseFullHeader(d), n && n.call(this, d);
      };
    },
    addSubBoxArrays: function(e) {
      if (e) {
        this.subBoxNames = e;
        for (var n = e.length, d = 0; d < n; d++)
          this[e[d] + "s"] = [];
      }
    },
    createContainerBoxCtor: function(e, n, d) {
      h[e + "Box"] = function(_) {
        h.ContainerBox.call(this, e, _), h.addSubBoxArrays.call(this, d);
      }, h[e + "Box"].prototype = new h.ContainerBox(), n && (h[e + "Box"].prototype.parse = n);
    },
    createMediaSampleEntryCtor: function(e, n, d) {
      h.sampleEntryCodes[e] = [], h[e + "SampleEntry"] = function(_, p) {
        h.SampleEntry.call(this, _, p), h.addSubBoxArrays.call(this, d);
      }, h[e + "SampleEntry"].prototype = new h.SampleEntry(), n && (h[e + "SampleEntry"].prototype.parse = n);
    },
    createSampleEntryCtor: function(e, n, d, _) {
      h.sampleEntryCodes[e].push(n), h[n + "SampleEntry"] = function(p) {
        h[e + "SampleEntry"].call(this, n, p), h.addSubBoxArrays.call(this, _);
      }, h[n + "SampleEntry"].prototype = new h[e + "SampleEntry"](), d && (h[n + "SampleEntry"].prototype.parse = d);
    },
    createEncryptedSampleEntryCtor: function(e, n, d) {
      h.createSampleEntryCtor.call(this, e, n, d, ["sinf"]);
    },
    createSampleGroupCtor: function(e, n) {
      h[e + "SampleGroupEntry"] = function(d) {
        h.SampleGroupEntry.call(this, e, d);
      }, h[e + "SampleGroupEntry"].prototype = new h.SampleGroupEntry(), n && (h[e + "SampleGroupEntry"].prototype.parse = n);
    },
    createTrackGroupCtor: function(e, n) {
      h[e + "TrackGroupTypeBox"] = function(d) {
        h.TrackGroupTypeBox.call(this, e, d);
      }, h[e + "TrackGroupTypeBox"].prototype = new h.TrackGroupTypeBox(), n && (h[e + "TrackGroupTypeBox"].prototype.parse = n);
    },
    createUUIDBox: function(e, n, d, _) {
      h.UUIDs.push(e), h.UUIDBoxes[e] = function(p) {
        n ? h.FullBox.call(this, "uuid", p, e) : d ? h.ContainerBox.call(this, "uuid", p, e) : h.Box.call(this, "uuid", p, e);
      }, h.UUIDBoxes[e].prototype = n ? new h.FullBox() : d ? new h.ContainerBox() : new h.Box(), _ && (n ? h.UUIDBoxes[e].prototype.parse = function(p) {
        this.parseFullHeader(p), _ && _.call(this, p);
      } : h.UUIDBoxes[e].prototype.parse = _);
    }
  };
  h.initialize(), h.TKHD_FLAG_ENABLED = 1, h.TKHD_FLAG_IN_MOVIE = 2, h.TKHD_FLAG_IN_PREVIEW = 4, h.TFHD_FLAG_BASE_DATA_OFFSET = 1, h.TFHD_FLAG_SAMPLE_DESC = 2, h.TFHD_FLAG_SAMPLE_DUR = 8, h.TFHD_FLAG_SAMPLE_SIZE = 16, h.TFHD_FLAG_SAMPLE_FLAGS = 32, h.TFHD_FLAG_DUR_EMPTY = 65536, h.TFHD_FLAG_DEFAULT_BASE_IS_MOOF = 131072, h.TRUN_FLAGS_DATA_OFFSET = 1, h.TRUN_FLAGS_FIRST_FLAG = 4, h.TRUN_FLAGS_DURATION = 256, h.TRUN_FLAGS_SIZE = 512, h.TRUN_FLAGS_FLAGS = 1024, h.TRUN_FLAGS_CTS_OFFSET = 2048, h.Box.prototype.add = function(e) {
    return this.addBox(new h[e + "Box"]());
  }, h.Box.prototype.addBox = function(e) {
    return this.boxes.push(e), this[e.type + "s"] ? this[e.type + "s"].push(e) : this[e.type] = e, e;
  }, h.Box.prototype.set = function(e, n) {
    return this[e] = n, this;
  }, h.Box.prototype.addEntry = function(e, n) {
    var d = n || "entries";
    return this[d] || (this[d] = []), this[d].push(e), this;
  }, Et.BoxParser = h, h.parseUUID = function(e) {
    return h.parseHex16(e);
  }, h.parseHex16 = function(e) {
    for (var n = "", d = 0; d < 16; d++) {
      var _ = e.readUint8().toString(16);
      n += _.length === 1 ? "0" + _ : _;
    }
    return n;
  }, h.parseOneBox = function(e, n, d) {
    var _, p = e.getPosition(), P = 0, $, ot;
    if (e.getEndPosition() - p < 8)
      return t.debug("BoxParser", "Not enough data in stream to parse the type and size of the box"), { code: h.ERR_NOT_ENOUGH_DATA };
    if (d && d < 8)
      return t.debug("BoxParser", "Not enough bytes left in the parent box to parse a new box"), { code: h.ERR_NOT_ENOUGH_DATA };
    var dt = e.readUint32(), xt = e.readString(4), Nt = xt;
    if (t.debug("BoxParser", "Found box of type '" + xt + "' and size " + dt + " at position " + p), P = 8, xt == "uuid") {
      if (e.getEndPosition() - e.getPosition() < 16 || d - P < 16)
        return e.seek(p), t.debug("BoxParser", "Not enough bytes left in the parent box to parse a UUID box"), { code: h.ERR_NOT_ENOUGH_DATA };
      ot = h.parseUUID(e), P += 16, Nt = ot;
    }
    if (dt == 1) {
      if (e.getEndPosition() - e.getPosition() < 8 || d && d - P < 8)
        return e.seek(p), t.warn("BoxParser", 'Not enough data in stream to parse the extended size of the "' + xt + '" box'), { code: h.ERR_NOT_ENOUGH_DATA };
      dt = e.readUint64(), P += 8;
    } else if (dt === 0) {
      if (d)
        dt = d;
      else if (xt !== "mdat")
        return t.error("BoxParser", "Unlimited box size not supported for type: '" + xt + "'"), _ = new h.Box(xt, dt), { code: h.OK, box: _, size: _.size };
    }
    return dt !== 0 && dt < P ? (t.error("BoxParser", "Box of type " + xt + " has an invalid size " + dt + " (too small to be a box)"), { code: h.ERR_NOT_ENOUGH_DATA, type: xt, size: dt, hdr_size: P, start: p }) : dt !== 0 && d && dt > d ? (t.error("BoxParser", "Box of type '" + xt + "' has a size " + dt + " greater than its container size " + d), { code: h.ERR_NOT_ENOUGH_DATA, type: xt, size: dt, hdr_size: P, start: p }) : dt !== 0 && p + dt > e.getEndPosition() ? (e.seek(p), t.info("BoxParser", "Not enough data in stream to parse the entire '" + xt + "' box"), { code: h.ERR_NOT_ENOUGH_DATA, type: xt, size: dt, hdr_size: P, start: p }) : n ? { code: h.OK, type: xt, size: dt, hdr_size: P, start: p } : (h[xt + "Box"] ? _ = new h[xt + "Box"](dt) : xt !== "uuid" ? (t.warn("BoxParser", "Unknown box type: '" + xt + "'"), _ = new h.Box(xt, dt), _.has_unparsed_data = !0) : h.UUIDBoxes[ot] ? _ = new h.UUIDBoxes[ot](dt) : (t.warn("BoxParser", "Unknown uuid type: '" + ot + "'"), _ = new h.Box(xt, dt), _.uuid = ot, _.has_unparsed_data = !0), _.hdr_size = P, _.start = p, _.write === h.Box.prototype.write && _.type !== "mdat" && (t.info("BoxParser", "'" + Nt + "' box writing not yet implemented, keeping unparsed data in memory for later write"), _.parseDataAndRewind(e)), _.parse(e), $ = e.getPosition() - (_.start + _.size), $ < 0 ? (t.warn("BoxParser", "Parsing of box '" + Nt + "' did not read the entire indicated box data size (missing " + -$ + " bytes), seeking forward"), e.seek(_.start + _.size)) : $ > 0 && (t.error("BoxParser", "Parsing of box '" + Nt + "' read " + $ + " more bytes than the indicated box data size, seeking backwards"), _.size !== 0 && e.seek(_.start + _.size)), { code: h.OK, box: _, size: _.size });
  }, h.Box.prototype.parse = function(e) {
    this.type != "mdat" ? this.data = e.readUint8Array(this.size - this.hdr_size) : this.size === 0 ? e.seek(e.getEndPosition()) : e.seek(this.start + this.size);
  }, h.Box.prototype.parseDataAndRewind = function(e) {
    this.data = e.readUint8Array(this.size - this.hdr_size), e.position -= this.size - this.hdr_size;
  }, h.FullBox.prototype.parseDataAndRewind = function(e) {
    this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 4, e.position -= this.size - this.hdr_size;
  }, h.FullBox.prototype.parseFullHeader = function(e) {
    this.version = e.readUint8(), this.flags = e.readUint24(), this.hdr_size += 4;
  }, h.FullBox.prototype.parse = function(e) {
    this.parseFullHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size);
  }, h.ContainerBox.prototype.parse = function(e) {
    for (var n, d; e.getPosition() < this.start + this.size; )
      if (n = h.parseOneBox(e, !1, this.size - (e.getPosition() - this.start)), n.code === h.OK)
        if (d = n.box, this.boxes.push(d), this.subBoxNames && this.subBoxNames.indexOf(d.type) != -1)
          this[this.subBoxNames[this.subBoxNames.indexOf(d.type)] + "s"].push(d);
        else {
          var _ = d.type !== "uuid" ? d.type : d.uuid;
          this[_] ? t.warn("Box of type " + _ + " already stored in field of this type") : this[_] = d;
        }
      else
        return;
  }, h.Box.prototype.parseLanguage = function(e) {
    this.language = e.readUint16();
    var n = [];
    n[0] = this.language >> 10 & 31, n[1] = this.language >> 5 & 31, n[2] = this.language & 31, this.languageString = String.fromCharCode(n[0] + 96, n[1] + 96, n[2] + 96);
  }, h.SAMPLE_ENTRY_TYPE_VISUAL = "Visual", h.SAMPLE_ENTRY_TYPE_AUDIO = "Audio", h.SAMPLE_ENTRY_TYPE_HINT = "Hint", h.SAMPLE_ENTRY_TYPE_METADATA = "Metadata", h.SAMPLE_ENTRY_TYPE_SUBTITLE = "Subtitle", h.SAMPLE_ENTRY_TYPE_SYSTEM = "System", h.SAMPLE_ENTRY_TYPE_TEXT = "Text", h.SampleEntry.prototype.parseHeader = function(e) {
    e.readUint8Array(6), this.data_reference_index = e.readUint16(), this.hdr_size += 8;
  }, h.SampleEntry.prototype.parse = function(e) {
    this.parseHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size);
  }, h.SampleEntry.prototype.parseDataAndRewind = function(e) {
    this.parseHeader(e), this.data = e.readUint8Array(this.size - this.hdr_size), this.hdr_size -= 8, e.position -= this.size - this.hdr_size;
  }, h.SampleEntry.prototype.parseFooter = function(e) {
    h.ContainerBox.prototype.parse.call(this, e);
  }, h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_HINT), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_METADATA), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SYSTEM), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_TEXT), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, function(e) {
    var n;
    this.parseHeader(e), e.readUint16(), e.readUint16(), e.readUint32Array(3), this.width = e.readUint16(), this.height = e.readUint16(), this.horizresolution = e.readUint32(), this.vertresolution = e.readUint32(), e.readUint32(), this.frame_count = e.readUint16(), n = Math.min(31, e.readUint8()), this.compressorname = e.readString(n), n < 31 && e.readString(31 - n), this.depth = e.readUint16(), e.readUint16(), this.parseFooter(e);
  }), h.createMediaSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, function(e) {
    this.parseHeader(e), e.readUint32Array(2), this.channel_count = e.readUint16(), this.samplesize = e.readUint16(), e.readUint16(), e.readUint16(), this.samplerate = e.readUint32() / 65536, this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "avc1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "avc2"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "avc3"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "avc4"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "av01"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "dav1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "hvc1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "hev1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "hvt1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "lhe1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "dvh1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "dvhe"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vvc1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vvi1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vvs1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vvcN"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vp08"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "vp09"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "avs3"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "j2ki"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "mjp2"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "mjpg"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "uncv"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "mp4a"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "ac-3"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "ac-4"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "ec-3"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "Opus"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "mha1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "mha2"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "mhm1"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "mhm2"), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "fLaC"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_VISUAL, "encv"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_AUDIO, "enca"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE, "encu"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SYSTEM, "encs"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_TEXT, "enct"), h.createEncryptedSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_METADATA, "encm"), h.createBoxCtor("a1lx", function(e) {
    var n = e.readUint8() & 1, d = ((n & 1) + 1) * 16;
    this.layer_size = [];
    for (var _ = 0; _ < 3; _++)
      d == 16 ? this.layer_size[_] = e.readUint16() : this.layer_size[_] = e.readUint32();
  }), h.createBoxCtor("a1op", function(e) {
    this.op_index = e.readUint8();
  }), h.createFullBoxCtor("auxC", function(e) {
    this.aux_type = e.readCString();
    var n = this.size - this.hdr_size - (this.aux_type.length + 1);
    this.aux_subtype = e.readUint8Array(n);
  }), h.createBoxCtor("av1C", function(e) {
    var n = e.readUint8();
    if (n >> 7 & !1) {
      t.error("av1C marker problem");
      return;
    }
    if (this.version = n & 127, this.version !== 1) {
      t.error("av1C version " + this.version + " not supported");
      return;
    }
    if (n = e.readUint8(), this.seq_profile = n >> 5 & 7, this.seq_level_idx_0 = n & 31, n = e.readUint8(), this.seq_tier_0 = n >> 7 & 1, this.high_bitdepth = n >> 6 & 1, this.twelve_bit = n >> 5 & 1, this.monochrome = n >> 4 & 1, this.chroma_subsampling_x = n >> 3 & 1, this.chroma_subsampling_y = n >> 2 & 1, this.chroma_sample_position = n & 3, n = e.readUint8(), this.reserved_1 = n >> 5 & 7, this.reserved_1 !== 0) {
      t.error("av1C reserved_1 parsing problem");
      return;
    }
    if (this.initial_presentation_delay_present = n >> 4 & 1, this.initial_presentation_delay_present === 1)
      this.initial_presentation_delay_minus_one = n & 15;
    else if (this.reserved_2 = n & 15, this.reserved_2 !== 0) {
      t.error("av1C reserved_2 parsing problem");
      return;
    }
    var d = this.size - this.hdr_size - 4;
    this.configOBUs = e.readUint8Array(d);
  });
  function b(e) {
    var n = "<table class='inner-table'>";
    n += "<thead><tr><th>length</th><th>nalu_data</th></tr></thead>", n += "<tbody>";
    for (var d = 0; d < e.length; d++) {
      var _ = e[d];
      n += "<tr>", n += "<td>" + _.length + "</td>", n += "<td>", n += _.nalu.reduce(function(p, P) {
        return p + P.toString(16).padStart(2, "0");
      }, "0x"), n += "</td></tr>";
    }
    return n += "</tbody></table>", n;
  }
  h.createBoxCtor("avcC", function(e) {
    var n, d;
    for (this.configurationVersion = e.readUint8(), this.AVCProfileIndication = e.readUint8(), this.profile_compatibility = e.readUint8(), this.AVCLevelIndication = e.readUint8(), this.lengthSizeMinusOne = e.readUint8() & 3, this.nb_SPS_nalus = e.readUint8() & 31, d = this.size - this.hdr_size - 6, this.SPS = [], this.SPS.toString = function() {
      return b(this);
    }, n = 0; n < this.nb_SPS_nalus; n++)
      this.SPS[n] = {}, this.SPS[n].length = e.readUint16(), this.SPS[n].nalu = e.readUint8Array(this.SPS[n].length), d -= 2 + this.SPS[n].length;
    for (this.nb_PPS_nalus = e.readUint8(), d--, this.PPS = [], this.PPS.toString = function() {
      return b(this);
    }, n = 0; n < this.nb_PPS_nalus; n++)
      this.PPS[n] = {}, this.PPS[n].length = e.readUint16(), this.PPS[n].nalu = e.readUint8Array(this.PPS[n].length), d -= 2 + this.PPS[n].length;
    d > 0 && (this.ext = e.readUint8Array(d));
  }), h.createBoxCtor("btrt", function(e) {
    this.bufferSizeDB = e.readUint32(), this.maxBitrate = e.readUint32(), this.avgBitrate = e.readUint32();
  }), h.createFullBoxCtor("ccst", function(e) {
    var n = e.readUint8();
    this.all_ref_pics_intra = (n & 128) == 128, this.intra_pred_used = (n & 64) == 64, this.max_ref_per_pic = (n & 63) >> 2, e.readUint24();
  }), h.createBoxCtor("cdef", function(e) {
    var n;
    for (this.channel_count = e.readUint16(), this.channel_indexes = [], this.channel_types = [], this.channel_associations = [], n = 0; n < this.channel_count; n++)
      this.channel_indexes.push(e.readUint16()), this.channel_types.push(e.readUint16()), this.channel_associations.push(e.readUint16());
  }), h.createBoxCtor("clap", function(e) {
    this.cleanApertureWidthN = e.readUint32(), this.cleanApertureWidthD = e.readUint32(), this.cleanApertureHeightN = e.readUint32(), this.cleanApertureHeightD = e.readUint32(), this.horizOffN = e.readUint32(), this.horizOffD = e.readUint32(), this.vertOffN = e.readUint32(), this.vertOffD = e.readUint32();
  }), h.createBoxCtor("clli", function(e) {
    this.max_content_light_level = e.readUint16(), this.max_pic_average_light_level = e.readUint16();
  }), h.createFullBoxCtor("cmex", function(e) {
    this.flags & 1 && (this.pos_x = e.readInt32()), this.flags & 2 && (this.pos_y = e.readInt32()), this.flags & 4 && (this.pos_z = e.readInt32()), this.flags & 8 && (this.version == 0 ? this.flags & 16 ? (this.quat_x = e.readInt32(), this.quat_y = e.readInt32(), this.quat_z = e.readInt32()) : (this.quat_x = e.readInt16(), this.quat_y = e.readInt16(), this.quat_z = e.readInt16()) : this.version == 1), this.flags & 32 && (this.id = e.readUint32());
  }), h.createFullBoxCtor("cmin", function(e) {
    this.focal_length_x = e.readInt32(), this.principal_point_x = e.readInt32(), this.principal_point_y = e.readInt32(), this.flags & 1 && (this.focal_length_y = e.readInt32(), this.skew_factor = e.readInt32());
  }), h.createBoxCtor("cmpd", function(e) {
    for (this.component_count = e.readUint32(), this.component_types = [], this.component_type_urls = [], i = 0; i < this.component_count; i++) {
      var n = e.readUint16();
      this.component_types.push(n), n >= 32768 && this.component_type_urls.push(e.readCString());
    }
  }), h.createFullBoxCtor("co64", function(e) {
    var n, d;
    if (n = e.readUint32(), this.chunk_offsets = [], this.version === 0)
      for (d = 0; d < n; d++)
        this.chunk_offsets.push(e.readUint64());
  }), h.createFullBoxCtor("CoLL", function(e) {
    this.maxCLL = e.readUint16(), this.maxFALL = e.readUint16();
  }), h.createBoxCtor("colr", function(e) {
    if (this.colour_type = e.readString(4), this.colour_type === "nclx") {
      this.colour_primaries = e.readUint16(), this.transfer_characteristics = e.readUint16(), this.matrix_coefficients = e.readUint16();
      var n = e.readUint8();
      this.full_range_flag = n >> 7;
    } else this.colour_type === "rICC" ? this.ICC_profile = e.readUint8Array(this.size - 4) : this.colour_type === "prof" && (this.ICC_profile = e.readUint8Array(this.size - 4));
  }), h.createFullBoxCtor("cprt", function(e) {
    this.parseLanguage(e), this.notice = e.readCString();
  }), h.createFullBoxCtor("cslg", function(e) {
    this.version === 0 && (this.compositionToDTSShift = e.readInt32(), this.leastDecodeToDisplayDelta = e.readInt32(), this.greatestDecodeToDisplayDelta = e.readInt32(), this.compositionStartTime = e.readInt32(), this.compositionEndTime = e.readInt32());
  }), h.createFullBoxCtor("ctts", function(e) {
    var n, d;
    if (n = e.readUint32(), this.sample_counts = [], this.sample_offsets = [], this.version === 0)
      for (d = 0; d < n; d++) {
        this.sample_counts.push(e.readUint32());
        var _ = e.readInt32();
        _ < 0 && t.warn("BoxParser", "ctts box uses negative values without using version 1"), this.sample_offsets.push(_);
      }
    else if (this.version == 1)
      for (d = 0; d < n; d++)
        this.sample_counts.push(e.readUint32()), this.sample_offsets.push(e.readInt32());
  }), h.createBoxCtor("dac3", function(e) {
    var n = e.readUint8(), d = e.readUint8(), _ = e.readUint8();
    this.fscod = n >> 6, this.bsid = n >> 1 & 31, this.bsmod = (n & 1) << 2 | d >> 6 & 3, this.acmod = d >> 3 & 7, this.lfeon = d >> 2 & 1, this.bit_rate_code = d & 3 | _ >> 5 & 7;
  }), h.createBoxCtor("dec3", function(e) {
    var n = e.readUint16();
    this.data_rate = n >> 3, this.num_ind_sub = n & 7, this.ind_subs = [];
    for (var d = 0; d < this.num_ind_sub + 1; d++) {
      var _ = {};
      this.ind_subs.push(_);
      var p = e.readUint8(), P = e.readUint8(), $ = e.readUint8();
      _.fscod = p >> 6, _.bsid = p >> 1 & 31, _.bsmod = (p & 1) << 4 | P >> 4 & 15, _.acmod = P >> 1 & 7, _.lfeon = P & 1, _.num_dep_sub = $ >> 1 & 15, _.num_dep_sub > 0 && (_.chan_loc = ($ & 1) << 8 | e.readUint8());
    }
  }), h.createFullBoxCtor("dfLa", function(e) {
    var n = 127, d = 128, _ = [], p = [
      "STREAMINFO",
      "PADDING",
      "APPLICATION",
      "SEEKTABLE",
      "VORBIS_COMMENT",
      "CUESHEET",
      "PICTURE",
      "RESERVED"
    ];
    do {
      var P = e.readUint8(), $ = Math.min(
        P & n,
        p.length - 1
      );
      if ($ ? e.readUint8Array(e.readUint24()) : (e.readUint8Array(13), this.samplerate = e.readUint32() >> 12, e.readUint8Array(20)), _.push(p[$]), P & d)
        break;
    } while (!0);
    this.numMetadataBlocks = _.length + " (" + _.join(", ") + ")";
  }), h.createBoxCtor("dimm", function(e) {
    this.bytessent = e.readUint64();
  }), h.createBoxCtor("dmax", function(e) {
    this.time = e.readUint32();
  }), h.createBoxCtor("dmed", function(e) {
    this.bytessent = e.readUint64();
  }), h.createBoxCtor("dOps", function(e) {
    if (this.Version = e.readUint8(), this.OutputChannelCount = e.readUint8(), this.PreSkip = e.readUint16(), this.InputSampleRate = e.readUint32(), this.OutputGain = e.readInt16(), this.ChannelMappingFamily = e.readUint8(), this.ChannelMappingFamily !== 0) {
      this.StreamCount = e.readUint8(), this.CoupledCount = e.readUint8(), this.ChannelMapping = [];
      for (var n = 0; n < this.OutputChannelCount; n++)
        this.ChannelMapping[n] = e.readUint8();
    }
  }), h.createFullBoxCtor("dref", function(e) {
    var n, d;
    this.entries = [];
    for (var _ = e.readUint32(), p = 0; p < _; p++)
      if (n = h.parseOneBox(e, !1, this.size - (e.getPosition() - this.start)), n.code === h.OK)
        d = n.box, this.entries.push(d);
      else
        return;
  }), h.createBoxCtor("drep", function(e) {
    this.bytessent = e.readUint64();
  }), h.createFullBoxCtor("elng", function(e) {
    this.extended_language = e.readString(this.size - this.hdr_size);
  }), h.createFullBoxCtor("elst", function(e) {
    this.entries = [];
    for (var n = e.readUint32(), d = 0; d < n; d++) {
      var _ = {};
      this.entries.push(_), this.version === 1 ? (_.segment_duration = e.readUint64(), _.media_time = e.readInt64()) : (_.segment_duration = e.readUint32(), _.media_time = e.readInt32()), _.media_rate_integer = e.readInt16(), _.media_rate_fraction = e.readInt16();
    }
  }), h.createFullBoxCtor("emsg", function(e) {
    this.version == 1 ? (this.timescale = e.readUint32(), this.presentation_time = e.readUint64(), this.event_duration = e.readUint32(), this.id = e.readUint32(), this.scheme_id_uri = e.readCString(), this.value = e.readCString()) : (this.scheme_id_uri = e.readCString(), this.value = e.readCString(), this.timescale = e.readUint32(), this.presentation_time_delta = e.readUint32(), this.event_duration = e.readUint32(), this.id = e.readUint32());
    var n = this.size - this.hdr_size - (4 * 4 + (this.scheme_id_uri.length + 1) + (this.value.length + 1));
    this.version == 1 && (n -= 4), this.message_data = e.readUint8Array(n);
  }), h.createEntityToGroupCtor = function(e, n) {
    h[e + "Box"] = function(d) {
      h.FullBox.call(this, e, d);
    }, h[e + "Box"].prototype = new h.FullBox(), h[e + "Box"].prototype.parse = function(d) {
      if (this.parseFullHeader(d), n)
        n.call(this, d);
      else
        for (this.group_id = d.readUint32(), this.num_entities_in_group = d.readUint32(), this.entity_ids = [], i = 0; i < this.num_entities_in_group; i++) {
          var _ = d.readUint32();
          this.entity_ids.push(_);
        }
    };
  }, h.createEntityToGroupCtor("aebr"), h.createEntityToGroupCtor("afbr"), h.createEntityToGroupCtor("albc"), h.createEntityToGroupCtor("altr"), h.createEntityToGroupCtor("brst"), h.createEntityToGroupCtor("dobr"), h.createEntityToGroupCtor("eqiv"), h.createEntityToGroupCtor("favc"), h.createEntityToGroupCtor("fobr"), h.createEntityToGroupCtor("iaug"), h.createEntityToGroupCtor("pano"), h.createEntityToGroupCtor("slid"), h.createEntityToGroupCtor("ster"), h.createEntityToGroupCtor("tsyn"), h.createEntityToGroupCtor("wbbr"), h.createEntityToGroupCtor("prgr"), h.createEntityToGroupCtor("pymd", function(e) {
    this.group_id = e.readUint32(), this.num_entities_in_group = e.readUint32(), this.entity_ids = [];
    for (var n = 0; n < this.num_entities_in_group; n++) {
      var d = e.readUint32();
      this.entity_ids.push(d);
    }
    for (this.tile_size_x = e.readUint16(), this.tile_size_y = e.readUint16(), this.layer_binning = [], this.tiles_in_layer_column_minus1 = [], this.tiles_in_layer_row_minus1 = [], n = 0; n < this.num_entities_in_group; n++)
      this.layer_binning[n] = e.readUint16(), this.tiles_in_layer_row_minus1[n] = e.readUint16(), this.tiles_in_layer_column_minus1[n] = e.readUint16();
  }), h.createFullBoxCtor("esds", function(e) {
    var n = e.readUint8Array(this.size - this.hdr_size);
    if (typeof L < "u") {
      var d = new L();
      this.esd = d.parseOneDescriptor(new c(n.buffer, 0, c.BIG_ENDIAN));
    }
  }), h.createBoxCtor("fiel", function(e) {
    this.fieldCount = e.readUint8(), this.fieldOrdering = e.readUint8();
  }), h.createBoxCtor("frma", function(e) {
    this.data_format = e.readString(4);
  }), h.createBoxCtor("ftyp", function(e) {
    var n = this.size - this.hdr_size;
    this.major_brand = e.readString(4), this.minor_version = e.readUint32(), n -= 8, this.compatible_brands = [];
    for (var d = 0; n >= 4; )
      this.compatible_brands[d] = e.readString(4), n -= 4, d++;
  }), h.createFullBoxCtor("hdlr", function(e) {
    this.version === 0 && (e.readUint32(), this.handler = e.readString(4), e.readUint32Array(3), this.name = e.readString(this.size - this.hdr_size - 20), this.name[this.name.length - 1] === "\0" && (this.name = this.name.slice(0, -1)));
  }), h.createBoxCtor("hvcC", function(e) {
    var n, d, _, p;
    this.configurationVersion = e.readUint8(), p = e.readUint8(), this.general_profile_space = p >> 6, this.general_tier_flag = (p & 32) >> 5, this.general_profile_idc = p & 31, this.general_profile_compatibility = e.readUint32(), this.general_constraint_indicator = e.readUint8Array(6), this.general_level_idc = e.readUint8(), this.min_spatial_segmentation_idc = e.readUint16() & 4095, this.parallelismType = e.readUint8() & 3, this.chroma_format_idc = e.readUint8() & 3, this.bit_depth_luma_minus8 = e.readUint8() & 7, this.bit_depth_chroma_minus8 = e.readUint8() & 7, this.avgFrameRate = e.readUint16(), p = e.readUint8(), this.constantFrameRate = p >> 6, this.numTemporalLayers = (p & 13) >> 3, this.temporalIdNested = (p & 4) >> 2, this.lengthSizeMinusOne = p & 3, this.nalu_arrays = [], this.nalu_arrays.toString = function() {
      var xt = "<table class='inner-table'>";
      xt += "<thead><tr><th>completeness</th><th>nalu_type</th><th>nalu_data</th></tr></thead>", xt += "<tbody>";
      for (var Nt = 0; Nt < this.length; Nt++) {
        var jt = this[Nt];
        xt += "<tr>", xt += "<td rowspan='" + jt.length + "'>" + jt.completeness + "</td>", xt += "<td rowspan='" + jt.length + "'>" + jt.nalu_type + "</td>";
        for (var q = 0; q < jt.length; q++) {
          var I = jt[q];
          q !== 0 && (xt += "<tr>"), xt += "<td>", xt += I.data.reduce(function(pt, It) {
            return pt + It.toString(16).padStart(2, "0");
          }, "0x"), xt += "</td></tr>";
        }
      }
      return xt += "</tbody></table>", xt;
    };
    var P = e.readUint8();
    for (n = 0; n < P; n++) {
      var $ = [];
      this.nalu_arrays.push($), p = e.readUint8(), $.completeness = (p & 128) >> 7, $.nalu_type = p & 63;
      var ot = e.readUint16();
      for (d = 0; d < ot; d++) {
        var dt = {};
        $.push(dt), _ = e.readUint16(), dt.data = e.readUint8Array(_);
      }
    }
  }), h.createFullBoxCtor("iinf", function(e) {
    var n;
    this.version === 0 ? this.entry_count = e.readUint16() : this.entry_count = e.readUint32(), this.item_infos = [];
    for (var d = 0; d < this.entry_count; d++)
      if (n = h.parseOneBox(e, !1, this.size - (e.getPosition() - this.start)), n.code === h.OK)
        n.box.type !== "infe" && t.error("BoxParser", "Expected 'infe' box, got " + n.box.type), this.item_infos[d] = n.box;
      else
        return;
  }), h.createFullBoxCtor("iloc", function(e) {
    var n;
    n = e.readUint8(), this.offset_size = n >> 4 & 15, this.length_size = n & 15, n = e.readUint8(), this.base_offset_size = n >> 4 & 15, this.version === 1 || this.version === 2 ? this.index_size = n & 15 : this.index_size = 0, this.items = [];
    var d = 0;
    if (this.version < 2)
      d = e.readUint16();
    else if (this.version === 2)
      d = e.readUint32();
    else
      throw "version of iloc box not supported";
    for (var _ = 0; _ < d; _++) {
      var p = {};
      if (this.items.push(p), this.version < 2)
        p.item_ID = e.readUint16();
      else if (this.version === 2)
        p.item_ID = e.readUint32();
      else
        throw "version of iloc box not supported";
      switch (this.version === 1 || this.version === 2 ? p.construction_method = e.readUint16() & 15 : p.construction_method = 0, p.data_reference_index = e.readUint16(), this.base_offset_size) {
        case 0:
          p.base_offset = 0;
          break;
        case 4:
          p.base_offset = e.readUint32();
          break;
        case 8:
          p.base_offset = e.readUint64();
          break;
        default:
          throw "Error reading base offset size";
      }
      var P = e.readUint16();
      p.extents = [];
      for (var $ = 0; $ < P; $++) {
        var ot = {};
        if (p.extents.push(ot), this.version === 1 || this.version === 2)
          switch (this.index_size) {
            case 0:
              ot.extent_index = 0;
              break;
            case 4:
              ot.extent_index = e.readUint32();
              break;
            case 8:
              ot.extent_index = e.readUint64();
              break;
            default:
              throw "Error reading extent index";
          }
        switch (this.offset_size) {
          case 0:
            ot.extent_offset = 0;
            break;
          case 4:
            ot.extent_offset = e.readUint32();
            break;
          case 8:
            ot.extent_offset = e.readUint64();
            break;
          default:
            throw "Error reading extent index";
        }
        switch (this.length_size) {
          case 0:
            ot.extent_length = 0;
            break;
          case 4:
            ot.extent_length = e.readUint32();
            break;
          case 8:
            ot.extent_length = e.readUint64();
            break;
          default:
            throw "Error reading extent index";
        }
      }
    }
  }), h.createBoxCtor("imir", function(e) {
    var n = e.readUint8();
    this.reserved = n >> 7, this.axis = n & 1;
  }), h.createFullBoxCtor("infe", function(e) {
    if ((this.version === 0 || this.version === 1) && (this.item_ID = e.readUint16(), this.item_protection_index = e.readUint16(), this.item_name = e.readCString(), this.content_type = e.readCString(), this.content_encoding = e.readCString()), this.version === 1) {
      this.extension_type = e.readString(4), t.warn("BoxParser", "Cannot parse extension type"), e.seek(this.start + this.size);
      return;
    }
    this.version >= 2 && (this.version === 2 ? this.item_ID = e.readUint16() : this.version === 3 && (this.item_ID = e.readUint32()), this.item_protection_index = e.readUint16(), this.item_type = e.readString(4), this.item_name = e.readCString(), this.item_type === "mime" ? (this.content_type = e.readCString(), this.content_encoding = e.readCString()) : this.item_type === "uri " && (this.item_uri_type = e.readCString()));
  }), h.createFullBoxCtor("ipma", function(e) {
    var n, d;
    for (entry_count = e.readUint32(), this.associations = [], n = 0; n < entry_count; n++) {
      var _ = {};
      this.associations.push(_), this.version < 1 ? _.id = e.readUint16() : _.id = e.readUint32();
      var p = e.readUint8();
      for (_.props = [], d = 0; d < p; d++) {
        var P = e.readUint8(), $ = {};
        _.props.push($), $.essential = (P & 128) >> 7 === 1, this.flags & 1 ? $.property_index = (P & 127) << 8 | e.readUint8() : $.property_index = P & 127;
      }
    }
  }), h.createFullBoxCtor("iref", function(e) {
    var n, d;
    for (this.references = []; e.getPosition() < this.start + this.size; )
      if (n = h.parseOneBox(e, !0, this.size - (e.getPosition() - this.start)), n.code === h.OK)
        this.version === 0 ? d = new h.SingleItemTypeReferenceBox(n.type, n.size, n.hdr_size, n.start) : d = new h.SingleItemTypeReferenceBoxLarge(n.type, n.size, n.hdr_size, n.start), d.write === h.Box.prototype.write && d.type !== "mdat" && (t.warn("BoxParser", d.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), d.parseDataAndRewind(e)), d.parse(e), this.references.push(d);
      else
        return;
  }), h.createBoxCtor("irot", function(e) {
    this.angle = e.readUint8() & 3;
  }), h.createFullBoxCtor("ispe", function(e) {
    this.image_width = e.readUint32(), this.image_height = e.readUint32();
  }), h.createFullBoxCtor("kind", function(e) {
    this.schemeURI = e.readCString(), this.value = e.readCString();
  }), h.createFullBoxCtor("leva", function(e) {
    var n = e.readUint8();
    this.levels = [];
    for (var d = 0; d < n; d++) {
      var _ = {};
      this.levels[d] = _, _.track_ID = e.readUint32();
      var p = e.readUint8();
      switch (_.padding_flag = p >> 7, _.assignment_type = p & 127, _.assignment_type) {
        case 0:
          _.grouping_type = e.readString(4);
          break;
        case 1:
          _.grouping_type = e.readString(4), _.grouping_type_parameter = e.readUint32();
          break;
        case 2:
          break;
        case 3:
          break;
        case 4:
          _.sub_track_id = e.readUint32();
          break;
        default:
          t.warn("BoxParser", "Unknown leva assignement type");
      }
    }
  }), h.createBoxCtor("lhvC", function(e) {
    var n, d, _;
    this.configurationVersion = e.readUint8(), this.min_spatial_segmentation_idc = e.readUint16() & 4095, this.parallelismType = e.readUint8() & 3, _ = e.readUint8(), this.numTemporalLayers = (_ & 13) >> 3, this.temporalIdNested = (_ & 4) >> 2, this.lengthSizeMinusOne = _ & 3, this.nalu_arrays = [], this.nalu_arrays.toString = function() {
      var xt = "<table class='inner-table'>";
      xt += "<thead><tr><th>completeness</th><th>nalu_type</th><th>nalu_data</th></tr></thead>", xt += "<tbody>";
      for (var Nt = 0; Nt < this.length; Nt++) {
        var jt = this[Nt];
        xt += "<tr>", xt += "<td rowspan='" + jt.length + "'>" + jt.completeness + "</td>", xt += "<td rowspan='" + jt.length + "'>" + jt.nalu_type + "</td>";
        for (var q = 0; q < jt.length; q++) {
          var I = jt[q];
          q !== 0 && (xt += "<tr>"), xt += "<td>", xt += I.data.reduce(function(pt, It) {
            return pt + It.toString(16).padStart(2, "0");
          }, "0x"), xt += "</td></tr>";
        }
      }
      return xt += "</tbody></table>", xt;
    };
    var p = e.readUint8();
    for (n = 0; n < p; n++) {
      var P = [];
      this.nalu_arrays.push(P), _ = e.readUint8(), P.completeness = (_ & 128) >> 7, P.nalu_type = _ & 63;
      var $ = e.readUint16();
      for (d = 0; d < $; d++) {
        var ot = {};
        P.push(ot);
        var dt = e.readUint16();
        ot.data = e.readUint8Array(dt);
      }
    }
  }), h.createBoxCtor("lsel", function(e) {
    this.layer_id = e.readUint16();
  }), h.createBoxCtor("maxr", function(e) {
    this.period = e.readUint32(), this.bytes = e.readUint32();
  });
  function A(e, n) {
    this.x = e, this.y = n;
  }
  A.prototype.toString = function() {
    return "(" + this.x + "," + this.y + ")";
  }, h.createBoxCtor("mdcv", function(e) {
    this.display_primaries = [], this.display_primaries[0] = new A(e.readUint16(), e.readUint16()), this.display_primaries[1] = new A(e.readUint16(), e.readUint16()), this.display_primaries[2] = new A(e.readUint16(), e.readUint16()), this.white_point = new A(e.readUint16(), e.readUint16()), this.max_display_mastering_luminance = e.readUint32(), this.min_display_mastering_luminance = e.readUint32();
  }), h.createFullBoxCtor("mdhd", function(e) {
    this.version == 1 ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.timescale = e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.timescale = e.readUint32(), this.duration = e.readUint32()), this.parseLanguage(e), e.readUint16();
  }), h.createFullBoxCtor("mehd", function(e) {
    this.flags & 1 && (t.warn("BoxParser", "mehd box incorrectly uses flags set to 1, converting version to 1"), this.version = 1), this.version == 1 ? this.fragment_duration = e.readUint64() : this.fragment_duration = e.readUint32();
  }), h.createFullBoxCtor("meta", function(e) {
    this.boxes = [], h.ContainerBox.prototype.parse.call(this, e);
  }), h.createFullBoxCtor("mfhd", function(e) {
    this.sequence_number = e.readUint32();
  }), h.createFullBoxCtor("mfro", function(e) {
    this._size = e.readUint32();
  }), h.createFullBoxCtor("mskC", function(e) {
    this.bits_per_pixel = e.readUint8();
  }), h.createFullBoxCtor("mvhd", function(e) {
    this.version == 1 ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.timescale = e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.timescale = e.readUint32(), this.duration = e.readUint32()), this.rate = e.readUint32(), this.volume = e.readUint16() >> 8, e.readUint16(), e.readUint32Array(2), this.matrix = e.readUint32Array(9), e.readUint32Array(6), this.next_track_id = e.readUint32();
  }), h.createBoxCtor("npck", function(e) {
    this.packetssent = e.readUint32();
  }), h.createBoxCtor("nump", function(e) {
    this.packetssent = e.readUint64();
  }), h.createFullBoxCtor("padb", function(e) {
    var n = e.readUint32();
    this.padbits = [];
    for (var d = 0; d < Math.floor((n + 1) / 2); d++)
      this.padbits = e.readUint8();
  }), h.createBoxCtor("pasp", function(e) {
    this.hSpacing = e.readUint32(), this.vSpacing = e.readUint32();
  }), h.createBoxCtor("payl", function(e) {
    this.text = e.readString(this.size - this.hdr_size);
  }), h.createBoxCtor("payt", function(e) {
    this.payloadID = e.readUint32();
    var n = e.readUint8();
    this.rtpmap_string = e.readString(n);
  }), h.createFullBoxCtor("pdin", function(e) {
    var n = (this.size - this.hdr_size) / 8;
    this.rate = [], this.initial_delay = [];
    for (var d = 0; d < n; d++)
      this.rate[d] = e.readUint32(), this.initial_delay[d] = e.readUint32();
  }), h.createFullBoxCtor("pitm", function(e) {
    this.version === 0 ? this.item_id = e.readUint16() : this.item_id = e.readUint32();
  }), h.createFullBoxCtor("pixi", function(e) {
    var n;
    for (this.num_channels = e.readUint8(), this.bits_per_channels = [], n = 0; n < this.num_channels; n++)
      this.bits_per_channels[n] = e.readUint8();
  }), h.createBoxCtor("pmax", function(e) {
    this.bytes = e.readUint32();
  }), h.createFullBoxCtor("prdi", function(e) {
    if (this.step_count = e.readUint16(), this.item_count = [], this.flags & 2)
      for (var n = 0; n < this.step_count; n++)
        this.item_count[n] = e.readUint16();
  }), h.createFullBoxCtor("prft", function(e) {
    this.ref_track_id = e.readUint32(), this.ntp_timestamp = e.readUint64(), this.version === 0 ? this.media_time = e.readUint32() : this.media_time = e.readUint64();
  }), h.createFullBoxCtor("pssh", function(e) {
    if (this.system_id = h.parseHex16(e), this.version > 0) {
      var n = e.readUint32();
      this.kid = [];
      for (var d = 0; d < n; d++)
        this.kid[d] = h.parseHex16(e);
    }
    var _ = e.readUint32();
    _ > 0 && (this.data = e.readUint8Array(_));
  }), h.createFullBoxCtor("clef", function(e) {
    this.width = e.readUint32(), this.height = e.readUint32();
  }), h.createFullBoxCtor("enof", function(e) {
    this.width = e.readUint32(), this.height = e.readUint32();
  }), h.createFullBoxCtor("prof", function(e) {
    this.width = e.readUint32(), this.height = e.readUint32();
  }), h.createContainerBoxCtor("tapt", null, ["clef", "prof", "enof"]), h.createBoxCtor("rtp ", function(e) {
    this.descriptionformat = e.readString(4), this.sdptext = e.readString(this.size - this.hdr_size - 4);
  }), h.createFullBoxCtor("saio", function(e) {
    this.flags & 1 && (this.aux_info_type = e.readString(4), this.aux_info_type_parameter = e.readUint32());
    var n = e.readUint32();
    this.offset = [];
    for (var d = 0; d < n; d++)
      this.version === 0 ? this.offset[d] = e.readUint32() : this.offset[d] = e.readUint64();
  }), h.createFullBoxCtor("saiz", function(e) {
    if (this.flags & 1 && (this.aux_info_type = e.readString(4), this.aux_info_type_parameter = e.readUint32()), this.default_sample_info_size = e.readUint8(), this.sample_count = e.readUint32(), this.sample_info_size = [], this.default_sample_info_size === 0)
      for (var n = 0; n < this.sample_count; n++)
        this.sample_info_size[n] = e.readUint8();
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_METADATA, "mett", function(e) {
    this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_METADATA, "metx", function(e) {
    this.parseHeader(e), this.content_encoding = e.readCString(), this.namespace = e.readCString(), this.schema_location = e.readCString(), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE, "sbtt", function(e) {
    this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE, "stpp", function(e) {
    this.parseHeader(e), this.namespace = e.readCString(), this.schema_location = e.readCString(), this.auxiliary_mime_types = e.readCString(), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE, "stxt", function(e) {
    this.parseHeader(e), this.content_encoding = e.readCString(), this.mime_format = e.readCString(), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_SUBTITLE, "tx3g", function(e) {
    this.parseHeader(e), this.displayFlags = e.readUint32(), this.horizontal_justification = e.readInt8(), this.vertical_justification = e.readInt8(), this.bg_color_rgba = e.readUint8Array(4), this.box_record = e.readInt16Array(4), this.style_record = e.readUint8Array(12), this.parseFooter(e);
  }), h.createSampleEntryCtor(h.SAMPLE_ENTRY_TYPE_METADATA, "wvtt", function(e) {
    this.parseHeader(e), this.parseFooter(e);
  }), h.createSampleGroupCtor("alst", function(e) {
    var n, d = e.readUint16();
    for (this.first_output_sample = e.readUint16(), this.sample_offset = [], n = 0; n < d; n++)
      this.sample_offset[n] = e.readUint32();
    var _ = this.description_length - 4 - 4 * d;
    for (this.num_output_samples = [], this.num_total_samples = [], n = 0; n < _ / 4; n++)
      this.num_output_samples[n] = e.readUint16(), this.num_total_samples[n] = e.readUint16();
  }), h.createSampleGroupCtor("avll", function(e) {
    this.layerNumber = e.readUint8(), this.accurateStatisticsFlag = e.readUint8(), this.avgBitRate = e.readUint16(), this.avgFrameRate = e.readUint16();
  }), h.createSampleGroupCtor("avss", function(e) {
    this.subSequenceIdentifier = e.readUint16(), this.layerNumber = e.readUint8();
    var n = e.readUint8();
    this.durationFlag = n >> 7, this.avgRateFlag = n >> 6 & 1, this.durationFlag && (this.duration = e.readUint32()), this.avgRateFlag && (this.accurateStatisticsFlag = e.readUint8(), this.avgBitRate = e.readUint16(), this.avgFrameRate = e.readUint16()), this.dependency = [];
    for (var d = e.readUint8(), _ = 0; _ < d; _++) {
      var p = {};
      this.dependency.push(p), p.subSeqDirectionFlag = e.readUint8(), p.layerNumber = e.readUint8(), p.subSequenceIdentifier = e.readUint16();
    }
  }), h.createSampleGroupCtor("dtrt", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("mvif", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("prol", function(e) {
    this.roll_distance = e.readInt16();
  }), h.createSampleGroupCtor("rap ", function(e) {
    var n = e.readUint8();
    this.num_leading_samples_known = n >> 7, this.num_leading_samples = n & 127;
  }), h.createSampleGroupCtor("rash", function(e) {
    if (this.operation_point_count = e.readUint16(), this.description_length !== 2 + (this.operation_point_count === 1 ? 2 : this.operation_point_count * 6) + 9)
      t.warn("BoxParser", "Mismatch in " + this.grouping_type + " sample group length"), this.data = e.readUint8Array(this.description_length - 2);
    else {
      if (this.operation_point_count === 1)
        this.target_rate_share = e.readUint16();
      else {
        this.target_rate_share = [], this.available_bitrate = [];
        for (var n = 0; n < this.operation_point_count; n++)
          this.available_bitrate[n] = e.readUint32(), this.target_rate_share[n] = e.readUint16();
      }
      this.maximum_bitrate = e.readUint32(), this.minimum_bitrate = e.readUint32(), this.discard_priority = e.readUint8();
    }
  }), h.createSampleGroupCtor("roll", function(e) {
    this.roll_distance = e.readInt16();
  }), h.SampleGroupEntry.prototype.parse = function(e) {
    t.warn("BoxParser", "Unknown Sample Group type: " + this.grouping_type), this.data = e.readUint8Array(this.description_length);
  }, h.createSampleGroupCtor("scif", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("scnm", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("seig", function(e) {
    this.reserved = e.readUint8();
    var n = e.readUint8();
    this.crypt_byte_block = n >> 4, this.skip_byte_block = n & 15, this.isProtected = e.readUint8(), this.Per_Sample_IV_Size = e.readUint8(), this.KID = h.parseHex16(e), this.constant_IV_size = 0, this.constant_IV = 0, this.isProtected === 1 && this.Per_Sample_IV_Size === 0 && (this.constant_IV_size = e.readUint8(), this.constant_IV = e.readUint8Array(this.constant_IV_size));
  }), h.createSampleGroupCtor("stsa", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("sync", function(e) {
    var n = e.readUint8();
    this.NAL_unit_type = n & 63;
  }), h.createSampleGroupCtor("tele", function(e) {
    var n = e.readUint8();
    this.level_independently_decodable = n >> 7;
  }), h.createSampleGroupCtor("tsas", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("tscl", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createSampleGroupCtor("vipr", function(e) {
    t.warn("BoxParser", "Sample Group type: " + this.grouping_type + " not fully parsed");
  }), h.createFullBoxCtor("sbgp", function(e) {
    this.grouping_type = e.readString(4), this.version === 1 ? this.grouping_type_parameter = e.readUint32() : this.grouping_type_parameter = 0, this.entries = [];
    for (var n = e.readUint32(), d = 0; d < n; d++) {
      var _ = {};
      this.entries.push(_), _.sample_count = e.readInt32(), _.group_description_index = e.readInt32();
    }
  });
  function l(e, n) {
    this.bad_pixel_row = e, this.bad_pixel_column = n;
  }
  l.prototype.toString = function() {
    return "[row: " + this.bad_pixel_row + ", column: " + this.bad_pixel_column + "]";
  }, h.createFullBoxCtor("sbpm", function(e) {
    var n;
    for (this.component_count = e.readUint16(), this.component_index = [], n = 0; n < this.component_count; n++)
      this.component_index.push(e.readUint16());
    var d = e.readUint8();
    for (this.correction_applied = (d & 128) == 128, this.num_bad_rows = e.readUint32(), this.num_bad_cols = e.readUint32(), this.num_bad_pixels = e.readUint32(), this.bad_rows = [], this.bad_columns = [], this.bad_pixels = [], n = 0; n < this.num_bad_rows; n++)
      this.bad_rows.push(e.readUint32());
    for (n = 0; n < this.num_bad_cols; n++)
      this.bad_columns.push(e.readUint32());
    for (n = 0; n < this.num_bad_pixels; n++) {
      var _ = e.readUint32(), p = e.readUint32();
      this.bad_pixels.push(new l(_, p));
    }
  }), h.createFullBoxCtor("schm", function(e) {
    this.scheme_type = e.readString(4), this.scheme_version = e.readUint32(), this.flags & 1 && (this.scheme_uri = e.readString(this.size - this.hdr_size - 8));
  }), h.createBoxCtor("sdp ", function(e) {
    this.sdptext = e.readString(this.size - this.hdr_size);
  }), h.createFullBoxCtor("sdtp", function(e) {
    var n, d = this.size - this.hdr_size;
    this.is_leading = [], this.sample_depends_on = [], this.sample_is_depended_on = [], this.sample_has_redundancy = [];
    for (var _ = 0; _ < d; _++)
      n = e.readUint8(), this.is_leading[_] = n >> 6, this.sample_depends_on[_] = n >> 4 & 3, this.sample_is_depended_on[_] = n >> 2 & 3, this.sample_has_redundancy[_] = n & 3;
  }), h.createFullBoxCtor("senc", function(e) {
    var n = e.readUint32();
    this.samples = [];
    for (var d = 0; d < n; d++) {
      var _ = {}, p = 8;
      if (_.InitializationVector = e.readUint8Array(p), this.flags & 2) {
        _.subsamples = [], subsample_count = e.readUint16();
        for (var P = 0; P < subsample_count; P++) {
          var $ = {};
          $.BytesOfClearData = e.readUint16(), $.BytesOfProtectedData = e.readUint32(), _.subsamples.push($);
        }
      }
      this.samples.push(_);
    }
  }), h.createFullBoxCtor("sgpd", function(e) {
    this.grouping_type = e.readString(4), t.debug("BoxParser", "Found Sample Groups of type " + this.grouping_type), this.version === 1 ? this.default_length = e.readUint32() : this.default_length = 0, this.version >= 2 && (this.default_group_description_index = e.readUint32()), this.entries = [];
    for (var n = e.readUint32(), d = 0; d < n; d++) {
      var _;
      h[this.grouping_type + "SampleGroupEntry"] ? _ = new h[this.grouping_type + "SampleGroupEntry"](this.grouping_type) : _ = new h.SampleGroupEntry(this.grouping_type), this.entries.push(_), this.version === 1 ? this.default_length === 0 ? _.description_length = e.readUint32() : _.description_length = this.default_length : _.description_length = this.default_length, _.write === h.SampleGroupEntry.prototype.write && (t.info("BoxParser", "SampleGroup for type " + this.grouping_type + " writing not yet implemented, keeping unparsed data in memory for later write"), _.data = e.readUint8Array(_.description_length), e.position -= _.description_length), _.parse(e);
    }
  }), h.createFullBoxCtor("sidx", function(e) {
    this.reference_ID = e.readUint32(), this.timescale = e.readUint32(), this.version === 0 ? (this.earliest_presentation_time = e.readUint32(), this.first_offset = e.readUint32()) : (this.earliest_presentation_time = e.readUint64(), this.first_offset = e.readUint64()), e.readUint16(), this.references = [];
    for (var n = e.readUint16(), d = 0; d < n; d++) {
      var _ = {};
      this.references.push(_);
      var p = e.readUint32();
      _.reference_type = p >> 31 & 1, _.referenced_size = p & 2147483647, _.subsegment_duration = e.readUint32(), p = e.readUint32(), _.starts_with_SAP = p >> 31 & 1, _.SAP_type = p >> 28 & 7, _.SAP_delta_time = p & 268435455;
    }
  }), h.SingleItemTypeReferenceBox = function(e, n, d, _) {
    h.Box.call(this, e, n), this.hdr_size = d, this.start = _;
  }, h.SingleItemTypeReferenceBox.prototype = new h.Box(), h.SingleItemTypeReferenceBox.prototype.parse = function(e) {
    this.from_item_ID = e.readUint16();
    var n = e.readUint16();
    this.references = [];
    for (var d = 0; d < n; d++)
      this.references[d] = {}, this.references[d].to_item_ID = e.readUint16();
  }, h.SingleItemTypeReferenceBoxLarge = function(e, n, d, _) {
    h.Box.call(this, e, n), this.hdr_size = d, this.start = _;
  }, h.SingleItemTypeReferenceBoxLarge.prototype = new h.Box(), h.SingleItemTypeReferenceBoxLarge.prototype.parse = function(e) {
    this.from_item_ID = e.readUint32();
    var n = e.readUint16();
    this.references = [];
    for (var d = 0; d < n; d++)
      this.references[d] = {}, this.references[d].to_item_ID = e.readUint32();
  }, h.createFullBoxCtor("SmDm", function(e) {
    this.primaryRChromaticity_x = e.readUint16(), this.primaryRChromaticity_y = e.readUint16(), this.primaryGChromaticity_x = e.readUint16(), this.primaryGChromaticity_y = e.readUint16(), this.primaryBChromaticity_x = e.readUint16(), this.primaryBChromaticity_y = e.readUint16(), this.whitePointChromaticity_x = e.readUint16(), this.whitePointChromaticity_y = e.readUint16(), this.luminanceMax = e.readUint32(), this.luminanceMin = e.readUint32();
  }), h.createFullBoxCtor("smhd", function(e) {
    this.balance = e.readUint16(), e.readUint16();
  }), h.createFullBoxCtor("ssix", function(e) {
    this.subsegments = [];
    for (var n = e.readUint32(), d = 0; d < n; d++) {
      var _ = {};
      this.subsegments.push(_), _.ranges = [];
      for (var p = e.readUint32(), P = 0; P < p; P++) {
        var $ = {};
        _.ranges.push($), $.level = e.readUint8(), $.range_size = e.readUint24();
      }
    }
  }), h.createFullBoxCtor("stco", function(e) {
    var n;
    if (n = e.readUint32(), this.chunk_offsets = [], this.version === 0)
      for (var d = 0; d < n; d++)
        this.chunk_offsets.push(e.readUint32());
  }), h.createFullBoxCtor("stdp", function(e) {
    var n = (this.size - this.hdr_size) / 2;
    this.priority = [];
    for (var d = 0; d < n; d++)
      this.priority[d] = e.readUint16();
  }), h.createFullBoxCtor("sthd"), h.createFullBoxCtor("stri", function(e) {
    this.switch_group = e.readUint16(), this.alternate_group = e.readUint16(), this.sub_track_id = e.readUint32();
    var n = (this.size - this.hdr_size - 8) / 4;
    this.attribute_list = [];
    for (var d = 0; d < n; d++)
      this.attribute_list[d] = e.readUint32();
  }), h.createFullBoxCtor("stsc", function(e) {
    var n, d;
    if (n = e.readUint32(), this.first_chunk = [], this.samples_per_chunk = [], this.sample_description_index = [], this.version === 0)
      for (d = 0; d < n; d++)
        this.first_chunk.push(e.readUint32()), this.samples_per_chunk.push(e.readUint32()), this.sample_description_index.push(e.readUint32());
  }), h.createFullBoxCtor("stsd", function(e) {
    var n, d, _, p;
    for (this.entries = [], _ = e.readUint32(), n = 1; n <= _; n++)
      if (d = h.parseOneBox(e, !0, this.size - (e.getPosition() - this.start)), d.code === h.OK)
        h[d.type + "SampleEntry"] ? (p = new h[d.type + "SampleEntry"](d.size), p.hdr_size = d.hdr_size, p.start = d.start) : (t.warn("BoxParser", "Unknown sample entry type: " + d.type), p = new h.SampleEntry(d.type, d.size, d.hdr_size, d.start)), p.write === h.SampleEntry.prototype.write && (t.info("BoxParser", "SampleEntry " + p.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), p.parseDataAndRewind(e)), p.parse(e), this.entries.push(p);
      else
        return;
  }), h.createFullBoxCtor("stsg", function(e) {
    this.grouping_type = e.readUint32();
    var n = e.readUint16();
    this.group_description_index = [];
    for (var d = 0; d < n; d++)
      this.group_description_index[d] = e.readUint32();
  }), h.createFullBoxCtor("stsh", function(e) {
    var n, d;
    if (n = e.readUint32(), this.shadowed_sample_numbers = [], this.sync_sample_numbers = [], this.version === 0)
      for (d = 0; d < n; d++)
        this.shadowed_sample_numbers.push(e.readUint32()), this.sync_sample_numbers.push(e.readUint32());
  }), h.createFullBoxCtor("stss", function(e) {
    var n, d;
    if (d = e.readUint32(), this.version === 0)
      for (this.sample_numbers = [], n = 0; n < d; n++)
        this.sample_numbers.push(e.readUint32());
  }), h.createFullBoxCtor("stsz", function(e) {
    var n;
    if (this.sample_sizes = [], this.version === 0)
      for (this.sample_size = e.readUint32(), this.sample_count = e.readUint32(), n = 0; n < this.sample_count; n++)
        this.sample_size === 0 ? this.sample_sizes.push(e.readUint32()) : this.sample_sizes[n] = this.sample_size;
  }), h.createFullBoxCtor("stts", function(e) {
    var n, d, _;
    if (n = e.readUint32(), this.sample_counts = [], this.sample_deltas = [], this.version === 0)
      for (d = 0; d < n; d++)
        this.sample_counts.push(e.readUint32()), _ = e.readInt32(), _ < 0 && (t.warn("BoxParser", "File uses negative stts sample delta, using value 1 instead, sync may be lost!"), _ = 1), this.sample_deltas.push(_);
  }), h.createFullBoxCtor("stvi", function(e) {
    var n = e.readUint32();
    this.single_view_allowed = n & 3, this.stereo_scheme = e.readUint32();
    var d = e.readUint32();
    this.stereo_indication_type = e.readString(d);
    var _, p;
    for (this.boxes = []; e.getPosition() < this.start + this.size; )
      if (_ = h.parseOneBox(e, !1, this.size - (e.getPosition() - this.start)), _.code === h.OK)
        p = _.box, this.boxes.push(p), this[p.type] = p;
      else
        return;
  }), h.createBoxCtor("styp", function(e) {
    h.ftypBox.prototype.parse.call(this, e);
  }), h.createFullBoxCtor("stz2", function(e) {
    var n, d;
    if (this.sample_sizes = [], this.version === 0)
      if (this.reserved = e.readUint24(), this.field_size = e.readUint8(), d = e.readUint32(), this.field_size === 4)
        for (n = 0; n < d; n += 2) {
          var _ = e.readUint8();
          this.sample_sizes[n] = _ >> 4 & 15, this.sample_sizes[n + 1] = _ & 15;
        }
      else if (this.field_size === 8)
        for (n = 0; n < d; n++)
          this.sample_sizes[n] = e.readUint8();
      else if (this.field_size === 16)
        for (n = 0; n < d; n++)
          this.sample_sizes[n] = e.readUint16();
      else
        t.error("BoxParser", "Error in length field in stz2 box");
  }), h.createFullBoxCtor("subs", function(e) {
    var n, d, _, p;
    for (_ = e.readUint32(), this.entries = [], n = 0; n < _; n++) {
      var P = {};
      if (this.entries[n] = P, P.sample_delta = e.readUint32(), P.subsamples = [], p = e.readUint16(), p > 0)
        for (d = 0; d < p; d++) {
          var $ = {};
          P.subsamples.push($), this.version == 1 ? $.size = e.readUint32() : $.size = e.readUint16(), $.priority = e.readUint8(), $.discardable = e.readUint8(), $.codec_specific_parameters = e.readUint32();
        }
    }
  }), h.createFullBoxCtor("tenc", function(e) {
    if (e.readUint8(), this.version === 0)
      e.readUint8();
    else {
      var n = e.readUint8();
      this.default_crypt_byte_block = n >> 4 & 15, this.default_skip_byte_block = n & 15;
    }
    this.default_isProtected = e.readUint8(), this.default_Per_Sample_IV_Size = e.readUint8(), this.default_KID = h.parseHex16(e), this.default_isProtected === 1 && this.default_Per_Sample_IV_Size === 0 && (this.default_constant_IV_size = e.readUint8(), this.default_constant_IV = e.readUint8Array(this.default_constant_IV_size));
  }), h.createFullBoxCtor("tfdt", function(e) {
    this.version == 1 ? this.baseMediaDecodeTime = e.readUint64() : this.baseMediaDecodeTime = e.readUint32();
  }), h.createFullBoxCtor("tfhd", function(e) {
    var n = 0;
    this.track_id = e.readUint32(), this.size - this.hdr_size > n && this.flags & h.TFHD_FLAG_BASE_DATA_OFFSET ? (this.base_data_offset = e.readUint64(), n += 8) : this.base_data_offset = 0, this.size - this.hdr_size > n && this.flags & h.TFHD_FLAG_SAMPLE_DESC ? (this.default_sample_description_index = e.readUint32(), n += 4) : this.default_sample_description_index = 0, this.size - this.hdr_size > n && this.flags & h.TFHD_FLAG_SAMPLE_DUR ? (this.default_sample_duration = e.readUint32(), n += 4) : this.default_sample_duration = 0, this.size - this.hdr_size > n && this.flags & h.TFHD_FLAG_SAMPLE_SIZE ? (this.default_sample_size = e.readUint32(), n += 4) : this.default_sample_size = 0, this.size - this.hdr_size > n && this.flags & h.TFHD_FLAG_SAMPLE_FLAGS ? (this.default_sample_flags = e.readUint32(), n += 4) : this.default_sample_flags = 0;
  }), h.createFullBoxCtor("tfra", function(e) {
    this.track_ID = e.readUint32(), e.readUint24();
    var n = e.readUint8();
    this.length_size_of_traf_num = n >> 4 & 3, this.length_size_of_trun_num = n >> 2 & 3, this.length_size_of_sample_num = n & 3, this.entries = [];
    for (var d = e.readUint32(), _ = 0; _ < d; _++)
      this.version === 1 ? (this.time = e.readUint64(), this.moof_offset = e.readUint64()) : (this.time = e.readUint32(), this.moof_offset = e.readUint32()), this.traf_number = e["readUint" + 8 * (this.length_size_of_traf_num + 1)](), this.trun_number = e["readUint" + 8 * (this.length_size_of_trun_num + 1)](), this.sample_number = e["readUint" + 8 * (this.length_size_of_sample_num + 1)]();
  }), h.createFullBoxCtor("tkhd", function(e) {
    this.version == 1 ? (this.creation_time = e.readUint64(), this.modification_time = e.readUint64(), this.track_id = e.readUint32(), e.readUint32(), this.duration = e.readUint64()) : (this.creation_time = e.readUint32(), this.modification_time = e.readUint32(), this.track_id = e.readUint32(), e.readUint32(), this.duration = e.readUint32()), e.readUint32Array(2), this.layer = e.readInt16(), this.alternate_group = e.readInt16(), this.volume = e.readInt16() >> 8, e.readUint16(), this.matrix = e.readInt32Array(9), this.width = e.readUint32(), this.height = e.readUint32();
  }), h.createBoxCtor("tmax", function(e) {
    this.time = e.readUint32();
  }), h.createBoxCtor("tmin", function(e) {
    this.time = e.readUint32();
  }), h.createBoxCtor("totl", function(e) {
    this.bytessent = e.readUint32();
  }), h.createBoxCtor("tpay", function(e) {
    this.bytessent = e.readUint32();
  }), h.createBoxCtor("tpyl", function(e) {
    this.bytessent = e.readUint64();
  }), h.TrackGroupTypeBox.prototype.parse = function(e) {
    this.parseFullHeader(e), this.track_group_id = e.readUint32();
  }, h.createTrackGroupCtor("msrc"), h.TrackReferenceTypeBox = function(e, n, d, _) {
    h.Box.call(this, e, n), this.hdr_size = d, this.start = _;
  }, h.TrackReferenceTypeBox.prototype = new h.Box(), h.TrackReferenceTypeBox.prototype.parse = function(e) {
    this.track_ids = e.readUint32Array((this.size - this.hdr_size) / 4);
  }, h.trefBox.prototype.parse = function(e) {
    for (var n, d; e.getPosition() < this.start + this.size; )
      if (n = h.parseOneBox(e, !0, this.size - (e.getPosition() - this.start)), n.code === h.OK)
        d = new h.TrackReferenceTypeBox(n.type, n.size, n.hdr_size, n.start), d.write === h.Box.prototype.write && d.type !== "mdat" && (t.info("BoxParser", "TrackReference " + d.type + " box writing not yet implemented, keeping unparsed data in memory for later write"), d.parseDataAndRewind(e)), d.parse(e), this.boxes.push(d);
      else
        return;
  }, h.createFullBoxCtor("trep", function(e) {
    for (this.track_ID = e.readUint32(), this.boxes = []; e.getPosition() < this.start + this.size; )
      if (ret = h.parseOneBox(e, !1, this.size - (e.getPosition() - this.start)), ret.code === h.OK)
        box = ret.box, this.boxes.push(box);
      else
        return;
  }), h.createFullBoxCtor("trex", function(e) {
    this.track_id = e.readUint32(), this.default_sample_description_index = e.readUint32(), this.default_sample_duration = e.readUint32(), this.default_sample_size = e.readUint32(), this.default_sample_flags = e.readUint32();
  }), h.createBoxCtor("trpy", function(e) {
    this.bytessent = e.readUint64();
  }), h.createFullBoxCtor("trun", function(e) {
    var n = 0;
    if (this.sample_count = e.readUint32(), n += 4, this.size - this.hdr_size > n && this.flags & h.TRUN_FLAGS_DATA_OFFSET ? (this.data_offset = e.readInt32(), n += 4) : this.data_offset = 0, this.size - this.hdr_size > n && this.flags & h.TRUN_FLAGS_FIRST_FLAG ? (this.first_sample_flags = e.readUint32(), n += 4) : this.first_sample_flags = 0, this.sample_duration = [], this.sample_size = [], this.sample_flags = [], this.sample_composition_time_offset = [], this.size - this.hdr_size > n)
      for (var d = 0; d < this.sample_count; d++)
        this.flags & h.TRUN_FLAGS_DURATION && (this.sample_duration[d] = e.readUint32()), this.flags & h.TRUN_FLAGS_SIZE && (this.sample_size[d] = e.readUint32()), this.flags & h.TRUN_FLAGS_FLAGS && (this.sample_flags[d] = e.readUint32()), this.flags & h.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? this.sample_composition_time_offset[d] = e.readUint32() : this.sample_composition_time_offset[d] = e.readInt32());
  }), h.createFullBoxCtor("tsel", function(e) {
    this.switch_group = e.readUint32();
    var n = (this.size - this.hdr_size - 4) / 4;
    this.attribute_list = [];
    for (var d = 0; d < n; d++)
      this.attribute_list[d] = e.readUint32();
  }), h.createFullBoxCtor("txtC", function(e) {
    this.config = e.readCString();
  }), h.createBoxCtor("tyco", function(e) {
    var n = (this.size - this.hdr_size) / 4;
    this.compatible_brands = [];
    for (var d = 0; d < n; d++)
      this.compatible_brands[d] = e.readString(4);
  }), h.createFullBoxCtor("udes", function(e) {
    this.lang = e.readCString(), this.name = e.readCString(), this.description = e.readCString(), this.tags = e.readCString();
  }), h.createFullBoxCtor("uncC", function(e) {
    var n;
    if (this.profile = e.readString(4), this.version != 1) {
      if (this.version == 0) {
        for (this.component_count = e.readUint32(), this.component_index = [], this.component_bit_depth_minus_one = [], this.component_format = [], this.component_align_size = [], n = 0; n < this.component_count; n++)
          this.component_index.push(e.readUint16()), this.component_bit_depth_minus_one.push(e.readUint8()), this.component_format.push(e.readUint8()), this.component_align_size.push(e.readUint8());
        this.sampling_type = e.readUint8(), this.interleave_type = e.readUint8(), this.block_size = e.readUint8();
        var d = e.readUint8();
        this.component_little_endian = d >> 7 & 1, this.block_pad_lsb = d >> 6 & 1, this.block_little_endian = d >> 5 & 1, this.block_reversed = d >> 4 & 1, this.pad_unknown = d >> 3 & 1, this.pixel_size = e.readUint32(), this.row_align_size = e.readUint32(), this.tile_align_size = e.readUint32(), this.num_tile_cols_minus_one = e.readUint32(), this.num_tile_rows_minus_one = e.readUint32();
      }
    }
  }), h.createFullBoxCtor("url ", function(e) {
    this.flags !== 1 && (this.location = e.readCString());
  }), h.createFullBoxCtor("urn ", function(e) {
    this.name = e.readCString(), this.size - this.hdr_size - this.name.length - 1 > 0 && (this.location = e.readCString());
  }), h.createUUIDBox("a5d40b30e81411ddba2f0800200c9a66", !0, !1, function(e) {
    this.LiveServerManifest = e.readString(this.size - this.hdr_size).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }), h.createUUIDBox("d08a4f1810f34a82b6c832d8aba183d3", !0, !1, function(e) {
    this.system_id = h.parseHex16(e);
    var n = e.readUint32();
    n > 0 && (this.data = e.readUint8Array(n));
  }), h.createUUIDBox(
    "a2394f525a9b4f14a2446c427c648df4",
    !0,
    !1
    /*, function(stream) {
    	if (this.flags & 0x1) {
    		this.AlgorithmID = stream.readUint24();
    		this.IV_size = stream.readUint8();
    		this.KID = BoxParser.parseHex16(stream);
    	}
    	var sample_count = stream.readUint32();
    	this.samples = [];
    	for (var i = 0; i < sample_count; i++) {
    		var sample = {};
    		sample.InitializationVector = this.readUint8Array(this.IV_size*8);
    		if (this.flags & 0x2) {
    			sample.subsamples = [];
    			sample.NumberOfEntries = stream.readUint16();
    			for (var j = 0; j < sample.NumberOfEntries; j++) {
    				var subsample = {};
    				subsample.BytesOfClearData = stream.readUint16();
    				subsample.BytesOfProtectedData = stream.readUint32();
    				sample.subsamples.push(subsample);
    			}
    		}
    		this.samples.push(sample);
    	}
    }*/
  ), h.createUUIDBox("8974dbce7be74c5184f97148f9882554", !0, !1, function(e) {
    this.default_AlgorithmID = e.readUint24(), this.default_IV_size = e.readUint8(), this.default_KID = h.parseHex16(e);
  }), h.createUUIDBox("d4807ef2ca3946958e5426cb9e46a79f", !0, !1, function(e) {
    this.fragment_count = e.readUint8(), this.entries = [];
    for (var n = 0; n < this.fragment_count; n++) {
      var d = {}, _ = 0, p = 0;
      this.version === 1 ? (_ = e.readUint64(), p = e.readUint64()) : (_ = e.readUint32(), p = e.readUint32()), d.absolute_time = _, d.absolute_duration = p, this.entries.push(d);
    }
  }), h.createUUIDBox("6d1d9b0542d544e680e2141daff757b2", !0, !1, function(e) {
    this.version === 1 ? (this.absolute_time = e.readUint64(), this.duration = e.readUint64()) : (this.absolute_time = e.readUint32(), this.duration = e.readUint32());
  }), h.createFullBoxCtor("vmhd", function(e) {
    this.graphicsmode = e.readUint16(), this.opcolor = e.readUint16Array(3);
  }), h.createFullBoxCtor("vpcC", function(e) {
    var n;
    this.version === 1 ? (this.profile = e.readUint8(), this.level = e.readUint8(), n = e.readUint8(), this.bitDepth = n >> 4, this.chromaSubsampling = n >> 1 & 7, this.videoFullRangeFlag = n & 1, this.colourPrimaries = e.readUint8(), this.transferCharacteristics = e.readUint8(), this.matrixCoefficients = e.readUint8(), this.codecIntializationDataSize = e.readUint16(), this.codecIntializationData = e.readUint8Array(this.codecIntializationDataSize)) : (this.profile = e.readUint8(), this.level = e.readUint8(), n = e.readUint8(), this.bitDepth = n >> 4 & 15, this.colorSpace = n & 15, n = e.readUint8(), this.chromaSubsampling = n >> 4 & 15, this.transferFunction = n >> 1 & 7, this.videoFullRangeFlag = n & 1, this.codecIntializationDataSize = e.readUint16(), this.codecIntializationData = e.readUint8Array(this.codecIntializationDataSize));
  }), h.createBoxCtor("vttC", function(e) {
    this.text = e.readString(this.size - this.hdr_size);
  }), h.createFullBoxCtor("vvcC", function(e) {
    var n, d, _ = {
      held_bits: void 0,
      num_held_bits: 0,
      stream_read_1_bytes: function(I) {
        this.held_bits = I.readUint8(), this.num_held_bits = 8;
      },
      stream_read_2_bytes: function(I) {
        this.held_bits = I.readUint16(), this.num_held_bits = 16;
      },
      extract_bits: function(I) {
        var pt = this.held_bits >> this.num_held_bits - I & (1 << I) - 1;
        return this.num_held_bits -= I, pt;
      }
    };
    if (_.stream_read_1_bytes(e), _.extract_bits(5), this.lengthSizeMinusOne = _.extract_bits(2), this.ptl_present_flag = _.extract_bits(1), this.ptl_present_flag) {
      _.stream_read_2_bytes(e), this.ols_idx = _.extract_bits(9), this.num_sublayers = _.extract_bits(3), this.constant_frame_rate = _.extract_bits(2), this.chroma_format_idc = _.extract_bits(2), _.stream_read_1_bytes(e), this.bit_depth_minus8 = _.extract_bits(3), _.extract_bits(5);
      {
        if (_.stream_read_2_bytes(e), _.extract_bits(2), this.num_bytes_constraint_info = _.extract_bits(6), this.general_profile_idc = _.extract_bits(7), this.general_tier_flag = _.extract_bits(1), this.general_level_idc = e.readUint8(), _.stream_read_1_bytes(e), this.ptl_frame_only_constraint_flag = _.extract_bits(1), this.ptl_multilayer_enabled_flag = _.extract_bits(1), this.general_constraint_info = new Uint8Array(this.num_bytes_constraint_info), this.num_bytes_constraint_info) {
          for (n = 0; n < this.num_bytes_constraint_info - 1; n++) {
            var p = _.extract_bits(6);
            _.stream_read_1_bytes(e);
            var P = _.extract_bits(2);
            this.general_constraint_info[n] = p << 2 | P;
          }
          this.general_constraint_info[this.num_bytes_constraint_info - 1] = _.extract_bits(6);
        } else
          _.extract_bits(6);
        if (this.num_sublayers > 1) {
          for (_.stream_read_1_bytes(e), this.ptl_sublayer_present_mask = 0, d = this.num_sublayers - 2; d >= 0; --d) {
            var $ = _.extract_bits(1);
            this.ptl_sublayer_present_mask |= $ << d;
          }
          for (d = this.num_sublayers; d <= 8 && this.num_sublayers > 1; ++d)
            _.extract_bits(1);
          for (this.sublayer_level_idc = [], d = this.num_sublayers - 2; d >= 0; --d)
            this.ptl_sublayer_present_mask & 1 << d && (this.sublayer_level_idc[d] = e.readUint8());
        }
        if (this.ptl_num_sub_profiles = e.readUint8(), this.general_sub_profile_idc = [], this.ptl_num_sub_profiles)
          for (n = 0; n < this.ptl_num_sub_profiles; n++)
            this.general_sub_profile_idc.push(e.readUint32());
      }
      this.max_picture_width = e.readUint16(), this.max_picture_height = e.readUint16(), this.avg_frame_rate = e.readUint16();
    }
    var ot = 12, dt = 13;
    this.nalu_arrays = [];
    var xt = e.readUint8();
    for (n = 0; n < xt; n++) {
      var Nt = [];
      this.nalu_arrays.push(Nt), _.stream_read_1_bytes(e), Nt.completeness = _.extract_bits(1), _.extract_bits(2), Nt.nalu_type = _.extract_bits(5);
      var jt = 1;
      for (Nt.nalu_type != dt && Nt.nalu_type != ot && (jt = e.readUint16()), d = 0; d < jt; d++) {
        var q = e.readUint16();
        Nt.push({
          data: e.readUint8Array(q),
          length: q
        });
      }
    }
  }), h.createFullBoxCtor("vvnC", function(e) {
    var n = strm.readUint8();
    this.lengthSizeMinusOne = n & 3;
  }), h.SampleEntry.prototype.isVideo = function() {
    return !1;
  }, h.SampleEntry.prototype.isAudio = function() {
    return !1;
  }, h.SampleEntry.prototype.isSubtitle = function() {
    return !1;
  }, h.SampleEntry.prototype.isMetadata = function() {
    return !1;
  }, h.SampleEntry.prototype.isHint = function() {
    return !1;
  }, h.SampleEntry.prototype.getCodec = function() {
    return this.type.replace(".", "");
  }, h.SampleEntry.prototype.getWidth = function() {
    return "";
  }, h.SampleEntry.prototype.getHeight = function() {
    return "";
  }, h.SampleEntry.prototype.getChannelCount = function() {
    return "";
  }, h.SampleEntry.prototype.getSampleRate = function() {
    return "";
  }, h.SampleEntry.prototype.getSampleSize = function() {
    return "";
  }, h.VisualSampleEntry.prototype.isVideo = function() {
    return !0;
  }, h.VisualSampleEntry.prototype.getWidth = function() {
    return this.width;
  }, h.VisualSampleEntry.prototype.getHeight = function() {
    return this.height;
  }, h.AudioSampleEntry.prototype.isAudio = function() {
    return !0;
  }, h.AudioSampleEntry.prototype.getChannelCount = function() {
    return this.channel_count;
  }, h.AudioSampleEntry.prototype.getSampleRate = function() {
    return this.samplerate;
  }, h.AudioSampleEntry.prototype.getSampleSize = function() {
    return this.samplesize;
  }, h.SubtitleSampleEntry.prototype.isSubtitle = function() {
    return !0;
  }, h.MetadataSampleEntry.prototype.isMetadata = function() {
    return !0;
  }, h.decimalToHex = function(e, n) {
    var d = Number(e).toString(16);
    for (n = typeof n > "u" || n === null ? n = 2 : n; d.length < n; )
      d = "0" + d;
    return d;
  }, h.avc1SampleEntry.prototype.getCodec = h.avc2SampleEntry.prototype.getCodec = h.avc3SampleEntry.prototype.getCodec = h.avc4SampleEntry.prototype.getCodec = function() {
    var e = h.SampleEntry.prototype.getCodec.call(this);
    return this.avcC ? e + "." + h.decimalToHex(this.avcC.AVCProfileIndication) + h.decimalToHex(this.avcC.profile_compatibility) + h.decimalToHex(this.avcC.AVCLevelIndication) : e;
  }, h.hev1SampleEntry.prototype.getCodec = h.hvc1SampleEntry.prototype.getCodec = function() {
    var e, n = h.SampleEntry.prototype.getCodec.call(this);
    if (this.hvcC) {
      switch (n += ".", this.hvcC.general_profile_space) {
        case 0:
          n += "";
          break;
        case 1:
          n += "A";
          break;
        case 2:
          n += "B";
          break;
        case 3:
          n += "C";
          break;
      }
      n += this.hvcC.general_profile_idc, n += ".";
      var d = this.hvcC.general_profile_compatibility, _ = 0;
      for (e = 0; e < 32 && (_ |= d & 1, e != 31); e++)
        _ <<= 1, d >>= 1;
      n += h.decimalToHex(_, 0), n += ".", this.hvcC.general_tier_flag === 0 ? n += "L" : n += "H", n += this.hvcC.general_level_idc;
      var p = !1, P = "";
      for (e = 5; e >= 0; e--)
        (this.hvcC.general_constraint_indicator[e] || p) && (P = "." + h.decimalToHex(this.hvcC.general_constraint_indicator[e], 0) + P, p = !0);
      n += P;
    }
    return n;
  }, h.vvc1SampleEntry.prototype.getCodec = h.vvi1SampleEntry.prototype.getCodec = function() {
    var e, n = h.SampleEntry.prototype.getCodec.call(this);
    if (this.vvcC) {
      n += "." + this.vvcC.general_profile_idc, this.vvcC.general_tier_flag ? n += ".H" : n += ".L", n += this.vvcC.general_level_idc;
      var d = "";
      if (this.vvcC.general_constraint_info) {
        var _ = [], p = 0;
        p |= this.vvcC.ptl_frame_only_constraint << 7, p |= this.vvcC.ptl_multilayer_enabled << 6;
        var P;
        for (e = 0; e < this.vvcC.general_constraint_info.length; ++e)
          p |= this.vvcC.general_constraint_info[e] >> 2 & 63, _.push(p), p && (P = e), p = this.vvcC.general_constraint_info[e] >> 2 & 3;
        if (P === void 0)
          d = ".CA";
        else {
          d = ".C";
          var $ = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", ot = 0, dt = 0;
          for (e = 0; e <= P; ++e)
            for (ot = ot << 8 | _[e], dt += 8; dt >= 5; ) {
              var xt = ot >> dt - 5 & 31;
              d += $[xt], dt -= 5, ot &= (1 << dt) - 1;
            }
          dt && (ot <<= 5 - dt, d += $[ot & 31]);
        }
      }
      n += d;
    }
    return n;
  }, h.mp4aSampleEntry.prototype.getCodec = function() {
    var e = h.SampleEntry.prototype.getCodec.call(this);
    if (this.esds && this.esds.esd) {
      var n = this.esds.esd.getOTI(), d = this.esds.esd.getAudioConfig();
      return e + "." + h.decimalToHex(n) + (d ? "." + d : "");
    } else
      return e;
  }, h.stxtSampleEntry.prototype.getCodec = function() {
    var e = h.SampleEntry.prototype.getCodec.call(this);
    return this.mime_format ? e + "." + this.mime_format : e;
  }, h.vp08SampleEntry.prototype.getCodec = h.vp09SampleEntry.prototype.getCodec = function() {
    var e = h.SampleEntry.prototype.getCodec.call(this), n = this.vpcC.level;
    n == 0 && (n = "00");
    var d = this.vpcC.bitDepth;
    return d == 8 && (d = "08"), e + ".0" + this.vpcC.profile + "." + n + "." + d;
  }, h.av01SampleEntry.prototype.getCodec = function() {
    var e = h.SampleEntry.prototype.getCodec.call(this), n = this.av1C.seq_level_idx_0;
    n < 10 && (n = "0" + n);
    var d;
    return this.av1C.seq_profile === 2 && this.av1C.high_bitdepth === 1 ? d = this.av1C.twelve_bit === 1 ? "12" : "10" : this.av1C.seq_profile <= 2 && (d = this.av1C.high_bitdepth === 1 ? "10" : "08"), e + "." + this.av1C.seq_profile + "." + n + (this.av1C.seq_tier_0 ? "H" : "M") + "." + d;
  }, h.Box.prototype.writeHeader = function(e, n) {
    this.size += 8, this.size > w && (this.size += 8), this.type === "uuid" && (this.size += 16), t.debug("BoxWriter", "Writing box " + this.type + " of size: " + this.size + " at position " + e.getPosition() + (n || "")), this.size > w ? e.writeUint32(1) : (this.sizePosition = e.getPosition(), e.writeUint32(this.size)), e.writeString(this.type, null, 4), this.type === "uuid" && e.writeUint8Array(this.uuid), this.size > w && e.writeUint64(this.size);
  }, h.FullBox.prototype.writeHeader = function(e) {
    this.size += 4, h.Box.prototype.writeHeader.call(this, e, " v=" + this.version + " f=" + this.flags), e.writeUint8(this.version), e.writeUint24(this.flags);
  }, h.Box.prototype.write = function(e) {
    this.type === "mdat" ? this.data && (this.size = this.data.length, this.writeHeader(e), e.writeUint8Array(this.data)) : (this.size = this.data ? this.data.length : 0, this.writeHeader(e), this.data && e.writeUint8Array(this.data));
  }, h.ContainerBox.prototype.write = function(e) {
    this.size = 0, this.writeHeader(e);
    for (var n = 0; n < this.boxes.length; n++)
      this.boxes[n] && (this.boxes[n].write(e), this.size += this.boxes[n].size);
    t.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }, h.TrackReferenceTypeBox.prototype.write = function(e) {
    this.size = this.track_ids.length * 4, this.writeHeader(e), e.writeUint32Array(this.track_ids);
  }, h.avcCBox.prototype.write = function(e) {
    var n;
    for (this.size = 7, n = 0; n < this.SPS.length; n++)
      this.size += 2 + this.SPS[n].length;
    for (n = 0; n < this.PPS.length; n++)
      this.size += 2 + this.PPS[n].length;
    for (this.ext && (this.size += this.ext.length), this.writeHeader(e), e.writeUint8(this.configurationVersion), e.writeUint8(this.AVCProfileIndication), e.writeUint8(this.profile_compatibility), e.writeUint8(this.AVCLevelIndication), e.writeUint8(this.lengthSizeMinusOne + 252), e.writeUint8(this.SPS.length + 224), n = 0; n < this.SPS.length; n++)
      e.writeUint16(this.SPS[n].length), e.writeUint8Array(this.SPS[n].nalu);
    for (e.writeUint8(this.PPS.length), n = 0; n < this.PPS.length; n++)
      e.writeUint16(this.PPS[n].length), e.writeUint8Array(this.PPS[n].nalu);
    this.ext && e.writeUint8Array(this.ext);
  }, h.co64Box.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.chunk_offsets.length, this.writeHeader(e), e.writeUint32(this.chunk_offsets.length), n = 0; n < this.chunk_offsets.length; n++)
      e.writeUint64(this.chunk_offsets[n]);
  }, h.cslgBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(e), e.writeInt32(this.compositionToDTSShift), e.writeInt32(this.leastDecodeToDisplayDelta), e.writeInt32(this.greatestDecodeToDisplayDelta), e.writeInt32(this.compositionStartTime), e.writeInt32(this.compositionEndTime);
  }, h.cttsBox.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(e), e.writeUint32(this.sample_counts.length), n = 0; n < this.sample_counts.length; n++)
      e.writeUint32(this.sample_counts[n]), this.version === 1 ? e.writeInt32(this.sample_offsets[n]) : e.writeUint32(this.sample_offsets[n]);
  }, h.drefBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.entries.length);
    for (var n = 0; n < this.entries.length; n++)
      this.entries[n].write(e), this.size += this.entries[n].size;
    t.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }, h.elngBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = this.extended_language.length, this.writeHeader(e), e.writeString(this.extended_language);
  }, h.elstBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 + 12 * this.entries.length, this.writeHeader(e), e.writeUint32(this.entries.length);
    for (var n = 0; n < this.entries.length; n++) {
      var d = this.entries[n];
      e.writeUint32(d.segment_duration), e.writeInt32(d.media_time), e.writeInt16(d.media_rate_integer), e.writeInt16(d.media_rate_fraction);
    }
  }, h.emsgBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 * 4 + this.message_data.length + (this.scheme_id_uri.length + 1) + (this.value.length + 1), this.writeHeader(e), e.writeCString(this.scheme_id_uri), e.writeCString(this.value), e.writeUint32(this.timescale), e.writeUint32(this.presentation_time_delta), e.writeUint32(this.event_duration), e.writeUint32(this.id), e.writeUint8Array(this.message_data);
  }, h.ftypBox.prototype.write = function(e) {
    this.size = 8 + 4 * this.compatible_brands.length, this.writeHeader(e), e.writeString(this.major_brand, null, 4), e.writeUint32(this.minor_version);
    for (var n = 0; n < this.compatible_brands.length; n++)
      e.writeString(this.compatible_brands[n], null, 4);
  }, h.hdlrBox.prototype.write = function(e) {
    this.size = 5 * 4 + this.name.length + 1, this.version = 0, this.flags = 0, this.writeHeader(e), e.writeUint32(0), e.writeString(this.handler, null, 4), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeCString(this.name);
  }, h.hvcCBox.prototype.write = function(e) {
    var n, d;
    for (this.size = 23, n = 0; n < this.nalu_arrays.length; n++)
      for (this.size += 3, d = 0; d < this.nalu_arrays[n].length; d++)
        this.size += 2 + this.nalu_arrays[n][d].data.length;
    for (this.writeHeader(e), e.writeUint8(this.configurationVersion), e.writeUint8((this.general_profile_space << 6) + (this.general_tier_flag << 5) + this.general_profile_idc), e.writeUint32(this.general_profile_compatibility), e.writeUint8Array(this.general_constraint_indicator), e.writeUint8(this.general_level_idc), e.writeUint16(this.min_spatial_segmentation_idc + (15 << 24)), e.writeUint8(this.parallelismType + 252), e.writeUint8(this.chroma_format_idc + 252), e.writeUint8(this.bit_depth_luma_minus8 + 248), e.writeUint8(this.bit_depth_chroma_minus8 + 248), e.writeUint16(this.avgFrameRate), e.writeUint8((this.constantFrameRate << 6) + (this.numTemporalLayers << 3) + (this.temporalIdNested << 2) + this.lengthSizeMinusOne), e.writeUint8(this.nalu_arrays.length), n = 0; n < this.nalu_arrays.length; n++)
      for (e.writeUint8((this.nalu_arrays[n].completeness << 7) + this.nalu_arrays[n].nalu_type), e.writeUint16(this.nalu_arrays[n].length), d = 0; d < this.nalu_arrays[n].length; d++)
        e.writeUint16(this.nalu_arrays[n][d].data.length), e.writeUint8Array(this.nalu_arrays[n][d].data);
  }, h.kindBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = this.schemeURI.length + 1 + (this.value.length + 1), this.writeHeader(e), e.writeCString(this.schemeURI), e.writeCString(this.value);
  }, h.mdhdBox.prototype.write = function(e) {
    this.size = 4 * 4 + 2 * 2, this.flags = 0, this.version = 0, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.timescale), e.writeUint32(this.duration), e.writeUint16(this.language), e.writeUint16(0);
  }, h.mehdBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.fragment_duration);
  }, h.mfhdBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4, this.writeHeader(e), e.writeUint32(this.sequence_number);
  }, h.mvhdBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 23 * 4 + 2 * 2, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.timescale), e.writeUint32(this.duration), e.writeUint32(this.rate), e.writeUint16(this.volume << 8), e.writeUint16(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32Array(this.matrix), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(this.next_track_id);
  }, h.SampleEntry.prototype.writeHeader = function(e) {
    this.size = 8, h.Box.prototype.writeHeader.call(this, e), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint8(0), e.writeUint16(this.data_reference_index);
  }, h.SampleEntry.prototype.writeFooter = function(e) {
    for (var n = 0; n < this.boxes.length; n++)
      this.boxes[n].write(e), this.size += this.boxes[n].size;
    t.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }, h.SampleEntry.prototype.write = function(e) {
    this.writeHeader(e), e.writeUint8Array(this.data), this.size += this.data.length, t.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }, h.VisualSampleEntry.prototype.write = function(e) {
    this.writeHeader(e), this.size += 2 * 7 + 6 * 4 + 32, e.writeUint16(0), e.writeUint16(0), e.writeUint32(0), e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.width), e.writeUint16(this.height), e.writeUint32(this.horizresolution), e.writeUint32(this.vertresolution), e.writeUint32(0), e.writeUint16(this.frame_count), e.writeUint8(Math.min(31, this.compressorname.length)), e.writeString(this.compressorname, null, 31), e.writeUint16(this.depth), e.writeInt16(-1), this.writeFooter(e);
  }, h.AudioSampleEntry.prototype.write = function(e) {
    this.writeHeader(e), this.size += 2 * 4 + 3 * 4, e.writeUint32(0), e.writeUint32(0), e.writeUint16(this.channel_count), e.writeUint16(this.samplesize), e.writeUint16(0), e.writeUint16(0), e.writeUint32(this.samplerate << 16), this.writeFooter(e);
  }, h.stppSampleEntry.prototype.write = function(e) {
    this.writeHeader(e), this.size += this.namespace.length + 1 + this.schema_location.length + 1 + this.auxiliary_mime_types.length + 1, e.writeCString(this.namespace), e.writeCString(this.schema_location), e.writeCString(this.auxiliary_mime_types), this.writeFooter(e);
  }, h.SampleGroupEntry.prototype.write = function(e) {
    e.writeUint8Array(this.data);
  }, h.sbgpBox.prototype.write = function(e) {
    this.version = 1, this.flags = 0, this.size = 12 + 8 * this.entries.length, this.writeHeader(e), e.writeString(this.grouping_type, null, 4), e.writeUint32(this.grouping_type_parameter), e.writeUint32(this.entries.length);
    for (var n = 0; n < this.entries.length; n++) {
      var d = this.entries[n];
      e.writeInt32(d.sample_count), e.writeInt32(d.group_description_index);
    }
  }, h.sgpdBox.prototype.write = function(e) {
    var n, d;
    for (this.flags = 0, this.size = 12, n = 0; n < this.entries.length; n++)
      d = this.entries[n], this.version === 1 && (this.default_length === 0 && (this.size += 4), this.size += d.data.length);
    for (this.writeHeader(e), e.writeString(this.grouping_type, null, 4), this.version === 1 && e.writeUint32(this.default_length), this.version >= 2 && e.writeUint32(this.default_sample_description_index), e.writeUint32(this.entries.length), n = 0; n < this.entries.length; n++)
      d = this.entries[n], this.version === 1 && this.default_length === 0 && e.writeUint32(d.description_length), d.write(e);
  }, h.sidxBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 * 4 + 2 + 2 + 12 * this.references.length, this.writeHeader(e), e.writeUint32(this.reference_ID), e.writeUint32(this.timescale), e.writeUint32(this.earliest_presentation_time), e.writeUint32(this.first_offset), e.writeUint16(0), e.writeUint16(this.references.length);
    for (var n = 0; n < this.references.length; n++) {
      var d = this.references[n];
      e.writeUint32(d.reference_type << 31 | d.referenced_size), e.writeUint32(d.subsegment_duration), e.writeUint32(d.starts_with_SAP << 31 | d.SAP_type << 28 | d.SAP_delta_time);
    }
  }, h.smhdBox.prototype.write = function(e) {
    this.version = 0, this.flags = 1, this.size = 4, this.writeHeader(e), e.writeUint16(this.balance), e.writeUint16(0);
  }, h.stcoBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.chunk_offsets.length, this.writeHeader(e), e.writeUint32(this.chunk_offsets.length), e.writeUint32Array(this.chunk_offsets);
  }, h.stscBox.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 4 + 12 * this.first_chunk.length, this.writeHeader(e), e.writeUint32(this.first_chunk.length), n = 0; n < this.first_chunk.length; n++)
      e.writeUint32(this.first_chunk[n]), e.writeUint32(this.samples_per_chunk[n]), e.writeUint32(this.sample_description_index[n]);
  }, h.stsdBox.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 0, this.writeHeader(e), e.writeUint32(this.entries.length), this.size += 4, n = 0; n < this.entries.length; n++)
      this.entries[n].write(e), this.size += this.entries[n].size;
    t.debug("BoxWriter", "Adjusting box " + this.type + " with new size " + this.size), e.adjustUint32(this.sizePosition, this.size);
  }, h.stshBox.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.shadowed_sample_numbers.length, this.writeHeader(e), e.writeUint32(this.shadowed_sample_numbers.length), n = 0; n < this.shadowed_sample_numbers.length; n++)
      e.writeUint32(this.shadowed_sample_numbers[n]), e.writeUint32(this.sync_sample_numbers[n]);
  }, h.stssBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 + 4 * this.sample_numbers.length, this.writeHeader(e), e.writeUint32(this.sample_numbers.length), e.writeUint32Array(this.sample_numbers);
  }, h.stszBox.prototype.write = function(e) {
    var n, d = !0;
    if (this.version = 0, this.flags = 0, this.sample_sizes.length > 0)
      for (n = 0; n + 1 < this.sample_sizes.length; )
        if (this.sample_sizes[n + 1] !== this.sample_sizes[0]) {
          d = !1;
          break;
        } else
          n++;
    else
      d = !1;
    this.size = 8, d || (this.size += 4 * this.sample_sizes.length), this.writeHeader(e), d ? e.writeUint32(this.sample_sizes[0]) : e.writeUint32(0), e.writeUint32(this.sample_sizes.length), d || e.writeUint32Array(this.sample_sizes);
  }, h.sttsBox.prototype.write = function(e) {
    var n;
    for (this.version = 0, this.flags = 0, this.size = 4 + 8 * this.sample_counts.length, this.writeHeader(e), e.writeUint32(this.sample_counts.length), n = 0; n < this.sample_counts.length; n++)
      e.writeUint32(this.sample_counts[n]), e.writeUint32(this.sample_deltas[n]);
  }, h.tfdtBox.prototype.write = function(e) {
    var n = Math.pow(2, 32) - 1;
    this.version = this.baseMediaDecodeTime > n ? 1 : 0, this.flags = 0, this.size = 4, this.version === 1 && (this.size += 4), this.writeHeader(e), this.version === 1 ? e.writeUint64(this.baseMediaDecodeTime) : e.writeUint32(this.baseMediaDecodeTime);
  }, h.tfhdBox.prototype.write = function(e) {
    this.version = 0, this.size = 4, this.flags & h.TFHD_FLAG_BASE_DATA_OFFSET && (this.size += 8), this.flags & h.TFHD_FLAG_SAMPLE_DESC && (this.size += 4), this.flags & h.TFHD_FLAG_SAMPLE_DUR && (this.size += 4), this.flags & h.TFHD_FLAG_SAMPLE_SIZE && (this.size += 4), this.flags & h.TFHD_FLAG_SAMPLE_FLAGS && (this.size += 4), this.writeHeader(e), e.writeUint32(this.track_id), this.flags & h.TFHD_FLAG_BASE_DATA_OFFSET && e.writeUint64(this.base_data_offset), this.flags & h.TFHD_FLAG_SAMPLE_DESC && e.writeUint32(this.default_sample_description_index), this.flags & h.TFHD_FLAG_SAMPLE_DUR && e.writeUint32(this.default_sample_duration), this.flags & h.TFHD_FLAG_SAMPLE_SIZE && e.writeUint32(this.default_sample_size), this.flags & h.TFHD_FLAG_SAMPLE_FLAGS && e.writeUint32(this.default_sample_flags);
  }, h.tkhdBox.prototype.write = function(e) {
    this.version = 0, this.size = 4 * 18 + 2 * 4, this.writeHeader(e), e.writeUint32(this.creation_time), e.writeUint32(this.modification_time), e.writeUint32(this.track_id), e.writeUint32(0), e.writeUint32(this.duration), e.writeUint32(0), e.writeUint32(0), e.writeInt16(this.layer), e.writeInt16(this.alternate_group), e.writeInt16(this.volume << 8), e.writeUint16(0), e.writeInt32Array(this.matrix), e.writeUint32(this.width), e.writeUint32(this.height);
  }, h.trexBox.prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = 4 * 5, this.writeHeader(e), e.writeUint32(this.track_id), e.writeUint32(this.default_sample_description_index), e.writeUint32(this.default_sample_duration), e.writeUint32(this.default_sample_size), e.writeUint32(this.default_sample_flags);
  }, h.trunBox.prototype.write = function(e) {
    this.version = 0, this.size = 4, this.flags & h.TRUN_FLAGS_DATA_OFFSET && (this.size += 4), this.flags & h.TRUN_FLAGS_FIRST_FLAG && (this.size += 4), this.flags & h.TRUN_FLAGS_DURATION && (this.size += 4 * this.sample_duration.length), this.flags & h.TRUN_FLAGS_SIZE && (this.size += 4 * this.sample_size.length), this.flags & h.TRUN_FLAGS_FLAGS && (this.size += 4 * this.sample_flags.length), this.flags & h.TRUN_FLAGS_CTS_OFFSET && (this.size += 4 * this.sample_composition_time_offset.length), this.writeHeader(e), e.writeUint32(this.sample_count), this.flags & h.TRUN_FLAGS_DATA_OFFSET && (this.data_offset_position = e.getPosition(), e.writeInt32(this.data_offset)), this.flags & h.TRUN_FLAGS_FIRST_FLAG && e.writeUint32(this.first_sample_flags);
    for (var n = 0; n < this.sample_count; n++)
      this.flags & h.TRUN_FLAGS_DURATION && e.writeUint32(this.sample_duration[n]), this.flags & h.TRUN_FLAGS_SIZE && e.writeUint32(this.sample_size[n]), this.flags & h.TRUN_FLAGS_FLAGS && e.writeUint32(this.sample_flags[n]), this.flags & h.TRUN_FLAGS_CTS_OFFSET && (this.version === 0 ? e.writeUint32(this.sample_composition_time_offset[n]) : e.writeInt32(this.sample_composition_time_offset[n]));
  }, h["url Box"].prototype.write = function(e) {
    this.version = 0, this.location ? (this.flags = 0, this.size = this.location.length + 1) : (this.flags = 1, this.size = 0), this.writeHeader(e), this.location && e.writeCString(this.location);
  }, h["urn Box"].prototype.write = function(e) {
    this.version = 0, this.flags = 0, this.size = this.name.length + 1 + (this.location ? this.location.length + 1 : 0), this.writeHeader(e), e.writeCString(this.name), this.location && e.writeCString(this.location);
  }, h.vmhdBox.prototype.write = function(e) {
    this.version = 0, this.flags = 1, this.size = 8, this.writeHeader(e), e.writeUint16(this.graphicsmode), e.writeUint16Array(this.opcolor);
  }, h.cttsBox.prototype.unpack = function(e) {
    var n, d, _;
    for (_ = 0, n = 0; n < this.sample_counts.length; n++)
      for (d = 0; d < this.sample_counts[n]; d++)
        e[_].pts = e[_].dts + this.sample_offsets[n], _++;
  }, h.sttsBox.prototype.unpack = function(e) {
    var n, d, _;
    for (_ = 0, n = 0; n < this.sample_counts.length; n++)
      for (d = 0; d < this.sample_counts[n]; d++)
        _ === 0 ? e[_].dts = 0 : e[_].dts = e[_ - 1].dts + this.sample_deltas[n], _++;
  }, h.stcoBox.prototype.unpack = function(e) {
    var n;
    for (n = 0; n < this.chunk_offsets.length; n++)
      e[n].offset = this.chunk_offsets[n];
  }, h.stscBox.prototype.unpack = function(e) {
    var n, d, _, p, P;
    for (p = 0, P = 0, n = 0; n < this.first_chunk.length; n++)
      for (d = 0; d < (n + 1 < this.first_chunk.length ? this.first_chunk[n + 1] : 1 / 0); d++)
        for (P++, _ = 0; _ < this.samples_per_chunk[n]; _++) {
          if (e[p])
            e[p].description_index = this.sample_description_index[n], e[p].chunk_index = P;
          else
            return;
          p++;
        }
  }, h.stszBox.prototype.unpack = function(e) {
    var n;
    for (n = 0; n < this.sample_sizes.length; n++)
      e[n].size = this.sample_sizes[n];
  }, h.DIFF_BOXES_PROP_NAMES = [
    "boxes",
    "entries",
    "references",
    "subsamples",
    "items",
    "item_infos",
    "extents",
    "associations",
    "subsegments",
    "ranges",
    "seekLists",
    "seekPoints",
    "esd",
    "levels"
  ], h.DIFF_PRIMITIVE_ARRAY_PROP_NAMES = [
    "compatible_brands",
    "matrix",
    "opcolor",
    "sample_counts",
    "sample_deltas",
    "first_chunk",
    "samples_per_chunk",
    "sample_sizes",
    "chunk_offsets",
    "sample_offsets",
    "sample_description_index",
    "sample_duration"
  ], h.boxEqualFields = function(e, n) {
    if (e && !n) return !1;
    var d;
    for (d in e)
      if (!(h.DIFF_BOXES_PROP_NAMES.indexOf(d) > -1)) {
        if (e[d] instanceof h.Box || n[d] instanceof h.Box)
          continue;
        if (typeof e[d] > "u" || typeof n[d] > "u")
          continue;
        if (typeof e[d] == "function" || typeof n[d] == "function")
          continue;
        if (e.subBoxNames && e.subBoxNames.indexOf(d.slice(0, 4)) > -1 || n.subBoxNames && n.subBoxNames.indexOf(d.slice(0, 4)) > -1)
          continue;
        if (d === "data" || d === "start" || d === "size" || d === "creation_time" || d === "modification_time")
          continue;
        if (h.DIFF_PRIMITIVE_ARRAY_PROP_NAMES.indexOf(d) > -1)
          continue;
        if (e[d] !== n[d])
          return !1;
      }
    return !0;
  }, h.boxEqual = function(e, n) {
    if (!h.boxEqualFields(e, n))
      return !1;
    for (var d = 0; d < h.DIFF_BOXES_PROP_NAMES.length; d++) {
      var _ = h.DIFF_BOXES_PROP_NAMES[d];
      if (e[_] && n[_] && !h.boxEqual(e[_], n[_]))
        return !1;
    }
    return !0;
  };
  var o = function() {
  };
  o.prototype.parseSample = function(e) {
    var n, d, _ = new r(e.buffer);
    for (n = []; !_.isEos(); )
      d = h.parseOneBox(_, !1), d.code === h.OK && d.box.type === "vttc" && n.push(d.box);
    return n;
  }, o.prototype.getText = function(e, n, d) {
    function _(xt, Nt, jt) {
      return jt = jt || "0", xt = xt + "", xt.length >= Nt ? xt : new Array(Nt - xt.length + 1).join(jt) + xt;
    }
    function p(xt) {
      var Nt = Math.floor(xt / 3600), jt = Math.floor((xt - Nt * 3600) / 60), q = Math.floor(xt - Nt * 3600 - jt * 60), I = Math.floor((xt - Nt * 3600 - jt * 60 - q) * 1e3);
      return "" + _(Nt, 2) + ":" + _(jt, 2) + ":" + _(q, 2) + "." + _(I, 3);
    }
    for (var P = this.parseSample(d), $ = "", ot = 0; ot < P.length; ot++) {
      var dt = P[ot];
      $ += p(e) + " --> " + p(n) + `\r
`, $ += dt.payl.text;
    }
    return $;
  };
  var u = function() {
  };
  u.prototype.parseSample = function(e) {
    var n = {}, d;
    n.resources = [];
    var _ = new r(e.data.buffer);
    if (!e.subsamples || e.subsamples.length === 0)
      n.documentString = _.readString(e.data.length);
    else if (n.documentString = _.readString(e.subsamples[0].size), e.subsamples.length > 1)
      for (d = 1; d < e.subsamples.length; d++)
        n.resources[d] = _.readUint8Array(e.subsamples[d].size);
    return typeof DOMParser < "u" && (n.document = new DOMParser().parseFromString(n.documentString, "application/xml")), n;
  };
  var g = function() {
  };
  g.prototype.parseSample = function(e) {
    var n, d = new r(e.data.buffer);
    return n = d.readString(e.data.length), n;
  }, g.prototype.parseConfig = function(e) {
    var n, d = new r(e.buffer);
    return d.readUint32(), n = d.readCString(), n;
  }, Et.VTTin4Parser = o, Et.XMLSubtitlein4Parser = u, Et.Textin4Parser = g;
  var m = function(e) {
    this.stream = e || new R(), this.boxes = [], this.mdats = [], this.moofs = [], this.isProgressive = !1, this.moovStartFound = !1, this.onMoovStart = null, this.moovStartSent = !1, this.onReady = null, this.readySent = !1, this.onSegment = null, this.onSamples = null, this.onError = null, this.sampleListBuilt = !1, this.fragmentedTracks = [], this.extractedTracks = [], this.isFragmentationInitialized = !1, this.sampleProcessingStarted = !1, this.nextMoofNumber = 0, this.itemListBuilt = !1, this.items = [], this.entity_groups = [], this.onSidx = null, this.sidxSent = !1;
  };
  m.prototype.setSegmentOptions = function(e, n, d) {
    var _ = this.getTrackById(e);
    if (_) {
      var p = {};
      this.fragmentedTracks.push(p), p.id = e, p.user = n, p.trak = _, _.nextSample = 0, p.segmentStream = null, p.nb_samples = 1e3, p.rapAlignement = !0, d && (d.nbSamples && (p.nb_samples = d.nbSamples), d.rapAlignement && (p.rapAlignement = d.rapAlignement));
    }
  }, m.prototype.unsetSegmentOptions = function(e) {
    for (var n = -1, d = 0; d < this.fragmentedTracks.length; d++) {
      var _ = this.fragmentedTracks[d];
      _.id == e && (n = d);
    }
    n > -1 && this.fragmentedTracks.splice(n, 1);
  }, m.prototype.setExtractionOptions = function(e, n, d) {
    var _ = this.getTrackById(e);
    if (_) {
      var p = {};
      this.extractedTracks.push(p), p.id = e, p.user = n, p.trak = _, _.nextSample = 0, p.nb_samples = 1e3, p.samples = [], d && d.nbSamples && (p.nb_samples = d.nbSamples);
    }
  }, m.prototype.unsetExtractionOptions = function(e) {
    for (var n = -1, d = 0; d < this.extractedTracks.length; d++) {
      var _ = this.extractedTracks[d];
      _.id == e && (n = d);
    }
    n > -1 && this.extractedTracks.splice(n, 1);
  }, m.prototype.parse = function() {
    var e, n, d = !1;
    if (!(this.restoreParsePosition && !this.restoreParsePosition()))
      for (; ; )
        if (this.hasIncompleteMdat && this.hasIncompleteMdat()) {
          if (this.processIncompleteMdat())
            continue;
          return;
        } else if (this.saveParsePosition && this.saveParsePosition(), e = h.parseOneBox(this.stream, d), e.code === h.ERR_NOT_ENOUGH_DATA)
          if (this.processIncompleteBox) {
            if (this.processIncompleteBox(e))
              continue;
            return;
          } else
            return;
        else {
          var _;
          switch (n = e.box, _ = n.type !== "uuid" ? n.type : n.uuid, this.boxes.push(n), _) {
            case "mdat":
              this.mdats.push(n);
              break;
            case "moof":
              this.moofs.push(n);
              break;
            case "moov":
              this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0);
            default:
              this[_] !== void 0 && t.warn("ISOFile", "Duplicate Box of type: " + _ + ", overriding previous occurrence"), this[_] = n;
              break;
          }
          this.updateUsedBytes && this.updateUsedBytes(n, e);
        }
  }, m.prototype.checkBuffer = function(e) {
    if (e == null)
      throw "Buffer must be defined and non empty";
    if (e.fileStart === void 0)
      throw "Buffer must have a fileStart property";
    return e.byteLength === 0 ? (t.warn("ISOFile", "Ignoring empty buffer (fileStart: " + e.fileStart + ")"), this.stream.logBufferLevel(), !1) : (t.info("ISOFile", "Processing buffer (fileStart: " + e.fileStart + ")"), e.usedBytes = 0, this.stream.insertBuffer(e), this.stream.logBufferLevel(), this.stream.initialized() ? !0 : (t.warn("ISOFile", "Not ready to start parsing"), !1));
  }, m.prototype.appendBuffer = function(e, n) {
    var d;
    if (this.checkBuffer(e))
      return this.parse(), this.moovStartFound && !this.moovStartSent && (this.moovStartSent = !0, this.onMoovStart && this.onMoovStart()), this.moov ? (this.sampleListBuilt || (this.buildSampleLists(), this.sampleListBuilt = !0), this.updateSampleLists(), this.onReady && !this.readySent && (this.readySent = !0, this.onReady(this.getInfo())), this.processSamples(n), this.nextSeekPosition ? (d = this.nextSeekPosition, this.nextSeekPosition = void 0) : d = this.nextParsePosition, this.stream.getEndFilePositionAfter && (d = this.stream.getEndFilePositionAfter(d))) : this.nextParsePosition ? d = this.nextParsePosition : d = 0, this.sidx && this.onSidx && !this.sidxSent && (this.onSidx(this.sidx), this.sidxSent = !0), this.meta && (this.flattenItemInfo && !this.itemListBuilt && (this.flattenItemInfo(), this.itemListBuilt = !0), this.processItems && this.processItems(this.onItem)), this.stream.cleanBuffers && (t.info("ISOFile", "Done processing buffer (fileStart: " + e.fileStart + ") - next buffer to fetch should have a fileStart position of " + d), this.stream.logBufferLevel(), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0), t.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize())), d;
  }, m.prototype.getInfo = function() {
    var e, n, d = {}, _, p, P, $, ot = (/* @__PURE__ */ new Date("1904-01-01T00:00:00Z")).getTime();
    if (this.moov)
      for (d.hasMoov = !0, d.duration = this.moov.mvhd.duration, d.timescale = this.moov.mvhd.timescale, d.isFragmented = this.moov.mvex != null, d.isFragmented && this.moov.mvex.mehd && (d.fragment_duration = this.moov.mvex.mehd.fragment_duration), d.isProgressive = this.isProgressive, d.hasIOD = this.moov.iods != null, d.brands = [], d.brands.push(this.ftyp.major_brand), d.brands = d.brands.concat(this.ftyp.compatible_brands), d.created = new Date(ot + this.moov.mvhd.creation_time * 1e3), d.modified = new Date(ot + this.moov.mvhd.modification_time * 1e3), d.tracks = [], d.audioTracks = [], d.videoTracks = [], d.subtitleTracks = [], d.metadataTracks = [], d.hintTracks = [], d.otherTracks = [], e = 0; e < this.moov.traks.length; e++) {
        if (_ = this.moov.traks[e], $ = _.mdia.minf.stbl.stsd.entries[0], p = {}, d.tracks.push(p), p.id = _.tkhd.track_id, p.name = _.mdia.hdlr.name, p.references = [], _.tref)
          for (n = 0; n < _.tref.boxes.length; n++)
            P = {}, p.references.push(P), P.type = _.tref.boxes[n].type, P.track_ids = _.tref.boxes[n].track_ids;
        _.edts && (p.edits = _.edts.elst.entries), p.created = new Date(ot + _.tkhd.creation_time * 1e3), p.modified = new Date(ot + _.tkhd.modification_time * 1e3), p.movie_duration = _.tkhd.duration, p.movie_timescale = d.timescale, p.layer = _.tkhd.layer, p.alternate_group = _.tkhd.alternate_group, p.volume = _.tkhd.volume, p.matrix = _.tkhd.matrix, p.track_width = _.tkhd.width / 65536, p.track_height = _.tkhd.height / 65536, p.timescale = _.mdia.mdhd.timescale, p.cts_shift = _.mdia.minf.stbl.cslg, p.duration = _.mdia.mdhd.duration, p.samples_duration = _.samples_duration, p.codec = $.getCodec(), p.kind = _.udta && _.udta.kinds.length ? _.udta.kinds[0] : { schemeURI: "", value: "" }, p.language = _.mdia.elng ? _.mdia.elng.extended_language : _.mdia.mdhd.languageString, p.nb_samples = _.samples.length, p.size = _.samples_size, p.bitrate = p.size * 8 * p.timescale / p.samples_duration, $.isAudio() ? (p.type = "audio", d.audioTracks.push(p), p.audio = {}, p.audio.sample_rate = $.getSampleRate(), p.audio.channel_count = $.getChannelCount(), p.audio.sample_size = $.getSampleSize()) : $.isVideo() ? (p.type = "video", d.videoTracks.push(p), p.video = {}, p.video.width = $.getWidth(), p.video.height = $.getHeight()) : $.isSubtitle() ? (p.type = "subtitles", d.subtitleTracks.push(p)) : $.isHint() ? (p.type = "metadata", d.hintTracks.push(p)) : $.isMetadata() ? (p.type = "metadata", d.metadataTracks.push(p)) : (p.type = "metadata", d.otherTracks.push(p));
      }
    else
      d.hasMoov = !1;
    if (d.mime = "", d.hasMoov && d.tracks) {
      for (d.videoTracks && d.videoTracks.length > 0 ? d.mime += 'video/mp4; codecs="' : d.audioTracks && d.audioTracks.length > 0 ? d.mime += 'audio/mp4; codecs="' : d.mime += 'application/mp4; codecs="', e = 0; e < d.tracks.length; e++)
        e !== 0 && (d.mime += ","), d.mime += d.tracks[e].codec;
      d.mime += '"; profiles="', d.mime += this.ftyp.compatible_brands.join(), d.mime += '"';
    }
    return d;
  }, m.prototype.setNextSeekPositionFromSample = function(e) {
    e && (this.nextSeekPosition ? this.nextSeekPosition = Math.min(e.offset + e.alreadyRead, this.nextSeekPosition) : this.nextSeekPosition = e.offset + e.alreadyRead);
  }, m.prototype.processSamples = function(e) {
    var n, d;
    if (this.sampleProcessingStarted) {
      if (this.isFragmentationInitialized && this.onSegment !== null)
        for (n = 0; n < this.fragmentedTracks.length; n++) {
          var _ = this.fragmentedTracks[n];
          for (d = _.trak; d.nextSample < d.samples.length && this.sampleProcessingStarted; ) {
            t.debug("ISOFile", "Creating media fragment on track #" + _.id + " for sample " + d.nextSample);
            var p = this.createFragment(_.id, d.nextSample, _.segmentStream);
            if (p)
              _.segmentStream = p, d.nextSample++;
            else
              break;
            if ((d.nextSample % _.nb_samples === 0 || e || d.nextSample >= d.samples.length) && (t.info("ISOFile", "Sending fragmented data on track #" + _.id + " for samples [" + Math.max(0, d.nextSample - _.nb_samples) + "," + (d.nextSample - 1) + "]"), t.info("ISOFile", "Sample data size in memory: " + this.getAllocatedSampleDataSize()), this.onSegment && this.onSegment(_.id, _.user, _.segmentStream.buffer, d.nextSample, e || d.nextSample >= d.samples.length), _.segmentStream = null, _ !== this.fragmentedTracks[n]))
              break;
          }
        }
      if (this.onSamples !== null)
        for (n = 0; n < this.extractedTracks.length; n++) {
          var P = this.extractedTracks[n];
          for (d = P.trak; d.nextSample < d.samples.length && this.sampleProcessingStarted; ) {
            t.debug("ISOFile", "Exporting on track #" + P.id + " sample #" + d.nextSample);
            var $ = this.getSample(d, d.nextSample);
            if ($)
              d.nextSample++, P.samples.push($);
            else {
              this.setNextSeekPositionFromSample(d.samples[d.nextSample]);
              break;
            }
            if ((d.nextSample % P.nb_samples === 0 || d.nextSample >= d.samples.length) && (t.debug("ISOFile", "Sending samples on track #" + P.id + " for sample " + d.nextSample), this.onSamples && this.onSamples(P.id, P.user, P.samples), P.samples = [], P !== this.extractedTracks[n]))
              break;
          }
        }
    }
  }, m.prototype.getBox = function(e) {
    var n = this.getBoxes(e, !0);
    return n.length ? n[0] : null;
  }, m.prototype.getBoxes = function(e, n) {
    var d = [];
    return m._sweep.call(this, e, d, n), d;
  }, m._sweep = function(e, n, d) {
    this.type && this.type == e && n.push(this);
    for (var _ in this.boxes) {
      if (n.length && d) return;
      m._sweep.call(this.boxes[_], e, n, d);
    }
  }, m.prototype.getTrackSamplesInfo = function(e) {
    var n = this.getTrackById(e);
    if (n)
      return n.samples;
  }, m.prototype.getTrackSample = function(e, n) {
    var d = this.getTrackById(e), _ = this.getSample(d, n);
    return _;
  }, m.prototype.releaseUsedSamples = function(e, n) {
    var d = 0, _ = this.getTrackById(e);
    _.lastValidSample || (_.lastValidSample = 0);
    for (var p = _.lastValidSample; p < n; p++)
      d += this.releaseSample(_, p);
    t.info("ISOFile", "Track #" + e + " released samples up to " + n + " (released size: " + d + ", remaining: " + this.samplesDataSize + ")"), _.lastValidSample = n;
  }, m.prototype.start = function() {
    this.sampleProcessingStarted = !0, this.processSamples(!1);
  }, m.prototype.stop = function() {
    this.sampleProcessingStarted = !1;
  }, m.prototype.flush = function() {
    t.info("ISOFile", "Flushing remaining samples"), this.updateSampleLists(), this.processSamples(!0), this.stream.cleanBuffers(), this.stream.logBufferLevel(!0);
  }, m.prototype.seekTrack = function(e, n, d) {
    var _, p, P = 1 / 0, $ = 0, ot = 0, dt;
    if (d.samples.length === 0)
      return t.info("ISOFile", "No sample in track, cannot seek! Using time " + t.getDurationString(0, 1) + " and offset: 0"), { offset: 0, time: 0 };
    for (_ = 0; _ < d.samples.length; _++) {
      if (p = d.samples[_], _ === 0)
        ot = 0, dt = p.timescale;
      else if (p.cts > e * p.timescale) {
        ot = _ - 1;
        break;
      }
      n && p.is_sync && ($ = _);
    }
    for (n && (ot = $), e = d.samples[ot].cts, d.nextSample = ot; d.samples[ot].alreadyRead === d.samples[ot].size && d.samples[ot + 1]; )
      ot++;
    return P = d.samples[ot].offset + d.samples[ot].alreadyRead, t.info("ISOFile", "Seeking to " + (n ? "RAP" : "") + " sample #" + d.nextSample + " on track " + d.tkhd.track_id + ", time " + t.getDurationString(e, dt) + " and offset: " + P), { offset: P, time: e / dt };
  }, m.prototype.getTrackDuration = function(e) {
    var n;
    return e.samples ? (n = e.samples[e.samples.length - 1], (n.cts + n.duration) / n.timescale) : 1 / 0;
  }, m.prototype.seek = function(e, n) {
    var d = this.moov, _, p, P, $ = { offset: 1 / 0, time: 1 / 0 };
    if (this.moov) {
      for (P = 0; P < d.traks.length; P++)
        _ = d.traks[P], !(e > this.getTrackDuration(_)) && (p = this.seekTrack(e, n, _), p.offset < $.offset && ($.offset = p.offset), p.time < $.time && ($.time = p.time));
      return t.info("ISOFile", "Seeking at time " + t.getDurationString($.time, 1) + " needs a buffer with a fileStart position of " + $.offset), $.offset === 1 / 0 ? $ = { offset: this.nextParsePosition, time: 0 } : $.offset = this.stream.getEndFilePositionAfter($.offset), t.info("ISOFile", "Adjusted seek position (after checking data already in buffer): " + $.offset), $;
    } else
      throw "Cannot seek: moov not received!";
  }, m.prototype.equal = function(e) {
    for (var n = 0; n < this.boxes.length && n < e.boxes.length; ) {
      var d = this.boxes[n], _ = e.boxes[n];
      if (!h.boxEqual(d, _))
        return !1;
      n++;
    }
    return !0;
  }, Et.ISOFile = m, m.prototype.lastBoxStartPosition = 0, m.prototype.parsingMdat = null, m.prototype.nextParsePosition = 0, m.prototype.discardMdatData = !1, m.prototype.processIncompleteBox = function(e) {
    var n, d, _;
    return e.type === "mdat" ? (n = new h[e.type + "Box"](e.size), this.parsingMdat = n, this.boxes.push(n), this.mdats.push(n), n.start = e.start, n.hdr_size = e.hdr_size, this.stream.addUsedBytes(n.hdr_size), this.lastBoxStartPosition = n.start + n.size, _ = this.stream.seek(n.start + n.size, !1, this.discardMdatData), _ ? (this.parsingMdat = null, !0) : (this.moovStartFound ? this.nextParsePosition = this.stream.findEndContiguousBuf() : this.nextParsePosition = n.start + n.size, !1)) : (e.type === "moov" && (this.moovStartFound = !0, this.mdats.length === 0 && (this.isProgressive = !0)), d = this.stream.mergeNextBuffer ? this.stream.mergeNextBuffer() : !1, d ? (this.nextParsePosition = this.stream.getEndPosition(), !0) : (e.type ? this.moovStartFound ? this.nextParsePosition = this.stream.getEndPosition() : this.nextParsePosition = this.stream.getPosition() + e.size : this.nextParsePosition = this.stream.getEndPosition(), !1));
  }, m.prototype.hasIncompleteMdat = function() {
    return this.parsingMdat !== null;
  }, m.prototype.processIncompleteMdat = function() {
    var e, n;
    return e = this.parsingMdat, n = this.stream.seek(e.start + e.size, !1, this.discardMdatData), n ? (t.debug("ISOFile", "Found 'mdat' end in buffered data"), this.parsingMdat = null, !0) : (this.nextParsePosition = this.stream.findEndContiguousBuf(), !1);
  }, m.prototype.restoreParsePosition = function() {
    return this.stream.seek(this.lastBoxStartPosition, !0, this.discardMdatData);
  }, m.prototype.saveParsePosition = function() {
    this.lastBoxStartPosition = this.stream.getPosition();
  }, m.prototype.updateUsedBytes = function(e, n) {
    this.stream.addUsedBytes && (e.type === "mdat" ? (this.stream.addUsedBytes(e.hdr_size), this.discardMdatData && this.stream.addUsedBytes(e.size - e.hdr_size)) : this.stream.addUsedBytes(e.size));
  }, m.prototype.add = h.Box.prototype.add, m.prototype.addBox = h.Box.prototype.addBox, m.prototype.init = function(e) {
    var n = e || {};
    this.add("ftyp").set("major_brand", n.brands && n.brands[0] || "iso4").set("minor_version", 0).set("compatible_brands", n.brands || ["iso4"]);
    var d = this.add("moov");
    return d.add("mvhd").set("timescale", n.timescale || 600).set("rate", n.rate || 65536).set("creation_time", 0).set("modification_time", 0).set("duration", n.duration || 0).set("volume", n.width ? 0 : 256).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("next_track_id", 1), d.add("mvex"), this;
  }, m.prototype.addTrack = function(e) {
    this.moov || this.init(e);
    var n = e || {};
    n.width = n.width || 320, n.height = n.height || 320, n.id = n.id || this.moov.mvhd.next_track_id, n.type = n.type || "avc1";
    var d = this.moov.add("trak");
    this.moov.mvhd.next_track_id = n.id + 1, d.add("tkhd").set("flags", h.TKHD_FLAG_ENABLED | h.TKHD_FLAG_IN_MOVIE | h.TKHD_FLAG_IN_PREVIEW).set("creation_time", 0).set("modification_time", 0).set("track_id", n.id).set("duration", n.duration || 0).set("layer", n.layer || 0).set("alternate_group", 0).set("volume", 1).set("matrix", [65536, 0, 0, 0, 65536, 0, 0, 0, 1073741824]).set("width", n.width << 16).set("height", n.height << 16);
    var _ = d.add("mdia");
    _.add("mdhd").set("creation_time", 0).set("modification_time", 0).set("timescale", n.timescale || 1).set("duration", n.media_duration || 0).set("language", n.language || "und"), _.add("hdlr").set("handler", n.hdlr || "vide").set("name", n.name || "Track created with MP4Box.js"), _.add("elng").set("extended_language", n.language || "fr-FR");
    var p = _.add("minf");
    if (h[n.type + "SampleEntry"] !== void 0) {
      var P = new h[n.type + "SampleEntry"]();
      P.data_reference_index = 1;
      var $ = "";
      for (var ot in h.sampleEntryCodes)
        for (var dt = h.sampleEntryCodes[ot], xt = 0; xt < dt.length; xt++)
          if (dt.indexOf(n.type) > -1) {
            $ = ot;
            break;
          }
      switch ($) {
        case "Visual":
          if (p.add("vmhd").set("graphicsmode", 0).set("opcolor", [0, 0, 0]), P.set("width", n.width).set("height", n.height).set("horizresolution", 72 << 16).set("vertresolution", 72 << 16).set("frame_count", 1).set("compressorname", n.type + " Compressor").set("depth", 24), n.avcDecoderConfigRecord) {
            var Nt = new h.avcCBox();
            Nt.parse(new r(n.avcDecoderConfigRecord)), P.addBox(Nt);
          } else if (n.hevcDecoderConfigRecord) {
            var jt = new h.hvcCBox();
            jt.parse(new r(n.hevcDecoderConfigRecord)), P.addBox(jt);
          }
          break;
        case "Audio":
          p.add("smhd").set("balance", n.balance || 0), P.set("channel_count", n.channel_count || 2).set("samplesize", n.samplesize || 16).set("samplerate", n.samplerate || 65536);
          break;
        case "Hint":
          p.add("hmhd");
          break;
        case "Subtitle":
          switch (p.add("sthd"), n.type) {
            case "stpp":
              P.set("namespace", n.namespace || "nonamespace").set("schema_location", n.schema_location || "").set("auxiliary_mime_types", n.auxiliary_mime_types || "");
              break;
          }
          break;
        case "Metadata":
          p.add("nmhd");
          break;
        case "System":
          p.add("nmhd");
          break;
        default:
          p.add("nmhd");
          break;
      }
      n.description && P.addBox(n.description), n.description_boxes && n.description_boxes.forEach(function(I) {
        P.addBox(I);
      }), p.add("dinf").add("dref").addEntry(new h["url Box"]().set("flags", 1));
      var q = p.add("stbl");
      return q.add("stsd").addEntry(P), q.add("stts").set("sample_counts", []).set("sample_deltas", []), q.add("stsc").set("first_chunk", []).set("samples_per_chunk", []).set("sample_description_index", []), q.add("stco").set("chunk_offsets", []), q.add("stsz").set("sample_sizes", []), this.moov.mvex.add("trex").set("track_id", n.id).set("default_sample_description_index", n.default_sample_description_index || 1).set("default_sample_duration", n.default_sample_duration || 0).set("default_sample_size", n.default_sample_size || 0).set("default_sample_flags", n.default_sample_flags || 0), this.buildTrakSampleLists(d), n.id;
    }
  }, h.Box.prototype.computeSize = function(e) {
    var n = e || new c();
    n.endianness = c.BIG_ENDIAN, this.write(n);
  }, m.prototype.addSample = function(e, n, d) {
    var _ = d || {}, p = {}, P = this.getTrackById(e);
    if (P !== null) {
      p.number = P.samples.length, p.track_id = P.tkhd.track_id, p.timescale = P.mdia.mdhd.timescale, p.description_index = _.sample_description_index ? _.sample_description_index - 1 : 0, p.description = P.mdia.minf.stbl.stsd.entries[p.description_index], p.data = n, p.size = n.byteLength, p.alreadyRead = p.size, p.duration = _.duration || 1, p.cts = _.cts || 0, p.dts = _.dts || 0, p.is_sync = _.is_sync || !1, p.is_leading = _.is_leading || 0, p.depends_on = _.depends_on || 0, p.is_depended_on = _.is_depended_on || 0, p.has_redundancy = _.has_redundancy || 0, p.degradation_priority = _.degradation_priority || 0, p.offset = 0, p.subsamples = _.subsamples, P.samples.push(p), P.samples_size += p.size, P.samples_duration += p.duration, P.first_dts === void 0 && (P.first_dts = _.dts), this.processSamples();
      var $ = this.createSingleSampleMoof(p);
      return this.addBox($), $.computeSize(), $.trafs[0].truns[0].data_offset = $.size + 8, this.add("mdat").data = new Uint8Array(n), p;
    }
  }, m.prototype.createSingleSampleMoof = function(e) {
    var n = 0;
    e.is_sync ? n = 1 << 25 : n = 65536;
    var d = new h.moofBox();
    d.add("mfhd").set("sequence_number", this.nextMoofNumber), this.nextMoofNumber++;
    var _ = d.add("traf"), p = this.getTrackById(e.track_id);
    return _.add("tfhd").set("track_id", e.track_id).set("flags", h.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), _.add("tfdt").set("baseMediaDecodeTime", e.dts - (p.first_dts || 0)), _.add("trun").set("flags", h.TRUN_FLAGS_DATA_OFFSET | h.TRUN_FLAGS_DURATION | h.TRUN_FLAGS_SIZE | h.TRUN_FLAGS_FLAGS | h.TRUN_FLAGS_CTS_OFFSET).set("data_offset", 0).set("first_sample_flags", 0).set("sample_count", 1).set("sample_duration", [e.duration]).set("sample_size", [e.size]).set("sample_flags", [n]).set("sample_composition_time_offset", [e.cts - e.dts]), d;
  }, m.prototype.lastMoofIndex = 0, m.prototype.samplesDataSize = 0, m.prototype.resetTables = function() {
    var e, n, d, _, p, P, $, ot;
    for (this.initial_duration = this.moov.mvhd.duration, this.moov.mvhd.duration = 0, e = 0; e < this.moov.traks.length; e++) {
      n = this.moov.traks[e], n.tkhd.duration = 0, n.mdia.mdhd.duration = 0, d = n.mdia.minf.stbl.stco || n.mdia.minf.stbl.co64, d.chunk_offsets = [], _ = n.mdia.minf.stbl.stsc, _.first_chunk = [], _.samples_per_chunk = [], _.sample_description_index = [], p = n.mdia.minf.stbl.stsz || n.mdia.minf.stbl.stz2, p.sample_sizes = [], P = n.mdia.minf.stbl.stts, P.sample_counts = [], P.sample_deltas = [], $ = n.mdia.minf.stbl.ctts, $ && ($.sample_counts = [], $.sample_offsets = []), ot = n.mdia.minf.stbl.stss;
      var dt = n.mdia.minf.stbl.boxes.indexOf(ot);
      dt != -1 && (n.mdia.minf.stbl.boxes[dt] = null);
    }
  }, m.initSampleGroups = function(e, n, d, _, p) {
    var P, $, ot, dt;
    function xt(Nt, jt, q) {
      this.grouping_type = Nt, this.grouping_type_parameter = jt, this.sbgp = q, this.last_sample_in_run = -1, this.entry_index = -1;
    }
    for (n && (n.sample_groups_info = []), e.sample_groups_info || (e.sample_groups_info = []), $ = 0; $ < d.length; $++) {
      for (dt = d[$].grouping_type + "/" + d[$].grouping_type_parameter, ot = new xt(d[$].grouping_type, d[$].grouping_type_parameter, d[$]), n && (n.sample_groups_info[dt] = ot), e.sample_groups_info[dt] || (e.sample_groups_info[dt] = ot), P = 0; P < _.length; P++)
        _[P].grouping_type === d[$].grouping_type && (ot.description = _[P], ot.description.used = !0);
      if (p)
        for (P = 0; P < p.length; P++)
          p[P].grouping_type === d[$].grouping_type && (ot.fragment_description = p[P], ot.fragment_description.used = !0, ot.is_fragment = !0);
    }
    if (n) {
      if (p)
        for ($ = 0; $ < p.length; $++)
          !p[$].used && p[$].version >= 2 && (dt = p[$].grouping_type + "/0", ot = new xt(p[$].grouping_type, 0), ot.is_fragment = !0, n.sample_groups_info[dt] || (n.sample_groups_info[dt] = ot));
    } else
      for ($ = 0; $ < _.length; $++)
        !_[$].used && _[$].version >= 2 && (dt = _[$].grouping_type + "/0", ot = new xt(_[$].grouping_type, 0), e.sample_groups_info[dt] || (e.sample_groups_info[dt] = ot));
  }, m.setSampleGroupProperties = function(e, n, d, _) {
    var p, P;
    n.sample_groups = [];
    for (p in _)
      if (n.sample_groups[p] = {}, n.sample_groups[p].grouping_type = _[p].grouping_type, n.sample_groups[p].grouping_type_parameter = _[p].grouping_type_parameter, d >= _[p].last_sample_in_run && (_[p].last_sample_in_run < 0 && (_[p].last_sample_in_run = 0), _[p].entry_index++, _[p].entry_index <= _[p].sbgp.entries.length - 1 && (_[p].last_sample_in_run += _[p].sbgp.entries[_[p].entry_index].sample_count)), _[p].entry_index <= _[p].sbgp.entries.length - 1 ? n.sample_groups[p].group_description_index = _[p].sbgp.entries[_[p].entry_index].group_description_index : n.sample_groups[p].group_description_index = -1, n.sample_groups[p].group_description_index !== 0) {
        var $;
        _[p].fragment_description ? $ = _[p].fragment_description : $ = _[p].description, n.sample_groups[p].group_description_index > 0 ? (n.sample_groups[p].group_description_index > 65535 ? P = (n.sample_groups[p].group_description_index >> 16) - 1 : P = n.sample_groups[p].group_description_index - 1, $ && P >= 0 && (n.sample_groups[p].description = $.entries[P])) : $ && $.version >= 2 && $.default_group_description_index > 0 && (n.sample_groups[p].description = $.entries[$.default_group_description_index - 1]);
      }
  }, m.process_sdtp = function(e, n, d) {
    n && (e ? (n.is_leading = e.is_leading[d], n.depends_on = e.sample_depends_on[d], n.is_depended_on = e.sample_is_depended_on[d], n.has_redundancy = e.sample_has_redundancy[d]) : (n.is_leading = 0, n.depends_on = 0, n.is_depended_on = 0, n.has_redundancy = 0));
  }, m.prototype.buildSampleLists = function() {
    var e, n;
    for (e = 0; e < this.moov.traks.length; e++)
      n = this.moov.traks[e], this.buildTrakSampleLists(n);
  }, m.prototype.buildTrakSampleLists = function(e) {
    var n, d, _, p, P, $, ot, dt, xt, Nt, jt, q, I, pt, It, et, Dt, ae, St, qe, zt, Ct, de, ze;
    if (e.samples = [], e.samples_duration = 0, e.samples_size = 0, d = e.mdia.minf.stbl.stco || e.mdia.minf.stbl.co64, _ = e.mdia.minf.stbl.stsc, p = e.mdia.minf.stbl.stsz || e.mdia.minf.stbl.stz2, P = e.mdia.minf.stbl.stts, $ = e.mdia.minf.stbl.ctts, ot = e.mdia.minf.stbl.stss, dt = e.mdia.minf.stbl.stsd, xt = e.mdia.minf.stbl.subs, q = e.mdia.minf.stbl.stdp, Nt = e.mdia.minf.stbl.sbgps, jt = e.mdia.minf.stbl.sgpds, ae = -1, St = -1, qe = -1, zt = -1, Ct = 0, de = 0, ze = 0, m.initSampleGroups(e, null, Nt, jt), !(typeof p > "u")) {
      for (n = 0; n < p.sample_sizes.length; n++) {
        var le = {};
        le.number = n, le.track_id = e.tkhd.track_id, le.timescale = e.mdia.mdhd.timescale, le.alreadyRead = 0, e.samples[n] = le, le.size = p.sample_sizes[n], e.samples_size += le.size, n === 0 ? (pt = 1, I = 0, le.chunk_index = pt, le.chunk_run_index = I, Dt = _.samples_per_chunk[I], et = 0, I + 1 < _.first_chunk.length ? It = _.first_chunk[I + 1] - 1 : It = 1 / 0) : n < Dt ? (le.chunk_index = pt, le.chunk_run_index = I) : (pt++, le.chunk_index = pt, et = 0, pt <= It || (I++, I + 1 < _.first_chunk.length ? It = _.first_chunk[I + 1] - 1 : It = 1 / 0), le.chunk_run_index = I, Dt += _.samples_per_chunk[I]), le.description_index = _.sample_description_index[le.chunk_run_index] - 1, le.description = dt.entries[le.description_index], le.offset = d.chunk_offsets[le.chunk_index - 1] + et, et += le.size, n > ae && (St++, ae < 0 && (ae = 0), ae += P.sample_counts[St]), n > 0 ? (e.samples[n - 1].duration = P.sample_deltas[St], e.samples_duration += e.samples[n - 1].duration, le.dts = e.samples[n - 1].dts + e.samples[n - 1].duration) : le.dts = 0, $ ? (n >= qe && (zt++, qe < 0 && (qe = 0), qe += $.sample_counts[zt]), le.cts = e.samples[n].dts + $.sample_offsets[zt]) : le.cts = le.dts, ot ? (n == ot.sample_numbers[Ct] - 1 ? (le.is_sync = !0, Ct++) : (le.is_sync = !1, le.degradation_priority = 0), xt && xt.entries[de].sample_delta + ze == n + 1 && (le.subsamples = xt.entries[de].subsamples, ze += xt.entries[de].sample_delta, de++)) : le.is_sync = !0, m.process_sdtp(e.mdia.minf.stbl.sdtp, le, le.number), q ? le.degradation_priority = q.priority[n] : le.degradation_priority = 0, xt && xt.entries[de].sample_delta + ze == n && (le.subsamples = xt.entries[de].subsamples, ze += xt.entries[de].sample_delta), (Nt.length > 0 || jt.length > 0) && m.setSampleGroupProperties(e, le, n, e.sample_groups_info);
      }
      n > 0 && (e.samples[n - 1].duration = Math.max(e.mdia.mdhd.duration - e.samples[n - 1].dts, 0), e.samples_duration += e.samples[n - 1].duration);
    }
  }, m.prototype.updateSampleLists = function() {
    var e, n, d, _, p, P, $, ot, dt, xt, Nt, jt, q, I, pt;
    if (this.moov !== void 0) {
      for (; this.lastMoofIndex < this.moofs.length; )
        if (dt = this.moofs[this.lastMoofIndex], this.lastMoofIndex++, dt.type == "moof")
          for (xt = dt, e = 0; e < xt.trafs.length; e++) {
            for (Nt = xt.trafs[e], jt = this.getTrackById(Nt.tfhd.track_id), q = this.getTrexById(Nt.tfhd.track_id), Nt.tfhd.flags & h.TFHD_FLAG_SAMPLE_DESC ? _ = Nt.tfhd.default_sample_description_index : _ = q ? q.default_sample_description_index : 1, Nt.tfhd.flags & h.TFHD_FLAG_SAMPLE_DUR ? p = Nt.tfhd.default_sample_duration : p = q ? q.default_sample_duration : 0, Nt.tfhd.flags & h.TFHD_FLAG_SAMPLE_SIZE ? P = Nt.tfhd.default_sample_size : P = q ? q.default_sample_size : 0, Nt.tfhd.flags & h.TFHD_FLAG_SAMPLE_FLAGS ? $ = Nt.tfhd.default_sample_flags : $ = q ? q.default_sample_flags : 0, Nt.sample_number = 0, Nt.sbgps.length > 0 && m.initSampleGroups(jt, Nt, Nt.sbgps, jt.mdia.minf.stbl.sgpds, Nt.sgpds), n = 0; n < Nt.truns.length; n++) {
              var It = Nt.truns[n];
              for (d = 0; d < It.sample_count; d++) {
                I = {}, I.moof_number = this.lastMoofIndex, I.number_in_traf = Nt.sample_number, Nt.sample_number++, I.number = jt.samples.length, Nt.first_sample_index = jt.samples.length, jt.samples.push(I), I.track_id = jt.tkhd.track_id, I.timescale = jt.mdia.mdhd.timescale, I.description_index = _ - 1, I.description = jt.mdia.minf.stbl.stsd.entries[I.description_index], I.size = P, It.flags & h.TRUN_FLAGS_SIZE && (I.size = It.sample_size[d]), jt.samples_size += I.size, I.duration = p, It.flags & h.TRUN_FLAGS_DURATION && (I.duration = It.sample_duration[d]), jt.samples_duration += I.duration, d > 0 ? I.dts = jt.samples[jt.samples.length - 2].dts + jt.samples[jt.samples.length - 2].duration : Nt.tfdt ? I.dts = Nt.tfdt.baseMediaDecodeTime : I.dts = 0, I.cts = I.dts, It.flags & h.TRUN_FLAGS_CTS_OFFSET && (I.cts = I.dts + It.sample_composition_time_offset[d]), pt = $, It.flags & h.TRUN_FLAGS_FLAGS ? pt = It.sample_flags[d] : d === 0 && It.flags & h.TRUN_FLAGS_FIRST_FLAG && (pt = It.first_sample_flags), I.is_sync = !(pt >> 16 & 1), I.is_leading = pt >> 26 & 3, I.depends_on = pt >> 24 & 3, I.is_depended_on = pt >> 22 & 3, I.has_redundancy = pt >> 20 & 3, I.degradation_priority = pt & 65535;
                var et = !!(Nt.tfhd.flags & h.TFHD_FLAG_BASE_DATA_OFFSET), Dt = !!(Nt.tfhd.flags & h.TFHD_FLAG_DEFAULT_BASE_IS_MOOF), ae = !!(It.flags & h.TRUN_FLAGS_DATA_OFFSET), St = 0;
                et ? St = Nt.tfhd.base_data_offset : Dt || n === 0 ? St = xt.start : St = ot, n === 0 && d === 0 ? ae ? I.offset = St + It.data_offset : I.offset = St : I.offset = ot, ot = I.offset + I.size, (Nt.sbgps.length > 0 || Nt.sgpds.length > 0 || jt.mdia.minf.stbl.sbgps.length > 0 || jt.mdia.minf.stbl.sgpds.length > 0) && m.setSampleGroupProperties(jt, I, I.number_in_traf, Nt.sample_groups_info);
              }
            }
            if (Nt.subs) {
              jt.has_fragment_subsamples = !0;
              var qe = Nt.first_sample_index;
              for (n = 0; n < Nt.subs.entries.length; n++)
                qe += Nt.subs.entries[n].sample_delta, I = jt.samples[qe - 1], I.subsamples = Nt.subs.entries[n].subsamples;
            }
          }
    }
  }, m.prototype.getSample = function(e, n) {
    var d, _ = e.samples[n];
    if (!this.moov)
      return null;
    var p = this.moofs[_.moof_number - 1];
    if (!p)
      return t.debug("ISOFile", "Where's the moof?"), null;
    var P = p.trafs[0];
    if (!P)
      return t.debug("ISOFile", "Where's the traf?"), null;
    if (P.senc) {
      var $ = P.senc.samples[_.number_in_traf];
      _.encrypted = !0, _.InitializationVector = $.InitializationVector;
    }
    if (!_.data)
      _.data = new Uint8Array(_.size), _.alreadyRead = 0, this.samplesDataSize += _.size, t.debug("ISOFile", "Allocating sample #" + n + " on track #" + e.tkhd.track_id + " of size " + _.size + " (total: " + this.samplesDataSize + ")");
    else if (_.alreadyRead == _.size)
      return _;
    for (; ; ) {
      var ot = this.stream.findPosition(!0, _.offset + _.alreadyRead, !1);
      if (ot > -1) {
        d = this.stream.buffers[ot];
        var dt = d.byteLength - (_.offset + _.alreadyRead - d.fileStart);
        if (_.size - _.alreadyRead <= dt)
          return t.debug("ISOFile", "Getting sample #" + n + " data (alreadyRead: " + _.alreadyRead + " offset: " + (_.offset + _.alreadyRead - d.fileStart) + " read size: " + (_.size - _.alreadyRead) + " full size: " + _.size + ")"), c.memcpy(
            _.data.buffer,
            _.alreadyRead,
            d,
            _.offset + _.alreadyRead - d.fileStart,
            _.size - _.alreadyRead
          ), d.usedBytes += _.size - _.alreadyRead, this.stream.logBufferLevel(), _.alreadyRead = _.size, _;
        if (dt === 0) return null;
        t.debug("ISOFile", "Getting sample #" + n + " partial data (alreadyRead: " + _.alreadyRead + " offset: " + (_.offset + _.alreadyRead - d.fileStart) + " read size: " + dt + " full size: " + _.size + ")"), c.memcpy(
          _.data.buffer,
          _.alreadyRead,
          d,
          _.offset + _.alreadyRead - d.fileStart,
          dt
        ), _.alreadyRead += dt, d.usedBytes += dt, this.stream.logBufferLevel();
      } else
        return null;
    }
  }, m.prototype.releaseSample = function(e, n) {
    var d = e.samples[n];
    return d.data ? (this.samplesDataSize -= d.size, d.data = null, d.alreadyRead = 0, d.size) : 0;
  }, m.prototype.getAllocatedSampleDataSize = function() {
    return this.samplesDataSize;
  }, m.prototype.getCodecs = function() {
    var e, n = "";
    for (e = 0; e < this.moov.traks.length; e++) {
      var d = this.moov.traks[e];
      e > 0 && (n += ","), n += d.mdia.minf.stbl.stsd.entries[0].getCodec();
    }
    return n;
  }, m.prototype.getTrexById = function(e) {
    var n;
    if (!this.moov || !this.moov.mvex) return null;
    for (n = 0; n < this.moov.mvex.trexs.length; n++) {
      var d = this.moov.mvex.trexs[n];
      if (d.track_id == e) return d;
    }
    return null;
  }, m.prototype.getTrackById = function(e) {
    if (this.moov === void 0)
      return null;
    for (var n = 0; n < this.moov.traks.length; n++) {
      var d = this.moov.traks[n];
      if (d.tkhd.track_id == e) return d;
    }
    return null;
  }, m.prototype.itemsDataSize = 0, m.prototype.flattenItemInfo = function() {
    var e = this.items, n = this.entity_groups, d, _, p, P = this.meta;
    if (P != null && P.hdlr !== void 0 && P.iinf !== void 0) {
      for (d = 0; d < P.iinf.item_infos.length; d++)
        p = {}, p.id = P.iinf.item_infos[d].item_ID, e[p.id] = p, p.ref_to = [], p.name = P.iinf.item_infos[d].item_name, P.iinf.item_infos[d].protection_index > 0 && (p.protection = P.ipro.protections[P.iinf.item_infos[d].protection_index - 1]), P.iinf.item_infos[d].item_type ? p.type = P.iinf.item_infos[d].item_type : p.type = "mime", p.content_type = P.iinf.item_infos[d].content_type, p.content_encoding = P.iinf.item_infos[d].content_encoding, p.item_uri_type = P.iinf.item_infos[d].item_uri_type;
      if (P.grpl)
        for (d = 0; d < P.grpl.boxes.length; d++)
          entity_group = {}, entity_group.id = P.grpl.boxes[d].group_id, entity_group.entity_ids = P.grpl.boxes[d].entity_ids, entity_group.type = P.grpl.boxes[d].type, n[entity_group.id] = entity_group;
      if (P.iloc)
        for (d = 0; d < P.iloc.items.length; d++) {
          var $ = P.iloc.items[d];
          switch (p = e[$.item_ID], $.data_reference_index !== 0 && (t.warn("Item storage with reference to other files: not supported"), p.source = P.dinf.boxes[$.data_reference_index - 1]), $.construction_method) {
            case 0:
              break;
            case 1:
              break;
            case 2:
              t.warn("Item storage with construction_method : not supported");
              break;
          }
          for (p.extents = [], p.size = 0, _ = 0; _ < $.extents.length; _++)
            p.extents[_] = {}, p.extents[_].offset = $.extents[_].extent_offset + $.base_offset, $.construction_method == 1 && (p.extents[_].offset += P.idat.start + P.idat.hdr_size), p.extents[_].length = $.extents[_].extent_length, p.extents[_].alreadyRead = 0, p.size += p.extents[_].length;
        }
      if (P.pitm && (e[P.pitm.item_id].primary = !0), P.iref)
        for (d = 0; d < P.iref.references.length; d++) {
          var ot = P.iref.references[d];
          for (_ = 0; _ < ot.references.length; _++)
            e[ot.from_item_ID].ref_to.push({ type: ot.type, id: ot.references[_] });
        }
      if (P.iprp)
        for (var dt = 0; dt < P.iprp.ipmas.length; dt++) {
          var xt = P.iprp.ipmas[dt];
          for (d = 0; d < xt.associations.length; d++) {
            var Nt = xt.associations[d];
            if (p = e[Nt.id], p || (p = n[Nt.id]), p)
              for (p.properties === void 0 && (p.properties = {}, p.properties.boxes = []), _ = 0; _ < Nt.props.length; _++) {
                var jt = Nt.props[_];
                if (jt.property_index > 0 && jt.property_index - 1 < P.iprp.ipco.boxes.length) {
                  var q = P.iprp.ipco.boxes[jt.property_index - 1];
                  p.properties[q.type] = q, p.properties.boxes.push(q);
                }
              }
          }
        }
    }
  }, m.prototype.getItem = function(e) {
    var n, d;
    if (!this.meta)
      return null;
    if (d = this.items[e], !d.data && d.size)
      d.data = new Uint8Array(d.size), d.alreadyRead = 0, this.itemsDataSize += d.size, t.debug("ISOFile", "Allocating item #" + e + " of size " + d.size + " (total: " + this.itemsDataSize + ")");
    else if (d.alreadyRead === d.size)
      return d;
    for (var _ = 0; _ < d.extents.length; _++) {
      var p = d.extents[_];
      if (p.alreadyRead !== p.length) {
        var P = this.stream.findPosition(!0, p.offset + p.alreadyRead, !1);
        if (P > -1) {
          n = this.stream.buffers[P];
          var $ = n.byteLength - (p.offset + p.alreadyRead - n.fileStart);
          if (p.length - p.alreadyRead <= $)
            t.debug("ISOFile", "Getting item #" + e + " extent #" + _ + " data (alreadyRead: " + p.alreadyRead + " offset: " + (p.offset + p.alreadyRead - n.fileStart) + " read size: " + (p.length - p.alreadyRead) + " full extent size: " + p.length + " full item size: " + d.size + ")"), c.memcpy(
              d.data.buffer,
              d.alreadyRead,
              n,
              p.offset + p.alreadyRead - n.fileStart,
              p.length - p.alreadyRead
            ), n.usedBytes += p.length - p.alreadyRead, this.stream.logBufferLevel(), d.alreadyRead += p.length - p.alreadyRead, p.alreadyRead = p.length;
          else
            return t.debug("ISOFile", "Getting item #" + e + " extent #" + _ + " partial data (alreadyRead: " + p.alreadyRead + " offset: " + (p.offset + p.alreadyRead - n.fileStart) + " read size: " + $ + " full extent size: " + p.length + " full item size: " + d.size + ")"), c.memcpy(
              d.data.buffer,
              d.alreadyRead,
              n,
              p.offset + p.alreadyRead - n.fileStart,
              $
            ), p.alreadyRead += $, d.alreadyRead += $, n.usedBytes += $, this.stream.logBufferLevel(), null;
        } else
          return null;
      }
    }
    return d.alreadyRead === d.size ? d : null;
  }, m.prototype.releaseItem = function(e) {
    var n = this.items[e];
    if (n.data) {
      this.itemsDataSize -= n.size, n.data = null, n.alreadyRead = 0;
      for (var d = 0; d < n.extents.length; d++) {
        var _ = n.extents[d];
        _.alreadyRead = 0;
      }
      return n.size;
    } else
      return 0;
  }, m.prototype.processItems = function(e) {
    for (var n in this.items) {
      var d = this.items[n];
      this.getItem(d.id), e && !d.sent && (e(d), d.sent = !0, d.data = null);
    }
  }, m.prototype.hasItem = function(e) {
    for (var n in this.items) {
      var d = this.items[n];
      if (d.name === e)
        return d.id;
    }
    return -1;
  }, m.prototype.getMetaHandler = function() {
    return this.meta ? this.meta.hdlr.handler : null;
  }, m.prototype.getPrimaryItem = function() {
    return !this.meta || !this.meta.pitm ? null : this.getItem(this.meta.pitm.item_id);
  }, m.prototype.itemToFragmentedTrackFile = function(e) {
    var n = e || {}, d = null;
    if (n.itemId ? d = this.getItem(n.itemId) : d = this.getPrimaryItem(), d == null) return null;
    var _ = new m();
    _.discardMdatData = !1;
    var p = { type: d.type, description_boxes: d.properties.boxes };
    d.properties.ispe && (p.width = d.properties.ispe.image_width, p.height = d.properties.ispe.image_height);
    var P = _.addTrack(p);
    return P ? (_.addSample(P, d.data), _) : null;
  }, m.prototype.write = function(e) {
    for (var n = 0; n < this.boxes.length; n++)
      this.boxes[n].write(e);
  }, m.prototype.createFragment = function(e, n, d) {
    var _ = this.getTrackById(e), p = this.getSample(_, n);
    if (p == null)
      return this.setNextSeekPositionFromSample(_.samples[n]), null;
    var P = d || new c();
    P.endianness = c.BIG_ENDIAN;
    var $ = this.createSingleSampleMoof(p);
    $.write(P), $.trafs[0].truns[0].data_offset = $.size + 8, t.debug("MP4Box", "Adjusting data_offset with new value " + $.trafs[0].truns[0].data_offset), P.adjustUint32($.trafs[0].truns[0].data_offset_position, $.trafs[0].truns[0].data_offset);
    var ot = new h.mdatBox();
    return ot.data = p.data, ot.write(P), P;
  }, m.writeInitializationSegment = function(e, n, d, _) {
    var p;
    t.debug("ISOFile", "Generating initialization segment");
    var P = new c();
    P.endianness = c.BIG_ENDIAN, e.write(P);
    var $ = n.add("mvex");
    for (d && $.add("mehd").set("fragment_duration", d), p = 0; p < n.traks.length; p++)
      $.add("trex").set("track_id", n.traks[p].tkhd.track_id).set("default_sample_description_index", 1).set("default_sample_duration", _).set("default_sample_size", 0).set("default_sample_flags", 65536);
    return n.write(P), P.buffer;
  }, m.prototype.save = function(e) {
    var n = new c();
    n.endianness = c.BIG_ENDIAN, this.write(n), n.save(e);
  }, m.prototype.getBuffer = function() {
    var e = new c();
    return e.endianness = c.BIG_ENDIAN, this.write(e), e.buffer;
  }, m.prototype.initializeSegmentation = function() {
    var e, n, d, _;
    for (this.onSegment === null && t.warn("MP4Box", "No segmentation callback set!"), this.isFragmentationInitialized || (this.isFragmentationInitialized = !0, this.nextMoofNumber = 0, this.resetTables()), n = [], e = 0; e < this.fragmentedTracks.length; e++) {
      var p = new h.moovBox();
      p.mvhd = this.moov.mvhd, p.boxes.push(p.mvhd), d = this.getTrackById(this.fragmentedTracks[e].id), p.boxes.push(d), p.traks.push(d), _ = {}, _.id = d.tkhd.track_id, _.user = this.fragmentedTracks[e].user, _.buffer = m.writeInitializationSegment(this.ftyp, p, this.moov.mvex && this.moov.mvex.mehd ? this.moov.mvex.mehd.fragment_duration : void 0, this.moov.traks[e].samples.length > 0 ? this.moov.traks[e].samples[0].duration : 0), n.push(_);
    }
    return n;
  }, h.Box.prototype.printHeader = function(e) {
    this.size += 8, this.size > w && (this.size += 8), this.type === "uuid" && (this.size += 16), e.log(e.indent + "size:" + this.size), e.log(e.indent + "type:" + this.type);
  }, h.FullBox.prototype.printHeader = function(e) {
    this.size += 4, h.Box.prototype.printHeader.call(this, e), e.log(e.indent + "version:" + this.version), e.log(e.indent + "flags:" + this.flags);
  }, h.Box.prototype.print = function(e) {
    this.printHeader(e);
  }, h.ContainerBox.prototype.print = function(e) {
    this.printHeader(e);
    for (var n = 0; n < this.boxes.length; n++)
      if (this.boxes[n]) {
        var d = e.indent;
        e.indent += " ", this.boxes[n].print(e), e.indent = d;
      }
  }, m.prototype.print = function(e) {
    e.indent = "";
    for (var n = 0; n < this.boxes.length; n++)
      this.boxes[n] && this.boxes[n].print(e);
  }, h.mvhdBox.prototype.print = function(e) {
    h.FullBox.prototype.printHeader.call(this, e), e.log(e.indent + "creation_time: " + this.creation_time), e.log(e.indent + "modification_time: " + this.modification_time), e.log(e.indent + "timescale: " + this.timescale), e.log(e.indent + "duration: " + this.duration), e.log(e.indent + "rate: " + this.rate), e.log(e.indent + "volume: " + (this.volume >> 8)), e.log(e.indent + "matrix: " + this.matrix.join(", ")), e.log(e.indent + "next_track_id: " + this.next_track_id);
  }, h.tkhdBox.prototype.print = function(e) {
    h.FullBox.prototype.printHeader.call(this, e), e.log(e.indent + "creation_time: " + this.creation_time), e.log(e.indent + "modification_time: " + this.modification_time), e.log(e.indent + "track_id: " + this.track_id), e.log(e.indent + "duration: " + this.duration), e.log(e.indent + "volume: " + (this.volume >> 8)), e.log(e.indent + "matrix: " + this.matrix.join(", ")), e.log(e.indent + "layer: " + this.layer), e.log(e.indent + "alternate_group: " + this.alternate_group), e.log(e.indent + "width: " + this.width), e.log(e.indent + "height: " + this.height);
  };
  var S = {};
  S.createFile = function(e, n) {
    var d = e !== void 0 ? e : !0, _ = new m(n);
    return _.discardMdatData = !d, _;
  }, Et.createFile = S.createFile;
})(am);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const sm = "173", Cl = 0, Ty = 1, iv = 2, rh = 1, ah = 100, sh = 204, oh = 205, lh = 3, wy = 0, om = 300, uh = 1e3, il = 1001, dh = 1002, rv = 1003, av = 1004, sv = 1005, Ay = 1006, ov = 1007, Sy = 1008, My = 1009, ky = 1015, xy = 1023, lv = 2300, uv = 2301, Ly = 0, lm = "", kr = "srgb", Nl = "srgb-linear", ch = "linear", du = "srgb", Cs = 7680, hh = 519, fh = 35044, Dy = "100", rl = 2e3, mh = 2001;
class Yl {
  addEventListener(t, r) {
    this._listeners === void 0 && (this._listeners = {});
    const c = this._listeners;
    c[t] === void 0 && (c[t] = []), c[t].indexOf(r) === -1 && c[t].push(r);
  }
  hasEventListener(t, r) {
    const c = this._listeners;
    return c === void 0 ? !1 : c[t] !== void 0 && c[t].indexOf(r) !== -1;
  }
  removeEventListener(t, r) {
    const c = this._listeners;
    if (c === void 0) return;
    const w = c[t];
    if (w !== void 0) {
      const R = w.indexOf(r);
      R !== -1 && w.splice(R, 1);
    }
  }
  dispatchEvent(t) {
    const r = this._listeners;
    if (r === void 0) return;
    const c = r[t.type];
    if (c !== void 0) {
      t.target = this;
      const w = c.slice(0);
      for (let R = 0, L = w.length; R < L; R++)
        w[R].call(this, t);
      t.target = null;
    }
  }
}
const er = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ph = 1234567;
const um = Math.PI / 180, dm = 180 / Math.PI;
function Js() {
  const Et = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, r = Math.random() * 4294967295 | 0, c = Math.random() * 4294967295 | 0;
  return (er[Et & 255] + er[Et >> 8 & 255] + er[Et >> 16 & 255] + er[Et >> 24 & 255] + "-" + er[t & 255] + er[t >> 8 & 255] + "-" + er[t >> 16 & 15 | 64] + er[t >> 24 & 255] + "-" + er[r & 63 | 128] + er[r >> 8 & 255] + "-" + er[r >> 16 & 255] + er[r >> 24 & 255] + er[c & 255] + er[c >> 8 & 255] + er[c >> 16 & 255] + er[c >> 24 & 255]).toLowerCase();
}
function fi(Et, t, r) {
  return Math.max(t, Math.min(r, Et));
}
function ad(Et, t) {
  return (Et % t + t) % t;
}
function Iy(Et, t, r, c, w) {
  return c + (Et - t) * (w - c) / (r - t);
}
function Ry(Et, t, r) {
  return Et !== t ? (r - Et) / (t - Et) : 0;
}
function wo(Et, t, r) {
  return (1 - r) * Et + r * t;
}
function Cy(Et, t, r, c) {
  return wo(Et, t, 1 - Math.exp(-r * c));
}
function Ny(Et, t = 1) {
  return t - Math.abs(ad(Et, t * 2) - t);
}
function Py(Et, t, r) {
  return Et <= t ? 0 : Et >= r ? 1 : (Et = (Et - t) / (r - t), Et * Et * (3 - 2 * Et));
}
function zy(Et, t, r) {
  return Et <= t ? 0 : Et >= r ? 1 : (Et = (Et - t) / (r - t), Et * Et * Et * (Et * (Et * 6 - 15) + 10));
}
function Oy(Et, t) {
  return Et + Math.floor(Math.random() * (t - Et + 1));
}
function Yy(Et, t) {
  return Et + Math.random() * (t - Et);
}
function Fy(Et) {
  return Et * (0.5 - Math.random());
}
function Uy(Et) {
  Et !== void 0 && (ph = Et);
  let t = ph += 1831565813;
  return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296;
}
function jy(Et) {
  return Et * um;
}
function By(Et) {
  return Et * dm;
}
function Hy(Et) {
  return (Et & Et - 1) === 0 && Et !== 0;
}
function qy(Et) {
  return Math.pow(2, Math.ceil(Math.log(Et) / Math.LN2));
}
function Gy(Et) {
  return Math.pow(2, Math.floor(Math.log(Et) / Math.LN2));
}
function Vy(Et, t, r, c, w) {
  const R = Math.cos, L = Math.sin, h = R(r / 2), b = L(r / 2), A = R((t + c) / 2), l = L((t + c) / 2), o = R((t - c) / 2), u = L((t - c) / 2), g = R((c - t) / 2), m = L((c - t) / 2);
  switch (w) {
    case "XYX":
      Et.set(h * l, b * o, b * u, h * A);
      break;
    case "YZY":
      Et.set(b * u, h * l, b * o, h * A);
      break;
    case "ZXZ":
      Et.set(b * o, b * u, h * l, h * A);
      break;
    case "XZX":
      Et.set(h * l, b * m, b * g, h * A);
      break;
    case "YXY":
      Et.set(b * g, h * l, b * m, h * A);
      break;
    case "ZYZ":
      Et.set(b * m, b * g, h * l, h * A);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + w);
  }
}
function qs(Et, t) {
  switch (t.constructor) {
    case Float32Array:
      return Et;
    case Uint32Array:
      return Et / 4294967295;
    case Uint16Array:
      return Et / 65535;
    case Uint8Array:
      return Et / 255;
    case Int32Array:
      return Math.max(Et / 2147483647, -1);
    case Int16Array:
      return Math.max(Et / 32767, -1);
    case Int8Array:
      return Math.max(Et / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function ur(Et, t) {
  switch (t.constructor) {
    case Float32Array:
      return Et;
    case Uint32Array:
      return Math.round(Et * 4294967295);
    case Uint16Array:
      return Math.round(Et * 65535);
    case Uint8Array:
      return Math.round(Et * 255);
    case Int32Array:
      return Math.round(Et * 2147483647);
    case Int16Array:
      return Math.round(Et * 32767);
    case Int8Array:
      return Math.round(Et * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const dv = {
  DEG2RAD: um,
  RAD2DEG: dm,
  generateUUID: Js,
  clamp: fi,
  euclideanModulo: ad,
  mapLinear: Iy,
  inverseLerp: Ry,
  lerp: wo,
  damp: Cy,
  pingpong: Ny,
  smoothstep: Py,
  smootherstep: zy,
  randInt: Oy,
  randFloat: Yy,
  randFloatSpread: Fy,
  seededRandom: Uy,
  degToRad: jy,
  radToDeg: By,
  isPowerOfTwo: Hy,
  ceilPowerOfTwo: qy,
  floorPowerOfTwo: Gy,
  setQuaternionFromProperEuler: Vy,
  normalize: ur,
  denormalize: qs
};
class jr {
  constructor(t = 0, r = 0) {
    jr.prototype.isVector2 = !0, this.x = t, this.y = r;
  }
  get width() {
    return this.x;
  }
  set width(t) {
    this.x = t;
  }
  get height() {
    return this.y;
  }
  set height(t) {
    this.y = t;
  }
  set(t, r) {
    return this.x = t, this.y = r, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setComponent(t, r) {
    switch (t) {
      case 0:
        this.x = r;
        break;
      case 1:
        this.y = r;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this;
  }
  addVectors(t, r) {
    return this.x = t.x + r.x, this.y = t.y + r.y, this;
  }
  addScaledVector(t, r) {
    return this.x += t.x * r, this.y += t.y * r, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this;
  }
  subVectors(t, r) {
    return this.x = t.x - r.x, this.y = t.y - r.y, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  applyMatrix3(t) {
    const r = this.x, c = this.y, w = t.elements;
    return this.x = w[0] * r + w[3] * c + w[6], this.y = w[1] * r + w[4] * c + w[7], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this;
  }
  clamp(t, r) {
    return this.x = fi(this.x, t.x, r.x), this.y = fi(this.y, t.y, r.y), this;
  }
  clampScalar(t, r) {
    return this.x = fi(this.x, t, r), this.y = fi(this.y, t, r), this;
  }
  clampLength(t, r) {
    const c = this.length();
    return this.divideScalar(c || 1).multiplyScalar(fi(c, t, r));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y;
  }
  cross(t) {
    return this.x * t.y - this.y * t.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(t) {
    const r = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (r === 0) return Math.PI / 2;
    const c = this.dot(t) / r;
    return Math.acos(fi(c, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const r = this.x - t.x, c = this.y - t.y;
    return r * r + c * c;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, r) {
    return this.x += (t.x - this.x) * r, this.y += (t.y - this.y) * r, this;
  }
  lerpVectors(t, r, c) {
    return this.x = t.x + (r.x - t.x) * c, this.y = t.y + (r.y - t.y) * c, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y;
  }
  fromArray(t, r = 0) {
    return this.x = t[r], this.y = t[r + 1], this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this.x, t[r + 1] = this.y, t;
  }
  fromBufferAttribute(t, r) {
    return this.x = t.getX(r), this.y = t.getY(r), this;
  }
  rotateAround(t, r) {
    const c = Math.cos(r), w = Math.sin(r), R = this.x - t.x, L = this.y - t.y;
    return this.x = R * c - L * w + t.x, this.y = R * w + L * c + t.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class as {
  constructor(t, r, c, w, R, L, h, b, A) {
    as.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, r, c, w, R, L, h, b, A);
  }
  set(t, r, c, w, R, L, h, b, A) {
    const l = this.elements;
    return l[0] = t, l[1] = w, l[2] = h, l[3] = r, l[4] = R, l[5] = b, l[6] = c, l[7] = L, l[8] = A, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  copy(t) {
    const r = this.elements, c = t.elements;
    return r[0] = c[0], r[1] = c[1], r[2] = c[2], r[3] = c[3], r[4] = c[4], r[5] = c[5], r[6] = c[6], r[7] = c[7], r[8] = c[8], this;
  }
  extractBasis(t, r, c) {
    return t.setFromMatrix3Column(this, 0), r.setFromMatrix3Column(this, 1), c.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(t) {
    const r = t.elements;
    return this.set(
      r[0],
      r[4],
      r[8],
      r[1],
      r[5],
      r[9],
      r[2],
      r[6],
      r[10]
    ), this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, r) {
    const c = t.elements, w = r.elements, R = this.elements, L = c[0], h = c[3], b = c[6], A = c[1], l = c[4], o = c[7], u = c[2], g = c[5], m = c[8], S = w[0], e = w[3], n = w[6], d = w[1], _ = w[4], p = w[7], P = w[2], $ = w[5], ot = w[8];
    return R[0] = L * S + h * d + b * P, R[3] = L * e + h * _ + b * $, R[6] = L * n + h * p + b * ot, R[1] = A * S + l * d + o * P, R[4] = A * e + l * _ + o * $, R[7] = A * n + l * p + o * ot, R[2] = u * S + g * d + m * P, R[5] = u * e + g * _ + m * $, R[8] = u * n + g * p + m * ot, this;
  }
  multiplyScalar(t) {
    const r = this.elements;
    return r[0] *= t, r[3] *= t, r[6] *= t, r[1] *= t, r[4] *= t, r[7] *= t, r[2] *= t, r[5] *= t, r[8] *= t, this;
  }
  determinant() {
    const t = this.elements, r = t[0], c = t[1], w = t[2], R = t[3], L = t[4], h = t[5], b = t[6], A = t[7], l = t[8];
    return r * L * l - r * h * A - c * R * l + c * h * b + w * R * A - w * L * b;
  }
  invert() {
    const t = this.elements, r = t[0], c = t[1], w = t[2], R = t[3], L = t[4], h = t[5], b = t[6], A = t[7], l = t[8], o = l * L - h * A, u = h * b - l * R, g = A * R - L * b, m = r * o + c * u + w * g;
    if (m === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / m;
    return t[0] = o * S, t[1] = (w * A - l * c) * S, t[2] = (h * c - w * L) * S, t[3] = u * S, t[4] = (l * r - w * b) * S, t[5] = (w * R - h * r) * S, t[6] = g * S, t[7] = (c * b - A * r) * S, t[8] = (L * r - c * R) * S, this;
  }
  transpose() {
    let t;
    const r = this.elements;
    return t = r[1], r[1] = r[3], r[3] = t, t = r[2], r[2] = r[6], r[6] = t, t = r[5], r[5] = r[7], r[7] = t, this;
  }
  getNormalMatrix(t) {
    return this.setFromMatrix4(t).invert().transpose();
  }
  transposeIntoArray(t) {
    const r = this.elements;
    return t[0] = r[0], t[1] = r[3], t[2] = r[6], t[3] = r[1], t[4] = r[4], t[5] = r[7], t[6] = r[2], t[7] = r[5], t[8] = r[8], this;
  }
  setUvTransform(t, r, c, w, R, L, h) {
    const b = Math.cos(R), A = Math.sin(R);
    return this.set(
      c * b,
      c * A,
      -c * (b * L + A * h) + L + t,
      -w * A,
      w * b,
      -w * (-A * L + b * h) + h + r,
      0,
      0,
      1
    ), this;
  }
  //
  scale(t, r) {
    return this.premultiply(cu.makeScale(t, r)), this;
  }
  rotate(t) {
    return this.premultiply(cu.makeRotation(-t)), this;
  }
  translate(t, r) {
    return this.premultiply(cu.makeTranslation(t, r)), this;
  }
  // for 2D Transforms
  makeTranslation(t, r) {
    return t.isVector2 ? this.set(
      1,
      0,
      t.x,
      0,
      1,
      t.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      t,
      0,
      1,
      r,
      0,
      0,
      1
    ), this;
  }
  makeRotation(t) {
    const r = Math.cos(t), c = Math.sin(t);
    return this.set(
      r,
      -c,
      0,
      c,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, r) {
    return this.set(
      t,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      1
    ), this;
  }
  //
  equals(t) {
    const r = this.elements, c = t.elements;
    for (let w = 0; w < 9; w++)
      if (r[w] !== c[w]) return !1;
    return !0;
  }
  fromArray(t, r = 0) {
    for (let c = 0; c < 9; c++)
      this.elements[c] = t[c + r];
    return this;
  }
  toArray(t = [], r = 0) {
    const c = this.elements;
    return t[r] = c[0], t[r + 1] = c[1], t[r + 2] = c[2], t[r + 3] = c[3], t[r + 4] = c[4], t[r + 5] = c[5], t[r + 6] = c[6], t[r + 7] = c[7], t[r + 8] = c[8], t;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const cu = /* @__PURE__ */ new as();
function Wy(Et) {
  for (let t = Et.length - 1; t >= 0; --t)
    if (Et[t] >= 65535) return !0;
  return !1;
}
function Qu(Et) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", Et);
}
const gh = /* @__PURE__ */ new as().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), _h = /* @__PURE__ */ new as().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function Ky() {
  const Et = {
    enabled: !0,
    workingColorSpace: Nl,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(w, R, L) {
      return this.enabled === !1 || R === L || !R || !L || (this.spaces[R].transfer === du && (w.r = Oa(w.r), w.g = Oa(w.g), w.b = Oa(w.b)), this.spaces[R].primaries !== this.spaces[L].primaries && (w.applyMatrix3(this.spaces[R].toXYZ), w.applyMatrix3(this.spaces[L].fromXYZ)), this.spaces[L].transfer === du && (w.r = Xs(w.r), w.g = Xs(w.g), w.b = Xs(w.b))), w;
    },
    fromWorkingColorSpace: function(w, R) {
      return this.convert(w, this.workingColorSpace, R);
    },
    toWorkingColorSpace: function(w, R) {
      return this.convert(w, R, this.workingColorSpace);
    },
    getPrimaries: function(w) {
      return this.spaces[w].primaries;
    },
    getTransfer: function(w) {
      return w === lm ? ch : this.spaces[w].transfer;
    },
    getLuminanceCoefficients: function(w, R = this.workingColorSpace) {
      return w.fromArray(this.spaces[R].luminanceCoefficients);
    },
    define: function(w) {
      Object.assign(this.spaces, w);
    },
    // Internal APIs
    _getMatrix: function(w, R, L) {
      return w.copy(this.spaces[R].toXYZ).multiply(this.spaces[L].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(w) {
      return this.spaces[w].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(w = this.workingColorSpace) {
      return this.spaces[w].workingColorSpaceConfig.unpackColorSpace;
    }
  }, t = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], r = [0.2126, 0.7152, 0.0722], c = [0.3127, 0.329];
  return Et.define({
    [Nl]: {
      primaries: t,
      whitePoint: c,
      transfer: ch,
      toXYZ: gh,
      fromXYZ: _h,
      luminanceCoefficients: r,
      workingColorSpaceConfig: { unpackColorSpace: kr },
      outputColorSpaceConfig: { drawingBufferColorSpace: kr }
    },
    [kr]: {
      primaries: t,
      whitePoint: c,
      transfer: du,
      toXYZ: gh,
      fromXYZ: _h,
      luminanceCoefficients: r,
      outputColorSpaceConfig: { drawingBufferColorSpace: kr }
    }
  }), Et;
}
const Jr = /* @__PURE__ */ Ky();
function Oa(Et) {
  return Et < 0.04045 ? Et * 0.0773993808 : Math.pow(Et * 0.9478672986 + 0.0521327014, 2.4);
}
function Xs(Et) {
  return Et < 31308e-7 ? Et * 12.92 : 1.055 * Math.pow(Et, 0.41666) - 0.055;
}
let Ns;
class $y {
  static getDataURL(t) {
    if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u")
      return t.src;
    let r;
    if (t instanceof HTMLCanvasElement)
      r = t;
    else {
      Ns === void 0 && (Ns = Qu("canvas")), Ns.width = t.width, Ns.height = t.height;
      const c = Ns.getContext("2d");
      t instanceof ImageData ? c.putImageData(t, 0, 0) : c.drawImage(t, 0, 0, t.width, t.height), r = Ns;
    }
    return r.toDataURL("image/png");
  }
  static sRGBToLinear(t) {
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) {
      const r = Qu("canvas");
      r.width = t.width, r.height = t.height;
      const c = r.getContext("2d");
      c.drawImage(t, 0, 0, t.width, t.height);
      const w = c.getImageData(0, 0, t.width, t.height), R = w.data;
      for (let L = 0; L < R.length; L++)
        R[L] = Oa(R[L] / 255) * 255;
      return c.putImageData(w, 0, 0), r;
    } else if (t.data) {
      const r = t.data.slice(0);
      for (let c = 0; c < r.length; c++)
        r instanceof Uint8Array || r instanceof Uint8ClampedArray ? r[c] = Math.floor(Oa(r[c] / 255) * 255) : r[c] = Oa(r[c]);
      return {
        data: r,
        width: t.width,
        height: t.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t;
  }
}
let Xy = 0;
class Qy {
  constructor(t = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: Xy++ }), this.uuid = Js(), this.data = t, this.dataReady = !0, this.version = 0;
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  toJSON(t) {
    const r = t === void 0 || typeof t == "string";
    if (!r && t.images[this.uuid] !== void 0)
      return t.images[this.uuid];
    const c = {
      uuid: this.uuid,
      url: ""
    }, w = this.data;
    if (w !== null) {
      let R;
      if (Array.isArray(w)) {
        R = [];
        for (let L = 0, h = w.length; L < h; L++)
          w[L].isDataTexture ? R.push(hu(w[L].image)) : R.push(hu(w[L]));
      } else
        R = hu(w);
      c.url = R;
    }
    return r || (t.images[this.uuid] = c), c;
  }
}
function hu(Et) {
  return typeof HTMLImageElement < "u" && Et instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && Et instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && Et instanceof ImageBitmap ? $y.getDataURL(Et) : Et.data ? {
    data: Array.from(Et.data),
    width: Et.width,
    height: Et.height,
    type: Et.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Jy = 0;
class Ya extends Yl {
  constructor(t = Ya.DEFAULT_IMAGE, r = Ya.DEFAULT_MAPPING, c = il, w = il, R = Ay, L = Sy, h = xy, b = My, A = Ya.DEFAULT_ANISOTROPY, l = lm) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: Jy++ }), this.uuid = Js(), this.name = "", this.source = new Qy(t), this.mipmaps = [], this.mapping = r, this.channel = 0, this.wrapS = c, this.wrapT = w, this.magFilter = R, this.minFilter = L, this.anisotropy = A, this.format = h, this.internalFormat = null, this.type = b, this.offset = new jr(0, 0), this.repeat = new jr(1, 1), this.center = new jr(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new as(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = l, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0;
  }
  get image() {
    return this.source.data;
  }
  set image(t = null) {
    this.source.data = t;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.channel = t.channel, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.colorSpace = t.colorSpace, this.renderTarget = t.renderTarget, this.isRenderTargetTexture = t.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this;
  }
  toJSON(t) {
    const r = t === void 0 || typeof t == "string";
    if (!r && t.textures[this.uuid] !== void 0)
      return t.textures[this.uuid];
    const c = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(t).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (c.userData = this.userData), r || (t.textures[this.uuid] = c), c;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(t) {
    if (this.mapping !== om) return t;
    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1)
      switch (this.wrapS) {
        case uh:
          t.x = t.x - Math.floor(t.x);
          break;
        case il:
          t.x = t.x < 0 ? 0 : 1;
          break;
        case dh:
          Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x);
          break;
      }
    if (t.y < 0 || t.y > 1)
      switch (this.wrapT) {
        case uh:
          t.y = t.y - Math.floor(t.y);
          break;
        case il:
          t.y = t.y < 0 ? 0 : 1;
          break;
        case dh:
          Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y);
          break;
      }
    return this.flipY && (t.y = 1 - t.y), t;
  }
  set needsUpdate(t) {
    t === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  set needsPMREMUpdate(t) {
    t === !0 && this.pmremVersion++;
  }
}
Ya.DEFAULT_IMAGE = null;
Ya.DEFAULT_MAPPING = om;
Ya.DEFAULT_ANISOTROPY = 1;
class ko {
  constructor(t = 0, r = 0, c = 0, w = 1) {
    ko.prototype.isVector4 = !0, this.x = t, this.y = r, this.z = c, this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(t) {
    this.z = t;
  }
  get height() {
    return this.w;
  }
  set height(t) {
    this.w = t;
  }
  set(t, r, c, w) {
    return this.x = t, this.y = r, this.z = c, this.w = w, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this.w = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setW(t) {
    return this.w = t, this;
  }
  setComponent(t, r) {
    switch (t) {
      case 0:
        this.x = r;
        break;
      case 1:
        this.y = r;
        break;
      case 2:
        this.z = r;
        break;
      case 3:
        this.w = r;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this.w += t, this;
  }
  addVectors(t, r) {
    return this.x = t.x + r.x, this.y = t.y + r.y, this.z = t.z + r.z, this.w = t.w + r.w, this;
  }
  addScaledVector(t, r) {
    return this.x += t.x * r, this.y += t.y * r, this.z += t.z * r, this.w += t.w * r, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this;
  }
  subVectors(t, r) {
    return this.x = t.x - r.x, this.y = t.y - r.y, this.z = t.z - r.z, this.w = t.w - r.w, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  applyMatrix4(t) {
    const r = this.x, c = this.y, w = this.z, R = this.w, L = t.elements;
    return this.x = L[0] * r + L[4] * c + L[8] * w + L[12] * R, this.y = L[1] * r + L[5] * c + L[9] * w + L[13] * R, this.z = L[2] * r + L[6] * c + L[10] * w + L[14] * R, this.w = L[3] * r + L[7] * c + L[11] * w + L[15] * R, this;
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this.w /= t.w, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  setAxisAngleFromQuaternion(t) {
    this.w = 2 * Math.acos(t.w);
    const r = Math.sqrt(1 - t.w * t.w);
    return r < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / r, this.y = t.y / r, this.z = t.z / r), this;
  }
  setAxisAngleFromRotationMatrix(t) {
    let r, c, w, R;
    const b = t.elements, A = b[0], l = b[4], o = b[8], u = b[1], g = b[5], m = b[9], S = b[2], e = b[6], n = b[10];
    if (Math.abs(l - u) < 0.01 && Math.abs(o - S) < 0.01 && Math.abs(m - e) < 0.01) {
      if (Math.abs(l + u) < 0.1 && Math.abs(o + S) < 0.1 && Math.abs(m + e) < 0.1 && Math.abs(A + g + n - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      r = Math.PI;
      const _ = (A + 1) / 2, p = (g + 1) / 2, P = (n + 1) / 2, $ = (l + u) / 4, ot = (o + S) / 4, dt = (m + e) / 4;
      return _ > p && _ > P ? _ < 0.01 ? (c = 0, w = 0.707106781, R = 0.707106781) : (c = Math.sqrt(_), w = $ / c, R = ot / c) : p > P ? p < 0.01 ? (c = 0.707106781, w = 0, R = 0.707106781) : (w = Math.sqrt(p), c = $ / w, R = dt / w) : P < 0.01 ? (c = 0.707106781, w = 0.707106781, R = 0) : (R = Math.sqrt(P), c = ot / R, w = dt / R), this.set(c, w, R, r), this;
    }
    let d = Math.sqrt((e - m) * (e - m) + (o - S) * (o - S) + (u - l) * (u - l));
    return Math.abs(d) < 1e-3 && (d = 1), this.x = (e - m) / d, this.y = (o - S) / d, this.z = (u - l) / d, this.w = Math.acos((A + g + n - 1) / 2), this;
  }
  setFromMatrixPosition(t) {
    const r = t.elements;
    return this.x = r[12], this.y = r[13], this.z = r[14], this.w = r[15], this;
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this;
  }
  clamp(t, r) {
    return this.x = fi(this.x, t.x, r.x), this.y = fi(this.y, t.y, r.y), this.z = fi(this.z, t.z, r.z), this.w = fi(this.w, t.w, r.w), this;
  }
  clampScalar(t, r) {
    return this.x = fi(this.x, t, r), this.y = fi(this.y, t, r), this.z = fi(this.z, t, r), this.w = fi(this.w, t, r), this;
  }
  clampLength(t, r) {
    const c = this.length();
    return this.divideScalar(c || 1).multiplyScalar(fi(c, t, r));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, r) {
    return this.x += (t.x - this.x) * r, this.y += (t.y - this.y) * r, this.z += (t.z - this.z) * r, this.w += (t.w - this.w) * r, this;
  }
  lerpVectors(t, r, c) {
    return this.x = t.x + (r.x - t.x) * c, this.y = t.y + (r.y - t.y) * c, this.z = t.z + (r.z - t.z) * c, this.w = t.w + (r.w - t.w) * c, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
  }
  fromArray(t, r = 0) {
    return this.x = t[r], this.y = t[r + 1], this.z = t[r + 2], this.w = t[r + 3], this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this.x, t[r + 1] = this.y, t[r + 2] = this.z, t[r + 3] = this.w, t;
  }
  fromBufferAttribute(t, r) {
    return this.x = t.getX(r), this.y = t.getY(r), this.z = t.getZ(r), this.w = t.getW(r), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class xo {
  constructor(t = 0, r = 0, c = 0, w = 1) {
    this.isQuaternion = !0, this._x = t, this._y = r, this._z = c, this._w = w;
  }
  static slerpFlat(t, r, c, w, R, L, h) {
    let b = c[w + 0], A = c[w + 1], l = c[w + 2], o = c[w + 3];
    const u = R[L + 0], g = R[L + 1], m = R[L + 2], S = R[L + 3];
    if (h === 0) {
      t[r + 0] = b, t[r + 1] = A, t[r + 2] = l, t[r + 3] = o;
      return;
    }
    if (h === 1) {
      t[r + 0] = u, t[r + 1] = g, t[r + 2] = m, t[r + 3] = S;
      return;
    }
    if (o !== S || b !== u || A !== g || l !== m) {
      let e = 1 - h;
      const n = b * u + A * g + l * m + o * S, d = n >= 0 ? 1 : -1, _ = 1 - n * n;
      if (_ > Number.EPSILON) {
        const P = Math.sqrt(_), $ = Math.atan2(P, n * d);
        e = Math.sin(e * $) / P, h = Math.sin(h * $) / P;
      }
      const p = h * d;
      if (b = b * e + u * p, A = A * e + g * p, l = l * e + m * p, o = o * e + S * p, e === 1 - h) {
        const P = 1 / Math.sqrt(b * b + A * A + l * l + o * o);
        b *= P, A *= P, l *= P, o *= P;
      }
    }
    t[r] = b, t[r + 1] = A, t[r + 2] = l, t[r + 3] = o;
  }
  static multiplyQuaternionsFlat(t, r, c, w, R, L) {
    const h = c[w], b = c[w + 1], A = c[w + 2], l = c[w + 3], o = R[L], u = R[L + 1], g = R[L + 2], m = R[L + 3];
    return t[r] = h * m + l * o + b * g - A * u, t[r + 1] = b * m + l * u + A * o - h * g, t[r + 2] = A * m + l * g + h * u - b * o, t[r + 3] = l * m - h * o - b * u - A * g, t;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(t) {
    this._w = t, this._onChangeCallback();
  }
  set(t, r, c, w) {
    return this._x = t, this._y = r, this._z = c, this._w = w, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(t) {
    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this;
  }
  setFromEuler(t, r = !0) {
    const c = t._x, w = t._y, R = t._z, L = t._order, h = Math.cos, b = Math.sin, A = h(c / 2), l = h(w / 2), o = h(R / 2), u = b(c / 2), g = b(w / 2), m = b(R / 2);
    switch (L) {
      case "XYZ":
        this._x = u * l * o + A * g * m, this._y = A * g * o - u * l * m, this._z = A * l * m + u * g * o, this._w = A * l * o - u * g * m;
        break;
      case "YXZ":
        this._x = u * l * o + A * g * m, this._y = A * g * o - u * l * m, this._z = A * l * m - u * g * o, this._w = A * l * o + u * g * m;
        break;
      case "ZXY":
        this._x = u * l * o - A * g * m, this._y = A * g * o + u * l * m, this._z = A * l * m + u * g * o, this._w = A * l * o - u * g * m;
        break;
      case "ZYX":
        this._x = u * l * o - A * g * m, this._y = A * g * o + u * l * m, this._z = A * l * m - u * g * o, this._w = A * l * o + u * g * m;
        break;
      case "YZX":
        this._x = u * l * o + A * g * m, this._y = A * g * o + u * l * m, this._z = A * l * m - u * g * o, this._w = A * l * o - u * g * m;
        break;
      case "XZY":
        this._x = u * l * o - A * g * m, this._y = A * g * o - u * l * m, this._z = A * l * m + u * g * o, this._w = A * l * o + u * g * m;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + L);
    }
    return r === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(t, r) {
    const c = r / 2, w = Math.sin(c);
    return this._x = t.x * w, this._y = t.y * w, this._z = t.z * w, this._w = Math.cos(c), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t) {
    const r = t.elements, c = r[0], w = r[4], R = r[8], L = r[1], h = r[5], b = r[9], A = r[2], l = r[6], o = r[10], u = c + h + o;
    if (u > 0) {
      const g = 0.5 / Math.sqrt(u + 1);
      this._w = 0.25 / g, this._x = (l - b) * g, this._y = (R - A) * g, this._z = (L - w) * g;
    } else if (c > h && c > o) {
      const g = 2 * Math.sqrt(1 + c - h - o);
      this._w = (l - b) / g, this._x = 0.25 * g, this._y = (w + L) / g, this._z = (R + A) / g;
    } else if (h > o) {
      const g = 2 * Math.sqrt(1 + h - c - o);
      this._w = (R - A) / g, this._x = (w + L) / g, this._y = 0.25 * g, this._z = (b + l) / g;
    } else {
      const g = 2 * Math.sqrt(1 + o - c - h);
      this._w = (L - w) / g, this._x = (R + A) / g, this._y = (b + l) / g, this._z = 0.25 * g;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(t, r) {
    let c = t.dot(r) + 1;
    return c < Number.EPSILON ? (c = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = c) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = c)) : (this._x = t.y * r.z - t.z * r.y, this._y = t.z * r.x - t.x * r.z, this._z = t.x * r.y - t.y * r.x, this._w = c), this.normalize();
  }
  angleTo(t) {
    return 2 * Math.acos(Math.abs(fi(this.dot(t), -1, 1)));
  }
  rotateTowards(t, r) {
    const c = this.angleTo(t);
    if (c === 0) return this;
    const w = Math.min(1, r / c);
    return this.slerp(t, w), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(t) {
    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let t = this.length();
    return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this;
  }
  multiply(t) {
    return this.multiplyQuaternions(this, t);
  }
  premultiply(t) {
    return this.multiplyQuaternions(t, this);
  }
  multiplyQuaternions(t, r) {
    const c = t._x, w = t._y, R = t._z, L = t._w, h = r._x, b = r._y, A = r._z, l = r._w;
    return this._x = c * l + L * h + w * A - R * b, this._y = w * l + L * b + R * h - c * A, this._z = R * l + L * A + c * b - w * h, this._w = L * l - c * h - w * b - R * A, this._onChangeCallback(), this;
  }
  slerp(t, r) {
    if (r === 0) return this;
    if (r === 1) return this.copy(t);
    const c = this._x, w = this._y, R = this._z, L = this._w;
    let h = L * t._w + c * t._x + w * t._y + R * t._z;
    if (h < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, h = -h) : this.copy(t), h >= 1)
      return this._w = L, this._x = c, this._y = w, this._z = R, this;
    const b = 1 - h * h;
    if (b <= Number.EPSILON) {
      const g = 1 - r;
      return this._w = g * L + r * this._w, this._x = g * c + r * this._x, this._y = g * w + r * this._y, this._z = g * R + r * this._z, this.normalize(), this;
    }
    const A = Math.sqrt(b), l = Math.atan2(A, h), o = Math.sin((1 - r) * l) / A, u = Math.sin(r * l) / A;
    return this._w = L * o + this._w * u, this._x = c * o + this._x * u, this._y = w * o + this._y * u, this._z = R * o + this._z * u, this._onChangeCallback(), this;
  }
  slerpQuaternions(t, r, c) {
    return this.copy(t).slerp(r, c);
  }
  random() {
    const t = 2 * Math.PI * Math.random(), r = 2 * Math.PI * Math.random(), c = Math.random(), w = Math.sqrt(1 - c), R = Math.sqrt(c);
    return this.set(
      w * Math.sin(t),
      w * Math.cos(t),
      R * Math.sin(r),
      R * Math.cos(r)
    );
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w;
  }
  fromArray(t, r = 0) {
    return this._x = t[r], this._y = t[r + 1], this._z = t[r + 2], this._w = t[r + 3], this._onChangeCallback(), this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this._x, t[r + 1] = this._y, t[r + 2] = this._z, t[r + 3] = this._w, t;
  }
  fromBufferAttribute(t, r) {
    return this._x = t.getX(r), this._y = t.getY(r), this._z = t.getZ(r), this._w = t.getW(r), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class un {
  constructor(t = 0, r = 0, c = 0) {
    un.prototype.isVector3 = !0, this.x = t, this.y = r, this.z = c;
  }
  set(t, r, c) {
    return c === void 0 && (c = this.z), this.x = t, this.y = r, this.z = c, this;
  }
  setScalar(t) {
    return this.x = t, this.y = t, this.z = t, this;
  }
  setX(t) {
    return this.x = t, this;
  }
  setY(t) {
    return this.y = t, this;
  }
  setZ(t) {
    return this.z = t, this;
  }
  setComponent(t, r) {
    switch (t) {
      case 0:
        this.x = r;
        break;
      case 1:
        this.y = r;
        break;
      case 2:
        this.z = r;
        break;
      default:
        throw new Error("index is out of range: " + t);
    }
    return this;
  }
  getComponent(t) {
    switch (t) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + t);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  addScalar(t) {
    return this.x += t, this.y += t, this.z += t, this;
  }
  addVectors(t, r) {
    return this.x = t.x + r.x, this.y = t.y + r.y, this.z = t.z + r.z, this;
  }
  addScaledVector(t, r) {
    return this.x += t.x * r, this.y += t.y * r, this.z += t.z * r, this;
  }
  sub(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  subScalar(t) {
    return this.x -= t, this.y -= t, this.z -= t, this;
  }
  subVectors(t, r) {
    return this.x = t.x - r.x, this.y = t.y - r.y, this.z = t.z - r.z, this;
  }
  multiply(t) {
    return this.x *= t.x, this.y *= t.y, this.z *= t.z, this;
  }
  multiplyScalar(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  multiplyVectors(t, r) {
    return this.x = t.x * r.x, this.y = t.y * r.y, this.z = t.z * r.z, this;
  }
  applyEuler(t) {
    return this.applyQuaternion(yh.setFromEuler(t));
  }
  applyAxisAngle(t, r) {
    return this.applyQuaternion(yh.setFromAxisAngle(t, r));
  }
  applyMatrix3(t) {
    const r = this.x, c = this.y, w = this.z, R = t.elements;
    return this.x = R[0] * r + R[3] * c + R[6] * w, this.y = R[1] * r + R[4] * c + R[7] * w, this.z = R[2] * r + R[5] * c + R[8] * w, this;
  }
  applyNormalMatrix(t) {
    return this.applyMatrix3(t).normalize();
  }
  applyMatrix4(t) {
    const r = this.x, c = this.y, w = this.z, R = t.elements, L = 1 / (R[3] * r + R[7] * c + R[11] * w + R[15]);
    return this.x = (R[0] * r + R[4] * c + R[8] * w + R[12]) * L, this.y = (R[1] * r + R[5] * c + R[9] * w + R[13]) * L, this.z = (R[2] * r + R[6] * c + R[10] * w + R[14]) * L, this;
  }
  applyQuaternion(t) {
    const r = this.x, c = this.y, w = this.z, R = t.x, L = t.y, h = t.z, b = t.w, A = 2 * (L * w - h * c), l = 2 * (h * r - R * w), o = 2 * (R * c - L * r);
    return this.x = r + b * A + L * o - h * l, this.y = c + b * l + h * A - R * o, this.z = w + b * o + R * l - L * A, this;
  }
  project(t) {
    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
  }
  unproject(t) {
    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld);
  }
  transformDirection(t) {
    const r = this.x, c = this.y, w = this.z, R = t.elements;
    return this.x = R[0] * r + R[4] * c + R[8] * w, this.y = R[1] * r + R[5] * c + R[9] * w, this.z = R[2] * r + R[6] * c + R[10] * w, this.normalize();
  }
  divide(t) {
    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this;
  }
  divideScalar(t) {
    return this.multiplyScalar(1 / t);
  }
  min(t) {
    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this;
  }
  max(t) {
    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this;
  }
  clamp(t, r) {
    return this.x = fi(this.x, t.x, r.x), this.y = fi(this.y, t.y, r.y), this.z = fi(this.z, t.z, r.z), this;
  }
  clampScalar(t, r) {
    return this.x = fi(this.x, t, r), this.y = fi(this.y, t, r), this.z = fi(this.z, t, r), this;
  }
  clampLength(t, r) {
    const c = this.length();
    return this.divideScalar(c || 1).multiplyScalar(fi(c, t, r));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(t) {
    return this.x * t.x + this.y * t.y + this.z * t.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(t) {
    return this.normalize().multiplyScalar(t);
  }
  lerp(t, r) {
    return this.x += (t.x - this.x) * r, this.y += (t.y - this.y) * r, this.z += (t.z - this.z) * r, this;
  }
  lerpVectors(t, r, c) {
    return this.x = t.x + (r.x - t.x) * c, this.y = t.y + (r.y - t.y) * c, this.z = t.z + (r.z - t.z) * c, this;
  }
  cross(t) {
    return this.crossVectors(this, t);
  }
  crossVectors(t, r) {
    const c = t.x, w = t.y, R = t.z, L = r.x, h = r.y, b = r.z;
    return this.x = w * b - R * h, this.y = R * L - c * b, this.z = c * h - w * L, this;
  }
  projectOnVector(t) {
    const r = t.lengthSq();
    if (r === 0) return this.set(0, 0, 0);
    const c = t.dot(this) / r;
    return this.copy(t).multiplyScalar(c);
  }
  projectOnPlane(t) {
    return fu.copy(this).projectOnVector(t), this.sub(fu);
  }
  reflect(t) {
    return this.sub(fu.copy(t).multiplyScalar(2 * this.dot(t)));
  }
  angleTo(t) {
    const r = Math.sqrt(this.lengthSq() * t.lengthSq());
    if (r === 0) return Math.PI / 2;
    const c = this.dot(t) / r;
    return Math.acos(fi(c, -1, 1));
  }
  distanceTo(t) {
    return Math.sqrt(this.distanceToSquared(t));
  }
  distanceToSquared(t) {
    const r = this.x - t.x, c = this.y - t.y, w = this.z - t.z;
    return r * r + c * c + w * w;
  }
  manhattanDistanceTo(t) {
    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
  }
  setFromSpherical(t) {
    return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
  }
  setFromSphericalCoords(t, r, c) {
    const w = Math.sin(r) * t;
    return this.x = w * Math.sin(c), this.y = Math.cos(r) * t, this.z = w * Math.cos(c), this;
  }
  setFromCylindrical(t) {
    return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
  }
  setFromCylindricalCoords(t, r, c) {
    return this.x = t * Math.sin(r), this.y = c, this.z = t * Math.cos(r), this;
  }
  setFromMatrixPosition(t) {
    const r = t.elements;
    return this.x = r[12], this.y = r[13], this.z = r[14], this;
  }
  setFromMatrixScale(t) {
    const r = this.setFromMatrixColumn(t, 0).length(), c = this.setFromMatrixColumn(t, 1).length(), w = this.setFromMatrixColumn(t, 2).length();
    return this.x = r, this.y = c, this.z = w, this;
  }
  setFromMatrixColumn(t, r) {
    return this.fromArray(t.elements, r * 4);
  }
  setFromMatrix3Column(t, r) {
    return this.fromArray(t.elements, r * 3);
  }
  setFromEuler(t) {
    return this.x = t._x, this.y = t._y, this.z = t._z, this;
  }
  setFromColor(t) {
    return this.x = t.r, this.y = t.g, this.z = t.b, this;
  }
  equals(t) {
    return t.x === this.x && t.y === this.y && t.z === this.z;
  }
  fromArray(t, r = 0) {
    return this.x = t[r], this.y = t[r + 1], this.z = t[r + 2], this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this.x, t[r + 1] = this.y, t[r + 2] = this.z, t;
  }
  fromBufferAttribute(t, r) {
    return this.x = t.getX(r), this.y = t.getY(r), this.z = t.getZ(r), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const t = Math.random() * Math.PI * 2, r = Math.random() * 2 - 1, c = Math.sqrt(1 - r * r);
    return this.x = c * Math.cos(t), this.y = r, this.z = c * Math.sin(t), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const fu = /* @__PURE__ */ new un(), yh = /* @__PURE__ */ new xo();
class Lo {
  constructor(t = new un(1 / 0, 1 / 0, 1 / 0), r = new un(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = t, this.max = r;
  }
  set(t, r) {
    return this.min.copy(t), this.max.copy(r), this;
  }
  setFromArray(t) {
    this.makeEmpty();
    for (let r = 0, c = t.length; r < c; r += 3)
      this.expandByPoint(Zr.fromArray(t, r));
    return this;
  }
  setFromBufferAttribute(t) {
    this.makeEmpty();
    for (let r = 0, c = t.count; r < c; r++)
      this.expandByPoint(Zr.fromBufferAttribute(t, r));
    return this;
  }
  setFromPoints(t) {
    this.makeEmpty();
    for (let r = 0, c = t.length; r < c; r++)
      this.expandByPoint(t[r]);
    return this;
  }
  setFromCenterAndSize(t, r) {
    const c = Zr.copy(r).multiplyScalar(0.5);
    return this.min.copy(t).sub(c), this.max.copy(t).add(c), this;
  }
  setFromObject(t, r = !1) {
    return this.makeEmpty(), this.expandByObject(t, r);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.min.copy(t.min), this.max.copy(t.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(t) {
    return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min);
  }
  expandByPoint(t) {
    return this.min.min(t), this.max.max(t), this;
  }
  expandByVector(t) {
    return this.min.sub(t), this.max.add(t), this;
  }
  expandByScalar(t) {
    return this.min.addScalar(-t), this.max.addScalar(t), this;
  }
  expandByObject(t, r = !1) {
    t.updateWorldMatrix(!1, !1);
    const c = t.geometry;
    if (c !== void 0) {
      const R = c.getAttribute("position");
      if (r === !0 && R !== void 0 && t.isInstancedMesh !== !0)
        for (let L = 0, h = R.count; L < h; L++)
          t.isMesh === !0 ? t.getVertexPosition(L, Zr) : Zr.fromBufferAttribute(R, L), Zr.applyMatrix4(t.matrixWorld), this.expandByPoint(Zr);
      else
        t.boundingBox !== void 0 ? (t.boundingBox === null && t.computeBoundingBox(), al.copy(t.boundingBox)) : (c.boundingBox === null && c.computeBoundingBox(), al.copy(c.boundingBox)), al.applyMatrix4(t.matrixWorld), this.union(al);
    }
    const w = t.children;
    for (let R = 0, L = w.length; R < L; R++)
      this.expandByObject(w[R], r);
    return this;
  }
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
  }
  containsBox(t) {
    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z;
  }
  getParameter(t, r) {
    return r.set(
      (t.x - this.min.x) / (this.max.x - this.min.x),
      (t.y - this.min.y) / (this.max.y - this.min.y),
      (t.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(t) {
    return t.max.x >= this.min.x && t.min.x <= this.max.x && t.max.y >= this.min.y && t.min.y <= this.max.y && t.max.z >= this.min.z && t.min.z <= this.max.z;
  }
  intersectsSphere(t) {
    return this.clampPoint(t.center, Zr), Zr.distanceToSquared(t.center) <= t.radius * t.radius;
  }
  intersectsPlane(t) {
    let r, c;
    return t.normal.x > 0 ? (r = t.normal.x * this.min.x, c = t.normal.x * this.max.x) : (r = t.normal.x * this.max.x, c = t.normal.x * this.min.x), t.normal.y > 0 ? (r += t.normal.y * this.min.y, c += t.normal.y * this.max.y) : (r += t.normal.y * this.max.y, c += t.normal.y * this.min.y), t.normal.z > 0 ? (r += t.normal.z * this.min.z, c += t.normal.z * this.max.z) : (r += t.normal.z * this.max.z, c += t.normal.z * this.min.z), r <= -t.constant && c >= -t.constant;
  }
  intersectsTriangle(t) {
    if (this.isEmpty())
      return !1;
    this.getCenter(mo), sl.subVectors(this.max, mo), Ps.subVectors(t.a, mo), zs.subVectors(t.b, mo), Os.subVectors(t.c, mo), Qa.subVectors(zs, Ps), Ja.subVectors(Os, zs), fs.subVectors(Ps, Os);
    let r = [
      0,
      -Qa.z,
      Qa.y,
      0,
      -Ja.z,
      Ja.y,
      0,
      -fs.z,
      fs.y,
      Qa.z,
      0,
      -Qa.x,
      Ja.z,
      0,
      -Ja.x,
      fs.z,
      0,
      -fs.x,
      -Qa.y,
      Qa.x,
      0,
      -Ja.y,
      Ja.x,
      0,
      -fs.y,
      fs.x,
      0
    ];
    return !mu(r, Ps, zs, Os, sl) || (r = [1, 0, 0, 0, 1, 0, 0, 0, 1], !mu(r, Ps, zs, Os, sl)) ? !1 : (ol.crossVectors(Qa, Ja), r = [ol.x, ol.y, ol.z], mu(r, Ps, zs, Os, sl));
  }
  clampPoint(t, r) {
    return r.copy(t).clamp(this.min, this.max);
  }
  distanceToPoint(t) {
    return this.clampPoint(t, Zr).distanceTo(t);
  }
  getBoundingSphere(t) {
    return this.isEmpty() ? t.makeEmpty() : (this.getCenter(t.center), t.radius = this.getSize(Zr).length() * 0.5), t;
  }
  intersect(t) {
    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(t) {
    return this.min.min(t.min), this.max.max(t.max), this;
  }
  applyMatrix4(t) {
    return this.isEmpty() ? this : (La[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), La[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), La[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), La[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), La[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), La[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), La[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), La[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(La), this);
  }
  translate(t) {
    return this.min.add(t), this.max.add(t), this;
  }
  equals(t) {
    return t.min.equals(this.min) && t.max.equals(this.max);
  }
}
const La = [
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un(),
  /* @__PURE__ */ new un()
], Zr = /* @__PURE__ */ new un(), al = /* @__PURE__ */ new Lo(), Ps = /* @__PURE__ */ new un(), zs = /* @__PURE__ */ new un(), Os = /* @__PURE__ */ new un(), Qa = /* @__PURE__ */ new un(), Ja = /* @__PURE__ */ new un(), fs = /* @__PURE__ */ new un(), mo = /* @__PURE__ */ new un(), sl = /* @__PURE__ */ new un(), ol = /* @__PURE__ */ new un(), ms = /* @__PURE__ */ new un();
function mu(Et, t, r, c, w) {
  for (let R = 0, L = Et.length - 3; R <= L; R += 3) {
    ms.fromArray(Et, R);
    const h = w.x * Math.abs(ms.x) + w.y * Math.abs(ms.y) + w.z * Math.abs(ms.z), b = t.dot(ms), A = r.dot(ms), l = c.dot(ms);
    if (Math.max(-Math.max(b, A, l), Math.min(b, A, l)) > h)
      return !1;
  }
  return !0;
}
const Zy = /* @__PURE__ */ new Lo(), po = /* @__PURE__ */ new un(), pu = /* @__PURE__ */ new un();
class cm {
  constructor(t = new un(), r = -1) {
    this.isSphere = !0, this.center = t, this.radius = r;
  }
  set(t, r) {
    return this.center.copy(t), this.radius = r, this;
  }
  setFromPoints(t, r) {
    const c = this.center;
    r !== void 0 ? c.copy(r) : Zy.setFromPoints(t).getCenter(c);
    let w = 0;
    for (let R = 0, L = t.length; R < L; R++)
      w = Math.max(w, c.distanceToSquared(t[R]));
    return this.radius = Math.sqrt(w), this;
  }
  copy(t) {
    return this.center.copy(t.center), this.radius = t.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(t) {
    return t.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(t) {
    return t.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(t) {
    const r = this.radius + t.radius;
    return t.center.distanceToSquared(this.center) <= r * r;
  }
  intersectsBox(t) {
    return t.intersectsSphere(this);
  }
  intersectsPlane(t) {
    return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(t, r) {
    const c = this.center.distanceToSquared(t);
    return r.copy(t), c > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)), r;
  }
  getBoundingBox(t) {
    return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
  }
  applyMatrix4(t) {
    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this;
  }
  translate(t) {
    return this.center.add(t), this;
  }
  expandByPoint(t) {
    if (this.isEmpty())
      return this.center.copy(t), this.radius = 0, this;
    po.subVectors(t, this.center);
    const r = po.lengthSq();
    if (r > this.radius * this.radius) {
      const c = Math.sqrt(r), w = (c - this.radius) * 0.5;
      this.center.addScaledVector(po, w / c), this.radius += w;
    }
    return this;
  }
  union(t) {
    return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (pu.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(po.copy(t.center).add(pu)), this.expandByPoint(po.copy(t.center).sub(pu))), this);
  }
  equals(t) {
    return t.center.equals(this.center) && t.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Da = /* @__PURE__ */ new un(), gu = /* @__PURE__ */ new un(), ll = /* @__PURE__ */ new un(), Za = /* @__PURE__ */ new un(), _u = /* @__PURE__ */ new un(), ul = /* @__PURE__ */ new un(), yu = /* @__PURE__ */ new un();
class tb {
  constructor(t = new un(), r = new un(0, 0, -1)) {
    this.origin = t, this.direction = r;
  }
  set(t, r) {
    return this.origin.copy(t), this.direction.copy(r), this;
  }
  copy(t) {
    return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
  }
  at(t, r) {
    return r.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(t) {
    return this.direction.copy(t).sub(this.origin).normalize(), this;
  }
  recast(t) {
    return this.origin.copy(this.at(t, Da)), this;
  }
  closestPointToPoint(t, r) {
    r.subVectors(t, this.origin);
    const c = r.dot(this.direction);
    return c < 0 ? r.copy(this.origin) : r.copy(this.origin).addScaledVector(this.direction, c);
  }
  distanceToPoint(t) {
    return Math.sqrt(this.distanceSqToPoint(t));
  }
  distanceSqToPoint(t) {
    const r = Da.subVectors(t, this.origin).dot(this.direction);
    return r < 0 ? this.origin.distanceToSquared(t) : (Da.copy(this.origin).addScaledVector(this.direction, r), Da.distanceToSquared(t));
  }
  distanceSqToSegment(t, r, c, w) {
    gu.copy(t).add(r).multiplyScalar(0.5), ll.copy(r).sub(t).normalize(), Za.copy(this.origin).sub(gu);
    const R = t.distanceTo(r) * 0.5, L = -this.direction.dot(ll), h = Za.dot(this.direction), b = -Za.dot(ll), A = Za.lengthSq(), l = Math.abs(1 - L * L);
    let o, u, g, m;
    if (l > 0)
      if (o = L * b - h, u = L * h - b, m = R * l, o >= 0)
        if (u >= -m)
          if (u <= m) {
            const S = 1 / l;
            o *= S, u *= S, g = o * (o + L * u + 2 * h) + u * (L * o + u + 2 * b) + A;
          } else
            u = R, o = Math.max(0, -(L * u + h)), g = -o * o + u * (u + 2 * b) + A;
        else
          u = -R, o = Math.max(0, -(L * u + h)), g = -o * o + u * (u + 2 * b) + A;
      else
        u <= -m ? (o = Math.max(0, -(-L * R + h)), u = o > 0 ? -R : Math.min(Math.max(-R, -b), R), g = -o * o + u * (u + 2 * b) + A) : u <= m ? (o = 0, u = Math.min(Math.max(-R, -b), R), g = u * (u + 2 * b) + A) : (o = Math.max(0, -(L * R + h)), u = o > 0 ? R : Math.min(Math.max(-R, -b), R), g = -o * o + u * (u + 2 * b) + A);
    else
      u = L > 0 ? -R : R, o = Math.max(0, -(L * u + h)), g = -o * o + u * (u + 2 * b) + A;
    return c && c.copy(this.origin).addScaledVector(this.direction, o), w && w.copy(gu).addScaledVector(ll, u), g;
  }
  intersectSphere(t, r) {
    Da.subVectors(t.center, this.origin);
    const c = Da.dot(this.direction), w = Da.dot(Da) - c * c, R = t.radius * t.radius;
    if (w > R) return null;
    const L = Math.sqrt(R - w), h = c - L, b = c + L;
    return b < 0 ? null : h < 0 ? this.at(b, r) : this.at(h, r);
  }
  intersectsSphere(t) {
    return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
  }
  distanceToPlane(t) {
    const r = t.normal.dot(this.direction);
    if (r === 0)
      return t.distanceToPoint(this.origin) === 0 ? 0 : null;
    const c = -(this.origin.dot(t.normal) + t.constant) / r;
    return c >= 0 ? c : null;
  }
  intersectPlane(t, r) {
    const c = this.distanceToPlane(t);
    return c === null ? null : this.at(c, r);
  }
  intersectsPlane(t) {
    const r = t.distanceToPoint(this.origin);
    return r === 0 || t.normal.dot(this.direction) * r < 0;
  }
  intersectBox(t, r) {
    let c, w, R, L, h, b;
    const A = 1 / this.direction.x, l = 1 / this.direction.y, o = 1 / this.direction.z, u = this.origin;
    return A >= 0 ? (c = (t.min.x - u.x) * A, w = (t.max.x - u.x) * A) : (c = (t.max.x - u.x) * A, w = (t.min.x - u.x) * A), l >= 0 ? (R = (t.min.y - u.y) * l, L = (t.max.y - u.y) * l) : (R = (t.max.y - u.y) * l, L = (t.min.y - u.y) * l), c > L || R > w || ((R > c || isNaN(c)) && (c = R), (L < w || isNaN(w)) && (w = L), o >= 0 ? (h = (t.min.z - u.z) * o, b = (t.max.z - u.z) * o) : (h = (t.max.z - u.z) * o, b = (t.min.z - u.z) * o), c > b || h > w) || ((h > c || c !== c) && (c = h), (b < w || w !== w) && (w = b), w < 0) ? null : this.at(c >= 0 ? c : w, r);
  }
  intersectsBox(t) {
    return this.intersectBox(t, Da) !== null;
  }
  intersectTriangle(t, r, c, w, R) {
    _u.subVectors(r, t), ul.subVectors(c, t), yu.crossVectors(_u, ul);
    let L = this.direction.dot(yu), h;
    if (L > 0) {
      if (w) return null;
      h = 1;
    } else if (L < 0)
      h = -1, L = -L;
    else
      return null;
    Za.subVectors(this.origin, t);
    const b = h * this.direction.dot(ul.crossVectors(Za, ul));
    if (b < 0)
      return null;
    const A = h * this.direction.dot(_u.cross(Za));
    if (A < 0 || b + A > L)
      return null;
    const l = -h * Za.dot(yu);
    return l < 0 ? null : this.at(l / L, R);
  }
  applyMatrix4(t) {
    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
  }
  equals(t) {
    return t.origin.equals(this.origin) && t.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Br {
  constructor(t, r, c, w, R, L, h, b, A, l, o, u, g, m, S, e) {
    Br.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], t !== void 0 && this.set(t, r, c, w, R, L, h, b, A, l, o, u, g, m, S, e);
  }
  set(t, r, c, w, R, L, h, b, A, l, o, u, g, m, S, e) {
    const n = this.elements;
    return n[0] = t, n[4] = r, n[8] = c, n[12] = w, n[1] = R, n[5] = L, n[9] = h, n[13] = b, n[2] = A, n[6] = l, n[10] = o, n[14] = u, n[3] = g, n[7] = m, n[11] = S, n[15] = e, this;
  }
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  clone() {
    return new Br().fromArray(this.elements);
  }
  copy(t) {
    const r = this.elements, c = t.elements;
    return r[0] = c[0], r[1] = c[1], r[2] = c[2], r[3] = c[3], r[4] = c[4], r[5] = c[5], r[6] = c[6], r[7] = c[7], r[8] = c[8], r[9] = c[9], r[10] = c[10], r[11] = c[11], r[12] = c[12], r[13] = c[13], r[14] = c[14], r[15] = c[15], this;
  }
  copyPosition(t) {
    const r = this.elements, c = t.elements;
    return r[12] = c[12], r[13] = c[13], r[14] = c[14], this;
  }
  setFromMatrix3(t) {
    const r = t.elements;
    return this.set(
      r[0],
      r[3],
      r[6],
      0,
      r[1],
      r[4],
      r[7],
      0,
      r[2],
      r[5],
      r[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractBasis(t, r, c) {
    return t.setFromMatrixColumn(this, 0), r.setFromMatrixColumn(this, 1), c.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(t, r, c) {
    return this.set(
      t.x,
      r.x,
      c.x,
      0,
      t.y,
      r.y,
      c.y,
      0,
      t.z,
      r.z,
      c.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  extractRotation(t) {
    const r = this.elements, c = t.elements, w = 1 / Ys.setFromMatrixColumn(t, 0).length(), R = 1 / Ys.setFromMatrixColumn(t, 1).length(), L = 1 / Ys.setFromMatrixColumn(t, 2).length();
    return r[0] = c[0] * w, r[1] = c[1] * w, r[2] = c[2] * w, r[3] = 0, r[4] = c[4] * R, r[5] = c[5] * R, r[6] = c[6] * R, r[7] = 0, r[8] = c[8] * L, r[9] = c[9] * L, r[10] = c[10] * L, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, this;
  }
  makeRotationFromEuler(t) {
    const r = this.elements, c = t.x, w = t.y, R = t.z, L = Math.cos(c), h = Math.sin(c), b = Math.cos(w), A = Math.sin(w), l = Math.cos(R), o = Math.sin(R);
    if (t.order === "XYZ") {
      const u = L * l, g = L * o, m = h * l, S = h * o;
      r[0] = b * l, r[4] = -b * o, r[8] = A, r[1] = g + m * A, r[5] = u - S * A, r[9] = -h * b, r[2] = S - u * A, r[6] = m + g * A, r[10] = L * b;
    } else if (t.order === "YXZ") {
      const u = b * l, g = b * o, m = A * l, S = A * o;
      r[0] = u + S * h, r[4] = m * h - g, r[8] = L * A, r[1] = L * o, r[5] = L * l, r[9] = -h, r[2] = g * h - m, r[6] = S + u * h, r[10] = L * b;
    } else if (t.order === "ZXY") {
      const u = b * l, g = b * o, m = A * l, S = A * o;
      r[0] = u - S * h, r[4] = -L * o, r[8] = m + g * h, r[1] = g + m * h, r[5] = L * l, r[9] = S - u * h, r[2] = -L * A, r[6] = h, r[10] = L * b;
    } else if (t.order === "ZYX") {
      const u = L * l, g = L * o, m = h * l, S = h * o;
      r[0] = b * l, r[4] = m * A - g, r[8] = u * A + S, r[1] = b * o, r[5] = S * A + u, r[9] = g * A - m, r[2] = -A, r[6] = h * b, r[10] = L * b;
    } else if (t.order === "YZX") {
      const u = L * b, g = L * A, m = h * b, S = h * A;
      r[0] = b * l, r[4] = S - u * o, r[8] = m * o + g, r[1] = o, r[5] = L * l, r[9] = -h * l, r[2] = -A * l, r[6] = g * o + m, r[10] = u - S * o;
    } else if (t.order === "XZY") {
      const u = L * b, g = L * A, m = h * b, S = h * A;
      r[0] = b * l, r[4] = -o, r[8] = A * l, r[1] = u * o + S, r[5] = L * l, r[9] = g * o - m, r[2] = m * o - g, r[6] = h * l, r[10] = S * o + u;
    }
    return r[3] = 0, r[7] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, this;
  }
  makeRotationFromQuaternion(t) {
    return this.compose(eb, t, nb);
  }
  lookAt(t, r, c) {
    const w = this.elements;
    return Sr.subVectors(t, r), Sr.lengthSq() === 0 && (Sr.z = 1), Sr.normalize(), ts.crossVectors(c, Sr), ts.lengthSq() === 0 && (Math.abs(c.z) === 1 ? Sr.x += 1e-4 : Sr.z += 1e-4, Sr.normalize(), ts.crossVectors(c, Sr)), ts.normalize(), dl.crossVectors(Sr, ts), w[0] = ts.x, w[4] = dl.x, w[8] = Sr.x, w[1] = ts.y, w[5] = dl.y, w[9] = Sr.y, w[2] = ts.z, w[6] = dl.z, w[10] = Sr.z, this;
  }
  multiply(t) {
    return this.multiplyMatrices(this, t);
  }
  premultiply(t) {
    return this.multiplyMatrices(t, this);
  }
  multiplyMatrices(t, r) {
    const c = t.elements, w = r.elements, R = this.elements, L = c[0], h = c[4], b = c[8], A = c[12], l = c[1], o = c[5], u = c[9], g = c[13], m = c[2], S = c[6], e = c[10], n = c[14], d = c[3], _ = c[7], p = c[11], P = c[15], $ = w[0], ot = w[4], dt = w[8], xt = w[12], Nt = w[1], jt = w[5], q = w[9], I = w[13], pt = w[2], It = w[6], et = w[10], Dt = w[14], ae = w[3], St = w[7], qe = w[11], zt = w[15];
    return R[0] = L * $ + h * Nt + b * pt + A * ae, R[4] = L * ot + h * jt + b * It + A * St, R[8] = L * dt + h * q + b * et + A * qe, R[12] = L * xt + h * I + b * Dt + A * zt, R[1] = l * $ + o * Nt + u * pt + g * ae, R[5] = l * ot + o * jt + u * It + g * St, R[9] = l * dt + o * q + u * et + g * qe, R[13] = l * xt + o * I + u * Dt + g * zt, R[2] = m * $ + S * Nt + e * pt + n * ae, R[6] = m * ot + S * jt + e * It + n * St, R[10] = m * dt + S * q + e * et + n * qe, R[14] = m * xt + S * I + e * Dt + n * zt, R[3] = d * $ + _ * Nt + p * pt + P * ae, R[7] = d * ot + _ * jt + p * It + P * St, R[11] = d * dt + _ * q + p * et + P * qe, R[15] = d * xt + _ * I + p * Dt + P * zt, this;
  }
  multiplyScalar(t) {
    const r = this.elements;
    return r[0] *= t, r[4] *= t, r[8] *= t, r[12] *= t, r[1] *= t, r[5] *= t, r[9] *= t, r[13] *= t, r[2] *= t, r[6] *= t, r[10] *= t, r[14] *= t, r[3] *= t, r[7] *= t, r[11] *= t, r[15] *= t, this;
  }
  determinant() {
    const t = this.elements, r = t[0], c = t[4], w = t[8], R = t[12], L = t[1], h = t[5], b = t[9], A = t[13], l = t[2], o = t[6], u = t[10], g = t[14], m = t[3], S = t[7], e = t[11], n = t[15];
    return m * (+R * b * o - w * A * o - R * h * u + c * A * u + w * h * g - c * b * g) + S * (+r * b * g - r * A * u + R * L * u - w * L * g + w * A * l - R * b * l) + e * (+r * A * o - r * h * g - R * L * o + c * L * g + R * h * l - c * A * l) + n * (-w * h * l - r * b * o + r * h * u + w * L * o - c * L * u + c * b * l);
  }
  transpose() {
    const t = this.elements;
    let r;
    return r = t[1], t[1] = t[4], t[4] = r, r = t[2], t[2] = t[8], t[8] = r, r = t[6], t[6] = t[9], t[9] = r, r = t[3], t[3] = t[12], t[12] = r, r = t[7], t[7] = t[13], t[13] = r, r = t[11], t[11] = t[14], t[14] = r, this;
  }
  setPosition(t, r, c) {
    const w = this.elements;
    return t.isVector3 ? (w[12] = t.x, w[13] = t.y, w[14] = t.z) : (w[12] = t, w[13] = r, w[14] = c), this;
  }
  invert() {
    const t = this.elements, r = t[0], c = t[1], w = t[2], R = t[3], L = t[4], h = t[5], b = t[6], A = t[7], l = t[8], o = t[9], u = t[10], g = t[11], m = t[12], S = t[13], e = t[14], n = t[15], d = o * e * A - S * u * A + S * b * g - h * e * g - o * b * n + h * u * n, _ = m * u * A - l * e * A - m * b * g + L * e * g + l * b * n - L * u * n, p = l * S * A - m * o * A + m * h * g - L * S * g - l * h * n + L * o * n, P = m * o * b - l * S * b - m * h * u + L * S * u + l * h * e - L * o * e, $ = r * d + c * _ + w * p + R * P;
    if ($ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const ot = 1 / $;
    return t[0] = d * ot, t[1] = (S * u * R - o * e * R - S * w * g + c * e * g + o * w * n - c * u * n) * ot, t[2] = (h * e * R - S * b * R + S * w * A - c * e * A - h * w * n + c * b * n) * ot, t[3] = (o * b * R - h * u * R - o * w * A + c * u * A + h * w * g - c * b * g) * ot, t[4] = _ * ot, t[5] = (l * e * R - m * u * R + m * w * g - r * e * g - l * w * n + r * u * n) * ot, t[6] = (m * b * R - L * e * R - m * w * A + r * e * A + L * w * n - r * b * n) * ot, t[7] = (L * u * R - l * b * R + l * w * A - r * u * A - L * w * g + r * b * g) * ot, t[8] = p * ot, t[9] = (m * o * R - l * S * R - m * c * g + r * S * g + l * c * n - r * o * n) * ot, t[10] = (L * S * R - m * h * R + m * c * A - r * S * A - L * c * n + r * h * n) * ot, t[11] = (l * h * R - L * o * R - l * c * A + r * o * A + L * c * g - r * h * g) * ot, t[12] = P * ot, t[13] = (l * S * w - m * o * w + m * c * u - r * S * u - l * c * e + r * o * e) * ot, t[14] = (m * h * w - L * S * w - m * c * b + r * S * b + L * c * e - r * h * e) * ot, t[15] = (L * o * w - l * h * w + l * c * b - r * o * b - L * c * u + r * h * u) * ot, this;
  }
  scale(t) {
    const r = this.elements, c = t.x, w = t.y, R = t.z;
    return r[0] *= c, r[4] *= w, r[8] *= R, r[1] *= c, r[5] *= w, r[9] *= R, r[2] *= c, r[6] *= w, r[10] *= R, r[3] *= c, r[7] *= w, r[11] *= R, this;
  }
  getMaxScaleOnAxis() {
    const t = this.elements, r = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], c = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], w = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
    return Math.sqrt(Math.max(r, c, w));
  }
  makeTranslation(t, r, c) {
    return t.isVector3 ? this.set(
      1,
      0,
      0,
      t.x,
      0,
      1,
      0,
      t.y,
      0,
      0,
      1,
      t.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      t,
      0,
      1,
      0,
      r,
      0,
      0,
      1,
      c,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationX(t) {
    const r = Math.cos(t), c = Math.sin(t);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      r,
      -c,
      0,
      0,
      c,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationY(t) {
    const r = Math.cos(t), c = Math.sin(t);
    return this.set(
      r,
      0,
      c,
      0,
      0,
      1,
      0,
      0,
      -c,
      0,
      r,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationZ(t) {
    const r = Math.cos(t), c = Math.sin(t);
    return this.set(
      r,
      -c,
      0,
      0,
      c,
      r,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeRotationAxis(t, r) {
    const c = Math.cos(r), w = Math.sin(r), R = 1 - c, L = t.x, h = t.y, b = t.z, A = R * L, l = R * h;
    return this.set(
      A * L + c,
      A * h - w * b,
      A * b + w * h,
      0,
      A * h + w * b,
      l * h + c,
      l * b - w * L,
      0,
      A * b - w * h,
      l * b + w * L,
      R * b * b + c,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeScale(t, r, c) {
    return this.set(
      t,
      0,
      0,
      0,
      0,
      r,
      0,
      0,
      0,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  makeShear(t, r, c, w, R, L) {
    return this.set(
      1,
      c,
      R,
      0,
      t,
      1,
      L,
      0,
      r,
      w,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  compose(t, r, c) {
    const w = this.elements, R = r._x, L = r._y, h = r._z, b = r._w, A = R + R, l = L + L, o = h + h, u = R * A, g = R * l, m = R * o, S = L * l, e = L * o, n = h * o, d = b * A, _ = b * l, p = b * o, P = c.x, $ = c.y, ot = c.z;
    return w[0] = (1 - (S + n)) * P, w[1] = (g + p) * P, w[2] = (m - _) * P, w[3] = 0, w[4] = (g - p) * $, w[5] = (1 - (u + n)) * $, w[6] = (e + d) * $, w[7] = 0, w[8] = (m + _) * ot, w[9] = (e - d) * ot, w[10] = (1 - (u + S)) * ot, w[11] = 0, w[12] = t.x, w[13] = t.y, w[14] = t.z, w[15] = 1, this;
  }
  decompose(t, r, c) {
    const w = this.elements;
    let R = Ys.set(w[0], w[1], w[2]).length();
    const L = Ys.set(w[4], w[5], w[6]).length(), h = Ys.set(w[8], w[9], w[10]).length();
    this.determinant() < 0 && (R = -R), t.x = w[12], t.y = w[13], t.z = w[14], ta.copy(this);
    const A = 1 / R, l = 1 / L, o = 1 / h;
    return ta.elements[0] *= A, ta.elements[1] *= A, ta.elements[2] *= A, ta.elements[4] *= l, ta.elements[5] *= l, ta.elements[6] *= l, ta.elements[8] *= o, ta.elements[9] *= o, ta.elements[10] *= o, r.setFromRotationMatrix(ta), c.x = R, c.y = L, c.z = h, this;
  }
  makePerspective(t, r, c, w, R, L, h = rl) {
    const b = this.elements, A = 2 * R / (r - t), l = 2 * R / (c - w), o = (r + t) / (r - t), u = (c + w) / (c - w);
    let g, m;
    if (h === rl)
      g = -(L + R) / (L - R), m = -2 * L * R / (L - R);
    else if (h === mh)
      g = -L / (L - R), m = -L * R / (L - R);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + h);
    return b[0] = A, b[4] = 0, b[8] = o, b[12] = 0, b[1] = 0, b[5] = l, b[9] = u, b[13] = 0, b[2] = 0, b[6] = 0, b[10] = g, b[14] = m, b[3] = 0, b[7] = 0, b[11] = -1, b[15] = 0, this;
  }
  makeOrthographic(t, r, c, w, R, L, h = rl) {
    const b = this.elements, A = 1 / (r - t), l = 1 / (c - w), o = 1 / (L - R), u = (r + t) * A, g = (c + w) * l;
    let m, S;
    if (h === rl)
      m = (L + R) * o, S = -2 * o;
    else if (h === mh)
      m = R * o, S = -1 * o;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + h);
    return b[0] = 2 * A, b[4] = 0, b[8] = 0, b[12] = -u, b[1] = 0, b[5] = 2 * l, b[9] = 0, b[13] = -g, b[2] = 0, b[6] = 0, b[10] = S, b[14] = -m, b[3] = 0, b[7] = 0, b[11] = 0, b[15] = 1, this;
  }
  equals(t) {
    const r = this.elements, c = t.elements;
    for (let w = 0; w < 16; w++)
      if (r[w] !== c[w]) return !1;
    return !0;
  }
  fromArray(t, r = 0) {
    for (let c = 0; c < 16; c++)
      this.elements[c] = t[c + r];
    return this;
  }
  toArray(t = [], r = 0) {
    const c = this.elements;
    return t[r] = c[0], t[r + 1] = c[1], t[r + 2] = c[2], t[r + 3] = c[3], t[r + 4] = c[4], t[r + 5] = c[5], t[r + 6] = c[6], t[r + 7] = c[7], t[r + 8] = c[8], t[r + 9] = c[9], t[r + 10] = c[10], t[r + 11] = c[11], t[r + 12] = c[12], t[r + 13] = c[13], t[r + 14] = c[14], t[r + 15] = c[15], t;
  }
}
const Ys = /* @__PURE__ */ new un(), ta = /* @__PURE__ */ new Br(), eb = /* @__PURE__ */ new un(0, 0, 0), nb = /* @__PURE__ */ new un(1, 1, 1), ts = /* @__PURE__ */ new un(), dl = /* @__PURE__ */ new un(), Sr = /* @__PURE__ */ new un(), bh = /* @__PURE__ */ new Br(), Eh = /* @__PURE__ */ new xo();
class ns {
  constructor(t = 0, r = 0, c = 0, w = ns.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = t, this._y = r, this._z = c, this._order = w;
  }
  get x() {
    return this._x;
  }
  set x(t) {
    this._x = t, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(t) {
    this._y = t, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(t) {
    this._z = t, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(t) {
    this._order = t, this._onChangeCallback();
  }
  set(t, r, c, w = this._order) {
    return this._x = t, this._y = r, this._z = c, this._order = w, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(t) {
    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(t, r = this._order, c = !0) {
    const w = t.elements, R = w[0], L = w[4], h = w[8], b = w[1], A = w[5], l = w[9], o = w[2], u = w[6], g = w[10];
    switch (r) {
      case "XYZ":
        this._y = Math.asin(fi(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(-l, g), this._z = Math.atan2(-L, R)) : (this._x = Math.atan2(u, A), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-fi(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._y = Math.atan2(h, g), this._z = Math.atan2(b, A)) : (this._y = Math.atan2(-o, R), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(fi(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(-o, g), this._z = Math.atan2(-L, A)) : (this._y = 0, this._z = Math.atan2(b, R));
        break;
      case "ZYX":
        this._y = Math.asin(-fi(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(u, g), this._z = Math.atan2(b, R)) : (this._x = 0, this._z = Math.atan2(-L, A));
        break;
      case "YZX":
        this._z = Math.asin(fi(b, -1, 1)), Math.abs(b) < 0.9999999 ? (this._x = Math.atan2(-l, A), this._y = Math.atan2(-o, R)) : (this._x = 0, this._y = Math.atan2(h, g));
        break;
      case "XZY":
        this._z = Math.asin(-fi(L, -1, 1)), Math.abs(L) < 0.9999999 ? (this._x = Math.atan2(u, A), this._y = Math.atan2(h, R)) : (this._x = Math.atan2(-l, g), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + r);
    }
    return this._order = r, c === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(t, r, c) {
    return bh.makeRotationFromQuaternion(t), this.setFromRotationMatrix(bh, r, c);
  }
  setFromVector3(t, r = this._order) {
    return this.set(t.x, t.y, t.z, r);
  }
  reorder(t) {
    return Eh.setFromEuler(this), this.setFromQuaternion(Eh, t);
  }
  equals(t) {
    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order;
  }
  fromArray(t) {
    return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this._x, t[r + 1] = this._y, t[r + 2] = this._z, t[r + 3] = this._order, t;
  }
  _onChange(t) {
    return this._onChangeCallback = t, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ns.DEFAULT_ORDER = "XYZ";
class ib {
  constructor() {
    this.mask = 1;
  }
  set(t) {
    this.mask = (1 << t | 0) >>> 0;
  }
  enable(t) {
    this.mask |= 1 << t | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(t) {
    this.mask ^= 1 << t | 0;
  }
  disable(t) {
    this.mask &= ~(1 << t | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(t) {
    return (this.mask & t.mask) !== 0;
  }
  isEnabled(t) {
    return (this.mask & (1 << t | 0)) !== 0;
  }
}
let rb = 0;
const vh = /* @__PURE__ */ new un(), Fs = /* @__PURE__ */ new xo(), Ia = /* @__PURE__ */ new Br(), cl = /* @__PURE__ */ new un(), go = /* @__PURE__ */ new un(), ab = /* @__PURE__ */ new un(), sb = /* @__PURE__ */ new xo(), Th = /* @__PURE__ */ new un(1, 0, 0), wh = /* @__PURE__ */ new un(0, 1, 0), Ah = /* @__PURE__ */ new un(0, 0, 1), Sh = { type: "added" }, ob = { type: "removed" }, Us = { type: "childadded", child: null }, bu = { type: "childremoved", child: null };
class Ea extends Yl {
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: rb++ }), this.uuid = Js(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ea.DEFAULT_UP.clone();
    const t = new un(), r = new ns(), c = new xo(), w = new un(1, 1, 1);
    function R() {
      c.setFromEuler(r, !1);
    }
    function L() {
      r.setFromQuaternion(c, void 0, !1);
    }
    r._onChange(R), c._onChange(L), Object.defineProperties(this, {
      position: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: r
      },
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: c
      },
      scale: {
        configurable: !0,
        enumerable: !0,
        value: w
      },
      modelViewMatrix: {
        value: new Br()
      },
      normalMatrix: {
        value: new as()
      }
    }), this.matrix = new Br(), this.matrixWorld = new Br(), this.matrixAutoUpdate = Ea.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ea.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new ib(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(t) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(t) {
    return this.quaternion.premultiply(t), this;
  }
  setRotationFromAxisAngle(t, r) {
    this.quaternion.setFromAxisAngle(t, r);
  }
  setRotationFromEuler(t) {
    this.quaternion.setFromEuler(t, !0);
  }
  setRotationFromMatrix(t) {
    this.quaternion.setFromRotationMatrix(t);
  }
  setRotationFromQuaternion(t) {
    this.quaternion.copy(t);
  }
  rotateOnAxis(t, r) {
    return Fs.setFromAxisAngle(t, r), this.quaternion.multiply(Fs), this;
  }
  rotateOnWorldAxis(t, r) {
    return Fs.setFromAxisAngle(t, r), this.quaternion.premultiply(Fs), this;
  }
  rotateX(t) {
    return this.rotateOnAxis(Th, t);
  }
  rotateY(t) {
    return this.rotateOnAxis(wh, t);
  }
  rotateZ(t) {
    return this.rotateOnAxis(Ah, t);
  }
  translateOnAxis(t, r) {
    return vh.copy(t).applyQuaternion(this.quaternion), this.position.add(vh.multiplyScalar(r)), this;
  }
  translateX(t) {
    return this.translateOnAxis(Th, t);
  }
  translateY(t) {
    return this.translateOnAxis(wh, t);
  }
  translateZ(t) {
    return this.translateOnAxis(Ah, t);
  }
  localToWorld(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(t) {
    return this.updateWorldMatrix(!0, !1), t.applyMatrix4(Ia.copy(this.matrixWorld).invert());
  }
  lookAt(t, r, c) {
    t.isVector3 ? cl.copy(t) : cl.set(t, r, c);
    const w = this.parent;
    this.updateWorldMatrix(!0, !1), go.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ia.lookAt(go, cl, this.up) : Ia.lookAt(cl, go, this.up), this.quaternion.setFromRotationMatrix(Ia), w && (Ia.extractRotation(w.matrixWorld), Fs.setFromRotationMatrix(Ia), this.quaternion.premultiply(Fs.invert()));
  }
  add(t) {
    if (arguments.length > 1) {
      for (let r = 0; r < arguments.length; r++)
        this.add(arguments[r]);
      return this;
    }
    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.removeFromParent(), t.parent = this, this.children.push(t), t.dispatchEvent(Sh), Us.child = t, this.dispatchEvent(Us), Us.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this);
  }
  remove(t) {
    if (arguments.length > 1) {
      for (let c = 0; c < arguments.length; c++)
        this.remove(arguments[c]);
      return this;
    }
    const r = this.children.indexOf(t);
    return r !== -1 && (t.parent = null, this.children.splice(r, 1), t.dispatchEvent(ob), bu.child = t, this.dispatchEvent(bu), bu.child = null), this;
  }
  removeFromParent() {
    const t = this.parent;
    return t !== null && t.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(t) {
    return this.updateWorldMatrix(!0, !1), Ia.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), Ia.multiply(t.parent.matrixWorld)), t.applyMatrix4(Ia), t.removeFromParent(), t.parent = this, this.children.push(t), t.updateWorldMatrix(!1, !0), t.dispatchEvent(Sh), Us.child = t, this.dispatchEvent(Us), Us.child = null, this;
  }
  getObjectById(t) {
    return this.getObjectByProperty("id", t);
  }
  getObjectByName(t) {
    return this.getObjectByProperty("name", t);
  }
  getObjectByProperty(t, r) {
    if (this[t] === r) return this;
    for (let c = 0, w = this.children.length; c < w; c++) {
      const L = this.children[c].getObjectByProperty(t, r);
      if (L !== void 0)
        return L;
    }
  }
  getObjectsByProperty(t, r, c = []) {
    this[t] === r && c.push(this);
    const w = this.children;
    for (let R = 0, L = w.length; R < L; R++)
      w[R].getObjectsByProperty(t, r, c);
    return c;
  }
  getWorldPosition(t) {
    return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(go, t, ab), t;
  }
  getWorldScale(t) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(go, sb, t), t;
  }
  getWorldDirection(t) {
    this.updateWorldMatrix(!0, !1);
    const r = this.matrixWorld.elements;
    return t.set(r[8], r[9], r[10]).normalize();
  }
  raycast() {
  }
  traverse(t) {
    t(this);
    const r = this.children;
    for (let c = 0, w = r.length; c < w; c++)
      r[c].traverse(t);
  }
  traverseVisible(t) {
    if (this.visible === !1) return;
    t(this);
    const r = this.children;
    for (let c = 0, w = r.length; c < w; c++)
      r[c].traverseVisible(t);
  }
  traverseAncestors(t) {
    const r = this.parent;
    r !== null && (t(r), r.traverseAncestors(t));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  updateMatrixWorld(t) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, t = !0);
    const r = this.children;
    for (let c = 0, w = r.length; c < w; c++)
      r[c].updateMatrixWorld(t);
  }
  updateWorldMatrix(t, r) {
    const c = this.parent;
    if (t === !0 && c !== null && c.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), r === !0) {
      const w = this.children;
      for (let R = 0, L = w.length; R < L; R++)
        w[R].updateWorldMatrix(!1, !0);
    }
  }
  toJSON(t) {
    const r = t === void 0 || typeof t == "string", c = {};
    r && (t = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, c.metadata = {
      version: 4.6,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const w = {};
    w.uuid = this.uuid, w.type = this.type, this.name !== "" && (w.name = this.name), this.castShadow === !0 && (w.castShadow = !0), this.receiveShadow === !0 && (w.receiveShadow = !0), this.visible === !1 && (w.visible = !1), this.frustumCulled === !1 && (w.frustumCulled = !1), this.renderOrder !== 0 && (w.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (w.userData = this.userData), w.layers = this.layers.mask, w.matrix = this.matrix.toArray(), w.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (w.matrixAutoUpdate = !1), this.isInstancedMesh && (w.type = "InstancedMesh", w.count = this.count, w.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (w.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (w.type = "BatchedMesh", w.perObjectFrustumCulled = this.perObjectFrustumCulled, w.sortObjects = this.sortObjects, w.drawRanges = this._drawRanges, w.reservedRanges = this._reservedRanges, w.visibility = this._visibility, w.active = this._active, w.bounds = this._bounds.map((h) => ({
      boxInitialized: h.boxInitialized,
      boxMin: h.box.min.toArray(),
      boxMax: h.box.max.toArray(),
      sphereInitialized: h.sphereInitialized,
      sphereRadius: h.sphere.radius,
      sphereCenter: h.sphere.center.toArray()
    })), w.maxInstanceCount = this._maxInstanceCount, w.maxVertexCount = this._maxVertexCount, w.maxIndexCount = this._maxIndexCount, w.geometryInitialized = this._geometryInitialized, w.geometryCount = this._geometryCount, w.matricesTexture = this._matricesTexture.toJSON(t), this._colorsTexture !== null && (w.colorsTexture = this._colorsTexture.toJSON(t)), this.boundingSphere !== null && (w.boundingSphere = {
      center: w.boundingSphere.center.toArray(),
      radius: w.boundingSphere.radius
    }), this.boundingBox !== null && (w.boundingBox = {
      min: w.boundingBox.min.toArray(),
      max: w.boundingBox.max.toArray()
    }));
    function R(h, b) {
      return h[b.uuid] === void 0 && (h[b.uuid] = b.toJSON(t)), b.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? w.background = this.background.toJSON() : this.background.isTexture && (w.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (w.environment = this.environment.toJSON(t).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      w.geometry = R(t.geometries, this.geometry);
      const h = this.geometry.parameters;
      if (h !== void 0 && h.shapes !== void 0) {
        const b = h.shapes;
        if (Array.isArray(b))
          for (let A = 0, l = b.length; A < l; A++) {
            const o = b[A];
            R(t.shapes, o);
          }
        else
          R(t.shapes, b);
      }
    }
    if (this.isSkinnedMesh && (w.bindMode = this.bindMode, w.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (R(t.skeletons, this.skeleton), w.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const h = [];
        for (let b = 0, A = this.material.length; b < A; b++)
          h.push(R(t.materials, this.material[b]));
        w.material = h;
      } else
        w.material = R(t.materials, this.material);
    if (this.children.length > 0) {
      w.children = [];
      for (let h = 0; h < this.children.length; h++)
        w.children.push(this.children[h].toJSON(t).object);
    }
    if (this.animations.length > 0) {
      w.animations = [];
      for (let h = 0; h < this.animations.length; h++) {
        const b = this.animations[h];
        w.animations.push(R(t.animations, b));
      }
    }
    if (r) {
      const h = L(t.geometries), b = L(t.materials), A = L(t.textures), l = L(t.images), o = L(t.shapes), u = L(t.skeletons), g = L(t.animations), m = L(t.nodes);
      h.length > 0 && (c.geometries = h), b.length > 0 && (c.materials = b), A.length > 0 && (c.textures = A), l.length > 0 && (c.images = l), o.length > 0 && (c.shapes = o), u.length > 0 && (c.skeletons = u), g.length > 0 && (c.animations = g), m.length > 0 && (c.nodes = m);
    }
    return c.object = w, c;
    function L(h) {
      const b = [];
      for (const A in h) {
        const l = h[A];
        delete l.metadata, b.push(l);
      }
      return b;
    }
  }
  clone(t) {
    return new this.constructor().copy(this, t);
  }
  copy(t, r = !0) {
    if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.animations = t.animations.slice(), this.userData = JSON.parse(JSON.stringify(t.userData)), r === !0)
      for (let c = 0; c < t.children.length; c++) {
        const w = t.children[c];
        this.add(w.clone());
      }
    return this;
  }
}
Ea.DEFAULT_UP = /* @__PURE__ */ new un(0, 1, 0);
Ea.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Ea.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ea = /* @__PURE__ */ new un(), Ra = /* @__PURE__ */ new un(), Eu = /* @__PURE__ */ new un(), Ca = /* @__PURE__ */ new un(), js = /* @__PURE__ */ new un(), Bs = /* @__PURE__ */ new un(), Mh = /* @__PURE__ */ new un(), vu = /* @__PURE__ */ new un(), Tu = /* @__PURE__ */ new un(), wu = /* @__PURE__ */ new un(), Au = /* @__PURE__ */ new ko(), Su = /* @__PURE__ */ new ko(), Mu = /* @__PURE__ */ new ko();
class na {
  constructor(t = new un(), r = new un(), c = new un()) {
    this.a = t, this.b = r, this.c = c;
  }
  static getNormal(t, r, c, w) {
    w.subVectors(c, r), ea.subVectors(t, r), w.cross(ea);
    const R = w.lengthSq();
    return R > 0 ? w.multiplyScalar(1 / Math.sqrt(R)) : w.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(t, r, c, w, R) {
    ea.subVectors(w, r), Ra.subVectors(c, r), Eu.subVectors(t, r);
    const L = ea.dot(ea), h = ea.dot(Ra), b = ea.dot(Eu), A = Ra.dot(Ra), l = Ra.dot(Eu), o = L * A - h * h;
    if (o === 0)
      return R.set(0, 0, 0), null;
    const u = 1 / o, g = (A * b - h * l) * u, m = (L * l - h * b) * u;
    return R.set(1 - g - m, m, g);
  }
  static containsPoint(t, r, c, w) {
    return this.getBarycoord(t, r, c, w, Ca) === null ? !1 : Ca.x >= 0 && Ca.y >= 0 && Ca.x + Ca.y <= 1;
  }
  static getInterpolation(t, r, c, w, R, L, h, b) {
    return this.getBarycoord(t, r, c, w, Ca) === null ? (b.x = 0, b.y = 0, "z" in b && (b.z = 0), "w" in b && (b.w = 0), null) : (b.setScalar(0), b.addScaledVector(R, Ca.x), b.addScaledVector(L, Ca.y), b.addScaledVector(h, Ca.z), b);
  }
  static getInterpolatedAttribute(t, r, c, w, R, L) {
    return Au.setScalar(0), Su.setScalar(0), Mu.setScalar(0), Au.fromBufferAttribute(t, r), Su.fromBufferAttribute(t, c), Mu.fromBufferAttribute(t, w), L.setScalar(0), L.addScaledVector(Au, R.x), L.addScaledVector(Su, R.y), L.addScaledVector(Mu, R.z), L;
  }
  static isFrontFacing(t, r, c, w) {
    return ea.subVectors(c, r), Ra.subVectors(t, r), ea.cross(Ra).dot(w) < 0;
  }
  set(t, r, c) {
    return this.a.copy(t), this.b.copy(r), this.c.copy(c), this;
  }
  setFromPointsAndIndices(t, r, c, w) {
    return this.a.copy(t[r]), this.b.copy(t[c]), this.c.copy(t[w]), this;
  }
  setFromAttributeAndIndices(t, r, c, w) {
    return this.a.fromBufferAttribute(t, r), this.b.fromBufferAttribute(t, c), this.c.fromBufferAttribute(t, w), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
  }
  getArea() {
    return ea.subVectors(this.c, this.b), Ra.subVectors(this.a, this.b), ea.cross(Ra).length() * 0.5;
  }
  getMidpoint(t) {
    return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(t) {
    return na.getNormal(this.a, this.b, this.c, t);
  }
  getPlane(t) {
    return t.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(t, r) {
    return na.getBarycoord(t, this.a, this.b, this.c, r);
  }
  getInterpolation(t, r, c, w, R) {
    return na.getInterpolation(t, this.a, this.b, this.c, r, c, w, R);
  }
  containsPoint(t) {
    return na.containsPoint(t, this.a, this.b, this.c);
  }
  isFrontFacing(t) {
    return na.isFrontFacing(this.a, this.b, this.c, t);
  }
  intersectsBox(t) {
    return t.intersectsTriangle(this);
  }
  closestPointToPoint(t, r) {
    const c = this.a, w = this.b, R = this.c;
    let L, h;
    js.subVectors(w, c), Bs.subVectors(R, c), vu.subVectors(t, c);
    const b = js.dot(vu), A = Bs.dot(vu);
    if (b <= 0 && A <= 0)
      return r.copy(c);
    Tu.subVectors(t, w);
    const l = js.dot(Tu), o = Bs.dot(Tu);
    if (l >= 0 && o <= l)
      return r.copy(w);
    const u = b * o - l * A;
    if (u <= 0 && b >= 0 && l <= 0)
      return L = b / (b - l), r.copy(c).addScaledVector(js, L);
    wu.subVectors(t, R);
    const g = js.dot(wu), m = Bs.dot(wu);
    if (m >= 0 && g <= m)
      return r.copy(R);
    const S = g * A - b * m;
    if (S <= 0 && A >= 0 && m <= 0)
      return h = A / (A - m), r.copy(c).addScaledVector(Bs, h);
    const e = l * m - g * o;
    if (e <= 0 && o - l >= 0 && g - m >= 0)
      return Mh.subVectors(R, w), h = (o - l) / (o - l + (g - m)), r.copy(w).addScaledVector(Mh, h);
    const n = 1 / (e + S + u);
    return L = S * n, h = u * n, r.copy(c).addScaledVector(js, L).addScaledVector(Bs, h);
  }
  equals(t) {
    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
  }
}
const hm = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, es = { h: 0, s: 0, l: 0 }, hl = { h: 0, s: 0, l: 0 };
function ku(Et, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? Et + (t - Et) * 6 * r : r < 1 / 2 ? t : r < 2 / 3 ? Et + (t - Et) * 6 * (2 / 3 - r) : Et;
}
class gs {
  constructor(t, r, c) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(t, r, c);
  }
  set(t, r, c) {
    if (r === void 0 && c === void 0) {
      const w = t;
      w && w.isColor ? this.copy(w) : typeof w == "number" ? this.setHex(w) : typeof w == "string" && this.setStyle(w);
    } else
      this.setRGB(t, r, c);
    return this;
  }
  setScalar(t) {
    return this.r = t, this.g = t, this.b = t, this;
  }
  setHex(t, r = kr) {
    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Jr.toWorkingColorSpace(this, r), this;
  }
  setRGB(t, r, c, w = Jr.workingColorSpace) {
    return this.r = t, this.g = r, this.b = c, Jr.toWorkingColorSpace(this, w), this;
  }
  setHSL(t, r, c, w = Jr.workingColorSpace) {
    if (t = ad(t, 1), r = fi(r, 0, 1), c = fi(c, 0, 1), r === 0)
      this.r = this.g = this.b = c;
    else {
      const R = c <= 0.5 ? c * (1 + r) : c + r - c * r, L = 2 * c - R;
      this.r = ku(L, R, t + 1 / 3), this.g = ku(L, R, t), this.b = ku(L, R, t - 1 / 3);
    }
    return Jr.toWorkingColorSpace(this, w), this;
  }
  setStyle(t, r = kr) {
    function c(R) {
      R !== void 0 && parseFloat(R) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.");
    }
    let w;
    if (w = /^(\w+)\(([^\)]*)\)/.exec(t)) {
      let R;
      const L = w[1], h = w[2];
      switch (L) {
        case "rgb":
        case "rgba":
          if (R = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return c(R[4]), this.setRGB(
              Math.min(255, parseInt(R[1], 10)) / 255,
              Math.min(255, parseInt(R[2], 10)) / 255,
              Math.min(255, parseInt(R[3], 10)) / 255,
              r
            );
          if (R = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return c(R[4]), this.setRGB(
              Math.min(100, parseInt(R[1], 10)) / 100,
              Math.min(100, parseInt(R[2], 10)) / 100,
              Math.min(100, parseInt(R[3], 10)) / 100,
              r
            );
          break;
        case "hsl":
        case "hsla":
          if (R = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(h))
            return c(R[4]), this.setHSL(
              parseFloat(R[1]) / 360,
              parseFloat(R[2]) / 100,
              parseFloat(R[3]) / 100,
              r
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + t);
      }
    } else if (w = /^\#([A-Fa-f\d]+)$/.exec(t)) {
      const R = w[1], L = R.length;
      if (L === 3)
        return this.setRGB(
          parseInt(R.charAt(0), 16) / 15,
          parseInt(R.charAt(1), 16) / 15,
          parseInt(R.charAt(2), 16) / 15,
          r
        );
      if (L === 6)
        return this.setHex(parseInt(R, 16), r);
      console.warn("THREE.Color: Invalid hex color " + t);
    } else if (t && t.length > 0)
      return this.setColorName(t, r);
    return this;
  }
  setColorName(t, r = kr) {
    const c = hm[t.toLowerCase()];
    return c !== void 0 ? this.setHex(c, r) : console.warn("THREE.Color: Unknown color " + t), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(t) {
    return this.r = t.r, this.g = t.g, this.b = t.b, this;
  }
  copySRGBToLinear(t) {
    return this.r = Oa(t.r), this.g = Oa(t.g), this.b = Oa(t.b), this;
  }
  copyLinearToSRGB(t) {
    return this.r = Xs(t.r), this.g = Xs(t.g), this.b = Xs(t.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(t = kr) {
    return Jr.fromWorkingColorSpace(nr.copy(this), t), Math.round(fi(nr.r * 255, 0, 255)) * 65536 + Math.round(fi(nr.g * 255, 0, 255)) * 256 + Math.round(fi(nr.b * 255, 0, 255));
  }
  getHexString(t = kr) {
    return ("000000" + this.getHex(t).toString(16)).slice(-6);
  }
  getHSL(t, r = Jr.workingColorSpace) {
    Jr.fromWorkingColorSpace(nr.copy(this), r);
    const c = nr.r, w = nr.g, R = nr.b, L = Math.max(c, w, R), h = Math.min(c, w, R);
    let b, A;
    const l = (h + L) / 2;
    if (h === L)
      b = 0, A = 0;
    else {
      const o = L - h;
      switch (A = l <= 0.5 ? o / (L + h) : o / (2 - L - h), L) {
        case c:
          b = (w - R) / o + (w < R ? 6 : 0);
          break;
        case w:
          b = (R - c) / o + 2;
          break;
        case R:
          b = (c - w) / o + 4;
          break;
      }
      b /= 6;
    }
    return t.h = b, t.s = A, t.l = l, t;
  }
  getRGB(t, r = Jr.workingColorSpace) {
    return Jr.fromWorkingColorSpace(nr.copy(this), r), t.r = nr.r, t.g = nr.g, t.b = nr.b, t;
  }
  getStyle(t = kr) {
    Jr.fromWorkingColorSpace(nr.copy(this), t);
    const r = nr.r, c = nr.g, w = nr.b;
    return t !== kr ? `color(${t} ${r.toFixed(3)} ${c.toFixed(3)} ${w.toFixed(3)})` : `rgb(${Math.round(r * 255)},${Math.round(c * 255)},${Math.round(w * 255)})`;
  }
  offsetHSL(t, r, c) {
    return this.getHSL(es), this.setHSL(es.h + t, es.s + r, es.l + c);
  }
  add(t) {
    return this.r += t.r, this.g += t.g, this.b += t.b, this;
  }
  addColors(t, r) {
    return this.r = t.r + r.r, this.g = t.g + r.g, this.b = t.b + r.b, this;
  }
  addScalar(t) {
    return this.r += t, this.g += t, this.b += t, this;
  }
  sub(t) {
    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this;
  }
  multiply(t) {
    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this;
  }
  multiplyScalar(t) {
    return this.r *= t, this.g *= t, this.b *= t, this;
  }
  lerp(t, r) {
    return this.r += (t.r - this.r) * r, this.g += (t.g - this.g) * r, this.b += (t.b - this.b) * r, this;
  }
  lerpColors(t, r, c) {
    return this.r = t.r + (r.r - t.r) * c, this.g = t.g + (r.g - t.g) * c, this.b = t.b + (r.b - t.b) * c, this;
  }
  lerpHSL(t, r) {
    this.getHSL(es), t.getHSL(hl);
    const c = wo(es.h, hl.h, r), w = wo(es.s, hl.s, r), R = wo(es.l, hl.l, r);
    return this.setHSL(c, w, R), this;
  }
  setFromVector3(t) {
    return this.r = t.x, this.g = t.y, this.b = t.z, this;
  }
  applyMatrix3(t) {
    const r = this.r, c = this.g, w = this.b, R = t.elements;
    return this.r = R[0] * r + R[3] * c + R[6] * w, this.g = R[1] * r + R[4] * c + R[7] * w, this.b = R[2] * r + R[5] * c + R[8] * w, this;
  }
  equals(t) {
    return t.r === this.r && t.g === this.g && t.b === this.b;
  }
  fromArray(t, r = 0) {
    return this.r = t[r], this.g = t[r + 1], this.b = t[r + 2], this;
  }
  toArray(t = [], r = 0) {
    return t[r] = this.r, t[r + 1] = this.g, t[r + 2] = this.b, t;
  }
  fromBufferAttribute(t, r) {
    return this.r = t.getX(r), this.g = t.getY(r), this.b = t.getZ(r), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const nr = /* @__PURE__ */ new gs();
gs.NAMES = hm;
let lb = 0;
class sd extends Yl {
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: lb++ }), this.uuid = Js(), this.name = "", this.type = "Material", this.blending = rh, this.side = Cl, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = sh, this.blendDst = oh, this.blendEquation = ah, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new gs(0, 0, 0), this.blendAlpha = 0, this.depthFunc = lh, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = hh, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Cs, this.stencilZFail = Cs, this.stencilZPass = Cs, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(t) {
    this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t;
  }
  // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(t) {
    if (t !== void 0)
      for (const r in t) {
        const c = t[r];
        if (c === void 0) {
          console.warn(`THREE.Material: parameter '${r}' has value of undefined.`);
          continue;
        }
        const w = this[r];
        if (w === void 0) {
          console.warn(`THREE.Material: '${r}' is not a property of THREE.${this.type}.`);
          continue;
        }
        w && w.isColor ? w.set(c) : w && w.isVector3 && c && c.isVector3 ? w.copy(c) : this[r] = c;
      }
  }
  toJSON(t) {
    const r = t === void 0 || typeof t == "string";
    r && (t = {
      textures: {},
      images: {}
    });
    const c = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    c.uuid = this.uuid, c.type = this.type, this.name !== "" && (c.name = this.name), this.color && this.color.isColor && (c.color = this.color.getHex()), this.roughness !== void 0 && (c.roughness = this.roughness), this.metalness !== void 0 && (c.metalness = this.metalness), this.sheen !== void 0 && (c.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (c.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (c.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (c.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (c.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (c.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (c.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (c.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (c.shininess = this.shininess), this.clearcoat !== void 0 && (c.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (c.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (c.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (c.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (c.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, c.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (c.dispersion = this.dispersion), this.iridescence !== void 0 && (c.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (c.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (c.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (c.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (c.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.anisotropy !== void 0 && (c.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (c.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (c.anisotropyMap = this.anisotropyMap.toJSON(t).uuid), this.map && this.map.isTexture && (c.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (c.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (c.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (c.lightMap = this.lightMap.toJSON(t).uuid, c.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (c.aoMap = this.aoMap.toJSON(t).uuid, c.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (c.bumpMap = this.bumpMap.toJSON(t).uuid, c.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (c.normalMap = this.normalMap.toJSON(t).uuid, c.normalMapType = this.normalMapType, c.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (c.displacementMap = this.displacementMap.toJSON(t).uuid, c.displacementScale = this.displacementScale, c.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (c.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (c.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (c.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (c.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (c.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (c.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (c.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (c.combine = this.combine)), this.envMapRotation !== void 0 && (c.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (c.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (c.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (c.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (c.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (c.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (c.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (c.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (c.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (c.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (c.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (c.size = this.size), this.shadowSide !== null && (c.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (c.sizeAttenuation = this.sizeAttenuation), this.blending !== rh && (c.blending = this.blending), this.side !== Cl && (c.side = this.side), this.vertexColors === !0 && (c.vertexColors = !0), this.opacity < 1 && (c.opacity = this.opacity), this.transparent === !0 && (c.transparent = !0), this.blendSrc !== sh && (c.blendSrc = this.blendSrc), this.blendDst !== oh && (c.blendDst = this.blendDst), this.blendEquation !== ah && (c.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (c.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (c.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (c.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (c.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (c.blendAlpha = this.blendAlpha), this.depthFunc !== lh && (c.depthFunc = this.depthFunc), this.depthTest === !1 && (c.depthTest = this.depthTest), this.depthWrite === !1 && (c.depthWrite = this.depthWrite), this.colorWrite === !1 && (c.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (c.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== hh && (c.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (c.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (c.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Cs && (c.stencilFail = this.stencilFail), this.stencilZFail !== Cs && (c.stencilZFail = this.stencilZFail), this.stencilZPass !== Cs && (c.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (c.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (c.rotation = this.rotation), this.polygonOffset === !0 && (c.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (c.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (c.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (c.linewidth = this.linewidth), this.dashSize !== void 0 && (c.dashSize = this.dashSize), this.gapSize !== void 0 && (c.gapSize = this.gapSize), this.scale !== void 0 && (c.scale = this.scale), this.dithering === !0 && (c.dithering = !0), this.alphaTest > 0 && (c.alphaTest = this.alphaTest), this.alphaHash === !0 && (c.alphaHash = !0), this.alphaToCoverage === !0 && (c.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (c.premultipliedAlpha = !0), this.forceSinglePass === !0 && (c.forceSinglePass = !0), this.wireframe === !0 && (c.wireframe = !0), this.wireframeLinewidth > 1 && (c.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (c.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (c.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (c.flatShading = !0), this.visible === !1 && (c.visible = !1), this.toneMapped === !1 && (c.toneMapped = !1), this.fog === !1 && (c.fog = !1), Object.keys(this.userData).length > 0 && (c.userData = this.userData);
    function w(R) {
      const L = [];
      for (const h in R) {
        const b = R[h];
        delete b.metadata, L.push(b);
      }
      return L;
    }
    if (r) {
      const R = w(t.textures), L = w(t.images);
      R.length > 0 && (c.textures = R), L.length > 0 && (c.images = L);
    }
    return c;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.blendColor.copy(t.blendColor), this.blendAlpha = t.blendAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite;
    const r = t.clippingPlanes;
    let c = null;
    if (r !== null) {
      const w = r.length;
      c = new Array(w);
      for (let R = 0; R !== w; ++R)
        c[R] = r[R].clone();
    }
    return this.clippingPlanes = c, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaHash = t.alphaHash, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  onBuild() {
    console.warn("Material: onBuild() has been removed.");
  }
}
class ub extends sd {
  constructor(t) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new gs(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ns(), this.combine = wy, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this;
  }
}
const Gi = /* @__PURE__ */ new un(), fl = /* @__PURE__ */ new jr();
let db = 0;
class xr {
  constructor(t, r, c = !1) {
    if (Array.isArray(t))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: db++ }), this.name = "", this.array = t, this.itemSize = r, this.count = t !== void 0 ? t.length / r : 0, this.normalized = c, this.usage = fh, this.updateRanges = [], this.gpuType = ky, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(t) {
    t === !0 && this.version++;
  }
  setUsage(t) {
    return this.usage = t, this;
  }
  addUpdateRange(t, r) {
    this.updateRanges.push({ start: t, count: r });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(t) {
    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this.gpuType = t.gpuType, this;
  }
  copyAt(t, r, c) {
    t *= this.itemSize, c *= r.itemSize;
    for (let w = 0, R = this.itemSize; w < R; w++)
      this.array[t + w] = r.array[c + w];
    return this;
  }
  copyArray(t) {
    return this.array.set(t), this;
  }
  applyMatrix3(t) {
    if (this.itemSize === 2)
      for (let r = 0, c = this.count; r < c; r++)
        fl.fromBufferAttribute(this, r), fl.applyMatrix3(t), this.setXY(r, fl.x, fl.y);
    else if (this.itemSize === 3)
      for (let r = 0, c = this.count; r < c; r++)
        Gi.fromBufferAttribute(this, r), Gi.applyMatrix3(t), this.setXYZ(r, Gi.x, Gi.y, Gi.z);
    return this;
  }
  applyMatrix4(t) {
    for (let r = 0, c = this.count; r < c; r++)
      Gi.fromBufferAttribute(this, r), Gi.applyMatrix4(t), this.setXYZ(r, Gi.x, Gi.y, Gi.z);
    return this;
  }
  applyNormalMatrix(t) {
    for (let r = 0, c = this.count; r < c; r++)
      Gi.fromBufferAttribute(this, r), Gi.applyNormalMatrix(t), this.setXYZ(r, Gi.x, Gi.y, Gi.z);
    return this;
  }
  transformDirection(t) {
    for (let r = 0, c = this.count; r < c; r++)
      Gi.fromBufferAttribute(this, r), Gi.transformDirection(t), this.setXYZ(r, Gi.x, Gi.y, Gi.z);
    return this;
  }
  set(t, r = 0) {
    return this.array.set(t, r), this;
  }
  getComponent(t, r) {
    let c = this.array[t * this.itemSize + r];
    return this.normalized && (c = qs(c, this.array)), c;
  }
  setComponent(t, r, c) {
    return this.normalized && (c = ur(c, this.array)), this.array[t * this.itemSize + r] = c, this;
  }
  getX(t) {
    let r = this.array[t * this.itemSize];
    return this.normalized && (r = qs(r, this.array)), r;
  }
  setX(t, r) {
    return this.normalized && (r = ur(r, this.array)), this.array[t * this.itemSize] = r, this;
  }
  getY(t) {
    let r = this.array[t * this.itemSize + 1];
    return this.normalized && (r = qs(r, this.array)), r;
  }
  setY(t, r) {
    return this.normalized && (r = ur(r, this.array)), this.array[t * this.itemSize + 1] = r, this;
  }
  getZ(t) {
    let r = this.array[t * this.itemSize + 2];
    return this.normalized && (r = qs(r, this.array)), r;
  }
  setZ(t, r) {
    return this.normalized && (r = ur(r, this.array)), this.array[t * this.itemSize + 2] = r, this;
  }
  getW(t) {
    let r = this.array[t * this.itemSize + 3];
    return this.normalized && (r = qs(r, this.array)), r;
  }
  setW(t, r) {
    return this.normalized && (r = ur(r, this.array)), this.array[t * this.itemSize + 3] = r, this;
  }
  setXY(t, r, c) {
    return t *= this.itemSize, this.normalized && (r = ur(r, this.array), c = ur(c, this.array)), this.array[t + 0] = r, this.array[t + 1] = c, this;
  }
  setXYZ(t, r, c, w) {
    return t *= this.itemSize, this.normalized && (r = ur(r, this.array), c = ur(c, this.array), w = ur(w, this.array)), this.array[t + 0] = r, this.array[t + 1] = c, this.array[t + 2] = w, this;
  }
  setXYZW(t, r, c, w, R) {
    return t *= this.itemSize, this.normalized && (r = ur(r, this.array), c = ur(c, this.array), w = ur(w, this.array), R = ur(R, this.array)), this.array[t + 0] = r, this.array[t + 1] = c, this.array[t + 2] = w, this.array[t + 3] = R, this;
  }
  onUpload(t) {
    return this.onUploadCallback = t, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const t = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (t.name = this.name), this.usage !== fh && (t.usage = this.usage), t;
  }
}
class fm extends xr {
  constructor(t, r, c) {
    super(new Uint16Array(t), r, c);
  }
}
class mm extends xr {
  constructor(t, r, c) {
    super(new Uint32Array(t), r, c);
  }
}
class pm extends xr {
  constructor(t, r, c) {
    super(new Float32Array(t), r, c);
  }
}
let cb = 0;
const Ur = /* @__PURE__ */ new Br(), xu = /* @__PURE__ */ new Ea(), Hs = /* @__PURE__ */ new un(), Mr = /* @__PURE__ */ new Lo(), _o = /* @__PURE__ */ new Lo(), Ki = /* @__PURE__ */ new un();
class _s extends Yl {
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: cb++ }), this.uuid = Js(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(t) {
    return Array.isArray(t) ? this.index = new (Wy(t) ? mm : fm)(t, 1) : this.index = t, this;
  }
  setIndirect(t) {
    return this.indirect = t, this;
  }
  getIndirect() {
    return this.indirect;
  }
  getAttribute(t) {
    return this.attributes[t];
  }
  setAttribute(t, r) {
    return this.attributes[t] = r, this;
  }
  deleteAttribute(t) {
    return delete this.attributes[t], this;
  }
  hasAttribute(t) {
    return this.attributes[t] !== void 0;
  }
  addGroup(t, r, c = 0) {
    this.groups.push({
      start: t,
      count: r,
      materialIndex: c
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(t, r) {
    this.drawRange.start = t, this.drawRange.count = r;
  }
  applyMatrix4(t) {
    const r = this.attributes.position;
    r !== void 0 && (r.applyMatrix4(t), r.needsUpdate = !0);
    const c = this.attributes.normal;
    if (c !== void 0) {
      const R = new as().getNormalMatrix(t);
      c.applyNormalMatrix(R), c.needsUpdate = !0;
    }
    const w = this.attributes.tangent;
    return w !== void 0 && (w.transformDirection(t), w.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(t) {
    return Ur.makeRotationFromQuaternion(t), this.applyMatrix4(Ur), this;
  }
  rotateX(t) {
    return Ur.makeRotationX(t), this.applyMatrix4(Ur), this;
  }
  rotateY(t) {
    return Ur.makeRotationY(t), this.applyMatrix4(Ur), this;
  }
  rotateZ(t) {
    return Ur.makeRotationZ(t), this.applyMatrix4(Ur), this;
  }
  translate(t, r, c) {
    return Ur.makeTranslation(t, r, c), this.applyMatrix4(Ur), this;
  }
  scale(t, r, c) {
    return Ur.makeScale(t, r, c), this.applyMatrix4(Ur), this;
  }
  lookAt(t) {
    return xu.lookAt(t), xu.updateMatrix(), this.applyMatrix4(xu.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Hs).negate(), this.translate(Hs.x, Hs.y, Hs.z), this;
  }
  setFromPoints(t) {
    const r = this.getAttribute("position");
    if (r === void 0) {
      const c = [];
      for (let w = 0, R = t.length; w < R; w++) {
        const L = t[w];
        c.push(L.x, L.y, L.z || 0);
      }
      this.setAttribute("position", new pm(c, 3));
    } else {
      const c = Math.min(t.length, r.count);
      for (let w = 0; w < c; w++) {
        const R = t[w];
        r.setXYZ(w, R.x, R.y, R.z || 0);
      }
      t.length > r.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), r.needsUpdate = !0;
    }
    return this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Lo());
    const t = this.attributes.position, r = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new un(-1 / 0, -1 / 0, -1 / 0),
        new un(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (t !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(t), r)
        for (let c = 0, w = r.length; c < w; c++) {
          const R = r[c];
          Mr.setFromBufferAttribute(R), this.morphTargetsRelative ? (Ki.addVectors(this.boundingBox.min, Mr.min), this.boundingBox.expandByPoint(Ki), Ki.addVectors(this.boundingBox.max, Mr.max), this.boundingBox.expandByPoint(Ki)) : (this.boundingBox.expandByPoint(Mr.min), this.boundingBox.expandByPoint(Mr.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new cm());
    const t = this.attributes.position, r = this.morphAttributes.position;
    if (t && t.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new un(), 1 / 0);
      return;
    }
    if (t) {
      const c = this.boundingSphere.center;
      if (Mr.setFromBufferAttribute(t), r)
        for (let R = 0, L = r.length; R < L; R++) {
          const h = r[R];
          _o.setFromBufferAttribute(h), this.morphTargetsRelative ? (Ki.addVectors(Mr.min, _o.min), Mr.expandByPoint(Ki), Ki.addVectors(Mr.max, _o.max), Mr.expandByPoint(Ki)) : (Mr.expandByPoint(_o.min), Mr.expandByPoint(_o.max));
        }
      Mr.getCenter(c);
      let w = 0;
      for (let R = 0, L = t.count; R < L; R++)
        Ki.fromBufferAttribute(t, R), w = Math.max(w, c.distanceToSquared(Ki));
      if (r)
        for (let R = 0, L = r.length; R < L; R++) {
          const h = r[R], b = this.morphTargetsRelative;
          for (let A = 0, l = h.count; A < l; A++)
            Ki.fromBufferAttribute(h, A), b && (Hs.fromBufferAttribute(t, A), Ki.add(Hs)), w = Math.max(w, c.distanceToSquared(Ki));
        }
      this.boundingSphere.radius = Math.sqrt(w), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const t = this.index, r = this.attributes;
    if (t === null || r.position === void 0 || r.normal === void 0 || r.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const c = r.position, w = r.normal, R = r.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new xr(new Float32Array(4 * c.count), 4));
    const L = this.getAttribute("tangent"), h = [], b = [];
    for (let dt = 0; dt < c.count; dt++)
      h[dt] = new un(), b[dt] = new un();
    const A = new un(), l = new un(), o = new un(), u = new jr(), g = new jr(), m = new jr(), S = new un(), e = new un();
    function n(dt, xt, Nt) {
      A.fromBufferAttribute(c, dt), l.fromBufferAttribute(c, xt), o.fromBufferAttribute(c, Nt), u.fromBufferAttribute(R, dt), g.fromBufferAttribute(R, xt), m.fromBufferAttribute(R, Nt), l.sub(A), o.sub(A), g.sub(u), m.sub(u);
      const jt = 1 / (g.x * m.y - m.x * g.y);
      isFinite(jt) && (S.copy(l).multiplyScalar(m.y).addScaledVector(o, -g.y).multiplyScalar(jt), e.copy(o).multiplyScalar(g.x).addScaledVector(l, -m.x).multiplyScalar(jt), h[dt].add(S), h[xt].add(S), h[Nt].add(S), b[dt].add(e), b[xt].add(e), b[Nt].add(e));
    }
    let d = this.groups;
    d.length === 0 && (d = [{
      start: 0,
      count: t.count
    }]);
    for (let dt = 0, xt = d.length; dt < xt; ++dt) {
      const Nt = d[dt], jt = Nt.start, q = Nt.count;
      for (let I = jt, pt = jt + q; I < pt; I += 3)
        n(
          t.getX(I + 0),
          t.getX(I + 1),
          t.getX(I + 2)
        );
    }
    const _ = new un(), p = new un(), P = new un(), $ = new un();
    function ot(dt) {
      P.fromBufferAttribute(w, dt), $.copy(P);
      const xt = h[dt];
      _.copy(xt), _.sub(P.multiplyScalar(P.dot(xt))).normalize(), p.crossVectors($, xt);
      const jt = p.dot(b[dt]) < 0 ? -1 : 1;
      L.setXYZW(dt, _.x, _.y, _.z, jt);
    }
    for (let dt = 0, xt = d.length; dt < xt; ++dt) {
      const Nt = d[dt], jt = Nt.start, q = Nt.count;
      for (let I = jt, pt = jt + q; I < pt; I += 3)
        ot(t.getX(I + 0)), ot(t.getX(I + 1)), ot(t.getX(I + 2));
    }
  }
  computeVertexNormals() {
    const t = this.index, r = this.getAttribute("position");
    if (r !== void 0) {
      let c = this.getAttribute("normal");
      if (c === void 0)
        c = new xr(new Float32Array(r.count * 3), 3), this.setAttribute("normal", c);
      else
        for (let u = 0, g = c.count; u < g; u++)
          c.setXYZ(u, 0, 0, 0);
      const w = new un(), R = new un(), L = new un(), h = new un(), b = new un(), A = new un(), l = new un(), o = new un();
      if (t)
        for (let u = 0, g = t.count; u < g; u += 3) {
          const m = t.getX(u + 0), S = t.getX(u + 1), e = t.getX(u + 2);
          w.fromBufferAttribute(r, m), R.fromBufferAttribute(r, S), L.fromBufferAttribute(r, e), l.subVectors(L, R), o.subVectors(w, R), l.cross(o), h.fromBufferAttribute(c, m), b.fromBufferAttribute(c, S), A.fromBufferAttribute(c, e), h.add(l), b.add(l), A.add(l), c.setXYZ(m, h.x, h.y, h.z), c.setXYZ(S, b.x, b.y, b.z), c.setXYZ(e, A.x, A.y, A.z);
        }
      else
        for (let u = 0, g = r.count; u < g; u += 3)
          w.fromBufferAttribute(r, u + 0), R.fromBufferAttribute(r, u + 1), L.fromBufferAttribute(r, u + 2), l.subVectors(L, R), o.subVectors(w, R), l.cross(o), c.setXYZ(u + 0, l.x, l.y, l.z), c.setXYZ(u + 1, l.x, l.y, l.z), c.setXYZ(u + 2, l.x, l.y, l.z);
      this.normalizeNormals(), c.needsUpdate = !0;
    }
  }
  normalizeNormals() {
    const t = this.attributes.normal;
    for (let r = 0, c = t.count; r < c; r++)
      Ki.fromBufferAttribute(t, r), Ki.normalize(), t.setXYZ(r, Ki.x, Ki.y, Ki.z);
  }
  toNonIndexed() {
    function t(h, b) {
      const A = h.array, l = h.itemSize, o = h.normalized, u = new A.constructor(b.length * l);
      let g = 0, m = 0;
      for (let S = 0, e = b.length; S < e; S++) {
        h.isInterleavedBufferAttribute ? g = b[S] * h.data.stride + h.offset : g = b[S] * l;
        for (let n = 0; n < l; n++)
          u[m++] = A[g++];
      }
      return new xr(u, l, o);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const r = new _s(), c = this.index.array, w = this.attributes;
    for (const h in w) {
      const b = w[h], A = t(b, c);
      r.setAttribute(h, A);
    }
    const R = this.morphAttributes;
    for (const h in R) {
      const b = [], A = R[h];
      for (let l = 0, o = A.length; l < o; l++) {
        const u = A[l], g = t(u, c);
        b.push(g);
      }
      r.morphAttributes[h] = b;
    }
    r.morphTargetsRelative = this.morphTargetsRelative;
    const L = this.groups;
    for (let h = 0, b = L.length; h < b; h++) {
      const A = L[h];
      r.addGroup(A.start, A.count, A.materialIndex);
    }
    return r;
  }
  toJSON() {
    const t = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) {
      const b = this.parameters;
      for (const A in b)
        b[A] !== void 0 && (t[A] = b[A]);
      return t;
    }
    t.data = { attributes: {} };
    const r = this.index;
    r !== null && (t.data.index = {
      type: r.array.constructor.name,
      array: Array.prototype.slice.call(r.array)
    });
    const c = this.attributes;
    for (const b in c) {
      const A = c[b];
      t.data.attributes[b] = A.toJSON(t.data);
    }
    const w = {};
    let R = !1;
    for (const b in this.morphAttributes) {
      const A = this.morphAttributes[b], l = [];
      for (let o = 0, u = A.length; o < u; o++) {
        const g = A[o];
        l.push(g.toJSON(t.data));
      }
      l.length > 0 && (w[b] = l, R = !0);
    }
    R && (t.data.morphAttributes = w, t.data.morphTargetsRelative = this.morphTargetsRelative);
    const L = this.groups;
    L.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(L)));
    const h = this.boundingSphere;
    return h !== null && (t.data.boundingSphere = {
      center: h.center.toArray(),
      radius: h.radius
    }), t;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(t) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const r = {};
    this.name = t.name;
    const c = t.index;
    c !== null && this.setIndex(c.clone(r));
    const w = t.attributes;
    for (const A in w) {
      const l = w[A];
      this.setAttribute(A, l.clone(r));
    }
    const R = t.morphAttributes;
    for (const A in R) {
      const l = [], o = R[A];
      for (let u = 0, g = o.length; u < g; u++)
        l.push(o[u].clone(r));
      this.morphAttributes[A] = l;
    }
    this.morphTargetsRelative = t.morphTargetsRelative;
    const L = t.groups;
    for (let A = 0, l = L.length; A < l; A++) {
      const o = L[A];
      this.addGroup(o.start, o.count, o.materialIndex);
    }
    const h = t.boundingBox;
    h !== null && (this.boundingBox = h.clone());
    const b = t.boundingSphere;
    return b !== null && (this.boundingSphere = b.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const kh = /* @__PURE__ */ new Br(), ps = /* @__PURE__ */ new tb(), ml = /* @__PURE__ */ new cm(), xh = /* @__PURE__ */ new un(), pl = /* @__PURE__ */ new un(), gl = /* @__PURE__ */ new un(), _l = /* @__PURE__ */ new un(), Lu = /* @__PURE__ */ new un(), yl = /* @__PURE__ */ new un(), Lh = /* @__PURE__ */ new un(), bl = /* @__PURE__ */ new un();
class hb extends Ea {
  constructor(t = new _s(), r = new ub()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = r, this.updateMorphTargets();
  }
  copy(t, r) {
    return super.copy(t, r), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = Array.isArray(t.material) ? t.material.slice() : t.material, this.geometry = t.geometry, this;
  }
  updateMorphTargets() {
    const r = this.geometry.morphAttributes, c = Object.keys(r);
    if (c.length > 0) {
      const w = r[c[0]];
      if (w !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let R = 0, L = w.length; R < L; R++) {
          const h = w[R].name || String(R);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[h] = R;
        }
      }
    }
  }
  getVertexPosition(t, r) {
    const c = this.geometry, w = c.attributes.position, R = c.morphAttributes.position, L = c.morphTargetsRelative;
    r.fromBufferAttribute(w, t);
    const h = this.morphTargetInfluences;
    if (R && h) {
      yl.set(0, 0, 0);
      for (let b = 0, A = R.length; b < A; b++) {
        const l = h[b], o = R[b];
        l !== 0 && (Lu.fromBufferAttribute(o, t), L ? yl.addScaledVector(Lu, l) : yl.addScaledVector(Lu.sub(r), l));
      }
      r.add(yl);
    }
    return r;
  }
  raycast(t, r) {
    const c = this.geometry, w = this.material, R = this.matrixWorld;
    w !== void 0 && (c.boundingSphere === null && c.computeBoundingSphere(), ml.copy(c.boundingSphere), ml.applyMatrix4(R), ps.copy(t.ray).recast(t.near), !(ml.containsPoint(ps.origin) === !1 && (ps.intersectSphere(ml, xh) === null || ps.origin.distanceToSquared(xh) > (t.far - t.near) ** 2)) && (kh.copy(R).invert(), ps.copy(t.ray).applyMatrix4(kh), !(c.boundingBox !== null && ps.intersectsBox(c.boundingBox) === !1) && this._computeIntersections(t, r, ps)));
  }
  _computeIntersections(t, r, c) {
    let w;
    const R = this.geometry, L = this.material, h = R.index, b = R.attributes.position, A = R.attributes.uv, l = R.attributes.uv1, o = R.attributes.normal, u = R.groups, g = R.drawRange;
    if (h !== null)
      if (Array.isArray(L))
        for (let m = 0, S = u.length; m < S; m++) {
          const e = u[m], n = L[e.materialIndex], d = Math.max(e.start, g.start), _ = Math.min(h.count, Math.min(e.start + e.count, g.start + g.count));
          for (let p = d, P = _; p < P; p += 3) {
            const $ = h.getX(p), ot = h.getX(p + 1), dt = h.getX(p + 2);
            w = El(this, n, t, c, A, l, o, $, ot, dt), w && (w.faceIndex = Math.floor(p / 3), w.face.materialIndex = e.materialIndex, r.push(w));
          }
        }
      else {
        const m = Math.max(0, g.start), S = Math.min(h.count, g.start + g.count);
        for (let e = m, n = S; e < n; e += 3) {
          const d = h.getX(e), _ = h.getX(e + 1), p = h.getX(e + 2);
          w = El(this, L, t, c, A, l, o, d, _, p), w && (w.faceIndex = Math.floor(e / 3), r.push(w));
        }
      }
    else if (b !== void 0)
      if (Array.isArray(L))
        for (let m = 0, S = u.length; m < S; m++) {
          const e = u[m], n = L[e.materialIndex], d = Math.max(e.start, g.start), _ = Math.min(b.count, Math.min(e.start + e.count, g.start + g.count));
          for (let p = d, P = _; p < P; p += 3) {
            const $ = p, ot = p + 1, dt = p + 2;
            w = El(this, n, t, c, A, l, o, $, ot, dt), w && (w.faceIndex = Math.floor(p / 3), w.face.materialIndex = e.materialIndex, r.push(w));
          }
        }
      else {
        const m = Math.max(0, g.start), S = Math.min(b.count, g.start + g.count);
        for (let e = m, n = S; e < n; e += 3) {
          const d = e, _ = e + 1, p = e + 2;
          w = El(this, L, t, c, A, l, o, d, _, p), w && (w.faceIndex = Math.floor(e / 3), r.push(w));
        }
      }
  }
}
function fb(Et, t, r, c, w, R, L, h) {
  let b;
  if (t.side === Ty ? b = c.intersectTriangle(L, R, w, !0, h) : b = c.intersectTriangle(w, R, L, t.side === Cl, h), b === null) return null;
  bl.copy(h), bl.applyMatrix4(Et.matrixWorld);
  const A = r.ray.origin.distanceTo(bl);
  return A < r.near || A > r.far ? null : {
    distance: A,
    point: bl.clone(),
    object: Et
  };
}
function El(Et, t, r, c, w, R, L, h, b, A) {
  Et.getVertexPosition(h, pl), Et.getVertexPosition(b, gl), Et.getVertexPosition(A, _l);
  const l = fb(Et, t, r, c, pl, gl, _l, Lh);
  if (l) {
    const o = new un();
    na.getBarycoord(Lh, pl, gl, _l, o), w && (l.uv = na.getInterpolatedAttribute(w, h, b, A, o, new jr())), R && (l.uv1 = na.getInterpolatedAttribute(R, h, b, A, o, new jr())), L && (l.normal = na.getInterpolatedAttribute(L, h, b, A, o, new un()), l.normal.dot(c.direction) > 0 && l.normal.multiplyScalar(-1));
    const u = {
      a: h,
      b,
      c: A,
      normal: new un(),
      materialIndex: 0
    };
    na.getNormal(pl, gl, _l, u.normal), l.face = u, l.barycoord = o;
  }
  return l;
}
function od(Et) {
  const t = {};
  for (const r in Et) {
    t[r] = {};
    for (const c in Et[r]) {
      const w = Et[r][c];
      w && (w.isColor || w.isMatrix3 || w.isMatrix4 || w.isVector2 || w.isVector3 || w.isVector4 || w.isTexture || w.isQuaternion) ? w.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), t[r][c] = null) : t[r][c] = w.clone() : Array.isArray(w) ? t[r][c] = w.slice() : t[r][c] = w;
    }
  }
  return t;
}
function mb(Et) {
  const t = {};
  for (let r = 0; r < Et.length; r++) {
    const c = od(Et[r]);
    for (const w in c)
      t[w] = c[w];
  }
  return t;
}
function pb(Et) {
  const t = [];
  for (let r = 0; r < Et.length; r++)
    t.push(Et[r].clone());
  return t;
}
const gb = { clone: od, merge: mb };
var _b = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, yb = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Dh extends sd {
  constructor(t) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = _b, this.fragmentShader = yb, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = od(t.uniforms), this.uniformsGroups = pb(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this;
  }
  toJSON(t) {
    const r = super.toJSON(t);
    r.glslVersion = this.glslVersion, r.uniforms = {};
    for (const w in this.uniforms) {
      const L = this.uniforms[w].value;
      L && L.isTexture ? r.uniforms[w] = {
        type: "t",
        value: L.toJSON(t).uuid
      } : L && L.isColor ? r.uniforms[w] = {
        type: "c",
        value: L.getHex()
      } : L && L.isVector2 ? r.uniforms[w] = {
        type: "v2",
        value: L.toArray()
      } : L && L.isVector3 ? r.uniforms[w] = {
        type: "v3",
        value: L.toArray()
      } : L && L.isVector4 ? r.uniforms[w] = {
        type: "v4",
        value: L.toArray()
      } : L && L.isMatrix3 ? r.uniforms[w] = {
        type: "m3",
        value: L.toArray()
      } : L && L.isMatrix4 ? r.uniforms[w] = {
        type: "m4",
        value: L.toArray()
      } : r.uniforms[w] = {
        value: L
      };
    }
    Object.keys(this.defines).length > 0 && (r.defines = this.defines), r.vertexShader = this.vertexShader, r.fragmentShader = this.fragmentShader, r.lights = this.lights, r.clipping = this.clipping;
    const c = {};
    for (const w in this.extensions)
      this.extensions[w] === !0 && (c[w] = !0);
    return Object.keys(c).length > 0 && (r.extensions = c), r;
  }
}
class cv extends Ea {
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new ns(), this.environmentIntensity = 1, this.environmentRotation = new ns(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(t, r) {
    return super.copy(t, r), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, this.backgroundRotation.copy(t.backgroundRotation), this.environmentIntensity = t.environmentIntensity, this.environmentRotation.copy(t.environmentRotation), t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this;
  }
  toJSON(t) {
    const r = super.toJSON(t);
    return this.fog !== null && (r.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (r.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (r.object.backgroundIntensity = this.backgroundIntensity), r.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (r.object.environmentIntensity = this.environmentIntensity), r.object.environmentRotation = this.environmentRotation.toArray(), r;
  }
}
class hv extends Ya {
  constructor(t, r, c, w, R, L, h, b, A, l, o, u) {
    super(null, L, h, b, A, l, w, R, o, u), this.isCompressedTexture = !0, this.image = { width: r, height: c }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1;
  }
}
class Ih extends sd {
  constructor(t) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new gs(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new gs(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ly, this.normalScale = new jr(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new ns(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(t);
  }
  copy(t) {
    return super.copy(t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapRotation.copy(t.envMapRotation), this.envMapIntensity = t.envMapIntensity, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.flatShading = t.flatShading, this.fog = t.fog, this;
  }
}
const Pl = {
  enabled: !1,
  files: {},
  add: function(Et, t) {
    this.enabled !== !1 && (this.files[Et] = t);
  },
  get: function(Et) {
    if (this.enabled !== !1)
      return this.files[Et];
  },
  remove: function(Et) {
    delete this.files[Et];
  },
  clear: function() {
    this.files = {};
  }
};
class bb {
  constructor(t, r, c) {
    const w = this;
    let R = !1, L = 0, h = 0, b;
    const A = [];
    this.onStart = void 0, this.onLoad = t, this.onProgress = r, this.onError = c, this.itemStart = function(l) {
      h++, R === !1 && w.onStart !== void 0 && w.onStart(l, L, h), R = !0;
    }, this.itemEnd = function(l) {
      L++, w.onProgress !== void 0 && w.onProgress(l, L, h), L === h && (R = !1, w.onLoad !== void 0 && w.onLoad());
    }, this.itemError = function(l) {
      w.onError !== void 0 && w.onError(l);
    }, this.resolveURL = function(l) {
      return b ? b(l) : l;
    }, this.setURLModifier = function(l) {
      return b = l, this;
    }, this.addHandler = function(l, o) {
      return A.push(l, o), this;
    }, this.removeHandler = function(l) {
      const o = A.indexOf(l);
      return o !== -1 && A.splice(o, 2), this;
    }, this.getHandler = function(l) {
      for (let o = 0, u = A.length; o < u; o += 2) {
        const g = A[o], m = A[o + 1];
        if (g.global && (g.lastIndex = 0), g.test(l))
          return m;
      }
      return null;
    };
  }
}
const gm = /* @__PURE__ */ new bb();
class Do {
  constructor(t) {
    this.manager = t !== void 0 ? t : gm, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(t, r) {
    const c = this;
    return new Promise(function(w, R) {
      c.load(t, w, r, R);
    });
  }
  parse() {
  }
  setCrossOrigin(t) {
    return this.crossOrigin = t, this;
  }
  setWithCredentials(t) {
    return this.withCredentials = t, this;
  }
  setPath(t) {
    return this.path = t, this;
  }
  setResourcePath(t) {
    return this.resourcePath = t, this;
  }
  setRequestHeader(t) {
    return this.requestHeader = t, this;
  }
}
Do.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Na = {};
class Eb extends Error {
  constructor(t, r) {
    super(t), this.response = r;
  }
}
class Rh extends Do {
  constructor(t) {
    super(t);
  }
  load(t, r, c, w) {
    t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const R = Pl.get(t);
    if (R !== void 0)
      return this.manager.itemStart(t), setTimeout(() => {
        r && r(R), this.manager.itemEnd(t);
      }, 0), R;
    if (Na[t] !== void 0) {
      Na[t].push({
        onLoad: r,
        onProgress: c,
        onError: w
      });
      return;
    }
    Na[t] = [], Na[t].push({
      onLoad: r,
      onProgress: c,
      onError: w
    });
    const L = new Request(t, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    }), h = this.mimeType, b = this.responseType;
    fetch(L).then((A) => {
      if (A.status === 200 || A.status === 0) {
        if (A.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || A.body === void 0 || A.body.getReader === void 0)
          return A;
        const l = Na[t], o = A.body.getReader(), u = A.headers.get("X-File-Size") || A.headers.get("Content-Length"), g = u ? parseInt(u) : 0, m = g !== 0;
        let S = 0;
        const e = new ReadableStream({
          start(n) {
            d();
            function d() {
              o.read().then(({ done: _, value: p }) => {
                if (_)
                  n.close();
                else {
                  S += p.byteLength;
                  const P = new ProgressEvent("progress", { lengthComputable: m, loaded: S, total: g });
                  for (let $ = 0, ot = l.length; $ < ot; $++) {
                    const dt = l[$];
                    dt.onProgress && dt.onProgress(P);
                  }
                  n.enqueue(p), d();
                }
              }, (_) => {
                n.error(_);
              });
            }
          }
        });
        return new Response(e);
      } else
        throw new Eb(`fetch for "${A.url}" responded with ${A.status}: ${A.statusText}`, A);
    }).then((A) => {
      switch (b) {
        case "arraybuffer":
          return A.arrayBuffer();
        case "blob":
          return A.blob();
        case "document":
          return A.text().then((l) => new DOMParser().parseFromString(l, h));
        case "json":
          return A.json();
        default:
          if (h === void 0)
            return A.text();
          {
            const o = /charset="?([^;"\s]*)"?/i.exec(h), u = o && o[1] ? o[1].toLowerCase() : void 0, g = new TextDecoder(u);
            return A.arrayBuffer().then((m) => g.decode(m));
          }
      }
    }).then((A) => {
      Pl.add(t, A);
      const l = Na[t];
      delete Na[t];
      for (let o = 0, u = l.length; o < u; o++) {
        const g = l[o];
        g.onLoad && g.onLoad(A);
      }
    }).catch((A) => {
      const l = Na[t];
      if (l === void 0)
        throw this.manager.itemError(t), A;
      delete Na[t];
      for (let o = 0, u = l.length; o < u; o++) {
        const g = l[o];
        g.onError && g.onError(A);
      }
      this.manager.itemError(t);
    }).finally(() => {
      this.manager.itemEnd(t);
    }), this.manager.itemStart(t);
  }
  setResponseType(t) {
    return this.responseType = t, this;
  }
  setMimeType(t) {
    return this.mimeType = t, this;
  }
}
class vb extends Do {
  constructor(t) {
    super(t);
  }
  load(t, r, c, w) {
    this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t);
    const R = this, L = Pl.get(t);
    if (L !== void 0)
      return R.manager.itemStart(t), setTimeout(function() {
        r && r(L), R.manager.itemEnd(t);
      }, 0), L;
    const h = Qu("img");
    function b() {
      l(), Pl.add(t, this), r && r(this), R.manager.itemEnd(t);
    }
    function A(o) {
      l(), w && w(o), R.manager.itemError(t), R.manager.itemEnd(t);
    }
    function l() {
      h.removeEventListener("load", b, !1), h.removeEventListener("error", A, !1);
    }
    return h.addEventListener("load", b, !1), h.addEventListener("error", A, !1), t.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (h.crossOrigin = this.crossOrigin), R.manager.itemStart(t), h.src = t, h;
  }
}
class Tb extends Do {
  constructor(t) {
    super(t);
  }
  load(t, r, c, w) {
    const R = new Ya(), L = new vb(this.manager);
    return L.setCrossOrigin(this.crossOrigin), L.setPath(this.path), L.load(t, function(h) {
      R.image = h, R.needsUpdate = !0, r !== void 0 && r(R);
    }, c, w), R;
  }
}
const ld = "\\[\\]\\.:\\/", wb = new RegExp("[" + ld + "]", "g"), ud = "[^" + ld + "]", Ab = "[^" + ld.replace("\\.", "") + "]", Sb = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", ud), Mb = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", Ab), kb = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", ud), xb = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", ud), Lb = new RegExp(
  "^" + Sb + Mb + kb + xb + "$"
), Db = ["material", "materials", "bones", "map"];
class Ib {
  constructor(t, r, c) {
    const w = c || ki.parseTrackName(r);
    this._targetGroup = t, this._bindings = t.subscribe_(r, w);
  }
  getValue(t, r) {
    this.bind();
    const c = this._targetGroup.nCachedObjects_, w = this._bindings[c];
    w !== void 0 && w.getValue(t, r);
  }
  setValue(t, r) {
    const c = this._bindings;
    for (let w = this._targetGroup.nCachedObjects_, R = c.length; w !== R; ++w)
      c[w].setValue(t, r);
  }
  bind() {
    const t = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, c = t.length; r !== c; ++r)
      t[r].bind();
  }
  unbind() {
    const t = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, c = t.length; r !== c; ++r)
      t[r].unbind();
  }
}
class ki {
  constructor(t, r, c) {
    this.path = r, this.parsedPath = c || ki.parseTrackName(r), this.node = ki.findNode(t, this.parsedPath.nodeName), this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(t, r, c) {
    return t && t.isAnimationObjectGroup ? new ki.Composite(t, r, c) : new ki(t, r, c);
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(t) {
    return t.replace(/\s/g, "_").replace(wb, "");
  }
  static parseTrackName(t) {
    const r = Lb.exec(t);
    if (r === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + t);
    const c = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: r[2],
      objectName: r[3],
      objectIndex: r[4],
      propertyName: r[5],
      // required
      propertyIndex: r[6]
    }, w = c.nodeName && c.nodeName.lastIndexOf(".");
    if (w !== void 0 && w !== -1) {
      const R = c.nodeName.substring(w + 1);
      Db.indexOf(R) !== -1 && (c.nodeName = c.nodeName.substring(0, w), c.objectName = R);
    }
    if (c.propertyName === null || c.propertyName.length === 0)
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
    return c;
  }
  static findNode(t, r) {
    if (r === void 0 || r === "" || r === "." || r === -1 || r === t.name || r === t.uuid)
      return t;
    if (t.skeleton) {
      const c = t.skeleton.getBoneByName(r);
      if (c !== void 0)
        return c;
    }
    if (t.children) {
      const c = function(R) {
        for (let L = 0; L < R.length; L++) {
          const h = R[L];
          if (h.name === r || h.uuid === r)
            return h;
          const b = c(h.children);
          if (b) return b;
        }
        return null;
      }, w = c(t.children);
      if (w)
        return w;
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(t, r) {
    t[r] = this.targetObject[this.propertyName];
  }
  _getValue_array(t, r) {
    const c = this.resolvedProperty;
    for (let w = 0, R = c.length; w !== R; ++w)
      t[r++] = c[w];
  }
  _getValue_arrayElement(t, r) {
    t[r] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(t, r) {
    this.resolvedProperty.toArray(t, r);
  }
  // Direct
  _setValue_direct(t, r) {
    this.targetObject[this.propertyName] = t[r];
  }
  _setValue_direct_setNeedsUpdate(t, r) {
    this.targetObject[this.propertyName] = t[r], this.targetObject.needsUpdate = !0;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(t, r) {
    this.targetObject[this.propertyName] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // EntireArray
  _setValue_array(t, r) {
    const c = this.resolvedProperty;
    for (let w = 0, R = c.length; w !== R; ++w)
      c[w] = t[r++];
  }
  _setValue_array_setNeedsUpdate(t, r) {
    const c = this.resolvedProperty;
    for (let w = 0, R = c.length; w !== R; ++w)
      c[w] = t[r++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(t, r) {
    const c = this.resolvedProperty;
    for (let w = 0, R = c.length; w !== R; ++w)
      c[w] = t[r++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // ArrayElement
  _setValue_arrayElement(t, r) {
    this.resolvedProperty[this.propertyIndex] = t[r];
  }
  _setValue_arrayElement_setNeedsUpdate(t, r) {
    this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.needsUpdate = !0;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, r) {
    this.resolvedProperty[this.propertyIndex] = t[r], this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  // HasToFromArray
  _setValue_fromArray(t, r) {
    this.resolvedProperty.fromArray(t, r);
  }
  _setValue_fromArray_setNeedsUpdate(t, r) {
    this.resolvedProperty.fromArray(t, r), this.targetObject.needsUpdate = !0;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(t, r) {
    this.resolvedProperty.fromArray(t, r), this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _getValue_unbound(t, r) {
    this.bind(), this.getValue(t, r);
  }
  _setValue_unbound(t, r) {
    this.bind(), this.setValue(t, r);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let t = this.node;
    const r = this.parsedPath, c = r.objectName, w = r.propertyName;
    let R = r.propertyIndex;
    if (t || (t = ki.findNode(this.rootNode, r.nodeName), this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (c) {
      let A = r.objectIndex;
      switch (c) {
        case "materials":
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          t = t.material.materials;
          break;
        case "bones":
          if (!t.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          t = t.skeleton.bones;
          for (let l = 0; l < t.length; l++)
            if (t[l].name === A) {
              A = l;
              break;
            }
          break;
        case "map":
          if ("map" in t) {
            t = t.map;
            break;
          }
          if (!t.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!t.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          t = t.material.map;
          break;
        default:
          if (t[c] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          t = t[c];
      }
      if (A !== void 0) {
        if (t[A] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
          return;
        }
        t = t[A];
      }
    }
    const L = t[w];
    if (L === void 0) {
      const A = r.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + A + "." + w + " but it wasn't found.", t);
      return;
    }
    let h = this.Versioning.None;
    this.targetObject = t, t.isMaterial === !0 ? h = this.Versioning.NeedsUpdate : t.isObject3D === !0 && (h = this.Versioning.MatrixWorldNeedsUpdate);
    let b = this.BindingType.Direct;
    if (R !== void 0) {
      if (w === "morphTargetInfluences") {
        if (!t.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!t.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        t.morphTargetDictionary[R] !== void 0 && (R = t.morphTargetDictionary[R]);
      }
      b = this.BindingType.ArrayElement, this.resolvedProperty = L, this.propertyIndex = R;
    } else L.fromArray !== void 0 && L.toArray !== void 0 ? (b = this.BindingType.HasFromToArray, this.resolvedProperty = L) : Array.isArray(L) ? (b = this.BindingType.EntireArray, this.resolvedProperty = L) : this.propertyName = w;
    this.getValue = this.GetterByBindingType[b], this.setValue = this.SetterByBindingTypeAndVersioning[b][h];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
ki.Composite = Ib;
ki.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
ki.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
ki.prototype.GetterByBindingType = [
  ki.prototype._getValue_direct,
  ki.prototype._getValue_array,
  ki.prototype._getValue_arrayElement,
  ki.prototype._getValue_toArray
];
ki.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    ki.prototype._setValue_direct,
    ki.prototype._setValue_direct_setNeedsUpdate,
    ki.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    ki.prototype._setValue_array,
    ki.prototype._setValue_array_setNeedsUpdate,
    ki.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    ki.prototype._setValue_arrayElement,
    ki.prototype._setValue_arrayElement_setNeedsUpdate,
    ki.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    ki.prototype._setValue_fromArray,
    ki.prototype._setValue_fromArray_setNeedsUpdate,
    ki.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
class Ws {
  constructor(t) {
    this.value = t;
  }
  clone() {
    return new Ws(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
  revision: sm
} }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = sm);
class Rb {
  constructor(t) {
    if (this.numWorkers = 1, this.workers = [], this.currentIndex = 0, this.onWorkerMessage = (r) => {
      this.onmessage(r);
    }, this.onWorkerError = (r) => {
      this.onerror(r);
    }, typeof t == "number") {
      if (t < 1)
        throw new Error("numWorkers must be greater than 0");
      this.numWorkers = t;
    }
    this.setupWorkers();
  }
  setupWorkers() {
    const { workers: t, numWorkers: r } = this;
    for (let c = 0; c < r; ++c) {
      const w = new Worker(
        new URL(
          /* @vite-ignore */
          "/assets/DecodeWorker-D-I-L_06.js",
          import.meta.url
        ),
        {
          type: "module"
        }
      );
      t.push(w), w.onmessage = this.onWorkerMessage, w.onerror = this.onWorkerError;
    }
  }
  postMessage(t, r) {
    const { currentIndex: c, numWorkers: w, workers: R } = this;
    R[c].postMessage(t, r);
    const h = (c + 1) % w;
    this.currentIndex = h;
  }
}
const Du = /* @__PURE__ */ new WeakMap();
class Cb extends Do {
  constructor(t) {
    super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = em, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
      position: "POSITION",
      normal: "NORMAL",
      color: "COLOR",
      uv: "TEX_COORD"
    }, this.defaultAttributeTypes = {
      position: "Float32Array",
      normal: "Float32Array",
      color: "Float32Array",
      uv: "Float32Array"
    };
  }
  setDecoderPath(t) {
    return this.decoderPath = t, this;
  }
  setDecoderConfig(t) {
    return this.decoderConfig = t, this;
  }
  setWorkerLimit(t) {
    return this.workerLimit = t, this;
  }
  load(t, r, c, w) {
    const R = new Rh(this.manager);
    R.setPath(this.path), R.setResponseType("arraybuffer"), R.setRequestHeader(this.requestHeader), R.setWithCredentials(this.withCredentials), R.load(
      t,
      (L) => {
        this.parse(L, r, w);
      },
      c,
      w
    );
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  parse(t, r, c = () => {
  }) {
    this.decodeDracoFile(
      t,
      r,
      null,
      null,
      kr,
      c
    ).catch(c);
  }
  decodeDracoFile(t, r, c, w, R = Nl, L = () => {
  }) {
    const h = {
      attributeIDs: c || this.defaultAttributeIDs,
      attributeTypes: w || this.defaultAttributeTypes,
      useUniqueIDs: !!c,
      vertexColorSpace: R
    };
    return this.decodeGeometry(t, h).then(r).catch(L);
  }
  decodeGeometry(t, r) {
    for (const b in r.attributeTypes) {
      const A = r.attributeTypes[b];
      A.BYTES_PER_ELEMENT !== void 0 && (r.attributeTypes[b] = A.name);
    }
    const c = JSON.stringify(r);
    if (Du.has(t)) {
      const b = Du.get(t);
      if (b.key === c)
        return b.promise;
      if (t.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let w;
    const R = this.workerNextTaskID++, L = t.byteLength, h = this._getWorker(R, L).then((b) => (w = b, new Promise((A, l) => {
      w._callbacks[R] = { resolve: A, reject: l }, w.postMessage(
        { type: "decode", id: R, taskConfig: r, buffer: t },
        [t]
      );
    }))).then((b) => this._createGeometry(b.geometry));
    return h.catch(() => !0).then(() => {
      w && R && this._releaseTask(w, R);
    }), Du.set(t, {
      key: c,
      promise: h
    }), h;
  }
  _createGeometry(t) {
    const r = new _s();
    t.index && r.setIndex(new xr(t.index.array, 1));
    for (let c = 0; c < t.attributes.length; c++) {
      const w = t.attributes[c], R = w.name, L = w.array, h = w.itemSize, b = new xr(L, h);
      R === "color" && (this._assignVertexColorSpace(b, w.vertexColorSpace), b.normalized = !(L instanceof Float32Array)), r.setAttribute(R, b);
    }
    return r.metadata = t.metadata, r;
  }
  _assignVertexColorSpace(t, r) {
    if (r !== kr) return;
    const c = new gs();
    for (let w = 0, R = t.count; w < R; w++)
      c.fromBufferAttribute(t, w).convertSRGBToLinear(), t.setXYZ(w, c.r, c.g, c.b);
  }
  _loadLibrary(t, r) {
    const c = new Rh(this.manager);
    return c.setPath(this.decoderPath), c.setResponseType(r), c.setWithCredentials(this.withCredentials), new Promise((w, R) => {
      c.load(t, w, void 0, R);
    });
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const t = typeof WebAssembly != "object" || this.decoderConfig.type === "js", r = [];
    return t ? r.push(this._loadLibrary("draco_decoder.js", "text")) : (r.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), r.push(
      this._loadLibrary("draco_decoder.wasm", "arraybuffer")
    )), this.decoderPending = Promise.all(r).then((c) => {
      const w = c[0];
      t || (this.decoderConfig.wasmBinary = c[1]);
      const R = Nb.toString(), L = [
        "/* draco decoder */",
        w,
        "",
        "/* worker */",
        R.substring(R.indexOf("{") + 1, R.lastIndexOf("}"))
      ].join(`
`);
      this.workerSourceURL = URL.createObjectURL(new Blob([L]));
    }), this.decoderPending;
  }
  _getWorker(t, r) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const w = new Worker(this.workerSourceURL);
        w._callbacks = {}, w._taskCosts = {}, w._taskLoad = 0, w.postMessage({ type: "init", decoderConfig: this.decoderConfig }), w.onmessage = function(R) {
          const L = R.data;
          switch (L.type) {
            case "decode":
              w._callbacks[L.id].resolve(L);
              break;
            case "error":
              w._callbacks[L.id].reject(L);
              break;
            default:
              console.error(
                'THREE.DRACOLoader: Unexpected message, "' + L.type + '"'
              );
          }
        }, this.workerPool.push(w);
      } else
        this.workerPool.sort(function(w, R) {
          return w._taskLoad > R._taskLoad ? -1 : 1;
        });
      const c = this.workerPool[this.workerPool.length - 1];
      return c._taskCosts[t] = r, c._taskLoad += r, c;
    });
  }
  _releaseTask(t, r) {
    t._taskLoad -= t._taskCosts[r], delete t._callbacks[r], delete t._taskCosts[r];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((t) => t._taskLoad)
    );
  }
  dispose() {
    for (let t = 0; t < this.workerPool.length; ++t)
      this.workerPool[t].terminate();
    return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this;
  }
}
function Nb() {
  let Et, t;
  onmessage = function(L) {
    const h = L.data;
    switch (h.type) {
      case "init": {
        Et = h.decoderConfig, t = new Promise(function(b) {
          Et.onModuleLoaded = function(A) {
            b({ draco: A });
          }, DracoDecoderModule(Et);
        });
        break;
      }
      case "decode": {
        const b = h.buffer, A = h.taskConfig;
        t.then((l) => {
          const o = l.draco, u = new o.Decoder();
          try {
            const g = r(
              o,
              u,
              new Int8Array(b),
              A
            ), m = g.attributes.map(
              (S) => S.array.buffer
            );
            Object.values(g.metadata).forEach((S) => {
              S && S.buffer && m.push(S.buffer);
            }), g.index && m.push(g.index.array.buffer), self.postMessage(
              { type: "decode", id: h.id, geometry: g },
              m
            );
          } catch (g) {
            console.error(g), self.postMessage({
              type: "error",
              id: h.id,
              error: g.message
            });
          } finally {
            o.destroy(u);
          }
        });
        break;
      }
    }
  };
  function r(L, h, b, A) {
    const l = A.attributeIDs, o = A.attributeTypes, u = A.metadataFields, g = !!A.isEncrypted;
    let m, S;
    const e = h.GetEncodedGeometryType(b);
    if (e === L.TRIANGULAR_MESH)
      m = new L.Mesh(), S = h.DecodeArrayToMesh(
        b,
        b.byteLength,
        m
      );
    else if (e === L.POINT_CLOUD)
      m = new L.PointCloud(), S = h.DecodeArrayToPointCloud(
        b,
        b.byteLength,
        m
      );
    else
      throw g ? new Error('"THREE.DRACOLoader: Could not decode mesh."') : new Error(
        `"THREE.DRACOLoader: Unexpected geometry type ${e}."`
      );
    if (!S.ok() || m.ptr === 0)
      throw new Error(
        "THREE.DRACOLoader: Decoding failed: " + S.error_msg()
      );
    const n = { index: null, attributes: [] };
    for (const P in l) {
      const $ = self[o[P]];
      let ot, dt;
      if (A.useUniqueIDs)
        dt = l[P], ot = h.GetAttributeByUniqueId(m, dt);
      else {
        if (dt = h.GetAttributeId(
          m,
          L[l[P]]
        ), dt === -1) continue;
        ot = h.GetAttribute(m, dt);
      }
      const xt = w(
        L,
        h,
        m,
        P,
        $,
        ot
      );
      P === "color" && (xt.vertexColorSpace = A.vertexColorSpace), n.attributes.push(xt);
    }
    n.metadata = n.metadata || {};
    const d = h.GetMetadata(m), _ = new L.MetadataQuerier();
    for (const P in u)
      if (_.HasEntry(d, P)) {
        const $ = u[P];
        let ot;
        if ($ === "IntEntryArray") {
          const dt = new L.DracoInt32Array();
          _[`Get${$}`](d, P, dt);
          const xt = dt.size();
          ot = new Int32Array(xt);
          for (let Nt = 0; Nt < xt; Nt++)
            ot[Nt] = dt.GetValue(Nt);
          L._free(dt);
        } else if ($ === "EntryDoubleArray" || $ === "DoubleEntryArray") {
          const dt = new L.DracoDoubleArray();
          _[`Get${$}`](d, P, dt);
          const xt = dt.size();
          ot = new Float64Array(xt);
          for (let Nt = 0; Nt < xt; Nt++)
            ot[Nt] = dt.GetValue(Nt);
          L._free(dt);
        } else
          ot = _[`Get${$}`](d, P);
        n.metadata[P] = ot;
      }
    for (const P of n.metadata.deltaIds || [])
      attribute = h.GetAttributeByUniqueId(m, P), n.attributes.push(
        w(
          L,
          h,
          m,
          P,
          Float32Array,
          attribute
        )
      );
    for (const P of n.metadata.deltaNormalIds || []) {
      const $ = h.GetAttributeByUniqueId(
        m,
        P
      );
      n.attributes.push(
        w(
          L,
          h,
          m,
          P,
          Float32Array,
          $
        )
      );
    }
    const p = {
      weightsAtt: Float32Array,
      bindingsAtt: Int32Array
    };
    for (const [P, $] of Object.entries(p))
      if (n.metadata[P]) {
        const ot = h.GetAttributeByUniqueId(
          m,
          n.metadata[P]
        );
        n.attributes.push(
          w(L, h, m, P, $, ot)
        );
      }
    return e === L.TRIANGULAR_MESH && (n.index = c(L, h, m)), L.destroy(m), n;
  }
  function c(L, h, b) {
    const l = b.num_faces() * 3, o = l * 4, u = L._malloc(o);
    h.GetTrianglesUInt32Array(b, o, u);
    const g = new Uint32Array(
      L.HEAPF32.buffer,
      u,
      l
    ).slice();
    return L._free(u), { array: g, itemSize: 1 };
  }
  function w(L, h, b, A, l, o) {
    const u = o.num_components(), m = b.num_points() * u, S = m * l.BYTES_PER_ELEMENT, e = R(L, l), n = L._malloc(S);
    h.GetAttributeDataArrayForAllPoints(
      b,
      o,
      e,
      S,
      n
    );
    const d = new l(
      L.HEAPF32.buffer,
      n,
      m
    ).slice();
    return L._free(n), {
      name: A,
      array: d,
      itemSize: u
    };
  }
  function R(L, h) {
    switch (h) {
      case Float32Array:
        return L.DT_FLOAT32;
      case Int8Array:
        return L.DT_INT8;
      case Int16Array:
        return L.DT_INT16;
      case Int32Array:
        return L.DT_INT32;
      case Uint8Array:
        return L.DT_UINT8;
      case Uint16Array:
        return L.DT_UINT16;
      case Uint32Array:
        return L.DT_UINT32;
    }
  }
}
let yo = null;
const vl = 4, Pb = async (Et, t = gm) => {
  const { data: r, timescale: c, dts: w } = Et;
  yo || (yo = new Cb(t), yo.setDecoderPath(iy));
  const { defaultAttributeIDs: R, defaultAttributeTypes: L } = yo, h = {
    attributeIDs: R,
    attributeTypes: L,
    metadataFields: {
      version: ay,
      timestamp: fo,
      interpolatedFrames: fo,
      deltaFrames: fo,
      deltaIds: fo,
      deltaNormalIds: fo,
      weightsAtt: eh,
      bindingsAtt: eh
      // headJoint: ENTRY_DOUBLE_ARRAY,
      // headJointIndex: ENTRY_INT,
      // neckJoint: ENTRY_DOUBLE_ARRAY,
      // neckJointIndex: ENTRY_INT,
      // NOSE: ENTRY_DOUBLE_ARRAY,
      // NOSE_INDEX: ENTRY_INT,
      // EYE_L: ENTRY_DOUBLE_ARRAY,
      // EYE_L_INDEX: ENTRY_INT,
      // EYE_R: ENTRY_DOUBLE_ARRAY,
      // EYE_R_INDEX: ENTRY_INT,
      // EAR_L: ENTRY_DOUBLE_ARRAY,
      // EAR_L_INDEX: ENTRY_INT,
      // EAR_R: ENTRY_DOUBLE_ARRAY,
      // EAR_R_INDEX: ENTRY_INT,
      // SHO_L: ENTRY_DOUBLE_ARRAY,
      // SHO_L_INDEX: ENTRY_INT,
      // SHO_R: ENTRY_DOUBLE_ARRAY,
      // SHO_R_INDEX: ENTRY_INT,
      // ELB_L: ENTRY_DOUBLE_ARRAY,
      // ELB_L_INDEX: ENTRY_INT,
      // ELB_R: ENTRY_DOUBLE_ARRAY,
      // ELB_R_INDEX: ENTRY_INT,
      // WRI_L: ENTRY_DOUBLE_ARRAY,
      // WRI_L_INDEX: ENTRY_INT,
      // WRI_R: ENTRY_DOUBLE_ARRAY,
      // WRI_R_INDEX: ENTRY_INT,
      // HIP_L: ENTRY_DOUBLE_ARRAY,
      // HIP_L_INDEX: ENTRY_INT,
      // HIP_R: ENTRY_DOUBLE_ARRAY,
      // HIP_R_INDEX: ENTRY_INT,
      // KNE_L: ENTRY_DOUBLE_ARRAY,
      // KNE_L_INDEX: ENTRY_INT,
      // KNE_R: ENTRY_DOUBLE_ARRAY,
      // KNE_R_INDEX: ENTRY_INT,
      // ANK_L: ENTRY_DOUBLE_ARRAY,
      // ANK_L_INDEX: ENTRY_INT,
      // ANK_R: ENTRY_DOUBLE_ARRAY,
      // ANK_R_INDEX: ENTRY_INT,
      // NECK: ENTRY_DOUBLE_ARRAY,
      // NECK_INDEX: ENTRY_INT,
      // HEAD: ENTRY_DOUBLE_ARRAY,
      // HEAD_INDEX: ENTRY_INT,
      // SPINE_H: ENTRY_DOUBLE_ARRAY,
      // SPINE_H_INDEX: ENTRY_INT,
      // SPINE_M: ENTRY_DOUBLE_ARRAY,
      // SPINE_M_INDEX: ENTRY_INT,
      // SPINE_L: ENTRY_DOUBLE_ARRAY,
      // SPINE_L_INDEX: ENTRY_INT,
      // HIP_M: ENTRY_DOUBLE_ARRAY,
      // HIP_M_INDEX: ENTRY_INT,
    },
    useUniqueIDs: !1,
    vertexColorSpace: Nl,
    isEncrypted: !!Et.encrypted
  }, b = await yo.decodeGeometry(r.buffer, h), {
    metadata: A,
    metadata: { deltaIds: l, deltaNormalIds: o }
  } = b;
  A.deltaFrames || (A.deltaFrames = []), A.interpolatedFrames || (A.interpolatedFrames = []);
  const u = o !== void 0 && b.attributes[o] !== void 0, g = A.timestamp ? A.timestamp.length : 1, m = new Array(g), S = A.timestamp ? Et.duration / A.timestamp.length : Et.duration;
  let e, n;
  for (let jt = 0; jt < g; jt++) {
    const q = {}, I = A.timestamp !== void 0 ? A.timestamp[jt] : w;
    if (jt === 0) {
      b.userData = q;
      const It = b.attributes.position.count * vl;
      b.attributes.weightsAtt ? e = b.attributes.weightsAtt.clone() : (e = new xr(
        new Float32Array(It),
        vl
      ), b.setAttribute("weightsAtt", e)), b.attributes.bindingsAtt ? (n = new xr(
        Float32Array.from(b.attributes.bindingsAtt.array),
        vl
      ), b.setAttribute("bindingsAtt", n)) : (n = new xr(
        new Float32Array(It),
        vl
      ), b.setAttribute("bindingsAtt", n)), m[jt] = {
        type: Ml,
        timescale: c,
        geometry: b,
        timestamp: I,
        duration: S
      };
    } else {
      const pt = new _s();
      pt.setIndex(b.index), pt.setAttribute("uv", b.attributes.uv.clone()), pt.setAttribute("position", b.attributes.position.clone()), b.attributes.normal && pt.setAttribute("normal", b.attributes.normal.clone()), pt.setAttribute("weightsAtt", e), pt.setAttribute("bindingsAtt", n), pt.userData = q, m[jt] = { geometry: pt, timestamp: I, duration: S };
    }
  }
  let d = null, _ = null, p = null;
  const { deltaFrames: P, interpolatedFrames: $ } = A;
  for (const jt of P)
    m[jt].type = ho;
  for (const jt of $)
    m[jt].type = th;
  let ot = 0, dt, xt = 0, Nt = null;
  for (let jt = 0; jt < m.length; jt++) {
    if (d = m[jt], d.type !== ho)
      continue;
    const q = b.attributes[l[ot++]];
    if (dt) {
      const { count: It, itemSize: et } = d.geometry.attributes.position;
      for (let Dt = 0; Dt < It * et; Dt++)
        q.array[Dt] += dt.array[Dt];
    }
    d.geometry.setAttribute(ho, q);
    const { count: I, itemSize: pt } = d.geometry.attributes.position;
    for (let It = 0; It < I * pt; It++)
      d.geometry.attributes.position.array[It] += q.array[It];
    if (d.geometry.attributes.position.needsUpdate = !0, dt = q, u) {
      const It = b.attributes[o[xt++]], { count: et, itemSize: Dt } = d.geometry.attributes.normal;
      if (Nt)
        for (let ae = 0; ae < et * Dt; ae++)
          It.array[ae] += Nt.array[ae];
      d.geometry.setAttribute("deltaNormal", It);
      for (let ae = 0; ae < et * Dt; ae++)
        d.geometry.attributes.normal.array[ae] += It.array[ae];
      d.geometry.attributes.normal.needsUpdate = !0, Nt = It;
    }
  }
  for (let jt = 0; jt < m.length; jt++)
    if (d = m[jt], d.type === th) {
      let q = -1, I = -1;
      for (let Dt = jt; Dt < m.length; Dt++)
        if (_ = m[Dt], _.type === ho) {
          q = Dt;
          break;
        }
      for (let Dt = jt; Dt >= 0; Dt--)
        if (_ = m[Dt], _.type === ho || _.type === Ml) {
          I = Dt;
          break;
        }
      const pt = jt - I, It = q - I, et = pt / It;
      if (_ = m[I], p = m[q], _.type === Ml) {
        const Dt = _.geometry.attributes.position, ae = p.geometry.attributes.delta, { count: St, itemSize: qe } = Dt;
        for (let zt = 0; zt < St * qe; zt++)
          d.geometry.attributes.position.array[zt] = Dt.array[zt] + et * ae.array[zt];
        if (u) {
          const zt = _.geometry.attributes.normal, Ct = p.geometry.attributes.deltaNormal, { count: de, itemSize: ze } = zt;
          for (let le = 0; le < de * ze; le++)
            d.geometry.attributes.normal.array[le] = zt.array[le] + et * Ct.array[le];
        }
      } else {
        const Dt = m[0].geometry.attributes.position, ae = _.geometry.attributes.delta, St = p.geometry.attributes.delta, { count: qe, itemSize: zt } = ae;
        for (let Ct = 0; Ct < qe * zt; Ct++)
          d.geometry.attributes.position.array[Ct] = Dt.array[Ct] + ae.array[Ct] + et * (St.array[Ct] - ae.array[Ct]);
        if (u) {
          const Ct = _.geometry.attributes.deltaNormal, de = p.geometry.attributes.deltaNormal, { count: ze, itemSize: le } = Ct;
          for (let Ze = 0; Ze < ze * le; Ze++)
            d.geometry.attributes.normal.array[Ze] = Dt.array[Ze] + Ct.array[Ze] + et * (de.array[Ze] - Ct.array[Ze]);
        }
      }
      d.geometry.attributes.position.needsUpdate = !0;
    }
  return m;
};
/**
 * filesize
 *
 * @copyright 2024 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.1.6
 */
const zb = "array", Ob = "bit", Ch = "bits", Yb = "byte", Nh = "bytes", za = "", Fb = "exponent", Ub = "function", Ph = "iec", jb = "Invalid number", Bb = "Invalid rounding method", Iu = "jedec", Hb = "object", zh = ".", _m = "round", qb = "s", Gb = "si", Vb = "kbit", Wb = "kB", ym = " ", bm = "string", Kb = "0", Ru = {
  symbol: {
    iec: {
      bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
      bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
    },
    jedec: {
      bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
      bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
    }
  },
  fullform: {
    iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
    jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
  }
};
function $b(Et, {
  bits: t = !1,
  pad: r = !1,
  base: c = -1,
  round: w = 2,
  locale: R = za,
  localeOptions: L = {},
  separator: h = za,
  spacer: b = ym,
  symbols: A = {},
  standard: l = za,
  output: o = bm,
  fullform: u = !1,
  fullforms: g = [],
  exponent: m = -1,
  roundingMethod: S = _m,
  precision: e = 0
} = {}) {
  let n = m, d = Number(Et), _ = [], p = 0, P = za;
  l === Gb ? (c = 10, l = Iu) : l === Ph || l === Iu ? c = 2 : c === 2 ? l = Ph : (c = 10, l = Iu);
  const $ = c === 10 ? 1e3 : 1024, ot = u === !0, dt = d < 0, xt = Math[S];
  if (typeof Et != "bigint" && isNaN(Et))
    throw new TypeError(jb);
  if (typeof xt !== Ub)
    throw new TypeError(Bb);
  if (dt && (d = -d), (n === -1 || isNaN(n)) && (n = Math.floor(Math.log(d) / Math.log($)), n < 0 && (n = 0)), n > 8 && (e > 0 && (e += 8 - n), n = 8), o === Fb)
    return n;
  if (d === 0)
    _[0] = 0, P = _[1] = Ru.symbol[l][t ? Ch : Nh][n];
  else {
    p = d / (c === 2 ? Math.pow(2, n * 10) : Math.pow(1e3, n)), t && (p = p * 8, p >= $ && n < 8 && (p = p / $, n++));
    const Nt = Math.pow(10, n > 0 ? w : 0);
    _[0] = xt(p * Nt) / Nt, _[0] === $ && n < 8 && m === -1 && (_[0] = 1, n++), P = _[1] = c === 10 && n === 1 ? t ? Vb : Wb : Ru.symbol[l][t ? Ch : Nh][n];
  }
  if (dt && (_[0] = -_[0]), e > 0 && (_[0] = _[0].toPrecision(e)), _[1] = A[_[1]] || _[1], R === !0 ? _[0] = _[0].toLocaleString() : R.length > 0 ? _[0] = _[0].toLocaleString(R, L) : h.length > 0 && (_[0] = _[0].toString().replace(zh, h)), r && w > 0) {
    const Nt = _[0].toString(), jt = h || (Nt.match(/(\D)/g) || []).pop() || zh, q = Nt.toString().split(jt), I = q[1] || za, pt = I.length, It = w - pt;
    _[0] = `${q[0]}${jt}${I.padEnd(pt + It, Kb)}`;
  }
  return ot && (_[1] = g[n] ? g[n] : Ru.fullform[l][n] + (t ? Ob : Yb) + (_[0] === 1 ? za : qb)), o === zb ? _ : o === Hb ? {
    value: _[0],
    symbol: _[1],
    exponent: n,
    unit: P
  } : _.join(b);
}
function Xb({
  bits: Et = !1,
  pad: t = !1,
  base: r = -1,
  round: c = 2,
  locale: w = za,
  localeOptions: R = {},
  separator: L = za,
  spacer: h = ym,
  symbols: b = {},
  standard: A = za,
  output: l = bm,
  fullform: o = !1,
  fullforms: u = [],
  exponent: g = -1,
  roundingMethod: m = _m,
  precision: S = 0
} = {}) {
  return (e) => $b(e, {
    bits: Et,
    pad: t,
    base: r,
    round: c,
    locale: w,
    localeOptions: R,
    separator: L,
    spacer: h,
    symbols: b,
    standard: A,
    output: l,
    fullform: o,
    fullforms: u,
    exponent: g,
    roundingMethod: m,
    precision: S
  });
}
const Pa = {
  Android: function() {
    return navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function() {
    return navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function() {
    return navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Safari: function() {
    return Pa.iOS();
  },
  PureSafari: function() {
    return Pa.iOS() && navigator.userAgent.indexOf("CriOS") == -1 && navigator.userAgent.indexOf("FxiOS") == -1;
  },
  Opera: function() {
    return navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function() {
    return navigator.userAgent.match(/IEMobile/i);
  },
  mobile: function() {
    return Pa.Android() || Pa.BlackBerry() || Pa.iOS() || Pa.Opera() || Pa.Windows();
  },
  notMobile: function() {
    return !Pa.mobile();
  },
  eighthWall: function() {
    return window.XRExtras !== void 0;
  }
}, Qb = () => !!document.createElement("canvas").getContext("webgl2"), Jb = (Et = 0) => new Promise((t) => setTimeout(t, Et)), Ju = Xb({
  base: 10,
  locale: "en",
  symbols: { kB: "KB" }
}), Zb = (Et) => new Promise((t, r) => {
  const c = window.setTimeout(() => {
    r(new Error(`Timeout of ${ih}`));
  }, ih);
  Et.addEventListener("loadedmetadata", () => {
    window.clearTimeout(c), t();
  });
}), Em = (Et) => {
  const t = Et > 0 ? Et / id : 1, r = yr * ba, c = Math.ceil(Ao * t);
  return [t, r, c];
}, tE = "segments", eE = 250, nE = (Et) => {
  const t = new Error(Et);
  return t.name = "InvalidStateError", t.code = 11, t;
};
class iE extends EventTarget {
  constructor(t, r, c) {
    super(), this._timestampOffset = 0, this.fileStart = 0, this.bytesReceived = 0, this._isInitialized = !1, this.useSync = !1, this.video = null, this.workerPool = null, this.updating = !1, this.timescale = 0, this.frameDuration = 0, this.logger = null, this.parser = null, this.mimeType = "application/octet-stream", this.key = null, this.mode = tE, this.samples = [], this.queuedSamples = [], this.frames = /* @__PURE__ */ new Map(), this.ranges = [], this.appendWindowStart = 0, this.appendWindowEnd = 1 / 0, this.remove = (h, b) => {
      const { logger: A, video: l } = this;
      if (this.updating === !0) {
        const p = new Error(
          "SourceBuffer.remove() cannot be called while an update is in progress"
        );
        throw p.name = "InvalidStateError", p.code = 11, p;
      }
      this.beginUpdate();
      const { frames: o, timescale: u, frameDuration: g } = this, m = h * u, S = b * u, e = Math.floor(m / g), n = Math.floor(S / g), d = o.size;
      if (!this._isInitialized)
        A.silly(
          "Preventing removing frames while CustomSourceBuffer is not initialized."
        );
      else if (l.paused)
        A.silly("Preventing removing frames while video is paused");
      else if (l.currentTime >= h && l.currentTime <= b)
        A.silly(
          `Preventing removing frames at current time ${l.currentTime}`
        );
      else
        for (let p = e; p < n; p++)
          o.delete(p);
      const _ = d - o.size;
      _ === 0 ? A.silly(
        `Attempted to remove samples in range ${h}-${b} (Frames ${e}-${n}) Total: ${o.size} frames.`
      ) : A.silly(
        `Removed ${_} samples in range ${h}-${b} (Frames ${e}-${n}). Total: ${o.size} frames.`
      ), this.calculateRanges(), this.dispatchEvent(new Event($c)), this.endUpdate();
    }, this.queueSamples = (h, b, A) => {
      const { logger: l, queuedSamples: o, parser: u } = this;
      l.silly(`Queueing a batch of ${A.length} sample(s).`), o.push(A), window.clearInterval(this.pollKeyIntervalId), this.pollKeyIntervalId = window.setInterval(async () => {
        if (this.key)
          for (window.clearInterval(this.pollKeyIntervalId), l.silly(`Processing ${this.queuedSamples.length} queued sample(s)`), u.start(); this.queuedSamples.length > 0; ) {
            const g = this.queuedSamples.shift();
            u.onSamples(h, b, g), await Jb(500);
          }
      }, eE);
    }, this.preprocessSamples = (h, b, A) => {
      const { key: l, parser: o } = this;
      return A.some(
        ({ encrypted: g }) => !!g
      ) && !l ? (o.stop(), this.queueSamples(h, b, A), this.endUpdate(), !0) : !1;
    }, this.onSamplesSync = async (h, b, A) => {
      const { logger: l } = this;
      if (this.preprocessSamples(h, b, A))
        return;
      l.silly(`Processing ${A.length} sample(s)...`), this.beginUpdate();
      const o = await Promise.all(
        A.map((u) => Pb(u))
      );
      for (const u of o)
        this.samples.push(...u);
      this.onProcessSamples();
    }, this.onSamplesAsync = async (h, b, A) => {
      const { workerPool: l, logger: o } = this;
      if (!this.preprocessSamples(h, b, A)) {
        o.silly(`Processing ${A.length} sample(s) using Web Workers...`), this.beginUpdate();
        for (const u of A) {
          if (u.encrypted) {
            const g = new Uint8Array(16);
            g.set(u.InitializationVector);
            const m = await window.crypto.subtle.decrypt(
              {
                name: im,
                counter: g,
                length: 128
              },
              this.key,
              u.data
            );
            u.data = new Uint8Array(m);
          }
          l.postMessage(u);
        }
      }
    }, this.onWorkerMessage = async (h) => {
      const { samples: b } = this, A = h.data;
      for (const l of A) {
        const { geometry: o } = l;
        if (o instanceof _s || o.isBufferGeometry) {
          Object.setPrototypeOf(o, _s.prototype), Object.setPrototypeOf(o.index, xr.prototype);
          for (const u in o.attributes) {
            const { array: g, itemSize: m } = o.attributes[u];
            let S;
            switch (!0) {
              case g instanceof Float32Array:
                S = new pm(g, m);
                break;
              case g instanceof Uint16Array:
                S = new fm(g, m);
                break;
              case g instanceof Uint32Array:
                S = new mm(g, m);
                break;
            }
            Object.setPrototypeOf(S, xr.prototype), o.attributes[u] = S;
          }
        } else
          throw new Error("Geometry is not a BufferGeometry");
        b.push(l);
      }
      window.clearTimeout(this.processSamplesTimeout), this.processSamplesTimeout = window.setTimeout(this.onProcessSamples, 0);
    }, this.onProcessSamples = async () => {
      const { logger: h, frames: b } = this, { samples: A } = this;
      A.sort((u, g) => u.timestamp - g.timestamp);
      const l = A[0], o = A[1];
      if (l && o && l.type === Ml) {
        const { timescale: u, duration: g } = l;
        this.timescale = u;
        const m = g;
        this.frameDuration = m, this._isInitialized || (this._isInitialized = !0, h.silly(
          `Initialized - timescale: ${this.timescale}, frame duration: ${this.frameDuration}`
        ));
      }
      if (!this._isInitialized) {
        h.silly(
          `CustomSourceBuffer is not initialized after initial samples have been processed - awaiting additional samples: ${A.length}`
        );
        return;
      }
      this.dispatchEvent(new Event($c));
      for (const u of A) {
        const { timestamp: g, duration: m } = u, S = Math.floor(g / m);
        b.set(S, u);
      }
      A.length = 0, this.calculateRanges(), this.endUpdate();
    }, this.mimeType = t, this.useSync = r, this.video = c;
    const w = new Ol("CustomSourceBuffer");
    this.logger = w;
    const R = am.createFile();
    this.parser = R;
    const L = new Rb(em);
    this.workerPool = L, L.onmessage = this.onWorkerMessage, L.onerror = (h) => {
      console.log("Worker error", h);
    }, Object.defineProperty(this, "timestampOffset", {
      get() {
        return this._timestampOffset;
      },
      set(h) {
        typeof h == "number" && (this._timestampOffset = h);
      }
    }), Object.defineProperty(this, "buffered", {
      get() {
        const { ranges: h } = this;
        return {
          length: h.length,
          start: (b) => h[b][0],
          end: (b) => h[b][1]
        };
      }
    }), R.onSamples = r ? this.onSamplesSync : this.onSamplesAsync, R.onMoovStart = () => {
      R.onMoovStart = void 0;
    }, R.onReady = (h) => {
      const { tracks: b } = h;
      if (b.length === 0)
        throw new Error("No tracks found.");
      for (const A of b)
        R.setExtractionOptions(A.id, null, {
          nbSamples: ry
        });
      R.onReady = void 0, R.start();
    };
  }
  // Custom Class methods
  setKey(t) {
    this.key = t;
  }
  getFrame(t) {
    const { frames: r } = this;
    return r.get(t);
  }
  canPlay(t, r = 0) {
    const { ranges: c } = this;
    for (let w = 0; w < c.length; w++) {
      const R = c[w][0], L = c[w][1];
      if (t >= R - r && t <= L + r)
        return !0;
    }
    return !1;
  }
  beginUpdate() {
    this.dispatchEvent(new Event(K_)), this.updating = !0;
  }
  endUpdate() {
    this.updating = !1, this.dispatchEvent(new Event(Xc));
  }
  // Custom implementation of SourceBuffer API
  abort() {
    this.updating && (this.reset(), this.updating = !1, this.dispatchEvent(new Event($_)), this.dispatchEvent(new Event(Xc)));
  }
  destroy() {
    const { logger: t, parser: r } = this;
    t.silly("Destroying CustomSourceBuffer."), r.stop();
  }
  // Override appendBuffer to handle Draco decoding
  async appendBuffer(t) {
    const { logger: r, parser: c, fileStart: w } = this, { byteLength: R } = t;
    if (this.updating)
      throw nE(
        "SourceBuffer.append() cannot be called while an update is in progress"
      );
    R <= Z_ && (r.warn("Initial segment received.."), this.reset()), t.fileStart = w;
    const L = w + R, h = c.appendBuffer(t);
    L !== h && r.info(`Gap at ${h}.`), c.flush(), this.fileStart = h, this.bytesReceived += R, r.debug(
      `Appended ${R} bytes (${Ju(R)}) - received: ${Ju(this.fileStart)}.`
    );
  }
  reset() {
    const { logger: t } = this;
    t.warn("Resetting CustomSourceBuffer.", this._isInitialized), this.fileStart = 0, this.samples.length = 0, this.frames.clear(), this.calculateRanges();
  }
  calculateRanges() {
    const { frames: t, timescale: r, frameDuration: c } = this, w = [];
    for (const R of t.values()) {
      const { timestamp: L, duration: h } = R, b = L / r, l = b + (h || c) / r;
      if (w.length === 0)
        w.push([b, l]);
      else {
        const o = w.length - 1, u = w[o];
        u[1] = l;
      }
    }
    this.ranges = w;
  }
}
var Zu = { exports: {} };
(function(Et, t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  function r(ot) {
    return typeof ot == "object" && !("toString" in ot) ? Object.prototype.toString.call(ot).slice(8, -1) : ot;
  }
  var c = typeof process == "object" && process.env.NODE_ENV === "production";
  function w(ot, dt) {
    if (!ot)
      throw c ? new Error("Invariant failed") : new Error(dt());
  }
  t.invariant = w;
  var R = Object.prototype.hasOwnProperty, L = Array.prototype.splice, h = Object.prototype.toString;
  function b(ot) {
    return h.call(ot).slice(8, -1);
  }
  var A = Object.assign || /* istanbul ignore next */
  function(ot, dt) {
    return l(dt).forEach(function(xt) {
      R.call(dt, xt) && (ot[xt] = dt[xt]);
    }), ot;
  }, l = typeof Object.getOwnPropertySymbols == "function" ? function(ot) {
    return Object.keys(ot).concat(Object.getOwnPropertySymbols(ot));
  } : function(ot) {
    return Object.keys(ot);
  };
  function o(ot) {
    return Array.isArray(ot) ? A(ot.constructor(ot.length), ot) : b(ot) === "Map" ? new Map(ot) : b(ot) === "Set" ? new Set(ot) : ot && typeof ot == "object" ? A(Object.create(Object.getPrototypeOf(ot)), ot) : ot;
  }
  var u = (
    /** @class */
    function() {
      function ot() {
        this.commands = A({}, g), this.update = this.update.bind(this), this.update.extend = this.extend = this.extend.bind(this), this.update.isEquals = function(dt, xt) {
          return dt === xt;
        }, this.update.newContext = function() {
          return new ot().update;
        };
      }
      return Object.defineProperty(ot.prototype, "isEquals", {
        get: function() {
          return this.update.isEquals;
        },
        set: function(dt) {
          this.update.isEquals = dt;
        },
        enumerable: !0,
        configurable: !0
      }), ot.prototype.extend = function(dt, xt) {
        this.commands[dt] = xt;
      }, ot.prototype.update = function(dt, xt) {
        var Nt = this, jt = typeof xt == "function" ? { $apply: xt } : xt;
        Array.isArray(dt) && Array.isArray(jt) || w(!Array.isArray(jt), function() {
          return "update(): You provided an invalid spec to update(). The spec may not contain an array except as the value of $set, $push, $unshift, $splice or any custom command allowing an array value.";
        }), w(typeof jt == "object" && jt !== null, function() {
          return "update(): You provided an invalid spec to update(). The spec and every included key path must be plain objects containing one of the " + ("following commands: " + Object.keys(Nt.commands).join(", ") + ".");
        });
        var q = dt;
        return l(jt).forEach(function(I) {
          if (R.call(Nt.commands, I)) {
            var pt = dt === q;
            q = Nt.commands[I](jt[I], q, jt, dt), pt && Nt.isEquals(q, dt) && (q = dt);
          } else {
            var It = b(dt) === "Map" ? Nt.update(dt.get(I), jt[I]) : Nt.update(dt[I], jt[I]), et = b(q) === "Map" ? q.get(I) : q[I];
            (!Nt.isEquals(It, et) || typeof It > "u" && !R.call(dt, I)) && (q === dt && (q = o(dt)), b(q) === "Map" ? q.set(I, It) : q[I] = It);
          }
        }), q;
      }, ot;
    }()
  );
  t.Context = u;
  var g = {
    $push: function(ot, dt, xt) {
      return S(dt, xt, "$push"), ot.length ? dt.concat(ot) : dt;
    },
    $unshift: function(ot, dt, xt) {
      return S(dt, xt, "$unshift"), ot.length ? ot.concat(dt) : dt;
    },
    $splice: function(ot, dt, xt, Nt) {
      return n(dt, xt), ot.forEach(function(jt) {
        d(jt), dt === Nt && jt.length && (dt = o(Nt)), L.apply(dt, jt);
      }), dt;
    },
    $set: function(ot, dt, xt) {
      return p(xt), ot;
    },
    $toggle: function(ot, dt) {
      e(ot, "$toggle");
      var xt = ot.length ? o(dt) : dt;
      return ot.forEach(function(Nt) {
        xt[Nt] = !dt[Nt];
      }), xt;
    },
    $unset: function(ot, dt, xt, Nt) {
      return e(ot, "$unset"), ot.forEach(function(jt) {
        Object.hasOwnProperty.call(dt, jt) && (dt === Nt && (dt = o(Nt)), delete dt[jt]);
      }), dt;
    },
    $add: function(ot, dt, xt, Nt) {
      return $(dt, "$add"), e(ot, "$add"), b(dt) === "Map" ? ot.forEach(function(jt) {
        var q = jt[0], I = jt[1];
        dt === Nt && dt.get(q) !== I && (dt = o(Nt)), dt.set(q, I);
      }) : ot.forEach(function(jt) {
        dt === Nt && !dt.has(jt) && (dt = o(Nt)), dt.add(jt);
      }), dt;
    },
    $remove: function(ot, dt, xt, Nt) {
      return $(dt, "$remove"), e(ot, "$remove"), ot.forEach(function(jt) {
        dt === Nt && dt.has(jt) && (dt = o(Nt)), dt.delete(jt);
      }), dt;
    },
    $merge: function(ot, dt, xt, Nt) {
      return P(dt, ot), l(ot).forEach(function(jt) {
        ot[jt] !== dt[jt] && (dt === Nt && (dt = o(Nt)), dt[jt] = ot[jt]);
      }), dt;
    },
    $apply: function(ot, dt) {
      return _(ot), ot(dt);
    }
  }, m = new u();
  t.isEquals = m.update.isEquals, t.extend = m.extend, t.default = m.update, t.default.default = Et.exports = A(t.default, t);
  function S(ot, dt, xt) {
    w(Array.isArray(ot), function() {
      return "update(): expected target of " + r(xt) + " to be an array; got " + r(ot) + ".";
    }), e(dt[xt], xt);
  }
  function e(ot, dt) {
    w(Array.isArray(ot), function() {
      return "update(): expected spec of " + r(dt) + " to be an array; got " + r(ot) + ". Did you forget to wrap your parameter in an array?";
    });
  }
  function n(ot, dt) {
    w(Array.isArray(ot), function() {
      return "Expected $splice target to be an array; got " + r(ot);
    }), d(dt.$splice);
  }
  function d(ot) {
    w(Array.isArray(ot), function() {
      return "update(): expected spec of $splice to be an array of arrays; got " + r(ot) + ". Did you forget to wrap your parameters in an array?";
    });
  }
  function _(ot) {
    w(typeof ot == "function", function() {
      return "update(): expected spec of $apply to be a function; got " + r(ot) + ".";
    });
  }
  function p(ot) {
    w(Object.keys(ot).length === 1, function() {
      return "Cannot have more than one key in an object with $set";
    });
  }
  function P(ot, dt) {
    w(dt && typeof dt == "object", function() {
      return "update(): $merge expects a spec of type 'object'; got " + r(dt);
    }), w(ot && typeof ot == "object", function() {
      return "update(): $merge expects a target of type 'object'; got " + r(ot);
    });
  }
  function $(ot, dt) {
    var xt = b(ot);
    w(xt === "Map" || xt === "Set", function() {
      return "update(): " + r(dt) + " expects a target of type Set or Map; got " + r(xt);
    });
  }
})(Zu, Zu.exports);
var rE = Zu.exports;
const aE = /* @__PURE__ */ Tg(rE), Oh = "MPD", Yh = "XLinkExpansion", Fh = "MediaSegment", Uh = "InitializationSegment", jh = "BitstreamSwitchingSegment", Bh = "IndexSegment", Hh = "FragmentInfoSegment", qh = "license", Gh = "other", sE = {
  debug: {
    logLevel: _i.Debug.LOG_LEVEL_WARNING,
    dispatchEvent: !1
  },
  streaming: {
    abandonLoadTimeout: 1e4,
    wallclockTimeUpdateInterval: 100,
    manifestUpdateRetryInterval: 100,
    liveUpdateTimeThresholdInMilliseconds: 0,
    cacheInitSegments: !1,
    applyServiceDescription: !0,
    applyProducerReferenceTime: !0,
    applyContentSteering: !0,
    enableManifestDurationMismatchFix: !0,
    parseInbandPrft: !1,
    enableManifestTimescaleMismatchFix: !1,
    capabilities: {
      filterUnsupportedEssentialProperties: !0,
      supportedEssentialProperties: [
        { schemeIdUri: _i.Constants.FONT_DOWNLOAD_DVB_SCHEME },
        {
          schemeIdUri: _i.Constants.COLOUR_PRIMARIES_SCHEME_ID_URI,
          value: /1|5|6|7/
        },
        { schemeIdUri: _i.Constants.URL_QUERY_INFO_SCHEME },
        { schemeIdUri: _i.Constants.EXT_URL_QUERY_INFO_SCHEME },
        {
          schemeIdUri: _i.Constants.MATRIX_COEFFICIENTS_SCHEME_ID_URI,
          value: /0|1|5|6/
        },
        {
          schemeIdUri: _i.Constants.TRANSFER_CHARACTERISTICS_SCHEME_ID_URI,
          value: /1|6|13|14|15/
        },
        ..._i.Constants.THUMBNAILS_SCHEME_ID_URIS.map((Et) => ({ schemeIdUri: Et }))
      ],
      useMediaCapabilitiesApi: !0,
      filterVideoColorimetryEssentialProperties: !1,
      filterHDRMetadataFormatEssentialProperties: !1
    },
    events: {
      eventControllerRefreshDelay: 100,
      deleteEventMessageDataAfterEventStarted: !0
    },
    timeShiftBuffer: {
      calcFromSegmentTimeline: !1,
      fallbackToSegmentTimeline: !0
    },
    metrics: {
      maxListDepth: 100
    },
    delay: {
      liveDelayFragmentCount: NaN,
      liveDelay: NaN,
      useSuggestedPresentationDelay: !0
    },
    protection: {
      keepProtectionMediaKeys: !1,
      ignoreEmeEncryptedEvent: !1,
      detectPlayreadyMessageFormat: !0,
      ignoreKeyStatuses: !1
    },
    buffer: {
      enableSeekDecorrelationFix: !1,
      fastSwitchEnabled: null,
      flushBufferAtTrackSwitch: !1,
      reuseExistingSourceBuffers: !0,
      bufferPruningInterval: 10,
      bufferToKeep: 20,
      bufferTimeAtTopQuality: 30,
      bufferTimeAtTopQualityLongForm: 60,
      initialBufferLevel: NaN,
      bufferTimeDefault: 18,
      longFormContentDurationThreshold: 600,
      stallThreshold: 0.3,
      useAppendWindow: !0,
      setStallState: !0,
      avoidCurrentTimeRangePruning: !1,
      useChangeType: !0,
      mediaSourceDurationInfinity: !0,
      resetSourceBuffersForTrackSwitch: !1,
      syntheticStallEvents: {
        enabled: !1,
        ignoreReadyState: !1
      }
    },
    gaps: {
      jumpGaps: !0,
      jumpLargeGaps: !0,
      smallGapLimit: 1.5,
      threshold: 0.3,
      enableSeekFix: !0,
      enableStallFix: !1,
      stallSeek: 0.1
    },
    utcSynchronization: {
      enabled: !0,
      useManifestDateHeaderTimeSource: !0,
      backgroundAttempts: 2,
      timeBetweenSyncAttempts: 30,
      maximumTimeBetweenSyncAttempts: 600,
      minimumTimeBetweenSyncAttempts: 2,
      timeBetweenSyncAttemptsAdjustmentFactor: 2,
      maximumAllowedDrift: 100,
      enableBackgroundSyncAfterSegmentDownloadError: !0,
      defaultTimingSource: {
        scheme: "urn:mpeg:dash:utc:http-xsdate:2014",
        value: "https://time.akamai.com/?iso&ms"
      }
    },
    scheduling: {
      defaultTimeout: 500,
      lowLatencyTimeout: 0,
      scheduleWhilePaused: !0
    },
    text: {
      defaultEnabled: !0,
      dispatchForManualRendering: !1,
      extendSegmentedCues: !0,
      imsc: {
        displayForcedOnlyMode: !1,
        enableRollUp: !0
      },
      webvtt: {
        customRenderingEnabled: !1
      }
    },
    liveCatchup: {
      maxDrift: NaN,
      playbackRate: {
        min: NaN,
        max: NaN
      },
      playbackBufferMin: 0.5,
      enabled: null,
      mode: _i.Constants.LIVE_CATCHUP_MODE_DEFAULT
    },
    lastBitrateCachingInfo: {
      enabled: !0,
      ttl: 36e4
    },
    lastMediaSettingsCachingInfo: {
      enabled: !0,
      ttl: 36e4
    },
    saveLastMediaSettingsForCurrentStreamingSession: !0,
    cacheLoadThresholds: {
      video: 10,
      audio: 5
    },
    trackSwitchMode: {
      audio: _i.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
      video: _i.Constants.TRACK_SWITCH_MODE_NEVER_REPLACE,
      mesh: _i.Constants.TRACK_SWITCH_MODE_NEVER_REPLACE
    },
    selectionModeForInitialTrack: _i.Constants.TRACK_SELECTION_MODE_HIGHEST_SELECTION_PRIORITY,
    fragmentRequestTimeout: 2e4,
    fragmentRequestProgressTimeout: -1,
    manifestRequestTimeout: 1e4,
    retryIntervals: {
      [Oh]: 500,
      [Yh]: 500,
      [Fh]: 1e3,
      [Uh]: 1e3,
      [jh]: 1e3,
      [Bh]: 1e3,
      [Hh]: 1e3,
      [qh]: 1e3,
      [Gh]: 1e3,
      lowLatencyReductionFactor: 10
    },
    retryAttempts: {
      [Oh]: 3,
      [Yh]: 1,
      [Fh]: 3,
      [Uh]: 3,
      [jh]: 3,
      [Bh]: 3,
      [Hh]: 3,
      [qh]: 3,
      [Gh]: 3,
      lowLatencyMultiplyFactor: 5
    },
    abr: {
      limitBitrateByPortal: !1,
      usePixelRatioInLimitBitrateByPortal: !1,
      enableSupplementalPropertyAdaptationSetSwitching: !0,
      rules: {
        throughputRule: {
          active: !0
        },
        bolaRule: {
          active: !0
        },
        insufficientBufferRule: {
          active: !0,
          parameters: {
            throughputSafetyFactor: 0.7,
            segmentIgnoreCount: 2
          }
        },
        switchHistoryRule: {
          active: !0,
          parameters: {
            sampleSize: 8,
            switchPercentageThreshold: 0.075
          }
        },
        droppedFramesRule: {
          active: !1,
          parameters: {
            minimumSampleSize: 375,
            droppedFramesPercentageThreshold: 0.15
          }
        },
        abandonRequestsRule: {
          active: !0,
          parameters: {
            abandonDurationMultiplier: 1.8,
            minSegmentDownloadTimeThresholdInMs: 500,
            minThroughputSamplesThreshold: 6
          }
        },
        l2ARule: {
          active: !1
        },
        loLPRule: {
          active: !1
        }
      },
      throughput: {
        averageCalculationMode: _i.Constants.THROUGHPUT_CALCULATION_MODES.EWMA,
        lowLatencyDownloadTimeCalculationMode: _i.Constants.LOW_LATENCY_DOWNLOAD_TIME_CALCULATION_MODE.MOOF_PARSING,
        useResourceTimingApi: !0,
        useNetworkInformationApi: {
          xhr: !1,
          fetch: !1
        },
        useDeadTimeLatency: !0,
        bandwidthSafetyFactor: 0.9,
        sampleSettings: {
          live: 3,
          vod: 4,
          enableSampleSizeAdjustment: !0,
          decreaseScale: 0.7,
          increaseScale: 1.3,
          maxMeasurementsToKeep: 20,
          averageLatencySampleAmount: 4
        },
        ewma: {
          throughputSlowHalfLifeSeconds: 8,
          throughputFastHalfLifeSeconds: 3,
          latencySlowHalfLifeCount: 2,
          latencyFastHalfLifeCount: 1,
          weightDownloadTimeMultiplicationFactor: 15e-4
        }
      },
      maxBitrate: {
        audio: -1,
        video: -1,
        mesh: -1
      },
      minBitrate: {
        audio: -1,
        video: -1,
        mesh: -1
      },
      initialBitrate: {
        audio: -1,
        video: -1,
        mesh: 0
      },
      autoSwitchBitrate: {
        audio: !0,
        video: !0,
        mesh: !1
      }
    },
    cmcd: {
      applyParametersFromMpd: !0,
      enabled: !1,
      sid: null,
      cid: null,
      rtp: null,
      rtpSafetyFactor: 5,
      mode: _i.Constants.CMCD_MODE_QUERY,
      enabledKeys: _i.Constants.CMCD_AVAILABLE_KEYS,
      includeInRequests: ["segment", "mpd"],
      version: 1
    },
    cmsd: {
      enabled: !1,
      abr: {
        applyMb: !1,
        etpWeightRatio: 0
      }
    },
    defaultSchemeIdUri: {
      viewpoint: "",
      audioChannelConfiguration: "urn:mpeg:mpegB:cicp:ChannelConfiguration",
      role: "urn:mpeg:dash:role:2011",
      accessibility: "urn:mpeg:dash:role:2011"
    }
  },
  errors: {
    recoverAttempts: {
      mediaErrorDecode: 5
    }
  }
}, oE = (Et, t, r = 0) => {
  for (let c = 0, w = 0, R = 0; c < Et.length; c++)
    if (w = Et.start(c), R = Et.end(c), t >= w - r && t <= R + r)
      return !0;
  return !1;
}, Vh = () => {
}, Wh = 5e3, lE = "reset", vm = "statechanged", uE = "PLAY", dE = "PAUSE", cE = "volumechange", hE = "timeupdate", fE = "canplay", mE = "canplaythrough", pE = "complete", gE = "durationchange", _E = "emptied", yE = "ended", bE = "error", EE = "loadeddata", vE = "loadedmetadata", TE = "loadstart", wE = "pause", AE = "play", SE = "playing", ME = "progress", kE = "ratechange", xE = "seeked", LE = "seeking", DE = "stalled", IE = "suspend", RE = "timeupdate", CE = "volumechange", NE = "waiting", PE = yr >> 1, Kh = "none", zE = "failed", $h = "initializing", Tm = "initialized", Cu = "seeking", Nu = "buffering", kl = "playing", Gs = "paused";
class OE extends EventTarget {
  constructor(t) {
    super(), this.player = null, this.qualityManager = null, this.timecodeByteLength = 0, this.useWebGL2 = !0, this.currentPoll = null, this.state = Kh, this.cancelPreviousPollForTime = async () => {
      const { pollForTimeTimerId: R, currentPoll: L } = this;
      window.clearTimeout(R), L && (L.reject(new Error("ERR_NEW_POLL_REQUEST")), this.currentPoll = null);
    }, this.onDashPlayerInitialized = async () => {
      const { logger: R } = this;
      R.silly(`Player is initialized, setting ${Gs}`), this.setState(Gs);
    }, this.onQualityChange = async () => {
      const {
        logger: R,
        currentPoll: L,
        player: { video: h }
      } = this, b = L ? L.wasPaused : h.paused;
      this.setState(Nu);
      const A = h.currentTime;
      b || this.pause(), R.silly(
        `onQualityChange at ${h.currentTime} for ${A} (was paused: ${b})`
      );
      try {
        h.currentTime - A > 0 ? await this.requestPollForTime(A, b) : R.silly("onQualityChange: Prevented polling."), this.setState(Gs), b || (R.debug(
          "Resuming video playback, as video was not paused earlier"
        ), this.play());
      } catch (l) {
        R.debug(
          `Could not await ${A} becoming available after quality change: ${l.message}`
        );
      }
    }, this.onCanPlay = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onCanPlay: ${L == null ? void 0 : L.src}`), this.state === $h && this.setState(Tm);
    }, this.onCanPlayThrough = () => {
      const { logger: R } = this;
      R.silly("onCanPlayThrough");
    }, this.onComplete = () => {
      const { logger: R } = this;
      R.silly("onComplete");
    }, this.onDurationChange = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onDurationChange: ${L.duration}`);
    }, this.onEmptied = () => {
      const { logger: R } = this;
      R.silly("onEmptied: The video element is now empty.");
    }, this.onEnded = () => {
      const { logger: R } = this;
      R.silly("onEnded");
    }, this.onError = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.error(`onError: ${L.error}`);
    }, this.onLoadedData = () => {
      const { logger: R } = this;
      R.silly("onLoadedData");
    }, this.onLoadedMetadata = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onLoadedMetadata: ${L.duration}`);
    }, this.onLoadStart = () => {
      const { logger: R } = this;
      R.silly("onLoadStart"), this.setState($h);
    }, this.onPause = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onPause: ${L == null ? void 0 : L.currentTime}`), this.state !== Cu && this.state !== Nu && this.setState(Gs), this.dispatchEvent(VE());
    }, this.onPlay = () => {
      this.state !== Cu && this.state !== Nu && this.setState(kl), this.dispatchEvent(GE());
    }, this.onPlaying = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onPlaying: ${L == null ? void 0 : L.currentTime}`);
    }, this.onProgress = () => {
    }, this.onRateChange = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.debug(`onRateChange: ${L.playbackRate}`);
    }, this.onSeeked = async () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onSeeked: ${L == null ? void 0 : L.currentTime}`);
    }, this.onSeeking = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(`onSeeking: ${L == null ? void 0 : L.currentTime}`);
    }, this.onStalled = () => {
      const { logger: R } = this;
      R.silly("onStalled: The video data is no longer available.");
    }, this.onSuspend = () => {
      const { logger: R } = this;
      R.silly("onSuspend: Video data loading has been suspended.");
    }, this.onTimeUpdate = () => {
      const {
        player: { video: R }
      } = this;
      R && this.dispatchEvent(KE(R));
    }, this.onVolumeChange = () => {
      const {
        logger: R,
        player: { video: L }
      } = this;
      R.silly(
        `onVolumeChange: Volume = ${L == null ? void 0 : L.volume}, Muted = ${L == null ? void 0 : L.muted}`
      ), this.dispatchEvent(WE(L));
    }, this.onWaiting = () => {
      const { logger: R } = this;
      R.silly("onWaiting: Video is waiting for more data.");
    };
    const { deviceCapabilities: r, qualityManager: c } = t, w = new Ol("PlaybackManager");
    this.player = t, this.logger = w, this.updateBufferSize(0, 0), this.useWebGL2 = !!r.webGL2, this.qualityManager = c, this.bindEvents();
  }
  //buffer will hold all timecode pixels - 16*10*timecode_height_of_resolution*stride
  updateBufferSize(t, r) {
    const c = t > 0 ? t / id : 1, w = yr * ba, R = Ao * c, L = $s * w * R;
    this.timecodeByteLength = L, this.timecodeBuffer = new Uint8ClampedArray(L);
  }
  bindEvents() {
    const {
      player: t,
      player: { video: r, qualityManager: c }
    } = this;
    t.addEventListener(
      Il,
      this.onDashPlayerInitialized
    ), c.addEventListener(
      rd,
      this.onQualityChange
    ), r.addEventListener(fE, this.onCanPlay), r.addEventListener(mE, this.onCanPlayThrough), r.addEventListener(pE, this.onComplete), r.addEventListener(gE, this.onDurationChange), r.addEventListener(_E, this.onEmptied), r.addEventListener(yE, this.onEnded), r.addEventListener(bE, this.onError), r.addEventListener(EE, this.onLoadedData), r.addEventListener(vE, this.onLoadedMetadata), r.addEventListener(TE, this.onLoadStart), r.addEventListener(wE, this.onPause), r.addEventListener(AE, this.onPlay), r.addEventListener(SE, this.onPlaying), r.addEventListener(ME, this.onProgress), r.addEventListener(kE, this.onRateChange), r.addEventListener(xE, this.onSeeked), r.addEventListener(LE, this.onSeeking), r.addEventListener(DE, this.onStalled), r.addEventListener(IE, this.onSuspend), r.addEventListener(RE, this.onTimeUpdate), r.addEventListener(CE, this.onVolumeChange), r.addEventListener(NE, this.onWaiting);
  }
  setState(t) {
    const { logger: r } = this, c = this.state;
    if (c !== t) {
      if (c === zE)
        throw new Error(`Cannot transition from state ${c}`);
      r.warn(
        `${vm} ${c} -> ${t}`
      ), this.state = t, this.dispatchEvent(
        qE(t, c)
      );
    }
  }
  reset() {
    const { logger: t } = this;
    t.info("Resetting PlaybackManager."), this.state = Kh, this.dispatchEvent(HE());
  }
  process() {
    const { timecodeBuffer: t } = this;
    let r = 0;
    for (let c = 0, w = 0; c < ba; ++c) {
      const R = t[w + PE];
      r = r << 1 | (R > 127 ? 1 : 0), w += $s * yr;
    }
    return r;
  }
  isPaused() {
    const {
      player: { player: t }
    } = this;
    return t.isPaused();
  }
  pause() {
    const {
      logger: t,
      player: { player: r }
    } = this;
    t.silly("Pause");
    try {
      r.pause();
    } catch (c) {
      t.error(c);
    }
  }
  play() {
    const {
      logger: t,
      player: { player: r }
    } = this;
    t.silly("Play");
    try {
      r.play();
    } catch (c) {
      t.error(c);
    }
  }
  /**
   * Checks whether `currentTime` is buffered.
   */
  checkPlayback(t, r = 0) {
    const {
      player: {
        video: { buffered: c },
        meshSourceBuffer: w
      }
    } = this;
    return w.canPlay(t, r) ? oE(c, t, r) : !1;
  }
  requestPollForTime(t, r) {
    const {
      logger: c,
      player: { meshSourceBuffer: w }
    } = this;
    if (!w._isInitialized)
      return Promise.resolve();
    this.cancelPreviousPollForTime();
    const R = {
      time: t,
      wasPaused: r,
      resolve: Vh,
      reject: Vh
    };
    c.debug(`Requesting poll for time ${t} (was paused: ${r})`);
    const L = new Promise((h, b) => {
      R.reject = (o) => {
        R.resolved = !0, b(o);
      }, R.resolve = (o) => {
        R.resolved = !0, h(o);
      }, R.resolved = !1;
      const A = () => {
        R.resolved || (c.warn(
          `Could not seek to ${t} after timeout reached of ${Wh}`
        ), R.reject(new Error("ERR_SEEK_TIMEOUT")), this.cancelPreviousPollForTime());
      }, l = () => {
        if (R.resolved)
          return;
        const {
          player: { video: o, meshSourceBuffer: u }
        } = this;
        if (o && u && this.checkPlayback(t)) {
          this.currentPoll = null, c.debug(
            `Resolved polling for ${t} (was paused: ${r})`
          ), R.resolve(void 0);
          return;
        }
        this.pollForTimeTimerId = window.setTimeout(l, 100);
      };
      l(), window.setTimeout(A, Wh);
    });
    return this.currentPoll = R, L;
  }
  async seek(t) {
    const {
      logger: r,
      currentPoll: c,
      player: { player: w, video: R }
    } = this;
    if (!this.checkPlayback(t)) {
      r.warn(`Cannot seek to ${t}.`);
      return;
    }
    const L = c ? c.wasPaused : this.state !== kl || R.paused;
    r.debug(`Seeking to: ${t}, was paused: ${L}`), this.setState(Cu), L && this.pause();
    try {
      w.seekToPresentationTime(t), await this.requestPollForTime(t, L), this.setState(Gs), L || (r.debug(
        "Resuming video playback, as video was not paused earlier"
      ), await this.play(), this.setState(kl));
    } catch (h) {
      r.debug(`Could not seek to ${t}: ${h.message}`);
    }
  }
}
const Er = (Et, t) => new CustomEvent(Et, { detail: t }), Vs = (Et) => Er(W_, Et), YE = (Et) => Er(sy, Et), FE = (Et, t, r) => Er(oy, {
  framerates: Et,
  meshRepresentations: t,
  videoRepresentations: r
}), wm = (Et) => Er(rd, Et), Am = (Et) => Er(nm, Et), UE = () => Er(Il), jE = () => Er(uy), BE = () => Er(ly), HE = () => Er(lE), qE = (Et, t) => Er(vm, {
  newState: Et,
  oldState: t
}), GE = () => Er(uE), VE = () => Er(dE), WE = (Et) => Er(cE, {
  target: Et
}), KE = (Et) => Er(hE, { target: Et }), Xh = (Et) => {
  if (!by(Et))
    return -1;
  const t = /^(\d+)\/(\d+)$/.exec(Et);
  if (!t)
    return -1;
  const r = t[1], c = t[2], w = parseFloat(r), R = parseFloat(c);
  return !Rl(w) && !Rl(R) ? -1 : w / R;
}, Qh = (Et) => Et.sort((t, r) => t.bandwidth - r.bandwidth);
class $E extends EventTarget {
  constructor(t) {
    super(), this.useDecodedByteCount = !1, this.lastDecodedByteCount = 0, this.framerates = [], this.videoRepresentations = [], this.meshRepresentations = [], this.currentRepresentations = {
      [tm]: null,
      [Fr]: null,
      [Xa]: null
    }, this.bitrate = NaN, this.resolution = [0, 0], this.fps = 0, this.targetFPS = -1, this.onDashPlayerInitialized = () => {
      const {
        logger: c,
        currentRepresentations: w,
        player: { player: R }
      } = this;
      for (const L in w) {
        const h = R.getCurrentRepresentationForType(L);
        if (!h) {
          c.warn(`Could not get current representation for ${L}`);
          continue;
        }
        w[L] = h.id, L === Fr && this.selectMeshRepresentation(h);
      }
    }, this.onFragmentLoadingCompleted = () => {
    }, this.onQualityChangeRequested = (c) => {
      const { logger: w } = this, { mediaType: R, newRepresentation: L } = c;
      w.silly(
        `onQualityChangeRequested - mediaType: ${R}, id: ${L.id}, codecFamily: ${L.codecFamily}, codecs: ${L.codecs}`
      );
    }, this.onQualityChangeRendered = (c) => {
      const { logger: w, currentRepresentations: R } = this, { mediaType: L, newRepresentation: h } = c;
      if (R[L] = h.id, w.silly(
        `onQualityChangeRendered - mediaType: ${L}, id: ${h.id}, codecFamily: ${h.codecFamily}, codecs: ${h.codecs}`
      ), L === Fr && (this.selectMeshRepresentation(h), this.dispatchEvent(wm(h))), L === Xa) {
        const { id: b } = h, A = b.replace(/fps$/, ""), l = parseFloat(A);
        this.setCurrentFrameRate(l);
      }
    }, this.updateMeshRepresentation = () => {
      const {
        player: { player: c }
      } = this, w = c.getCurrentRepresentationForType(Fr);
      this.selectMeshRepresentation(w);
    }, this.filterRepresentation = (c) => {
      const {
        logger: w,
        player: {
          options: { maximumTextureSize: R }
        }
      } = this, { targetFPS: L } = this, { mimeType: h } = c;
      return h.startsWith("video") && c.width > R ? (w.silly(
        `Representation rejected on mobile for ${h}: ${c.id}`
      ), !1) : "framerate" in c && L !== -1 && !(c.framerate === `${L}/1`) ? !1 : (w.silly(
        `Representation selected for ${h}: ${c.id}`
      ), !0);
    };
    const {
      options: { targetFPS: r }
    } = t;
    this.player = t, this.targetFPS = r, this.logger = new Ol("QualityManager");
    try {
      const c = document.createElement("video");
      this.useDecodedByteCount = _y(c.webkitVideoDecodedByteCount);
    } catch {
    }
    this.bindEvents();
  }
  async configure() {
    const {
      logger: t,
      player: r,
      player: { player: c }
    } = this;
    t.info(
      `Configuring Player (is mobile: ${Dl}, is iOS: ${uu})`
    ), c.updateSettings(this.getDashSettings()), Dl && uu && (r.options.maximumTextureSize = 1024);
  }
  bindEvents() {
    const {
      player: t,
      player: { player: r }
    } = this;
    t.addEventListener(
      Il,
      this.onDashPlayerInitialized
    ), r.on(
      _i.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED,
      this.onFragmentLoadingCompleted
    ), r.on(
      _i.MediaPlayer.events.QUALITY_CHANGE_REQUESTED,
      this.onQualityChangeRequested
    ), r.on(
      _i.MediaPlayer.events.QUALITY_CHANGE_RENDERED,
      this.onQualityChangeRendered
    );
  }
  unbindEvents() {
    const {
      player: t,
      player: { player: r }
    } = this;
    t.removeEventListener(
      Il,
      this.onDashPlayerInitialized
    ), r && (r.off(
      _i.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED,
      this.onFragmentLoadingCompleted
    ), r.off(
      _i.MediaPlayer.events.QUALITY_CHANGE_REQUESTED,
      this.onQualityChangeRequested
    ), r.off(
      _i.MediaPlayer.events.QUALITY_CHANGE_RENDERED,
      this.onQualityChangeRendered
    ));
  }
  setCurrentFrameRate(t) {
    this.fps = t, this.dispatchEvent(Am(t));
  }
  enableABR() {
    const {
      logger: t,
      player: { player: r }
    } = this;
    t.info("Enabling ABR"), r.updateSettings({
      streaming: {
        abr: {
          autoSwitchBitrate: {
            [Fr]: !0
          }
        }
      }
    });
  }
  disableABR() {
    const {
      logger: t,
      player: { player: r }
    } = this;
    t.info("Disabling ABR"), r.updateSettings({
      streaming: {
        abr: {
          autoSwitchBitrate: {
            [Fr]: !1
          }
        }
      }
    });
  }
  /**
   * In case the video track changes, adapt to suitable representation of the
   * mesh.
   */
  selectMeshRepresentation(t) {
    const {
      logger: r,
      player: { player: c }
    } = this, { id: w, mediaType: R } = t;
    if (R === Fr)
      throw new Error(
        `Expected ${Fr}, but received ${R}.`
      );
    const L = c.getCurrentRepresentationForType(Xa);
    if (L && w.endsWith(L.id)) {
      r.silly(
        `Mesh representation (already) selected for video ${w}:  ${L.id}`
      );
      const A = parseFloat(L.id.replace("fps", ""));
      this.setCurrentFrameRate(A);
      return;
    }
    const b = c.getRepresentationsByType(Xa).find(
      (A) => w.endsWith(A.id)
    );
    if (b) {
      r.silly(
        `Selecting mesh representation for video ${w}: ${b.id}`
      );
      const A = parseFloat(b.id.replace("fps", ""));
      this.setCurrentFrameRate(A), c.setRepresentationForTypeById(
        Xa,
        b.id,
        !0
      );
    } else
      throw new Error(`No mesh representation found for ${w}.`);
  }
  /**
   * In case the mesh track changes, adapt to suitable representation of the
   * video.
   */
  selectVideoRepresentation(t) {
    const {
      logger: r,
      player: { player: c }
    } = this, { id: w, mediaType: R } = t;
    if (R === Xa)
      throw new Error(`
          Expected ${Xa}, but received ${R}.
          `);
    const L = c.getCurrentRepresentationForType(Fr);
    if (L && L.id.endsWith(w)) {
      r.info(
        `Video representation selected for mesh ${w}:  ${L.id}`
      );
      return;
    }
    const b = c.getRepresentationsByType(Fr).find(
      (A) => A.id.endsWith(w)
    );
    if (b)
      r.info(
        `Selecting video representation for mesh ${w}: ${b.id}`
      ), c.setRepresentationForTypeById(
        Fr,
        b.id,
        !0
      );
    else
      throw new Error(`No video representation found for ${w}.`);
  }
  //   pollMetrics = () => {
  //     return;
  //     const {
  //       logger,
  //       useDecodedByteCount,
  //       lastDecodedByteCount,
  //       player: { meshSourceBuffer, video, player: dashPlayer },
  //     } = this;
  //     const activeStream = dashPlayer.getActiveStream();
  //     if (!activeStream) {
  //       return;
  //     }
  //     const streamInfo = activeStream.getStreamInfo();
  //     const dashMetrics = dashPlayer.getDashMetrics();
  //     const dashAdapter = dashPlayer.getDashAdapter();
  //     if (!dashMetrics || !streamInfo) {
  //       return;
  //     }
  //     const periodIdx = streamInfo.index;
  //     const repSwitch = dashMetrics.getCurrentRepresentationSwitch(MEDIA_TYPE_VIDEO, true);
  //     const bufferLevel = dashMetrics.getCurrentBufferLevel(MEDIA_TYPE_VIDEO, true);
  //     if (!useDecodedByteCount) {
  //       this.bitrate = repSwitch
  //         ? Math.round(dashAdapter.getBandwidthForRepresentation(repSwitch.to, periodIdx) / 1000)
  //         : NaN;
  //     } else {
  //       this.bitrate = (((video.webkitVideoDecodedByteCount - lastDecodedByteCount) / 1000) * 8) / BITRATE_INTERVAL;
  //       this.lastDecodedByteCount = video.webkitVideoDecodedByteCount;
  //     }
  //     const adaptation = dashAdapter.getAdaptationForType(periodIdx, MEDIA_TYPE_VIDEO, streamInfo);
  //     if (!adaptation) {
  //       return;
  //     }
  //     // const meshBitRates = dashPlayer.getBitrateInfoListFor(MEDIA_TYPE_MESH);
  //     const currentRep = adaptation.Representation.find((rep) => rep.id === repSwitch.to);
  //     // const currentRepFramerate = parseFrameRate(currentRep.framerate);
  //     // const meshRepresentation = this.meshRepresentations.find((rep) => {
  //     //   return rep.framerate === currentRepFramerate;
  //     // });
  //     // const bitrate = meshBitRates.find((bitrate) => bitrate.bitrate === meshRepresentation.bandwidth);
  //     const { currentTime, duration } = video;
  //     this.currentTime = currentTime;
  //     this.duration = duration;
  //     this.progress = currentTime / duration;
  //     this.fps = currentRep.framerate;
  //     this.resolution = [currentRep.width, currentRep.height];
  //     this.bufferLevel = bufferLevel;
  //     if (!meshSourceBuffer) {
  //       return;
  //     }
  //     logger.debug(
  //       `
  // Polling stream condition:
  // Progress:     ${this.progress}
  // FPS:          ${this.fps}
  // Resolution:   ${this.resolution.join("x")}
  // Bitrate:      ${this.bitrate}
  // Buffer Level: ${this.bufferLevel}
  // Received:     ${getHumanFileSize(meshSourceBuffer.bytesReceived)}
  //       `.trim()
  //     );
  //   };
  parseManifest(t) {
    const {
      logger: r,
      player: c,
      player: {
        options: { maximumTextureSize: w }
      }
    } = this;
    r.silly("Parsing manifest:", t);
    const R = t.Period[0].AdaptationSet.find(
      (g) => g.contentType === Fr
    ), L = Qh(
      R.Representation.map((g) => {
        const { id: m, framerate: S, bandwidth: e, width: n, height: d } = g;
        return {
          id: m,
          bandwidth: e,
          framerate: Xh(S),
          width: n,
          height: d
        };
      })
    );
    if (L.filter(
      ({ width: g }) => g <= w
    ).length === 0) {
      const g = Array.from(
        new Set(
          L.map(({ width: m, height: S }) => `${m}x${S}`)
        )
      );
      c.dispatchEvent(
        Vs(
          `Could not find video stream smaller than the maximum size of ${w}x${w}.

Available: ${g.join(", ")}`
        )
      );
      return;
    }
    const b = t.Period[0].AdaptationSet.find(
      (g) => g.contentType === Xa
    ), A = Qh(
      b.Representation.map((g) => {
        const { id: m, framerate: S, bandwidth: e, codecs: n } = g;
        return {
          id: m,
          bandwidth: e,
          framerate: Xh(S),
          codecs: n
        };
      })
    ), l = Array.from(
      new Set(L.map(({ framerate: g }) => g))
    ), o = l.join(", ");
    let { targetFPS: u } = this;
    if (u === -1)
      r.silly(
        `Selecting frame rate automatically. Available framerates in this manifest: ${o}.`
      );
    else if (l.includes(u))
      r.silly(
        `Selecting target frame rate ${u} from available frame rates in this manifest: ${o}.`
      );
    else {
      const g = l.reduce(
        (m, S) => Math.abs(S - u) < Math.abs(m - u) ? S : m
      );
      r.warn(
        `Target frame rate ${u} not available in frame rates: ${l.join(
          ", "
        )}. Selecting closest frame rate ${g}.`
      ), u = g;
    }
    this.targetFPS = u, this.videoRepresentations = L, this.meshRepresentations = A, this.framerates = l;
  }
  getDashSettings() {
    const {
      logger: t,
      player: {
        options: { abr: r }
      }
    } = this, c = {
      debug: {
        $merge: {
          logLevel: _i.Debug.LOG_LEVEL_WARNING
        }
      },
      streaming: {
        buffer: {
          $merge: {
            // See also https://github.com/Dash-Industry-Forum/dash.js/issues/3595
            fastSwitchEnabled: !0,
            reuseExistingSourceBuffers: !1,
            flushBufferAtTrackSwitch: !0,
            resetSourceBuffersForTrackSwitch: !0,
            bufferTimeAtTopQualityLongForm: 15,
            bufferTimeAtTopQuality: 12
          }
        },
        gaps: {
          $merge: {
            jumpGaps: !1,
            jumpLargeGaps: !1,
            enableSeekFix: !1,
            enableStallFix: !0
          }
        },
        abr: {
          $merge: {
            autoSwitchBitrate: {
              audio: !1,
              video: !!r,
              // The mesh is selected in onQualityChangeRendered
              mesh: !1
            },
            rules: {
              throughputRule: {
                active: !0
              },
              bolaRule: {
                active: !1
              },
              insufficientBufferRule: {
                active: !0
              },
              switchHistoryRule: {
                active: !0
              },
              droppedFramesRule: {
                active: !0
              },
              abandonRequestsRule: {
                active: !0
              }
            }
          }
        },
        trackSwitchMode: {
          $merge: {
            audio: _i.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
            video: _i.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE,
            mesh: _i.Constants.TRACK_SWITCH_MODE_ALWAYS_REPLACE
          }
        }
      }
    };
    (uu || Zf) && (c.streaming.buffer.$merge.bufferToKeep = 10, c.streaming.buffer.$merge.bufferTimeAtTopQuality = 10, c.streaming.buffer.$merge.bufferTimeAtTopQualityLongForm = 10, c.streaming.buffer.$merge.bufferPruningInterval = 4);
    const w = aE(sE, c);
    return t.silly("dash.js settings:", w), w;
  }
}
const Pu = (Et) => (Et == null ? void 0 : Et.message) || (Et == null ? void 0 : Et.stack) || Et, Sm = (Et, t) => {
  const r = window.URL.createObjectURL(Et), c = document.createElement("a");
  c.href = r, c.setAttribute("download", t), document.body.appendChild(c), c.click(), document.body.removeChild(c);
};
var XE = `varying vec2 vUv;
uniform sampler2D videoMap;
uniform float contrast;
uniform float opacity;

void main() {
  vec3 col =
    clamp(texture2D(videoMap, vUv).rgb - vec3(1.0 - contrast), 0.0, 1.0) *
    1.0 /
    contrast;

  gl_FragColor = vec4(col, opacity);
}`, QE = `varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;
uniform sampler2D videoMap;
uniform float contrast;
uniform float opacity;

#define EPSILON (1e-6)

void main() {
  vec3 baseColor =
    clamp(texture2D(videoMap, vUv).rgb - vec3(1.0 - contrast), 0.0, 1.0) /
    contrast;
  vec3 viewDir = normalize(cameraPosition - vPosition);
  vec3 normal = normalize(vNormal);
  float lighting = smoothstep(
    0.0,
    1.0,
    max(dot(normal, viewDir), contrast * 0.85)
  );
  vec3 col = baseColor * lighting;
  gl_FragColor = vec4(col, opacity);
}`, JE = `attribute vec4 weightsAtt;
attribute vec4 bindingsAtt;

uniform mat4 boneTransforms[25];
varying vec2 vUv;

void main() {
  vUv = uv;
  
  vec4 totalAnimatedPos = vec4(0.0);
  for (int i = 0; i < 4; i++) {
    int index = int(bindingsAtt[i]);
    if (index == -1 || index == 0) {
      totalAnimatedPos = vec4(position, 1.0);
      break;
    }
    vec4 localAnimatedPos = boneTransforms[index] * vec4(position, 1.0);
    totalAnimatedPos += localAnimatedPos * weightsAtt[i];
  }
  gl_Position =
    projectionMatrix * modelViewMatrix * vec4(totalAnimatedPos.xyz, 1.0);
}`, ZE = `attribute vec4 weightsAtt;
attribute vec4 bindingsAtt;

uniform mat4 boneTransforms[25];
varying vec2 vUv;
varying vec3 vNormal;
varying vec3 vPosition;

void main() {
  vUv = uv;
  vNormal = normal;

  
  vec4 totalAnimatedPos = vec4(0.0);
  for (int i = 0; i < 4; i++) {
    int index = int(bindingsAtt[i]);
    if (index == -1 || index == 0) {
      totalAnimatedPos = vec4(position, 1.0);
      break;
    }
    vec4 localAnimatedPos = boneTransforms[index] * vec4(position, 1.0);
    totalAnimatedPos += localAnimatedPos * weightsAtt[i];
  }
  gl_Position =
    projectionMatrix * modelViewMatrix * vec4(totalAnimatedPos.xyz, 1.0);
  vPosition = mat3(modelViewMatrix) * position;
}`;
const Jh = (Et, t = ny, r = 0.98) => new Promise((c, w) => {
  try {
    const R = document.createElement("canvas");
    R.width = Et.videoWidth, R.height = Et.videoHeight;
    const L = R.getContext("2d");
    L.translate(0, R.height), L.scale(1, -1), L.drawImage(Et, 0, 0, R.width, R.height);
    const h = R.toDataURL(t, r), b = new Image();
    b.src = h, new Tb().load(h, c);
  } catch (R) {
    w(R);
  }
}), bo = (Et, t) => String(Et).padStart(t, "0"), zu = (Et) => {
  const t = /* @__PURE__ */ new Date(), r = t.getFullYear(), c = bo(t.getMonth() + 1, 2), w = bo(t.getDate(), 2), R = {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: !0
  }, h = new Intl.DateTimeFormat("en-US", R).format(t), [b, A] = h.split(" "), [l, o, u] = b.split(/[: ]/), g = `${r}-${c}-${w}`, m = `${bo(l, 2)}-${bo(o, 2)}-${bo(u, 2)}${A ? "-" + A : ""}`;
  return `8i.com@${g}-${m}.${Et}`;
};
class tv {
  setup(t) {
    this.player = t, t.setupTextures = this.setupTextures.bind(t), t.setupMaterials = this.setupMaterials.bind(t), t.setupMesh = this.setupMesh.bind(t), t.copyVideoToStagingTexture = this.copyVideoToStagingTexture.bind(t), t.updateRenderTexture = this.updateRenderTexture.bind(t), t.createTexture = this.createTexture.bind(t), t.createFramebuffer = this.createFramebuffer.bind(t), t.createPixelBuffer = this.createPixelBuffer.bind(t), t.processTimecode = this.processTimecode.bind(t), t.saveFrameAsGLTF = this.saveFrameAsGLTF.bind(t), t.saveFrameAsUSDZ = this.saveFrameAsUSDZ.bind(t), t.saveFrameAsScreenshot = this.saveFrameAsScreenshot.bind(t), t.getFrameAsScreenshot = this.getFrameAsScreenshot.bind(t), t.handleVideoResolutionChange = this.handleVideoResolutionChange.bind(t), t.setOpacity = this.setOpacity.bind(t), t.setContrast = this.setContrast.bind(t), t.displayDrawTimecodeRegion = this.displayDrawTimecodeRegion.bind(t), t.debugDrawEntireFramebuffer = this.debugDrawEntireFramebuffer.bind(t);
  }
  /**
   * Processes the timecode information from the video frame to determine the current frame number.
   * The timecode is encoded as a series of black and white pixels in the top-right corner of the video frame.
   * IMPORTANT:The width of the timecode is always 16px per bit, while the height scales with the texture resolution.
   *
   * @param videoWidth - The width of the current video frame
   */
  processTimecode(t) {
    const {
      framebuffer: r,
      gl: c,
      pixelBuffer: w,
      video: R,
      options: { displayDrawTimecodeRegion: L, displayEntireFramebuffer: h },
      playbackManager: { timecodeByteLength: b, useWebGL2: A, timecodeBuffer: l }
    } = this, [o, u, g] = Em(t), m = t - u, S = 0;
    if (A) {
      c.bindFramebuffer(c.FRAMEBUFFER, r);
      const p = c.checkFramebufferStatus(c.FRAMEBUFFER);
      if (p !== c.FRAMEBUFFER_COMPLETE)
        return console.warn("Framebuffer is not complete. Status:", p), 0;
      c.bindBuffer(c.PIXEL_PACK_BUFFER, w), c.drawingBufferWidth, c.drawingBufferHeight, c.bufferData(c.PIXEL_PACK_BUFFER, b, c.STATIC_COPY), c.readPixels(
        m,
        S,
        u,
        g,
        c.RGBA,
        c.UNSIGNED_BYTE,
        0
        // Offset into the pixel buffer
      ), c.getBufferSubData(c.PIXEL_PACK_BUFFER, 0, l);
    } else {
      c.bindFramebuffer(c.FRAMEBUFFER, r);
      const p = c.checkFramebufferStatus(c.FRAMEBUFFER);
      if (p !== c.FRAMEBUFFER_COMPLETE)
        return console.warn("Framebuffer is not complete. Status:", p), 0;
      c.readPixels(
        m,
        S,
        u,
        g,
        c.RGBA,
        c.UNSIGNED_BYTE,
        l
      );
    }
    L && this.displayDrawTimecodeRegion(
      m,
      S,
      u,
      g
    ), h && this.debugDrawEntireFramebuffer();
    const e = u * g * $s;
    l.length !== e && console.error(
      `Invalid buffer size. Expected ${e}, got ${l.length}`
    );
    let n = 0, d = 0;
    const _ = $s * yr * o;
    for (let p = 0; p < ba; ++p)
      d += _, l[d] > 200 && (n += 1 << p);
    return n;
  }
  handleVideoResolutionChange() {
    const {
      logger: t,
      video: { videoWidth: r, videoHeight: c }
    } = this;
    t.info(
      `Video resolution changed to ${r}x${c} - Resetting textures.`
    ), this.isTextureAllocated = !1;
  }
  /**
   * Saves the current frame as a GLTF (binary) file.
   */
  async saveFrameAsGLTF(t = zu("glb")) {
    const { mesh: r, video: c } = this, w = !c.paused;
    let R = null, L = null, h = null;
    try {
      w && c.pause(), R = r.clone(), L = R.material.clone(), R.material = new Ih(), R.material.map = await Jh(c);
      const { GLTFExporter: b } = await import("./GLTFExporter-C7CdpNw8.js"), A = new b(), l = {
        onlyVisible: !1,
        binary: !0,
        embedImages: !0
      }, o = await A.parseAsync(R, l);
      h = new Blob([o], { type: "model/gltf-binary" });
    } catch (b) {
      console.error(`Error when creating GLTF: ${b}`);
    }
    return R && (R.material = L), w && c.play(), {
      blob: h,
      filename: t
    };
  }
  async saveFrameAsUSDZ(t = zu("usdz")) {
    const { mesh: r, video: c } = this, w = !c.paused;
    let R = null, L = null, h = null;
    try {
      w && c.pause(), R = r.clone();
      const b = R.material.clone();
      R.material = new Ih(), R.material.map = await Jh(c);
      const { USDZExporter: A } = await import("./USDZExporter-f6OuwF7I.js"), l = new A(), o = {
        maxTextureSize: 1 / 0,
        quickLookCompatible: !0
      }, u = await l.parseAsync(R, o);
      h = new Blob([u], {
        type: "model/vnd.usdz+zip"
      });
    } catch (b) {
      console.error(`Error when creating USDZ: ${b}`);
    }
    return R.material = L, w && c.play(), {
      blob: h,
      filename: t
    };
  }
  async getFrameAsScreenshot() {
    const { renderer: t } = this;
    return new Promise((r, c) => {
      try {
        t.domElement.toBlob(r);
      } catch (w) {
        reject(w);
      }
    });
  }
  async saveFrameAsScreenshot(t = zu("png")) {
    const r = await this.getFrameAsScreenshot();
    r.name = t, Sm(r, t);
  }
  setupTextures() {
    const {
      gl: t,
      renderer: r,
      deviceCapabilities: { anisotropicExtension: c }
    } = this, w = this.createTexture(), R = this.createFramebuffer(w), L = this.createTexture(), h = this.createPixelBuffer();
    if (c) {
      t.bindTexture(t.TEXTURE_2D, L);
      const A = Math.min(
        10,
        t.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      );
      t.texParameterf(
        t.TEXTURE_2D,
        c.TEXTURE_MAX_ANISOTROPY_EXT,
        A
      );
    }
    t.bindTexture(t.TEXTURE_2D, null);
    const b = r.properties.get(L);
    b.__webglTexture = L, this.pixelBuffer = h, this.framebuffer = R, this.stagingTexture = w, this.renderTexture = L;
  }
  setupMaterials() {
    const {
      renderTexture: t,
      options: { enableDirectionalLight: r, opacity: c, contrast: w }
    } = this, R = new Array(J_);
    R.fill(new Br());
    const L = gb.clone(Dh.uniforms);
    L.videoMap = new Ws(t), L.opacity = new Ws(c), L.contrast = new Ws(w), L.boneTransforms = new Ws(R);
    const h = new Dh({
      glslVersion: Dy,
      defaultAttributeValues: {
        weightsAtt: [0, 0, 0, 0],
        bindingsAtt: [0, 0, 0, 0]
      },
      uniforms: L,
      vertexShader: r ? ZE : JE,
      fragmentShader: r ? QE : XE,
      transparent: !0,
      side: Cl
    });
    this.defaultMaterial = h;
  }
  setOpacity(t) {
    const { logger: r } = this;
    if (!this.mesh) {
      r.warn(`setOpacity: ${t} - No mesh available`);
      return;
    }
    r.debug(`setOpacity: ${t}`);
    const {
      mesh: { material: c }
    } = this;
    c.uniforms.opacity.value = t;
  }
  setContrast(t) {
    const { logger: r } = this;
    if (!this.mesh) {
      r.warn(`setContrast: ${t} - No mesh available`);
      return;
    }
    r.debug(`setContrast: ${t}`);
    const {
      mesh: { material: c }
    } = this;
    c.uniforms.contrast.value = t;
  }
  setupMesh() {
    const { defaultMaterial: t } = this, r = new hb(void 0, t);
    if (!r)
      throw new Error("Failed to initalize mesh");
    this.mesh = r;
  }
  copyVideoToStagingTexture() {
    const { gl: t, stagingTexture: r, video: c } = this;
    t.bindTexture(t.TEXTURE_2D, r), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1), this.isTextureAllocated ? t.texSubImage2D(
      t.TEXTURE_2D,
      0,
      0,
      0,
      t.RGBA,
      t.UNSIGNED_BYTE,
      c
    ) : t.texImage2D(
      t.TEXTURE_2D,
      0,
      t.RGBA,
      t.RGBA,
      t.UNSIGNED_BYTE,
      c
    ), t.bindTexture(t.TEXTURE_2D, null);
  }
  /**
   * Updates the render texture with the current video frame.
   */
  updateRenderTexture() {
    const {
      gl: t,
      renderTexture: r,
      framebuffer: c,
      video: { videoWidth: w, videoHeight: R }
    } = this;
    t.bindTexture(t.TEXTURE_2D, r), t.bindFramebuffer(t.FRAMEBUFFER, c), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1), this.isTextureAllocated ? t.copyTexSubImage2D(
      t.TEXTURE_2D,
      0,
      0,
      0,
      0,
      0,
      w,
      R
    ) : t.copyTexImage2D(
      t.TEXTURE_2D,
      0,
      t.RGBA,
      0,
      // x
      0,
      // y
      w,
      // width
      R,
      // height
      0
    ), t.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  /**
   * Create a new WebGL texture with default values.
   */
  createTexture() {
    const { gl: t } = this, r = t.createTexture();
    if (!r)
      throw new Error("Failed to create WebGL texture");
    return t.bindTexture(t.TEXTURE_2D, r), t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, !1), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.texImage2D(
      t.TEXTURE_2D,
      0,
      t.RGB,
      X_,
      Q_,
      0,
      t.RGB,
      t.UNSIGNED_BYTE,
      null
    ), t.bindTexture(t.TEXTURE_2D, null), r;
  }
  /**
   * Create a new WebGL framebuffer with default values.
   * @param texture
   */
  createFramebuffer(t) {
    const { gl: r } = this, c = r.createFramebuffer();
    if (!c)
      throw new Error("Failed to create WebGL framebuffer");
    return r.bindFramebuffer(r.FRAMEBUFFER, c), r.framebufferTexture2D(
      r.FRAMEBUFFER,
      r.COLOR_ATTACHMENT0,
      r.TEXTURE_2D,
      t,
      0
    ), r.bindFramebuffer(r.FRAMEBUFFER, null), c;
  }
  /**
   * Create a new pixel buffer with default values.
   * The buffer is used in `timecode` in order to hold the current frame's
   * frame number.
   */
  createPixelBuffer() {
    const { gl: t } = this, r = t.createBuffer();
    if (!r)
      throw new Error("Failed to create WebGL pixel buffer");
    t.bindBuffer(t.PIXEL_PACK_BUFFER, r);
    const c = yr * Ao * $s, w = new Uint8Array(c);
    return t.bufferData(t.PIXEL_PACK_BUFFER, w, t.STATIC_COPY), t.bindBuffer(t.PIXEL_PACK_BUFFER, null), r;
  }
  debugDrawEntireFramebuffer() {
    const { gl: t, framebuffer: r, video: c } = this;
    this.framebufferDebugCanvas || (this.framebufferDebugCanvas = document.createElement("canvas"), this.framebufferDebugCanvas.style.position = "absolute", this.framebufferDebugCanvas.style.zIndex = "1000", this.framebufferDebugCanvas.style.pointerEvents = "none", this.framebufferDebugCanvas.style.right = "10px", this.framebufferDebugCanvas.style.bottom = "10px", this.framebufferDebugCanvas.style.border = "2px solid blue", document.body.appendChild(this.framebufferDebugCanvas)), this.framebufferDebugCanvas.width = c.videoWidth, this.framebufferDebugCanvas.height = c.videoHeight, this.framebufferDebugCanvas.style.width = "50%", this.framebufferDebugCanvas.style.height = "auto";
    const w = c.videoWidth * c.videoHeight * 4, R = new Uint8Array(w);
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.bindBuffer(t.PIXEL_PACK_BUFFER, this.pixelBuffer), t.bufferData(t.PIXEL_PACK_BUFFER, w, t.STATIC_COPY), t.readPixels(
      0,
      0,
      c.videoWidth,
      c.videoHeight,
      t.RGBA,
      t.UNSIGNED_BYTE,
      0
    ), t.getBufferSubData(t.PIXEL_PACK_BUFFER, 0, R), t.bindBuffer(t.PIXEL_PACK_BUFFER, null);
    const L = this.framebufferDebugCanvas.getContext("2d"), h = L.createImageData(c.videoWidth, c.videoHeight);
    for (let u = 0; u < c.videoHeight; u++)
      for (let g = 0; g < c.videoWidth; g++) {
        const m = (g + u * c.videoWidth) * 4, S = (g + u * c.videoWidth) * 4;
        h.data[S] = R[m], h.data[S + 1] = R[m + 1], h.data[S + 2] = R[m + 2], h.data[S + 3] = 255;
      }
    L.putImageData(h, 0, 0);
    const b = c.videoWidth / id, A = c.videoHeight - c.videoHeight, o = c.videoWidth - yr * ba + 0;
    L.strokeStyle = "red", L.lineWidth = 2, L.strokeRect(
      o,
      A,
      yr * ba,
      Ao * b
    ), t.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  displayDrawTimecodeRegion(t, r, c, w) {
    if (!this.debugCanvas) {
      this.debugCanvas = document.createElement("canvas"), this.debugCanvas.style.position = "absolute", this.debugCanvas.style.zIndex = "1000", this.debugCanvas.style.pointerEvents = "none";
      const A = this.video, l = A.getBoundingClientRect();
      this.debugCanvas.style.top = `${l.top}px`, this.debugCanvas.style.left = `${l.left}px`, document.body.appendChild(this.debugCanvas), new ResizeObserver(() => {
        const u = A.getBoundingClientRect();
        this.debugCanvas.style.top = `${u.top}px`, this.debugCanvas.style.left = `${u.left}px`, this.debugCanvas.width = u.width, this.debugCanvas.height = u.height;
      }).observe(A);
    }
    const R = this.video.getBoundingClientRect();
    this.debugCanvas.width = R.width, this.debugCanvas.height = R.height;
    const L = R.width / this.video.videoWidth, h = R.height / this.video.videoHeight, b = this.debugCanvas.getContext("2d");
    b.clearRect(0, 0, this.debugCanvas.width, this.debugCanvas.height), b.strokeStyle = "red", b.lineWidth = 2, b.strokeRect(t * L, r * h, c * L, w * h), b.fillStyle = "red", b.font = "12px monospace", b.fillText(
      `Timecode Region (${c}x${w})`,
      t * L,
      r * h - 5
    );
  }
}
window.requestIdleCallback = window.requestIdleCallback || function(Et) {
  var t = Date.now();
  return setTimeout(function() {
    Et({
      didTimeout: !1,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - t));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(Et) {
  clearTimeout(Et);
};
const ev = {
  abr: !0,
  loop: !0,
  autoplay: !1,
  muted: !0,
  video: void 0,
  targetFPS: -1,
  maximumTextureSize: 1 / 0,
  displayDebugCanvas: !1,
  //The debugCanvas is the black box that displays the video timecode and framerate
  displayTimecodeInDebugCanvas: !1,
  //this is the timecode within the debugCanvas
  displayTimecodeVideoOrigin: !1,
  //this shows the actual video texture we are reading the timecode from
  displayDrawTimecodeRegion: !1,
  //this draws a red box around the timecode region of the timecode video origin
  displayEntireFramebuffer: !1,
  //this draws the entire video texture on the screen with a red box around it. It can catch discrepancies between the video texture and the timecode video origin
  displayFramerate: !1,
  licenseServerURL: void 0,
  enableDirectionalLight: !Dl,
  opacity: ey,
  contrast: ty
}, Ou = 320, Yu = 96, Fu = yr, Tl = 5;
class nv extends EventTarget {
  constructor(t, r, c) {
    super(), this.logger = null, this.fpsMeter = null, this.options = {
      ...ev
    }, this.gl = null, this.renderer = null, this.video = null, this.canvas = null, this.implementation = null, this.qualityManager = null, this.playbackManager = null, this.meshSourceBuffer = null, this.player = null, this.mesh = null, this.stagingTexture = null, this.renderTexture = null, this.pixelBuffer = null, this.framebuffer = null, this.defaultMaterial = null, this.isInitialized = !1, this.isRendering = !1, this.lastFrame = 0, this.manifestSrc = null, this.isTextureAllocated = !1, this.previousVideoWidth = 0, this.previousVideoHeight = 0, this.deviceCapabilities = {
      isMobile: Dl,
      isTablet: V_,
      isDesktop: G_,
      isSafari: Zf,
      webGL2: !1,
      requestVideoFrameCallback: !1,
      anisotropicExtension: !1,
      webWorkers: !1,
      supportImmersiveVR: !1,
      supportImmersiveAR: !1
    }, this.initialize = async () => {
      this.isInitialized || (await this.installMediaSourcePolyfills(), this.setupPlayerEventListeners(), this.setupPublicAPI(), await this.checkAsyncDeviceCapabilities(), this.isInitialized = !0);
    }, this.checkDeviceCapabilities = async () => {
      const { gl: w, logger: R, deviceCapabilities: L } = this;
      L.webGL2 = Qb(), L.requestVideoFrameCallback = "requestVideoFrameCallback" in HTMLVideoElement.prototype, L.anisotropicExtension = w.getExtension("EXT_texture_filter_anisotropic") || w.getExtension("MOZ_EXT_texture_filter_anisotropic") || w.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), L.webWorkers = !!window.Worker, R.silly("Capabilities:", JSON.stringify(L));
    }, this.checkAsyncDeviceCapabilities = async () => {
      const { logger: w, deviceCapabilities: R } = this;
      let L = !1, h = !1;
      try {
        if (!navigator.xr || !navigator.xr.isSessionSupported || !navigator.xr.requestSession)
          throw new Error("Immersive VR support cannot be determined.");
        L = await navigator.xr.isSessionSupported(
          dy
        );
      } catch (b) {
        w.warn(`Could not determine immersive VR support: ${b.stack}`);
      }
      R.supportImmersiveVR = L;
      try {
        if (!navigator.xr || !navigator.xr.isSessionSupported || !navigator.xr.requestSession)
          throw new Error("Immersive VR support cannot be determined.");
        h = await navigator.xr.isSessionSupported(
          cy
        );
      } catch (b) {
        w.warn(`Could not determine immersive VR support: ${b.stack}`);
      }
      R.supportImmersiveAR = h, w.silly("Capabilities:", JSON.stringify(R));
    }, this.onManifestLoaded = ({ data: w }) => {
      const { qualityManager: R } = this;
      try {
        R.parseManifest(w);
        const { framerates: L, meshRepresentations: h, videoRepresentations: b } = R;
        this.dispatchEvent(
          FE(
            L,
            h,
            b
          )
        );
      } catch (L) {
        const h = Pu(L);
        this.dispatchEvent(
          Vs(`Could not parse manifest: ${h}`)
        );
      }
    }, this.onStreamInitialized = (w) => {
      const { logger: R } = this;
      R.silly("onStreamInitialized", w);
    }, this.onPlayerError = (w) => {
      const { logger: R } = this, { error: L } = w, h = Pu(L);
      if (L.code === _i.MediaPlayer.errors.MEDIA_KEY_MESSAGE_NO_LICENSE_SERVER_URL_ERROR_CODE) {
        this.dispatchEvent(
          Vs(`Could not obtain stream keys: ${h}`)
        );
        return;
      }
      R.error(h), this.dispatchEvent(Vs(h));
    }, this.onQualityChange = (w) => {
      this.dispatchEvent(wm(w.detail));
    }, this.onFramerateChange = (w) => {
      this.dispatchEvent(Am(w.detail));
    }, this.onBufferEmpty = () => {
    }, this.onBufferLoaded = () => {
    }, this.logger = new Ol("8i Web Player"), this.options = { ...this.options, ...c }, this.renderer = t, this.logger.silly("DashPlayer settings:", this.options), this.gl = t.getContext(), this.checkDeviceCapabilities(), this.setupTextureVideoElement(), this.setupDebugCanvasElement(), r.setup(this), this.setupTextures(), this.setupMaterials(), this.setupMesh(), this.setupDashPlayer(), this.setupQualityManager(), this.setupPlaybackManager();
  }
  // The following methods must be implemented in `DashPlayerWebGLImplementation``
  setupTextures() {
    throw new Error(Yr);
  }
  setupMaterials() {
    throw new Error(Yr);
  }
  setupMesh() {
    throw new Error(Yr);
  }
  copyVideoToStagingTexture() {
    throw new Error(Yr);
  }
  processTimecode() {
    throw new Error(Yr);
  }
  async saveFrame() {
    let t = null;
    const r = Pa.iOS();
    r ? t = await this.saveFrameAsUSDZ() : t = await this.saveFrameAsGLTF();
    const { blob: c, filename: w } = t;
    if (c) {
      if (r) {
        const R = URL.createObjectURL(c), L = new URL(R, window.location.href), h = document.createElement("a"), b = document.createElement("img");
        h.appendChild(b), h.setAttribute("rel", "ar"), h.setAttribute("href", L.toString()), h.setAttribute("download", w), h.style.display = "none", h.click(), URL.revokeObjectURL(R);
        return;
      }
      Sm(c, w);
    }
  }
  async saveFrameAsGLTF() {
    throw new Error(Yr);
  }
  async saveFrameAsUSDZ() {
    throw new Error(Yr);
  }
  async saveFrameAsScreenshot() {
    throw new Error(Yr);
  }
  async getFrameAsScreenshot() {
    throw new Error(Yr);
  }
  /**
   * Updates the render texture with the current video frame.
   */
  updateRenderTexture() {
    throw new Error(Yr);
  }
  /**
   * Creates the underlying Dash.js `MediaPlayer` instance.
   */
  setupDashPlayer() {
    this.player = _i.MediaPlayer().create();
  }
  setupQualityManager() {
    this.qualityManager = new $E(this);
  }
  setupPlaybackManager() {
    this.playbackManager = new OE(this);
  }
  async reset() {
    const { logger: t, player: r, meshSourceBuffer: c, playbackManager: w } = this;
    t.debug("Resetting player."), r && r.reset(), w && w.reset(), c && c.reset();
  }
  /**
   * Initializes the player, if applicable and loads the specified 8i MPD manifest.
   */
  async loadManifest(t) {
    const { logger: r, mesh: c } = this;
    this.isRendering = !1, r.debug(`Loading manifest: ${t}`), this.dispatchEvent(YE(t)), this.isTextureAllocated = !1, c.visible && (c.visible = !1);
    const {
      player: w,
      qualityManager: R,
      video: L,
      options: { licenseServerURL: h, autoplay: b }
    } = this;
    this.isInitialized ? await this.reset() : await this.initialize();
    try {
      this.manifestSrc = t, await this.qualityManager.configure();
      let A;
      Ey(h) && (A = {
        "org.w3.clearkey": {
          serverURL: h
        }
      }), A && (w.setProtectionData(A), w.registerLicenseResponseFilter(async (l) => {
        const {
          url: o,
          data: { type: u, keys: g }
        } = l;
        if (!this.meshSourceBuffer)
          throw new Error("No CustomSourceBuffer instance available");
        r.info(
          `Retrieved ${g.length} ${u} key(s) from ${o}.`
        );
        for (const m of l.data.keys) {
          const S = await window.crypto.subtle.importKey(
            my,
            {
              kty: m.kty,
              k: m.k.replace(/=/g, ""),
              alg: hy,
              ext: !0
            },
            { name: im },
            !1,
            [fy]
          );
          this.meshSourceBuffer.setKey(S);
        }
        return this.dispatchEvent(jE()), l;
      })), w.registerCustomCapabilitiesFilter(
        R.filterRepresentation
      ), w.initialize(L, t, !!b), await Zb(L);
    } catch (A) {
      const l = Pu(A);
      this.dispatchEvent(
        Vs(`Could not load manifest: ${l}`)
      );
    }
  }
  async setTargetFPS(t) {
    const { qualityManager: r, logger: c } = this;
    if (!Rl(t))
      throw new Error(`Expected a number, received: ${t}`);
    if (t !== -1 && t < 0)
      throw new Error(
        `Expected target framerate to be -1 or >= 0, received: ${t}.`
      );
    return c.debug(`Set target FPS to ${t}`), r.targetFPS = t, this.loadManifest(this.manifestSrc);
  }
  setOpacity() {
    throw new Error(Yr);
  }
  setContrast() {
    throw new Error(Yr);
  }
  destroy() {
    const { logger: t, player: r, mesh: c, qualityManager: w } = this;
    this.dispatchEvent(BE()), this.isInitialized = !1, t.debug("Destroying instance."), r && (r.off(
      _i.MediaPlayer.events.MANIFEST_LOADED,
      this.onManifestLoaded
    ), r.off(
      _i.MediaPlayer.events.STREAM_INITIALIZED,
      this.onStreamInitialized
    ), r.off(_i.MediaPlayer.events.ERROR, this.onPlayerError)), w.unbindEvents();
    try {
      r.destroy();
    } catch {
    }
    if (this.player = null, c.parent)
      try {
        c.parent.remove(c);
      } catch {
      }
    this.removeVideoElement();
  }
  setupPlayerEventListeners() {
    const { player: t, qualityManager: r } = this;
    t.on(_i.MediaPlayer.events.MANIFEST_LOADED, this.onManifestLoaded), t.on(
      _i.MediaPlayer.events.STREAM_INITIALIZED,
      this.onStreamInitialized
    ), t.on(_i.MediaPlayer.events.ERROR, this.onPlayerError), r.addEventListener(
      rd,
      this.onQualityChange
    ), r.addEventListener(
      nm,
      this.onFramerateChange
    );
  }
  setupPublicAPI() {
    const { player: t, qualityManager: r, playbackManager: c } = this;
    this.play = (...w) => c.play(...w), this.isPaused = () => c.isPaused(), this.isMuted = () => t.isMuted(), this.setIsMuted = (w) => t.setMute(!!w), this.setVolume = (w) => t.setVolume(w), this.getCurrentFrame = () => {
      const { fps: w } = r;
      return Math.floor(t.time() * w);
    }, this.getCurrentTime = () => t.time(), this.getDuration = () => t.duration(), this.getVideo = () => t.getVideoElement(), this.getMeshSourceBuffer = () => this.meshSourceBuffer, this.pause = (...w) => c.pause(...w), this.seek = (...w) => c.seek(...w);
  }
  /**
   * Creates the underlying video element which is used in order to play back the actual stream. On iOS, it is required
   * that the video element is in view.
   */
  setupTextureVideoElement() {
    const {
      options: {
        loop: t,
        muted: r,
        displayTimecodeVideoOrigin: c,
        video: w
      }
    } = this, R = w || document.createElement("video");
    if (!w) {
      if (c) {
        let L;
        const h = {
          position: "absolute",
          top: "0px",
          right: "0px"
        };
        Object.assign(R.style, h), L = document.createElement("div"), L.classList.add("video-container");
        const b = {
          // overflow: "hidden", //Turned off for debug purposes.
          zIndex: "998",
          display: "block",
          pointerEvents: "none",
          backgroundColor: "green",
          position: "fixed",
          width: `${yr * ba}px`,
          height: `${Ao}px`,
          top: `${Yu}px`
        };
        Object.assign(L.style, b), document.body.append(L), L.append(R);
      } else {
        const L = {
          position: "fixed",
          top: "0px",
          right: "0px",
          width: "2px",
          height: "2px",
          zIndex: "998",
          display: "block",
          opacity: "1"
          //Originally .01
        };
        Object.assign(R.style, L), document.body.append(R);
      }
      R.style.pointerEvents = "none";
    }
    R.setAttribute("crossorigin", "anonymous"), R.setAttribute("playsinline", "playsinline"), R.setMediaKeys = () => Promise.resolve(), this.video = R, R.muted = !!r, R.loop = !!t;
  }
  /**
   * Creates the underlying video element which is used in order to play back the actual stream. On iOS, it is required
   * that the video element is in view.
   */
  setupDebugCanvasElement() {
    const {
      options: { displayDebugCanvas: t, displayFramerate: r }
    } = this;
    if (t) {
      const w = document.createElement("canvas"), R = {
        position: "fixed",
        top: "0px",
        left: "0px",
        zIndex: "998",
        // canvas.style.opacity = "0.5";
        pointerEvents: "none"
      };
      Object.assign(w.style, R), document.body.append(w), this.canvas = w;
    }
    const c = t ? 64 : 0;
    if (r) {
      const w = new FPSMeter({
        interval: 1e3,
        top: c,
        left: 0,
        zIndex: 1e3
      });
      this.fpsMeter = w;
    }
  }
  /**
   * Removes the video element, if applicable.
   */
  removeVideoElement() {
    const { video: t } = this;
    if (t) {
      if (!t.paused)
        try {
          t.pause();
        } catch {
        }
      t.parentElement && t.parentElement.removeChild(t), this.video = null;
    }
  }
  /**
   * Alternative to `startRenderLoop` -  Makes use of the `requestVideoFrameCallback` API
   * in order to be optimize calling `update`. This API is not supported on all
   * browsers.
   */
  attachVideoFrameCallback() {
    const {
      /*logger, */
      video: t
    } = this, r = () => {
      this.video && (this.update(), t.requestVideoFrameCallback(r));
    };
    if (t.requestVideoFrameCallback(r), window.requestIdleCallback) {
      const c = () => {
        this.video && (this.video.paused && this.update(), window.requestIdleCallback(c));
      };
      window.requestIdleCallback(c);
    } else {
      const c = () => {
        this.video && (this.video.paused && this.update(), window.requestAnimationFrame(c));
      };
      window.requestAnimationFrame(c);
    }
  }
  startRenderLoop() {
    const t = () => {
      this.video && (this.update(), window.requestAnimationFrame(t));
    };
    window.requestAnimationFrame(t);
  }
  async installMediaSourcePolyfills() {
    const {
      /*logger,*/
      video: t,
      deviceCapabilities: { webWorkers: r }
    } = this, c = this, w = window.MediaSource || window.ManagedMediaSource;
    if (typeof w > "u") {
      this.dispatchEvent(Vs("MediaSource API not available.")), await delay(1e3), alert("MediaSource API not available.");
      return;
    }
    const R = w.prototype.addSourceBuffer, L = r === !1, h = function(...l) {
      const o = l[0];
      if (o === Qc || o === Jc) {
        c.meshSourceBuffer && (c.meshSourceBuffer.abort(), c.meshSourceBuffer.destroy());
        const u = new iE(
          o,
          L,
          t
        );
        return c.meshSourceBuffer = u, u;
      }
      return R.apply(this, l);
    };
    window.MediaSource && (window.MediaSource.prototype.addSourceBuffer = h), window.ManagedMediaSource && (window.ManagedMediaSource.prototype.addSourceBuffer = h);
    const b = w.isTypeSupported, A = function(l) {
      return l === Qc || l === Jc ? !0 : b(l);
    };
    window.MediaSource && (window.MediaSource.isTypeSupported = A), window.ManagedMediaSource && (window.ManagedMediaSource.isTypeSupported = A);
  }
  onVideoResolutionChange() {
    const {
      logger: t,
      video: { videoWidth: r, videoHeight: c }
    } = this;
    t.debug(`Video resolution changed to ${r}x${c}`);
  }
  update() {
    const { fpsMeter: t } = this;
    t && t.tickStart(), this.updateVideo(), t && t.tick();
  }
  updateVideo() {
    const {
      canvas: t,
      options: { displayTimecodeInDebugCanvas: r },
      logger: c,
      video: w,
      meshSourceBuffer: R,
      qualityManager: L,
      mesh: h,
      playbackManager: b,
      previousVideoWidth: A,
      previousVideoHeight: l
    } = this;
    if (!this.isInitialized)
      return;
    if (!w || !R || !R._isInitialized) {
      c.debug(
        "Cannot update video: no video or source buffer not initialized."
      );
      return;
    }
    const o = [], u = w.currentTime, { readyState: g, videoWidth: m, videoHeight: S } = w;
    (A !== m || l !== S) && (this.onVideoResolutionChange(), this.previousVideoWidth = m, this.previousVideoHeight = S, c.silly(
      `Updating buffer size in DashPlayer to ${m}x${S}`
    ), b.updateBufferSize(m, S));
    let e;
    if (t && (t.width = Ou, t.height = Yu, e = t.getContext("2d"), e)) {
      e.fillStyle = "#222222", e.fillRect(0, 0, Ou, Yu), e.fillStyle = "#ffffff";
      const pt = [];
      for (const et in L.currentRepresentations)
        et !== tm && pt.push(
          `${et}: ${L.currentRepresentations[et]}`
        );
      const It = pt.join(", ");
      It && o.push(It), o.push(`${L.fps} FPS`), o.push(
        `${Ju(R.bytesReceived)} received`
      );
    }
    if (g < w.HAVE_ENOUGH_DATA) {
      t && o.push("Not enough data"), c.debug(`Not enough data - video ready state: ${g}`);
      return;
    }
    if (m <= Zc || S <= Zc) {
      t && o.push("Video too small"), c.debug(`Video too small: ${m}x${S}`);
      return;
    }
    if (t && (b.state !== Gs && b.state !== kl && b.state !== Tm ? o.push(
      `Mismatching playback state: ${b.state}`
    ) : o.push(`playback state: ${b.state}`)), !b.checkPlayback(u)) {
      t && o.push("NO MESH AVAILABLE AT TIME"), b.pause();
      return;
    }
    if (this.copyVideoToStagingTexture(), this.processTimecode(m), t && e && r) {
      const pt = Ou - yr * ba, [It, et, Dt] = Em(m), ae = e.createImageData(
        et,
        Dt
      );
      ae.data.set(b.timecodeBuffer), e.putImageData(ae, pt, 0);
      let St = "";
      for (let qe = 0, zt = 0; qe < ba; ++qe) {
        const Ct = qe * yr + (yr >> 1), de = Fu >> 1;
        ae.data[zt] < 127 ? (e.fillStyle = "black", St += "0") : (e.fillStyle = "white", St += "1"), e.fillRect(
          pt + (Ct - Tl / 2),
          de - Tl / 2,
          Tl,
          Tl
        ), zt += $s * yr;
      }
      e.fillStyle = "#ffffff", e.fillText(
        `${St}`,
        pt,
        Fu + 12
      );
    }
    const d = b.process(), { timescale: _, frameDuration: p } = R, P = u * _, ot = Math.floor(P / p) * p / p, dt = Math.floor(ot / vo) * vo;
    t && o.push(`timecodeFrame: ${d}`);
    let xt = dt + d;
    ot - xt > nh ? xt = xt + vo : xt - ot > nh && (xt = xt - vo), t && e && (e.fillStyle = "#ffffff", o.push(`wrapped frame: ${xt}`));
    const Nt = (pt) => {
      if (!this.canvas) return;
      const It = this.canvas.getContext("2d");
      if (!It) {
        c.warn("Canvas context not found");
        return;
      }
      let et = 12;
      const Dt = Fu;
      for (const ae of pt)
        It.fillText(ae, 8, et), et += Dt;
    }, jt = R.getFrame(xt);
    let q = !1;
    if (jt || (t && o.push("MISS"), c.debug(
      `Could not find sample at frame: ${xt}, current time: ${u}`
    ), w.paused || b.pause(), q = !0), q) {
      t && o.push("MISS (fix: time)"), Nt(o);
      return;
    }
    this.lastFrame = xt;
    const { geometry: I } = jt;
    h.geometry.dispose(), h.geometry = I, h.visible || (h.visible = !0), this.isRendering || (c.silly(
      `Initial sample can be rendered at frame: ${xt}, current time: ${u}`
    ), this.isRendering = !0, this.dispatchEvent(UE())), Nt(o), this.updateRenderTexture();
  }
}
typeof window < "u" && (window.DashPlayer = nv, window.DashPlayerWebGLImplementation = tv);
export {
  xr as B,
  gs as C,
  iv as D,
  lv as I,
  Ay as L,
  dv as M,
  lm as N,
  ki as P,
  xo as Q,
  sm as R,
  Qy as S,
  un as V,
  hv as a,
  xy as b,
  Br as c,
  cv as d,
  uv as e,
  rv as f,
  av as g,
  sv as h,
  ov as i,
  Sy as j,
  il as k,
  uh as l,
  dh as m,
  kr as n,
  Tl as o,
  nv as p,
  tv as q
};
